<?xml version="1.0" encoding="utf-8"?>
<doc>
  <members>
  </members>
  <AdsSQLServer>
    <summary>ADS Compatible DbServer class that received a Sql Select statement in its constructor</summary>
  </AdsSQLServer>
  <AdsSQLServer.ctor>
    <inheritdoc />
  </AdsSQLServer.ctor>
  <DbError>
    <exclude />
  </DbError>
  <DbError.ctor>
    <exclude />
  </DbError.ctor>
  <DbError.Throw>
    <exclude />
  </DbError.Throw>
  <DbFileSpec>
    <summary>
      Hold the file name and path for a .DBF file and provide DBF-related functions, such as creating, copying, deleting, moving, and renaming files.
    </summary>
    <remarks>
      A FileSpec is a general purpose object that holds the file name and path of a file. The DBFileSpec subclass is intended specifically for holding information about a DBF file.
      The FileSpec class does not contain any methods for reading or writing the file, however you can in fact create a DBF structure with this class; it is limited to directory-level properties such as size, date and time changed and operations such as delete and rename. The DBFileSpec adds two operations that apply to DBF files only: reading the record layout through DBFileSpec:DBStruct and creating a file given a record layout through DBFileSpec:Create().
      Note that a DBServer object opens an existing file on instantiation; it requires that the file exists, so it cannot be used to create a DBF file. DBFileSpec:Create() is the ideal method for creating a DBF file.
      DBStruct is available as a access method of the DBServer class, but instantiating a DBServer is an unnecessary complex way of reading a file header. DBFileSpec:DBStruct is a simpler way of getting the record layout.
    </remarks>
    <example>
      The two methods may be used together, in concert with the path manipulation methods of the FileSpec class.
      For example, to create in the corresponding directory on a different drive a new file with the same record layout as an existing file, you might do something like this:
      <code language="X#">
        oDBFileSpec := DBFileSpec{"c:\data\custdata.dbf"}
        IF oDBFileSpec:Find()		// File exists?
        aDBStruct := oDBFileSpec:DBStruct
        oDBFileSpec:Drive := "d:"
        oDBFileSpec:Create(aDBStruct)
        ENDIF
      </code>
    </example>
  </DbFileSpec>
  <DbFileSpec.ctor>
    <summary>
      Instantiates a DBFileSpec object and fills its instance variables with DBF information.
    </summary>
    <param name="cFullPath">The drive, path and file name of the DBF file.</param>
    <param name="oFS">The drive, path and file name of the DBF file.</param>
    <param name="cDriver">The RDD used to instantiate the DBFileSpec.</param>
    <param name="_aRDDs">The 1-D array of 'hidden' RDDs required to open a DBF file, such as DBFMEMO.</param>
    <returns>
      A DBFileSpec object.
    </returns>
    <example>
      <code language="X#">
        oDB1 := DBFileSpec{ "C:\TEST\TEST.DBF" }
        oDB2 := DBFileSpec{}
        oDB2:FullPath := "C:\TEST\TEST.DBF"
      </code>
    </example>
  </DbFileSpec.ctor>
  <DbFileSpec.Copy>
    <summary>
      Copies all files associated with DBFileSpec objects to a different drive and/or directory.
    </summary>
    <param name="oDBFSTarget">The DBFileSpec object's target directory. Can be either optional or full path.</param>
    <param name="lIDX">Logical parameter. TRUE also moves any index files associated with SELF. The default is TRUE.</param>
    <param name="lName">Logical parameter. TRUE causes an auto-rename of the target file if a file conflict occurs during the copy. The default is FALSE. </param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <example>
      <code language="X#">
        // Copy the CUSTOMER.DBF file to C:\TEST directory:
        SetDefault( "C:\CAVOxx\SAMPLES\GSTUTOR" )
        oDB := DBFileSpec{}
        oDB:FileName := "CUSTOMER"
        IF oDB:Find()
        oDB:Copy( "C:\TEST\" )
        ENDIF
        // Copy using FileSpec object
        // Copy CUSTOMER.DBF file to C:\TEST\COPY\DBFS directory:
        // Copy the TEST.DBF file to C:\TEST directory:
        SetDefault( "C:\CAVOxx\SAMPLES\GSTUTOR" )
        oFS := FileSpec{ "C:\TEST\" }
        oDB := DBFileSpec{}
        oDB:FileName := "CUSTOMER"
        IF oDB:Find()
        oDB:Copy( oFS )
        ENDIF
      </code>
    </example>
  </DbFileSpec.Copy>
  <DbFileSpec.CopyTo>
    <summary>
      Copies the DBFileSpec object's DBF file to another data format. This can be used for copying out to another RDD, to a delimited file, or to an SDF file.
    </summary>
    <param name="oFS">The drive and directory into which to copy SELF's files. Can also be an existing DBFileSpec object or FileSpec object.</param>
    <param name="cDriver">The target file's RDD.</param>
    <param name="lWantAnsi">Logical parameter. TRUE creates the target file in ANSI format. The default is the source DBFileSpec's ANSI setting.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <example>
      The following examples illustrate copying a DBF file to different data formats:
      <code language="X#">
        // Export the records of CUSTOMER.DBF/DBT file to various formats:
        SetDefault( "C:\CAVOxx\SAMPLES\SSATUTOR" )
        oDB := DBFileSpec{}
        oDB:FileName := "CUSTOMER"
        IF oDB:Find()
        // copy out to DBF/FPT
        oDB:CopyTo( "cust_CDX", "DBFCDX" )
        // copy out to a delimited file
        oDB:Delim := ","
        oDB:CopyTo( "cust_DEL" )
        oDB:Delim := NULL_STRING
        // copy out to an SDF file
        oDB:SDF := TRUE
        oDB:CopyTo( "cust_SDF" )
        oDB:SDF := FALSE
        // copy out to a DBF/DBV file
        oDB:HidRDDs := { "DBFMEMO" }
        oDB:CopyTo( "cust_DBV" )
        oDB:HidRDDs := {}
        ENDIF
      </code>
    </example>
  </DbFileSpec.CopyTo>
  <DbFileSpec.Create>
    <summary>
      Create a new DBF file with the given name, using a provided DBStruct array.
    </summary>
    <param name="cFullPath">The file name for the new DBF and optional path or FileSpec object.</param>
    <param name="aDbStruct">The layout of the DBF to be created with each field represented by a subarray containing the field name, the type, the length, the decimals, and the alias in the DBStruct() format if different from SELF's DBF file structure.</param>
    <param name="cDriver">The RDD used to create the new DBF file structure if different from SELF's.</param>
    <param name="lWantAnsi">TRUE if this new DBF is to be an ANSI DBF (default). </param>
    <param name="aRdds">The 1-D array of 'hidden' RDDs required to open a DBF file, such as DBFMEMO. Defaults to SELF's.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      The DBFileSpec:Create() method is useful for generating a new DBF file given a file specification and path. The DBCreate() function is also useful to do the same thing, however this approach is more efficient.
      Note that the DBServer class does not contain a Create() method: instantiating a DBServer requires that the file exists already, so one cannot be created. The CopyDB() and CopyStructure() methods of the DBServer class often provide an easier way of copying the structure, completely or partially, of an existing file.
      Note that the method does not open the file.
    </remarks>
    <example>
      <code language="X#">
        aDBF := { { "FLD1_C", "C", 10, 0 }, { "FLD2_N", "N", 10, 2 }, { "FLD3_D", "D", 8, 0 }, ;
        { "FLD4_L", "L", 1, 0 }, { "FLD5_M", "M", 10, 0 } }
        aRDD := { "DBFMEMO" }
        cSomePath	:= WorkDir{} + "data\"
        SetDefault( "C:\TEST" )
        oDB := DBFileSpec{}
        // create a DBF/DBV file
        oDB:Create( "NewFile1", aDBF, "DBFNTX", TRUE, aRDD )
        // create a DBF/FPT file to a different folder
        oDB:Create( cSomePath + "NewFile2", aDBF, "DBFCDX", TRUE )
      </code>
    </example>
  </DbFileSpec.Create>
  <DbFileSpec.DBFAttr>
    <summary>
      The DBF file attributes returned as a string type.
    </summary>
    <value>The DBF file attributes returned as a string type.</value>
  </DbFileSpec.DBFAttr>
  <DbFileSpec.DBFDateChanged>
    <summary>
      The DBF file date stamp returned as a date type.
    </summary>
    <value>The DBF file date stamp returned as a date type.</value>
  </DbFileSpec.DBFDateChanged>
  <DbFileSpec.DBFName>
    <summary>
      The DBF file name and extension.
    </summary>
    <value>The DBF file name and extension.</value>
  </DbFileSpec.DBFName>
  <DbFileSpec.DBFSGetInfo>
    <summary>
      Fills in the DBFileSpec object's instance variables. This method is not required when using the Find() method, which will invoke this method internally if the file is found.
    </summary>
    <param name="xRDDs">The RDD used to open the target file defined in the DBFileSpec object.</param>
    <param name="xRdds">The RDD used to open the target file defined in the DBFileSpec object.</param>
    <param name="aHidden">The 1-D Array of 'hidden' RDDs required for target file defined in the DBFileSpec object.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <example>
      <code language="X#">
        oDB := DBFileSpec{}
        // path to existing DBF file
        oDB:FullPath := "C:\TEST\CUSTOMER.DBF"
        IF !oDB:DBFSGetInfo()
        MessageBox( 0, "an error occurred", "", 0 )
        ENDIF
      </code>
    </example>
  </DbFileSpec.DBFSGetInfo>
  <DbFileSpec.DBFSize>
    <summary>
      The DBF file size.
    </summary>
    <value>The DBF file size.</value>
  </DbFileSpec.DBFSize>
  <DbFileSpec.DBFTime>
    <summary>
      The DBF file time stamp returned as a string.
    </summary>
    <value>The DBF file time stamp returned as a string.</value>
  </DbFileSpec.DBFTime>
  <DbFileSpec.DbStruct>
    <summary>
      Returns an array containing the structure of the DBF file.
    </summary>
    <value>An array containing the structure of the DBF file.</value>
    <remarks>
      Returns an array containing the structure of the DBF file.
      The structure of the current database file in an array whose length is equal to 
      the number of fields in the database file. 
      Each element of the array is a subarray containing information for one field. 
      The subarrays have the following format:
      <include file="RTComments.xml" path="Comments/DbStruct_Constants/*"  />
  </remarks>
  </DbFileSpec.DbStruct>
  <DbFileSpec.Delete>
    <summary>
      Physically deletes all files that are associated with the DBFileSpec object, including memo files and any index files associated with the DBF through OrderSpec objects.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <example>
      <code language="X#">
        oDB := DBFileSpec{ "C:\TEST\DELETE\STRING\TEST.DBF" }
        oDB:Delete( )
      </code>
    </example>
  </DbFileSpec.Delete>
  <DbFileSpec.Delim>
    <summary>
      Access the delimiter used for the CopyTo() method.
    </summary>
    <value>Access the delimiter used for the CopyTo() method.</value>
  </DbFileSpec.Delim>
  <DbFileSpec.FCount>
    <summary>
      The number of fields in the DBF file.
    </summary>
    <value>The number of fields in the DBF file.</value>
  </DbFileSpec.FCount>
  <DbFileSpec.Fields>
    <summary>
      The 1-D array of DBF fields to copy out to when using the CopyTo() method.
    </summary>
    <value>The 1-D array of DBF fields to copy out to when using the CopyTo() method.</value>
  </DbFileSpec.Fields>
  <DbFileSpec.FileName>
    <summary>
      Assign a file name to the DBFileSpec object.
    </summary>
    <value>Assign a file name to the DBFileSpec object.</value>
  </DbFileSpec.FileName>
  <DbFileSpec.Find>
    <summary>
      Locates the file defined in the DBFileSpec object using the current directory, SetDefault(), or SetPath(). Fills in the instance variables of the DBFileSpec if successful.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <example>
      <code language="X#">
        // find the DBF
        SetDefault( "C:\CAVOxx\SAMPLES\GSTUTOR" )
        oDB := DBFileSpec{}
        oDB:FileName := "CUSTOMER"
        IF oDB:Find()
        &lt;execute some code&gt;
        ENDIF
      </code>
    </example>
  </DbFileSpec.Find>
  <DbFileSpec.ForBlock>
    <summary>
      The FOR condition code block used for the CopyTo() method.
    </summary>
    <value>The FOR condition code block used for the CopyTo() method.</value>
  </DbFileSpec.ForBlock>
  <DbFileSpec.FullPath>
    <summary>
      Assign a full path—including drive, directory, file name, and extension—to the DBFileSpec object.
    </summary>
    <value>Assign a full path—including drive, directory, file name, and extension—to the DBFileSpec object.</value>
  </DbFileSpec.FullPath>
  <DbFileSpec.HeaderSize>
    <summary>
      The size of the DBF file header.
    </summary>
    <value>The size of the DBF file header.</value>
  </DbFileSpec.HeaderSize>
  <DbFileSpec.HidRDDs>
    <summary>
      The 1-D array of "hidden" RDDs (i.e., DBFMEMO) used for the CopyTo() method.
    </summary>
    <value>The 1-D array of "hidden" RDDs (i.e., DBFMEMO) used for the CopyTo() method.</value>
  </DbFileSpec.HidRDDs>
  <DbFileSpec.IndexNames>
    <summary>
      The 1-D array of index files with drive, path, file name, and extension information.
    </summary>
    <value>The 1-D array of index files with drive, path, file name, and extension information.</value>
    <remarks>
      <note type="tip">It is not required to assign this array when using the OrderSpec:OrderCreate() and OrderSpec:OrderAdd() methods.</note>
    </remarks>
  </DbFileSpec.IndexNames>
  <DbFileSpec.IsAnsi>
    <summary>
      The ANSI/OEM setting used in the DBF file header.
    </summary>
    <value>The ANSI/OEM setting used in the DBF file header.</value>
  </DbFileSpec.IsAnsi>
  <DbFileSpec.LastUpDate>
    <summary>
      The date of the last update made to the DBF file as reported in the DBF header.
    </summary>
    <value>The date of the last update made to the DBF file as reported in the DBF header.</value>
  </DbFileSpec.LastUpDate>
  <DbFileSpec.MemAttr>
    <summary>
      The memo file attributes.
    </summary>
    <value>The memo file attributes.</value>
  </DbFileSpec.MemAttr>
  <DbFileSpec.MemBlockSize>
    <summary>
      The memo block size used in the memo file.
    </summary>
    <value>The memo block size used in the memo file.</value>
  </DbFileSpec.MemBlockSize>
  <DbFileSpec.MemDateChanged>
    <summary>
      The memo file date stamp returned as a date type.
    </summary>
    <value>The memo file date stamp returned as a date type.</value>
  </DbFileSpec.MemDateChanged>
  <DbFileSpec.MemFileExt>
    <summary>
      The memo file name extension excluding the file name.
    </summary>
    <value>The memo file name extension excluding the file name.</value>
  </DbFileSpec.MemFileExt>
  <DbFileSpec.MemFileName>
    <summary>
      The base memo file name excluding the file name extension.
    </summary>
    <value>The base memo file name excluding the file name extension.</value>
  </DbFileSpec.MemFileName>
  <DbFileSpec.MemFullPath>
    <summary>
      The full path of the memo file, including drive, directory, file name, and extension.
    </summary>
    <value>The full path of the memo file, including drive, directory, file name, and extension.</value>
  </DbFileSpec.MemFullPath>
  <DbFileSpec.MemName>
    <summary>
      The memo file name and extension.
    </summary>
    <value>The memo file name and extension.</value>
  </DbFileSpec.MemName>
  <DbFileSpec.MemSize>
    <summary>
      The memo file size.
    </summary>
    <value>The memo file size.</value>
  </DbFileSpec.MemSize>
  <DbFileSpec.MemTime>
    <summary>
      The memo file time stamp returned as a string.
    </summary>
    <value>The memo file time stamp returned as a string.</value>
  </DbFileSpec.MemTime>
  <DbFileSpec.Move>
    <summary>
      Moves and/or renames all files associated with DBFileSpec objects to a different drive and/or directory. Updates DBFileSpec and/or OrderSpec instance variables. Will also rename auto-open index files. Only DBF, MEMO and auto-open index files will get renamed.
    </summary>
    <param name="oDBFSTarget">The drive and directory to move SELF's files into. Can also be an existing DBFileSpec object.</param>
    <param name="lIDX">Logical parameter. TRUE also moves any index files associated with SELF. The default is TRUE.</param>
    <param name="lName">Logical parameter. TRUE causes an auto-rename of the target file if a file conflict occurs during the move. The default is FALSE. </param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <example>
      <code language="X#">
        // Move the CUSTOMER.DBF file to C:\TEST directory:
        SetDefault("C:\CAVO25\SAMPLES\GSTUTOR")
        oDB := DBFileSpec{ }
        oDB:FileName := "customer"
        IF oDB:Find()
        oDB:Move("C:\TEST\")
        ENDIF
        // Move using FileSpec object
        // Move the CUSTOMER.DBF file to C:\TEST directory:
        SetDefault("C:\CAVO25\SAMPLES\GSTUTOR")
        oFS := FileSpec{"C:\TEST\"}
        oDB := DBFileSpec{ }
        oDB:FileName := "customer"
        IF oDB:Find()
        oDB:Move(oFS)
        ENDIF
        // Move the CUSTOMER.DBF file to C:\TEST directory and rename:
        SetDefault("C:\CAVO25\SAMPLES\GSTUTOR")
        oDB := DBFileSpec{ }
        oDB:FileName := "customer"
        IF oDB:Find()
        oDB:Move("C:\TEST\NewFile")
        ENDIF
      </code>
    </example>
  </DbFileSpec.Move>
  <DbFileSpec.Orders>
    <summary>
      The 1-D array of OrderSpec objects that are associated with this DBFileSpec object.
    </summary>
    <value>The 1-D array of OrderSpec objects that are associated with this DBFileSpec object.</value>
    <remarks>
      <note type="tip">It is not required to assign this array when using OrderSpec:OrderCreate() and OrderSpec:OrderAdd() methods.</note>
    </remarks>
  </DbFileSpec.Orders>
  <DbFileSpec.RDD_Name>
    <summary>
      The name of the RDD used for instantiation.
    </summary>
    <value>The name of the RDD used for instantiation.</value>
  </DbFileSpec.RDD_Name>
  <DbFileSpec.RDD_Version>
    <summary>
      The version number of the RDD.
    </summary>
    <value>The version number of the RDD.</value>
  </DbFileSpec.RDD_Version>
  <DbFileSpec.RDDs>
    <summary>
      An array of "hidden" RDDs (such as DBFMEMO) used for instantiation.
    </summary>
    <value>An array of "hidden" RDDs (such as DBFMEMO) used for instantiation.</value>
  </DbFileSpec.RDDs>
  <DbFileSpec.RecCount>
    <summary>
      The number of records in the DBF. (Note that "LastRec" is not available in this class, only in the dbServer class)
    </summary>
    <value>The number of records in the DBF. (Note that "LastRec" is not available in this class, only in the dbServer class)</value>
  </DbFileSpec.RecCount>
  <DbFileSpec.Recno>
    <summary>
      The record number for the CopyTo() method when a single record is required.
    </summary>
    <value>The record number for the CopyTo() method when a single record is required.</value>
  </DbFileSpec.Recno>
  <DbFileSpec.Records>
    <summary>
      The number of records for the CopyTo() method.
    </summary>
    <value>The number of records for the CopyTo() method.</value>
  </DbFileSpec.Records>
  <DbFileSpec.RecSize>
    <summary>
      The record size of the DBF.
    </summary>
    <value>The record size of the DBF.</value>
  </DbFileSpec.RecSize>
  <DbFileSpec.Rename>
    <summary>
      Renames files associated with DBFileSpec object. Only DBF/MEMO and auto-open index files will get renamed.
      Rename() will not rename a file if it is already open or there is a file name conflict.
      To rename files to another directory, use the Move() method and supply a different target file name.
    </summary>
    <param name="oDBFSNewName">The new name for the DBF file.</param>
    <param name="lName">Logical parameter. TRUE causes an auto-rename of the target file if a file conflict occurs during the move. The default is FALSE. </param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <example>
      <code language="X#">
        SetDefault("C:\CAVO2x\SAMPLES\GSTUTOR")
        oDB := DBFileSpec{ }
        oDB:FileName := "customer"
        IF oDB:Find()
        IF !oDB:Rename("NewFile", TRUE )
        // Did not work, so let the user know…
        ENDIF
        ENDIF
      </code>
    </example>
  </DbFileSpec.Rename>
  <DbFileSpec.Rest>
    <summary>
      A logical determining if the CopyTo() method is to copy all records or the current record to EOF.
    </summary>
    <value>A logical determining if the CopyTo() method is to copy all records or the current record to EOF.</value>
  </DbFileSpec.Rest>
  <DbFileSpec.RLockCount>
    <summary>
      The number of locked records in the DBF.
    </summary>
    <value>The number of locked records in the DBF.</value>
  </DbFileSpec.RLockCount>
  <DbFileSpec.SDF>
    <summary>
      A logical determining if the CopyTo() method is to copy out to an SDF file.
    </summary>
    <value>A logical determining if the CopyTo() method is to copy out to an SDF file.</value>
  </DbFileSpec.SDF>
  <DbFileSpec.WhileBlock>
    <summary>
      A WHILE condition code block used with the CopyTo() method.
    </summary>
    <value>A WHILE condition code block used with the CopyTo() method.</value>
  </DbFileSpec.WhileBlock>
  <DBSelectionIndex>
    <exclude />
  </DBSelectionIndex>
  <DBSelectionIndex.ctor>
    <exclude />
  </DBSelectionIndex.ctor>
  <DBSelectionIndex.Eval>
    <exclude />
  </DBSelectionIndex.Eval>
  <DbServer>
    <summary>
      Create a data server that can operate with existing .DBF database files and their associated index files.
    </summary>
    <examples>
      Once a DBF table is opened in a DBServer object, it can be manipulated through the methods of the DBServer class, several of which are shown in the following examples:
      <code language="X#">
        oDBCust := DBServer{"customer"}
        oDBCust:Skip(3)
        ? oDBCust:CustName
        oDBCust:CustNo := NewNumber
        oDBCust:GoTo(86)
        oDBCust:Delete()
        oDBCust:Append()
        oDBCust:Close()
      </code>

      The fields of the table can be considered as exported instance variables of the object. They can also be accessed through the FieldGet() and FieldPut() methods, with the field identified through a symbol, a string, or a number:
      <code language="X#">
        oDBCust := DBServer{"customer"}
        oDBCust:CustNo := 1234
        ? oDBCust:CustNo
        oDBCust:FieldPut(#CustNo, 1234)
        oDBCust:FieldPut("CustNo", 1234)
        oDBCust:FieldPut(1, 1234)
        ? oDBCust:FieldGet(#CustNo)
        ? oDBCust:FieldGet("CustNo")
        ? oDBCust:FieldGet(1)
      </code>
      (The fields are, of course, not real exported variables of the DBServer class. See "Objects, Classes, and Methods" in the Programmer's Guide  for a discussion of how these "virtual" exported variables are created using the NoIVarGet() and NoIVarPut() methods.)

      All the traditional database operations available through commands or functions are available as methods for the DBServer object. In general, they behave the same way, with two exceptions: expanded parameter types and general scope-setting.

      Whenever an operation requires the specification of a file, an alias, a work area, or a field, the methods accept an object of the corresponding class: a FileSpec object for a file, a DBServer object for an alias or a work area, or a DataField object for a field. These options allow a more consistent use of objects and all the benefits they convey. The new, object-oriented approach is not required: a file can be specified as either an object or a string, an alias as an object, string or symbol, fields as objects, strings, or symbols.

      The classical SetRelation() operation allows you to link to servers, so that a movement in the parent server causes an automatic movement in the child server. The prototypical situation is a relation between a customer server and an order server, to make the order server show the orders for the current customer:
      <code language="X#">
        oDBCust := DBServer{"customer"}
        oDBCust:SetIndex("custname")
        oDBOrder := DBServer{"order"}
        oDBOrder:SetIndex("ordcstno")
        oDBCust:SetRelation(oDBOrder,#CustNo)
      </code>
      After this relation is established, any movement in the parent of the relationship causes a corresponding repositioning of the client: moving to customer Jones positions the order database at the first of Jones's orders, if any. The DBServer:SetRelation() method works exactly the same as the corresponding command and function in traditional Xbase DML.
      However, this type of relation is not very helpful. The child database is positioned correctly at the beginning of the orders, but it is not limited at the end of the orders. Thus, the application that uses the server must continually check if it is still on the appropriate customer's orders. DBServer:SetFilter() is not very helpful, because if you skip past the last of the customer's orders, DBServer:Skip() continues to scan the file until it finds one that matches. This kind of behavior is particularly burdensome for general purpose tools like data windows, which have to express these tests in a general way while they provide for data browsing.
      This is where a selective relation is more valuable. If we establish a selective relation, all operations on the child server are restricted to those records that match. DBServer:GoTop(), DBServer:GoBottom(), DBServer:BOF, DBServer:EOF, and DBServer:Skip() act as if the only records that exist are those that match the relation. Specifically, if you try to skip past the last appropriate order, Skip() fails and returns an end-of-file condition. Similarly, if you try to GoTo() a record that doesn't match, GoTo() fails as if that record didn't exist and stays on the current record. And utilities like Eval(), Count(), Sum(), etc., by default apply only to the selection (although explicitly specified scopes are allowed to violate this restriction).
      <code language="X#">
        LOCAL aSum
        oDBCust := DBServer{"customer"}
        oDBCust:SetIndex("custname")
        oDBOrder := DBServer{"order"}
        oDBOrder:SetIndex("ordcstno")
        oDBCust:SetSelectiveRelation(oDBOrder,#CustNo)
        oDBCust:Seek("Jones")
        DO WHILE ! oDBOrder:EOF
        ? oDBOrder:OrderNumber
        ENDDO
        aSum := oDBOrder:Sum(#Charge)
        ? "Number of orders:",oDBOrder:RecCount
        ? "Total value:",oDBOrder:aSum[1]
      </code>
    </examples>
    <remarks>
      The following table lists the properties and methods that reflect the currently active selection:
      <list type="table">
        <listheader>
          <term>Method or Property</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>BOF</term>
          <description>Attempt to position before first record in selection.</description>
        </item>
        <item>
          <term>EOF</term>
          <description>Attempt to position after last record in selection.</description>
        </item>
        <item>
          <term>Found</term>
          <description>Indicates if a record is found within the selection only (after Seek(), Locate(), Continue())</description>
        </item>
        <item>
          <term>RecCount</term>
          <description>Returns number of records in selection (note that LastRec is not dependent on selection)</description>
        </item>
        <item>
          <term>Average()</term>
          <description>If no scope is specified, makes the calculation over the current selection instead of ALL records</description>
        </item>
        <item>
          <term>Continue()</term>
          <description>Limits the search to the current selection</description>
        </item>
        <item>
          <term>CopyDB(), CopySDF(), CopyDelimited() </term>
          <description>If no scope is specified, copies the current selection instead of ALL records</description>
        </item>
        <item>
          <term>Count()</term>
          <description>If no scope is specified, makes the calculation over the current selection instead of ALL records</description>
        </item>
        <item>
          <term>DeleteAll()</term>
          <description>Deletes all the records of the selection, instead of all records in the file</description>
        </item>
        <item>
          <term>Eval()</term>
          <description>If no scope is specified, evaluates the code block over the current selection instead of ALL records</description>
        </item>
        <item>
          <term>GetArray()</term>
          <description>Limits array to current selection</description>
        </item>
        <item>
          <term>GetLookupTable()</term>
          <description>Limits array to current selection</description>
        </item>
        <item>
          <term>GoTop()</term>
          <description>Goes to first record in selection</description>
        </item>
        <item>
          <term>GoTo()</term>
          <description>Fails if the record number is not within selection</description>
        </item>
        <item>
          <term>GoBottom()</term>
          <description>Goes to last record in selection</description>
        </item>
        <item>
          <term>Locate()</term>
          <description>Succeeds only if the record is found within the selection</description>
        </item>
        <item>
          <term>LockSelection()</term>
          <description>Locks all records in the current selection</description>
        </item>
        <item>
          <term>RecallAll()</term>
          <description>Recalls all the records of the selection, instead of all records in the file</description>
        </item>
        <item>
          <term>Replace()</term>
          <description>If no scope is specified, processes the current selection instead of ALL records</description>
        </item>
        <item>
          <term>Seek()</term>
          <description>Positions to the beginning of the current selection—only if the seek value is the same as the selection value; otherwise, positions to the last record of the file and set the EOF flag. (Softseek is ignored.)</description>
        </item>
        <item>
          <term>Skip()</term>
          <description>If the move would lead out of the selection: positions to the last record of the selection and sets the EOF flag or positions to the first record in the selection and sets the BOF flag, depending on the direction of the move.</description>
        </item>
        <item>
          <term>Sort(), Sum(), Total()</term>
          <description>If no scope is specified, processes the current selection instead of ALL records</description>
        </item>
      </list><note type="tip">
        The following methods are not subject to the limitations of an active selection:
        AppendDB(), AppendDelimited(), and AppendSDF(), because their scoping parameters apply to the source file, not to this server
        Delete(), because its default is this record rather than all
        Recall(), because its default is this record rather than all
      </note>

      Several Xbase database commands provide a number of options for specifying the scope of the operation through keywords: ALL, REST, NEXT <paramref name="nRecords" />, RECORD <paramref name="nRecord" />, as well as through FOR and WHILE clauses. The semantics of these clauses, and how they interact when several are specified, are described under "Using DBF Files" in the Programmer's Guide.
      The corresponding DBServer methods (like Average(), AppendDB(), CopyDB(), Sort(), Sum(), Total(), and others) allow the specification of a FOR clause, a WHILE clause and a scope as arguments in the invocation. In addition, it is possible to set up a "general server scope" using simple assigns (the corresponding accesses are also provided). This general scope applies whenever one of these bulk processing methods is invoked without an explicit scope. This approach can in many cases be more convenient.
      For example, to delete the next five records:
      <code language="X#">
        oDB:Scope := 5			// NEXT 5 records
        oDB:Delete()
        oDB:Scope := NIL		// Don't forget to reset the scope!
      </code>
      For example, to delete all the remaining records:
      <code language="X#">
        oDB:Scope := DBScopeRest		// REST
        oDB:Delete()
        oDB:Scope := NIL			// Don't forget to reset the scope!
      </code>
      To count the number of Smiths in New Jersey:
      <code language="X#">
        oDBCust:SetOrder("CustomerName")	// ORDER by name
        oDBCust:Seek("Smith")			// FIND first Smith
        oDBCust:WhileBlock := {||CustomerName = "Smith"}
        // WHILE still on the Smiths...
        oDBCust:ForBlock := {||State = "NJ"}	// FOR 									// customers
        // in NJ...
        Tally := oDBCust:Count()			// COUNT 'em!
        oDBCust:ClearScope()			// RESET everything
      </code>
      Remember to restore the scope afterwards: the scope is persistent and applies to all following scope-based methods until reset. The convenience of this style of specifying a scope comes with the danger of leaving it active for too long. The scope can be reset with the DBServer:ClearScope() method, or by assigning NIL to the individual components.
      The general server scope can be set with:
      Property 	Meaning
      ForBlock	A string or codeblock specifying the FOR condition.
      Scope	DBSCOPEALL, DBSCOPEREST or a number <paramref name="nRecords" /> (meaning NEXT <paramref name="nRecords" />).
      WhileBlock	A string or codeblock specifying the WHILE condition.
      Note that there is no provision for specifying a specific record number with this approach. There is rarely a need to process a specific record (e.g., the average of the salary of record 5). In cases where there is, such as for Delete(), use RecNo := <paramref name="n" />, GoTo(<paramref name="n" />) or Seek(<paramref name="Value" />) to position the server, and then invoke Delete().
      The methods that are subject to the general server scope are:
      <list type="table">
        <listheader>
          <term>Method Name</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>AppendDB()</term>
          <description>Append records from DBF.</description>
        </item>
        <item>
          <term>AppendDelimited()</term>
          <description>Append records from delimited file.</description>
        </item>
        <item>
          <term>AppendSDF()</term>
          <description>Append records from SDF file.</description>
        </item>
        <item>
          <term>Average()</term>
          <description>Calculate average of expressions.</description>
        </item>
        <item>
          <term>CopyDB()</term>
          <description>Copy records to DBF.</description>
        </item>
        <item>
          <term>CopyDelimited()</term>
          <description>Copy records to delimited file.</description>
        </item>
        <item>
          <term>CopySDF()</term>
          <description>Copy records to SDF file.</description>
        </item>
        <item>
          <term>Count()</term>
          <description>Count how many records match.</description>
        </item>
        <item>
          <term>Delete()</term>
          <description>Delete records.</description>
        </item>
        <item>
          <term>Eval()</term>
          <description>Evaluate code block for each record.</description>
        </item>
        <item>
          <term>Join()</term>
          <description>Join with another DBF, write to DBF.</description>
        </item>
        <item>
          <term>Locate()</term>
          <description>Find record that matches conditions.</description>
        </item>
        <item>
          <term>Recall()</term>
          <description>Recall deleted records.</description>
        </item>
        <item>
          <term>Replace()</term>
          <description>Replace values with data from DBF.</description>
        </item>
        <item>
          <term>Sort()</term>
          <description>Sort records to a DBF.</description>
        </item>
        <item>
          <term>Sum()</term>
          <description>Calculate sums of expressions.</description>
        </item>
        <item>
          <term>Total()</term>
          <description>Summarize fields to a DBF.</description>
        </item>
      </list>
      The default scope is, of course, "no scope," so these methods have the same default behavior as the corresponding commands and functions. Most of them process all records or all remaining records, depending on how the scope is defined; those for which the default is "the current record" also have corresponding "all" methods:
      <list type="table">
        <listheader>
          <term>Method Name</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>Delete()</term>
          <description>Delete current record.</description>
        </item>
        <item>
          <term>DeleteAll()</term>
          <description>Delete all records.</description>
        </item>
        <item>
          <term>Recall()</term>
          <description>Recall current record.</description>
        </item>
        <item>
          <term>RecallAll()</term>
          <description>Recall all records.</description>
        </item>
      </list>
      But note that if a selective relation has been specified, the default source scope is the selection, not the entire file. Thus, we have four levels of inheritance with regard to the scope of an operation:
      1.	The scope that explicitly specified through arguments of the call
      2.	If none was provided, the scope that is set through the ForBlock, WhileBlock and Scope properties
      3.	If none was set, the selection specified with the selective relation
      4.	If no selective relation is active, the entire file
      The exceptions Delete() and Recall() use options 1 and 2, then default to the current record. DeleteAll() and RecallAll() apply to the current selection, if any; otherwise, to the entire file. Of course, a selection scope is not relevant to the Append... methods, for which the conditions apply to the source file, not this server.

      The DBServer Editor generates a subclass of the generic DBServer class, one with specific information such as file names and virtual fields created as access/assign methods.

      It is not possible to use the DBServer class to create a database file; the file must exist before a server can be opened on it. To create a database file, use the DBCreate() (recommended) method, the VODBCreate() function, or the DBServer Editor.

      This section describes the shared access and aliasing mechanisms used when creating multiple DBServer work areas or servers, as well as hybrid object/procedural operation.

      Work area
      Creating a DBServer object opens a database in a work area. There is no provision for specifying whether a new or existing work area should be used; the DBServer always uses a new work area.

      After the instantiation, the new work area is not selected; the work area that was selected before the instantiation remains active. Thus, traditional database commands and functions issued after the instantiation of the DBServer does not apply to the newly opened database. The proper way to operate on the new DBServer is through its methods.
      Shared access
      Creating two DBServer objects on the same database file is equivalent to opening the same file in two different work areas. The two servers (work areas) each maintain its own position and record locks, and operate as two users sharing access to the same file.

      To allow creating two servers on the same database file (opening the same file in two work areas), they must, of course, be opened in shared mode; otherwise the second attempt produces a sharing violation. However, this does not raise an error condition, it simply stores an invalid status of the object. Use the DBServer:Status or DBServer:Used properties after the instantiation to verify if a file was successfully opened.

      Shared mode can be specified as an instantiation parameter (for example, SetExclusive(FALSE) in the Start() function) or as a system default (see DBServer:Init()).
      Alias
      When using the methods of the DBServer to work with the database, an alias is not needed; the DBServer object provides the handle by which the database is referenced. The alias has no role in operating with a DBServer object, but internally the system needs a unique alias for every work area.
      The DBServer automatically constructs a unique alias. If the file is not open in any other work area or server, it uses the file name as the alias in the traditional manner, but if the file is already open, it creates a unique alias by appending a number. Thus, opening the CUSTOMER file twice would produce the two aliases #Customer and #Customer_1.

      The only reason for explicitly using the alias is to perform "hybrid" operation, using traditional, procedural operations with commands or functions on a DBServer object. This practice is strongly discouraged, however. Because the DBServer object may not be aware of what is done through the commands, DBServer methods can malfunction after use of procedural commands. (For more details, see "Using DBF Files" in the Programmer's Guide.)
      It is possible to retrieve the automatically generated alias from the DBServer object, to enable selection of the work area as the focus of procedural database operations:
      <code language="X#">
        oDBCust := DBServer{"customer"}
        cCust := oDBCust:Alias
        SELECT (cCust)
        SKIP
        DELETE
        ? (cCust) -&gt; CustNo
      </code>

      Most of the changes we made in the RDD classes were made to improve the speed of the RDD classes. One change in particular could influence your application: in the old implementation Visual Objects was restoring the ‘current workarea’ after each DbServer:Method call. This is only useful if you are mixing Object Oriented DBF access with traditional work area oriented DBF access. If all you do is Object Oriented DBF access, the work area switching is unnecessary and may have a negative impact on your applications performance.
      Therefore we have added a switch to the RDD classes that allows you do enable/disable this restore mechanism. The default for Visual Objects 2.8 is to NOT restore the workarea. The switch is in the function:
      <code language="X#">DbSetRestoreWorkarea (lEnable)</code>
      This is a global switch, which changes the behaviour of the DBServer class.
      The default value of the lEnable switch is FALSE which means that workarea restoring is disabled. As a result of this at the end of each DbServer method the current workarea is the workarea of the DBServer.
      If you set the lEnable flag to TRUE every DBServer method restores the workarea at the end of the method to the value of the work area at the beginning of the method. This is the old behavior, but costs some extra time.
      The return value of DbSetRestoreWorkarea () is the previous value.
      If lEnable is NIL the switch is not set and SetRestoreWorkarea() returns only the current value.
      DbSetRestoreWorkarea () also changes the internal behaviour of the new internal function __DBSetSelect(siNew). If you call DbSetRestoreWorkarea (TRUE) which is the default __DBSetSelect() is identical to VODBSetSelect(), if you call DbSetRestoreWorkarea (FALSE) DBSetSelect() is empty and do nothing.

      <note type="tip">
        There have been some major changes in the DbServer class in VO 2.8. Please read the section on the bottom of this topic carefully if you are migrating from an older version of Visual Objects.
      </note>
    </remarks>
  </DbServer>
  <DbServer.LogicReturn>
    <returns>
      TRUE if successful; otherwise, FALSE (although some records still might have been processed).
    </returns>
  </DbServer.LogicReturn>
  <DbServer.FileNameClause>
    <span>
      This parameter identifies the DBF file that is to be opened.
      If a string is specified, it corresponds exactly to the file name parameter of the DBUseArea() function; it can contain a full path with drive and directories, or just a file name.
      If a FileSpec object is specified, its file name component is used as the file to open. It can also contain a full path with drive and directories, or just a file name.
      With either type of parameter, if only a file name is specified, the DBServer works the same way as the USE command or the DBUseArea() function with regard to default path—it is subject to SET PATH and SET DEFAULT, for example. The extension DBF is assumed by default.
      In either case, after the DBServer object has been successfully created, it contains a FileSpec object with the original file specification.
    </span>
  </DbServer.FileNameClause>
  <DbServer.ctor>
    <summary>
      Construct a server object.
    </summary>

    <param name="cFile">
      The name of the file to open<br/>
      <include file="Rdd.xml" path="doc/DbServer.FileNameClause/*" />
    </param>
    <param name="oFS">
      A FileSpec object with the name of the file to open<br/>
      <include file="Rdd.xml" path="doc/DbServer.FileNameClause/*" />
    </param>
    <param name="oFile">
      A String or a FileSpec object with the name of the file to open<br/>
      <include file="Rdd.xml" path="doc/DbServer.FileNameClause/*" />
    </param>
    <param name="lShareMode">Identifies whether the file should be opened in shared mode. Can be specified as a constant, DBSHARED (TRUE) or DBEXCLUSIVE (FALSE). If not specified, the default is determined by the SetExclusive() function, which in turn defaults to 'exclusive' or FALSE.</param>
    <param name="lReadOnlyMode">Identifies whether the file should be opened in read only mode. Can be specified as a constant, DBREADONLY (TRUE) DBREADWRITE (FALSE). If not specified, it defaults to read-write or FALSE.</param>
    <param name="xDriver">The driver can be specified. If not specified, it defaults to the driver specified by RDDSetDefault() which in turn defaults to DBFNTX.</param>
    <param name="aRDD">
      A one-dimensional array with the names of RDDs from which the main RDD inherits special functionality. This allows you to use RDDs with special capabilities, like encryption or decryption, for different data servers with different database drivers. These RDDs overlay special functions of the main RDD (specified with the <paramref name="cDriver" /> argument). If multiple RDDs (specified with this argument) implement the same function, the function associated with the last RDD in the list takes precedence. If <paramref name="aRdds" /> is omitted, no additional RDDs are assumed.
    </param>
    <param name="aParams">Optional array of parameter values</param>
    <returns>
      As with all Init() methods, the instantiation returns the object. An object is created even if the file was not successfully opened, perhaps because the file does not exist, is corrupted or is locked by another user. Thus, before using the DBServer error, verify that it was successfully opened with the DBServer:Used or Status access methods.
    </returns>
    <example>
      The following examples demonstrate several different methods of constructing a DBServer object:
      <code language="X#">
        // Specify only the DBF file
        oDBCust := DBServer{"CUSTOMER"}
        // Specify all four parameters
        oDBCust := DBServer{"CUSTOMER",DBSHARED,DBREADONLY, "DBFNTX"}
        // Use a FileSpec object specification to define the
        // DBF file to open (in "exclusive", read-write mode)
        oFSCust := FileSpec{"d:\data\customer"}
        oDBCust := DBServer{oFSCust,,FALSE}
      </code>
    </example>
  </DbServer.ctor>
  <DbServer.Alias>
    <summary>
      A string representing the alias of the work area.
    </summary>
    <value>A string representing the alias of the work area.</value>
    <remarks>
      A string representing the alias of the work area.
      <note type="tip">"Hybrid" operation, with procedural commands referencing a DBServer object, is strongly discouraged. See the discussion of hybrid operation under CLASS DBServer.</note>
    </remarks>
  </DbServer.Alias>
  <DbServer.AliasSym>
    <summary>
      A symbol representing the alias of a DBServer object.
    </summary>
    <value>A symbol representing the alias of a DBServer object.</value>
    <remarks>
      A symbol representing the alias of a DBServer object.
      <note type="tip">"Hybrid" operation, with procedural commands referencing a DBServer object, is strongly discouraged. See the discussion of hybrid operation under CLASS DBServer.</note>
    </remarks>
  </DbServer.AliasSym>
  <DbServer.Append>
    <summary>
      Append a blank record to the table; this blank record becomes the current position and is ready for assignment of data values. The record is automatically locked if the Append() method returns TRUE.
    </summary>
    <param name="lReleaseLocks">Indicates if existing record locks should be released.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      The default behavior is to release existing locks when a new record is appended.<br/>
      If you want to prevent this, you need to pass a parameter with the value FALSE.<br/>
      Sends a NotifyIntentToMove message before the operation.<br/>
      Sends a NotifyAppend message, if successful.<br/>
    </remarks>
  </DbServer.Append>
  <DbServer.AppendDB>
    <summary>
      Append new records to the table from another DBF file.
    </summary>
    <param name="oFSSource">
      A string or filespec object that specifies the source file, which is opened in shared, read-only mode, and can be open elsewhere in this or some other application.
      This function attempts to open <paramref name="oFSSource" /> in shared mode. If the file does not exist, a runtime error is raised. If the file is successfully opened, the operation proceeds. Refer to the 'Concurrency Control' chapter in the Programmer's Guide for more information on resolving concurrency conflicts.
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation.<br/>
      Sends a NotifyFileChange message, if any record was appended.<br/>
    </remarks>
  </DbServer.AppendDB>
  <DbServer.AppendDelimited>
    <summary>
      Append new records to the table from a delimited file, such as the "comma-separated-value" (CSV) file format.
    </summary>
    <param name="oFSSource">
      A string or filespec object that specifies the source file containing the records to be appended.
      The source file is opened in shared, read-only mode, and can be open elsewhere in this or some other application.
    </param>
    <param name="cDelimiter">The delimiter for fields within a delimited database file. If omitted, the default is NULL_STRING.</param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation.<br/>
      Sends a NotifyFileChange message, if any record was appended.<br/>
    </remarks>
  </DbServer.AppendDelimited>
  <DbServer.AppendSDF>
    <summary>
      Append new records to the table from an SDF-formatted file.
    </summary>
    <param name="oFSSource">
      A string or filespec object that specifies the source file containing the records to be appended.
      The source file is opened in shared, read-only mode, and can be open elsewhere in this or some other application.
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation.<br/>
      Sends a NotifyFileChange message, if any record was appended.<br/>
    </remarks>
  </DbServer.AppendSDF>
  <DbServer.Average>
    <summary>
      Calculate the average of a series of numeric expressions, based on the number of actual records involved.
    </summary>
    <param name="acbExpression">The single expression to be averaged or the array of expressions to be averaged.</param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      An array that contains the averages for each field or expression specified. If a single expression was specified, an array length of 1 is returned.
    </returns>
    <remarks>
      Sends a NotifyIntentToMove message before the operation.<br/>
      Sends a NotifyRecordChange message upon completion.<br/>
      The Average() method allows several averages to be calculated in one pass through the database.
      On successful completion, the current record will be the last file record and EOF will be TRUE.
    </remarks>
  </DbServer.Average>
  <DbServer.BLOBDirectExport>
    <summary>
      Export the contents of a binary large object (BLOB) pointer to a file.
    </summary>
    <param name="nPointer">
      A pointer to the BLOB data. This pointer can be obtained using DBServer:BLOBDirectPut(), DBServer:BLOBDirectExport(), or DBServer:FieldInfo(DBS_BLOB_POINTER, <paramref name="nFieldPos" />).
    </param>
    <param name="oFSTarget">
      A string or filespec object that specifies the name of the target file where the BLOB data will be written, including an optional drive, directory, and extension. See SetDefault() and SetPath() for file searching and creation rules. No default extension is assumed.
      If <paramref name="oFSTarget" />  does not exist, it is created. If it exists, this method attempts to open the file in exclusive mode and, if successful, the file is written to without warning or error. If access is denied because, for example, another process is using the file, NetErr() is set to TRUE and the data server's Status property is set.
    </param>
    <param name="cTarget">
      The name of the target file where the BLOB data will be written, including an optional drive, directory, and extension. See SetDefault() and SetPath() for file searching and creation rules. No default extension is assumed.
      If <paramref name="cTarget" /> does not exist, it is created. If it exists, this method attempts to open the file in exclusive mode and, if successful, the file is written to without warning or error. If access is denied because, for example, another process is using the file, NetErr() is set to TRUE and the data server's Status property is set.
    </param>
    <param name="kMode">
      A constant defining the copy mode, as shown in the table below:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>
            BLOB_EXPORT_APPEND
          </term>
          <description>Appends to the file</description>
        </item>
        <item>
          <term>
            BLOB_EXPORT_OVERWRITE
          </term>
          <description>Overwrites the file—this is the default</description>
        </item>
      </list>
    </param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">A BLOB file (.DBV or .FPT) is used for storing memo field information, as an alternative to the standard .DBT file mechanism supported by some RDDs. It is a more powerful and efficient mechanism for storing and retrieving large amounts of data than using .DBT files. X# supplies the DBFCDX driver, which uses the BLOB file storage mechanism by default, and the DBFBLOB driver, which you can use as an inherited driver with other RDDs. Refer to the "RDD Specifics" appendix in the Programmer's Guide for further information on using this driver.</note>
    </remarks>
    <example>
      This example extracts an array of pointers from the BLOB file's root area, then uses one of the pointers to export a picture to a file:
      <code language="X#">
        FUNCTION PutPix()
        LOCAL cPixFile AS STRING
        LOCAL nPointer
        LOCAL aBLOBPtrs AS ARRAY
        LOCAL oDBCust AS DBServer
        cPixFile := "picture.gif"
        // Customer data server with a picture of each
        // customer stored in a field called Pix
        oDBCust := Customer{}
        // Assumes that the program previously stored
        // an array of direct BLOB pointers into the root area of the BLOB file.
        // The picture that we want is assumed to be the second array element.
        aBLOBPtrs := BLOBRootGet()
        nPointer := aBLOBPtrs[2]
        // Export picture pointed to by nPointer to a file
        IF !oDBCust:BLOBDirectExport(nPointer, cPixFile, BLOB_EXPORT_OVERWRITE)
        Alert("Export of picture " + cPixFile + "failed!")
        ELSE
        // Code for displaying picture would go here
        ENDIF
      </code>
    </example>
  </DbServer.BLOBDirectExport>
  <DbServer.BLOBDirectGet>
    <summary>
      Retrieve data stored in a BLOB file without referencing a specific field.
    </summary>
    <param name="nPointer">
      A pointer to the BLOB data. This pointer can be obtained using DBServer:BLOBDirectPut(), DBServer:BLOBDirectImport(), or DBServer:FieldInfo(DBS_BLOB_POINTER, <paramref name="nFieldPos" />).
    </param>
    <param name="nStart">
      The starting position in <paramref name="nPointer" />. If <paramref name="nStart" /> is positive, the starting position is relative to the leftmost character in <paramref name="nPointer" />. If <paramref name="nStart" /> is negative, it is relative to the rightmost character in <paramref name="nPointer" />. If <paramref name="nStart" /> is omitted, it is assumed to be 1.
    </param>
    <param name="nCount">
      The number of bytes of data to retrieve, beginning at <paramref name="nStart" />. If <paramref name="nCount" /> is larger than the amount of data stored, excess data is ignored. If omitted, DBServer:BLOBDirectGet() retrieves to the end of the data.
    </param>
    <returns>
      The data retrieved from the BLOB file. The data type of the return value depends on the actual data stored. Use ValType() or UsualType() to determine the data type.
    </returns>
    <remarks>
      <note type="tip">
        <paramref name="nStart" /> and <paramref name="nCount" /> apply to string data only. They are ignored for any other data types.
      </note>
      DBServer:BLOBDirectGet() retrieves data stored in a BLOB file without the need to reference a particular field in the data server. It is particularly useful when accessing data that is larger than 64KB, (such as memo fields created with the BLOBImport() method).
    </remarks>
    <include file="RDD.xml" path="doc/DbServer.BLOBDirectExample/*" />
  </DbServer.BLOBDirectGet>
  <DbServer.BLOBDirectExample>
    <example>
      This example illustrates storing setup information in a BLOB file, then selectively retrieving the stored information:
      <code language="X#">
        FUNCTION PutSettings(aColors AS ARRAY,;
        aPaths AS ARRAY, aPW AS ARRAY) AS VOID
        LOCAL aSettings AS ARRAY
        LOCAL oDBSetup AS DBServer
        oDBSetup := Setup{}
        aSettings := {}
        AAdd(aSettings, oDBSetup:BLOBDirectPut(0, aColors))
        AAdd(aSettings, oDBSetup:BLOBDirectPut(0, aPaths))
        AAdd(aSettings, oDBSetup:BLOBDirectPut(0, aPW))
        oDBSetup:BLOBRootPut(aSettings)
        oDBSetup:Close()
        FUNCTION GetColors() AS ARRAY
        LOCAL aSettings AS ARRAY
        LOCAL aColors  AS ARRAY
        LOCAL oDBSetup AS DBServer
        oDBSetup := Setup{}
        aSettings := oDBSetup:BLOBRootGet()
        aColors := oDBSetup:BLOBDirectGet(aSettings[1])
        oDBSetup:Close()
        RETURN aColors
      </code>
    </example>
  </DbServer.BLOBDirectExample>

  <DbServer.BLOBDirectImport>
    <summary>
      Import a file into a BLOB file and return a pointer to the data.
    </summary>
    <param name="nPointer">
      A pointer to the BLOB data which will be released after the import. This pointer can be obtained using DBServer:BLOBDirectPut(), DBServer:BLOBDirectImport(), or DBServer:FieldInfo(DBS_BLOB_POINTER, <paramref name="nFieldPos" />). Passing 0 disables the release of data.
      <br />Important! If specified, DBServer:BLOBDirectImport() releases the space associated with <paramref name="nOldPointer" /> for reuse by other data. Therefore, it is illegal to use <paramref name="nOldPointer" /> with any of the BLOB methods after passing it as an argument to this method. Use the method's return value to refer to the newly stored data.
    </param>
    <param name="cSource">
      The name of the file from which to read the BLOB data, including an optional drive, directory, and extension.
      See SetDefault() and SetPath() for file searching and creation rules. No default extension is assumed.
    </param>
    <param name="oFSSource">
      A string or filespec object that specifies the name of the file from which to read the BLOB data, including an optional drive, directory, and extension.
      See SetDefault() and SetPath() for file searching and creation rules. No default extension is assumed.
    </param>
    <returns>
      A numeric pointer to the BLOB image stored in the source file.
    </returns>
    <remarks>
      This method attempts to openthe source file in shared mode. If the file does not exist, a runtime error is raised. If the file is successfully opened, the operation proceeds. If access is denied because, for example, another process has exclusive use of the file, NetErr() is set to TRUE and the data server's Status property is set. Refer to the 'Concurrency Control' chapter in the Programmer's Guide for more information on resolving concurrency conflicts.
      <note type="tip">There are no restrictions on the size of the source file except that you must have enough disk space to make the copy.</note>
      DBServer:BLOBDirectImport() provides a mechanism for copying the contents of a file into a BLOB file.
      DBServer:BLOBDirectImport() is used in conjunction with DBServer:BLOBDirectExport() to transfer data back and forth between external files and BLOB files. You can use DBServer:BLOBDirectImport() with a variety of file types, including graphics images, word processor files, and printer fonts. These two methods are excellent for creating databases of documents, graphics, sounds, and so on.
      <br />Important! After importing a file with DBServer:BLOBDirectImport(), nNewPointer, the return value, is the only way to access the data from the BLOB file. It is up to you, the developer, to provide permanent storage for this reference (see example below)
      <note type="tip">
        DBServer:FieldInfo(DBS_BLOB_TYPE, <paramref name="nFieldPos" />) will return "C" (string) for any memo field created using DBServer:BLOBDirectImport().
      </note>
    </remarks>
    <include file="RDD.xml" path="doc/DbServer.BLOBDirectExample/*" />
  </DbServer.BLOBDirectImport>
  <DbServer.BLOBDirectPut>
    <summary>
      Put data in a BLOB file without referencing a specific field.
    </summary>
    <param name="nPointer">
      A reference to previously stored BLOB data. This reference can be obtained using DBServer:BLOBDirectPut(), DBServer:BLOBDirectImport(), or DBServer:FieldInfo(DBS_BLOB_POINTER, <paramref name="nFieldPos" />). If other than 0, the data referenced by <paramref name="nOldPointer" /> is replaced by <paramref name="uBLOB" />; otherwise, <paramref name="uBLOB" /> is added to the current contents of the BLOB file.
      <br />Important! If specified, DBServer:BLOBDirectPut() releases the space associated with <paramref name="nOldPointer" /> for reuse by other data. Therefore, it is illegal to use <paramref name="nOldPointer" /> with any of the BLOB methods after passing it as an argument to this method. Use the method's return value to refer to the newly stored data.
    </param>
    <param name="uBlob">
      The data you want to put into the BLOB file. <paramref name="uBLOB" /> can be any X# usual data type, except code block and object.
    </param>
    <returns>
      A numeric pointer to the <paramref name="uBLOB" /> data.
    </returns>
    <remarks>
      DBServer:BLOBDirectPut() stores variable length BLOB data without creating a link with a particular memo field in a data server. After adding data to a BLOB file using DBServer:BLOBDirectPut(), you should store the method's return value, as this is the only way to access the data from the BLOB file. It is up to you, the developer, to provide permanent storage for this reference (see DBServer:BLOBRootPut()).
    </remarks>
    <include file="RDD.xml" path="doc/DbServer.BLOBDirectExample/*" />
  </DbServer.BLOBDirectPut>
  <DbServer.BLOBExport>
    <summary>
      Copy the contents of a BLOB, identified by its memo field number, to a file.
    </summary>
    <param name="uField">The name, number, or symbol representing the position of the field in the database file structure.</param>
    <param name="cTarget">The file to which the records is copied.</param>
    <param name="oFSTarget">
      A string or filespec object that specifies the name of the target file where the BLOB data will be written, including an optional drive, directory, and extension.
      See SetDefault() and SetPath() for file searching and creation rules. No default extension is assumed.
      If <paramref name="oFSTarget" /> does not exist, it is created. If it exists, this method attempts to
      open the file in exclusive mode and, if successful, the file is written to without warning or error. If access is denied because,
      for example, another process is using the file, NetErr() is set to TRUE and the data server's Status property is set.
    </param>
    <param name="kMode">
      A constant defining the copy mode, as shown in the table below:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>
            BLOB_EXPORT_APPEND
          </term>
          <description>Appends to the file</description>
        </item>
        <item>
          <term>
            BLOB_EXPORT_OVERWRITE
          </term>
          <description>Overwrites the file—this is the default</description>
        </item>
      </list>
    </param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <example>
      This example exports the contents of a field that stores a picture to a .GIF file, so that the file can be programmatically displayed:
      <code language="X#">
        FUNCTION ShowPix()
        LOCAL cPixFile := "picture.gif" AS STRING
        LOCAL nPos
        LOCAL oDBCust AS DBServer
        // Customer database with a picture of each 	// customer stored in a field called Pix
        oDBCust := Customer{}
        nPos := oDBCust:FieldPos("Pix")
        // Export the BLOB file's data
        // for the current Pix field
        IF !oDBCust:BLOBExport(nPos, cPixFile, ;
        BLOB_EXPORT_OVERWRITE)
        Alert("Export of picture " + cPixFile + " failed!")
        ELSE
        // Code for displaying picture would go here
        ENDIF
      </code>
    </example>
  </DbServer.BLOBExport>
  <DbServer.BLOBGet>
    <summary>
      Get the contents of a BLOB, identified by its memo field number.
    </summary>
    <param name="uField">The name, number, or symbol representing the position of the field in the database file structure.</param>
    <param name="nStart">
      The starting position in the memo field of the BLOB data. If <paramref name="nStart" /> is positive, the starting position is relative to the leftmost character in <paramref name="uFieldPos" />. If <paramref name="nStart" /> is negative, it is relative to the rightmost character in <paramref name="uFieldPos" />. If <paramref name="nStart" /> is omitted, it is assumed to be 1.
    </param>
    <param name="nCount">
      The number of bytes of data to retrieve, beginning at <paramref name="nStart" />. If <paramref name="nCount" /> is larger than the amount of data stored, excess data is ignored. If omitted, DBServer:BLOBGet() retrieves to the end of the data.
    </param>
    <returns>
      The BLOB data retrieved from the memo field. The data type of the return value depends on the actual data stored. Use ValType() or UsualType() to determine the data type. If the indicated field is not a memo field, DBServer:BLOBGet() returns NIL.
    </returns>
    <remarks>
      <note type="tip">
        <paramref name="nStart" /> and <paramref name="nCount" /> apply to string data only. They are ignored for any other data types.
      </note>
      DBServer:BLOBGet() is very similar to DBServer:FieldGet(). However, because string type variables cannot be larger than 64KB, DBServer:FieldGet() will raise a runtime error when attempting to retrieve memo fields of this magnitude or greater.
      DBServer:BLOBGet() will also raise an error if you attempt to retrieve a field greater than this magnitude; however, you can retrieve any subset of the BLOB data by using an <paramref name="nCount" /> less than 64KB.
      <note type="tip">BLOB data less than 64KB can be retrieved from a memo field using standard means (for example, referring to the field by name in an expression or using the DBServer:FieldGet() method).</note>
    </remarks>
    <example>
      This example imports information from a word processing document into a field, then uses DBServer:BLOBGet() to extract the first 25 characters of the field:
      <code language="X#">
        FUNCTION GetFirst25()
        LOCAL nPos
        LOCAL cStr AS STRING
        LOCAL oDBCust := Customer{}
        oDBCust := Customer{}
        // Field that contains word processor documentation
        nPos := oDBCust:FieldPos("WP_DOC")
        // Import a file (can be larger than 64 KB), then obtain the
        // first 25 characters to show to the user
        IF oDBCust:BLOBImport(nPos, "c:\app\temp.doc")
        cStr := oDBCust:BLOBGet(nPos, 1, 25)
        ELSE
        cStr := "Error: could not import file!"
        ENDIF
        oDBCust:Close()
        RETURN cStr
      </code>
    </example>
  </DbServer.BLOBGet>
  <DbServer.BLOBImport>
    <summary>
      Read the contents of a file as a BLOB, identified by a memo field number.
    </summary>
    <param name="uField">The name, number, or symbol representing the position of the field in the database file structure.</param>
    <param name="oFSSource">
      A string or filespec object that specifies the name of the file from which to read the BLOB data, including an optional drive, directory, and extension. See SetDefault() and SetPath() for file searching and creation rules. No default extension is assumed.
    </param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method attempts to open the source file in shared mode. If the file does not exist, a runtime error is raised. If the file is successfully opened, the operation proceeds. If access is denied because, for example, another process has exclusive use of the file, NetErr() is set to TRUE and the data server's Status property is set. Refer to the 'Concurrency Control' chapter in the Programmer's Guide for more information on resolving concurrency conflicts.
      <note type="tip">There are no restrictions on the size of the source file except that you must have enough disk space to make the copy.</note>
      DBServer:BLOBImport() provides a mechanism for copying the contents of a file into a memo field as BLOB data.
      DBServer:BLOBImport() is used in conjunction with DBServer:BLOBExport() to transfer BLOB data back and forth between files and memo fields. You can use DBServer:BLOBImport() with a variety of file types, including graphics images, word processor files, and printer fonts. These two methods are excellent for creating databases of documents, graphics, sounds, and so on.
      DBServer:BlobImport() sends a NotifyFieldChange message upon successful completion.
      <note type="tip">
        DBServer:FieldInfo(DBS_BLOB_TYPE, <paramref name="uFieldPos" />) will return "C" (string) for any memo field created using DBServer:BLOBImport().
      </note>
    </remarks>
    <example>
      This example imports information from a word processing document into a field, then uses DBServer:BLOBGet() to extract the first 25 characters of the field:
      <code language="X#">
        FUNCTION Populate()
        LOCAL oDBCust AS DBServer
        oDBCust := Customer{}
        // Construct unique name based on last name 	// and id
        DO WHILE .NOT. oDBCust:EOF
        oDBCust:GetPix("Pix", ;
        Substr(oDBCust:LastName, 1, 4) + oDBCust:CustID)
        oDBCust:Skip()
        ENDDO
        METHOD GetPix(cPixField, cPixFile) CLASS Customer
        LOCAL nPos
        nPos := SELF:FieldPos(cPixField)
        // Import the picture file into indicated 	// field
        IF !SELF:BLOBImport(nPos, cPixFile)
        Alert("Import of picture " + cPixFile + " 	failed!")
        ENDIF
      </code>
    </example>
  </DbServer.BLOBImport>
  <DbServer.BLOBRootGet>
    <summary>
      Retrieve the data from the root area of a BLOB file.
    </summary>
    <returns>
      The data retrieved from the root of the BLOB file. The data type of the return value depends on the actual data stored. Use ValType() or UsualType() to determine the data type. Note that DBServer:BLOBRootGet() returns NIL if the root reference has never been written to with DBServer:BLOBRootPut().
    </returns>
    <remarks>
      DBServer:BLOBRootGet() allows the retrieval of a BLOB from the root of a BLOB file.
      <note type="tip">Because the root data does not reference a particular record in the data server, it is not affected by DBServer:RLock(), nor is it subject to the DataServer:ConcurrencyControl settings. Therefore, if the data server is opened in shared mode, you should use DBServer:BLOBRootLock() before calling DBServer:BLOBRootGet().</note>
    </remarks>
    <include file="RDD.xml" path="doc/DbServer.BLOBRootExample/*" />
  </DbServer.BLOBRootGet>
  <DbServer.BLOBRootLock>
    <summary>
      Obtain a lock on the root area of a BLOB file.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Use DBServer:BLOBRootLock() when accessing the data server in shared mode to obtain a lock on the root area of a BLOB file for reading from or writing to the root area.
    </remarks>
    <include file="RDD.xml" path="doc/DbServer.BLOBRootExample/*" />
  </DbServer.BLOBRootLock>
  <DbServer.BLOBRootPut>
    <summary>
      Store data in the root area of a BLOB file.
    </summary>
    <param name="uBlob">
      The data you want to put into the BLOB file's root area. <paramref name="uBLOB" /> can be any X# usual data type, except code block and object.
    </param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      DBServer:BLOBRootPut() allows the storage of one—and only one—piece of data to a BLOB file's root area (there is no size limitation on this one piece of data). After storing the new data, DBServer:BLOBRootPut() releases the space associated with any data previously stored in the BLOB file's root area.
      <note type="tip">Because the root data does not reference a particular record in the data server, it is not affected by DBServer:RLock(), nor is it subject to the DataServer:ConcurrencyControl settings. Therefore, if the data server is opened in shared mode, you should use DBServer:BLOBRootLock() before calling DBServer:BLOBRootGet().</note>
    </remarks>
    <example>
      This example uses DBServer:BLOBRootPut() to store system settings to a BLOB file after modification:
      <code language="X#">
        FUNCTION UpdateSettings()
        LOCAL aSettings AS ARRAY
        LOCAL oDBCust AS DBServer
        oDBCust := Customer{}
        IF oDBCust:BLOBRootLock()
        // Get any existing settings
        aSettings := oDBCust:BLOBRootGet()
        IF Empty(aSettings)
        // This function would populate aSettings with default data
        aSettings := oDBCust:GetDefaultSettings()
        ENDIF
        // This function would allow the user to
        // modify the settings.
        IF oDBCust:ModifySettings(aSettings)
        // Finally, store the settings
        oDBCust:BLOBRootPut(aSettings)
        ENDIF
        oDBCust:BLOBRootUnlock()
        ELSE
        aSettings := {}
        Alert("Could not obtain a lock on the root")
        ENDIF
        oDBCust:Close()
        RETURN aSettings
      </code>
    </example>
  </DbServer.BLOBRootPut>
  <DbServer.BLOBRootExample>
    <example>
      This example illustrates how to store information in the root of a BLOB file and how to use locking for a data server opened in shared mode.
      <code language="X#">
        FUNCTION GetSettings()
        LOCAL aCustSettings AS ARRAY
        LOCAL oDBCust AS DBServer
        // Open a customer file in shared mode
        oDBCust := Customer{}
        IF oDBCust:BLOBRootLock()
        aCustSettings := oDBCust:BLOBRootGet()
        oDBCust:BLOBRootUnlock()
        ELSE
        Alert("Could not obtain root lock")
        ENDIF
        oDBCust:Close()
        RETURN aCustSettings
      </code>
    </example>
  </DbServer.BLOBRootExample>
  <DbServer.BLOBRootUnlock>
    <summary>
      Release the lock on a BLOB file's root area.
    </summary>
    <remarks>
      Use DBServer:BLOBRootUnlock() to release a lock previously obtained using DBServer:BLOBRootLock().
      <note type="tip">The only methods that require the use of DBServer:BLOBRootLock() or DBServer:BLOBRootUnlock() are DBServer:BLOBRootGet() and DBServer:BLOBRootPut().</note>
    </remarks>
    <include file="RDD.xml" path="doc/DbServer.BLOBRootExample/*" />
  </DbServer.BLOBRootUnlock>
  <DbServer.BoF>
    <summary>
      A logical value indicating whether the server is positioned at the beginning of the file, on the first record.
    </summary>
    <value>A logical value indicating whether the server is positioned at the beginning of the file, on the first record.</value>
    <remarks>
      A logical value indicating whether the server is positioned at the beginning of the file, on the first record.
      It returns TRUE after an attempt to move backward beyond the first logical record in a database file; otherwise, it returns FALSE. If the current database file contains no records, BOF also returns TRUE.
    </remarks>
    <example>
      This example demonstrates BOF by attempting to move the record pointer before the first record:
      <code language="X#">
        CLASS Sales INHERIT DBServer
        ...
        FUNCTION BOFDemo()
        LOCAL oDBSales AS Sales
        oDBSales := Sales{}
        ? ODBSales:BOF		// Result: FALSE
        oDBSales:Skip(-1)
        ? ODBSales:BOF		// Result: TRUE
      </code>
    </example>
  </DbServer.BoF>
  <DbServer.ClearFilter>
    <summary>
      Clear a filter condition specified with the DBServer:SetFilter() method.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
  </DbServer.ClearFilter>
  <DbServer.ClearIndex>
    <summary>
      Clear all indexes currently associated with the server.
    </summary>
    <param name="uOrder">The name of an order, or the ordinal position of the order within the order list. A value of 0 specifies the controlling index, without regard to its actual position in the list.</param>
    <param name="cOrdBag">The name of the orderbag in which the order resides. </param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
  </DbServer.ClearIndex>
  <DbServer.ClearLocate>
    <summary>
      Clear the LOCATE condition of the server, if any.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
  </DbServer.ClearLocate>
  <DbServer.ClearOrderScope>
    <summary>
      Set or clear the boundaries for scoping key values in the controlling order.
    </summary>
    <remarks>
      DBServer:ClearOrderScope() resets the values set by the DBServer:OrderScope() method.
    </remarks>
  </DbServer.ClearOrderScope>
  <DbServer.ClearRelation>
    <summary>
      Clear all active relations held by this server to other servers.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
  </DbServer.ClearRelation>
  <DbServer.ClearScope>
    <summary>
      Clear the settings that define the default scope for multi-record operations.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
  </DbServer.ClearScope>
  <DbServer.Close>
    <summary>
      Close the database file and its associated index files.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      It will also help the garbage collector if you set the <paramref name="oDBServer" /> to NULL_OBJECT after closing it.
    </remarks>
  </DbServer.Close>
  <DbServer.Commit>
    <summary>
      Commit all changes to disk from the buffer, ensuring that all buffers are flushed.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Sends a NotifyCompletion message, if successful. <br/>
      If using in conjunction with an Unlock() method, then the Commit() method should be executed prior to the Unlock() method call. Using a Commit() when scanning numerous records can be a very slow process, thus you may want to limit your Commit() statements to every 10 or 20 records to speed up your process.
      Note that DBServer:Commit() can fail for many reasons, ranging from a lack of capability in the server to lock conflicts and technical problems, such as network crashes. Use the DBServer:Status property to determine the exact cause of the failure.

      DBCommit() Function
    </remarks>
  </DbServer.Commit>
  <DbServer.ConcurrencyControl>
    <summary>
      A constant, identifying the mode of automatic concurrency control for this data server, determining when and how records are locked and released:
    </summary>
    <value>A constant, identifying the mode of automatic concurrency control for this data server, determining when and how records are locked and released:</value>
    <remarks>
      One of the following constants, identifying the mode of automatic concurrency control for this data server, determining when and how records are locked and released:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>CCNONE</term>
          <description>The data server provides no automatic record locking; the application is required to do all locking explicitly. </description>
        </item>
        <item>
          <term>CCOPTIMISTIC</term>
          <description>
            No locks are maintained continuously except when appending—the record just appended is locked, and the lock is only
            released when moving off the record or explicitly calling the DataServer or DBServer Unlock() method.
            For all other records, the record is reread from disk before any update is done. This is the <b>default</b>.
          </description>
        </item>
        <item>
          <term>CCSTABLE</term>
          <description>The record that the window is sitting on is always kept locked. Note that when in browse view, the row that the cursor is on represents the current record.</description>
        </item>
        <item>
          <term>CCREPEATABLE</term>
          <description>All records that have been read are maintained locked. The user is guaranteed that when moving back among previously viewed data, they are unchanged.</description>
        </item>
        <item>
          <term>CCFILE</term>
          <description>All the records in the entire set provided by the server are locked throughout. This is not very practical for windows associated with all the records of a server, since it would correspond to a file lock. It is intended to be used in conjunction with method DBServer:SetSelectiveRelation(). </description>
        </item>
      </list>
    </remarks>
    <example>
      This example sets up the Sales:Init() method to accept the open mode for the server as an argument. Then, the oDBSales server is opened using CCNONE, indicating that any application using this server must supply code for explicit locking:
      <code language="X#">
        CLASS Sales INHERIT DBServer
        ...
        METHOD Init(kOpenMode) CLASS Sales
        ...
        SELF:ConcurrencyControl := kOpenMode
        FUNCTION CreateSales()
        LOCAL oDBSales AS Sales
        oDBSales := Sales{CCNONE}
        ...
      </code>
    </example>
  </DbServer.ConcurrencyControl>
  <DbServer.ConstructUniqueAlias>
    <summary>Create a unique alias based on the filename and an optional numeric suffix</summary>
    <param name="cFileName">The filename to base the alias on.</param>
  </DbServer.ConstructUniqueAlias>
  <DbServer.Continue>
    <summary>
      Resume a pending DBServer:Locate() operation, searching for the next record that matches (like the DBContinue() function).
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE. After the operation, the DBServer:Found access can be used to determine if a record was found.
    </returns>
    <remarks>
      Sends a NotifyIntentToMove message before the operation.<br/>
      Sends a NotifyRecordChange message upon completion, whether successful or not.<br/>
      Continue respects the FOR clause of the original Locate(), but ignores any WHILE clause and scope. If you want to continue searching with the WHILE clause of the original Locate() operation, set the scope to REST and do another Locate().
      If DBServer:Found returns FALSE, the current record will be the last record and DBServer:EOF will be TRUE.
    </remarks>
  </DbServer.Continue>
  <DbServer.CopyDB>
    <summary>
      Copy records to another DBF file.
    </summary>
    <param name="oFSTarget">A string or filespec object that specifies the file to which the records is copied. This file is opened exclusively during the operation, so it should not be open elsewhere with write capability.</param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation.<br/>
      Sends a NotifyRecordChange message upon completion.<br/>
      This method does not open the new file, it simply creates the file on disk. If you want to open it afterwards, you simply instantiate it directly.
    </remarks>
    <example>
      The example below creates the file and instantiates it to open it.
      <code language="X#">
        IF oDB1:CopyDB(oFSTarget)
        oDB2 := DBServer{oFSTarget}
        ELSE
        ...
        ENDIF
      </code>
    </example>
  </DbServer.CopyDB>
  <DbServer.CopyDelimited>
    <summary>
      Copy records to a delimited file.
    </summary>
    <param name="oFSTarget">A string or filespec object that specifies the file to which the records is copied.</param>
    <param name="cDelimiter">The delimiter for fields within a delimited database file. If omitted, the default is NULL_STRING.</param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation.<br/>
      Sends a NotifyRecordChange message upon completion.<br/>
    </remarks>
  </DbServer.CopyDelimited>
  <DbServer.CopySDF>
    <summary>
      Copy records to an SDF file.
    </summary>
    <param name="oFSTarget">A string or filespec object that specifies the file to which the records is copied.</param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyRecordChange message upon completion.<br/>
    </remarks>
  </DbServer.CopySDF>
  <DbServer.CopyStructure>
    <summary>
      Create a DBF file with the same record layout as the server object to which the message is sent.
    </summary>
    <param name="cFileName">The file to which the record is copied.</param>
    <param name="oFSTarget">A filespec object that specifies the file to which the record is copied.</param>
    <param name="aFieldList">An array of fields that are to be included in the records to be copied.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Sends a NotifyCompletion message, if successful.<br/>
      This method does not open the new file; it simply creates the file on disk. If you want to open it afterwards, you simply instantiate it directly.
    </remarks>
    <example>
      The example below creates the file and instantiates it to open it.
      <code language="X#">
        IF oDB1:CopyStructure(oFSTarget)
        oDB2 := DBServer{oFSTarget}
        ELSE
        ...
        ENDIF
      </code>
    </example>
  </DbServer.CopyStructure>
  <DbServer.Count>
    <summary>
      Return the number of records that match a specified scope.
    </summary>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      The number of records that match the scope.
    </returns>
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyRecordChange message upon completion.<br/>
      On successful completion, the current record will be the last file record and DBServer:EOF will be TRUE.
    </remarks>
    <example>
      Compare with the way the COUNT command is used:
      <code language="X#">
        COUNT TO nBranchCnt FOR Branch = 100
        nBranchCnt := oDBSales:Count({||Branch=100})
      </code>
    </example>
  </DbServer.Count>
  <DbServer.CreateIndex>
    <summary>
      Create an index file with an order in it.
    </summary>
    <param name="oFSIndex">A string or filespec object that specifies the name of the index file to be created.</param>
    <param name="cExpr">The indexing expression.</param>
    <param name="cbExpr">The indexing expression. If a code block is provided, it should match the string expression; if a code block is not provided, one is created from the string expression.</param>
    <param name="lUnique">Whether the index is unique. If not specified, the default is determined by SetUnique().</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyFileChange message upon completion.<br/>
    </remarks>
  </DbServer.CreateIndex>
  <DbServer.CreateOrder>
    <summary>
      Create an order within an existing index file. The behavior depends on which driver is used.
    </summary>
    <param name="cOrderName">The order name to be used.</param>
    <param name="cIndexFileName">The name of the index file.</param>
    <param name="cExpr">The indexing expression.</param>
    <param name="cbExpr">The indexing expression. If a code block is provided, it should match the string expression; if a code block is not provided, one is created from the string expression.</param>
    <param name="lUnique">Whether the index is unique. If not specified, the default is determined by SetUnique().</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyFileChange message upon completion.<br/>

      This sample shows how to create a single tag order:
      <code language="X#">
        // If you want descending order by chance, then include this line first:
        &lt;oDbServer&gt;:SetOrderCondition(,,,,,,,,,,TRUE)
        IF &lt;oDbServer&gt;:CREATEORDER( "PlayerName", SELF:cPath + "Players", "Upper(LastName + FirstName + MiddleInit)" )
        &lt;oDbServer&gt;:Commit()
        ELSE
        // If the index tag was not created successfully, then tell somebody about it: ….
        ENDIF
        // Don't forget to turn the ascending order back on:
        &lt;oDbServer&gt;:SetOrderCondition(,,,,,,,,,,FALSE)
      </code>

      DBCreateOrder() Function
    </remarks>
  </DbServer.CreateOrder>
  <DbServer.DataField>
    <summary>
      Retrieve the data field object at the specified field position.
    </summary>
    <param name="uField">The name, number, or symbol representing the desired field.</param>
  </DbServer.DataField>
  <DbServer.DBStruct>
    <summary>
      An array containing the structure of this data server, whose length (that is, number of elements) is equal to the number of fields in the server.
    </summary>
    <value>An array containing the structure of this data server, whose length (that is, number of elements) is equal to the number of fields in the server.</value>
    <remarks>
      An array containing the structure of this data server, whose length (that is, number of elements) is equal to the number of fields in the server.
      Each sub-array is comprised of five elements, which contain the following information, in this order:
      <include file="RTComments.xml" path="Comments/DbStruct_Constants/*"  />
    </remarks>
    <example>
      This example opens a database file, then creates an array containing the database structure using DBServer:DBStruct within an aliased expression. The field names are then listed using AEval():
      <code language="X#">
        CLASS Sales INHERIT DBServer
        ...
        FUNCTION StructDemo()
        LOCAL aStruct AS ARRAY, oDBSales AS DBServer
        oDBSales := Sales{}
        aStruct := oDBSales:DBStruct
        AEval(aStruct, {|aField|QOut(aField[DBS_NAME])})
      </code>
    </example>
  </DbServer.DBStruct>
  <DbServer.DbStructure>
    <summary>Return the original dbstructure array from the DbServer object.</summary>
    <value>The original dbstructure array from the DbServer object.</value>
    <summary>Since this returns the original array and not a copy of it you should be extremely careful not to change it !</summary>
  </DbServer.DbStructure>
  <DbServer.Delete>
    <summary>
      Delete the current record or the records specified with the scoping parameters.
    </summary>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      If called with a scope or if a server scope is active, Delete() sends a NotifyIntentToMove message before the operation, and a NotifyFileChange upon completion (regardless of the number of records actually deleted). If no scope is used and Delete() applies to the current record only, it sends a NotifyRecordChange message, if successful. <br/>
      If a scope is specified, on successful completion, the current record will be the last file record and DBServer:EOF will be TRUE.
      <br />Important! Since the scope is persistent, a scope left around from processing a method like CopyDB() or Average() could cause Delete() to process too many records. Remember to reset a scope after it has been used.
      Even though the record is marked for deletion, it remains in the file and can be recalled. (The current setting of the SetDeleted() function affects whether deleted records are visible.) If changes have been made to fields, the changes are recorded in the record before it is flagged as deleted; thus, if the field is recalled, it correctly reflects any changes made before the delete operation.
      <note type="tip">DBServer:Delete() does not advance to the next record after the deletion takes place, unlike DataWindow:Delete() which does (if SetDeleted() is TRUE).</note>
    </remarks>
  </DbServer.Delete>
  <DbServer.DeleteAll>
    <summary>
      Delete all records of the table.
    </summary>
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyFileChange message upon completion.<br/>
    </remarks>
  </DbServer.DeleteAll>
  <DbServer.Deleted>
    <summary>
      A logical value indicating whether the current record is marked as deleted.
    </summary>
    <value>A logical value indicating whether the current record is marked as deleted.</value>
    <remarks>
      A logical value indicating whether the current record is marked as deleted. Note that a pointer change, such as GoTop(), must be invoked in order for the filter condition to become active.
    </remarks>
    <example>
      This example uses Deleted as a filtering condition with the DBServer:SetFilter() method:
      <code language="X#">
        CLASS Sales INHERIT DBServer
        ...
        FUNCTION IgnoreDeleted()
        LOCAL oDBSales AS Sales
        oDBSales := Sales{}
        oDBSales:SetFilter("!Deleted()")
        oDBSales:GoTop()
        .
        . &lt;Process records&gt;
        .
        oDBSales:ClearFilter()
      </code>
      This example uses a compound filtering condition with the DBServer:SetFilter() method, and is also assuming that the Players.dbf file is already open at the class level:
      <code language="X#">
        CLASS Players INHERIT DBServer
        ...
        FUNCTION pbResetFilter()
        Local cFilter
        cFilter	:= [Season = '] + SELF:cSeason + [' .and. .not. empty(TeamNr) ]
        cFilter	+= [ .and. empty(HomePhone)]
        cFilter	+= [ .and. Gender = '] + SELF:cGender + [']
        SELF:oPlayersServer:SetFilter(, cFilter )	// Note placement of comma parameter
        SELF:oPlayersServer:GoTop()
        .
        . &lt;Process records&gt;
        .
        SELF:oPlayersServer:ClearFilter()
      </code>
    </example>
  </DbServer.Deleted>
  <DbServer.DeleteOrder>
    <summary>
      Delete an order from an index file.
    </summary>
    <param name="uOrder">The name or number of the order to be deleted.</param>
    <param name="cIndexFileName">The index file does not have to be specified if the order name specified is unique among all the opened orders, or if an order number is used. But if a non-unique order name is specified, the index file should also be specified.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
  </DbServer.DeleteOrder>
  <DbServer.Driver>
    <summary>
      A string representing the name of the database driver in use with this server.
    </summary>
    <value>A string representing the name of the database driver in use with this server.</value>
    <remarks>
      A string representing the name of the database driver in use with this server.
      The server can be specified as an instantiation parameter to the server. If no driver is set, the default driver is used; it can be set by RDDSetDefault() or DBSetDriver().
    </remarks>
  </DbServer.Driver>
  <DbServer.EoF>
    <summary>
      A logical value indicating whether the server is positioned at the end of the file, on the last record
    </summary>
    <value>A logical value indicating whether the server is positioned at the end of the file, on the last record</value>
    <remarks>
      A logical value indicating whether the server is positioned at the end of the file, on the last record.
      It returns TRUE after an attempt is made to move the record pointer beyond the last logical record in a database file; otherwise, FALSE. If the current database file contains no records, EOF returns TRUE.
    </remarks>
    <example>
      This example demonstrates using EOF as the condition defining a WHILE loop. Note that while performing a DO loop similar to the one below but you might also be including some other field-to-var comparisons, always have the EOF as the first condition on the DO WHILE line. This prevents you from comparing field values when you are in fact at an EOF condition:
      <code language="X#">
        CLASS Sales INHERIT DBServer
        ...
        FUNCTION EOFDemo()
        LOCAL oDBSales AS Sales
        oDBSales := Sales{}
        DO WHILE !oDBSales:EOF
        ...
        oDBSales:Skip()
        ENDDO
      </code>
    </example>
  </DbServer.EoF>
  <DbServer.ErrInfo>
    <summary>
      An Error object identifying the error condition after the last operation.
    </summary>
    <value>An Error object identifying the error condition after the last operation.</value>
    <remarks>
      An Error object identifying the error condition after the last operation. If the last operation was successful, DBServer:ErrInfo returns NULL_OBJECT.
    </remarks>
    <example>
      This example demonstrates a SEQUENCE construct in which ErrInfo is passed to the RECOVER USING statement:
      <code language="X#">
        CLASS Sales INHERIT DBServer
        ...
        FUNCTION EOFDemo()
        LOCAL oDBSales AS Sales
        oDBSales := Sales{}
        BEGIN SEQUENCE
        .
        . &lt;Some statements that may fail&gt;
        .
        RECOVER USING oDBSales:ErrInfo
        .
        . &lt;Some recovery statements&gt;
        .
        END SEQUENCE
      </code>
    </example>
  </DbServer.ErrInfo>
  <DbServer.Error>
    <summary>
      Provide a method for handling error conditions raised during database processing.
    </summary>
    <param name="oError">An Error object describing the error condition.</param>
    <param name="symMethod">The symbolic name of the method that originated the error.</param>
    <remarks>
      <note type="tip">This is an event handler and is automatically called by other methods; the developer does not normally need to call the DBServer:Error() method, but might want to replace or amend it.</note>
      All methods of the DBServer trap serious errors with a recover statement and send them to this method. Ordinary failures, such as locking conflicts or record-not-found, do not raise error conditions; they are simply indicated through failure return values.
      The standard Error() handling method fills in some more information about the errors and about the DBServer object that originates the error, sets the status value for the server object, and passes the problem to its client, if there is one, in its standard Error() handling method. If there is no client who wants to deal with the problem, the method passes it up the call stack by issuing a BREAK with the same Error object.
      <note type="tip">If an error comes in while one is being handled, the Error() method immediately breaks.</note>
    </remarks>
    <example>
      The Skip() method uses the Error() method like this:
      <code language="X#">
        METHOD Skip(n) CLASS DBServer
        LOCAL oError AS USUAL
        BEGIN SEQUENCE
        RETURN (wWorkarea)-&gt;(VODBSkip(...))
        RECOVER USING oError
        SELF:Error(oError,#Skip)
        RETURN FALSE
        END SEQUENCE
      </code>
    </example>
  </DbServer.Error>
  <DbServer.ErrorInfo>
    <summary>Returns the internal ErrorInfo object, regardless of the last operation produced an error or not.</summary>
    <value>The internal ErrorInfo object, regardless of the last operation produced an error or not.</value>
  </DbServer.ErrorInfo>
  <DbServer.Eval>
    <summary>
      Evaluate a code block for each record matching a scope and condition. If neither conditions nor scope is passed to the method, it is subject to the general server scope.
    </summary>
    <param name="cbBlock">The code block to execute for each record processed.</param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyFileChange message upon completion, whether successful or not.<br/>
      On successful completion, the current record will be the last file record and DBServer:EOF will be TRUE.
    </remarks>
  </DbServer.Eval>
  <DbServer.FCount>
    <summary>
      The number of fields in the server.
    </summary>
    <value>The number of fields in the server.</value>
    <example>
      This example uses FCount as the upper boundary of a FOR loop that processes the list of current work area fields:
      <code language="X#">
        CLASS Sales INHERIT DBServer
        ...
        FUNCTION ListFields()
        LOCAL nField AS SHORTINT, oDBSales AS Sales
        oDBSales := Sales{}
        FOR nField := 1 UPTO oDBSales:FCount
        ? oDBSales:FieldName(nField)
        NEXT
      </code>
    </example>
  </DbServer.FCount>
  <DbServer.FieldDesc>
    <summary>This returns an empty array. For servers that were painted in the DbServer editor this returns the array of DataFields.</summary>
    <value>An empty array. For servers that were painted in the DbServer editor this returns the array of DataFields.</value>
  </DbServer.FieldDesc>
  <DbServer.FieldGet>
    <summary>
      Get the contents of a field that is identified by its position.
    </summary>
    <param name="uField">The name, number, or symbol representing the desired field.</param>
    <returns>
      The value of the specified field. If <paramref name="nFieldPos" /> does not correspond to the position of any field in the current data server, DBServer:FieldGet() returns NIL.
    </returns>
    <remarks>
      DBServer:FieldGet() retrieves the value of a field using its position within the database file structure rather than its field name. Within generic database service functions this allows, among other things, the retrieval of field values without use of the macro operator.
      <note type="tip">DBServer:FieldGet() can be used with a BLOB field (that is, a memo field associated with a BLOB file), provided the length of the field does not exceed 64KB. For BLOB fields longer than 64KB, use DBServer:BLOBGet() instead.</note>
    </remarks>
    <example>
      This example compares DBServer:FieldGet() to functionally equivalent code that uses the macro operator to retrieve the value of a field:
      <code language="X#">
        LOCAL nFieldPos := 1, FName, FVal
        LOCAL oDBCust := Customer{} AS DBServer
        // Get field value using macro operator
        FName := oDBCust:FieldName(nFieldPos)
        FVal := &amp;FName
        // Get field value using FieldGet()
        FVal := oDBCust:FieldGet(nFieldPos)
        FVal := oDBCust:FieldGet( #Fname )
        Fval := oDBCust:FieldGet( "Fname" )
      </code>
    </example>
  </DbServer.FieldGet>
  <DbServer.FieldGetBytes>
    <summary>
      Read an array of bytes direct from the workarea buffer.
    </summary>
    <param name="uField">
      The position of the field in the database file structure for the current work area.
    </param>
    <returns>
      The value of the field.   IF nFieldPos does not correspond to the position of any field in the database file, FieldGetBytes() will generate an error.
    </returns>
  </DbServer.FieldGetBytes>
  <DbServer.FieldGetFormatted>
    <summary>
      Return the contents of a specified field according to the formatting specifications of its FieldSpec object.
    </summary>
    <param name="uField">The name, number, or symbol representing the desired field.</param>
  </DbServer.FieldGetFormatted>
  <DbServer.FieldHyperLabel>
    <summary>
      Return the hyperlabel of a specified field.
    </summary>
    <param name="uField">The name, number, or symbol representing the desired field.</param>
    <returns>
      The field hyperlabel or NIL.
    </returns>
    <remarks>
      By accessing the hyperlabel, you can in turn access its various properties which annotate the field:
      <code language="X#">
        oDBServer:FieldHyperLabel(#LastName):Caption
        oDBServer:FieldHyperLabel(#LastName):Description
        oDBServer:FieldHyperLabel(#LastName):HelpContext
      </code>
    </remarks>
  </DbServer.FieldHyperLabel>
  <DbServer.FieldInfo>
    <summary>
      Return and optionally change information about a field.
    </summary>
    <param name="kFieldInfoType">
      Specifies the type of information. The constants are described in the Remarks section below. Note, however, that not all constants are supported for all RDDs.
    </param>
    <param name="uField">
      The name, number, or symbol representing the position of the field in the database file structure or a numeric pointer to a BLOB.
      Only certain <paramref name="kFieldInfoType" /> constants designed to work with BLOB fields—all noted in the Constants section below—allow specifying the
      field using a pointer; all others require specifying the field by its position.
    </param>
    <param name="uFieldVal">
      If specified, this parameter is used to change the value of a setting. The data type (and whether <paramref name="uNewSetting" /> can be specified), depends on the <paramref name="kInfoType" /> constant and is documented in the Constants section below.
    </param>
    <returns>
      If <paramref name="uNewSetting" /> is not specified, DBServer:FieldInfo() returns the current setting. If <paramref name="uNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      <include file="RTComments.xml" path="Comments/DBS_Constants/*"  />

      DBServer:FieldInfo() retrieves information about the state of a field (column).
      The field information that is available is defined by the RDD. In the DBF model, this is limited to the information stored in the DBF file structure (that is, name, length, number of decimals, and data type) plus the field alias that can be changed at runtime.
      To support RDDs for other database models (such as dictionary based databases) that store more information about each field or column, the X# RDD API has been enhanced. The DBServer:FieldInfo() method is designed to allow for additional <paramref name="kInfoType" /> values that can be defined by third-party RDD developers.
    </remarks>
    <example>
      The following examples use DBServer:FieldInfo() to retrieve field information:
      <code language="X#">
        METHOD DBOutStruct() CLASS Customer
        LOCAL aStruct AS ARRAY
        LOCAL wFcount AS DWORD
        LOCAL i    AS DWORD
        aStruct := {}
        wFcount := FCount()
        FOR i := 1 UPTO wFcount
        AAdd(aStruct,;
        {SELF:FieldInfo(DBS_NAME, i),;
        SELF:FieldInfo(DBS_TYPE, i),;
        SELF:FieldInfo(DBS_LEN, i),;
        SELF:FieldInfo(DBS_DEC, i)})
        NEXT
        RETURN aStruct
      </code>
      The next example illustrates using the third parameter to assign an alias to a field name:
      <code language="X#">
        METHOD Start() CLASS App
        LOCAL oDBDate AS DBServer
        oDBDate := DateBook{}
        oDBDate:FieldInfo(DBS_ALIAS,;
        oDBDate:FieldPos("Name"),;
        "NewName")
        ? Name		// Displays name field
        ? NewName	// Also displays name field
        ...
      </code>
    </example>
  </DbServer.FieldInfo>
  <DbServer.FieldName>
    <summary>
      Return the name of a specified field as a string.
    </summary>
    <param name="nFieldPosition">The number of the field referenced.</param>
    <remarks>
      The field's hyperlabel also contains a name; these two names are the same in the code generated by the DBServer Editor.
    </remarks>
  </DbServer.FieldName>
  <DbServer.FieldPos>
    <summary>
      Return the position of a specified field within the data server, as a number starting with 1.
    </summary>
    <param name="cFieldName">The name or symbol of the desired field.</param>
    <returns>
      The field position in the dbServer structure, or zero if not found.

      FieldPos() Function
    </returns>
  </DbServer.FieldPos>
  <DbServer.FieldPut>
    <summary>
      Set the value of a field identified by its position.
    </summary>
    <param name="uField">The name, number, or symbol representing the desired field.</param>
    <param name="uValue">The value to assign to the field. The data type of this expression must match the data type of the field.</param>
    <returns>
      The value assigned to the field. If <paramref name="nFieldPos" /> does not correspond to the position of any field in the data server, DBServer:FieldPut() returns NIL.
    </returns>
    <remarks>
      DBServer:FieldPut() allows you to set the value of a field using its position within the database file structure rather than its field name. Within generic database service functions this allows, among other things, the setting of field values without use of the macro operator.
      <note type="tip">DBServer:FieldPut() can be used with a BLOB field (that is, a memo field associated with a BLOB file), provided the length of the field does not exceed 64KB.</note>
      Shared mode: For a shared database, this function requires a record lock. Refer to the "Concurrency Control" chapter in the Programmer's Guide for more information on locking.
    </remarks>
    <example>
      This example compares DBServer:FieldPut() to functionally equivalent code that uses the macro operator to set the value of a field:
      <code language="X#">
        LOCAL nFieldPos := 1, FName, FVal
        LOCAL oDBCust := Customer{} AS DBServer
        // Set field value using macro operator
        FName := oDBCust:FieldName(nFieldPos)
        oDBCust:&amp;FName := FVal
        // Set field value using FieldPut() samples:
        oDBCust:FieldPut(nFieldPos, FVal)
        oDBCust:FieldPut( #SSN, SELF:oDCsleSSN:Value )
        oDBCust:FieldPut( "SSN", SELF:cSSN )
      </code>
    </example>
  </DbServer.FieldPut>
  <DbServer.FieldPutBytes>
    <summary>Write an array of bytes direct to the workarea buffer.</summary>
    <param name="uField">The position of the field in the database file structure.</param>
    <param name="bValue">The value to write to the field</param>
  </DbServer.FieldPutBytes>
  <DbServer.FieldSpec>
    <summary>
      Return the FieldSpec object in the specified field.
    </summary>
    <param name="uField">The name, number, or symbol representing the desired field.</param>
  </DbServer.FieldSpec>
  <DbServer.FieldStatus>
    <summary>
      Return the status of a field after the last operation.
    </summary>
    <param name="uField">The name, number, or symbol representing the desired field.</param>
    <returns>
      A HyperLabel object if any error condition had occurred or if a validation has failed, NIL if everything is OK, if the validation passed, or if there has been no validation attempt.
    </returns>
    <remarks>
      DBServer:FieldStatus() can be used to find out more about a validation failure.
      By accessing the properties of this hyperlabel, you can retrieve not only a description but also context-sensitive help on the condition that was raised:
      <code language="X#">
        oDBServer:FieldStatus(#LastName):Caption
        oDBServer:FieldStatus(#LastName):Description
        oDBServer:FieldStatus(#LastName):HelpContext
      </code>
    </remarks>
  </DbServer.FieldStatus>
  <DbServer.FieldSym>
    <summary>
      Return the name of a specified field.
    </summary>
    <param name="uField">The number of the desired field.</param>
    <remarks>
      The field's hyperlabel also contains a name; these two names are the same in the code generated by the DBServer Editor.
    </remarks>
  </DbServer.FieldSym>
  <DbServer.FieldValidate>
    <summary>
      Perform all the validations defined to the FieldSpec object of a field (for example, required, maximum and minimum digits, maximum and minimum value, validation rule) and return the result of the test.
    </summary>
    <param name="uField">The name, number, or symbol representing the desired field.</param>
    <param name="uValue">
      The value that is to be validated. Its data type should be compatible with the data type of the specified field. If the type cannot be converted to the appropriate data type, it is considered to have failed validation.
      See the Programmer's Guide for the rules on data type conversion; in general, any kind of conversion that is reasonable is done, including converting strings like 'TRUE' and 'T' to the logical value TRUE.
    </param>
    <returns>
      FALSE if any of the validations fail; otherwise, TRUE.
    </returns>
  </DbServer.FieldValidate>
  <DbServer.FileSpec>
    <summary>
      The FileSpec object that defines the path and file name of the DBF file.
    </summary>
    <value>The FileSpec object that defines the path and file name of the DBF file.</value>
    <remarks>
      The FileSpec object that defines the path and file name of the DBF file. If the DBServer was originally instantiated with a FileSpec object, this is that original FileSpec object; if the server was originally instantiated with a file name in string format, a FileSpec object is created.
      Note that the path of the file specification is exactly as originally entered. To store the full path of the file in the file specification, use the FileSpec:Find() method.
    </remarks>
    <example>
      This example opens a data server using a FileSpec object, the retrieves information based on the server's FileSpec property:
      <code language="X#">
        oFSSales := FileSpec{"c:\data\cust\sales.dbf"}
        oDBSales := DBServer{oFSSales}
        ? oDBSales:FileSpec:Drive		// C:
        ? oDBSales:FileSpec:Extension	// .DBF
      </code>
    </example>
  </DbServer.FileSpec>
  <DbServer.Filter>
    <summary>
      A string representing the current active filter.
    </summary>
    <value>A string representing the current active filter.</value>
    <remarks>
      A string representing the current active filter. If no filter has been set, NULL_STRING is returned. Assigning a string or a code block to DBServer:Filter is equivalent to calling DBSetFilter().
    </remarks>
    <example>
      This example displays the current Filter condition. Also, if you already have an existing filter condition, you might want to retrieve its :Filter value first, then if your new SetFilter() condition fails, you can reset it back to it's prior filter expression:
      <code language="X#">
        CLASS Sales INHERIT DBServer
        ...
        FUNCTION IgnoreDeleted()
        LOCAL oDBSales AS Sales
        oDBSales := Sales{}
        oDBSales:SetFilter("!Deleted()")
        oDBSales:GoTop()		// move pointer to invoke filter
        ? oDBSales:Filter		// !Deleted()
        .
        . &lt;Process records&gt;
        .
        oDBSales:ClearFilter()
        ? oDBSales:Filter		// NULL_STRING
      </code>
    </example>
  </DbServer.Filter>
  <DbServer.FLock>
    <summary>
      Lock the table used by this server for exclusive access.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
  </DbServer.FLock>
  <DbServer.ForBlock>
    <summary>
      The "FOR block" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope.
    </summary>
    <value>The "FOR block" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope.</value>
    <remarks>
      The "FOR block" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope. The FOR block can be specified as a code block or a string. This access always returns a code block.
      Specifying a FOR block makes the method process all those records where the FOR block evaluates TRUE, subject to other scope settings, of course. Specifying a FOR block makes the Scope default to ALL in those cases where it is otherwise "current record," unless a WhileBlock is also specified in which case it is set to REST.
    </remarks>
    <example>
      This example assigns a code block to ForBlock to limit the scope of a recall operation:
      <code language="X#">
        // RECALL FOR Last == "Smith" REST
        oDB:ForBlock := {|| Last == "Smith"}
        oDB:Scope := DBSCOPEREST
        oDB:Recall()
        oDB:ClearScope()
      </code>
    </example>
  </DbServer.ForBlock>
  <DbServer.Found>
    <summary>
      A logical value indicating whether the previous search operation succeeded.
    </summary>
    <value>A logical value indicating whether the previous search operation succeeded.</value>
    <remarks>
      A logical value indicating whether the previous search operation succeeded. Note that this is old technology and is mainly here for backwards compatibility. Typically if you are doing a SEEK/FOUND scenario, you would simply do a "IF oDB:Seek(…)" to check if the seek was successful (FOUND) or not.
    </remarks>
    <example>
      This example illustrates the behavior of Found after a record movement operation:
      <code language="X#">
        CLASS Sales INHERIT DBServer
        ...
        METHOD Init() CLASS Sales
        ...
        SELF:SetIndex("sales")
        ...
        FUNCTION FoundDemo()
        LOCAL oDBSales AS Sales
        oDBSales := Sales{}
        oDBSales:Seek("1000")
        ? DBSales:Found		// Result: FALSE
        oDBSales:Seek("100")
        ? DBSales:Found		// Result: TRUE
        DBSales:Skip()
        ? DBSales:Found		// Result: FALSE
      </code>
    </example>
  </DbServer.Found>
  <DbServer.GetArray>
    <summary>
      Retrieve an array of values from a field in the server, subject to the currently active selection, if any.
    </summary>
    <param name="nMaxRows">The maximum number of rows that should be retrieved. If omitted, a maximum of 100 rows are retrieved.</param>
    <param name="uField1">The name, number, or symbol representing the field to be retrieved. If omitted, the first field is retrieved.</param>
    <param name="uSearchValue">The value to be searched for, under the currently controlling order. The system performs a Seek() operation, and then proceeds to load up the array from there.</param>
    <returns>
      An array of values found for the specified field, moving sequentially until the specified maximum number of rows or until end of file. If a selection is active, the method includes only records from that selection. The values are retrieved under the current controlling order, if any.
      Note that the method does not reposition to the beginning before starting to fill the array. Either provide a start value, or explicitly position the server before using the method. (This allows incremental reading, building up an array in pieces.)
    </returns>
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyRecordChange message upon completion, and leaves the server positioned at the last record used or at end of file (last file record). <br/>
      One use of this method is to populate validation lists in user interfacing.
    </remarks>
    <example>
      The following fills an array with product names for use as validation values, beginning at the indicated product number:
      <code language="X#">
        oDB := DBServer{"products",#Shared,#ReadOnly}
        oDB:SetIndex("prodno")
        aProducts := oDB:GetArray(100,#ProdName, 22750)
        oDB:Close()
      </code>
    </example>
  </DbServer.GetArray>
  <DbServer.GetLocate>
    <summary>
      Retrieve the code block of the current LOCATE condition, or NIL if no code block is set.
    </summary>
    <remarks>
      DBServer:GetLocate() returns the FOR condition code block used in the Locate() method.
    </remarks>
  </DbServer.GetLocate>
  <DbServer.GetLookupTable>
    <summary>
      Retrieve a two-column array of values from two fields in the server, subject to the currently active selection, if any.
    </summary>
    <param name="nMaxRows">The maximum number of rows that should be retrieved. If omitted, 100 rows at most are retrieved.</param>
    <param name="uField1">The name, number, or symbol of the first field to be retrieved. If omitted, the first field is retrieved.</param>
    <param name="uField2">The name, number, or symbol of the second field to be retrieved. If omitted, the second field is retrieved.</param>
    <param name="uSearchValue">The value to be searched for, under the currently controlling order. The system performs a Seek() operation, and then proceeds to load up the array from there.</param>
    <returns>
      The method returns a two-column array of values found for the specified fields, moving sequentially until the specified maximum number of rows or until end of file. If a selection is active, the method includes only records from that selection. The values are retrieved under the current controlling order, if any.
      Note that the method does not reposition to the beginning before starting to fill the array. Either provide a start value, or explicitly position the server before using the method. (This allows incremental reading, building up an array in pieces.)
    </returns>
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyRecordChange message upon completion, and leaves the server positioned at the last record used or at end of file (last file record). <br/>
      One use of this method is to populate translation lists in user interfacing. The resulting array can be used in ATranslate().
    </remarks>
    <example>
      The following builds a lookup table, for example to translate product codes into product names and vice versa, beginning at the indicated product number:
      <code language="X#">
        oDB := DBServer{"products",#Shared,#ReadOnly}
        oDB:SetIndex("prodno")
        aProducts := oDB:GetLookupTable(500,#ProdNo,#ProdName, 22750)
        oDB:Close()
      </code>
    </example>
  </DbServer.GetLookupTable>
  <DbServer.GoBottom>
    <summary>
      Position the data server at the last record.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyGoBottom message, if successful.<br/>
      If DBServer:RecNo is greater than DBServer:LastRec, the DBServer will be positioned at the last record and DBServer:EOF will be TRUE.
    </remarks>
  </DbServer.GoBottom>
  <DbServer.GoTo>
    <summary>
      Position the data server at a specified record number.
    </summary>
    <param name="nRecordNumber">The record number at which the server should be positioned.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyRecordChange message, if successful.<br/>
    </remarks>
  </DbServer.GoTo>
  <DbServer.GoTop>
    <summary>
      Position the data server at the first record.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyGoTop message, if successful.<br/>
    </remarks>
  </DbServer.GoTop>
  <DbServer.Header>
    <summary>
      A numeric value representing the length of the database file header.
    </summary>
    <value>A numeric value representing the length of the database file header.</value>
    <example>
      This example uses Header to define an access method to return the Size of the data server:
      <code language="X#">
        CLASS Sales INHERIT DBServer
        ...
        ACCESS Size CLASS Sales
        RETURN (SELF:RecSize * SELF:RecCount) + ;
        SELF:Header + 1
      </code>
    </example>
  </DbServer.Header>
  <DbServer.IndexExt>
    <summary>
      A string representing the default index extension based on the database driver currently linked (for example, ".NTX" for the DBFNTX driver).
    </summary>
    <value>A string representing the default index extension based on the database driver currently linked (for example, ".NTX" for the DBFNTX driver).</value>
  </DbServer.IndexExt>
  <DbServer.IndexKey>
    <summary>
      Return the key expression of a specified single-order index.
    </summary>
    <param name="uOrder">The name of an order, or the ordinal position of the order within the order list. A value of 0 specifies the controlling index, without regard to its actual position in the list.</param>
    <returns>
      The key expression of the specified index as a string; if there is no corresponding order or the order name is not unique, the method returns a NULL_STRING.
    </returns>
    <remarks>
      The key expression actually belongs to an order and not to an index file. When using single-order indexes, or when the order name uniquely identifies an order, requesting key information for an index with IndexKey() works. But this practice is not recommended, since the request may not work when a different driver is used.
    </remarks>
  </DbServer.IndexKey>
  <DbServer.IndexList>
    <summary>This returns an empty array. For servers that were painted in the DbServer editor this returns the array of Indexes.</summary>
    <value>An empty array. For servers that were painted in the DbServer editor this returns the array of Indexes.</value>
  </DbServer.IndexList>
  <DbServer.IndexOrd>
    <summary>
      Return the ordinal position of the controlling order in the order list. (Similar to the IndexOrd() function.)
    </summary>
    <returns>
      An integer numeric value. The value returned is equal to the position of the controlling index in the list of open indexes for the current work area. A value of 0 indicates that there is no controlling index and records are being accessed in natural order.
    </returns>
  </DbServer.IndexOrd>
  <DbServer.Info>
    <summary>
      Return and optionally change information about a data server.
    </summary>
    <param name="kInfoType">
      Specifies the type of information.
      <include file="RTComments.xml" path="Comments/RddInfoParam/*"  />
    </param>
    <param name="uInfo">
      If specified, this parameter is used to change the value of a setting. The data type (and whether <paramref name="uInfo" /> can be specified), depends on the <paramref name="kInfoType" /> constant and is documented in the Constants section below.
    </param>
    <returns>
      If <paramref name="uInfo" /> is not specified, DBServer:RDDInfo() returns the current setting. If <paramref name="uInfo" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
    <include file="RTComments.xml" path="Comments/DBI_Constants/*"  />
    </remarks>
    <example>
      The following examples return data server information:
      <code language="X#">
        // Same as oDBServer:Header
        oDBServer:Info(DBI_GETHEADERSIZE)
        // Same as oDBServer:LUpdate
        oDBServer:Info(DBI_LASTUPDATE)
        // Same as oDBServer:RecSize
        oDBServer:Info(DBI_GETRECSIZE)
        // Get the full path
        oDBServer:Info(DBI_FULLPATH)
      </code>
    </example>
  </DbServer.Info>
  <DbServer.Join>
    <summary>
      Join this DBServer object with another DBServer object and place the results in the file specified.
    </summary>
    <param name="oDBSource">The 'other' DBServer object to which this DBServer object is joined. It can be specified as a DBServer object, or as the alias of a table opened in a work area.</param>
    <param name="oFSTarget">A string or filespec object that specifies the file into which results of the join operation is placed.</param>
    <param name="aFieldList">An array of fields to be included in the join operation.</param>
    <param name="cbForBlock">The condition evaluated for each record in the scope; if TRUE, the record is included in the processing. It provides the same functionality as the FOR clause of record processing commands.</param>
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyRecordChange message, if successful.<br/>
    </remarks>
  </DbServer.Join>
  <DbServer.LastRec>
    <summary>
      The number of records in the current database file.
    </summary>
    <value>The number of records in the current database file.</value>
    <remarks>
      The number of records in the current database file. Filtering commands such as SET FILTER or SET DELETED have no effect on the return value.
    </remarks>
    <example>
      This example uses LastRec to define an access method to return the Size of the data server:
      <code language="X#">
        CLASS Sales INHERIT DBServer
        ...
        ACCESS Size CLASS Sales
        RETURN (SELF:RecSize * SELF:LastRec) + ;
        SELF:Header + 1
      </code>
    </example>
  </DbServer.LastRec>
  <DbServer.Locate>
    <summary>
      Search sequentially for a record matching a condition. If neither conditions nor scope is passed to the method, it is subject to the general server scope.
    </summary>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      TRUE if a record was found that matches the conditions, FALSE if no match was found or if the operation failed for some other reason. Afterwards, the Found and Status access methods can be used to determine exactly what happened.
    </returns>
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyRecordChange message upon completion, whether successful or not.<br/>
      If no match was found, the current record will be the last file record and DBServer:EOF will be TRUE.
    </remarks>
  </DbServer.Locate>
  <DbServer.LockCurrentRecord>
    <summary>
      Lock the current record. This method is identical to invoking RLock() with the current record number as a parameter.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
  </DbServer.LockCurrentRecord>
  <DbServer.LockSelection>
    <summary>
      Lock all the records in the currently active selection.
    </summary>
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      If a selection is not active, sends a NotifyIntentToMove message before the operation and functions the same as FLock().
    </remarks>
    <example>
      A selective relation is set up between customer and order servers. The application operates under "cursor stability" mode, which means that the currently active record remains locked and hence protected from outside influence. When a customer record is locked, all the orders that correspond to that customer are also locked:
      <code language="X#">
        oDBCust := DBServer{"customer"}
        oDBOrder := DBServer{"order"}
        oDBOrder:SetIndex{("ORDCSTNO")
        oDBCust:SetSelectiveRelation(oDBOrder,#CustNo)
        ...
        METHOD Skip() CLASS CustomerWindow
        oDBCust:Skip()				// Reposition order server
        oDBCust:RLock()			// Lock customer record
        oDBOrder:LockSelection()		// Lock order records
      </code>
    </example>
  </DbServer.LockSelection>
  <DbServer.Lupdate>
    <summary>
      The last modification date of the DBF file used in the server.
    </summary>
    <value>The last modification date of the DBF file used in the server.</value>
  </DbServer.Lupdate>
  <DbServer.MemoExt>
    <summary>This returns the memo extension of the file (if any). For example DBT or FPT.</summary>
    <value>The memo extension of the file (if any).</value>
  </DbServer.MemoExt>
  <DbServer.Name>
    <summary>This returns the name of the DbServer.</summary>
    <value>The name of the DbServer</value>
  </DbServer.Name>
  <DbServer.NoIVarGet>
    <summary>
      Provide a general error interception that is automatically called (in any class) whenever an access reference is made to a non-existent exported instance variable. In the DBServer class, it is used to implement the virtual field variable.
      <br />Important! NoIVarGet() should not be called directly; it is called by the system for handling invalid references.
    </summary>
    <param name="symFieldName">The symbolic name of the variable that was referenced. In the standard usage of the method with the DBServer class, this is a field name.</param>
    <remarks>
      For DBServer, this method is used to intercept references to field names as exported variables, which ordinarily would not be allowed. If the field name is valid, it does FieldGet() for the corresponding field name, in effect turning database fields into Access methods of each DBServer object. See "Objects, Classes, and Methods" in the Programmer's Guide for more information on NoIVarGet().
    </remarks>
  </DbServer.NoIVarGet>
  <DbServer.NoIVarPut>
    <summary>
      Provide a general error interception that is automatically called (in any class) whenever an assignment reference is made to a non-existent exported instance variable. In the DBServer class, it is used to implement the virtual field variable.
      <br />Important! NoIVarPut() should not be called directly; it is called by the system for handling invalid references.
    </summary>
    <param name="symFieldName">The symbolic name of the variable that was referenced. In the standard usage of the method with the DBServer class, this is a field name.</param>
    <param name="uValue">The value to be assigned to the field. The data type of this value must match the data type of the field.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Sends a NotifyFieldChange message if the variable reference was to a valid field of the server, and the assignment was successful.<br/>
      For DBServer, this method is used to intercept references to field names as exported variables, which ordinarily would not be allowed. If the field name is valid, it does a FieldPut() for the corresponding field name with the passed value, in effect turning database fields into assign methods of each DBServer object. See "Objects, Classes, and Methods" in the Programmer's Guide for more information on NoIVarGet().
    </remarks>
  </DbServer.NoIVarPut>
  <DbServer.Notify>
    <summary>
      An event handler that responds to events that have occurred in methods of this server, or in other servers that are linked to this server in some way. The standard implementation notifies all the server's clients of the event.
      <br />Important! This method is automatically called by the various action methods of the data server, and should normally not be called by application code.
    </summary>
    <returns>
      SELF, except if NOTIFYINTENTTOMOVE is specified for <paramref name="kNotifyName" />.
      In this case, the return value is TRUE if successful; otherwise, FALSE.
    </returns>
    <include file="VOSDK.xml" path="doc/commonblocks/notify/*" />
  </DbServer.Notify>
  <DbServer.OleExt>
    <summary>This returns the OLE extension of the file (if any). For example DFL.</summary>
    <value>The OLE extension of the file (if any).</value>
    <remarks>DFL files are not supported by the X# RDD system.</remarks>
  </DbServer.OleExt>
  <DbServer.OrderBottomScope>
    <summary>
      A key value representing the record of the bottom boundary in the range of key values that will be included in the controlling order's current scope.
    </summary>
    <value>A key value representing the record of the bottom boundary in the range of key values that will be included in the controlling order's current scope.</value>
  </DbServer.OrderBottomScope>
  <DbServer.OrderArgs>
    <param name="uOrder">
      The name of the order or a number representing its position in the order list. Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files. If omitted or NIL, the controlling order is assumed.
      Specifying an invalid value will raise a runtime error.
    </param>
    <param name="cIndex">
      The name of an index file, including an optional drive and directory (no extension should be specified).
      Use this argument with <paramref name="uOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.
      If <paramref name="cIndex" /> is not open by the current process, a runtime error is raised.
    </param>
    <param name="oFSIndex">
      A string or filespec object that specifies the name of an index file, including an optional drive and directory (no extension should be specified).
      Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.
      If <paramref name="oFSIndex" /> is not open by the current process, a runtime error is raised.
    </param>
  </DbServer.OrderArgs>
  <DbServer.OrderDescend>
    <summary>
      Return and optionally change the descending flag of an order.
    </summary>
    <include file="Rdd.xml" path="doc/DbServer.OrderArgs/*" />
    <param name="lNew">TRUE dynamically turns on the descending flag for the order, resulting in descending order. FALSE dynamically turns the flag off, resulting in ascending order.</param>
    <returns>
      If <paramref name="lNew" /> is not specified, DBServer:OrderDescend() returns the current setting. If <paramref name="lNewDescend" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      DBServer:OrderDescend() changes the ascending/descending flag at runtime only—it does not change the descending flag stored in the actual index file.
      <note type="tip">
        If you are using DbServer:OrderDescend() with Scopes, you need to swap the Top and Bottom scope values !
        <code language="X#">
          oServer:OrderScope (TOPSCOPE, cFrom)
          oServer:OrderScope (BOTTOMSCOPE, cTo)
          oServer:OrderDescend(,, TRUE)
          oServer:OrderScope (TOPSCOPE, cTo)
          oServer:OrderScope (BOTTOMSCOPE, cFrom)
        </code>
      </note>
    </remarks>
    <example>
      The following example illustrates DBServer:OrderDescend(); every order can be both ascending and descending:
      <code language="X#">
        LOCAL oDBCust AS DBServer
        oDBCust := Customer{}
        oDBCust:CreateOrder("Last", "customer", "oDBCust:LastName")
        oDBCust:SetOrderCondition(,,,,,,,,,, TRUE)
        oDBCust:CreateOrder("First", "customer", "oDBCust:FirstName")
        oDBCust:SetOrder("Last")		// Last was originally created in ascending order
        oDBCust:OrderDescend(,, TRUE)	// Swap it to descending
        // Last will now be processed in descending order
        oDBCust:SetOrder("First")		// First was originally created in descending order
        oDBCust:OrderDescend(,, FALSE)	// Swap it to ascending
        // First will now be processed in ascending order
      </code>
    </example>
  </DbServer.OrderDescend>
  <DbServer.OrderInfo>
    <summary>
      Return and optionally change information about orders and index files.
    </summary>
    <param name="kOrderInfoType">
      Specifies the type of information. The constants are listed below. Note, however, that not all constants are supported for all RDDs.
      This should be one of the DBOI_ constants listed in the remarks section.
    </param>
    <param name="oFSIndex">
      A string or filespec object that specifies the name of an index file, including an optional drive and directory (no extension should be specified). Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.
      If <paramref name="oFSIndex" /> is not open by the current process, a runtime error is raised.
    </param>
    <param name="uOrder">
      The name of the order about which you want to obtain information or a number representing its position in the order list. (For single-order index files, the order name is the eight-letter index file name.) Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files. Invalid values are ignored.
      If no index file or order is specified, the controlling order is assumed.
    </param>
    <param name="uOrdVal">
      If specified, this parameter is used to change the value of a setting. The data type (and whether <paramref name="uOrdVal" /> can be specified), depends on the <paramref name="kInfoType" /> constant and is documented in the Constants section below.
    </param>
    <returns>
      If <paramref name="uNewSetting" /> is not specified, DBServer:OrderInfo() returns the current setting. If <paramref name="uNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      <include file="RTComments.xml" path="Comments/DBOI_Constants/*"  />      
    </remarks>
    <example>
      This example uses DBOI_NAME to save the current controlling order. After changing to a new controlling order, it uses the saved value to restore the original order:
      <code language="X#">
        oDBCust := Customer{}
        oDBCust:SetIndex("name")
        oDBCust:SetIndex("serial")
        cOrder := oDBCust:OrderInfo(DBOI_NAME)		// name
        oDBCust:SetOrder("serial")
        ? oDBCust:OrderInfo(DBOI_NAME)			// serial
        oDBCust:SetOrder(cOrder)
        ? oDBCust:OrderInfo(DBOI_NAME)			// name
      </code>
      This example returns the default index file extension (using DBOI_INDEXEXT) for two different data servers:
      <code language="X#">
        oDBSales := Sales{}
        oDBCust := Customer{}
        ? oDBSales:OrderInfo(DBOI_INDEXEXT)	  	// .CDX
        ? oDBCust:OrderInfo(DBOI_INDEXEXT)   		// .NTX
      </code>
      In this example, DBServer:OrderInfo(DBOI_INDEXEXT) checks for the existence of the CUSTOMER index file independent of the RDD associated with the data server:
      <code language="X#">
        oDBCust := Customer{}
        IF !File("customer" + oDBCust:OrderInfo(DBOI_INDEXEXT))
        oDBCust:CreateIndex("customer", "oDBCust:CustName")
        ENDIF
      </code>
      This example accesses the key expression of several orders from the same index file:
      <code language="X#">
        oDBCust := Customer{}
        oDBCust:SetOrder("serial")
        ? oDBCust:OrderInfo(DBOI_EXPRESSION,, "name")
        // Result: key expression for name order
        ? oDBCust:OrderInfo(DBOI_EXPRESSION,, "serial")
        // Result: key expression for serial order
      </code>
      In this example, ALL_CUST.MDX contains three orders named CUACCT, CUNAME, CUZIP. The DBOI_INDEXNAME constant is used to display the name of the index file using one of its orders:
      <code language="X#">
        oDBCust := Customer{}
        oDBCust:SetIndex("all_cust")
        ? oDBCust:OrderInfo(DBOI_INDEXNAME,, "cuname")
        // Returns: all_cust
      </code>
      The following example searches for CUNAME in the order list:
      <code language="X#">
        oDBCust := Customer{}
        oDBCust:SetIndex("cuacct")
        oDBCust:SetIndex("cuname")
        oDBCust:SetIndex("cuzip")
        ? oDBCust:OrderInfo(DBOI_NUMBER,, "cuname") // 2
      </code>
      This example retrieves the "for condition" from an order:
      <code language="X#">
        oDBCust := Customer{}
        oDBCust:SetOrderCondition("oDBCust:Acct &gt; 'AZZZZZ'")
        oDBCust:CreateIndex("customer", "oDBCust:Acct")
        oDBCust:OrderInfo(DBOI_CONDITION,, "customer")
        // Returns: oDBCust:Acct &gt; 'AZZZZZ'
      </code>
    </example>
  </DbServer.OrderInfo>
  <DbServer.OrderIsUnique>
    <summary>
      Return the status of the unique flag for a given order.
    </summary>
    <include file="Rdd.xml" path="doc/DbServer.OrderArgs/*" />
    <param name="cTarget">
      The name of an index file, including an optional drive and directory (no extension should be specified). Use this argument with <paramref name="uOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.
      If <paramref name="cTarget" /> is not open by the current process, a runtime error is raised.
    </param>
    <returns>
      The status of the indicated order's unique flag as a logical value.
    </returns>
    <example>
      This example shows the return value of DBServer:OrderIsUnique() using various orders:
      <code language="X#">
        oDBCust := Customer{}
        oDBCust:CreateOrder("Last", "Customer",;
        "oDBCust:LastName",, TRUE)
        oDBCust:CreateOrder("First", "Customer",;
        "oDBCust:FirstName")
        oDBCust:CreateIndex("j:\test\tmp\age",	;
        "oDBCust:Age",, TRUE)
        oDBCust:SetOrder("Last")
        ? oDBCust:OrderIsUnique()	 		// Result: TRUE, for order last
        ? oDBCust:OrderIsUnique("First")	// Result: FALSE
        ? oDBCust:OrderIsUnique("Age")		// Result: TRUE
      </code>
    </example>
  </DbServer.OrderIsUnique>
  <DbServer.OrderKeyAdd>
    <summary>
      Add a key to a custom built order.
    </summary>
    <include file="Rdd.xml" path="doc/DbServer.OrderArgs/*" />
    <param name="uKeyValue">
      A specific key value that you want to add for the current record.
      The data type must match that of the order. If not specified, the order's key expression is evaluated for
      the current record and added to the order.
    </param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      A custom built order is one that is not automatically maintained by the DBFCDX driver. You can determine if an order is custom built using DBServer:OrderInfo(DBOI_CUSTOM, ...). When you create such an order, it is initially empty.
      You must manually add and delete keys using DBServer:OrderKeyAdd() and DBServer:OrderKeyDel().
      DBServer:OrderKeyAdd() evaluates the key expression (or <paramref name="uKeyValue" />, if specified), then adds the key for the current record to the order. If the order has a for condition, the key will be added only if that condition is met, and then, only if it falls within the current scoping range.
      <note type="tip">RDDs may allow you to add several keys for the same record with consecutive calls to DBServer:OrderKeyAdd().</note>
      DBServer:OrderKeyAdd() will fail if:
      <list type="bullet">
        <item>The record pointer is positioned on an invalid record (i.e., at DBServer:EOF)</item>
        <item>The specified order is not custom built</item>
        <item>The specified order does not exist</item>
        <item>No order was specified and there is no controlling order</item>
      </list>
      <note type="tip">
        From the standard RDDs only the DBFCDX RDD supports Custom Indexes. This RDD does NOT support the use of the <paramref name="uKeyValue" /> parameter. It always uses the Key Expression to calculate the Key Values to insert.
      </note>
    </remarks>
    <example>
      This example creates a custom index and adds every fiftieth record to it:
      <code language="X#">
        oDBCust := Customer{}
        // Create custom built order that is initially empty
        oDBCust:SetOrderCondition(,,,,,,,,,,,,, TRUE)
        oDBCust:CreateIndex("last", "oDBCust:LastName")
        // Add every 50th record
        FOR n := 1 UPTO oDBCust:RecCount STEP 50
        oDBCust:GoTo(n)
        oDBCust:OrderKeyAdd()
        NEXT
      </code>
    </example>
  </DbServer.OrderKeyAdd>
  <DbServer.OrderKeyCount>
    <summary>
      Return the number of keys in an order.
    </summary>
    <include file="Rdd.xml" path="doc/DbServer.OrderArgs/*" />
    <remarks>
      DBServer:OrderKeyCount() counts the keys in the specified order and returns the result as a numeric value. If the order is not conditional and no scope has been set for it, DBServer:OrderKeyCount() is identical to DBServer:RecCount, returning the number of records in the data server. However, for a conditional order, there may be fewer keys than there are records, since some records may not meet the order's for condition or may not fall inside the scope specified by DBServer:OrderScope()—in counting the keys, DBServer:OrderKeyCount() respects the currently defined scope and for condition.
      <note type="tip">
        If there is no order in operation, DBServer:OrderKeyCount() will return 0 and not the value of DBServer:RecCount().
      </note>
    </remarks>
    <example>
      This example demonstrates using DBServer:OrderKeyCount() with various orders.
      <code language="X#">
        oDBCust := Customer{}
        // Assume 1000 total records,
        // 500 less than thirty years old, and
        // 895 making less than 50,000
        ? oDBCust:RecCount				// Result: 1000
        ? oDBCust:OrderKeyCount()			// Result: 0
        oDBCust:CreateIndex("age", "oDBCust:Age")
        oDBCust:SetOrderCondition("oDBCust:Age &lt; 30")
        oDBCust:CreateIndex("first", "oDBCust:FirstName")
        oDBCust:SetOrderCondition("oDBCust:Salary &lt; 50000")
        oDBCust:CreateIndex("last", "oDBCust:LastName")
        // age is the controlling order
        oDBCust:SetIndex("age")
        oDBCust:SetIndex("first")
        oDBCust:SetIndex("last")
        ? oDBCust:RecCount				// Result: 1000
        ? oDBCust:OrderKeyCount()			// Result: 1000
        ? oDBCust:OrderKeyCount("first")	// Result: 500
        ? oDBCust:OrderKeyCount(3)		// Result: 895
      </code>
    </example>
  </DbServer.OrderKeyCount>
  <DbServer.OrderKeyDel>
    <summary>
      Delete a key from a custom built order.
    </summary>
    <include file="Rdd.xml" path="doc/DbServer.OrderArgs/*" />
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      A custom built order is one that is not automatically maintained by the DBFCDX driver. You can determine if an order is custom built using DBServer:OrderInfo(DBOI_CUSTOM, ...). When you create such an order, it is initially empty.
      You must manually add and delete keys using DBServer:OrderKeyAdd() and DBServer:OrderKeyDel().
      DBServer:OrderKeyDel() will fail if:
      <list type="bullet">
        <item>
          The record pointer is positioned on an invalid record (for example, DBServer:EOF returns TRUE
          or the record pointer is positioned on a record that falls outside the orders' scope or for condition)
        </item>
        <item>The specified order is not custom built</item>
        <item>The specified order does not exist</item>
        <item>No order was specified and there is no controlling order</item>
      </list>
    </remarks>
    <example>
      This example creates a custom index, adds every fiftieth record to it, and deletes every hundredth record:
      <code language="X#">
        oDBCust := Customer{}
        // Create custom built order that is initially empty
        oDBCust:SetOrderCondition(,,,,,,,,,,,,, TRUE)
        oDBCust:CreateIndex("last", "oDBCust:LastName")
        // Add every 50th record
        FOR n := 1 UPTO oDBCust:RecCount STEP 50
        oDBCust:GoTo(n)
        oDBCust:OrderKeyAdd()
        NEXT
        // Remove every 100th record
        FOR n := 1 UPTO oDBCust:RecCount STEP 100
        oDBCust:GoTo(n)
        oDBCust:OrderKeyDel()
        NEXT
      </code>
    </example>
  </DbServer.OrderKeyDel>
  <DbServer.OrderKeyGoTo>
    <summary>
      Move to a record specified by its logical record number in the controlling order.
    </summary>
    <param name="nKeyNo">The logical record number. If the value specified does not satisfy the scope or for condition for the order, the record pointer is positioned at the end-of-file.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      DBServer:OrderKeyGoTo() is the complement to DBServer:OrderKeyNo(). DBServer:OrderKeyNo() returns the logical record number (i.e., its position in the controlling order) of the current record, and DBServer:OrderKeyGoTo() moves the record pointer to the specified logical record.
      DBServer:OrderKeyGoTo() sends a NotifyIntentToMove message before the operation. It also sends a NotifyRecordChange message upon successful completion.
      Tip: This method can be useful when displaying scroll bars. If the user clicks on a certain position on the scroll bar, you can move to the corresponding record by calling DBServer:OrderKeyGoTo().
    </remarks>
    <example>
      This example shows the difference between physical and logical record number:
      <code language="X#">
        oDBCust := Customer{}
        oDBCust:SetIndex("first") 	// Make records in first name order
        oDBCust:OrderKeyGoTo(100)	 	// Go to the 100th logical record
        ? oDBCust:RECNO			// Returns the physical record number
        ? oDBCust:OrderKeyNo()		// Returns 100, the logical record no
      </code>
    </example>
  </DbServer.OrderKeyGoTo>
  <DbServer.OrderKeyNo>
    <summary>
      Get the logical record number of the current record.
    </summary>
    <include file="Rdd.xml" path="doc/DbServer.OrderArgs/*" />
    <returns>
      The relative position of the current record in the specified order, as a numeric value. DBServer:OrderKeyNo() respects the scope and for condition of the order by returning zero if the record pointer is positioned on an invalid record or if DBServer:EOF is TRUE.
    </returns>
    <remarks>
      DBServer:OrderKeyNo() returns the logical record number of a key in an order. This in contrast to the physical record number (returned using DBServer:RecNo), which is the relative position of the record in the physical database file.
      DBServer:OrderKeyNo() sends a NotifyIntentToMove message before the operation.<br/>
      Tip: This method can be useful for displaying scroll bars and messages such as "Record 9 of 123" when viewing records in a browser.
      By default, DBServer:OrderKeyNo() operates on the currently selected work area. It will operate on an unselected work area if you specify it as part of an aliased expression.
    </remarks>
    <example>
      This example shows the difference between physical and logical record number:
      <code language="X#">
        oDBCust := Customer{}	// Assuming 1000 records
        oDBCust:SetIndex("first")	// Make records in first name order
        ? oDBCust:OrderKeyNo()	// Result: 1
        oDBCust:Skip(10)
        ? oDBCust:OrderKeyNo()	// Result: 11
        ? oDBCust:RECNO		// Result: Unknown
        oDBCust:GoBottom()
        ? oDBCust:OrderKeyNo()	// Result: 1000
        ? oDBCust:RECNO		// Result: Unknown
      </code>
    </example>
  </DbServer.OrderKeyNo>
  <DbServer.OrderKeyNo>
    <summary>
      A numeric value representing the logical record number of the current record.
      The DBServer:OrderKeyNo assign sends a NotifyRecordChange message upon successful completion.
    </summary>
    <value>
      A numeric value representing the logical record number of the current record.
      The DBServer:OrderKeyNo assign sends a NotifyRecordChange message upon successful completion.
    </value>
  </DbServer.OrderKeyNo>
  <DbServer.OrderKeyVal>
    <summary>
      The key value of the current record from the controlling order.
    </summary>
    <value>The key value of the current record from the controlling order.</value>
    <remarks>
      The key value of the current record from the controlling order. The data type is the same as the that of the key expression used to create the order. Use ValType() or UsualType() to determine the data type.
    </remarks>
  </DbServer.OrderKeyVal>
  <DbServer.OrderScope>
    <summary>
      Set the boundaries for scoping key values in the controlling order.
    </summary>
    <param name="nScope">A number specifying the top (TOPSCOPE) or bottom (BOTTOMSCOPE) boundary.</param>
    <param name="uValue">
      The top or bottom range of key values that will be included in the controlling order's current scope. <paramref name="uValue" /> can be an expression that matches the data type of the key expression in the controlling order or a code block that returns the correct data type.
      Omitting <paramref name="uValue" /> or specifying it as NIL has the special effect of resetting the specified scope to its original default. The default top range is the first logical record in the controlling order, and the default bottom range is the last logical record.
    </param>
    <returns>
      If <paramref name="uNewValue" /> is not specified, DBServer:OrderScope() returns the current setting. If <paramref name="uNewValue" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      The range of values specified using DBServer:OrderScope() is inclusive. In other words, the keys included in the scope will be greater than or equal the top boundary and less than or equal to the bottom boundary.
      <note type="tip">
        If you are using DbServer:OrderDescend() with Scopes, you need to swap the Top and Bottom scope values !
        <code language="X#">
          oServer:OrderScope (TOPSCOPE, cFrom)
          oServer:OrderScope (BOTTOMSCOPE, cTo)
          oServer:OrderDescend(,, TRUE)
          oServer:OrderScope (TOPSCOPE, cTo)
          oServer:OrderScope (BOTTOMSCOPE, cFrom)
        </code>
      </note>
    </remarks>
    <example>
      This example illustrates using DBServer:OrderScope() to set various scoping limitations on an order. Although not shown in the examples below, the GoTop() or some other pointer mechanism, should be used immediately following the OrderScope() method calls to invoke the scope itself. Checking for :EOF after the GoTop() call will also let you know if
      in fact any records even matched the scope conditions:
      <code language="X#">
        oDBFr := Friends{}
        oDBFr:SetIndex("age")
      </code><code language="X#">
        oDBFr:OrderScope(BOTTOMSCOPE, 25)	// Make 25 the lowest age in range
        oDBFr:OrderScope(TOPSCOPE, 30)	// Make 30 the highest age in range
        LIST Age					// Shows records with 25 &lt;= Age &lt;= 30
        oDBFr:OrderScope(BOTTOMSCOPE, 35)	// Change highest age to 35
        LIST Age					// Shows records with 25 &lt;= Age &lt;= 35
        oDBFr:OrderScope(TOPSCOPE, NIL)	// Reset top boundary
        LIST Age					// Shows records with Age &lt;= 35
        oDBFr:OrderScope(BOTTOMSCOPE, NIL)	// Reset bottom boundary
        LIST Age					// Shows all records
      </code>
    </example>
  </DbServer.OrderScope>
  <DbServer.OrderSkipUnique>
    <summary>
      Move the record pointer to the next or previous unique key in the controlling order.
    </summary>
    <param name="nDirection">Specifies whether the method will skip to the next or previous key. Omitting this value or specifying it as 1 skips to the next unique key. Specifying a negative value skips to the previous key.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      DBServer:OrderSkipUnique() allows you to make a non-unique order look like a unique order. Each time you use DBServer:OrderSkipUnique(), you are moved to the next (or previous) unique key, exactly as if you were skipping through a unique order. This method eliminates the problems associated with maintaining a unique order, while providing you with fast access to unique keys.
      DBServer:OrderSkipUnique() sends a NotifyIntentToMove message before the operation.  <br/>
      It also sends a NotifyRecordChange message upon successful completion.<br/>
    </remarks>
    <example>
      This examples uses DBServer:OrderSkipUnique() to build an array of unique last names beginning with the letter "J:"
      <code language="X#">
        METHOD LastUnique() CLASS Customer
        LOCAL aLast[0] AS ARRAY
        SELF:SetIndex("last")	 // Use the last name order
        ? SELF:OrderIsUnique()	 // Result: FALSE
        // Only look at the J's
        SELF:OrderScope(0, "J")
        SELF:OrderScope(1, "J")
        SELF:GoTop()
        DO WHILE !SELF:EOF		  // Add all the unique J
        AADD(aLast, Last)	 // last names to aLast
        SELF:OrderSkipUnique()
        ENDDO
        // Clear the scope
        SELF:OrderScope(0, NIL)
        SELF:OrderScope(1, NIL)
        RETURN aLast
      </code>
    </example>
  </DbServer.OrderSkipUnique>
  <DbServer.OrderTopScope>
    <summary>
      A key value representing the record of the top boundary in the range of key values that will be included in the controlling order's current scope.
    </summary>
    <value>A key value representing the record of the top boundary in the range of key values that will be included in the controlling order's current scope.</value>
  </DbServer.OrderTopScope>
  <DbServer.Pack>
    <summary>
      Remove deleted records from a database file.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Sends a NotifyFileChange message, if successful.<br/>
    </remarks>
  </DbServer.Pack>
  <DbServer.PaintedStructure>
    <summary>This returns a DBSTRUCT array based on the DataFields and Fieldspecs that were painter in the server editor.</summary>
    <value>A DBSTRUCT array based on the DataFields and Fieldspecs that were painter in the server editor.</value>
  </DbServer.PaintedStructure>
  <DbServer.RddInfo>
    <summary>
      Return and optionally change settings controlled directly by the RDD.
    </summary>
    <param name="kRDDInfoType">
      Specifies the setting.
      <include file="RTComments.xml" path="Comments/RddInfoParam/*"  />
    </param>
    <param name="uRDDVal">
      If specified, this parameter is used to change the value of a setting.
      The data type (and whether <paramref name="uNewSetting" /> can be specified), depends on the <paramref name="kRDDInfoType" />
      constant and is documented in the Constants section below.
    </param>
    <returns>
      If <paramref name="uNewSetting" /> is not specified, DBServer:RDDInfo() returns the current setting.
      If <paramref name="uNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      <include file="RTComments.xml" path="Comments/RddInfoRemarks/*"  />
    </remarks>
  </DbServer.RddInfo>
  <DbServer.RddName>
    <summary>
      A string representing the name of the database driver in use with this server.
    </summary>
    <value>A string representing the name of the database driver in use with this server.</value>
    <remarks>
      A string representing the name of the database driver in use with this server.
      The server can be specified as an instantiation parameter to the server. If no driver is set, the default driver is used; it can be set by RDDSetDefault() or DBSetDriver().
    </remarks>
  </DbServer.RddName>
  <DbServer.Rdds>
    <summary>This returns the list of RDDs that were passed to the DbServer constructor.</summary>
    <value>The list of RDDs that were passed to the DbServer constructor.</value>
  </DbServer.Rdds>
  <DbServer.ReadOnly>
    <summary>
      A logical value indicating whether the file was opened as a read-only file. This is determined by an instantiation parameter of the server.
    </summary>
    <value>A logical value indicating whether the file was opened as a read-only file. This is determined by an instantiation parameter of the server.</value>
    <example>
      This example function processes updates against the server only if the ReadOnly property is FALSE; otherwise, the function returns FALSE:
      <code language="X#">
        FUNCTION SalesUpdates(oDBServer)
        ...
        IF oDBServer:ReadOnly
        RETURN FALSE
        ELSE
        .
        . &lt;Statements TO update server&gt;
        .
        RETURN TRUE
        ENDIF
      </code>
    </example>
  </DbServer.ReadOnly>
  <DbServer.Recall>
    <summary>
      Recall those deleted records indicated by a specified scope.
    </summary>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      If no scope was passed and no scope was active, it sends a NotifyRecordChange, if the operation was successful.<br/>
      If a scope was used, it sends a NotifyFileChange message regardless of the number of records processed.<br/>
      If no server scope is set, it recalls the current record. On successful completion, the current record will be the last file record and DBServer:EOF will be TRUE.
    </remarks>
  </DbServer.Recall>
  <DbServer.RecallAll>
    <summary>
      Recall all deleted records in the table.
    </summary>
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyFileChange message upon completion.<br/>
      On successful completion, the current record will be the last file record and DBServer:EOF will be TRUE.
    </remarks>
  </DbServer.RecallAll>
  <DbServer.RecCount>
    <summary>
      The number of records in the current database file.
    </summary>
    <value>The number of records in the current database file.</value>
    <remarks>
      The number of records in the current database file. Filtering commands such as SET FILTER or SET DELETED have no effect on the return value. This access is identical to the :LastRec Access.
    </remarks>
    <example>
      This example uses RecCount to define an access method to return the Size of the data server:
      <code language="X#">
        CLASS Sales INHERIT DBServer
        ...
        ACCESS Size CLASS Sales
        RETURN (SELF:RecSize * SELF:RecCount) + ;
        SELF:Header + 1
      </code>
    </example>
  </DbServer.RecCount>
  <DbServer.RecNo>
    <summary>
      A numeric value representing the current record number, identifying the position of the record pointer.
    </summary>
    <value>A numeric value representing the current record number, identifying the position of the record pointer.</value>
    <remarks>
      A numeric value representing the current record number, identifying the position of the record pointer.
      Assigning a value to RecNo is equivalent to executing GoTo(); both reposition the record pointer on the given record.
      These two statements are equivalent:
      <code language="X#">
        oDBServer:RecNo := 1168
        oDBServer:GoTo(1168)
      </code>
      If the server contains a database file with 0 records, RecNo returns 1, BOF and EOF both return TRUE, and RecCount/LastRec return 0. If the record pointer is moved past the last record, RecNo returns LastRec + 1 and EOF returns TRUE. If an attempt is made to move before the first record, RecNo returns the record number of the first logical record in the database file and BOF returns TRUE.
      The DBServer:RecNo assign sends a NotifyIntentToMove message before the operation.
    </remarks>
    <example>
      This example queries RecNo after deliberately moving the record pointer:
      <code language="X#">
        CLASS Sales INHERIT DBServer
        ...
        FUNCTION RecNoDemo()
        LOCAL oDBSales AS Sales
        oDBSales := Sales{}
        oDBSales:GoTo(3)
        ? oDBSales:RECNO			// Result: 3
        oDBSales:GoTop()
        ? oDBSales:RECNO			// Result: 1
        oDBSales:GoBottom()
        ? oDBSales:RECNO			// Result: 10
      </code>
    </example>
  </DbServer.RecNo>
  <DbServer.RecordInfo>
    <summary>
      Retrieve information about the indicated record.
    </summary>
    <param name="kRecInfoType">
      The information retrieved depends on the constant specified
    </param>
    <param name="nRecordNumber">Indicates the record for which information is to be retrieved; if 0 or omitted, refers to the current record.</param>
    <param name="uRecVal">This parameter is reserved for RDDs that allow you to change the information rather than just retrieve it. None of the supplied RDDs (as outlined in the 'RDD Specifics' appendix in the Programmer's Guide) support this argument. Either omit the argument or specify it as NIL.</param>
    <returns>
      The data type of the return value depends on the value requested.
    </returns>
    <remarks>
      <include file="RTComments.xml" path="Comments/DBRI_Constants/*"  />
    </remarks>
  </DbServer.RecordInfo>
  <DbServer.RecSize>
    <summary>
      A numeric value representing the record length of the server in bytes.
    </summary>
    <value>A numeric value representing the record length of the server in bytes.</value>
    <example>
      This example uses RecSize to define an access method to return the Size of the data server:
      <code language="X#">
        CLASS Sales INHERIT DBServer
        ...
        ACCESS Size CLASS Sales
        RETURN (SELF:RecSize * SELF:RecCount) + ;
        SELF:Header + 1
      </code>
    </example>
  </DbServer.RecSize>
  <DbServer.Refresh>
    <summary>
      Reread the current record from the database, discarding any changes that have been made.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Sends a NotifyRecordChange message, if successful.<br/>
      This command discards all changes to the current record. It is useful as a way of implementing Undo in an application. However, it cannot roll back changes that have been committed with the DBServer:Commit(). Also, note that it applies only to the current record; the data server and the drivers do not buffer changes made to multiple records.
    </remarks>
  </DbServer.Refresh>
  <DbServer.Reindex>
    <summary>
      Recreate all active indexes for this server.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyCompletion message upon completion. Obviously all other users should be out of your system prior to executing this method.
    </remarks>
  </DbServer.Reindex>
  <DbServer.Relation>
    <summary>
      Return the linking expression of a specified relation.
    </summary>
    <param name="nRelation">The position of the desired relation in the list of current relations. The relations are numbered according to the order in which they were defined with DBServer:SetRelation().</param>
    <returns>
      A string containing the linking expression of the relation specified by <paramref name="nRelation" />. If there is no relation set for <paramref name="nRelation" />, DBServer:Relation() returns a NULL_STRING.
    </returns>
  </DbServer.Relation>
  <DbServer.RelationChildren>
    <summary>The returns the array of children that were registered with SetRelation()</summary>
    <value>The array of children that were registered with SetRelation()</value>
  </DbServer.RelationChildren>
  <DbServer.Replace>
    <summary>
      Replace one or several fields with a new expression, for all records that match a specified scope.
    </summary>
    <param name="acbExpression">The single expression to be evaluated to yield the replacement value or the array of expressions to be evaluated to yield the replacement values.</param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      If the specified scope is active, DBServer:Replace() sends a NotifyIntentToMove message before the operation. <br/>
      It also sends a NotifyFileChange message upon completion, whether successful or not.<br/>
      If no scope is used, on successful completion, the current record will be the last file record and DBServer:EOF will be TRUE.
    </remarks>
    <example>
      The following examples demonstrate how the DBServer:Replace() method can be used:
      <code language="X#">
        // Add 100 to the salaries of female employees
        oDBEmp:Replace({||Salary+100}, #Salary, {||Sex="F"})
        // Subtract 20 from grade, assign a raise of 100,
        // and establish a new raise date for those
        // employees that are newly assigned to Proj20
        oDBEmp:Replace({"GRADE-20", "100", "NewDate"}, {#Grade, #Raise, #RaiseDate},	;
        {|| NewAssignment(EmpNo) = Proj20})
        // Assign 0 to the credit status field of all records
        oDBEmp:Replace(0,#CreditStatus)
      </code>
    </example>
  </DbServer.Replace>
  <DbServer.ResetNotification>
    <summary>
      Resume the broadcasting of Notify messages to the server's attached clients (after DBServer:SuspendNotification() has been called).
    </summary>
    <remarks>
      This method is used in conjunction with DBServer:SuspendNotification(), which suspends the broadcasting of Notify messages.
      Note that DBServer:SuspendNotification() stacks its invocations. Therefore, for each call to DBServer:SuspendNotification(), there needs to be a corresponding call DBServer:ResetNotification().
    </remarks>
  </DbServer.ResetNotification>
  <DbServer.Retries>
    <summary>The setting that determines how often the DbServer object should retry operations that fail.</summary>
    <value>The setting that determines how often the DbServer object should retry operations that fail.</value>
  </DbServer.Retries>
  <DbServer.RLock>
    <summary>
      Lock a record for exclusive write access; other users can still make read-only reference to the record.
    </summary>
    <param name="nRecordNumber">
      The number of the record number to be locked.
      The indicated record is locked, and previous record locks are maintained.
      Note that this can be the current record: explicitly specifying the current record indicates that previous locks should be maintained.
      If omitted, or NIL or -1, the current record is locked and all previous record locks are released.
    </param>
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
  </DbServer.RLock>
  <DbServer.RLockList>
    <summary>
      An array of record numbers that are currently locked.
    </summary>
    <value>An array of record numbers that are currently locked.</value>
    <example>
      The following method processes all locked records in the data server:
      <code language="X#">
        CLASS Sales INHERIT DBServer
        ...
        METHOD ProcessLocked() CLASS Sales
        LOCAL siCount AS SHORTINT
        FOR siCount := 1 UPTO ALen(SELF:RLockList)
        SELF:GoTo(RLockList[siCount])
        // Process record
        NEXT
        SELF:Unlock()			// Release all locks
      </code>
    </example>
  </DbServer.RLockList>
  <DbServer.RLockVerify>
    <summary>
      Determine if the current record in this data server has any pending updates and lock it for exclusive write access if there are none.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />

    <remarks>
      This method checks for pending updates to the current record by comparing the values that were read to the record when the server was initially positioned on the record with the current values in the corresponding database record.
      If the values match, it signifies that no other user has modified the data since the user started working on it, and, therefore, that it is safe to lock the record and let the user continue with an update transaction. (Note that when locked, other users can still make read-only reference to the record.)
      If the values do not match, somebody else has changed the record, and the user should refresh the values from disk and restart the transaction. The application has to decide what to do about values that are different. Note that DBServer:Status can be used to determine the reason for the failure.
      This method is used for optimistic concurrency control. (See "Concurrency Control" in the Programmer's Guide  for more information.)
    </remarks>
  </DbServer.RLockVerify>
  <DbServer.Scope>
    <summary>
      The "scope" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope. The initial value of the scope is NIL.
    </summary>
    <value>The "scope" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope. The initial value of the scope is NIL.</value>
    <remarks>
      The following constants represent the range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands:
      
    </remarks>
    <example>
      This example illustrates how various Scope values affect the extent of a recall operation:
      <code language="X#">
        // RECALL FOR Last == "Smith" REST
        oDB:ForBlock := {|| Last == "Smith"}
        oDB:Scope := DBSCOPEREST
        oDB:Recall()
        // RECALL WHILE Last == "Smith" NEXT 10
        oDB:WhileBlock := {|| Last == "Smith"}
        oDB:Scope := 10
        oDB:Recall()
      </code>
    </example>
  </DbServer.Scope>
  <DbServer.Seek>
    <summary>
      Move to the record having the specified key value in the controlling order.
    </summary>
    <param name="uSearchExpr">Specifies the key value associated with the desired record.</param>
    <param name="lSoftSeek">
      Determines how the data server is positioned if the specified key value is not found: TRUE performs a soft seek; FALSE does not. If <paramref name="lSoftSeek" /> is omitted, the current SetSoftSeek() setting is used.
    </param>
    <param name="lLast">
      TRUE seeks the last occurrence of the specified key value. FALSE, the default, seeks the first occurrence. <paramref name="lLast" /> only applies to CDX indexes.
    </param>
    <returns>
      TRUE if the specified key value was found; otherwise, FALSE.
    </returns>
    <remarks>
      Sends a NotifyIntentToMove message before the operation.<br/>
      DBServer:Seek() moves to the first logical record whose key value is equal to <paramref name="uKey" />. If such a record is found, it becomes the current record and DBServer:Seek() returns TRUE. Otherwise, DBServer:Seek() returns FALSE and the positioning of the data server is as follows: for a normal (not soft) seek, the data server is positioned to DBServer:LastRec + 1 and DBServer:EOF returns TRUE; for a soft seek, the data server is positioned to the first record whose key value is greater than the specified key value. If no such record exists, the data server is positioned to DBServer:LastRec + 1 and DBServer:EOF returns TRUE.
      For a data server with no controlling order, DBServer:Seek() has no effect.
      <note type="tip">
        Logical records:	DBServer:Seek() operates on logical records. Records are processed in controlling order. If a filter is set, only records which meet the filter condition are considered.
        Shared mode:	For a shared file, moving to a different record can cause updates to the current record to become visible to other processes. For more information, refer to "Concurrency Control" in the Programmer's Guide.
      </note>
    </remarks>
    <example>
      In this example, DBServer:Seek() moves the pointer to the record in the database, EMPLOYEE, in which the value in the control field sleLastName matches a record in the database:
      <code language="X#">
        IF Employee:Seek( UPPER( SELF:oDCsleLastName:Value ) )
        Employee:ViewRecord()
        ELSE
        QOut("Not found")
        END
      </code>
    </example>
  </DbServer.Seek>
  <DbServer.Select>
    <summary>Select the workarea that the DbServer uses.</summary>
    <returns>The previous workarea that was selected.</returns>
  </DbServer.Select>
  <DbServer.SelectionWorkArea>
    <summary>The workarea number of the parent area when the dbserver is a child in a relation.</summary>
    <value>The workarea number of the parent area when the dbserver is a child in a relation.</value>
  </DbServer.SelectionWorkArea>
  <DbServer.SetDataField>
    <summary>
      Assign a DataField object to a specified field.
    </summary>
    <param name="nFieldPosition">The number of the desired field.</param>
    <param name="oDataField">The data field to assign.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      The new field is verified to be compatible with the actual database field, if one is open. This method is normally used only during instantiation of a data server, most often in Init() methods of subclasses. For example, the code generated by the DBServer Editor uses this method.
    </remarks>
  </DbServer.SetDataField>
  <DbServer.SetFilter>
    <summary>
      Set a filter condition.
    </summary>
    <param name="cbFilterBlock">The code block that expresses the filter condition in executable form. If the code block is omitted, the string version of the filter expression is macro-compiled into a code block.</param>
    <param name="cFilterText">The filter condition. If omitted, the DBServer:Filter access method returns a NULL_STRING.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Both arguments specify the filter expression, one in the form of a code block, one in the form of a string. Both arguments are optional, but at least one must be provided. The reason for specifying both versions is that a compiled code block is faster, while the string version can be reported back through the Filter access method. Obviously, if both forms are specified, they should define the same expression.
    </remarks>
    <example>
      The following examples demonstrate the various methods of setting a filter using the DBServer:SetFilter(). The filter condition is customer numbers (CustNo) exceeding 20,000. Note the user of the GoTop() method to invoke the filter expression by moving the record pointer.
      <code language="X#">
        // Codeblock specified only
        oDBCust:SetFilter({||CustNo &gt; 20000})
        oDBCust:GoTop()
        // Codeblock and text to describe the filter text specified
        oDBCust:SetFilter({||CustNo &gt; 20000}, "CustNo &gt; 20000")
        oDBCust:GoTop()
        // Filter text specified only, which is compiled into a code block
        oDBCust:SetFilter(, "CustNo &gt; 20000")
        oDBCust:GoTop()
        // Filter text specified only, which is compiled into a code block
        oDBCust:SetFilter(, [ Gender = '] + SELF:cGender + ['] )
        oDBCust:GoTop()
      </code>
    </example>
  </DbServer.SetFilter>
  <DbServer.SetIndex>
    <summary>
      Open an index file and select its order as the controlling order, if this is the first index being opened.
    </summary>
    <param name="oFSIndex">
      A string or filespec object that specifies the index file. File type defaults to the native type for the driver (RDD).
    </param>
    <param name="cIndexFileName">
      The index file. File type defaults to the native type for the driver (RDD).
    </param>

    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyFileChange message, if successful.<br/>
      If the index file contains more than one order, the first one is set as the controlling order. The server is positioned to the first logical record in the controlling order.
    </remarks>
    <example>
      The following example opens multiple index files:
      <code language="X#">
        oSales := DBServer{"sales"}
        oSales:SetIndex("firstname")
        oSales:SetIndex("lastname")
        IF oSales:Seek(cLast)
        IF oSales:Deleted() .AND. RLock()
        oSales:Recall()
        ENDIF
        ENDIF
      </code>
    </example>
  </DbServer.SetIndex>
  <DbServer.SetOrder>
    <summary>
      Select an order from one of the open index files as the controlling order.
    </summary>

    <param name="uOrder">The order can be identified by an order number, the position of the order in the order list, or a name.</param>
    <param name="oFSIndex">If the order is specified by an order name that is not unique within the order list, the index file name can be specified, either as a FileSpec object or as a file name in string format, with or without file type. File type defaults to the native type for the driver (RDD). Note, however, that SetOrder() does not open the index file, it refers only to orders within already opened files.</param>
    <param name="cIndexFileName">If the order is specified by an order name that is not unique within the order list, the index file name can be specified, either as a FileSpec object or as a file name in string format, with or without file type. File type defaults to the native type for the driver (RDD). Note, however, that SetOrder() does not open the index file, it refers only to orders within already opened files.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Sends a NotifyFileChange message, if successful.<br/>
      The server remains positioned on the same record after the controlling order is changed. Note that when a dbServer object is first instantiated, and the CDX index driver is used and auto-open indexes is set to TRUE, then the tag that will be opened will be the first tag identified alphabetically – NOT the sequence that you created the tags in. Thus a SetOrder() should typically be set before performing any sort of Seek() operation to ensure that the proper index tag is set.
    </remarks>
  </DbServer.SetOrder>
  <DbServer.SetOrderCondition>
    <summary>
      Set conditions that is applied to index and order creation. If SetOrderCondition() has not been called, order creation is subject to the general server scope. If neither has been set, orders are not conditional.
    </summary>
    <param name="cFor">A string that specifies the FOR condition for the order. If you do not need this information, you can specify a NULL_STRING.</param>
    <param name="cbForBlock">
      A code block that defines a FOR condition that each record within the scope must meet in order to be processed. Only those records that meet the condition are included in the resulting order. Duplicate key values are not added to the index file.
      The FOR condition is stored as part of the index file and used when updating or recreating the index using the DBServer:Reindex() method. The FOR clause provides the only scoping that is maintained for all database changes. All other scope conditions create orders that do not reflect database updates.
      If a string is provided, it is compiled into a code block dynamically. It can be no longer than 250 characters under the DBFNTX driver.
    </param>
    <param name="lAll">Specifies all orders in the current or specified work area. ALL is the default scope of INDEX ON.</param>
    <param name="cbWhileBlock">
      A code block that specifies another condition that must be met by each record as it is processed. As soon as a record is encountered that causes the condition to fail, the order creation terminates. If a WHILE clause is specified, the data is processed in the controlling order.
      The WHILE condition is transient (that is, it is not stored in the file and not used for index updates and reindexing purposes). The WHILE condition creates temporary orders, but these orders are not updated.
      Using the WHILE condition is more efficient and faster than using the FOR condition. The WHILE condition processes only data for which <paramref name="cbWhileCondition" /> is TRUE from the current position. The FOR condition, in contrast, processes all data in the data source.
    </param>
    <param name="cbEvalBlock">The code block that is evaluated for every record that is processed, or as specified below. This code block allows the application to intercede during the order creation, which might be quite lengthy; it might be used to update the screen, for example, showing progress on a thermometer-type display or in the status bar.</param>
    <param name="nStep">
      The numeric expression that modifies the number of times <paramref name="cbEvalBlock" /> is evaluated. This argument offers a performance enhancement by evaluating the condition for every nth record instead of for every record ordered. To step through every record, specify a value of 0 or omit the parameter.
    </param>
    <param name="nStart">The record number to start the evaluation from. To start at the top, specify a value of 0 or omit the parameter.</param>
    <param name="nNext">
      The number of records to process, starting at <paramref name="nStart" />. Specify 0 to ignore this argument.
    </param>
    <param name="nRecno">A single record number to process. Specify 0 to ignore this argument.</param>
    <param name="lRest">Specifies whether the scope of processing is all records, or, starting with the current record, all records to the end of file. This argument corresponds to the REST and ALL clauses of record processing commands. If TRUE , the scope is REST; otherwise, the scope is ALL records.</param>
    <param name="lDescending">Specifies whether the keyed pairs be sorted in decreasing or increasing order of value. If TRUE the order is in descending order otherwise the order is in ascending order.</param>
    <param name="lAdditive">Specifies whether open orders should remain open while the new order is being created. TRUE specifies that they should remain open. FALSE specifies that all open order should be closed. The default is FALSE.</param>
    <param name="lCurrent">Specifies whether only records in the controlling order—and within the current range as specified by DBServer:OrderScope()—will be included in this order. TRUE specifies that the controlling order and range should be used to limit the scope of the newly created order. FALSE specifies that all records in the database file are included in the order. The default is FALSE.</param>
    <param name="lCustom">Specifies whether the new order will be a custom built order (for RDDs that this feature). TRUE specifies that a custom built order will be created. A custom built order is initially empty, giving you complete control over order maintenance. The system does not automatically add and delete keys from a custom built order. Instead, you explicitly add and delete keys using DBServer:OrderKeyAdd() and DBServer:OrderKeyDel(). FALSE specifies a standard, system-maintained order. The default is FALSE.</param>
    <param name="lNoOptimize">Specifies whether the FOR condition will be optimized (for RDDs that support this feature). TRUE optimizes the FOR condition, and FALSE does not. The default is FALSE.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
  </DbServer.SetOrderCondition>
  <DbServer.SetRelation>
    <summary>
      Set a relation from this server to the child server.
    </summary>
    <param name="oDBChild">
      The server attached to the child server must be specified as a DBServer object (not as an alias). If <paramref name="oDBChild" /> is omitted, all relations for this server are removed (the recommended way of doing this is the ClearRelations() method).
    </param>
    <param name="uRelation">The relation code block for the server or the name or symbol representing the field from this server; a code block is constructed and macro-compiled</param>
    <param name="cRelation">When the relation is specified as a code block, a string version of the code block can be provided as well; it is returned by the Relation() method.</param>
    <param name="lSelective">Should this be a selective relation ?</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Sends a NotifyRecordChange message to the child server, if successful.<br/>
      As always, the child work area should have a controlling index that matches the expression.
    </remarks>
    <example>
      The API can take these forms:
      <code language="X#">
        oDBCustomer:SetRelation(oDBOrders, {||_FIELD-&gt;CustNo},"CustNo")
        oDBCustomer:SetRelation(oDBOrders, #CustNo)
        oDBCustomer:SetRelation(oDBOrders, {#LastName, #Initial, #FirstName})
      </code>
    </example>
  </DbServer.SetRelation>
  <DbServer.SetSelectiveRelation>
    <summary>
      Set a selective relation from this server to the child server; standard database operations are restricted to those records that match the relation.
    </summary>
    <param name="oDBChild">
      The server attached to the child server must be specified as a DBServer object (not as an alias). If <paramref name="oDBChild" /> is omitted, all relations for this server are removed (the recommended way of doing this is the ClearRelations() method).
    </param>
    <param name="uRelation">The relation code block for the server or the name or symbol representing the field from this server; a code block is constructed and macro-compiled</param>
    <param name="cRelation">When the relation is specified as a code block, a string version of the code block can be provided as well; it is returned by the Relation() method.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Sends a NotifyRecordChange message to the child server, if successful.<br/>
      As always, the expression should match or be a partial index of the controlling index of the child's work area.
    </remarks>
    <example>
      The API can take these forms:
      <code language="X#">
        oDBCustomer:SetSelectiveRelation(oDBOrders, {||_FIELD-&gt;CustNo},"CustNo")
        oDBCustomer:SetSelectiveRelation(oDBOrders, #CustNo)
        oDBCustomer:SetSelectiveRelation(oDBOrders, {#LastName,#Initial,#FirstName})
      </code>
    </example>
  </DbServer.SetSelectiveRelation>
  <DbServer.Shared>
    <summary>
      A logical value indicating whether the server is sharable or exclusive.
    </summary>
    <value>A logical value indicating whether the server is sharable or exclusive.</value>
    <remarks>
      A logical value indicating whether the server is sharable or exclusive. DBServer:Shared is determined by an instantiation parameter of the server; if not specified, the default set by SetExclusive() is used.
    </remarks>
    <example>
      This example function processes updates against the server only if the Shared property is FALSE; otherwise, the function returns FALSE:
      <code language="X#">
        FUNCTION SalesUpdates(oDBServer)
        ...
        IF oDBServer:Shared
        RETURN FALSE
        ELSE
        .
        . &lt;Statements TO update server&gt;
        .
        RETURN TRUE
        ENDIF
      </code>
    </example>
  </DbServer.Shared>
  <DbServer.Skip>
    <summary>
      Move the record pointer forward or backward a specified number of records.
    </summary>
    <param name="nRecordCount">The number of records to move, relative to the current record. A positive value means to move forward, and a negative value means to move backward. If omitted, +1 is assumed.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyRecordChange message, if a move was made.<br/>
      If DBServer:Skip() positions the DBServer beyond the last record, DBServer:EOF will be set and the DBServer will be positioned on the last record.
    </remarks>
  </DbServer.Skip>
  <DbServer.Sort>
    <summary>
      Copy records to another database file in sorted order. If neither conditions nor scope is passed to the method, it is subject to the general server scope.
    </summary>
    <param name="cTarget">The file to which the records is copied.</param>
    <param name="oFSTarget">A string or filespec object that specifies the file to which the records is copied.</param>
    <param name="cTarget">The file to which the records is copied.</param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyRecordChange message upon completion.<br/>
      This method does not open the new file, it simply creates the file on disk. If you want to open it afterwards, you simply instantiate it directly:
      <code language="X#">
        oDB1:Sort(oFSTarget)
        oDB2 := DBServer{oFSTarget}
      </code>
    </remarks>
  </DbServer.Sort>
  <DbServer.Status>
    <summary>
      A HyperLabel object identifying the status after the last operation. If
    </summary>
    <value>A HyperLabel object identifying the status after the last operation. If</value>
    <remarks>
      A HyperLabel object identifying the status after the last operation. If the last operation was successful, DBServer:Status returns NULL_OBJECT; if something went wrong (whether it raised an error condition or merely returned a failure code), DBServer:Status returns an informative HyperLabel object.
      By accessing the properties of this hyperlabel, you can retrieve not only a description of the condition that was raised, but also context-sensitive help on the condition that was raised.
    </remarks>
    <example>
      The following examples invoke several DBServer:Status access/assign methods:
      <code language="X#">
        oDataServer:Status:Caption
        oDataServer:Status:Description
        oDataServer:Status:HelpContext
      </code>
    </example>
  </DbServer.Status>
  <DbServer.Sum>
    <summary>
      Calculate the sum of a series of numeric expressions.
    </summary>
    <param name="acbExpression">The single expression that Sum() operates on or the array of expressions that Sum() operates on.</param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      An array that contains the sums for each expression or field specified.
    </returns>
    <remarks>
      Sends a NotifyIntentToMove message before the operation.<br/>
      On successful completion, the current record will be the last file record and DBServer:EOF will be TRUE.
    </remarks>
    <example>
      The following example calculates the totals of the salaries, commissions, and withholdings for department 1348:
      <code language="X#">
        aSums := oDB1:Sum({#Salary, #Commission, #Withholdings},{||Department=1348})
        ? "Salary:", aSums[1]
        ? "Commission:", aSums[2]
        ? "Withholdings:", aSums[3]
      </code>
    </example>
  </DbServer.Sum>
  <DbServer.SuspendNotification>
    <summary>
      Suspend the broadcasting of Notify messages to the server's attached clients.
    </summary>
    <remarks>
      This method is useful, for example, when the server is moving through the database and the server is ultimately restored to its original position. Therefore, there is no reason to notify the clients of the server of a change in position within the database.
      Note that DBServer:SuspendNotification() stacks its invocations. Therefore, for each call to DBServer:SuspendNotification(), there needs to be a corresponding call DBServer:ResetNotification().
    </remarks>
  </DbServer.SuspendNotification>
  <DbServer.TableExt>
    <summary>Return the Extension for the opened DBF. This is normally .DBF but may be different if a file with a different extension was opened.</summary>
    <value>The Extension for the opened DBF</value>
  </DbServer.TableExt>
  <DbServer.Total>
    <summary>
      Aggregate records by key value, producing grouped summarizations, and write the aggregate records to another database.
    </summary>
    <param name="oFSTarget">A string or filespec object that specifies the file to which the summary data is written.</param>
    <param name="cbKeyField">The key field in this server that is the basis for the summarization. Note that for the summarization to produce correct results, the table should be indexed or sorted on this key field.</param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      Sends a NotifyIntentToMove message before the operation. <br/>
      Sends a NotifyRecordChange message upon completion.<br/>
    </remarks>
    <example>
      This method does not open the new file, it simply creates the file on disk. If you want to open it afterwards, you simply instantiate it directly.
      <code language="X#">
        IF oDB1:Total(oFSTarget)
        oDB2 := DBServer{oFSTarget}
        ELSE
        ...
        ENDIF
      </code>
    </example>
  </DbServer.Total>
  <DbServer.UnLock>
    <summary>
      Release a specified lock or all locks.
    </summary>
    <param name="nRecordNumber">The number of the desired record. If 0 or omitted, all locks for this server are released, record locks as well as file locks.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
  </DbServer.UnLock>
  <DbServer.Update>
    <summary>
      Update this server with data from another server or table.
    </summary>
    <param name="oDbServer">The database that provides the new data.</param>
    <param name="cbKey">The key field that defines how records are matched between the servers.</param>
    <param name="lRandomFlag">Indicates if the records in the other database are allowed to be in random order. If FALSE or not specified, the other database must be ordered on the specified key.</param>
    <param name="cbReplace">Code block that performs the update operations.</param>
    <include file="RDD.xml" path="doc/DbServer.LogicReturn/*" />
    <remarks>
      <note type="tip">This method requires a file lock or exclusive access.</note>
      Sends a NotifyFileChange message upon completion.<br/>
      There are two different formulations of the matching relationship between the two servers. If <paramref name="lRandomFlag" /> is TRUE, this server must be indexed on the specified key, but the other server can be in any order; if <paramref name="lRandomFlag" /> is not specified or is FALSE, both servers must be indexed or sorted on the specified key.
      If there is more than one record in this server with matching key fields, only the first one is updated.
    </remarks>
  </DbServer.Update>
  <DbServer.Used>
    <summary>
      A logical value indicating whether the server is currently open
    </summary>
    <value>A logical value indicating whether the server is currently open</value>
    <remarks>
      A logical value indicating whether the server is currently open. DBServer:Used returns TRUE if the server was successfully opened, and FALSE if the server has been closed or if a serious error has occurred that renders the table unusable. In that case, more information can be retrieved through DBServer:Status or by intercepting the error condition.
      If DBServer:Used is FALSE, the properties and methods return NIL, FALSE, or some similar null value.
    </remarks>
  </DbServer.Used>
  <DbServer.WhileBlock>
    <summary>
      The "WHILE block" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope
    </summary>
    <value>The "WHILE block" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope</value>
    <remarks>
      The "WHILE block" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope. The access always returns a code block.
      Specifying a WHILE block makes the method process all remaining records until the WHILE block evaluates FALSE, subject to other scope settings, of course. Specifying a WHILE block makes the scope default to REST.
    </remarks>
    <example>
      This example assigns a code block to WhileBlock to limit the scope of a recall operation:
      <code language="X#">
        // RECALL WHILE Last == "Smith" ALL
        oDB:WhileBlock := {|| Last == "Smith"}
        oDB:Scope := DBSCOPEALL
        oDB:Recall()
      </code>
    </example>
  </DbServer.WhileBlock>
  <DbServer.WorkArea>
    <summary>
      A number representing the workarea of the server
    </summary>
    <value>A number representing the workarea of the server</value>
  </DbServer.WorkArea>
  <DbServer.Zap>
    <summary>
      Permanently remove all records from the server and release the disk space.
    </summary>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">This method requires exclusive access.</note>
      Sends a NotifyFileChange message upon completion.<br/>
    </remarks>
  </DbServer.Zap>
  <OrderSpec>
    <summary>
      OrderSpec class was designed to model index information at the order level - not file level - and complement the DBFileSpec class.
    </summary>
    <remarks>
      Instantiation requires a DBFileSpec object. Each order will require a separate OrderSpec object.
      For single-order index formats such as DBFNTX, this is equivalent to one OrderSpec object per physical file.
      For multi-order index formats such as DBFCDX, this would mean multiple OrderSpec objects for one physical file.
      For more information on the conditional index order instance variables, refer to the OrdCondSet() function.
    </remarks>
  </OrderSpec>
  <OrderSpec.ctor>
    <summary>
      Instantiates an OrderSpec object using an existing DBFileSpec object.
    </summary>
    <param name="oDBFS">An existing DBFileSpec object.</param>
    <returns>
      An OrderSpec object.
    </returns>
    <example>
      <code language="X#">
        oDB := DBFileSpec{"C:\TEST\CUSTOMER.DBF"}
        oOrd1 := OrderSpec{oDB}
      </code>
    </example>
  </OrderSpec.ctor>
  <OrderSpec.Add>
    <summary>
      A logical value specifying whether open orders should remain open while the new order is being created.
    </summary>
    <value>A logical value specifying whether open orders should remain open while the new order is being created.</value>
    <remarks>
      A logical value specifying whether open orders should remain open while the new order is being created. TRUE specifies that they should remain open. FALSE specifies that all open orders should be closed. The default is FALSE.
    </remarks>
  </OrderSpec.Add>
  <OrderSpec.All>
    <summary>
      A logical value determining whether the record scope is for all records in the DBF (TRUE)
    </summary>
    <value>A logical value determining whether the record scope is for all records in the DBF (TRUE)</value>
    <remarks>
      Used for a conditional index. A logical value determining whether the record scope is for all records in the DBF (TRUE). Defaults to FALSE so that OrderSpec:Records and OrderSpec:Interval can be used.
    </remarks>
  </OrderSpec.All>
  <OrderSpec.AutoOpen>
    <summary>
      Determines if this index file will open when the DBF file is opened.
    </summary>
    <value>Determines if this index file will open when the DBF file is opened.</value>
  </OrderSpec.AutoOpen>
  <OrderSpec.AutoOrder>
    <summary>
      Determines if this index file will set the first order when it is opened.
    </summary>
    <value>Determines if this index file will set the first order when it is opened.</value>
  </OrderSpec.AutoOrder>
  <OrderSpec.AutoShare>
    <summary>
      Determines if this index file will be opened in the same share mode as the DBF file.
    </summary>
    <value>Determines if this index file will be opened in the same share mode as the DBF file.</value>
  </OrderSpec.AutoShare>
  <OrderSpec.Current>
    <summary>
      A logical value determining whether only those records in the controlling order and in the scope are included in this order. Defaults to FALSE so that all records in DBF are included.
    </summary>
    <value>A logical value determining whether only those records in the controlling order and in the scope are included in this order. Defaults to FALSE so that all records in DBF are included.</value>
  </OrderSpec.Current>
  <OrderSpec.Custom>
    <summary>
      A logical value determining if this is to be a custom order. Valid for RDDs that support custom orders. Defaults to FALSE for a non-custom order.
    </summary>
    <value>A logical value determining if this is to be a custom order. Valid for RDDs that support custom orders. Defaults to FALSE for a non-custom order.</value>
  </OrderSpec.Custom>
  <OrderSpec.DBF>
    <summary>
      The DBFileSpec object with which this OrderSpec object is associated.
    </summary>
    <value>The DBFileSpec object with which this OrderSpec object is associated.</value>
  </OrderSpec.DBF>
  <OrderSpec.Descend>
    <summary>
      A logical value determining if this is to be a descending order. Defaults to FALSE for ascending order.
    </summary>
    <value>A logical value determining if this is to be a descending order. Defaults to FALSE for ascending order.</value>
  </OrderSpec.Descend>
  <OrderSpec.EvalBlock>
    <summary>
      The code block to be evaluated based upon OrderSpec:Interval. The code block should return a TRUE value.
    </summary>
    <value>The code block to be evaluated based upon OrderSpec:Interval. The code block should return a TRUE value.</value>
  </OrderSpec.EvalBlock>
  <OrderSpec.FileName>
    <summary>
      The drive, path and file name of the order. The drive and path default to either the current window's drive and path or to the drive and path used in SetDefault(), if omitted.
    </summary>
    <value>The drive, path and file name of the order. The drive and path default to either the current window's drive and path or to the drive and path used in SetDefault(), if omitted.</value>
  </OrderSpec.FileName>
  <OrderSpec.ForBlock>
    <summary>
      The FOR condition code block to build this order.
    </summary>
    <value>The FOR condition code block to build this order.</value>
  </OrderSpec.ForBlock>
  <OrderSpec.ForCond>
    <summary>
      The FOR condition string used to build this order.
    </summary>
    <value>The FOR condition string used to build this order.</value>
  </OrderSpec.ForCond>
  <OrderSpec.HPLock>
    <summary>
      A logical value determining whether the DBFNTX RDD will use the HPLocking scheme for building this order. The default is FALSE, i.e., no HPLocking.
    </summary>
    <value>A logical value determining whether the DBFNTX RDD will use the HPLocking scheme for building this order. The default is FALSE, i.e., no HPLocking.</value>
  </OrderSpec.HPLock>
  <OrderSpec.Interval>
    <summary>
      An integer determining the interval for the execution of OrderSpec:EvalBlock during order building.
    </summary>
    <value>An integer determining the interval for the execution of OrderSpec:EvalBlock during order building.</value>
  </OrderSpec.Interval>
  <OrderSpec.IsCond>
    <summary>
      A logical value indicating whether this is a conditional order. This is assigned TRUE internally when any of the conditional ASSIGNs are assigned values and is not required to be assigned manually to create a conditional order.
    </summary>
    <value>A logical value indicating whether this is a conditional order. This is assigned TRUE internally when any of the conditional ASSIGNs are assigned values and is not required to be assigned manually to create a conditional order.</value>
  </OrderSpec.IsCond>
  <OrderSpec.KeyInfo>
    <summary>
      The 1-D, 4-element array containing the structure of the OrderSpec object.
    </summary>
    <value>The 1-D, 4-element array containing the structure of the OrderSpec object.</value>
    <remarks>
      The 1-D, 4-element array containing the structure of the OrderSpec object.
      Each subarray is comprised of four elements, which contain the following order key information:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>ORD_KEYTYPE</term>
          <description>Data type of index key.</description>
        </item>
        <item>
          <term>ORD_KEYCOUNT</term>
          <description>Number of keys included in this order.</description>
        </item>
        <item>
          <term>ORD_KEYSIZE</term>
          <description>Length of this order key.</description>
        </item>
        <item>
          <term>ORD_KEYDEC</term>
          <description>Number of decimals in this order</description>
        </item>
      </list>
    </remarks>
  </OrderSpec.KeyInfo>
  <OrderSpec.LockOffSet>
    <summary>
      The current NTX locking offset as a numeric value.
    </summary>
    <value>The current NTX locking offset as a numeric value.</value>
  </OrderSpec.LockOffSet>
  <OrderSpec.NoOptimize>
    <summary>
      A logical value determining whether the FOR condition used to build this order should be optimized. Valid for RDDs that support query optimizations. Defaults to FALSE for no optimization.
    </summary>
    <value>A logical value determining whether the FOR condition used to build this order should be optimized. Valid for RDDs that support query optimizations. Defaults to FALSE for no optimization.</value>
  </OrderSpec.NoOptimize>
  <OrderSpec.OrderAdd>
    <summary>
      Adds order information from an existing index file to the OrderSpec object and associates this OrderSpec object with the DBFileSpec object used for instantiation.
    </summary>
    <param name="oFS">A string or filespec object that specifies the full path to the index file or a FileSpec object of the index file.</param>
    <param name="uOrder">The order name or numeric position if using multi-order files.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <example>
      The following examples illustrate several different types of orders you can add:
      <code language="X#">
        // add orders from a multi-order file:
        oDB := DBFileSpec{, "DBFCDX"}
        IF oDB:Find()
        oOrd1 := OrderSpec{oDB}
        oOrd2 := OrderSpec{oDB}
        oOrd3 := OrderSpec{oDB}
        oOrd1:OrderAdd("C:\TEST\customer.cdx", "FirstName")
        oOrd2:OrderAdd("C:\TEST\customer.cdx", "LastName")
        oOrd3:OrderAdd("C:\TEST\customer.cdx", "CustNum")
        ENDIF
        // add orders from single-order files:
        oDB := DBFileSpec{, "DBFNTX"}
        IF oDB:Find()
        oOrd1 := OrderSpec{oDB}
        oOrd2 := OrderSpec{oDB}
        oOrd3 := OrderSpec{oDB}
        oOrd1:OrderAdd("C:\TEST\cust1.ntx")
        oOrd2:OrderAdd("C:\TEST\cust2.ntx")
        oOrd3:OrderAdd("C:\TEST\cust3.ntx")
        ENDIF
      </code>
    </example>
  </OrderSpec.OrderAdd>
  <OrderSpec.OrderBlock>
    <summary>
      The code block of the index key expression used to create this order.
    </summary>
    <value>The code block of the index key expression used to create this order.</value>
  </OrderSpec.OrderBlock>
  <OrderSpec.OrderCreate>
    <summary>
      Create new orders, and if empty, fills in OrderSpec information and associates the created order with the DBFileSpec object.
    </summary>
    <param name="oFS">A string or filespec object that specifies the full path to the target file.</param>
    <param name="cOrder">The order name. Used for multi-order index files.</param>
    <param name="cKeyValue">A string of the index key expression.</param>
    <param name="cbKeyValue">A code block of the index key expression.</param>
    <param name="lUnique">A logical to determine if this is to be a unique order.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <example>
      The following examples illustrate several different types of orders you can create:
      <code language="X#">
        // create orders for a multi-order file:
        oDB := DBFileSpec{, "DBFCDX"}
        IF oDB:Find()
        oOrd1 := OrderSpec{oDB}
        oOrd2 := OrderSpec{oDB}
        oOrd3 := OrderSpec{oDB}
        oOrd1:OrderCreate("C:\TEST\customer.cdx", "FirstName", "FirstName")
        oOrd2:OrderCreate("C:\TEST\customer.cdx", "LastName", "LastName")
        oOrd3:OrderCreate("C:\TEST\customer.cdx", "CustNum", "CustNum")
        ENDIF
        // create orders for single-order files:
        oDB := DBFileSpec{, "DBFNTX"}
        IF oDB:Find()
        oOrd1 := OrderSpec{oDB}
        oOrd2 := OrderSpec{oDB}
        oOrd3 := OrderSpec{oDB}
        oOrd1:OrderCreate("C:\TEST\cust1.ntx", , "FirstName")
        oOrd2:OrderCreate("C:\TEST\cust2.ntx", , "LastName")
        oOrd3:OrderCreate"C:\TEST\cust3.ntx", , "CustNum")
        ENDIF
        // create some orders using instance variables for a multi-order file:
        oDB := DBFileSpec{, "DBFCDX"}
        IF oDB:Find()
        oOrd1 := OrderSpec{oDB}
        oOrd2 := OrderSpec{oDB}
        oOrd3 := OrderSpec{oDB}
        // create an order starting from record 3 and display the progress.
        oOrd1:FileName := "customer"
        oOrd1:OrderName := "FirstName"
        oOrd1:OrderExpr := "FirstName"
        oOrd1:OrderBlock := {| | _Field-&gt;FirstName }
        oOrd1:All := FALSE
        oOrd1:EvalBlock := {| | _Field-&gt;FirstName, Qout(RECNO()), TRUE}
        oOrd1:Start := 3
        oOrd1:Rest := TRUE
        // create a unique, descending order on lastname field
        oOrd2:FileName := "customer"
        oOrd2:OrderName := "LastName"
        oOrd2:OrderExpr := "LastName"
        oOrd2:OrderBlock := {| | _Field-&gt;LastName }
        oOrd2:Unique := TRUE
        oOrd2:DESCEND := TRUE
        // create a FOR condition based on firstnames with starting letter &gt; "M"
        oOrd3:FileName := "customer"
        oOrd3:OrderName := "FirstName"
        oOrd3:OrderExpr := "FirstName"
        oOrd3:OrderBlock := {| | _Field-&gt;FirstName }
        oOrd3:ForCond := "SubStr(_Field-&gt;FirstName, 1, 1) &gt; 'M'"
        oOrd3:ForBlock := {| | SUBSTR(_Field-&gt;FirstName, 1, 1) &gt; 'M' }
        oOrd1:OrderCreate( )
        oOrd2:OrderCreate( )
        oOrd3:OrderCreate( )
        ENDIF
      </code>
    </example>
  </OrderSpec.OrderCreate>
  <OrderSpec.OrderDelete>
    <summary>
      Deletes orders from a multi-order file or a physical index file of a single-order file. NULLs out OrderSpec object information in the OrderSpec object and the DBFileSpec object specific to this order.
    </summary>
    <param name="uOrder">The numeric position or order name of the order to be deleted. Use order names unless the actual order position is known. The default is the first order of the index file.</param>
    <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    <example>
      <code language="X#">
        RDDSetDefault("DBFNTX")
        oDB := DBFileSpec{"C:\TEST\CUSTOMER.DBF"}
        oOrd1 := OrderSpec{oDB}
        oOrd2 := OrderSpec{oDB}
        oOrd3 := OrderSpec{oDB}
        oOrd1:OrderAdd("C:\TEST\CUST1.NTX")
        oOrd2:OrderAdd("C:\TEST\CUST2.NTX")
        oOrd3:OrderAdd("C:\TEST\CUST3.NTX")
        oOrd1:OrderDelete( )
        oOrd2:OrderDelete( )
        oOrd3:OrderDelete( )
      </code>
    </example>
  </OrderSpec.OrderDelete>
  <OrderSpec.OrderExpr>
    <summary>
      The string of the index key expression used to create this order.
    </summary>
    <value>The string of the index key expression used to create this order.</value>
  </OrderSpec.OrderExpr>
  <OrderSpec.OrderName>
    <summary>
      The order (tag) name for this order. Used for creating multi-order order files (bags).
    </summary>
    <value>The order (tag) name for this order. Used for creating multi-order order files (bags).</value>
  </OrderSpec.OrderName>
  <OrderSpec.Recno>
    <summary>
      The individual record number to be processed. Defaults to zero (0) for all records.
    </summary>
    <value>The individual record number to be processed. Defaults to zero (0) for all records.</value>
  </OrderSpec.Recno>
  <OrderSpec.Records>
    <summary>
      The number of records to be processed starting from OrderSpec:Start.
    </summary>
    <value>The number of records to be processed starting from OrderSpec:Start.</value>
  </OrderSpec.Records>
  <OrderSpec.Rest>
    <summary>
      A logical value indicating that records are to be processed starting from OrderSpec:Start (TRUE). Defaults to FALSE to process all records from the beginning of file.
    </summary>
    <value>A logical value indicating that records are to be processed starting from OrderSpec:Start (TRUE). Defaults to FALSE to process all records from the beginning of file.</value>
  </OrderSpec.Rest>
  <OrderSpec.Start>
    <summary>
      Determines the starting record number from which to start building this order.
    </summary>
    <value>Determines the starting record number from which to start building this order.</value>
  </OrderSpec.Start>
  <OrderSpec.StrictRead>
    <summary>
      A logical value determining whether the records will be read directly from disk during order creation.
    </summary>
    <value>A logical value determining whether the records will be read directly from disk during order creation.</value>
  </OrderSpec.StrictRead>
  <OrderSpec.Unique>
    <summary>
      A logical value determining whether this order is to be a unique order (no duplicate keys).
    </summary>
    <value>A logical value determining whether this order is to be a unique order (no duplicate keys).</value>
  </OrderSpec.Unique>
  <OrderSpec.WhileBlock>
    <summary>
      A WHILE condition code block used during the building of this order.
    </summary>
    <value>A WHILE condition code block used during the building of this order.</value>
  </OrderSpec.WhileBlock>
  <DbSetDefaultLockMode>
    <summary>Get/Set the default locking mode for the DbServer class</summary>
    <param name="dwLockMode">The new locking mode. The default = ccOptimistic</param>
    <returns>The previous locking mode</returns>
  </DbSetDefaultLockMode>
  <DbGetDefaultLockMode>
    <summary>Get the default locking mode for the DbServer class</summary>
    <returns>The current locking mode</returns>
  </DbGetDefaultLockMode>
  <DbSetRestoreWorkarea>
    <summary>Get/Set the flag that determines if DbServer operations restore the current workarea </summary>
  </DbSetRestoreWorkarea>
</doc>
