<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../helpproject.xsl" ?>
<topic template="Default" modified="2023-12-19T12:06:36.304+01:00" lasteditedby="robert" version="2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../helpproject.xsd">
  <title>Memory Variables</title>
  <body>
    <header>
      <para styleclass="Heading1">Memory Variables</para>
    </header>
    <para styleclass="Body Text">X# provides support for dynamically scoped variables that are created and maintained completely at runtime. <br/>The term dynamically scoped refers to the fact that the scope of these variables is not limited by the entity in which the variable is created. </para>
    <para styleclass="Body Text"><br/><text style="font-weight:bold; font-style:italic;">Warning</text>! Dynamically scoped variables are NOT supported in the Core and Vulcan dialects. In other dialects they are supported only if the <link displaytype="text" defaultstyle="true" type="topiclink" href="opt-memvar">-memvar </link> compiler option is enabled. </para>
    <para styleclass="Body Text"></para>
    <para styleclass="Body Text"><table styleclass="Default" rowcount="3" colcount="3">
      <tr style="vertical-align:top">
        <td>
          <para styleclass="Body Text"><text style="font-weight:bold;">Variable Type</text></para>
        </td>
        <td>
          <para styleclass="Body Text"><text style="font-weight:bold;">Lifetime</text></para>
        </td>
        <td>
          <para styleclass="Body Text"><text style="font-weight:bold;">Visibility</text></para>
        </td>
      </tr>
      <tr style="vertical-align:top">
        <td>
          <para styleclass="Body Text">PRIVATE</para>
        </td>
        <td>
          <para styleclass="Body Text">Until creator returns or until released</para>
        </td>
        <td>
          <para styleclass="Body Text">Creator and called routines</para>
        </td>
      </tr>
      <tr style="vertical-align:top">
        <td>
          <para styleclass="Body Text">PUBLIC</para>
        </td>
        <td>
          <para styleclass="Body Text">Application or until released</para>
        </td>
        <td>
          <para styleclass="Body Text">Application</para>
        </td>
      </tr>
    </table></para>
    <para styleclass="Body Text">The data type of a dynamically scoped variable changes according to the contents of the variable. For this reason they are often described as dynamic or polymorphic.</para>
    <para styleclass="Body Text">Dynamically scoped variables are provided mainly for Clipper/Xbase compatibility; however, they are very useful in certain circumstances. For instance, they let you develop rapid prototypes and have certain inheritance properties that you may find hard to resist.</para>
    <para styleclass="Body Text">You must be aware, however, that using them comes at a cost. Consider these points:</para>
    <list id="0" type="ul" listtype="bullet" formatstring="&#183;" format-charset="SYMBOL_CHARSET" levelreset="true" legalstyle="false" startfrom="1" styleclass="Body Text" style="font-family:Symbol; font-size:11pt; color:#000000;">
      <li styleclass="Body Text">Because they are not resolved at compile time, these variables require overhead in the form of runtime code, making your application larger and slower than necessary.</li>
      <li styleclass="Body Text">No compile time checking for type compatibility is possible with these variables.</li>
      <li styleclass="Body Text">Using the inheritance properties of these variables defies one of the basic tenets of modular programming and may lead to maintenance and debugging problems down the line. Furthermore, this practice will make the transition to lexically scoped and typed variables more difficult.</li>
    </list>
    <para styleclass="Body Text">This section explores dynamically scoped variables fully, but X# has several options for variable declarations that you will want to explore before choosing to use this variable class. The next two sections in this chapter introduce you to Lexically Scoped Variables and Strongly Typed Variables, which you may find useful.</para>
    <para styleclass="Body Text"><text style="font-style:italic;">Important! For the sake of illustration, some of the examples in this section use unorthodox programming practices. Using the inheritance properties of public and private variables instead of passing arguments and returning values is not recommended.</text></para>
    <para styleclass="Heading1">Private</para>
    <para styleclass="Body Text">Private is one of the two types of dynamically scoped variables, and there are several ways to create a private variable: </para>
    <list id="1" type="ul" listtype="bullet" formatstring="&#183;" format-charset="SYMBOL_CHARSET" levelreset="true" legalstyle="false" startfrom="1" styleclass="Normal" style="font-family:Symbol; font-size:11pt; color:#000000;">
      <li styleclass="Normal"><text styleclass="Body Text">List the variable name as part of a PRIVATE statement. If you do not make an assignment at this time, the variable takes on the NIL value and data type; otherwise, it takes on the data type of its assigned value. You can assign a new value (with a new datatype) to a variable at any time:</text><br/><tab /><text styleclass="Code Example" style="font-weight:bold; font-style:normal; color:#ff0000;">PRIVATE</text><text styleclass="Code Example" style="font-weight:normal; font-style:normal; color:#000000;"> X := 10, y</text><br/><text styleclass="Body Text">This creates x as a numeric variable and y as an untyped variable with the value NIL. You can later change the values and their types by assigning other values to them:</text><br/><text styleclass="Code Example" style="font-weight:normal; font-style:normal; color:#000000;">&#32;</text><text styleclass="Code Example" style="font-weight:normal; font-style:normal; text-decoration:none; color:#000000;"> &#160;X := &quot;X# Is great&quot;</text><br/><text styleclass="Code Example" style="font-weight:normal; font-style:normal; text-decoration:none; color:#000000;"> &#160; Y := Today()</text></li>
    </list>
    <list id="2" type="ul" listtype="bullet" formatstring="&#183;" format-charset="SYMBOL_CHARSET" levelreset="true" legalstyle="false" startfrom="1" styleclass="Body Text" style="font-family:Symbol; font-size:11pt; color:#000000;">
      <li styleclass="Body Text">List the variable name as part of a PARAMETERS statement within a FUNCTION, PROCEDURE or METHOD definition. The variable takes on the data type of its associated argument when the routine is called, or NIL if the argument is omitted. You can assign a new value (and a new data type) to the variable at any time. </li>
    </list>
    <list id="3" type="ul" listtype="bullet" formatstring="&#183;" format-charset="SYMBOL_CHARSET" levelreset="true" legalstyle="false" startfrom="1" styleclass="Body Text" style="font-family:Symbol; font-size:11pt; color:#000000;">
      <li styleclass="Body Text">Assign a value to a non-existent variable name (for example, x := 10). The variable takes on the data type of its assigned value until you assign a new value to it. (x is numeric, but the assignment x := &quot;Ms. Jones&quot; changes it to a string.) This will only work if you have used the <link displaytype="text" defaultstyle="true" type="topiclink" href="opt-undeclared">-undeclared</link> &#160;as well as the <link displaytype="text" defaultstyle="true" type="topiclink" href="opt-memvar">-memvar </link> commandline options.</li>
    </list>
    <para styleclass="Body Text">Private variables have these properties: </para>
    <list id="4" type="ul" listtype="bullet" formatstring="&#183;" format-charset="SYMBOL_CHARSET" levelreset="true" legalstyle="false" startfrom="1" styleclass="Body Text" style="font-family:Symbol; font-size:11pt; color:#000000;">
      <li styleclass="Body Text">You can access them within the creating routine and any routines called by the creator. In other words, private variables are automatically inherited by called routines without having to pass them as arguments. </li>
      <li styleclass="Body Text">You can hide them from a called routine by explicitly creating a private (using PRIVATE or PARAMETERS) or declaring a local (using LOCAL) variable with the same name in the called routine. </li>
      <li styleclass="Body Text">They are automatically released from memory when the creator returns to its calling routine, or you can release them explicitly using RELEASE, CLEAR ALL, or CLEAR MEMORY. </li>
    </list>
    <para styleclass="Body Text">In this example, the function Volume() expects three arguments, or parameters, to be passed. When the function is called, it creates three private variables, nLength, nWidth, and nHeight to accept the arguments. Because they are created with the PARAMETERS statement, any higher-level variables (either public or private) created with these names are temporarily hidden, preventing their values from being overwritten in memory: </para>
    <para styleclass="Code Example"><text style="font-weight:bold; font-style:normal; color:#ff0000;">FUNCTION</text><text style="font-weight:normal; font-style:normal; color:#000000;"> Volume() </text><br/><tab /><text style="font-weight:bold; font-style:normal; color:#ff0000;">PARAMETERS</text><text style="font-weight:normal; font-style:normal; color:#000000;"> nLength, nWidth, nHeight </text><br/><tab /><text style="font-weight:bold; font-style:normal; color:#ff0000;">RETURN</text><text style="font-weight:normal; font-style:normal; color:#000000;"> nLength * nWidth * nHeight </text></para>
    <para styleclass="Body Text">In the next example, a modified version of Volume() creates a private variable (assuming no other variable name nVolume is visible) to store its return value. If the variable nVolume exists prior to calling Volume() and is visible to Volume() (for example, nVolume may be public or private to the routine that called Volume()), its value is overwritten in memory and will remain changed when the function returns to its calling routine: </para>
    <para styleclass="Code Example"><text style="font-weight:bold; font-style:normal; color:#ff0000;">FUNCTION</text><text style="font-weight:normal; font-style:normal; color:#000000;"> Volume() </text><br/><tab /><text style="font-weight:bold; font-style:normal; color:#ff0000;">PARAMETERS</text><text style="font-weight:normal; font-style:normal; color:#000000;"> nLength, nWidth, nHeight </text><br/><tab /><text style="font-weight:normal; font-style:normal; color:#000000;">nVolume := nLength * nWidth * nHeight </text><br/><tab /><text style="font-weight:bold; font-style:normal; color:#ff0000;">RETURN</text><text style="font-weight:normal; font-style:normal; color:#000000;"> nVolume </text></para>
    <para styleclass="Body Text">In this version, Volume() specifies the nVolume variable as PRIVATE. Doing this temporarily hides any higher-level variable (either public or private) with the same name, preventing its value from being overwritten in memory: </para>
    <para styleclass="Code Example"><text style="font-weight:bold; font-style:normal; color:#ff0000;">FUNCTION</text><text style="font-weight:normal; font-style:normal; color:#000000;"> Volume() </text><br/><tab /><text style="font-weight:bold; font-style:normal; color:#ff0000;">PARAMETERS</text><text style="font-weight:normal; font-style:normal; color:#000000;"> nLength, nWidth, nHeight </text><br/><tab /><text style="font-weight:bold; font-style:normal; color:#ff0000;">PRIVATE</text><text style="font-weight:normal; font-style:normal; color:#000000;"> nVolume := nLength * nWidth * nHeight </text><br/><tab /><text style="font-weight:bold; font-style:normal; color:#ff0000;">RETURN</text><text style="font-weight:normal; font-style:normal; color:#000000;"> nVolume </text></para>
    <para styleclass="Heading1">Public</para>
    <para styleclass="Body Text">The second category of undeclared variable is public. Public variables have application-wide lifetime and visibility, and you can define them in only one way: </para>
    <list id="5" type="ul" listtype="bullet" formatstring="&#183;" format-charset="SYMBOL_CHARSET" levelreset="true" legalstyle="false" startfrom="1" styleclass="Body Text" style="font-family:Symbol; font-size:11pt; color:#000000;">
      <li styleclass="Body Text">List the variable name as part of a PUBLIC statement. If you do not make an assignment at this time, the variable takes on a value of FALSE (or NIL for array elements); otherwise, it takes on the data type of its assigned value. You can assign a new value (and a new data type) to the variable at any time. </li>
    </list>
    <para styleclass="Body Text">Public variables have these properties: </para>
    <list id="6" type="ul" listtype="bullet" formatstring="&#183;" format-charset="SYMBOL_CHARSET" levelreset="true" legalstyle="false" startfrom="1" styleclass="Body Text" style="font-family:Symbol; font-size:11pt; color:#000000;">
      <li styleclass="Body Text">Once they are created, you can access them anywhere in the application. In other words, public variables are automatically inherited by all routines in the application without having to pass them as arguments or post them as return values. </li>
      <li styleclass="Body Text">You can hide them from a routine by explicitly creating a private (using PRIVATE or PARAMETERS) or declaring a local (using LOCAL) variable with the same name. </li>
      <li styleclass="Body Text">They are not released from memory until you explicitly release them using RELEASE, CLEAR ALL, or CLEAR MEMORY. </li>
    </list>
    <para styleclass="Body Text">In this example, the function Volume() is defined without arguments. Instead, the calling routine, Compute(), creates three public variables, nLength, nWidth, and nHeight that are automatically visible to Volume(): </para>
    <para styleclass="Code Example"><text style="font-weight:bold; font-style:normal; color:#ff0000;">PROCEDURE</text><text style="font-weight:normal; font-style:normal; color:#000000;"> Compute()</text><br/><text style="font-weight:bold; font-style:normal; color:#ff0000;">PUBLIC</text><text style="font-weight:normal; font-style:normal; color:#000000;"> nLength := 5, nWidth := 2, nHeight := 4</text><br/><text style="font-weight:normal; font-style:normal; color:#000000;">? Volume() </text><text style="font-weight:bold; font-style:italic; color:#339966;">// Result: 40</text><br/><br/><text style="font-weight:bold; font-style:normal; color:#ff0000;">FUNCTION</text><text style="font-weight:normal; font-style:normal; color:#000000;"> Volume()</text><br/><text style="font-weight:bold; font-style:normal; color:#ff0000;">RETURN</text><text style="font-weight:normal; font-style:normal; color:#000000;"> nLength * nWidth * nHeight</text></para>
    <para styleclass="Body Text">In the next example, a modified version of Volume() creates a public variable to store the computed volume, getting around having to return a value to the calling routine. Since nVolume is public, it is not released from memory when Volume() returns: </para>
    <para styleclass="Code Example"><text style="font-weight:bold; font-style:normal; color:#ff0000;">PROCEDURE</text><text style="font-weight:normal; font-style:normal; color:#000000;"> Compute() </text><br/><text style="font-weight:bold; font-style:normal; color:#ff0000;">PUBLIC</text><text style="font-weight:normal; font-style:normal; color:#000000;"> nLength := 5, nWidth := 2, nHeight := 4 </text><br/><text style="font-weight:normal; font-style:normal; color:#000000;">Volume() </text><br/><text style="font-weight:normal; font-style:normal; color:#000000;">? nVolume </text><text style="font-weight:bold; font-style:italic; color:#339966;">// Result: 40 , this will only compile with -undeclared</text><br/><text style="font-weight:bold; font-style:normal; color:#ff0000;">RETURN</text><br/><br/><text style="font-weight:bold; font-style:normal; color:#ff0000;">PROCEDURE</text><text style="font-weight:normal; font-style:normal; color:#000000;"> Volume() </text><br/><text style="font-weight:bold; font-style:normal; color:#ff0000;">PUBLIC</text><text style="font-weight:normal; font-style:normal; color:#000000;"> nVolume </text><br/><text style="font-weight:normal; font-style:normal; color:#000000;">nVolume := nLength * nWidth * nHeight </text><br/><text style="font-weight:bold; font-style:normal; color:#ff0000;">RETURN</text></para>
    <para styleclass="Body Text">A better solution for the use of the nVolume variable from last example that will not require the -undeclared commandline option is:</para>
    <para styleclass="Code Example"><text style="font-weight:bold; font-style:normal; color:#ff0000;">PROCEDURE</text><text style="font-weight:normal; font-style:normal; color:#000000;"> Compute() </text><br/><text style="font-weight:bold; font-style:normal; color:#ff0000;">PUBLIC</text><text style="font-weight:normal; font-style:normal; color:#000000;"> nLength := 5, nWidth := 2, nHeight := 4 </text><br/><text style="font-weight:bold; font-style:normal; color:#ff0000;">MEMVAR</text><text style="font-weight:normal; font-style:normal; color:#000000;"> nVolume &#160; </text><text style="font-weight:bold; font-style:italic; color:#339966;">// tell the compiler that nVolume is a Public or private</text><br/><text style="font-weight:normal; font-style:normal; color:#000000;">Volume() </text><br/><text style="font-weight:normal; font-style:normal; color:#000000;">? nVolume </text><text style="font-weight:bold; font-style:italic; color:#339966;">// Result: 40 </text><br/><text style="font-weight:bold; font-style:normal; color:#ff0000;">RETURN</text></para>
    <para styleclass="Body Text">or</para>
    <para styleclass="Code Example"><text style="font-weight:bold; font-style:normal; color:#ff0000;">PROCEDURE</text><text style="font-weight:normal; font-style:normal; color:#000000;"> Compute() </text><br/><text style="font-weight:bold; font-style:normal; color:#ff0000;">PUBLIC</text><text style="font-weight:normal; font-style:normal; color:#000000;"> nLength := 5, nWidth := 2, nHeight := 4 </text><br/><text style="font-weight:normal; font-style:normal; color:#000000;">Volume() </text><br/><text style="font-weight:normal; font-style:normal; color:#000000;">? _MEMVAR-&gt;nVolume </text><text style="font-weight:bold; font-style:italic; color:#339966;">// Result: 40 </text><br/><text style="font-weight:bold; font-style:normal; color:#ff0000;">RETURN</text><br/></para>
    <para styleclass="Body Text">Please note that this kind of programming is NOT recommended. </para>
    <para styleclass="Heading1">Variable References</para>
    <para styleclass="Body Text">Once a public or private variable is created as demonstrated in the previous two sections, you obtain its value by referring to its name. You might display the value of a variable using a built-in command or function:</para>
    <para styleclass="Code Example"><text style="font-weight:normal; font-style:normal; text-decoration:none; color:#000000;">? nVolume</text><br/><text style="font-weight:normal; font-style:normal; text-decoration:none; color:#000000;">QOut(nVolume)</text></para>
    <para styleclass="Body Text">or use its value as part of an expression:</para>
    <para styleclass="Code Example"><text style="font-weight:normal; font-style:normal; text-decoration:none; color:#000000;">Str(nVolume, 10, 2) + &quot; cubic feet&quot;</text></para>
    <para styleclass="Body Text">For dynamically scoped variables, you can use the _MEMVAR alias to qualify a variable reference. In some cases, you may have to do this in order to help the compiler resolve what might otherwise be an ambiguous reference (for example, if you have a field variable with the same name as a memory variable and want to use the memory variable in an expression).</para>
    <para styleclass="Body Text"><text style="font-weight:bold;">Note</text>: MEMVAR is an abbreviation for memory variable, a term that is synonymous with dynamically scoped variable. <br/>Assuming that the database file Measures has fields named nLength, nWidth, and</para>
    <para styleclass="Body Text">nHeight, this example calls Volume() using the field variable values:</para>
    <para styleclass="Code Example"><text style="font-weight:bold; font-style:normal; text-decoration:none; color:#ff0000;">FUNCTION</text><text style="font-weight:normal; font-style:normal; text-decoration:none; color:#000000;"> Calculate()</text><br/><text style="font-weight:bold; font-style:normal; text-decoration:none; color:#ff0000;">PRIVATE</text><text style="font-weight:normal; font-style:normal; text-decoration:none; color:#000000;"> nLength := 5, nWidth := 2, nHeight := 3</text><br/><text style="font-weight:bold; font-style:normal; text-decoration:none; color:#ff0000;">USE</text><text style="font-weight:normal; font-style:normal; text-decoration:none; color:#000000;"> measures</text><br/><text style="font-weight:normal; font-style:normal; text-decoration:none; color:#000000;">? Volume(nLength, nWidth, nHeight)</text><br/><text style="font-weight:normal; font-style:normal; text-decoration:none; color:#000000;">...</text></para>
    <para styleclass="Body Text">To force the function to use the private variables instead of the field variables,</para>
    <para styleclass="Body Text">you could use the _MEMVAR-&gt; (or, more simply, M-&gt;) alias to qualify the</para>
    <para styleclass="Body Text">variable names:</para>
    <para styleclass="Code Example"><text style="font-weight:bold; font-style:normal; text-decoration:none; color:#ff0000;">FUNCTION</text><text style="font-weight:normal; font-style:normal; text-decoration:none; color:#000000;"> Calculate()</text><br/><text style="font-weight:bold; font-style:normal; text-decoration:none; color:#ff0000;">PRIVATE</text><text style="font-weight:normal; font-style:normal; text-decoration:none; color:#000000;"> nLength := 5, nWidth := 2, nHeight := 3</text><br/><text style="font-weight:bold; font-style:normal; text-decoration:none; color:#ff0000;">USE</text><text style="font-weight:normal; font-style:normal; text-decoration:none; color:#000000;"> measures</text><br/><text style="font-weight:normal; font-style:normal; text-decoration:none; color:#000000;">? Volume(_MEMVAR-&gt;nLength, _MEMVAR-&gt;nWidth, _MEMVAR-&gt;nHeight)</text><br/><text style="font-weight:normal; font-style:normal; text-decoration:none; color:#000000;">...</text></para>
    <para styleclass="Body Text">Of course, it is better to avoid ambiguous situations like the one described above by taking care to have unique field and variable names, but the point is that the compiler has certain default rules for handling ambiguous references. If you do not want to be at the mercy of those defaults, it is best to qualify variable names in all cases. </para>
    <para styleclass="Heading1">MEMVAR Declarations </para>
    <para styleclass="Body Text">Although you may hear them referred to as such, the statements mentioned so far in the discussion of dynamically scoped variables are not declarations. The term declaration refers to a statement whose purpose is to inform the compiler of something—PRIVATE, PARAMETERS, and PUBLIC are statements that generate memory variables at runtime. </para>
    <para styleclass="Body Text">In fact you never have to declare a dynamically scoped variable to the compiler, which is the reason for their inefficiency. Because they are not created using compile-time declaration statements, the compiler has to generate runtime code for handling such issues as type translation, memory management, and resolving ambiguous references to variable names since it is possible for several variables with the same name to be visible at one time. </para>
    <para styleclass="Body Text">You can, however, declare dynamically scoped variables with the MEMVAR statement and they will be created as PRIVATE variables:</para>
    <para styleclass="Code Example"><text style="font-weight:bold; font-style:normal; color:#ff0000;">FUNCTION</text><text style="font-weight:normal; font-style:normal; color:#000000;"> Calculate()</text><br/><text style="font-weight:bold; font-style:normal; color:#ff0000;">MEMVAR</text><text style="font-weight:normal; font-style:normal; color:#000000;"> nLength, nWidth, nHeight</text><br/><text style="font-weight:normal; font-style:normal; color:#000000;">nLength := 5</text><br/><text style="font-weight:normal; font-style:normal; color:#000000;">nWidth := 2</text><br/><text style="font-weight:normal; font-style:normal; color:#000000;">nHeight := 3</text><br/><text style="font-weight:normal; font-style:normal; color:#000000;">USE measures</text><br/><text style="font-weight:normal; font-style:normal; color:#000000;">? Volume(nLength, nWidth, nHeight)</text></para>
    <para styleclass="Body Text">In this case, the MEMVAR statement causes memory variables to take precedence over field variables with the same names, causing Volume() to be called with the private variables.</para>
    <para styleclass="Body Text">Using MEMVAR to declare dynamically scoped variable names to the compiler may make your programs slightly more efficient (especially if you have lots of ambiguous references); however, it will not eliminate the runtime overhead of these variables. </para>
  </body>
</topic>
