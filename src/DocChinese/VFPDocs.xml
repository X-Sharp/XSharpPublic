<?xml version="1.0" encoding="utf-8"?>
<Runtimefunctions>
    <aclass>
        <summary>
            将对象的类名及其祖先类名放入变量数组中。
        </summary>
        <param name="ArrayName">
            指定用于存放类名的数组名称。
        </param>
        <param name="oExpression">
            指定一个对象，其类名和祖先类名将被放入数组中。
            oExpression 可以是任何对象表达式，如对象引用、对象变量或对象数组元素。
        </param>
        <returns>数值</returns>
        <remarks>
            如果指定的数组名不存在，X# 会自动创建该数组。
            如果指定的现有数组不够大，无法容纳所有父类名，X# 会自动增加数组的大小。
            如果数组大于所需大小，数组大小将被截断。如果指定了现有的二维数组，
            该数组将被重新调整为一维数组。<br/> <br/>
            AClass() 创建一个一维数组，包含指定对象的类名及其祖先类名。
            数组的第一个元素包含对象的类名，第二个元素包含对象的父类名，
            第三个元素包含对象的祖父类名，依此类推。<br/>
            AClass() 返回数组中类名的数量。如果无法创建数组，AClass() 返回 0。<br/>
        </remarks>
        <example>
             <code language="X#">
                Clear
                frmMyForm = CreateObject("FormGrandChild")

                For nCount = 1 TO AClass(gaNewarray, frmMyForm)    &amp;&amp; 创建一个数组
                    ? gaNewarray(nCount)  &amp;&amp; 显示类名
                ENDFor

                RELEASE frmMyForm

                DEFINE CLASS FormChild AS ForM
                ENDDEFINE

                DEFINE CLASS FormGrandChild AS FormChild
                ENDDEFINE
            </code>
        </example>
    </aclass>

    <adatabases>
        <summary>
            将所有打开的数据库名称及其路径放入变量数组中。
        </summary>
        <param name="ArrayName">
            指定数组的名称。
        </param>
        <returns>
            数值
        </returns>
        <remarks>
            所有打开的数据库的名称将被放入变量数组中。<br/> <br/>
            如果指定的数组不存在，X# 会自动创建该数组。
            如果数组存在但不够大，无法容纳所有数据库信息，
            X# 会自动增加数组的大小以容纳信息。如果数组大于所需大小，X# 会截断数组。
            如果数组存在且 ADatabases() 因没有打开的数据库而返回 0，现有数组保持不变。
            如果数组不存在，且 ADatabases() 返回 0，则不会创建数组。<br/><br/>
            ADatabases() 创建一个二维数组。数组的第一列包含打开的数据库名称，
            第二列包含数据库的路径。<br/>
            ADatabases() 返回数组中的数据库名称（行）数量。如果没有打开的数据库，ADatabases() 返回 0，且不会创建数组。<br/>
        </remarks>
        <example>
             <code language="X#">
                Set PATH TO (HOME(2) + 'data\')     &amp;&amp; 设置数据库路径
                Open Database testdata &amp;&amp; 打开数据库
                Clear
                ? ADatabases(gaDatabase)     &amp;&amp; 创建包含打开数据库的数组
                Display MEMORY LIKE gadatabase  &amp;&amp; 显示数组内容
                Close Databases
            </code>
        </example>
    </adatabases>

    <adbobjects>
        <summary>
            将当前数据库中的命名连接、关系、表或 SQL 视图的名称放入变量数组中。
        </summary>
        <param name="ArrayName">
            指定用于存放名称的数组名称。
        </param>
        <param name="cSetting">
            指定要放入变量数组的名称。备注部分的表格列出了 cSetting 的值及相应放入数组的名称：
        </param>
        <returns>
            数值
        </returns>
        <remarks>
            执行 ADBObjects() 时必须有一个打开并设为当前的数据库；否则 X# 会生成错误消息。
            <list type="table">
                <listheader>
                    <term>值</term>
                    <description>放入数组的名称</description>
                </listheader>
                <item>
                    <term>Connection</term>
                    <description>连接名称</description>
                </item>
                <item>
                    <term>RELATION</term>
                    <description>表关系</description>
                </item>
                <item>
                    <term>Table</term>
                    <description>表名称</description>
                </item>
                <item>
                    <term>View</term>
                    <description>视图名称</description>
                </item>
            </list>
            Connection、Relation、Table 和 View 设置不能缩写。<br/><br/>

            ArrayName: 如果指定的数组不存在，X# 会自动创建该数组。如果数组存在但不够大，无法容纳所有名称，
            X# 会自动增加数组的大小以容纳名称。如果数组大于所需大小，X# 会截断数组。
            如果数组存在且 ADBObjects() 因未找到名称而返回0，现有数组保持不变。
            如果数组不存在，且 ADBObjects() 返回0，则不会创建数组。<br/><br/>

            当 cSetting 指定为 Connection、Table 或 View 时，会创建一个一维数组。
            一维数组的每一行包含数据库中的一个连接、表或视图的名称。<br/>
            当 cSetting 指定为 Relation 时，会创建一个二维数组。
            二维数组的每一行对应数据库中的一个关系。
            数组行的第一列包含子表的名称，第二列包含父表的名称。
            第三列包含子表的索引标记名称，第四列包含父表的索引标记名称。<br/>
            数组行的第五列包含引用完整性信息。如果关系没有引用完整性规则，该列为空。
            如果关系有引用完整性规则，该列包含对应于更新、删除和插入的引用完整性规则类型的字符。<br/>
            第一个字符表示更新规则类型，第二个字符表示删除规则类型，
            第三个字符表示插入规则类型。<br/>
            更新和删除的可能值为"C"（级联）、"R"（限制）和"I"（忽略）。插入的可能值为"R"（限制）和"I"（忽略）。
            例如，如果一个关系有级联更新、限制删除和忽略插入引用完整性规则，该列将包含"CRI"。<br/>
        </remarks>
        <example>
             <code language="X#">
                * 关闭所有打开的数据库
                Close Databases
                * 清空桌面以准备显示数组
                Clear
                * 打开示例testdata数据库
                Open Database (HOME(2) + 'Data\testdata')
                * 使用cSetting获取表名的函数调用
                =ADBObjects(gaTables, "Table")
                * 显示由ADBObjects()函数创建的gaTables数组
                Display MEMORY LIKE gaTables
            </code>
        </example>
    </adbobjects>

    <aelement>
        <summary>
            根据数组元素的下标返回该元素的编号。
        </summary>
        <param name="ArrayName">
            指定要返回元素编号的数组名称。
        </param>
        <param name="nRowSubscript">
            指定行下标。如果数组是一维的，AElement() 将直接返回 nRowSubscript。<br/>
            如果只包含 nRowSubscript 且其大于数组的行数，X# 将生成错误消息。
        </param>
        <param name="nColumnSubscript">
            指定列下标。如果数组是二维的，需同时包含 nRowSubscript 和 nColumnSubscript。
        </param>
        <returns>
            数值
        </returns>
        <remarks>
            可以用两种方式引用二维数组中的元素。第一种方法使用两个下标指定数组中元素的行和列位置，
            第二种方法使用单个元素编号。当提供元素的行和列下标时，AElement() 返回元素编号。<br/>
            X# 函数 ADel()、ADir()、AFields()、AIns()、ALen()、AScan()、ASort() 和 ASubscript() 可以操作二维数组，
            并要求通过元素编号引用元素。AElement() 便于将下标转换为这些函数使用的元素编号。
            可以使用 ASubscript() 从元素编号返回相应的行和列下标。<br/>
            以下示例说明了创建一个有两行三列的数组。Display MEMORY 显示了按元素编号顺序列出的数组元素内容。
             <code language="X#">
                DIMENSION gaMyArray(2,3)
                Display MEMORY LIKE gaMyArray
                gaMyArray   Pub  A
                ( 1, 1)   L  .F. (元素编号 1)
                ( 1, 2)   L  .F. (元素编号 2)
                ( 1, 3)   L  .F. (元素编号 3)
                ( 2, 1)   L  .F. (元素编号 4)
                ( 2, 2)   L  .F. (元素编号 5)
                ( 2, 3)   L  .F. (元素编号 6)
            </code>
            可以通过下标或元素编号引用元素。命令 <c>STORE 'INVOICE' TO gaMyArray(2, 1)</c> 和
            <c>STORE 'INVOICE' TO gaMyArray(4)</c> 都将字符串 INVOICE 存储到相同的数组元素中。<br/>
            在一维数组中，元素编号与其单行下标相同。对于一维数组，无需使用 AElement()。
        </remarks>
    </aelement>

    <agetfileversion>
        <summary>
            创建一个数组，包含具有 Windows 版本资源的文件（如 .exe、.dll 和 .fll 文件）或在 X# 中创建的自动化服务器的信息。
            对于 X# 自动化服务器要具有 Windows 版本资源，您必须在 EXE 版本对话框中至少为一个项目指定一个值。
            有关更多信息，请参阅 EXE 版本对话框。
        </summary>
        <param name="ArrayName">
            指定用于存放文件信息的数组名称。如果指定的数组不存在，X# 会自动创建该数组。
            如果数组存在但不够大，无法容纳所有文件信息，X# 会自动增加数组的大小。
            如果数组大于所需大小，X# 会截断数组。
        </param>
        <param name="cFileName">
            指定目标文件的名称，可选择包含路径。
        </param>
        <returns>
            数值。<b>AGetfileversion( )</b> 返回数组中的元素数量。
            如果指定的文件不存在或不包含 Windows 版本资源，
            <b>AGetfileversion( )</b> 返回零，如果数组已创建，则保持不变。
        </returns>
        <remarks>
            下表列出了数组每个元素的内容。
            例如，您可以使用以下代码来确定 X# 可执行文件的区域设置 ID：
             <code language="X#">
                DIMENSION aFiles[1]
                AGetfileversion(aFiles,"VFP9.EXE")
                ? EVAL("0x"+LEFT(aFiles[15],4))
                ** 返回 1033 表示美国版本
            </code>
            <list type="table">
                <listheader>
                    <term>数组元素</term>
                    <description>内容</description>
                </listheader>
                <item>
                    <term>1</term>
                    <descripton>注释</descripton>
                </item>
                <item>
                    <term>2</term>
                    <descripton>公司名称</descripton>
                </item>
                <item>
                    <term>3</term>
                    <descripton>文件描述</descripton>
                </item>
                <item>
                    <term>4</term>
                    <descripton>文件版本</descripton>
                </item>
                <item>
                    <term>5</term>
                    <descripton>内部名称</descripton>
                </item>
                <item>
                    <term>6</term>
                    <descripton>法律版权</descripton>
                </item>
                <item>
                    <term>7</term>
                    <descripton>法律商标</descripton>
                </item>
                <item>
                    <term>8</term>
                    <descripton>原始文件名</descripton>
                </item>
                <item>
                    <term>9</term>
                    <descripton>私有版本</descripton>
                </item>
                <item>
                    <term>10</term>
                    <descripton>产品名称</descripton>
                </item>
                <item>
                    <term>11</term>
                    <descripton>
                        产品版本
                        此值的格式取决于 X# 的版本。详情请参阅 VERSION( ) 函数。
                    </descripton>
                </item>
                <item>
                    <term>12</term>
                    <descripton>特殊版本</descripton>
                </item>
                <item>
                    <term>13</term>
                    <descripton>OLE 自注册（如果文件支持自注册，则包含 "OLESelfRegister"；否则包含空字符串）</descripton>
                </item>
                <item>
                    <term>14</term>
                    <descripton>语言（从翻译代码派生）</descripton>
                </item>
            </list>
            <b>AGetfileversion( )</b> 可以缩写为最少 5 个字符。
        </remarks>
    </agetfileversion>

    <alines>
        <summary>
            将字符表达式或备注字段中的每一行复制到数组的对应行中。
        </summary>
        <param name="ArrayName">
            指定用于存储字符表达式或备注字段中复制行的数组名称。
        </param>
        <param name="cExpression">
            指定包含要复制到数组中的行的字符表达式或备注字段。所有字符表达式区分大小写。
            如果 cExpression 为空字符串或空值，将创建一个只有一行的数组，该行包含空字符串。
            您可以使用双字节表达式。
        </param>
        <param name="nFlags">
            在 X# 的早期版本中，nFlags 是 lTrim 选项。lTrim 选项对应 nFlag 的值为 1。之前的代码在 X# 9.0 中将以相同方式运行。
            下表描述了 nFlags 的值。
        </param>
        <param name="cParseChar">
            指定一个或多个用于终止 cExpression 中元素的字符串。
        </param>
        <param name="cParseChar2">
            指定一个或多个用于终止 cExpression 中元素的字符串。
        </param>
        <returns>
            数值。<b>ALines( )</b> 返回数组中的行数，或等同于字符表达式或备注字段中的行数。
        </returns>
        <remarks>
            如果指定的数组不存在，X# 会自动创建该数组。
            如果数组存在但不够大，无法容纳备注字段中的所有行，X# 会自动增加数组的大小。
            如果数组大于所需大小，X# 会截断数组。<br/><br/>
            <list type="table">
                <listheader>
                    <term>位</term>
                    <description>值</description>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>1</description>
                    <description>（默认）删除行首和行尾的空格，或对于 Varbinary 和 Blob 值，删除尾部的零（0）而不是空格。</description>
                </item>
                <item>
                    <term>1</term>
                    <description>2</description>
                    <description>即使最后一个元素为空，也将其包含在数组中。</description>
                </item>
                <item>
                    <term>2</term>
                    <description>4</description>
                    <description>不在数组中包含空元素。</description>
                </item>
                <item>
                    <term>3</term>
                    <description>8</description>
                    <description>指定不区分大小写的解析。</description>
                </item>
                <item>
                    <term>4</term>
                    <description>16</description>
                    <description>在数组中包含解析字符。</description>
                </item>
            </list>
            当用于二进制值（如 <b>Varbinary</b> 和 <b>Blob</b>）时，<b>ALines( )</b> 创建具有 <b>Varbinary</b> 类型元素的数组。<br/><br/>
            当指定 cParseChar 时，在找到 cParseChar 时行会中断，下一行从 cParseChar 后的字符继续。<br/>
            cParseChar 中允许的最大字符串数为 23。<br/>
            您可以使用换行符（CHR(10)）或回车符（CHR(13)）来表示行的结束。
            您还可以使用这两个字符的任意组合来表示行的结束，例如（CHR(10) + CHR(13) 或 CHR(13) + CHR(10)）。
            <b>ALines( )</b> 的默认行为是在指定一个或多个 cParseChar 值时忽略 CHR(13) 和 CHR(10)，
            除非您也指定了行结束字符。<br/>
            当对 <b>Varbinary</b> 或 <b>Blob</b> 输入省略 cParseChar 时，<b>ALines( )</b> 将十六进制值 0hA（10）视为回车符，
            并在该位置中断行。值 0hA 不会保存在结果数组元素中，可能导致不正确的二进制值。
            例如，给定二进制值 0hFE0AF2，<b>ALines( )</b> 创建一个包含值 0hFE 和 0hF2 的两元素数组。<br/>
            <b>ALines( )</b> 提供了一种简单的方法来解析字符表达式或备注字段中的行。
            虽然您也可以使用 <b>MLINES( )</b> 来解析字符表达式或备注字段，但 <b>ALines( )</b> 更快且需要更少的编程。
            此外，<b>ALines( )</b> 不受 <b>Set MEMOWIDTH</b> 值的影响。<br/>
            字符表达式或备注字段的第一行被复制到数组的第一行，
            字符表达式或备注字段的第二行被复制到数组的第二行，依此类推。<br/>
            您必须有足够的内存来将大型备注字段中的行复制到数组中。如果内存不足，X# 会生成错误消息。<br/>
            如果您想执行不区分大小写的解析，可以参考以下示例之一：
             <code language="X#">? ALines(aMyArray, UPPER(employee.notes), "R.") </code>
            - 或 -
             <code language="X#">? ALines(aMyArray, employee.notes, "R.", "r.")</code>
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Clear
                Open Database (HOME(2) + "data\testdata")
                Use employee  &amp;&amp; 打开 Employee 表
                ? ALines(aMyArray, employee.notes)            &amp;&amp; 显示 1
                ? ALines(aMyArray, employee.notes, CHR(13))   &amp;&amp; 显示 1
                ? ALines(aMyArray, employee.notes, " ")       &amp;&amp; 显示 75
                ? ALines(aMyArray, employee.notes, ".")       &amp;&amp; 显示 7
                ? ALines(aMyArray, employee.notes, ",")       &amp;&amp; 显示 4
                ? ALines(aMyArray, employee.notes, ".", ",")  &amp;&amp; 显示 10
                ? ALines(aMyArray, employee.notes, 8, "m")    &amp;&amp; 显示 14
                ? ALines(aMyArray, employee.notes, "m")       &amp;&amp; 显示 11
                ? ALines(aMyArray, employee.notes, "M")       &amp;&amp; 显示 4
            </code>
        </example>
    </alines>

    <amembers>
        <summary>
            将对象的属性、过程和成员对象的名称放入变量数组中。
        </summary>
        <param name="ArrayName">
            指定存放 oObjectName 成员属性名称的数组。
            如果指定的数组不存在，系统会自动创建该数组。
            如果数组不够大，无法容纳所有名称，X# 会自动增加数组的大小。
        </param>
        <param name="oObjectNameOrClassName">
            指定要将其成员属性放入 ArrayName 指定的变量数组中的对象或 X# 类。
            这可以是任何计算结果为对象的表达式，如对象引用、对象变量或对象数组元素。<br/>
        </param>
        <param name="nArrayContentsID">
            指定数组的内容。
        </param>
        <param name="cFlags">
            指定应用于 AMembers() 函数返回的数组的过滤。
            当 AMembers() 传递 COM 对象时（ArrayContentsID 的值为 3），cFlags 将不起作用。
            某些标志是互斥的，因此如果使用多个 cFlag，请按以下分组使用：
            <code>[P | H | G] [N | U] [C] [I | B] [R]</code>
        </param>
        <returns>
            数值
        </returns>
        <remarks>
            <list type="table">
                <listheader>
                    <term> </term>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>
                        指定数组包含单列属性名称。省略 nArrayContentsID 参数等同于传递 0。
                    </description>
                </item>
                <item>
                    <term>1</term>
                    <description>
                        指定数组包含对象或类的属性名称，以及方法和成员对象。
                        结果数组是二维的，第二列指定第一列中列出的成员类型。
                        第二列的可能值为 Property、Event、Method 或 Object。
                    </description>
                </item>
                <item>
                    <term>2</term>
                    <description>
                        指定数组包含 oObjectName 指定的原生 X# 对象的成员对象的名称。结果数组是一维的。
                        此选项提供了一种方法来确定容器中子对象的名称，例如表单集中的所有 Form 对象或表单中的控件。
                    </description>
                </item>
                <item>
                    <term>3</term>
                    <description>
                        指定数组包含一个或多个对象的信息。您可以传递原生 X# 对象或 COM 对象的对象引用。
                        <note>在 .app 或 .exe 应用程序中不支持此参数值为 3。</note>
                    </description>
                </item>
            </list>
            指定此参数时返回的数组由四列组成，如备注部分的表格所述：
            <list type="table">
                <listheader>
                    <term>列</term>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>事件或方法的名称</description>
                </item>
                <item>
                    <term>2</term>
                    <description>属性类型（例如，PROPERTYPUT、PROPERTYGET、PROPERTYPUTREF、METHOD）</description>
                </item>
                <item>
                    <term>3</term>
                    <description>
                        函数签名（参数及其类型，以及函数返回类型）。
                        此信息类似于 IntelliSense 展开方法时提供的快速信息文本。
                    </description>
                </item>
                <item>
                    <term>4</term>
                    <description>帮助字符串</description>
                </item>
            </list>
            如果省略 nArrayContentsID，AMembers() 返回一个包含属性的单列数组。<br/><br/>
            下表描述了 cFlags 的有效值。
            <list type="table">
                <listheader>
                    <term>值</term>
                    <description>过滤标志</description>
                </listheader>
                <item>
                    <term>P</term>
                    <description>受保护的属性、方法或事件</description>
                </item>
                <item>
                    <term>H</term>
                    <description>隐藏的属性、方法或事件</description>
                </item>
                <item>
                    <term>G</term>
                    <description>公共属性、方法或事件</description>
                </item>
                <item>
                    <term>N</term>
                    <description>原生（内部）属性、方法或事件</description>
                </item>
                <item>
                    <term>U</term>
                    <description>用户定义（外部）属性、方法或事件</description>
                </item>
                <item>
                    <term>C</term>
                    <description>已更改的属性（但不包括已更改的数组属性）</description>
                </item>
                <item>
                    <term>I</term>
                    <description>继承的属性、方法或事件</description>
                </item>
                <item>
                    <term>B</term>
                    <description>基本属性、方法或事件（使用 AddProperty 方法）</description>
                </item>
                <item>
                    <term>R</term>
                    <description>只读属性</description>
                </item>
            </list>
            cFlags 指定的过滤的默认配置是标志之间的逻辑 OR。您可以使用特殊的 "+" cFlags 来更改这一点。
            <list type="table">
                <listheader>
                    <term>值</term>
                    <description>特殊标志</description>
                </listheader>
                <item>
                    <term>#</term>
                    <description>向输出数组添加一个新列，其中包含相应的 cFlags 值。</description>
                </item>
                <item>
                    <term>+</term>
                    <description>在过滤标志之间执行逻辑 AND。</description>
                </item>
            </list>
            AMembers() 返回对象的对象、属性和过程的数量，如果无法创建数组则返回 0。
            如果省略可选的 1、2 或 3 标志参数，将创建一个包含 oObjectName 属性的一维数组。
            您可以将 COM 对象引用传递给 AMembers() 函数，但在这样做时，您还必须在第三个（标志）参数中传递值 3，
            如以下示例所示。
             <code language="X#">
                oExcel = CreateObject("excel.application")
                = AMembers(gaPropArray, oExcel, 3)
            </code>
        </remarks>
        <example>
             <code language="X#">
                Clear
                goForm1 = CreateObject("Form")  &amp;&amp; 创建一个表单
                = AMembers(gaPropArray, goForm1, 1)  &amp;&amp; 包含表单属性的数组
                Display MEMORY LIKE gaPropArray  &amp;&amp; 显示表单属性
            </code>
        </example>
    </amembers>

    <anetresources>
        <summary>
            将网络共享或打印机的名称放入数组，然后返回资源数量。
        </summary>
        <param name="ArrayName">
            指定包含网络共享或打印机信息的数组的名称。
        </param>
        <param name="cNetworkName">
            指定要返回共享或打印机信息的网络或域的名称。
        </param>
        <param name="nResourceType">
            指定要返回信息的网络资源类型。
        </param>
        <returns>
            数值
        </returns>
        <remarks>
            如果指定的数组不存在，X# 会自动创建该数组。如果数组存在但不够大，无法容纳所有信息，
            X# 会自动增加数组的大小以容纳信息。如果数组大于所需大小，X# 会截断数组。<br/>
            如果数组存在且 ANetResources() 返回 0（因为未找到网络共享或打印机），数组保持不变。
            如果数组不存在且 ANetResources() 返回 0，则不会创建数组。<br/>
            网络名称应采用 "\\NetworkName" 格式。您不必连接到指定的网络，
            指定网络也不会使您连接到该网络。
            如果指定域名，ANetResources() 将返回该域的成员或资源数组。<br/>
            如果 nResourceType 的值为 1，则返回网络上的共享名称。
            如果 nResourceType 的值为 2，则返回网络上的打印机名称。值为 0 时返回任何资源的名称。<br/>
            ANetResources() 返回找到的网络共享或打印机数量（与数组中的行数相同）。
            如果指定类型的网络没有共享或打印机，或指定的网络不存在，ANetResources() 返回零。<br/>
            在 Windows 2000 之前，共享名称限制为十二个字符长度。
            如果在使用早于 Windows 2000 的操作系统的计算机上运行 ANetResources()，
            ANetResources() 将不会返回运行 Windows 2000 或更高版本的计算机上共享名称超过十二个字符的任何共享。<br/>
            有关更多详细信息，请参阅 WNetOpenEnum 和 WNetEnumResource Win32 API 函数。
        </remarks>
    </anetresources>

    <aprinters>
        <summary>
            将有关当前可用打印机的信息存储到数组中。<br/>
            此函数的行为是特定于操作系统（OS）的。
            X#在准备此列表时可能会也可能不会检查打印机是否实际连接到您的计算机，
            并且该列表可能包括所有安装为打印机设置的打印机，或仅包括当前网络上可用的打印机。
        </summary>
        <param name="ArrayName">
            指定包含打印机信息的数组的名称。
        </param>
        <param name="nValue">
            指定创建两列数组或五列数组的值。数组中的每一行包含有关一台打印机的信息。<br/>
            备注部分的表格描述了nValue的可能值。
        </param>
        <remarks>
            如果您包含的数组不存在，X#会自动创建该数组。如果数组存在但不够大以容纳所有信息，
            X#会增加数组的大小以容纳信息。如果数组大于必要的大小，X#会截断数组。
            如果数组存在但由于没有可用的打印机而<b>APRINTERS( )</b>返回0，则数组保持不变。
            如果数组不存在，且<b>APRINTERS( )</b>返回0，则不会创建数组。<br/><br/>
            <list type="table">
                <listheader>
                    <term>nValue</term>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>0或省略</term>
                    <description>
                        返回包含以下项目的两列数组，从第一列开始：
                        <list type="bullet">
                            <item>
                                <description>打印机名称。</description>
                            </item>
                            <item>
                                <description>打印机连接的端口名称。</description>
                            </item>
                        </list>
                    </description>
                </item>
                <item>
                    <term>1</term>
                    <description>
                        返回包含以下项目的五列数组，从第一列开始：
                        <list type="bullet">
                            <item>
                                <description>打印机名称。</description>
                            </item>
                            <item>
                                <description>打印机连接的端口名称。</description>
                            </item>
                            <item>
                                <description>打印机驱动程序名称。</description>
                            </item>
                            <item>
                                <description>打印机注释。</description>
                            </item>
                            <item>
                                <description>打印机位置。</description>
                            </item>
                        </list>
                    </description>
                </item>
            </list>
        </remarks>
        <returns>
            数值。<b>APRINTERS( )</b>返回数组中的行数，或在没有可用打印机时返回0。
        </returns>
        <example>
             <code language="X#">
                IF APRINTERS(gaPrinters) &gt; 0
                    Clear  &amp;&amp; 清除当前输出窗口
                    Display MEMORY LIKE gaPrinters &amp;&amp; 显示数组的内容
                ELSE
                    WAIT '未找到打印机。'
                ENDIF
            </code>
        </example>
    </aprinters>

    <asessions>
        <summary>
            创建现有数据会话ID的数组。
        </summary>
        <param name="ArrayName">
            指定包含数据会话ID的数组。
        </param>
        <returns>
            数值。返回数据会话的数量。
        </returns>
        <remarks>
            如果数组不存在，X#会自动创建并填充它。X#会自动调整数组大小以适应当前的数据会话。
        </remarks>
    </asessions>

    <astackinfo>
        <summary>
            创建一个数组并用当前调用堆栈状态的信息填充它。
        </summary>
        <param name="ArrayName">
            指定用于存储调用堆栈信息的数组名称。
        </param>
        <returns>
            数值
        </returns>
        <remarks>
            下表描述了 AStackInfo( ) 函数返回的信息：
            <list type="table">
                <listheaders>
                    <term>数组元素</term>
                    <description>描述</description>
                </listheaders>
                <item>
                    <term>1</term>
                    <description>调用堆栈级别</description>
                </item>
                <item>
                    <term>2</term>
                    <description>当前程序文件名</description>
                </item>
                <item>
                    <term>3</term>
                    <description>模块或对象名称</description>
                </item>
                <item>
                    <term>4</term>
                    <description>模块或对象源文件名</description>
                </item>
                <item>
                    <term>5</term>
                    <description>对象源文件中的行号</description>
                </item>
                <item>
                    <term>6</term>
                    <description>源代码行内容</description>
                </item>
            </list>
            <br/>
            AStackInfo( ) 用整个调用堆栈的信息填充数组。
            它结合了 SYS(16) 和 Program( ) 函数的功能，同时为每个调用堆栈级别添加了新的行号支持。
            返回值是程序级别数量或返回数组的行数。<br/>
            只有在源代码行内容可用时，AStackInfo( ) 才会填充第 6 个数组元素，否则将留空。<br/>
            AStackInfo( ) 在第 2 和第 4 个元素中分别提供当前文件的名称，
            如果文件绑定在 APP 或其他单独文件中，则提供绑定程序的完整路径名。<br/>
            第 4 个元素包含原始源文件信息。
            对于对象，这与 SYS(16) 返回的信息相同，即使绑定在应用程序内部也是如此。<br/>
            AStackInfo() 可能无法检索有关程序（.prg）文件的信息。
            在这种情况下，X# 显示的第 2 个元素类似于 SYS(16) 函数。有关更多信息，请参见 SYS(16) - 执行程序文件名。
        </remarks>
        <example>
             <code language="X#">
                AStackInfo(myarray)
                Display MEMO LIKE myarray
                myArray
                (1,1)   1                                    &amp;&amp; 堆栈级别 = 1
                (1,2)   c:\vfp\myAppl.app                        &amp;&amp; 当前程序
                (1,3) frmRerport.PrintReport.Click         &amp;&amp; 对象
                (1,4) c:\vfp\myclasses\buttons.vct         &amp;&amp; 对象源文件名
                (1,5) 42                              &amp;&amp; 源文件中的行号
                (1,6) THISForM.DoReport()                  &amp;&amp; 源代码
                (2,1)   2                                    &amp;&amp; 堆栈级别 = 2
                (2,2) c:\vfp\myAppl.app
                (2,3) frmRerport.DoReport
                (2,4) c:\vfp\forms\frmRerport.sct         &amp;&amp; 模块源文件名
                (2,5) 31
                (2,6) DO RunListReport                     &amp;&amp; 源代码
                (3,1)   3                                    &amp;&amp; 堆栈级别 = 3
                (3,2) c:\vfp\myAppl.app
                (3,3)
                (3,4) c:\vfp\programs\runlisterport.prg   &amp;&amp; 模块源文件名
                (3,5) 12
                (3,6) REPORT ForM myreport1.frx            &amp;&amp; 源代码
                (4,1)   4                                    &amp;&amp; 堆栈级别 = 4
                (4,2) c:\vfp\reports\myreport1.frt
                (4,3) myreport1.DataEnvironment.BeforeOpenTables
                (4,4) c:\vfp\reports\myreport1.frt          &amp;&amp; 模块源文件名
                (4,5) 31
                (4,6) DO ForM getcusts                     &amp;&amp; 源代码
                (5,1)   5                                    &amp;&amp; 堆栈级别 = 5
                (5,2) c:\vfp\myAppl.app
                (5,3) getcusts.init
                (5,4) c:\vfp\forms\getcusts.sct            &amp;&amp; 模块源文件名
                (5,5) 2
                (5,6) AStackInfo(myarray)                  &amp;&amp; 源代码
            </code>
        </example>
    </astackinfo>
    
    <at>
        <summary>
            在一个字符表达式中搜索另一个字符表达式的出现位置。
            <b>AT( )</b> 执行的搜索区分大小写。要执行不区分大小写的搜索，请使用 <b>ATC( )</b>。
            更多信息，请参见 ATC( ) 函数。
        </summary>
        <param name="cSearchExpression">
            指定要在 cExpressionSearched 中搜索的字符表达式。
        </param>
        <param name="cExpressionSearched">
            指定要搜索 cSearchExpression 的字符表达式。
            cSearchExpression 和 cExpressionSearched 都可以是任意大小的备注字段。
        </param>
        <param name="nOccurrence">
            指定要在 cExpressionSearched 中搜索 cSearchExpression 的第几次出现（第一次、第二次、第三次等）。
            默认情况下，<b>AT( )</b> 搜索 cSearchExpression 的第一次出现（nOccurrence = 1）。
        </param>
        <returns>
            数值型。<b>AT( )</b> 返回一个整数，表示在另一个字符表达式或备注字段中找到的字符表达式或备注字段的第一个字符的位置，
            从最左边的字符开始计数。如果未找到表达式或字段，或者 nOccurrence 大于 cSearchExpression 在 cExpressionSearched 中出现的次数，
            <b>AT( )</b> 返回 0。
        </returns>
        <example>
             <code language="X#">
                STORE 'Now is the time for all good men' TO gcString
                STORE 'is the' TO gcFindString
                Clear
                ? AT(gcFindString,gcString)  &amp;&amp; 显示 5
                STORE 'IS' TO gcFindString
                ? AT(gcFindString,gcString)  &amp;&amp; 显示 0，区分大小写
            </code>
        </example>
    </at>

    <ataginfo>
        <summary>
            创建一个包含所选表的索引文件信息的数组。
        </summary>
        <param name="ArrayName">
            指定要创建的数组的名称。如果该数组不存在，X# 将创建它。
        </param>
        <param name="cCDXName">
            指定要返回信息的复合索引（.cdx）文件的名称。
            指定空字符串（""）将返回所选表的所有打开的 .cdx 文件和所有打开的独立索引（.idx）文件中的标记数。
        </param>
        <param name="uArea">
            指定包含要返回信息的表的工作区号或工作区别名。<br/>
            省略此参数将使用当前工作区中的表。
        </param>
        <returns>
            数值型。<b>ATagInfo( )</b> 返回当前表的复合索引（.cdx）文件中
            或打开的单键独立索引（.idx）文件中的索引标记数量。
        </returns>
        <remarks>
            下表描述了 <b>ATagInfo( )</b> 创建的数组中存储的信息。
            <list type="table">
                <listheader>
                    <term>列</term>
                    <description>描述</description>
                    <description>数据类型</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>.cdx 文件中的索引标记名称或 .idx 文件的索引文件名</description>
                    <description>字符型</description>
                </item>
                <item>
                    <term>2</term>
                    <description>索引标记类型</description>
                    <description>字符型</description>
                </item>
                <item>
                    <term>3</term>
                    <description>索引键表达式</description>
                    <description>字符型</description>
                </item>
                <item>
                    <term>4</term>
                    <description>过滤表达式</description>
                    <description>字符型</description>
                </item>
                <item>
                    <term>5</term>
                    <description>创建时的索引顺序（升序或降序）</description>
                    <description>字符型</description>
                </item>
                <item>
                    <term>6</term>
                    <description>排序序列</description>
                    <description>字符型</description>
                </item>
            </list>
        </remarks>
    </ataginfo>

    <atc>
        <summary>
            返回一个字符表达式或备注字段在另一个字符表达式或备注字段中第一次出现的起始数字位置，
            不考虑这两个表达式的大小写。
        </summary>
        <param name="cSearchExpression">
            指定 ATC( ) 在 <paramref name='cExpressionSearched' /> 中搜索的字符表达式。
        </param>
        <param name="cExpressionSearched">
            指定 <paramref name='cSearchExpression' /> 搜索的字符表达式。
            <paramref name='cSearchExpression' /> 和 <paramref name='cExpressionSearched' /> 都可以是任意大小的备注字段。
        </param>
        <param name="nOccurrence">
            指定在 <paramref name='cExpressionSearched' /> 中搜索 <paramref name='cSearchExpression' /> 的第几次出现（第一次、第二次、第三次等）。
            默认情况下，ATC( ) 搜索 <paramref name='cSearchExpression' /> 的第一次出现（nOccurrence = 1）。
            包含 nOccurrence 可以让你搜索 <paramref name='cExpressionSearched' /> 中 <paramref name='cSearchExpression' /> 的其他出现位置。
        </param>
        <returns>
            数值型
        </returns>
        <remarks>
            ATC( ) 在第二个字符表达式中搜索第一个字符表达式的出现，
            不考虑任一表达式中字符的大小写（大写或小写）。使用 AT( ) 执行区分大小写的搜索。
            ATC( ) 返回一个整数，对应于找到字符表达式第一个字符的位置。
            如果未找到字符表达式，ATC( ) 返回 0。
        </remarks>
        <example>
             <code language="X#">
                STORE 'Now is the time for all good men ... ' TO gcString
                STORE 'IS THE' TO gcFindString
                Clear
                ? ATC(gcFindString, gcString)  &amp;&amp; 显示 5
                STORE 'is' TO gcFindString
                ? ATC(gcFindString, gcString)  &amp;&amp; 显示 5
                ? ATC('now',gcString)  &amp;&amp; 显示 1
            </code>
        </example>
    </atc>

    <aused>
        <summary>
            将数据会话的表别名和工作区放入变量数组中。
        </summary>
        <param name="ArrayName">
            指定包含数据会话的表别名和工作区的数组的名称。
        </param>
        <param name="nDataSessionNumber">
            指定 <b>AUsed( )</b> 返回表别名和工作区的数据会话编号。
            如果省略 nDataSessionNumber，<b>AUsed( )</b> 返回当前数据会话的信息。
            使用 <b>Set DATASESSION</b> 指定当前数据会话。
        </param>
        <param name="cTableName">
            数组将仅包含 cTableName 指定的表的别名。
        </param>
        <returns>
            数值型
        </returns>
        <remarks>
            如果您指定的数组不存在，X# 会自动创建该数组。
            如果数组存在但不够大，无法容纳所有表别名和工作区，X# 会自动增加数组的大小。
            如果数组大于必要的大小，X# 会截断数组。如果数组存在，
            而 <b>AUsed( )</b> 返回 0（因为数据会话中没有打开的表），则数组保持不变。如果数组不存在，
            而 <b>AUsed( )</b> 返回 0，则不会创建数组。<br/><br/>
            如果将 nDataSessionNumber 设置为空值 (.NULL.)，则使用当前数据会话。<br/>
            cTableName 可以采用以下格式，列出的顺序是 X# 搜索表的顺序。<br/>
            <list type="bullet">
                <term>数据库名!表名 或 数据库名!视图名。</term>
                <term>路径\数据库名!表名 或 路径\数据库名!视图名。</term>
                <term>数据会话中当前数据库容器（DBC）中定义的表名或视图。</term>
                <term>简单或完整的表名。</term>
            </list>
            <br/>
            <b>AUsed( )</b> 返回数组中的行数，这与数据会话中打开的表数相同。<br/><br/>
            <b>AUsed( )</b> 创建一个二维数组，并将数据会话的打开表的别名放在数组的第一列中。
            数组的第二列包含表对应的工作区号。<br/>
            表别名按它们打开的相反顺序放入数组中。例如，第一个数组元素包含最后打开的表的别名，
            最后一个数组元素包含第一个打开的表的别名。
            这种排序在对包含视图的视图使用 <b>TableUpdate( )</b> 时很有用。例如：<br/>
             <code language="X#">
                For x = 1 TO AUsed(aTableAliases,1)
                IF CursorGetProp( "Buffering", aTableAliases(x) ) &gt; 1 &amp;&amp; 已缓冲
                ? TableUpdate( 0, .T., aTableAliases(x) )
                ENDIF
                Next
            </code>
        </remarks>
        <example>
             <code language="X#">
                Open Database (HOME(2) + 'Data\testdata') EXCLUSIVE
                Use Customer IN 0
                Clear
                ? AUsed(gaInuse)
                Display MEMORY LIKE gaInuse
                Close Databases
            </code>
        </example>
    </aused>

    <bintoc>
        <summary>
            将数值转换为二进制字符表示。
        </summary>
        <param name="nExpression">
            指定要转换的值。对于 eFlags 设置为 1、2 或 4 时，此值为整数。否则，表达式数据类型基于 eFlags 设置。
        </param>
        <param name="eFlags">
            指定返回的字符串的长度（以字符为单位）。
        </param>
        <returns>
            字符型。BinToc( ) 返回一个二进制字符表达式。
        </returns>
        <remarks>
            eFlags 决定了您可以为 nExpression 指定的值。eFlags 可以是数值型或字符型。
            下表列出了 eFlags 的允许值和 nExpression 相应的值范围：<br/>
            <list type="table">
                <listheader>
                    <term>eFlags</term>
                    <description>nExpression 范围</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>–128 到 127</description>
                </item>
                <item>
                    <term>2</term>
                    <description>–32,768 到 32,767</description>
                </item>
                <item>
                    <term>4</term>
                    <description>
                        –2,147,483,648 到 2,147,483,647 <br/>
                        这是默认设置。
                    </description>
                </item>
                <item>
                    <term>8</term>
                    <description>
                        nExpression 的范围取决于其类型。此选项仅支持数值型、浮点型、双精度型和货币型数据类型。
                        有关数值型、浮点型、双精度型和货币型数据类型的范围，请参见 X# 数据和字段类型。<br/>
                        对于此设置，BinToc( ) 返回 8 个字节。
                    </description>
                </item>
                <item>
                    <term>F</term>
                    <description>nExpression 被解释为浮点字段类型，BinToc( ) 返回 4 个字节。</description>
                </item>
                <item>
                    <term>B</term>
                    <description>nExpression 被解释为双精度字段类型，BinToc( ) 返回 8 个字节。</description>
                </item>
                <item>
                    <term>R</term>
                    <description>反转结果二进制表达式。</description>
                </item>
                <item>
                    <term>S</term>
                    <description>防止数字的符号位被切换（BitXOR）。</description>
                </item>
            </list>
            如果省略此参数，BinToc( ) 返回由四个字符组成的字符串。<br/>
            <br/>
            eFlags 参数可以是数值型或字符型。'R' 和 'S' 设置是可累加的，而其他设置是互斥的。
            字符设置可以以大写或小写形式传递（例如，'R' 或 'r'）。以下示例展示了 eFlags 参数的各种用法。
             <code language="X#">
                ? BinToc(1,1)
                ? BinToc(1000,"2")&amp;&amp; 等同于 BinToc(1000,2)
                ? BinToc($12.34,8)
                ? BinToc(1, "4RS")&amp;&amp; 等同于 BinToc(1,"RS")
                ? BinToc(-100, "Fr")
            </code>
            您可以通过传递数值型 eFlags 参数来使用 BinToc( ) 减小包含整数数据的数值字段的索引大小。
            例如，名为 <c>nPartCode</c> 的数值字段可能包含 1 到 32,767 之间的整数值，对应于零件分类代码。
            BinToc( ) 允许您将数值字段中的值转换为较小的字符表示。例如，
            以下命令创建了一个具有两个字符索引键的索引：
             <code language="X#">Index ON BinToc(nPartCode,2) TAG PartCode</code>
            在创建 8 字节索引时使用 BinToc( )，您应该使用 8 而不是 "B"。对于 4 字节结果，如果 nExpression 是整数类型，应该使用 4。
            否则，对于浮点类型，应该使用 'F'。
            在使用 Win32 API 例程时，BinToc( ) 也可以用于需要转换为或转换自 Win32 结构成员的情况。在用于索引时，
            BinToc( ) 需要正确处理结果二进制表达式中的负数。这是通过对高位进行 BitXOR 操作来实现的。
            这也意味着最高有效字节在前。对于 Intel 平台上的 Win32 API 例程，
            架构遵循小端规则，即最低有效字节首先存储（地址最低的内存位置）。
            'R' 和 'S' 设置允许您使用 BinToc( ) 更有效地处理使用结构的例程。
        </remarks>
    </bintoc>

    <bitand>
        <summary>
            对两个或多个<b>数值型</b>、<b>可变二进制</b>或<b>大型二进制</b>类型的值执行按位与操作并返回结果。
            有数值版本和二进制版本的语法。
        </summary>
        <param name="Arg1">
            指定要执行按位与操作的可变二进制或大型二进制值。
        </param>
        <param name="Arg2">
            指定要执行按位与操作的可变二进制或大型二进制值。
        </param>
        <returns>
            <b>数值型</b>或<b>可变二进制</b>。<b>BitAnd( )</b>返回对指定表达式执行按位与操作的结果。
            对于<b>可变二进制</b>或<b>大型二进制</b>值，返回值的计算方式是将所有值在右侧用0h00填充
            直到最长值的长度。然后在这些值之间执行适当的操作。
        </returns>
        <remarks>
            <note>
                您最多可以指定26个值。指定的值必须具有相同的类型。如果指定的表达式不是整数，
                它们在执行操作之前会被转换为整数。
            </note><br/>
            <b>BitAnd( )</b>比较eExpressionN中的每个位与eExpressionN+1中的相应位。如果eExpressionN和eExpressionN+1中的位都为1，
            则相应的结果位设置为1；否则，相应的结果位设置为0。<br/>
            下表显示了对应的eExpressionN和eExpressionN+1位进行按位与操作的结果：
            <list type="table">
                <listheader>
                    <term>eExpressionN位</term>
                    <description>eExpressionN+1位</description>
                    <description>结果位</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>0</description>
                    <description>0</description>
                </item>
                <item>
                    <term>0</term>
                    <description>1</description>
                    <description>0</description>
                </item>
                <item>
                    <term>1</term>
                    <description>1</description>
                    <description>1</description>
                </item>
                <item>
                    <term>1</term>
                    <description>0</description>
                    <description>0</description>
                </item>
            </list>
        </remarks>
        <example>
             <code language="X#">
                x = 3  &amp;&amp; 二进制0011
                y = 6  &amp;&amp; 二进制0110
                ? BitAnd(x,y) &amp;&amp; 返回2，二进制0010
            </code>
        </example>
    </bitand>

    <bitclear>
        <summary>
            通过将指定位设置为0来清除<b>数值型</b>、<b>可变二进制</b>或<b>大型二进制</b>值中的指定位，并返回结果值。
            有数值版本和二进制版本的语法。
            如果指定的表达式不是整数，则在执行操作之前会将其转换为整数。
        </summary>
        <param name="Arg1">
            指定要清除位的<b>数值型</b>值或<b>可变二进制</b>或<b>大型二进制</b>表达式。如果表达式不是整数，则在设置位之前会将其转换为整数。
        </param>
        <param name="Num">
            指定要清除位的<b>数值型</b>值。如果表达式不是整数，则在设置位之前会将其转换为整数。
        </param>
        <param name="Bit">
            指定要在nExpression1中清除的位位置。nExpression2可以范围从0到31，其中0位于最右边的位。
        </param>
        <param name="BinString">
            指定一个<b>可变二进制</b>或<b>大型二进制</b>表达式。
        </param>
        <param name="StartBit">
            指定执行操作的第一个位的基于零的起始数字为nStartBit，执行操作的位数为nBitCount。<br/>
            如果不指定nStartBit和nBitCount，操作将应用于表达式中的所有位。
            如果只指定nStartBit，操作将仅应用于nStartBit。
        </param>
        <param name="BitCount">
            指定执行操作的第一个位的基于零的起始数字为nStartBit，执行操作的位数为nBitCount。<br/>
            如果不指定nStartBit和nBitCount，操作将应用于表达式中的所有位。
            如果只指定nStartBit，操作将仅应用于nStartBit。
        </param>
        <returns>
            <b>数值型</b>、<b>可变二进制</b>或<b>大型二进制</b>。<b>BitClear( )</b>返回没有指定位的指定表达式。
        </returns>
        <example>
             <code language="X#">
                x = 7  &amp;&amp; 二进制0111
                y = 1  &amp;&amp; 第2位位置（0 = 第1位位置）
                ? BitClear(x,y) &amp;&amp; 返回5，二进制0101
            </code>
        </example>
    </bitclear>

    <bitlshift>
        <summary>
            将数值中的位向左移动指定的位数，并返回结果值。
            如果指定的表达式不是整数，它们在执行操作之前会被转换为整数。
        </summary>
        <param name="Arg">
            指定要向左移动位的数值。
        </param>
        <param name="Bit">
            指定要向左移动的位数。
        </param>
        <returns>
            数值型。<b>BitLShift( )</b>返回指定表达式中的位被移动指定位数后的结果。
        </returns>
        <remarks>
            <b>BitLShift( )</b>不支持<b>可变二进制</b>值。
        </remarks>
        <example>
             <code language="X#">
                x = 5  &amp;&amp; 二进制0101
                y = 1  &amp;&amp; 向左移动1位
                ? BitLShift(x,y) &amp;&amp; 返回10，二进制1010
            </code>
        </example>
    </bitlshift>

    <bitnot>
        <summary>
            对<b>数值型</b>、<b>可变二进制</b>或<b>大型二进制</b>类型的值执行按位非操作，并返回指定值的按位补码。
            有数值版本和二进制版本的语法。
            如果指定的表达式不是整数，则在执行操作之前会将其转换为整数。
        </summary>
        <param name="Arg1">
            指定要执行按位非操作的<b>数值型</b>或<b>可变二进制</b>或<b>大型二进制</b>值。
        </param>
        <param name="nNumericExpression">
            指定要执行按位非操作的<b>数值型</b>值。
        </param>
        <param name="BinString">
            指定要执行按位非操作的<b>可变二进制</b>或<b>大型二进制</b>值。
        </param>
        <param name="StartBit">
            指定nStartBit为执行操作的第一个位的基于零的起始数字，nBitCount为执行操作的位数。<br/>
            如果不指定nStartBit和nBitCount，操作将应用于表达式中的所有位。
            如果只指定nStartBit，操作将仅应用于nStartBit。
        </param>
        <param name="BitCount">
            指定nStartBit为执行操作的第一个位的基于零的起始数字，nBitCount为执行操作的位数。<br/>
            如果不指定nStartBit和nBitCount，操作将应用于表达式中的所有位。如果只指定nStartBit，
            操作将仅应用于nStartBit。
        </param>
        <returns>
            <b>数值型</b>、<b>可变二进制</b>或<b>大型二进制</b>。<b>BitNot( )</b>返回指定表达式的按位补码。
            换句话说，返回值表示指定表达式中每个0位变为1，每个1位变为0的结果。
        </returns>
        <example>
             <code language="X#">
                x = 5  &amp;&amp; 二进制0101
                ? BitNot(x) &amp;&amp; 返回-6
            </code>
        </example>
    </bitnot>

    <bitor>
        <summary>
            对<b>数值型</b>、<b>可变二进制</b>或<b>大型二进制</b>类型的两个或多个值执行按位包含性OR操作，并返回结果。
            有数值版本和二进制版本的语法。
        </summary>
        <param name="Arg1">
            指定要执行按位AND操作的可变二进制或大型二进制值。
        </param>
        <param name="Arg2">
            指定要执行按位AND操作的可变二进制或大型二进制值。
        </param>
        <returns>
            <b>数值型</b>或<b>可变二进制</b>。<b>BitOr( )</b>返回对指定表达式执行按位包含性OR操作的结果。<br/>
            对于<b>可变二进制</b>或<b>大型二进制</b>值，返回值的计算方式是：所有值在右侧用0h00填充到最长值的长度，
            然后在这些值之间执行适当的操作。
        </returns>
        <remarks>
            <b>BitOr( )</b>比较eExpressionN中的每个位与eExpressionN+1中的对应位。如果eExpressionN和eExpressionN+1中的任一位为1，
            则相应的结果位设置为1；否则，相应的结果位设置为0。<br/>
            下表显示了对应的eExpressionN和nExpressionN+1位进行包含性OR操作的结果：
            <list type="table">
                <listheader>
                    <term>eExpressionN位</term>
                    <description>eExpressionN+1位</description>
                    <description>结果位</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>0</description>
                    <description>0</description>
                </item>
                <item>
                    <term>0</term>
                    <description>1</description>
                    <description>1</description>
                </item>
                <item>
                    <term>1</term>
                    <description>0</description>
                    <description>1</description>
                </item>
                <item>
                    <term>1</term>
                    <description>1</description>
                    <description>1</description>
                </item>
            </list>
        </remarks>
        <example>
             <code language="X#">
                x = 5  &amp;&amp; 二进制0101
                y = 6  &amp;&amp; 二进制0110
                ? BitOr(x,y) &amp;&amp; 返回7，二进制0111
            </code>
        </example>
    </bitor>

    <bitrshift>
        <summary>
            将数值中的位向右移动指定的位数，并返回结果值。
            如果指定的表达式不是整数，它们在执行操作之前会被转换为整数。
        </summary>
        <param name="Arg">
            指定要向右移动位的数值。
        </param>
        <param name="Bits">
            指定要向右移动的位数。
        </param>
        <returns>
            数值型。<b>BitRShift( )</b>返回指定表达式中的位被移动指定位数后的结果。
        </returns>
        <remarks>
            <b>BitRShift( )</b>不支持<b>可变二进制</b>值。
        </remarks>
        <example>
             <code language="X#">
                x = 5  &amp;&amp; 二进制0101
                y = 1  &amp;&amp; 向右移动1位
                ? BitRShift(x,y) &amp;&amp; 返回2，二进制0010
            </code>
        </example>
    </bitrshift>

    <bitset>
        <summary>
            通过将指定位设置为1来设置<b>数值型</b>、<b>可变二进制</b>或<b>大型二进制</b>值中的指定位，并返回结果值。
            有数值版本和二进制版本的语法。<br/>
            如果指定的表达式不是整数，则在执行操作之前会将其转换为整数。
        </summary>
        <param name="Arg1">
            指定要设置位的<b>数值型</b>值或<b>可变二进制</b>表达式。
        </param>
        <param name="Num">
            指定要设置位的<b>数值型</b>值。
        </param>
        <param name="Bit">
            指定要在nExpression1中设置为1的位位置。nExpression2可以范围从0到31，其中0位于最右边的位。
        </param>
        <param name="BinString">
            指定一个<b>可变二进制</b>或<b>大型二进制</b>表达式。
        </param>
        <param name="StartBit">
            指定执行操作的第一个位的基于零的起始数字为nStartBit，执行操作的位数为nBitCount。<br/>
            如果不指定nStartBit和nBitCount，操作将应用于表达式中的所有位。
            如果只指定nStartBit，操作将仅应用于nStartBit。
        </param>
        <param name="BitCount">
            指定执行操作的第一个位的基于零的起始数字为nStartBit，执行操作的位数为nBitCount。<br/>
            如果不指定nStartBit和nBitCount，操作将应用于表达式中的所有位。
            如果只指定nStartBit，操作将仅应用于nStartBit。
        </param>
        <returns>
            <b>数值型</b>、<b>可变二进制</b>或<b>大型二进制</b>。<b>BitSet( )</b>返回指定表达式中指定位被设置为1的结果。
        </returns>
        <example>
             <code language="X#">
                x = 5  &amp;&amp; 二进制0101
                y = 1  &amp;&amp; 第2位位置（0 = 第1位位置）
                ? BitSet(x,y) &amp;&amp; 返回7，二进制0111
            </code>
        </example>
    </bitset>

    <bittest>
        <summary>
            确定<b>数值型</b>、<b>可变二进制</b>或<b>大型二进制</b>值中的特定位是否设置为1。
            有数值版本和二进制版本的语法。
            如果指定的表达式不是整数，则在执行操作之前会将其转换为整数。
        </summary>
        <param name="Arg">
            指定要检查指定位的<b>数值型</b>值。
        </param>
        <param name="Bit">
            指定要在nExpression1中检查的位位置。nExpression2可以范围从0到31，其中0位于最右边的位。
        </param>
        <param name="BinString">
            指定要检查指定位的<b>可变二进制</b>或<b>大型二进制</b>表达式。
        </param>
        <param name="BitNumber">
            指定BinString中的基于零的位。
            如果nBitNumber超出BinString的范围，X#会生成错误。
        </param>
        <returns>
            逻辑值。如果指定的位设置为1，<b>BitTest( )</b>返回True (.T.)；否则，返回False (.F.)。
        </returns>
        <example>
             <code language="X#">
                Clear
                ? '2是偶数吗？'
                ?? IsEven(2)  &amp;&amp; 偶数，返回.T.
                ? '3是偶数吗？'
                ?? IsEven(3)  &amp;&amp; 不是偶数，返回.F.
                ? '0是偶数吗？'
                ?? IsEven(0)  &amp;&amp; 偶数，返回.T.
                ? '-13是偶数吗？'
                ?? IsEven(-13)  &amp;&amp; 不是偶数，返回.F.
                Function IsEven
                PARAMETER nInteger
                RETURN NOT BitTest(nInteger, 0)
            </code>
        </example>
    </bittest>

    <bitxor>
        <summary>
            对两个或多个<b>数值型</b>、<b>可变二进制</b>或<b>大型二进制</b>类型的值执行按位异或操作，并返回结果。
            有数值版本和二进制版本的语法。
        </summary>
        <param name="Arg1">
            指定要执行按位异或操作的可变二进制或大型二进制值。
        </param>
        <param name="Arg2">
            指定要执行按位异或操作的可变二进制或大型二进制值。
        </param>
        <returns>
            <b>数值型</b>或<b>可变二进制</b>。<b>BitXOR( )</b>返回对指定表达式执行按位异或操作的结果。<br/>
            对于<b>可变二进制</b>或<b>大型二进制</b>值，返回值的计算方式是：所有值在右侧用0h00填充到最长值的长度，然后在这些值之间执行相应的操作。
        </returns>
        <remarks>
            <b>BitXOR( )</b>比较eExpressionN中的每个位与eExpressionN+1中的对应位。如果eExpressionN和eExpressionN+1中的位相同，
            则相应的结果位设置为0；否则，相应的结果位设置为1。<br/>
            下表显示了对应的eExpressionN和eExpressionN+1位进行异或操作的结果：
            <list type="table">
                <listheader>
                    <term>eExpressionN位</term>
                    <description>eExpressionN+1位</description>
                    <description>结果位</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>0</description>
                    <description>0</description>
                </item>
                <item>
                    <term>0</term>
                    <description>1</description>
                    <description>1</description>
                </item>
                <item>
                    <term>1</term>
                    <description>0</description>
                    <description>1</description>
                </item>
                <item>
                    <term>1</term>
                    <description>1</description>
                    <description>0</description>
                </item>
            </list>
        </remarks>
        <example>
             <code language="X#">
                Var1 = 5  &amp;&amp; 二进制值 0101
                Var2 = 6  &amp;&amp; 二进制值 0110
                ? BitXOR(Var1,Var2) &amp;&amp; 返回 3（二进制值 0011）
            </code>
        </example>
    </bitxor>

    <candidate>
        <summary>
            如果索引标签是候选索引标签，则返回真 (.T.)；否则，返回假 (.F.)。
        </summary>
        <param name="nIndexNumber">
            指定 Candidate( ) 返回候选状态的索引标签的编号。
        </param>
        <param name="uArea">
            指定 nIndexNumber 参数所指定的索引标签的工作区编号或工作区别名。<br/>
            如果省略此参数，Candidate( ) 将检查当前选定工作区中的索引标签，以确定它是否为候选索引标签。
        </param>
        <returns>
            逻辑值
        </returns>
        <remarks>
            Candidate( ) 按以下顺序返回候选状态，nIndexNumber 从 1 递增到结构复合索引和独立复合索引标签的总数：<br/>
            首先返回结构复合索引（如果存在）中每个标签的候选状态。
            候选状态按标签在结构索引中创建的顺序返回。<br/>
            最后返回任何打开的独立复合索引中每个标签的候选状态。
            候选状态按标签在独立复合索引中创建的顺序返回。<br/>
            如果省略 nIndexNumber，Candidate( ) 将检查主控制索引标签是否为候选索引标签。
            如果没有主控制索引标签，Candidate( ) 返回假 (.F.)。<br/><br/>
            候选索引标签是可以成为主索引标签的索引标签，因为它不包含空值或重复值。
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Open Database (HOME(2) + 'data\testdata')
                Use customer     &amp;&amp; 打开客户表

                For nCount = 1 TO TAGCOUNT( )
                    IF !EMPTY(TAG(nCount))  &amp;&amp; 检查索引中的标签
                        ? TAG(nCount)  &amp;&amp; 显示标签名称
                        ? Candidate(nCount)  &amp;&amp; 显示候选状态
                    ELSE
                EXIT  &amp;&amp; 当没有更多标签时退出循环
                    ENDIF
                ENDFor
            </code>
        </example>
    </candidate>

    <capslock>
        <summary>
            返回CAPS Lock键的当前模式，或设置CAPS Lock键的模式为开启或关闭。
        </summary>
        <param name="lSetOn">
            包含此参数以打开或关闭CAPS Lock键。Capslock(.T.)打开CAPS Lock，Capslock(.F.)关闭CAPS Lock。
        </param>
        <returns>
            返回一个逻辑值，对应于执行Capslock(.T.)或Capslock(.F.)之前的CAPS Lock设置。
        </returns>
        <remarks>
            不带参数执行Capslock()时，如果CAPS Lock开启则返回真(.T.)，如果CAPS Lock关闭则返回假(.F.)。
        </remarks>
        <example>
             <code language="X#">
                glOldLock = Capslock()     &amp;&amp; 保存原始设置
                Capslock(.T.)     &amp;&amp; 打开CAPS Lock
                *** 执行任意数量的语句 ***
                Capslock(glOldLock)  &amp;&amp; 恢复到原始设置
                *** 或者，将CapsLock切换到相反的值再切换回来 ***
                Capslock(!Capslock())
                WAIT
                Capslock(!Capslock())
                WAIT
                Capslock(glOldLock)  &amp;&amp; 恢复到原始设置
            </code>
        </example>
    </capslock>

    <ceiling>
        <summary>
            返回大于或等于指定数值表达式的下一个最高整数。
        </summary>
        <param name="nExpression">
            指定<b>Ceiling( )</b>返回其下一个最高整数的数字。
        </param>
        <returns>
            数值
        </returns>
        <remarks>
            <b>Ceiling</b>将带有小数部分的数字四舍五入到下一个最高整数。
        </remarks>
        <example>
             <code language="X#">
                STORE 10.1 TO num1
                STORE -10.9 TO num2
                ? Ceiling(num1)  &amp;&amp; 显示 11
                ? Ceiling(num2)  &amp;&amp; 显示 -10
                ? Ceiling(10.0)  &amp;&amp; 显示 10
                ? Ceiling(-10.0) &amp;&amp; 显示 -10
            </code>
        </example>
    </ceiling>

    <compobj>
        <summary>
            比较两个对象的属性，如果它们的属性和属性值完全相同，则返回True（.T.）。
        </summary>
        <param name="oExpression1">
            指定要比较的对象。oExpression1和oExpression2可以是任何计算结果为对象的表达式，
            如对象引用、对象变量或对象数组元素。
        </param>
        <param name="oExpression2">
            指定要比较的对象。oExpression1和oExpression2可以是任何计算结果为对象的表达式，
            如对象引用、对象变量或对象数组元素。
        </param>
        <returns>
            逻辑值
        </returns>
        <remarks>
            如果一个对象有另一个对象没有的属性，或者对象有相同的属性但一个或多个属性的值不同，
            CompObj()返回False（.F.）。
        </remarks>
        <example>
             <code language="X#">
                lstMyList1 = CreateOBJ('ListBox')  &amp;&amp; 创建一个ListBox
                lstMyList2 = CreateOBJ('ListBox')  &amp;&amp; 创建第二个ListBox
                cmbMyCombo = CreateOBJ('ComboBox')  &amp;&amp; 创建一个ComboBox
                lstMyList1.Name = 'list1'
                lstMyList2.Name = 'list2'
                Clear
                ? lstMyList1.Name  &amp;&amp; 显示List1的Name属性
                ? lstMyList2.Name  &amp;&amp; 显示List2的Name属性
                ? CompObj(lstMyList1, cmbMyCombo)     &amp;&amp; 显示.F.
                ? CompObj(lstMyList1, lstMyList2)     &amp;&amp; 显示.F.，Name不同
                lstMyList2.Name = lstMyList1.Name
                ? CompObj(lstMyList1, lstMyList2)     &amp;&amp; 显示.T.，属性相同
            </code>
        </example>
    </compobj>

    <cpconvert>
        <summary>
            将字符或备注字段或字符表达式转换为另一个代码页。
        </summary>
        <param name="nCurrentCodePage">
            指定cExpression正在从哪个代码页转换。
        </param>
        <param name="nNewCodePage">
            指定cExpression要转换到的代码页。
        </param>
        <param name="cExpression">
            指定要转换的字符表达式。
        </param>
        <remarks>
            请注意，CPConvert()对于产品的正常跨平台功能并不是必需的。
            它仅用于访问X#的底层翻译功能。
            例如，如果变量<c>gcCharExpr</c>在Macintosh上（代码页10000）包含一个看起来像的字符，
            那么CPConvert()将返回一个在Microsoft Windows（代码页1252）中看起来像的字符：
             <code language="X#">CPConvert(10000, 1252, gcCharExpr)</code>
            有关代码页和X#国际化支持的更多信息，请参阅X#支持的代码页和开发国际化应用程序。
        </remarks>
    </cpconvert>

    <cpcurrent>
        <summary>
            返回X#配置文件中的代码页设置（如果有），或返回当前操作系统的代码页。
        </summary>
        <remarks>
            CPCurrent([1 | 2])备注
            CPCurrent()返回以下之一：
            在X#中，如果配置文件中未包含CODEPAGE配置项，则返回当前操作系统的代码页。
            在FoxPro的早期版本中，如果配置文件中未包含CODEPAGE配置项，则返回0。
            CODEPAGE配置项中指定的代码页号。
            例如，如果在配置文件中包含以下行，CPCurrent()将返回852：
             <code language="X#">CODEPAGE = 852</code>
            如果在配置文件中包含以下行，则返回当前操作系统的代码页：
             <code language="X#">CODEPAGE = AUTO</code>
            在X#中，CPCurrent(1)返回当前操作系统的代码页，无论配置中的CODEPAGE设置如何。
            CPCurrent(2)始终返回底层操作系统的代码页，无论配置中的CODEPAGE设置如何。
            例如，如果您运行的是Windows，CPCurrent(2)将返回MS-DOS代码页。
            有关代码页和X#国际化支持的更多信息，请参阅X#支持的代码页和开发国际化应用程序。
        </remarks>
    </cpcurrent>

    <createobject>
        <summary>
            从类定义或支持自动化的应用程序创建对象。
        </summary>
        <param name="cClassName">
            指定要从中创建新对象的类或OLE对象。X#按以下顺序搜索类或OLE对象：<br/>
            X#基类<br/>
            当前程序中的类<br/>
            使用Set CLASSLIB打开的.vcx类库中的类<br/>
            使用Set PROCEDURE打开的过程文件中的类<br/>
            X#程序执行链中的类<br/>
            如果Set OLEOBJECT为ON，则搜索OLE注册表<br/>
            OLE对象使用以下语法创建ClassName：<br/>
             <code language="X#">ApplicationName.Class</code>
            例如，要创建Microsoft Excel工作表（支持自动化），可以使用以下语法：<br/>
             <code language="X#">x = CreateObject('Excel.Sheet')</code>
            运行此代码时，将启动Microsoft Excel（如果尚未运行），并创建一个新工作表。<br/>
            类库可以有别名。要指定具有别名的类库中的对象，
            请包含类库别名，后跟句点和对象名称。
            注意，ClassName不能是X# OLE Container控件基类。
        </param>
        <returns>
            对象
        </returns>
        <remarks>
            eParameter1, eParameter2, ...<br/>
            这些可选参数用于将值传递给类的Init事件过程。<br/>
            当您发出CreateObject()时，将执行Init事件，允许您初始化对象。<br/>
            使用CreateObject()从类定义或支持自动化的应用程序创建对象，
            并将对象的引用分配给系统变量或数组元素。<br/>
            在从用户定义的类创建对象之前，必须首先使用DEFINE CLASS创建用户定义的类，
            或者它必须在使用Set CLASSLIB打开的.vcx可视类库中可用。<br/>
            使用=或STORE将对象的引用分配给系统变量或数组元素。
            如果分配给系统变量或数组元素的对象被释放，系统变量或数组元素将包含空值。
            使用RELEASE从内存中删除系统变量或数组元素。<br/>
        </remarks>
        <example>
             <code language="X#">
                Clear
                * 验证当前类库设置
                cCurClassLib=Set("CLASSLIB")

                IF LEN(ALLTRIM(cCurClassLib))=0
                    cCurClassLib="None"
                ENDIF

                WAIT "当前类库是：" + cCurClassLib + CHR(13);
                + "按任意键继续..."
                frmMyForm = CreateObject("FormGrandChild")

                * 创建一个数组
                For nCount = 1 TO AClass(gaNewarray, frmMyForm)
                    ? gaNewarray(nCount)  &amp;&amp; 显示类的名称
                ENDFor

                RELEASE frmMyForm

                * 从ForM基类创建FormChild
                DEFINE CLASS FormChild AS ForM
                ENDDEFINE

                * 从用户定义的FormChild类创建FormGrandChild
                DEFINE CLASS FormGrandChild AS FormChild
                ENDDEFINE
            </code>
        </example>
    </createobject>

    <createoffline>
        <summary>
            将现有视图脱机。
        </summary>
        <param name="ViewName">
            指定要脱机的现有视图的名称。包含现有视图的数据库必须在您将现有视图脱机之前打开。
        </param>
        <param name="cPath">
            指定放置脱机视图的目录和脱机视图的名称。
        </param>
        <returns>
            逻辑值
        </returns>
        <remarks>
            如果成功将现有视图脱机，CreateOffline() 返回逻辑值 true (.T.)；否则返回 false (.F.)。<br/>
            脱机视图使用 Use 命令打开。当脱机视图打开时，您可以向脱机视图添加记录或对记录进行更改。
            但是，您不能在脱机视图中使用 Create Trigger、Insert、Pack 或 Zap 命令。对脱机视图进行更改后，
            您可以通过使用 Use 命令打开脱机视图并包含 Online 子句来用您的更改更新服务器上的数据。<br/>
            在使用 Use 命令和 Online 子句打开脱机视图之前，您无法用服务器上的数据刷新脱机视图的内容。<br/>
            使用 DropOffline() 将脱机视图重新联机。
        </remarks>
    </createoffline>

    <ctobin>
        <summary>
            将二进制字符表示转换为数值。
        </summary>
        <param name="cExpression">
            指定要转换的二进制字符表示。
        </param>
        <param name="cFlags">
            如果使用8字节数据类型（例如货币或双精度）生成了cExpression指定的二进制字符表示，
            请包含cFlags以控制CToBin()返回的值类型。
        </param>
        <returns>
            数值。<b>CToBin()</b>从二进制字符表达式返回一个数值。
        </returns>
        <remarks>
            <list type="table">
                <listheader>
                    <term>cFlags</term>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>cExpression是1字节长的表达式。</description>
                </item>
                <item>
                    <term>2</term>
                    <description>cExpression是2字节长的表达式。</description>
                </item>
                <item>
                    <term>4</term>
                    <description>cExpression是4字节长的表达式。</description>
                </item>
                <item>
                    <term>8</term>
                    <description>cExpression是8字节长的表达式。</description>
                </item>
                <item>
                    <term>B</term>
                    <description>
                        cExpression是双精度数据类型，必须是8字节长。<br/>
                        CToBin()返回双精度数据类型值。这是8字节长表达式的默认设置。
                    </description>
                </item>
                <item>
                    <term>N</term>
                    <description>
                        cExpression是数值数据类型，必须是4或8字节长。<br/>
                        CToBin()返回数值类型值。
                    </description>
                </item>
                <item>
                    <term>Y</term>
                    <description>
                        cExpression是货币数据类型，必须是8字节长。<br/>
                        CToBin()返回货币类型值。
                    </description>
                </item>
                <item>
                    <term>R</term>
                    <description>反转二进制表达式。</description>
                </item>
                <item>
                    <term>S</term>
                    <description>防止数字的符号位被切换（BitXOR）。</description>
                </item>
            </list>
            cFlags参数是一个字符表达式。'R'和'S'设置是可累加的，而其他设置是互斥的。
            字符设置可以以大写或小写形式传递（例如，'R'或'r'）。指定'1'、'2'或'4'的值不是必需的，
            但作为一种方便提供，以反馈cExpression的长度。<br/>
            以下示例展示了cFlags参数的各种用法。
             <code language="X#">
                ? CToBin("A")&amp;&amp; 等同于 CToBin("A","1")
                ? CToBin(BinToc($12.34,"8"),"Y")
                ? CToBin(BinToc(12.34,"8"),"B")
                ? CToBin(BinToc(PI(),"BR"),"NRS")
            </code>
            您可以使用CToBin()将使用BinToc()创建的二进制字符表示转换为其整数值。
            在使用Win32 API例程时，CToBin()也可用于需要转换Win32结构成员的情况。
            'R'和'S'设置允许您更有效地使用CToBin()处理这些场景。
        </remarks>
    </ctobin>

    <ctot>
        <summary>
            从字符表达式返回一个DateTime值。
        </summary>
        <param name="cCharacterExpression">
            指定从中返回DateTime值的字符表达式。
        </param>
        <returns>
            DateTime数据类型。CToT()从字符表达式返回一个DateTime值。
        </returns>
        <remarks>
            <note>
                当Set STRICTDATE设置为2时，CToT()可能创建模糊的DateTime值并生成编译错误。
                要创建非模糊的Date值，请使用DATETIME()函数。
            </note>
            X#支持原生SQL数据类型Datetime和Smalldatetime，它们在SQL XML中以24小时格式返回。
            <note>CToT()函数不处理T-SQL Convert()函数返回datetime和smalldatetime值的19种不同方式。</note>
            要转换来自Access、SQL Server、Visual Studio和XML的日期格式，您必须调用适当的Set DATE设置以正确解释DateTime字符串。
            但是，如果XML日期字符串中有大写T，X#会通过内部调用Set DATE YMD覆盖当前日期设置，
            并在退出CToT()时恢复当前日期设置。
            <note>
                CToT()将这些日期解析为X# DateTime数据类型的精度限制。
                因此，在使用某些格式的CToT()时可能会丢失精度。X# DateTime数据类型不支持毫秒或时区。
            </note>
            CToT()遵守Set CENTURY命令的设置。有关更多信息，请参见Set CENTURY命令。<br/><br/>
            以下示例展示了CToT()如何处理来自不同源的DateTime值。
            在所有示例中，CToT()无需调用Set DATE YMD就能正确转换DateTime值。
            Access 2000 XML日期格式
             <code language="X#">
                * 2000-10-24T13:30:00 (从Access导出的24小时格式，
                * 无论原始格式是12小时还是24小时)
                ? CToT("2000-10-24T13:30:00")
            </code>
            SQL Server 2000 XML日期格式
             <code language="X#">
                ? CToT("2000-10-24T20:47:58.170")   &amp;&amp; datetime (24小时格式)
                ? CToT("2000-10-24T21:11:00")         &amp;&amp; Small DT (24小时格式)
                ? CToT("2000-10-03T02:02:02")
            </code>
            Visual Studio XML
             <code language="X#">? CToT("2002-10-05T04:04:04.0000000-07:00")</code>
            简单对象访问协议（SOAP）
             <code language="X#">? CToT("2001-09-14T07:00:00Z")</code>
        </remarks>
    </ctot>

    <cursorgetprop>
        <summary>
            检索X#表或游标的当前属性设置。
            <note name="tip">
                要为X#表或游标设置特定属性，请使用<b>CursorGetProp( )</b>。
                有关每个属性及其设置的更多信息，请参见CursorGetProp( )函数。
            </note>
        </summary>
        <param name="cProperty">
            指定要检索的属性设置。有关可能的属性，请参见备注部分的表格。
        </param>
        <param name="uArea">
            指定要返回属性设置的表或游标的工作区号或别名。
            如果为uArea指定0，<b>CursorGetProp( )</b>将返回环境设置。
        </param>
        <returns>
            字符、数值或逻辑数据类型
        </returns>
        <remarks>
            如果在没有可选uArea参数的情况下发出<b>CursorSetProp( )</b>，则返回当前选定工作区中打开的表或游标的当前属性设置。
            如果在没有选择表、打开游标或指定别名的情况下使用CursorGetProp( )，
            您将得到错误52（当前工作区中没有打开的表。），除非指定了工作区，如以下示例所示：
            CursorSetProp("Refresh",-2,0)。<br/><br/>
            下表包括可以返回其设置的属性列表、返回值的数据类型以及返回值的描述。
            <list type="table">
                <listheader>
                    <term>cProperty</term>
                    <description>类型</description>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>ADOBookmark</term>
                    <description>变体</description>
                    <description>包含一个值，对应于基于ADO的游标中当前记录的ADO书签。</description>
                </item>
                <item>
                    <term>ADOCodePage</term>
                    <description>N</description>
                    <description>返回由ADOCodePage属性指定的绑定到基于ADO的游标的代码页。只读。</description>
                </item>
                <item>
                    <term>ADORecordset</term>
                    <description>O</description>
                    <description>
                        包含与游标关联的ActiveX数据对象（ADO）记录集的对象引用。
                        对于不基于ADO记录集的游标无效。只读。
                    </description>
                </item>
                <item>
                    <term>AllowSimultaneousFetch</term>
                    <description>L</description>
                    <description>
                        适用于使用远程视图、共享连接和使用ODBC创建的游标。<br/>
                        当允许共享连接的类似配置的游标同时获取行时，AllowSimultaneousFetch包含True (.T.)。<br/>
                        否则，当不允许同时获取行时，AllowSimultaneousFetch包含False (.F.)。
                    </description>
                </item>
                <item>
                    <term>AutoIncError</term>
                    <description>L</description>
                    <description>
                        当尝试在使用自动递增字段值的字段中插入或更新值时生成错误消息时，包含True (.T.)。<br/>
                        当尝试在使用自动递增字段值的字段中插入或更新值时不生成错误消息，
                        并且指定要插入或更新的值被忽略时，包含False (.F.)。<br/>
                        适用于游标和会话。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>BatchUpdateCount</term>
                    <description>N</description>
                    <description>
                        包含为缓冲表发送到远程数据源的更新语句数。默认值为1。
                        调整此值可以大大提高更新性能。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>Buffering</term>
                    <description>N</description>
                    <description>
                        1 – 行和表缓冲关闭。（默认）<br/>
                        2 – 悲观行缓冲开启。<br/>
                        3 – 乐观行缓冲开启。<br/>
                        4 – 悲观表缓冲开启。<br/>
                        5 – 乐观表缓冲开启。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>CompareMemo</term>
                    <description>L</description>
                    <description>
                        如果更新的Where子句包括Memo、General或Picture类型的备注字段，则包含True (.T.)。（默认）<br/>
                        否则，包含False (.F.)。<br/>
                        仅适用于视图。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>ConnectHandle</term>
                    <description>N</description>
                    <description>
                        连接句柄。此属性仅在数据源包含远程表时有效。
                        为视图获得的连接句柄可能在视图关闭时关闭。<br/>
                        只读。
                    </description>
                </item>
                <item>
                    <term>ConnectName</term>
                    <description>C</description>
                    <description>
                        创建游标时使用的连接名称。此属性仅在数据源包含远程表时有效。<br/>
                        只读。
                    </description>
                </item>
                <item>
                    <term>Database</term>
                    <description>C</description>
                    <description>
                        包含表或视图的数据库的名称。如果表是自由表，Database包含一个空字符串。<br/>
                        只读。
                    </description>
                </item>
                <item>
                    <term>FetchAsNeeded</term>
                    <description>L</description>
                    <description>
                        如果为True (.T.)，则仅在需要时获取数据，例如当记录指针移动到尚未获取的行时。<br/>
                        如果为False (.F.)，则在空闲时获取额外数据。（默认）
                        <note>当禁用渐进获取时（FetchSize为-1），FetchAsNeeded不适用。</note>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>FetchIsComplete</term>
                    <description>L</description>
                    <description>
                        如果为True (.T.)，则ODBC或基于ADO的游标的获取过程已完成。<br/>
                        如果为False (.F.)，则获取过程尚未完成。<br/>
                        此选项不支持表和本地视图，也不支持环境级别（工作区0）。
                    </description>
                </item>
                <item>
                    <term>FetchMemo*</term>
                    <description>L</description>
                    <description>
                        如果备注字段与视图结果一起获取，则包含True (.T.)。否则，包含False (.F.)。（默认）<br/>
                        使用ISMEMOFETCHED( )函数确定是否已获取备注字段。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>FetchSize*</term>
                    <description>N</description>
                    <description>
                        包含一次从远程表获取的行数。
                        默认值为100行。将FetchSize设置为–1将检索完整的结果集，受MaxRecords设置的限制。
                        <note>
                            渐进获取会保持连接，直到检索所有行。
                            如果ShareConnection为True (.T.)，请谨慎使用FetchSize进行编码。
                        </note>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>KeyFieldList</term>
                    <description>C</description>
                    <description>
                        游标的主要字段的逗号分隔列表。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>MapBinary</term>
                    <description>L</description>
                    <description>
                        如果启用了Varbinary映射，则包含True (.T.)。否则，包含(.F.)。<br/>
                        仅当uArea设置为0时可读/写。对于SQL直通游标只读。对于表游标无效（uArea等于或大于1）。
                    </description>
                </item>
                <item>
                    <term>MapVarchar</term>
                    <description>L</description>
                    <description>
                        如果启用了Varchar映射，则包含True (.T.)。否则，包含False (.F.)。<br/>
                        仅当uArea设置为0时可读/写。对于SQL直通游标只读。对于表游标无效（uArea等于或大于1）。
                    </description>
                </item>
                <item>
                    <term>MaxRecords*</term>
                    <description>N</description>
                    <description>
                        返回结果集时获取的最大行数。默认值为– 1（返回所有行）。
                        值为0指定执行视图但不获取结果。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>ParameterList</term>
                    <description>C</description>
                    <description>
                        视图参数和参数类型的分号分隔列表。仅适用于视图。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>Prepared</term>
                    <description>L</description>
                    <description>
                        如果为后续Requery( )函数调用准备了SQL语句，则包含True (.T.)。否则，包含False (.F.)。（默认）<br/>
                        Requery( )用于再次检索SQL视图的数据。有关准备SQL语句的更多信息，请参见SqlPrepare( )。仅适用于视图。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>RecordsFetched</term>
                    <description>N</description>
                    <description>
                        包含一个数值，表示从ODBC或基于ADO的游标的数据源获取的记录数。<br/>
                        如果本地删除或追加了记录，此数值可能不反映游标的当前记录计数。<br/>
                        此选项不支持表和本地视图，也不支持环境级别（工作区0）。<br/>
                        <note>在记录计数中忽略任何过滤条件。</note>
                        只读。
                    </description>
                </item>
                <item>
                    <term>Refresh</term>
                    <description>N</description>
                    <description>
                        包含一个数值，表示当前数据会话中单个游标的刷新设置，
                        或当前数据会话中新打开游标的初始刷新值。
                    </description>
                </item>
                <item>
                    <term>SendUpdates</term>
                    <description>L</description>
                    <description>
                        如果在使用视图进行更新时发送SQL更新查询以更新表，则包含True (.T.)；否则，包含false (.F.)（默认）。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>SourceName</term>
                    <description>N</description>
                    <description>
                        1 – 数据源是本地SQL视图。<br/>
                        101 (1 + 100) - 游标由CursorFill方法创建。<br/>
                        201 (1 + 200) - 游标使用CursorAttach方法附加到CursorAdapter对象。<br/>
                        2 – 数据源是远程SQL视图。<br/>
                        102 (2 + 100) - 游标由CursorFill创建。<br/>
                        202 (2 + 200) - 游标使用CursorAttach附加到CursorAdapter对象。<br/>
                        3 – 数据源是表。<br/>
                        103 (3 + 100) - 游标由CursorFill创建。<br/>
                        203 (3 + 200) - 游标使用CursorAttach附加到CursorAdapter对象。<br/>
                        4 - 游标基于ADO记录集并附加到CursorAdapter对象。<br/>
                        104 (4 + 100) - 游标由CursorFill创建。<br/>
                        204 (4 + 200) - 游标使用CursorAttach附加到CursorAdapter对象。<br/>
                        只读。
                    </description>
                </item>
                <item>
                    <term>SQL</term>
                    <description>C</description>
                    <description>
                        创建游标时执行的SQL语句。<br/>
                        只读。
                    </description>
                </item>
                <item>
                    <term>Tables</term>
                    <description>C</description>
                    <description>
                        表名的逗号分隔列表。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>UpdatableFieldList</term>
                    <description>C</description>
                    <description>
                        视图中字段的逗号分隔列表。此列表可以包括来自本地和远程表的字段。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>UpdateNameList</term>
                    <description>C</description>
                    <description>
                        远程字段名称和分配给游标的本地字段名称的逗号分隔列表。
                        使用此选项为游标中具有无效Visual FoxPro字段名称的字段指定有效的Visual FoxPro名称。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>UpdateType</term>
                    <description>N</description>
                    <description>
                        1 – 指定用新数据更新旧数据。（默认）<br/>
                        2 – 指定通过删除旧数据并插入新数据来进行更新。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>UseMemoSize*</term>
                    <description>N</description>
                    <description>
                        结果列以备忘录字段形式返回的最小大小（以字节为单位）。
                        例如，如果列结果的宽度大于UseMemoSize的值，则列结果将存储在备忘录字段中。
                        UseMemoSize可以从1到255变化；默认值为255。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>WhereType</term>
                    <description>N</description>
                    <description>
                        用于更新表的Where子句。WhereType可以指定以下值：<br/>
                        1或DB_KEY（来自Foxpro.H）。用于更新表的Where子句仅包含使用KeyFieldList属性指定的主要字段。<br/>
                        2或DB_KEYANDUPDATable（来自Foxpro.H）。用于更新表的Where子句
                        包含使用KeyFieldList属性指定的主要字段和任何可更新字段。<br/>
                        3或DB_KEYANDMODIFIED（来自Foxpro.H）（默认）。用于更新表的Where子句
                        包含使用KeyFieldList属性指定的主要字段和任何其他已修改的字段。<br/>
                        4或DB_KEYANDTIMESTAMP（来自Foxpro.H）。用于更新表的Where子句
                        包含使用KeyFieldList属性指定的主要字段和时间戳的比较。<br/>
                        可读/写。
                    </description>
                </item>
            </list>
            * 此属性返回的值仅对远程视图有意义；
            如果您获取本地视图的此属性，<b>CursorGetProp( )</b>函数将返回默认值。
        </remarks>
        <example>
            当打开游标时，AutoIncError属性的默认值从会话默认值读取，
            该值是当前默认数据会话设置。
            以下示例展示了如何通过指定0（默认会话）作为最后一个参数来检索每个会话的默认AutoIncError值：
             <code language="X#">CursorGetProp("AutoIncError", 0) </code>
            打开新的私有数据会话或游标时使用默认会话。
            以下示例展示了如何通过使用uArea参数作为最后一个参数来检索每个表的游标或表AutoIncError设置：
             <code language="X#">CursorGetProp("AutoIncError", uArea)</code>
            以下示例在"Testdata"数据库中打开"Customer"表，并使用<b>CursorGetProp( )</b>显示表的缓冲模式
            以及包含该表的数据库的名称：
             <code language="X#">
                Close Databases
                Clear
                Open Database (HOME(2) + 'data\testdata')
                Use customer     &amp;&amp; 打开customer表
                ? CursorGetProp("Buffering") &amp;&amp; 显示缓冲模式
                ? CursorGetProp("Database")  &amp;&amp; 显示数据库名称
            </code>
        </example>
    </cursorgetprop>

    <cursorsetprop>
        <summary>
            指定X#表或游标的属性设置。
        </summary>
        <param name="cProperty">
            指定要设置的表或游标属性。对于X#表，只能指定Buffering属性。
        </param>
        <param name="eExpression">
            指定用cProperty指定的属性的值。如果省略eExpression，属性将设置为其默认值。<br/>
            remarks部分的表列出了可以为cProperty指定的属性，以及eExpression可以采用的值的描述。
        </param>
        <param name="uArea">
            指定要为其设置属性的表或游标的别名，或指定要为其设置属性的表或游标的工作区。<br/>
            如果为uArea指定0，<b>CursorSetProp( )</b>将为所有后续表或游标设置环境设置。<br/>
            缓冲不适用于隐式打开的表，例如使用SQL Insert/Update/Delete命令。
        </param>
        <returns>
            逻辑数据类型。如果X#成功设置了您指定的属性，<b>CursorSetProp( )</b>返回True (.T.)。
            如果无法设置您指定的属性，X#会生成错误。
        </returns>
        <remarks>
            <b>CursorSetProp( )</b>的Buffering属性的设置决定了X#如何执行记录锁定和更新缓冲。
            有关记录锁定和更新缓冲的更多信息，请参见如何：缓冲数据。<br/>
            <b>CursorSetProp( )</b>的WhereType属性的设置决定了如何对远程表执行更新。
            有关远程表更新的更多信息，请参见开发数据库。<br/>
            您可以使用<b>CursorSetProp( )</b>来覆盖游标的<b>SqlSetProp( )</b>函数中的FetchSize属性。
            默认情况下，此属性从游标的连接句柄继承。<br/>
            使用<b>CursorGetProp( )</b>返回X#表或为表创建的游标的当前属性设置。<br/>
            如果在没有可选uArea参数的情况下发出<b>CursorSetProp( )</b>，
            则属性设置将指定为当前选定工作区中的打开表或游标。
            <list type="table">
                <listheader>
                    <term>属性</term>
                    <desdription>eExpression值</desdription>
                </listheader>
                <item>
                    <term>AllowSimultaneousFetch</term>
                    <description>
                        适用于使用远程视图、共享连接和使用ODBC创建的游标。<br/>
                        .T. - 允许共享连接的类似配置的游标同时获取行。<br/>
                        .F. - 不允许共享连接的类似配置的游标同时获取行。
                    </description>
                </item>
                <item>
                    <term>AutoIncError</term>
                    <description>
                        .T. - 在尝试插入或更新使用自动递增字段值的字段中的值时生成错误消息。<br/>
                        .F. - 不生成错误消息，但在尝试插入或更新使用自动递增字段值的字段中的值时不使用指定的值，
                        而是使用适当的递增值。<br/>
                        适用于游标和会话。
                    </description>
                </item>
                <item>
                    <term>BatchUpdateCount*</term>
                    <description>
                        指定要发送到远程数据源的缓冲表的更新语句数。
                        默认值为1。调整此值可以在使用自动更新时大大提高更新性能。
                    </description>
                </item>
                <item>
                    <term>Buffering</term>
                    <description>
                        1 – 关闭行和表缓冲。记录锁定和数据写入与早期FoxPro版本相同。（默认）<br/>
                        2 – 开启悲观行缓冲。<br/>
                        3 – 开启乐观行缓冲。<br/>
                        4 – 开启悲观表缓冲。<br/>
                        5 – 开启乐观表缓冲。除了1（关闭）之外，所有缓冲模式都必须将<b>Set multilocs</b>设置为<b>on</b>。
                    </description>
                </item>
                <item>
                    <term>CompareMemo</term>
                    <description>
                        .T. - 在更新的<b>Where</b>子句中包含Memo、General或Picture类型的备注字段。<br/>
                        .F. – 不在更新的Where子句中包含备注字段。<br/>
                        适用于使用自动更新时。
                    </description>
                </item>
                <item>
                    <term>FetchAsNeeded</term>
                    <description>
                        .T. – 仅在需要时获取记录，例如当记录指针移动到尚未获取的行时。<br/>
                        .F. – 在空闲时获取额外数据。<br/>
                        <note name="注意">当禁用渐进式获取（FetchSize为-1）时，FetchAsNeeded不适用。</note>
                    </description>
                </item>
                <item>
                    <term>FetchMemo*</term>
                    <description>
                        .T. – 随视图结果获取备注字段。<br/>
                        .F. – 不随视图结果获取备注字段。
                    </description>
                </item>
                <item>
                    <term>FetchSize*</term>
                    <description>
                        指定从远程表结果集渐进获取的行数。默认值为100行。
                        将FetchSize设置为–1将检索完整的结果集，受MaxRecords设置的限制。<br/>
                        <note name="注意">
                            渐进式获取会保持连接直到检索所有行。
                            如果ShareConnection为True (.T.)，在使用FetchSize时要谨慎编码。
                        </note>
                    </description>
                </item>
                <item>
                    <term>KeyFieldList</term>
                    <description>
                        指定游标的主要字段的逗号分隔列表。没有默认值。
                        使用自动更新时，必须包含字段名列表才能进行更新。
                    </description>
                </item>
                <item>
                    <term>MapBinary</term>
                    <description>
                        .T. - 在会话级别，SQL Pass-Through将SQL_BINARY、SQL_VARBINARY和
                        SQL_LONGVARBINARY ODBC类型映射到<b>Varbinary</b>或<b>Blob</b>数据类型。<br/>
                        对于远程视图，<b>Create SQL View</b>命令将SQL_LONGVARBINARY ODBC数据源类型映射到<b>Blob</b>类型，
                        当数据源中相应列的精度小于或等于254字节时，将SQL_BINARY和SQL_VARBINARY ODBC数据源类型映射到<b>Varbinary</b>类型。
                        当精度大于254字节时，这些类型映射到<b>Blob</b>类型。<br/>
                        .F. - SQL Pass-Through将SQL_BINARY和SQL_VARBINARY ODBC类型映射到<b>Character</b>类型。（默认）<br/>
                        对于远程视图，<b>Create SQL View</b>命令将SQL_BINARY和SQL_VARBINARY ODBC数据源类型映射到<b>Memo</b>类型。<br/>
                        <note name="注意">
                            对于uArea设置为0，<b>MapBinary</b>是读/写的；对于SQL Pass-Through游标，是只读的；对于表游标
                            （uArea等于或大于1），是无效的。
                        </note>
                    </description>
                </item>
                <item>
                    <term>MapVarchar</term>
                    <description>
                        .T. - 在会话级别，SQL Pass-Through将SQL_WVARCHAR和SQL_VARCHAR ODBC类型映射到<b>Varchar</b>类型。<br/>
                        对于远程视图，<b>Create SQL View</b>命令将SQL_WVARCHAR和SQL_VARCHAR ODBC数据源类型映射到<b>Varchar</b>类型。<br/>
                        .F. - SQL Pass-Through将SQL_WVARCHAR和SQL_VARCHAR ODBC类型映射到Character类型。（默认）<br/>
                        对于远程视图，<b>Create SQL View</b>命令将SQL_WVARCHAR和SQL_VARCHAR ODBC数据源类型映射到<b>Character</b>类型。<br/>
                        <note name="注意">
                            对于uArea设置为0，<b>MapVarchar</b>是读/写的；对于SQL Pass-Through游标，是只读的；对于表游标（uArea等于或大于1），是无效的。
                        </note>
                    </description>
                </item>
                <item>
                    <term>MaxRecords*</term>
                    <description>
                        指定返回结果集时获取的最大行数。默认值为– 1，返回所有行。
                        值为0指定执行视图但不获取任何结果。
                    </description>
                </item>
                <item>
                    <term>ParameterList</term>
                    <description>指定视图参数和参数类型的分号分隔列表。仅适用于视图。</description>
                </item>
                <item>
                    <term>Prepared</term>
                    <description>
                        .T. - 为后续的<b>Requery( )</b>函数调用准备SQL语句。<br/>
                        .F. - 不为后续的<b>Requery( )</b>调用准备SQL语句。（默认）<br/>
                        <b>Requery( )</b>用于再次检索SQL视图的数据。
                        有关准备SQL语句的更多信息，请参见SqlPrepare( )函数。
                    </description>
                </item>
                <item>
                    <term>Refresh</term>
                    <description>
                        为当前数据会话中的单个游标指定数值刷新值，或为新打开的游标指定初始刷新值。<br/>
                        使用Set DATASESSION命令选择特定的数据会话，并使用uWorkArea参数指定特定的游标。
                        使用uArea = 0更改所有新打开游标的初始刷新值。
                        已经打开的任何游标不会受到新刷新设置的影响。<br/>
                        Set Refresh命令允许您指定全局刷新值。默认情况下，CursorSetProp( ) Refresh设置为-2，
                        表示使用当前的全局Set Refresh值。全局Set Refresh值通过其第二个参数nSeconds2指定。<br/>
                        您可以将CursorSetProp( ) Refresh设置设为与Set Refresh中的nSeconds2参数相同的值。<br/>
                        <note name="注意">如果Set Refresh命令中的nSeconds2参数当前设置为零，则会忽略CursorSetProp( ) Refresh设置。</note>
                    </description>
                </item>
                <item>
                    <term>SendUpdates</term>
                    <description>
                        .T. – 指定在使用视图进行更新时发送SQL更新查询以更新表。<br/>
                        .F. – 指定不发送SQL更新查询以更新表。
                    </description>
                </item>
                <item>
                    <term>Tables</term>
                    <description>
                        指定远程表名称的逗号分隔列表。没有默认值。
                        使用自动更新时，必须包含表名列表才能进行更新。
                    </description>
                </item>
                <item>
                    <term>UpdateableFieldList</term>
                    <description>
                        指定视图中字段的逗号分隔列表。此列表可以包括来自本地和远程表的字段。
                        使用自动更新时，必须包含字段列表才能进行更新。
                    </description>
                </item>
                <item>
                    <term>UpdateNameList</term>
                    <description>
                        指定远程字段名称和分配给游标的本地字段名称的逗号分隔列表。
                        使用此选项为游标中具有无效Visual FoxPro字段名的字段指定有效的Visual FoxPro名称。
                    </description>
                </item>
                <item>
                    <term>UpdateType</term>
                    <description>
                        1 – 用新数据更新旧数据。（默认）<br/>
                        2 – 通过删除旧数据并插入新数据来更新。
                    </description>
                </item>
                <item>
                    <term>UseMemoSize*</term>
                    <description>
                        指定结果列返回为备注字段的最小字节大小。
                        例如，如果列结果的宽度大于UseMemoSize的值，则列结果将存储在备注字段中。
                        UseMemoSize可以从1到255字节不等。<br/>
                        默认值为255字节。
                    </description>
                </item>
                <item>
                    <term>WhereType</term>
                    <description>
                        用于更新远程表的<b>Where</b>子句。WhereType可以采用以下值：<br/>
                        1或<b>DB_KEY</b>（来自Foxpro.H）。用于更新远程表的<b>Where</b>子句仅包含
                        由KeyFieldList属性指定的主键字段。<br/>
                        2或<b>DB_KEYANDUPDATable</b>（来自Foxpro.H）。用于更新远程表的<b>Where</b>子句
                        包含由KeyFieldList属性指定的主键字段和任何可更新字段。<br/>
                        3或<b>DB_KEYANDMODIFIED</b>（来自Foxpro.H）。用于更新远程表的<b>Where</b>子句
                        包含由KeyFieldList属性指定的主键字段和任何其他已修改的字段。（默认）<br/>
                        4或<b>DB_KEYANDTIMESTAMP</b>（来自Foxpro.H）。用于更新远程表的<b>Where</b>子句
                        包含由KeyFieldList属性指定的主键字段和时间戳的比较。
                    </description>
                </item>
            </list>
            * 此属性主要用于远程视图；对本地视图设置它没有效果。但是，您可以为将要升级的本地视图预设此属性。
        </remarks>
        <example>
            当打开游标时，AutoIncError属性的默认值从会话默认值读取，
            该值是当前默认数据会话设置。以下示例展示了如何通过指定0（默认会话）作为最后一个参数来为每个会话设置默认AutoIncError值：
             <code language="X#">CursorSetProp("AutoIncError", .T., 0) </code>
            打开新的私有数据会话或游标时使用默认会话。以下示例展示了如何通过使用uArea参数作为最后一个参数来为每个表设置游标或表AutoIncError设置：
             <code language="X#">CursorSetProp("AutoIncError", .F. , uArea )</code>
            以下示例演示了如何使用<b>CursorSetProp( )</b>启用乐观表缓冲。将<b>MultiLocks</b>设置为
            <b>ON</b>，这是表缓冲的必要条件。打开"testdata"数据库中的"Customer"表，并使用<b>CursorSetProp( )</b>
            将缓冲模式设置为乐观表缓冲（5）。显示一个消息框，显示操作结果。
             <code language="X#">
                Close Databases
                Clear
                Set MultiLocks ON
                Open Database (HOME(2) + 'data\testdata')
                Use Customer     &amp;&amp; 打开Customer表
                * 设置缓冲模式并存储逻辑结果
                lSuccess=CursorSetProp("Buffering", 5, "Customer")

                IF lSuccess = .T.
                    =MessageBox("操作成功！",0,"操作状态")
                ELSE
                    =MessageBox("操作未成功！",0,"操作状态")
                ENDIF
            </code>
        </example>
    </cursorsetprop>

    <cursortoxml>
        <summary>
            将X#游标转换为XML。
        </summary>
        <param name="uArea">
            指定要从中创建XML字符串的表的工作区号或别名。
            如果指定0或不指定值，X#将使用当前工作区。
        </param>
        <param name="cOutput">
            指定结果发送到的路径和文件名或内存变量名。
            如果nFlags设置为0（默认）用于内存变量输出，XML将返回到内存变量。
            如果内存变量不存在，将创建它。
            如果nFlags设置为512用于文件输出，且文件不存在，将创建该文件。
            如果文件已存在，将被覆盖。遵守<b>Set SAFETY</b>的设置。
        </param>
        <param name="nOutputFormat">
            指定XML字符串的输出格式。备注部分的表列出了nOutputFormat的值。
        </param>
        <param name="nFlags">
            指定生成的XML的格式及其目标。备注部分的表列出了nFlags的值。
        </param>
        <param name="nRecords">
            指定要输出到XML的记录数，默认值为0。<br/>
            如果nRecords为0，则输出所有记录。如果nRecords大于表中剩余的记录数，
            将输出所有剩余记录。
        </param>
        <param name="cSchemaName">
            指定包含cOutput中数据的架构信息的名称和位置，例如"MySchema.xsd"。
            如果未提供扩展名，将使用.xsd扩展名创建架构文件。<br/>
            备注部分的表列出了cSchemaName的值。
        </param>
        <param name="cSchemaLocation">
            指定读取XML数据的应用程序应查找架构文件的可选位置。
            <note name="注意">仅在将架构部署到XML数据位置以外的位置时使用此参数。</note>
            cSchemaLocation的内容是生成的XML数据的xsi:schemaLocation或xsi:noNamespaceSchemaLocation属性。<br/>
            cschemaLocation参数可以是HTTP地址或其他URI。您需要将架构文件复制到cSchemaLocation中指定的位置。
            以下示例生成XML数据：
             <code language="X#">
                CURSORTOXML("LABELS", "myXMLFile.xml", 1, 512, 0, ;
                "mySchema.xsd", "http://www.microsoft.com/mySchema.xsd")
            </code>
            包含以下属性：
             <code language="X#">   xsi:noNamespaceSchemaLocation=" http://www.microsoft.com/mySchema.xsd"</code>
            当cSchemaName为空时指定cSchemaLocation会导致相同的属性被写入XML数据。
            这使得您可以指向现有架构，而无需在每次调用<b>CURSORTOXML( )</b>时重新创建架构。
        </param>
        <param name="cNamespace">
            指定要生成的XML或架构的命名空间，默认值为空字符串("")。<br/>
            为cNameSpace指定值会将targetNamespace属性设置为相同的值，并将elementFormDefault="qualified"
            属性添加到架构中。<br/>
            如果未指定cNamespace值，且架构是外部的，则不会将命名空间声明写入架构。
            如果未指定cNamespace值且架构是内联的，则架构中的targetNamespace将设置为空字符串("")。
        </param>
        <returns>
            数值数据类型。<b>CURSORTOXML( )</b>返回写入文件或内存变量的字节数。
        </returns>
        <remarks>
            您可以将<b>CURSORTOXML( )</b>与X#的OLE DB提供程序一起使用。但是，<b>_VFP</b> <b>VFPXMLProgID</b>属性不
            受支持，因为OLE DB提供程序不支持<b>_VFP</b>系统变量。<br/>
            要将X# OLE DB提供程序与<b>CURSORTOXML( )</b>一起使用，您必须在安装OLE DB提供程序的计算机上安装MSXML 3.0。
            <note name="注意">
                <b>CURSORTOXML( )</b>的输出遵循游标索引顺序、<b>Set Fields TO</b>和当前筛选器设置。
            </note>
            但是，它不保留游标位置。调用<b>CURSORTOXML( )</b>后，如果输出所有记录，
            游标记录指针将报告<b>EOF</b>。如果未输出所有记录，它将指向最后一条输出到XML的记录。<br/>
            如果表包含<b>Double</b>数据类型值，则<b>CURSORTOXML( )</b>生成的XML将包含与导出表相同的小数位数。
            例如，如果使用以下代码创建具有6位小数的<b>Double</b>列，则生成的XML将包含小数点右侧的六位数字：
             <code language="X#">Create Table test (col1 b(6))</code>
            当您使用<b>CURSORTOXML( )</b>函数将表或游标导出到XML时，根节点始终称为"VFPData"，
            无论输出格式如何。
            仅对于<b>Date</b>类型，您可以使用<b>CURSORTOXML( )</b>导出"空"<b>Date</b>和<b>DateTime</b>类型。
            但是，XML架构验证可能会失败，因为在XML架构定义（XSD）架构中，"空"对这些类型无效。
            这仅在需要架构且生成的XML针对可以解释XSD架构的XML解析器进行验证时才是问题。
            要解决此问题，您可能需要通过调用适当的<b>Select</b>语句来更改数据为非空表示，
            并对创建的游标使用<b>CURSORTOXML( )</b>。例如，您可以将空<b>Date</b>或<b>DateTime</b>值更改为.<b>NULL.</b>：
             <code language="X#">Select orderid, EVL(shippeddate,.NULL.) as ShippedDate From orders</code>
            您还可以将空<b>Date</b>或<b>DateTime</b>更改为"空"的适当表示：
             <code language="X#">
                Select orderid, IIF(EMPTY(shippeddate),{^1899-12-30 00:00:00},tc11);
            </code>
            使用标志32768时，标志16和32的设置可能会影响应用哪个代码页，具体取决于您要写入XML的数据类型。
            下表显示了设置的可能组合以及每种组合应用的代码页。
            对于使用32768标志写入的XML文档，应用以下代码页。
            <list type="table">
                <item>
                    <term>标志16</term>
                    <description>标志32</description>
                    <description>设置标志32768</description>
                </item>
                <item>
                    <term>未设置</term>
                    <description>未设置</description>
                    <description>
                        XML文档：Windows-1252。<br/>
                        Unicode数据：代码页1252。<br/>
                        字符数据：默认代码页，除非字段标记为<b>NOCPTRANS</b>。
                    </description>
                </item>
                <item>
                    <term>True (.T)</term>
                    <description>未设置</description>
                    <description>
                        XML文档：加上游标的<b>CodePage</b>属性。<br/>
                        如果XMLField <b>CodePage</b>属性大于零(0)且与游标的代码页不匹配，则报告错误。<br/>
                        Unicode数据：游标对象的<b>Code page</b>属性。<br/>
                        字符数据：无。改用来自X#表(.dbf)的原始数据。
                    </description>
                </item>
                <item>
                    <term>未设置</term>
                    <description>设置</description>
                    <description>
                        XML文档：UTF-8代码页。<br/>
                        Unicode数据：UTF-8代码页。<br/>
                        字符数据：默认代码页，除非字段标记为<b>NOCPTRANS</b>，
                        在这种情况下不会进行额外的字符转换为UTF-8。
                    </description>
                </item>
                <item>
                    <term>设置</term>
                    <description>设置</description>
                    <description>
                        XML文档：UTF-8代码页。<br/>
                        Unicode数据：UTF-8代码页。<br/>
                        字符数据：默认代码页，除非字段标记为<b>NOCPTRANS</b>，在这种情况下，数据使用
                        <b>SYS(3005)</b>设置转换为UTF-8。
                    </description>
                </item>
            </list>
            对于未设置32768标志写入的XML文档，应用以下代码页。

            <list type="table">
                <item>
                    <term>标志16</term>
                    <description>标志32</description>
                    <description>不带32768标志</description>
                </item>
                <item>
                    <term>未设置</term>
                    <description>未设置</description>
                    <description>
                        XML文档：Windows-1252。<br/>
                        Unicode数据：代码页1252。<br/>
                        字符数据：默认代码页，除非字段标记为<b>NOCPTRANS</b>。
                    </description>
                </item>
                <item>
                    <term>True (.T)</term>
                    <description>未设置</description>
                    <description>
                        XML文档：游标的<b>CodePage</b>属性。<br/>
                        字符数据：无。改用来自X#表(.dbf)的原始数据。<br/>
                        Unicode数据：游标对象的代码页属性。
                    </description>
                </item>
                <item>
                    <term>未设置</term>
                    <description>设置</description>
                    <description>
                        XML文档：UTF-8代码页。<br/>
                        Unicode数据：UTF-8代码页。<br/>
                        字符数据：默认代码页，除非字段标记为<b>NOCPTRANS</b>，
                        在这种情况下不会进行额外的字符转换为UTF-8。
                    </description>
                </item>
                <item>
                    <term>设置</term>
                    <description>设置</description>
                    <description>
                        XML文档：UTF-8代码页。<br/>
                        Unicode数据：UTF-8代码页。<br/>
                        字符数据：默认代码页，除非字段标记为<b>NOCPTRANS</b>，在这种情况下，
                        它们使用当前<b>SYS(3005)</b>设置的代码页转换为UTF-8。
                    </description>
                </item>
            </list>
            <list type="table">
                <listheader>
                    <term>nOutputFormat</term>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>1 – ELEMENTS</term>
                    <description>（默认）以元素为中心的XML</description>
                </item>
                <item>
                    <term>2 – ATTRIBUTES</term>
                    <description>以属性为中心的XML</description>
                </item>
                <item>
                    <term>3 – RAW</term>
                    <description>通用的、以属性为中心的XML</description>
                </item>
            </list>

            <list type="table">
                <listheader>
                    <term>nFlags</term>
                    <description>位</description>
                    <description>输出描述</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>0000</description>
                    <description>
                        （默认）以UTF-8格式生成XML。<br/>
                        当cOutput指定时，如果内存变量不存在，此设置会创建一个内存变量并将XML返回到该内存变量。<br/>
                        XML声明不包含Encoding=属性；也就是说，没有设置编码属性为UTF-8。
                    </description>
                </item>
                <item>
                    <term>1</term>
                    <description>0001</description>
                    <description>生成未格式化的XML作为连续字符串。</description>
                </item>
                <item>
                    <term>2</term>
                    <description>0010</description>
                    <description>用开放和闭合元素包围空元素，例如，&lt;cc04&gt;&lt;/cc04&gt;。</description>
                </item>
                <item>
                    <term>4</term>
                    <description>0100</description>
                    <description>保留字段中的空白。</description>
                </item>
                <item>
                    <term>8</term>
                    <description>1000</description>
                    <description>将Memo字段包装在CDATA部分中。</description>
                </item>
                <item>
                    <term>16</term>
                    <description>10000</description>
                    <description>
                        输出编码。输出设置为游标代码页。<br/>
                        为确保准确的字符转换，X#默认代码页必须与游标的代码页匹配。<br/>
                        您可以通过将游标中的字符和备注字段设置为<b>NOCPTRAN</b>（字符二进制/备注二进制）来实现这一点。<br/>
                        使用任何代码页的表设置此值时，XML中的编码属性设置为空字符串（""）。要更改为正确的编码属性，请使用STRTRAN()函数。<br/>
                        例如，对于代码页936，为结果XML字符串提供以下内容：
                         <code language="X#">strxml=STRTRAN(strxml, 'encoding=""', 'encoding="gb2312"'</code>
                    </description>
                </item>
                <item>
                    <term>32</term>
                    <description>100000</description>
                    <description>输出编码。</description>
                </item>
                <item>
                    <term>512</term>
                    <description>1000000000</description>
                    <description>
                        输出到cOutput指定的文件。
                        如果文件不存在，则创建它。如果文件已存在，则覆盖它。遵守<b>Set SAFETY</b>的设置。
                    </description>
                </item>
                <item>
                    <term>4096</term>
                    <description>1000000000000</description>
                    <description>
                        禁用base64编码。<br/>
                        <b>CURSORTOXML()</b>将Memo（二进制）字段导出为xsd:base64binary，除非您使用nFlags设置为4096。<br/>
                        在X#中，base64编码仅用于编码二进制数据。
                    </description>
                </item>
                <item>
                    <term>32768</term>
                    <description>无</description>
                    <description>指示应使用代码页。</description>
                </item>
            </list>
            下表描述了当输出编码默认为游标或表代码页时，如何写入编码属性。
            <note name="注意">通过组合第4位和第5位（0010000）设置编码标志。</note>
            <list type="table">
                <listheader>
                    <term>编码标志</term>
                    <description>第4位和第5位</description>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>+0</term>
                    <description>00</description>
                    <description>（默认）Windows-1252</description>
                </item>
                <item>
                    <term>+16</term>
                    <description>01</description>
                    <description>将输出编码属性设置为游标代码页。</description>
                </item>
                <item>
                    <term>+32</term>
                    <description>10</description>
                    <description>将输出编码属性设置为UTF-8，不进行字符转换。</description>
                </item>
                <item>
                    <term>+48</term>
                    <description>11</description>
                    <description>将输出编码属性设置为UTF-8，并将字符数据转换为UTF-8。</description>
                </item>
            </list>
            下表列出了常见的Windows兼容代码页。
            <list type="table">
                <listheader>
                    <term>代码页</term>
                    <description>平台</description>
                    <description>XML声明中的编码属性</description>
                    <description>注释</description>
                </listheader>
                <item>
                    <term>437</term>
                    <description>MS-DOS，美国</description>
                    <description>ibm437</description>
                    <description></description>
                </item>
                <item>
                    <term>850</term>
                    <description>MS-DOS，国际</description>
                    <description>ibm850</description>
                </item>
                <item>
                    <term>865</term>
                    <description>MS-DOS，北欧</description>
                    <description>空字符串 ("")</description>
                </item>
                <item>
                    <term>866</term>
                    <description>MS-DOS，俄罗斯</description>
                    <description>cp866</description>
                </item>
                <item>
                    <term>932</term>
                    <description>Windows，日语</description>
                    <description>shift-jis</description>
                </item>
                <item>
                    <term>936</term>
                    <description>简体中文</description>
                    <description>gb2312</description>
                </item>
                <item>
                    <term>949</term>
                    <description>Windows，韩语</description>
                    <description>iso-2022-kr</description>
                    <description>
                        或：<br/> ks_c_5601-1987
                    </description>
                </item>
                <item>
                    <term>950</term>
                    <description>Windows，繁体中文（台湾）</description>
                    <description>big5</description>
                </item>
                <item>
                    <term>1250</term>
                    <description>Windows，东欧</description>
                    <description>Windows-1250</description>
                    <description>注意大小写。</description>
                </item>
                <item>
                    <term>1251</term>
                    <description>Windows，俄罗斯</description>
                    <description>Windows-1251</description>
                </item>
                <item>
                    <term>1252</term>
                    <description>Windows，美国，西欧</description>
                    <description>Windows-1252</description>
                </item>
                <item>
                    <term>1253</term>
                    <description>Windows，希腊</description>
                    <description>Windows-1253</description>
                </item>
                <item>
                    <term>1254</term>
                    <description>Windows，土耳其</description>
                    <description>Windows-1254</description>
                </item>
                <item>
                    <term>1255</term>
                    <description>Windows，希伯来</description>
                    <description>Windows-1255</description>
                </item>
                <item>
                    <term>1256</term>
                    <description>Windows，阿拉伯</description>
                    <description>Windows-1256</description>
                </item>
            </list>
            <note name="注意">
                X#使用Windows-1252作为默认编码。使用双字节字符集（DBCS）时，您可以指定将编码属性设置为匹配代码页，
                例如Big5（代码页950），用于X#支持代码页的DBCS语言。
            </note>
            使用Windows-1252和DBCS时，不需要额外的字符转换就可以在Internet Explorer中正确显示。<br/>
            然而，为了使XML更符合可以解释UTF-8的Web浏览器，您可以选择将编码属性设置为
            UTF-8而不是Windows-1252。只有当您将nFlags设置为48时（将编码属性指定为UTF-8并将字符数据转换为UTF-8格式），
            结果集才会进行转换为UTF-8字符。这仅在数据实际包含双字节字符时才需要。如果您只输出拉丁（单字节）字符，
            则不必使用字符转换，例如<b>STRCONV()</b>。
            <list type="table">
                <listheader>
                    <term>cSchemaName</term>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>cSchemaName</term>
                    <description>
                        指定架构的外部文件的名称和路径（限定于XML的根元素）。
                        <note name="注意">
                            如果cSchemaName包含文件名，而cSchemaLocation未提供或为空白，则cSchemaName的内容将成为XML中的xsi:schemaLocation或
                            xsi:noNamespaceSchemaLocation属性。
                        </note>
                        在以下示例中，X#从"Labels"别名中的Labels.dbf文件生成一个名为MyXMLFile.xml的通用XML文件，并在同一文件夹中生成名为
                        MySchema的架构文件。
                         <code language="X#">CURSORTOXML("LABELS", "myXMLFile.xml", 1, 512, 0, "mySchema.xsd")</code>
                        如果cSchemaName包含URI，架构将被写入当前目录，并且必须上传到服务器才能被浏览器或解析器访问。
                        外部架构始终被写入与XML文件相同的位置。
                    </description>
                </item>
                <item>
                    <term>"1"</term>
                    <description>
                        指定生成内联架构。例如，以下代码生成内联架构：
                         <code language="X#">CURSORTOXML("LABELS", "myXMLFile.xml", 1, 512, 0, "1")</code>
                    </description>
                </item>
                <item>
                    <term>""</term>
                    <description>指定不生成架构。</description>
                </item>
            </list>
        </remarks>
    </cursortoxml>

    <curval>
        <summary>
            从磁盘或远程数据源直接返回表的字段值。
        </summary>
        <param name="cExpression">
            指定CurVal()从表或远程数据源返回其值的表达式。
            cExpression通常是字段或由表或远程数据源中的一组字段组成的表达式。
        </param>
        <param name="uArea">
            指定从其磁盘返回字段值的表的别名或工作区号，适用于表或远程数据源。
        </param>
        <returns>
            字符型、货币型、日期型、日期时间型、双精度型、浮点型、逻辑型、数值型或备注型
        </returns>
        <remarks>
            可以比较CurVal()和OldVal()返回的字段值，以确定在编辑字段时网络上的其他用户是否更改了字段值。
            只有在启用乐观行或表缓冲时，CurVal()和OldVal()才能返回不同的值。
            使用CursorSetProp()启用乐观行或表缓冲。<br/>
            如果在多用户环境中使用视图，除非先调用Refresh()函数，否则CurVal()返回的值可能不是最新的。
            视图返回的数据被缓冲，CurVal()函数从缓冲区读取值。
            但是，如果其他用户更改了视图的底层表中的数据，则在调用Refresh()函数之前不会更新缓冲的数据。<br/>
            CurVal()返回当前记录的字段值，返回值的数据类型由cExpression指定的表达式确定。<br/>
            如果在没有可选uArea参数的情况下发出CurVal()，则返回当前选定工作区中打开的表或游标的值。
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Clear
                Create Table mytable FREE (cDigit C(10))
                * 存储原始值
                Insert Into mytable (cDigit) VALUES ("One")
                Set MultiLocks ON        &amp;&amp; 允许乐观表缓冲
                = CursorSetProp("Buffering",5)   &amp;&amp; 启用乐观表缓冲
                Replace cDigit WITH "Two"    &amp;&amp; 新值
                ? "当前值: " + CurVal("cDigit", "mytable")
                ? "旧值: " + OldVal("cDigit", "mytable")
                = TableUpdate(.T.)       &amp;&amp; 提交对表的更改
                ? "表更改已提交"
                ? "新的当前值: " + CurVal("cDigit", "mytable")
                ? "新的旧值: " + OldVal("cDigit", "mytable")
            </code>
        </example>
    </curval>

    <dbalias>
        <summary>
            返回当前设置的数据库的别名。
        </summary>
        <returns>
            字符型。
        </returns>
        <remarks>
            如果没有当前数据库，<b>DBAlias( )</b>返回空字符串。
        </remarks>
        <example>
            <code language="X#">
                Open Database HOME(2)+"northwind\northwind" SHARED
                Open Database HOME(2)+"tastrade\data\tastrade" SHARED
                Set Database TO NORTHWIND
                ? DBAlias()
                Set Database TO TASTRADE
                ? DBAlias()
                ? JUSTSTEM(DBC())
            </code>
        </example>
    </dbalias>

    <dbc>
        <summary>
            返回当前数据库的名称和路径。
        </summary>
        <returns>
            字符型
        </returns>
        <remarks>
            如果没有当前数据库，<b>DBC( )</b>返回空字符串。
            使用Set Database来指定当前数据库。
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Open Database (HOME(2) + 'data\testdata')  &amp;&amp; 打开数据库容器（DBC）。
                Clear
                ? DBC( )  &amp;&amp; 显示数据库的路径和名称
            </code>
        </example>
    </dbc>

    <dbgetprop>
        <summary>
            检索当前数据库或当前数据库中的字段、命名连接、表或视图的属性值。<br/>
            <note name="注意">
                在检索数据库及其连接、表、视图或字段的属性之前，必须先打开数据库。
                但是，在检索表或视图的属性之前，不需要打开表或视图。
            </note>
        </summary>
        <param name="cName">
            指定当前打开数据库或当前打开数据库中的字段、命名连接、表或视图的名称，
            <b>DbGetProp( )</b>将返回这些对象的信息。<br/>
            要返回表或视图中字段的信息，请在字段名称前加上包含该字段的表或视图的名称。
            例如，要返回<c>customer</c>表中<c>custid</c>字段的信息，请为cName指定以下内容：
             <code language="X#">customer.custid</code>
        </param>
        <param name="cType">
            指定cName是当前数据库，还是当前数据库中的字段、命名连接、表或视图。
            备注部分的表格列出了cType的可用值。
        </param>
        <param name="cProperty">
            指定<b>DbGetProp( )</b>返回信息的属性名称。<br/>
            备注部分的表格列出了可以为cProperty指定的值、返回值类型和每个属性的描述。
            每个描述包括属性的读写权限。如果属性是只读的，则无法使用<b>DbSetProp( )</b>更改其值。
        </param>
        <returns>
            字符、数值或逻辑数据类型。<b>DbGetProp( )</b>返回指定属性的值。
        </returns>
        <remarks>
            有关设置属性值的更多信息，请参见DbSetProp( )函数。
            <list type="table">
                <listheader>
                    <term>cType</term>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>Connection</term>
                    <description>cName是当前数据库中的命名连接。</description>
                </item>
                <item>
                    <term>Database</term>
                    <description>Name是当前数据库。</description>
                </item>
                <item>
                    <term>Field</term>
                    <description>cName是当前数据库中的字段。</description>
                </item>
                <item>
                    <term>Table</term>
                    <description>cName是当前数据库中的表。</description>
                </item>
                <item>
                    <term>View</term>
                    <description>
                        cName是当前数据库中的视图。
                    </description>
                </item>
            </list>


            <b>连接属性</b>
            <list type="table">
                <listheader>
                    <term>cProperty</term>
                    <description>类型</description>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>Asynchronous</term>
                    <description>L</description>
                    <description>
                        连接模式。（默认）False (.F.) 指定同步连接。True (.T.) 指定异步连接。<br/>
                    </description>
                </item>
                <item>
                    <term>BatchMode</term>
                    <description>L</description>
                    <description>
                        批处理模式。（默认）True (.T.) 指定连接以批处理模式运行。
                    </description>
                </item>
                <item>
                    <term>Comment</term>
                    <description>C</description>
                    <description>连接注释的文本。</description>
                </item>
                <item>
                    <term>ConnectString</term>
                    <description>C</description>
                    <description>登录连接字符串。</description>
                </item>
                <item>
                    <term>ConnectTimeout</term>
                    <description>N</description>
                    <description>连接超时间隔（以秒为单位）。默认值为0（无限等待）。</description>
                </item>
                <item>
                    <term>Database</term>
                    <description>C</description>
                    <description>在Create Connection命令或Connection Designer中使用Database子句指定的服务器数据库名称。</description>
                </item>
                <item>
                    <term>DataSource</term>
                    <description>C</description>
                    <description>Odbc.ini文件中定义的数据源名称。</description>
                </item>
                <item>
                    <term>DisconnectRollback</term>
                    <description>L</description>
                    <description>
                        指定在为最后一个连接句柄调用SqlDisconnect( )时是提交还是回滚挂起的事务。<br/>
                        默认值为false (.F.)，表示在为最后一个连接句柄调用SqlDisconnect( )时提交挂起的事务。<br/>
                        指定true (.T.)以在为最后一个连接句柄调用SqlDisconnect( )时回滚挂起的事务。<br/>
                        具有自动事务处理的连接不受此设置的影响。
                    </description>
                </item>
                <item>
                    <term>DispLogin</term>
                    <description>N</description>
                    <description>
                        包含一个数值，用于确定何时显示ODBC登录对话框。DispLogin可以采用以下值：<br/>
                        1或DB_PROMPTCOMPLETE（来自Foxpro.h）。1是默认值。<br/>
                        2或DB_PROMPTALWAYS（来自Foxpro.h）。<br/>
                        3或DB_PROMPTNEVER（来自Foxpro.h）。<br/>
                        如果指定1或DB_PROMPTCOMPLETE，X#仅在缺少任何必需信息时才显示ODBC登录对话框。<br/>
                        如果指定2或DB_PROMPTALWAYS，则始终显示ODBC登录对话框，允许您在连接之前更改设置。<br/>
                        如果指定3或DB_PROMPTNEVER，则不显示ODBC登录对话框，
                        如果所需的登录信息不可用，X#将生成错误。
                    </description>
                </item>
                <item>
                    <term>DispWarnings</term>
                    <description>L</description>
                    <description>
                        包含一个逻辑值，用于确定是否显示来自远程表、ODBC或X#的不可捕获的警告。
                        （默认）True (.T.) 指定显示不可捕获的错误。
                    </description>
                </item>
                <item>
                    <term>IdleTimeout </term>
                    <description>N</description>
                    <description>
                        空闲超时间隔（以分钟为单位）。超时每分钟最多检查一次，
                        因此活动连接可能会在指定时间间隔过后一到两分钟后才停用。
                        默认值为0（无限等待）。
                    </description>
                </item>
                <item>
                    <term>PacketSize</term>
                    <description>N</description>
                    <description>
                        连接使用的网络数据包大小。
                        调整此值可以提高性能。默认值为4096字节（4K）。
                    </description>
                </item>
                <item>
                    <term>PassWord</term>
                    <description>C</description>
                    <description>连接密码。</description>
                </item>
                <item>
                    <term>QueryTimeout</term>
                    <description>N</description>
                    <description>查询超时间隔（以秒为单位）。默认值为0（无限等待）。</description>
                </item>
                <item>
                    <term>Transactions</term>
                    <description>N</description>
                    <description>
                        包含一个数值，用于确定连接如何管理远程表上的事务。Transactions可以采用以下值：<br/>
                        1或DB_TRANSAUTO（来自Foxpro.h）。1是默认值。远程表的事务处理自动处理。<br/>
                        2或DB_TRANSMANUAL（来自Foxpro.h）。事务处理通过SqlCommit( )和SqlRollBack( )手动处理。
                    </description>
                </item>
                <item>
                    <term>UserId</term>
                    <description>C</description>
                    <description>用户标识。</description>
                </item>
                <item>
                    <term>WaitTime</term>
                    <description>N</description>
                    <description>
                        X#在检查SQL语句是否已完成执行之前经过的时间（以毫秒为单位）。
                        默认值为100毫秒。
                    </description>
                </item>
            </list>
            <note name="注意">所有这些都是可读/写的</note><br/><br/>

            <b>数据库属性</b>
            <list type="table">
                <listheader>
                    <term>cProperty</term>
                    <description>类型</description>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>Comment</term>
                    <description>C</description>
                    <description>
                        数据库注释的文本。<br/>
                        读/写。
                    </description>
                </item>
                <item>
                    <term>DBCEventFileName</term>
                    <description>C</description>
                    <description>包含DBC事件代码的外部程序文件的相对路径和文件名。</description>
                </item>
                <item>
                    <term>DBCEvents</term>
                    <description>L</description>
                    <description>DBC事件的启用状态。设置为True (.T.)以启用。</description>
                </item>
                <item>
                    <term>Version</term>
                    <description>N</description>
                    <description>
                        数据库版本号。<br/>
                        只读。
                    </description>
                </item>
            </list>
            <br/><br/>
            <b>表的字段属性</b>
            <list type="table">
                <listheader>
                    <term>cProperty</term>
                    <description>类型</description>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>Caption</term>
                    <description>C</description>
                    <description>
                        字段标题。如果此属性的值前面有等号(=)，X#会将该值评估为表达式。
                        否则，它被视为字符串字面量。
                    </description>
                </item>
                <item>
                    <term>Comment</term>
                    <description>C</description>
                    <description>
                        字段注释的文本。
                    </description>
                </item>
                <item>
                    <term>DefaultValue</term>
                    <description>C</description>
                    <description>字段的默认值。</description>
                </item>
                <item>
                    <term>DisplayClass</term>
                    <description>C</description>
                    <description>用于字段映射的类的名称。</description>
                </item>
                <item>
                    <term>DisplayClassLibrary</term>
                    <description>C</description>
                    <description>
                        <b>DisplayClass</b>属性指定的类库的路径。
                    </description>
                </item>
                <item>
                    <term>Format</term>
                    <description>C</description>
                    <description>字段显示格式。有关格式设置的列表，请参见Format属性。</description>
                </item>
                <item>
                    <term>InputMask</term>
                    <description>C</description>
                    <description>字段输入格式。有关输入掩码设置的列表，请参见InputMask属性。</description>
                </item>
                <item>
                    <term>RuleExpression</term>
                    <description>C</description>
                    <description>字段规则表达式。</description>
                </item>
                <item>
                    <term>RuleText</term>
                    <description>C</description>
                    <description>字段规则错误文本。</description>
                </item>
            </list>
            <note name="注意">以上所有属性均为读/写</note><br/><br/>

            <b>视图的字段属性</b>
            <list type="table">
                <listheader>
                    <term>cProperty</term>
                    <description>类型</description>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>Caption</term>
                    <description>C</description>
                    <description>
                        字段标题。如果此属性的值前面有等号(=)，
                        Visual FoxPro会将该值评估为表达式。否则，它被视为字符串字面量。
                    </description>
                </item>
                <item>
                    <term>Comment</term>
                    <description>C</description>
                    <description>字段注释的文本。</description>
                </item>
                <item>
                    <term>DataType</term>
                    <description>C</description>
                    <description>
                        视图中字段的数据类型。最初设置为数据源中该字段的数据类型。<br/>
                        要使用<b>DbSetProp( )</b>为字段指定不同的数据类型，请使用Create Table – SQL中创建字段的语法。<br/>
                        例如，要将名为Mytable的表中名为iCost的整数字段的数据类型更改为宽度为4且小数位为2的数值类型，
                        使用DbSetProp('mytable.icost', 'field', ; 'DataType', 'N(4,2)')<br/>
                        您还可以包含NOCPTRANS子句以防止将字符和备注字段转换为不同的代码页。<br/>
                        对于远程视图为读/写。
                    </description>
                </item>
                <item>
                    <term>DisplayClass</term>
                    <description>C</description>
                    <description>用于字段映射的类的名称。</description>
                </item>
                <item>
                    <term>DisplayClassLibrary</term>
                    <description>C</description>
                    <description>
                        <b>DisplayClass</b>属性指定的类库的路径。
                    </description>
                </item>
                <item>
                    <term>DefaultValue</term>
                    <description>C</description>
                    <description>字段的默认值</description>
                </item>
                <item>
                    <term>KeyField</term>
                    <description>L</description>
                    <description>如果字段在索引键表达式中指定，则包含True (.T.)；否则，包含False (.F.)。</description>
                </item>
                <item>
                    <term>RuleExpression</term>
                    <description>C</description>
                    <description>字段规则表达式。</description>
                </item>
                <item>
                    <term>RuleText</term>
                    <description>C</description>
                    <description>字段规则错误文本。</description>
                </item>
                <item>
                    <term>Updatable</term>
                    <description>L</description>
                    <description>如果字段可以更新，则包含True (.T.)；否则，包含False (.F.)。</description>
                </item>
                <item>
                    <term>UpdateName</term>
                    <description>C</description>
                    <description>当字段中的数据更新到远程表时使用的字段名称。默认为远程表字段名。</description>
                </item>
            </list>
            <note name="注意">以上所有属性均为读/写</note><br/><br/>

            <b>表属性</b>
            <list type="table">
                <listheader>
                    <term>cProperty</term>
                    <description>类型</description>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>Comment</term>
                    <description>C</description>
                    <description>
                        表注释的文本。<br/>
                        读/写。
                    </description>
                </item>
                <item>
                    <term>DeleteTrigger</term>
                    <description>C</description>
                    <description>
                        删除触发器表达式。<br/>
                        只读。
                    </description>
                </item>
                <item>
                    <term>InsertTrigger</term>
                    <description>C</description>
                    <description>
                        插入触发器表达式。<br/>
                        只读。
                    </description>
                </item>
                <item>
                    <term>Path</term>
                    <description>C</description>
                    <description>
                        相对于DBC的表的相对路径，包括文件名。<br/>
                        只读。
                    </description>
                </item>
                <item>
                    <term>PrimaryKey</term>
                    <description>C</description>
                    <description>
                        主键的标签名。<br/>
                        只读。
                    </description>
                </item>
                <item>
                    <term>RuleExpression</term>
                    <description>C</description>
                    <description>
                        行规则表达式。<br/>
                        只读。
                    </description>
                </item>
                <item>
                    <term>RuleText</term>
                    <description>C</description>
                    <description>
                        行规则错误文本。<br/>
                        只读。
                    </description>
                </item>
                <item>
                    <term>UpdateTrigger</term>
                    <description>C</description>
                    <description>
                        更新触发器表达式。<br/>
                        只读。
                    </description>
                </item>
            </list><br/><br/>

            <b>视图属性</b>
            <list type="table">
                <listheader>
                    <term>cProperty</term>
                    <description>类型</description>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>AllowSimultaneousFetch</term>
                    <description>L</description>
                    <description>
                        适用于使用远程视图、共享连接和使用ODBC创建的游标。<br/>
                        当允许共享连接的类似配置的游标同时获取行时，AllowSimultaneousFetch包含True (.T.)。<br/>
                        否则，当不允许同时获取行时，AllowSimultaneousFetch包含False (.F.)。
                        <note name="注意">
                            此属性在X# 8.0及更高版本中可用。在X# 8.0及更高版本中创建的视图与早期版本不兼容。
                            在X# 8.0之前的版本中对包含在X# 8.0及更高版本中创建或修改的远程视图的数据库容器调用<b>VALIDATE Database</b>命令会生成错误。
                            在X# 8.0之前的版本中调用<c>VALIDATE Database RECOVER</c>会从任何此类视图中删除<b>AllowSimultaneousFetch</b>属性。
                        </note>
                    </description>
                </item>
                <item>
                    <term>BatchUpdateCount</term>
                    <description>N</description>
                    <description>
                        发送到后端的视图更新语句的数量。默认为1。
                        调整此值可以大大提高更新性能。<br/>
                        读/写。
                    </description>
                </item>
                <item>
                    <term>Comment</term>
                    <description>C</description>
                    <description>
                        视图注释的文本。<br/>
                        读/写。
                    </description>
                </item>
                <item>
                    <term>CompareMemo</term>
                    <description>L</description>
                    <description>
                        如果在更新的Where子句中包含备注字段（类型为Memo、General或Picture，或对于远程视图，类型为Timestamp），
                        则包含true (.T.)（默认）；否则，包含false (.F.)。<br/>
                        读/写。
                    </description>
                </item>
                <item>
                    <term>ConnectName</term>
                    <description>C</description>
                    <description>
                        打开视图时使用的命名连接。<br/>
                        只读。
                    </description>
                </item>
                <item>
                    <term>FetchAsNeeded</term>
                    <description>L</description>
                    <description>
                        如果为True (.T.)，则仅在需要时获取数据，例如当记录指针移动到尚未获取的行时。<br/>
                        如果为False (.F.)，则在空闲时获取额外数据。（默认）<br/>
                        <note name="注意">当禁用渐进式获取时（FetchSize为-1），FetchAsNeeded不适用。</note><br/>
                        读/写。
                    </description>
                </item>
                <item>
                    <term>FetchMemo</term>
                    <description>L</description>
                    <description>
                        如果与视图结果一起获取备注和通用字段，则包含true (.T.)（默认）；否则，包含false (.F.)。<br/>
                        使用ISMEMOFETCHED( )函数来确定是否已获取备注字段。<br/>
                        读/写。
                    </description>
                </item>
                <item>
                    <term>FetchSize</term>
                    <description>N</description>
                    <description>
                        包含一次从远程表获取的记录数。默认为100条记录。
                        将FetchSize设置为–1会检索完整的结果集，受MaxRecords设置的限制。<br/>
                        <note name="注意">
                            渐进式获取会保持连接直到检索所有行。
                            如果ShareConnection为True (.T.)，请谨慎使用FetchSize进行编码。
                        </note><br/>
                        读/写。
                    </description>
                </item>
                <item>
                    <term>MaxRecords</term>
                    <description>N</description>
                    <description>
                        返回结果集时获取的最大记录数。默认为– 1（返回所有行）。<br/>
                        值为0指定执行视图但不获取任何结果。<br/>
                        读/写。
                    </description>
                </item>
                <item>
                    <term>Offline</term>
                    <description>L</description>
                    <description>
                        如果视图是离线视图，则包含true (.T.)。<br/>
                        只读。
                    </description>
                </item>
                <item>
                    <term>ParameterList</term>
                    <description>C</description>
                    <description>
                        Where子句参数。参数的格式为"ParameterName1, 'Type1'; ParameterName2, 'Type2'; ..."，其中Type
                        是指定参数类型的以下字符之一：<br/>
                        C – 字符型  D – 日期型  T – 日期时间型  N – 数值型  F – 浮点型  B – 双精度型  I – 整数型  Y – 货币型  L - 逻辑型<br/>
                        例如，"MyParam1, 'C'"指定了一个名为MyParam1的字符型参数。<br/>
                        有关创建参数化视图的更多信息，请参见如何：创建参数化视图。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>Prepared</term>
                    <description>L</description>
                    <description>
                        如果为后续<b>Requery( )</b>函数调用准备了SQL语句，则包含True (.T.)。
                        <b>Requery( )</b>用于再次检索SQL视图的数据。有关准备SQL语句的更多信息，请参见SqlPrepare( )。
                        默认值为False (.F.)。<br/>
                        在Browse或Edit窗口中编辑数据时发生错误时显示的规则文本表达式。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>RuleExpression</term>
                    <description>C</description>
                    <description>
                        行规则表达式。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>RuleText</term>
                    <description>C</description>
                    <description>
                        在Browse或Edit窗口中编辑数据时发生错误时显示的规则文本表达式。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>SendUpdates</term>
                    <description>L</description>
                    <description>
                        如果发送SQL更新查询以更新远程表，则包含True (.T.)；否则，包含False (.F.)（默认）。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>ShareConnection</term>
                    <description>L</description>
                    <description>
                        如果发送SQL更新查询以更新远程表，则包含True (.T.)；否则，包含False (.F.)（默认）。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>ShareType</term>
                    <description>L</description>
                    <description>
                        如果视图可以与其他连接共享其连接句柄，则包含True (.T.)；否则，包含False (.F.)。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>SourceType</term>
                    <description>N</description>
                    <description>
                        视图源。SourceType可能具有以下值：<br/>
                        1 - 视图使用本地表。<br/>
                        2 - 视图使用远程表。<br/>
                        只读。
                    </description>
                </item>
                <item>
                    <term>SQL</term>
                    <description>C</description>
                    <description>
                        打开视图时执行的SQL语句。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>Tables</term>
                    <description>C</description>
                    <description>
                        表名的逗号分隔列表。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>UpdateType</term>
                    <description>N</description>
                    <description>
                        更新类型。有效值为：<br/>
                        1 或 DB_Update（来自Foxpro.h）。用新数据更新旧数据（默认）。<br/>
                        2 或 DB_DeleteInsert（来自Foxpro.h）。删除旧数据并插入新数据。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>UseMemoSize</term>
                    <description>N</description>
                    <description>
                        结果列以备注字段返回的最小大小（以字节为单位）。
                        例如，如果列结果的宽度大于UseMemoSize的值，则列结果将存储在备注字段中。
                        UseMemoSize可以从1到255变化；默认值为255。<br/>
                        可读/写。
                    </description>
                </item>
                <item>
                    <term>WhereType</term>
                    <description>N</description>
                    <description>
                        用于更新远程表的Where子句。WhereType可能具有以下值：<br/>
                        1 或 DB_KEY（来自Foxpro.h）。用于更新远程表的Where子句仅包含
                        使用<b>KeyFieldList</b>属性指定的主键字段。<br/>
                        2 或 DB_KEYANDUPDATable（来自Foxpro.h）。用于更新远程表的Where子句包含使用<b>KeyFieldList</b>属性
                        指定的主键字段和任何可更新字段。<br/>
                        3 或 DB_KEYANDMODIFIED（来自Foxpro.h）（默认）。用于更新远程表的Where子句包含使用<b>KeyFieldList</b>属性
                        指定的主键字段和任何其他已修改的字段。<br/>
                        4 或 DB_KEYANDTIMESTAMP（来自Foxpro.h）。用于更新远程表的Where子句包含使用<b>KeyFieldList</b>属性
                        指定的主键字段和时间戳的比较。<br/>
                        有关<b>WhereType</b>属性的更多信息，请参见使用视图管理更新。<br/>
                        可读/写。
                    </description>
                </item>
            </list>
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Clear
                Open Database (HOME(2) + 'Data\testdata')
                * 显示主键字段
                cResults = DbGetProp("customer", "Table", "PrimaryKey")
                =MessageBox(cResults)   &amp;&amp; 显示    'cust_id'
                * 显示'cust_id'字段的注释
                cResults = DbGetProp("customer.cust_id", "Field", "Comment")

                IF LEN(ALLTRIM(cResults)) = 0
                    =MessageBox("此字段没有注释。" + CHR(13) + ;
                    CHR (13) + "使用DbSetProp( )添加注释。")
                ELSE
                    =MessageBox("Cust_id字段注释：" + cRESULTS)
                ENDIF
            </code>
        </example>
    </dbgetprop>

    <dbsetprop>
        <summary>
            为当前数据库或当前数据库中的字段、命名连接、表或视图设置属性。
        </summary>
        <param name="cName">
            指定当前打开数据库或当前打开数据库中<b>DbGetProp( )</b>返回信息的字段、命名连接、表或视图的名称。<br/>
            要为表或视图中的字段设置属性，请在字段名称前加上包含该字段的表或视图的名称。
            例如，要为<c>customer</c>表中的<c>custid</c>字段设置属性，请为cName指定以下内容：
             <code language="X#">customer.custid</code>
        </param>
        <param name="cType">
            指定cName是当前数据库还是当前数据库中的字段、命名连接、表或视图。
            备注部分的表列出了可以为cType指定的值。
        </param>
        <param name="cProperty">
            指定要设置的属性的名称。如果属性是只读的，则无法使用<b>DbSetProp( )</b>更改其值。
            如果尝试设置只读属性，X#将生成错误消息。<br/>
            有关可以用cProperty指定的属性的更多信息，包括它们的数据类型，请参见DbGetProp( )。
        </param>
        <param name="ePropertyValue">
            指定将cProperty设置为的值。ePropertyValue必须与属性的数据类型相同。<br/>
            <note name="注意">
                X#不会验证您指定的值对属性是否有效。因此，可以使用<b>DbSetProp( )</b>将属性设置为无效值。
                例如，<b>DbSetProp( )</b>可以用来将字段规则表达式设置为对该字段无效的表达式，
                而X#不会生成错误。为避免在设置视图的Tables属性时出错，
                请在ePropertyValue前加上以下语法中的数据库指定：
                 <code language="X#">         &lt;databaseName&gt;!ePropertyValue</code>
            </note>
        </param>
        <returns>
            逻辑数据类型。如果X#成功设置您指定的属性，<b>DbSetProp( )</b>返回True (.T.)。如果您指定的属性无法设置，X#会生成错误。
        </returns>
        <remarks>
            <list type="table">
                <listheader>
                    <term>cType</term>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>Connection</term>
                    <description>cName是当前数据库中的命名连接。</description>
                </item>
                <item>
                    <term>Database</term>
                    <description>cName是当前数据库</description>
                </item>
                <item>
                    <term>Field</term>
                    <description>cName是当前数据库中的字段</description>
                </item>
                <item>
                    <term>Table</term>
                    <description>cName是当前数据库中的表</description>
                </item>
                <item>
                    <term>View</term>
                    <description>cName是当前数据库中的视图</description>
                </item>
            </list><br/>
            有关检索当前属性值的更多信息，请参见DbGetProp( )函数。
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Clear
                Open Database (HOME(2) + 'data\testdata')
                Use customer     &amp;&amp; 打开customer表
                = DbSetProp("customer.cust_id", "Field", "Comment", ;
                "属性已由DbSetProp设置。")  &amp;&amp; 新的字段注释
                cRESULTS = DbGetProp("customer.cust_id", "Field", "Comment")
                WAIT "Cust_id字段注释: "+ cRESULTS  &amp;&amp; 显示注释
            </code>
        </example>
    </dbsetprop>

    <dbused>
        <summary>
            如果指定的数据库已打开，则返回true (.T.)。
        </summary>
        <param name="cDatabaseName">
            指定<b>DbUsed( )</b>返回逻辑值的数据库名称，该值表示数据库是否打开。
        </param>
        <returns>
            逻辑值
        </returns>
        <remarks>
            如果指定的数据库已打开，<b>DbUsed( ) </b>返回true (.T.)；否则，返回false (.F.)。
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Open Database (HOME(2) + 'Data\testdata')
                Clear
                ? 'Testdata数据库已打开？ '
                ?? DbUsed('testdata')     &amp;&amp; 显示 .T.
                ? 'Test数据库已打开？ '
                ?? DbUsed('test')     &amp;&amp; 显示 .F.
            </code>
        </example>
    </dbused>

    <defaultext>
        <summary>
            如果文件名没有扩展名，则返回带有新扩展名的文件名。
        </summary>
        <param name="cFileName">
            指定要返回的文件名（带或不带路径或扩展名）。
        </param>
        <param name="cDefault">
            指定不带句点的默认扩展名。
        </param>
        <returns>
            字符型
        </returns>
    </defaultext>

    <difference>
        <summary>
            返回一个整数，0到4，表示两个字符表达式之间的相对语音差异。
        </summary>
        <param name="cExpression1">指定DIFFERENCE( )比较的字符表达式。</param>
        <param name="cExpression2">指定DIFFERENCE( )比较的字符表达式。</param>
        <returns>
            数值型
        </returns>
        <remarks>
            Difference( )在不知道条目的确切拼写时搜索表格很有用。<br/>
            两个表达式的拼写越相似，Difference( )返回的数字就越高。
            如果字符表达式的拼写非常相似，Difference( )返回4。对于语音上几乎没有共同点的两个字符表达式，
            Difference( )返回0。
        </remarks>
        <example>
             <code language="X#">
                STORE 'Smith' TO gcName1
                STORE 'Smythe'  TO gcName2
                STORE 'Smittie' TO gcName3
                STORE '' TO gcName4
                Clear
                ? Difference(gcName1, gcName2)  &amp;&amp; 显示 4
                ? Difference(gcName1, gcName3)  &amp;&amp; 显示 4
                ? Difference(gcName1, gcName4)  &amp;&amp; 显示 1
            </code>
        </example>
    </difference>

    <displaypath>
        <summary>
            截断长路径表达式以显示指定长度。
        </summary>
        <param name="cFilename">
            指定目标路径末尾的文件名。如果指定一个只包含空格的字符串作为cFileName，X#返回当前目录。
            如果指定一个空字符串作为cFileName，DisplayPath()返回一个空字符串。您可以使用CurDir()获取当前目录的路径。<br/>
            此函数不检查cFileName的有效性，即使该文件不存在，也会报告截断的路径表达式。
        </param>
        <param name="nMaxLength">
            指定截断结果的最大长度。nMaxLength必须大于或等于10且小于或等于260
            字符数据类型。DisplayPath()返回一个字符串并以小写形式显示路径。
        </param>
        <remarks>
            DisplayPath()返回一个仅适用于显示目的的字符串，因此您不能使用结果来引用文件。
            结果字符串的长度等于或小于nMaxLength。但是，结果不会打断目录名。
            如果包含目录名会超过nMaxLength，结果将是省略号(...)。
            如果文件名超过nMaxLength，结果将是文件名加扩展名。
        </remarks>
    </displaypath>

    <drivetype>
        <summary>
            返回指定驱动器的类型。
        </summary>
        <param name="cDrive">
            驱动器标识符。驱动器名称中的冒号（例如，"C:"）是可选的。
        </param>
        <returns>
            数值
        </returns>
        <remarks>
            下表解释了DriveType()返回的数字和相应的驱动器类型描述：
            <list type ="table">
                <listheader>
                    <term>数字</term>
                    <description>驱动器类型</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>无类型</description>
                </item>
                <item>
                    <term>2</term>
                    <description>软盘</description>
                </item>
                <item>
                    <term>3</term>
                    <description>硬盘</description>
                </item>
                <item>
                    <term>4</term>
                    <description>可移动驱动器或网络驱动器</description>
                </item>
                <item>
                    <term>5</term>
                    <description>CD-ROM</description>
                </item>
                <item>
                    <term>6</term>
                    <description>RAM磁盘1</description>
                </item>
            </list>
            <note name="注意">由于RAM磁盘有许多不同类型，您可能会得到不一致的返回结果。</note>
        </remarks>
    </drivetype>

    <dropoffline>
        <summary>
            丢弃对离线视图所做的所有更改，并将离线视图恢复为在线状态。
        </summary>
        <param name="cViewName">
            指定要恢复为在线状态的离线视图的名称。
        </param>
        <returns>
            逻辑值
        </returns>
        <remarks>
            如果离线视图成功恢复为在线状态，DropOffline()返回逻辑值真(.T.)；否则返回假(.F.)。
        </remarks>
    </dropoffline>

    <evl>
        <param name="eExpression1">
            指定一个表达式。eExpression1可以是任何数据类型。
        </param>
        <param name="eExpression2">
            指定一个表达式。eExpression1可以是任何数据类型。
        </param>
        <summary>
            从两个表达式中返回一个非空值。<br/>
            您可以使用<b>EVL()</b>函数从两个表达式中返回一个适当的替代值，而不是空值（如False (.F.)或0）。
            您还可以使用此功能从不支持或不相关的空值的计算或操作中删除空值。<br/>
            X#的<b>逻辑</b>值False (.F.)和<b>数值</b>0也被评估为空。
        </summary>
        <returns>
            字符、日期、日期时间、数值、货币、逻辑、对象。
            如果eExpression1的计算结果不为空值，<b>EVL()</b>返回eExpression1，
            否则返回eExpresssion2。
        </returns>
        <example>
            以下示例创建了内存变量<code>glEmptyDate</code>，
            其中包含一个空的<b>日期</b>值，和<code>glEmptyNum</code>，
            其中包含一个空的<b>数值</b>值0。<br/>
            当使用<code>glEmptyNum</code>执行<b>EVL()</b>时，<b>EVL()</b>在评估<code>glEmptyNum</code>和空字符串时返回一个空字符串("")，
            在评估<code>glEmptyNum</code>和<code>"None"</code>时返回code"None"/code。
             <code language="X#">
                STORE {  /  /  } TO glEmptyDate
                ? EVL(glEmptyDate,"")
                ? EVL(glEmptyDate, "None")
            </code>
            当使用glEmptyNum执行EVL()时，在评估glEmptyNum和空字符串时EVL()返回一个空字符串，
            在评估glEmptyNum和"Empty"时返回"Empty"。
             <code language="X#">
                STORE 0 TO glEmptyNum
                ? EVL(glEmptyNum,"")
                ? EVL(glEmptyNum, "Empty")
            </code>
        </example>
    </evl>

    <fldlist>
        <summary>
            包含用于与dBASE兼容。
        </summary>
    </fldlist>

    <fontmetric>
        <summary>
            返回当前安装的操作系统字体的字体属性。
        </summary>
        <param name="nAttribute">
            确定FontMetric()返回的字体属性。如果省略cFontName、nFontSize和cFontStyle，
            FontMetric()将返回活动输出窗口中当前字体的属性。<br/>
            备注部分的表格列出了nAttribute的值和相应返回的字体属性。
        </param>
        <param name="cFontName">
            指定已安装字体的名称。
        </param>
        <param name="nFontSize">
            指定用cFontName指定的字体的点大小。
        </param>
        <param name="cFontStyle">
            指定用cFontName指定的字体的字体样式代码。如果省略cFontStyle，FontMetric()将返回Normal字体样式的属性。<br/>
            cFontStyle可以是以下字体样式表中列出的单个字符或字符组合。
            例如，组合BI指定粗体斜体字体样式。
        </param>
        <returns>
            数值型
        </returns>
        <remarks>
            FontMetric()返回活动输出窗口当前字体的字体属性。可以使用WFONT()来确定当前窗口字体。
            <list type="table">
                <listheader>
                    <term>nAttribute</term>
                    <description>属性</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>字符高度（像素）</description>
                </item>
                <item>
                    <term>2</term>
                    <description>字符上升（基线以上单位）（像素）</description>
                </item>
                <item>
                    <term>3</term>
                    <description>字符下降（基线以下单位）（像素）</description>
                </item>
                <item>
                    <term>4</term>
                    <description>行距（行间距）（像素）</description>
                </item>
                <item>
                    <term>5</term>
                    <description>额外行距（像素）</description>
                </item>
                <item>
                    <term>6</term>
                    <description>平均字符宽度（像素）</description>
                </item>
                <item>
                    <term>7</term>
                    <description>最大字符宽度（像素）</description>
                </item>
                <item>
                    <term>8</term>
                    <description>字体粗细</description>
                </item>
                <item>
                    <term>9</term>
                    <description>斜体（0 = 否，非零 = 是）</description>
                </item>
                <item>
                    <term>10</term>
                    <description>下划线（0 = 否，非零 = 是）</description>
                </item>
                <item>
                    <term>11</term>
                    <description>删除线（0 = 否，非零 = 是）</description>
                </item>
                <item>
                    <term>12</term>
                    <description>字体中定义的第一个字符</description>
                </item>
                <item>
                    <term>13</term>
                    <description>字体中定义的最后一个字符</description>
                </item>
                <item>
                    <term>14</term>
                    <description>默认字符（替代字体中不存在的字符）</description>
                </item>
                <item>
                    <term>15</term>
                    <description>断字符</description>
                </item>
                <item>
                    <term>16</term>
                    <description>字距和字体系列</description>
                </item>
                <item>
                    <term>17</term>
                    <description>字符集</description>
                </item>
                <item>
                    <term>18</term>
                    <description>悬挂（额外添加的宽度）</description>
                </item>
                <item>
                    <term>19</term>
                    <description>字体设备的水平方面</description>
                </item>
                <item>
                    <term>20</term>
                    <description>字体设备的垂直方面</description>
                </item>
            </list>
            <list type="table">
                <listheader>
                    <term>字符</term>
                    <description>字体样式</description>
                </listheader>
                <item>
                    <term>B</term>
                    <description>粗体</description>
                </item>
                <item>
                    <term>I</term>
                    <description>斜体</description>
                </item>
                <item>
                    <term>N</term>
                    <description>正常</description>
                </item>
                <item>
                    <term>O</term>
                    <description>轮廓</description>
                </item>
                <item>
                    <term>Q</term>
                    <description>额外行距（像素）</description>
                </item>
                <item>
                    <term>S</term>
                    <description>阴影</description>
                </item>
                <item>
                    <term>-</term>
                    <description>删除线</description>
                </item>
                <item>
                    <term>T</term>
                    <description>透明</description>
                </item>
                <item>
                    <term>U</term>
                    <description>下划线</description>
                </item>
            </list>
            <br/><br/>
            有关FontMetric()返回的数值的更多信息，请参阅Microsoft Windows程序员参考中的TEXTMETRIC函数。
        </remarks>
    </fontmetric>

    <fullpath>
        <summary>
            返回指定文件的路径或相对于另一个文件的路径。
        </summary>
        <param name="cFileName1">
            指定X#搜索的文件。
            <note name="注意">请确保包含文件名扩展名。</note>
            如果文件位于X#路径中，则返回带有文件名的路径。您可以使用Set PATH命令指定X#路径。
            如果在X#路径中找不到文件，FullPath()将返回当前目录路径和文件名，就好像文件位于当前默认目录中一样。
        </param>
        <param name="uPath">
            指定搜索MS-DOS路径而不是X#路径。nMSDOSPath可以是任何数值。
            如果在MS-DOS路径中找不到文件，FullPath()将返回路径和文件名，就好像文件位于当前默认目录中一样。
        </param>
        <returns>
            字符型。FullPath()返回文件路径。
        </returns>
        <remarks>
            使用<b>FILE()</b>函数验证文件是否实际存在；否则，如果文件不存在，
            该函数将返回带有当前目录的文件名。
        </remarks>
    </fullpath>

    <fv>
        <summary>
            返回金融投资的未来价值。
        </summary>
        <param name="nPayment">
            指定恒定的定期付款（可以是负数或正数）。
        </param>
        <param name="nInterestRate">
            指定定期利率。如果利率是年利率但付款是每月进行的，请将年利率除以12。
        </param>
        <param name="nPeriods">
            指定付款的期数。FV()假设定期付款在每个期末进行。
        </param>
        <returns>
            数值型
        </returns>
        <remarks>
            FV()计算一系列恒定定期付款的未来价值，这些付款按固定复利计息。
            未来价值是所有付款和利息的总和。
        </remarks>
        <example>
             <code language="X#">
                STORE 500 TO gnPayment  &amp;&amp; 月付款
                STORE .075/12 TO gnInterest     &amp;&amp; 7.5%年利率
                STORE 48 TO gnPeriods  &amp;&amp; 四年（48个月）
                Clear
                ? FV(gnPayment, gnInterest, gnPeriods)    &amp;&amp; 显示 27887.93
            </code>
        </example>
    </fv>

    <getautoincvalue>
        <summary>
            返回数据会话中自动递增字段生成的最后一个值。
        </summary>
        <param name="nDataSessionNumber">
            指定返回自动递增字段值的数据会话的数据会话编号。
            如果省略nDataSessionNumber和0参数，则返回当前数据会话的自动递增字段值。
            使用Set DATASESSION激活特定的数据会话。
        </param>
        <param name="0">
            指定返回的最后一个自动递增字段值来自当前作用域（函数、方法、过程）。
            使用此参数可防止当前代码块外的事件（如ON KEY LABEL）执行可能意外更改值的代码。
        </param>
        <returns>
            数值数据类型。GetAutoIncValue()返回的值是生成的最后一个自动递增值，即使字段未成功更新为
            自动递增值。如果尚未为数据会话生成自动递增值，则返回.NULL.。例如，如果
            打开了数据会话但未发生更新，则返回.NULL.。
        </returns>
        <remarks>
            当包含AutoInc选项时，自动递增字段值会为表操作（如Append命令、Insert命令、Append From命令
            和Blank命令）更新。有关自动递增字段的更多信息，请参阅表中的自动递增字段值。
        </remarks>
    </getautoincvalue>

    <getcolor>
        <summary>
            显示Windows颜色对话框并返回所选颜色的颜色编号。
        </summary>
        <param name="nDefaultColorNumber">
            指定显示颜色对话框时最初选择的颜色。如果nDefaultColorNumber不对应于颜色对话框中的颜色，
            则选择颜色对话框中的第一个颜色。如果省略nDefaultColorNumber，则选择黑色。
        </param>
        <returns>
            数值型
        </returns>
        <remarks>
            如果通过按Esc、选择取消按钮或从控制菜单中选择关闭来退出颜色对话框，GetColor()返回-1。
        </remarks>
        <example>
             <code language="X#">
                Clear
                ? GetColor(255)
            </code>
        </example>
    </getcolor>

    <getcp>
        <summary>
            通过显示代码页对话框提示选择代码页，然后返回所选代码页的编号。
        </summary>
        <param name="nCodePage">
            指定显示代码页对话框时最初选择的代码页编号。
            如果nCodePage为0或省略nCodePage，则显示代码页对话框时不会选择代码页。
        </param>
        <param name="cText">
            指定在代码页对话框中显示的文本。如果省略cText，X#将显示以下文本：
            "请选择用于跨平台数据共享的代码页。"
        </param>
        <param name="cDialogTitle">
            指定显示在代码页对话框标题栏中的标题。如果省略cDialogTitle，将显示标题"代码页"。
        </param>
        <returns>
            数值型
        </returns>
        <remarks>
            如果通过按Esc、选择取消按钮或从控制菜单中选择关闭来退出代码页对话框，GetCp()将返回0。<br/>
            代码页对话框中列出的代码页由X#国际代码页支持文件Foxpro.INT确定。<br/>
            您可以在支持AS nCodePage子句的命令（如MODIFY COMMAND、Append From和COPY TO）中包含GetCp()。<br/>
            将显示代码页对话框，使您能够指定打开、追加或创建的文件的代码页。<br/>
            由于不存在代码页0，因此如果用户选择Esc、取消按钮或从控制菜单中选择关闭，您必须捕获0。
        </remarks>
        <example>
             <code language="X#">? GetCp(1252, "选择代码页", "代码页选择")</code>
        </example>
    </getcp>

    <getcursoradapter>
        <summary>
            通过引用游标名称在运行时返回<b>CursorAdapter</b>对象的对象引用。
        </summary>
        <param name="cAlias">
            指定游标的别名。如果不提供别名，X#将使用当前工作区中游标的别名。
        </param>
        <returns>
            <b>CursorAdapter</b>对象的对象引用。
        </returns>
        <remarks>
            适用于：CursorAdapter类
        </remarks>
    </getcursoradapter>

    <getdir>
        <summary>
            显示"选择目录"对话框，您可以从中选择目录。
        </summary>
        <param name="cDirectory">
            指定对话框中最初显示的目录。当未指定cDirectory时，
            对话框将打开并显示X#默认目录。
        </param>
        <param name="cText">
            指定对话框中目录列表的文本。
        </param>
        <param name="cCaption">
            指定要在对话框标题栏中显示的标题。Windows默认为"选择目录"。
        </param>
        <param name="nFlags">
            指定对话框的选项。nFlags可以包括零个或多个值的组合。<br/>
            备注部分的表格包含一些更常用的标志。有关更多信息，请参阅MSDN中的SHBrowseForFolder。
        </param>
        <param name="lRootOnly">
            指定仅显示cDirectory及其子文件夹。此参数防止导航到根文件夹之上。
            如果未指定cDirectory，则使用默认目录（Set DEFAULT值）。
        </param>
        <returns>
            字符型
        </returns>
        <remarks>
            GetDir()以字符串形式返回您选择的目录名称。<br/>
            如果您未选择目录（单击取消、按Esc或从窗口菜单中选择关闭），GetDir()将返回空字符串。<br/>
            从X# 7开始，GetDir()支持两种不同的对话框。如果提供少于三个参数，
            GetDir()将返回早期版本的对话框。如果提供超过两个参数，
            X#将使用Win32 API中的<b>SHBrowseForFolder</b>例程提供对话框。<br/>

            <list type="table">
                <listheader>
                    <term>nFlag</term>
                    <description>值</description>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>BIF_RETURNONLYFSDIRS</description>
                    <description>
                        仅返回文件系统目录（物理位置）。如果用户选择不属于文件系统的文件夹，"确定"按钮将变灰。
                    </description>
                </item>
                <item>
                    <term>2</term>
                    <description>
                        BIF_DONTGOBELOWDOMAIN
                    </description>
                    <description>
                        在树视图控件中不包括域级别以下的网络文件夹（例如，我的电脑和我的网络）。
                    </description>
                </item>
                <item>
                    <term>8</term>
                    <description>
                        BIF_RETURNFSANCESTORS
                    </description>
                    <description>
                        仅返回文件系统祖先。如果用户选择文件系统祖先以外的任何内容，"确定"按钮将变灰。
                    </description>
                </item>
                <item>
                    <term>16</term>
                    <description>
                        BIF_EDITBOX
                    </description>
                    <description>
                        浏览对话框包括一个编辑控件，用户可以在其中键入项目名称。在Windows 98及更高版本上可用，
                        或在Internet Explorer 4.0或更高版本上可用（假设选择了shell集成选项）。需要shell32.dll版本4.71。
                    </description>
                </item>
                <item>
                    <term>32</term>
                    <description>BIF_VALIDATE</description>
                    <description>
                        验证编辑框内容。如果使用编辑框，则需要验证用户指定的内容。
                        如果用户在编辑框中键入无效名称，取消按钮将成为唯一可用的选择。
                        如果未指定BIF_EDITBOX，则忽略此标志。
                    </description>
                </item>
                <item>
                    <term>64</term>
                    <description>
                        BIF_NEWDIALOGSTYLE
                    </description>
                    <description>
                        使用新的用户界面。设置此标志将为用户提供更大、可调整大小的对话框。其他功能包括：
                        对话框内的拖放功能、重新排序、上下文菜单、新建文件夹、删除和其他上下文菜单命令。
                        在Windows 2000及更高版本上支持。需要shell32.dll版本5.00。
                    </description>
                </item>
                <item>
                    <term>16384</term>
                    <description>
                        BIF_BROWSEINCLUDEFILES
                    </description>
                    <description>
                        浏览对话框将显示文件和文件夹。在Windows 98及更高版本上可用，或在Internet Explorer 4.0或更高版本上可用
                        （假设选择了shell集成选项）。需要shell32.dll版本4.71。
                    </description>
                </item>
            </list>
        </remarks>
    </getdir>

    <getfile>
        <summary>
            显示打开对话框。
        </summary>
        <param name="cFileExtensions">
            指定在未选择"所有文件"类型时在打开对话框中显示的文件的文件名扩展名。<br/>
            有关更多信息，请参阅备注部分
        </param>
        <param name="cText">
            指定在打开对话框中显示的文件名标签的文本。
        </param>
        <param name="cOpenButtonCaption">
            指定打开对话框中"确定"按钮的标题。
        </param>
        <param name="nButtonType">
            指定在打开对话框中显示的按钮的数量和类型。备注部分的表格列出了nButtonType的值。
        </param>
        <param name="cTitleBarCaption">
            指定打开对话框标题栏的标题。
        </param>
        <remarks>
            传递字面值时，请用引号（""）将其括起来。不要在文件名扩展名前包含句点（.）。<br/>
            <note name="注意">cFileExtensions参数的长度不能超过254个字符。</note>
            cFileExtensions可以采用多种形式：<br/>
            <list type="bullet">
                <term>如果cFileExtensions包含单个扩展名，例如"prg"，则打开对话框仅显示具有该扩展名的文件名。</term>
                <term>如果cFileExtensions为空字符串，则打开对话框显示当前目录中的所有文件。</term>
                <term>
                    cFileExtensions可以包含通配符，如*和?。打开对话框显示扩展名满足通配符条件的所有文件名。
                    例如，如果cFileExtensions为"?X?"，则打开对话框显示扩展名为.fxp、.exe和.txt的所有文件名。
                </term>
                <term>
                    cFileExtensions可以包含文件描述，后跟文件扩展名或用逗号分隔的文件扩展名列表。
                    文件描述显示在打开对话框的"文件类型"列表中。
                    用冒号（:）分隔文件描述和文件扩展名或文件扩展名列表。
                    用分号（;）分隔多个文件描述及其文件扩展名。
                </term>
                <term>
                    例如，如果cFileExtensions为"文本:TXT"，则打开对话框在"文件类型"列表中显示文件描述"文本"，
                    并显示所有扩展名为.txt的文件。
                </term>
                <term>
                    如果cFileExtensions为"表:DBF; 文件:TXT,BAK"，则文件描述"表"和"文件"出现在"文件类型"列表中。
                    从"文件类型"列表中选择"表"时，将显示所有扩展名为.dbf的文件。从"文件类型"列表中选择"文件"时，
                    将显示所有扩展名为.txt和.bak的文件。
                </term>
                <term>如果cFileExtensions仅包含分号（";"），则打开对话框显示所有没有扩展名的文件。</term>
            </list>
            <list type="table">
                <listheader>
                    <term>nButtonType</term>
                    <description>显示的按钮</description>
                </listheader>
                <item>
                    <term>0（或省略）</term>
                    <description>确定、取消</description>
                </item>
                <item>
                    <term>1</term>
                    <description>确定、新建、取消</description>
                </item>
                <item>
                    <term>2</term>
                    <description>确定、无、取消</description>
                </item>
            </list><br/>

            <note name="注意">
                当nButtonType设置为1且用户单击新建时，或当nButtonType设置为2且用户单击无时，
                GetFile()返回带有打开对话框中指定路径的字符串"Untitled"。
            </note>
        </remarks>
        <returns>
            字符型。GetFile()返回在打开对话框中选择的文件名，或者如果用户通过按Esc、
            单击取消或单击打开对话框上的关闭按钮来关闭打开对话框，则返回空字符串。
        </returns>
        <example>
             <code language="X#">
                Close Databases
                Select 0
                gcTable=GetFile('DBF', '浏览或创建.DBF:',
                '浏览', 1, '浏览或创建')

                DO CASE
                    CASE 'Untitled' $ gcTable
                        Create (gcTable)
                    CASE EMPTY(gcTable)
                        RETURN
                    OTHERWISE
                        Use (gcTable)
                        BROWSE
                ENDCASE
            </code>
        </example>
    </getfile>

    <getfldstate>
        <summary>
            返回一个数值，表示表或游标中的字段是否被修改、是否添加了记录，
            或当前记录的删除状态是否已更改。
        </summary>
        <param name="uField">
            指定要返回修改状态的字段名称或字段编号。
            字段编号 nFieldNumber 对应于表或游标结构中字段的位置。
            可以使用 Display Structure 或 Field() 来确定字段的编号。<br/>
            可以为 nFieldNumber 指定 -1，以返回由表或游标中所有字段的删除和修改状态值组成的字符串。
            例如，如果一个表有五个字段，只有第一个字段被更改，GetFldState() 将返回 121111。<br/>
            第一个位置的 1 表示删除状态没有改变。<br/>
            还可以为 nFieldNumber 包含 0，以确定自表或游标打开以来当前记录的删除状态是否已更改。

            <note name="注意">
                使用 GetFldState() 只能确定当前记录的删除状态是否已更改。
                例如，如果您标记一条记录为删除，然后又取消删除，GetFldState() 会指示删除状态已更改，即使记录的删除状态已恢复到原始状态。
                使用 Deleted() 可以确定记录的当前删除状态。
            </note>
        </param>
        <param name="uArea">
            指定要返回字段修改或记录删除状态的表或游标的别名。<br/>
            或<br/>
            指定要返回字段修改或记录删除状态的表或游标的工作区。<br/>
            如果不指定别名或工作区，GetFldState() 将返回当前选定表或游标中字段的值。
        </param>
        <returns>
            数值、字符或 .NULL.
        </returns>
        <remarks>
            下表列出了字符返回值及其对应的修改或删除状态。
            <list type="table">
                <listheader>
                    <term>返回值</term>
                    <description>修改或删除状态</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>字段未被修改或删除状态未改变。</description>
                </item>
                <item>
                    <term>2</term>
                    <description>字段已被修改或删除状态已改变。</description>
                </item>
                <item>
                    <term>3</term>
                    <description>新添加记录中的字段未被修改或新添加记录的删除状态未改变。</description>
                </item>
                <item>
                    <term>4</term>
                    <description>新添加记录中的字段已被修改或新添加记录的删除状态已改变。</description>
                </item>
                <item>
                    <term>.NULL.</term>
                    <description>在 EOF() 位置</description>
                </item>
            </list>
            对于本地表，必须先使用 CursorSetProp() 启用行或表缓冲，GetFldState() 才能操作。<br/>
            如果在没有可选 uArea 参数的情况下发出 GetFldState()，将返回当前选定工作区中打开的表或游标的修改或删除状态。<br/>
            字段的任何更改都会导致 GetFldState() 返回表示字段已被修改的值，无论更改是显式的还是隐式的。
            显式修改的例子是在 Replace 或 Insert Into 命令中包含该字段。当发出任何添加新记录的命令时，具有默认值的字段会发生隐式修改。
        </remarks>
        <examples>
            以下示例演示如何使用 GetFldState() 来确定字段的内容是否已更改。设置 MultiLocks 为 ON，
            这是表缓冲的要求。打开 <c>testdata</c> 数据库中的 <c>customer</c> 表，
            然后使用 CursorSetProp() 将缓冲模式设置为乐观表缓冲（5）。
            在修改 <c>cust_id</c> 字段之前，发出 GetFldState() 显示对应于未修改状态的值（1）。
            使用 Replace 修改 <c>cust_id</c> 字段，然后再次发出 GetFldState() 显示对应于已修改状态的值（2）。
            使用 TableRevert() 将表恢复到原始状态，然后再次发出 GetFldState() 显示对应于 <c>cust_id</c> 字段原始状态的值（1）。
             <code language="X#">
                Close Databases
                Clear
                Set MultiLocks ON         &amp;&amp; 允许表缓冲
                Open Database (HOME(2) + 'data\testdata')
                Use Customer             &amp;&amp; 打开 customer 表
                =CursorSetProp("Buffering",5,"customer")  &amp;&amp; 启用表缓冲
                * 获取原始 cust_id 字段的状态并显示
                nState=<b>GetFldState(</b>"cust_id"<b>)</b>
                DO DisplayState WITH nState, "原始"
                * 更改字段内容并显示状态
                Replace cust_id    WITH "***"
                nState=<b>GetFldState(</b>"cust_id"<b>)</b>
                DO DisplayState WITH nState, "Replace 后"
                * 丢弃表更改并显示状态
                = TableRevert(.T.)        &amp;&amp; 丢弃所有表更改
                nState=<b>GetFldState(</b>"cust_id"<b>)</b>
                DO DisplayState WITH nState, "Revert 后"
                PROCEDURE DisplayState
                PARAMETER nState,cOperation
                DO CASE
                CASE nState=1
                =MessageBox("字段未被修改",0,cOperation)
                OTHERWISE
                =MessageBox("字段已被修改",0,cOperation)
                ENDCASE
            </code>
            以下示例展示了有默认值和没有默认值的字段之间的行为差异。
             <code language="X#">
                Set MultiLocks ON
                Create Database example
                Create Table customer (cust_id C(6),state C(2) DEFAULT "FL")
                Close TableS
                Use customer
                =CursorSetProp("Buffering",5,"customer")
                Append Blank
                ?GetFldState("cust_id")     &amp;&amp; 返回 3，新添加记录中的字段未被修改
                ?GetFldState("state")    &amp;&amp; 返回 4，新添加记录中的字段已被修改
            </code>
        </examples>
    </getfldstate>

    <getfont>
        <summary>
            显示字体对话框并返回您选择的字体信息。
        </summary>
        <param name="cFontName">
            指定在字体对话框中最初选择的字体名称。如果您指定的字体未安装，则最初选择默认字体。
        </param>
        <param name="nFontSize">
            指定在字体对话框中最初选择的字体大小。如果您指定的字体大小不受支持，则最初选择默认字体大小。
            如果您省略 nFontSize 或 nFontSize 小于或等于零，则字体大小默认选择为 10 点。<br/>
            <note name="注意">
                对话框允许您选择 <code>4</code> 到 <code>127</code>（含）之间的大小。调用 <b>GetFont</b> 函数时，您可以指定其他 nFontSize 值；
                不会发生错误。但是，如果这样做，用户必须在对话框中点击 <b>确定</b> 之前选择指定范围内的大小。否则，对话框将显示警告并不接受该值。
            </note>
        </param>
        <param name="cFontStyle">
            指定在字体对话框中最初选择的字体样式，或仅显示所选打印机上可用的字体。
            如果您指定的字体样式不受支持，则最初选择默认字体样式。<br/>
            备注部分的表格列出了 cFontStyle 可用的值。
        </param>
        <param name="nFontCharSet">
            指定语言脚本的值。您可以指定的值因 Windows 版本而异。
            <note name="注意">省略此值将禁用对话框中的脚本下拉列表。</note>
            备注部分的表格描述了 nFontCharSet 的一些示例值。
            <note name="注意">
                如果为 nFontCharSet 指定 1，<b>GetFont()</b> 打开的对话框将显示操作系统上的默认语言脚本。
                <b>GetFont()</b> 永远不会返回 1，因为它返回在 <b>GetFont()</b> 对话框中选择的语言脚本的值。<br/>
                有关更多信息，请参见 FontCharSet 属性。
            </note>
        </param>
        <returns>
            字符。<b>GetFont()</b> 根据某些条件返回以下之一：
            <list type="bullet">
                <term>
                    包含三种字体信息的字符串，返回项目用逗号分隔：字体名称、大小和样式。
                    当您在字体对话框中选择一个字体，且调用 <b>GetFont()</b> 函数时未包含第四个可选参数时，会出现此行为。
                </term>
                <term>
                    包含四种字体信息的字符串，返回项目用逗号分隔：字体名称、大小、样式和语言脚本。
                    如果包含 nFontCharSet 参数的值，则会出现此行为。
                </term>
                <note name="注意">
                    在 X# 9.0 之前的版本中，如果您将 0 作为第四个参数包含在 <b>GetFont()</b> 中，
                    您将收到与完全不包含第四个参数相同的返回信息。脚本下拉列表未启用，
                    返回值仅包含三种字体信息。在 X# 9.0 中，值 0 明确表示对应于西方脚本的数值。
                    如果您为此值指定 1，脚本下拉列表可能也会最初显示西方，但前提是西方是您的区域设置的默认脚本。
                </note>
                <term>
                    如果您通过单击 <b>取消</b>、控制菜单上的 <b>关闭</b> 或按 <b>Esc</b> 键退出字体对话框，则返回空字符串。
                </term>
            </list>
        </returns>
        <remarks>
            <list type="table">
                <listheader>
                    <term>cFontStyle</term>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>B</term>
                    <description>最初选择粗体字体样式。</description>
                </item>
                <item>
                    <term>I</term>
                    <description>最初选择斜体字体样式。</description>
                </item>
                <item>
                    <term>BI</term>
                    <description>最初选择粗斜体字体样式。</description>
                </item>
                <item>
                    <term>P</term>
                    <description>仅显示当前默认打印机上可用的字体。</description>
                </item>
            </list>
            <br/>
            <list type="table">
                <listheader>
                    <term>nFontCharSet</term>
                    <description>语言脚本</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>西方</description>
                </item>
                <item>
                    <term>1</term>
                    <description>默认</description>
                </item>
                <item>
                    <term>2</term>
                    <description>符号</description>
                </item>
                <item>
                    <term>128</term>
                    <description>日语</description>
                </item>
                <item>
                    <term>161</term>
                    <description>希腊语</description>
                </item>
                <item>
                    <term>162</term>
                    <description>土耳其语</description>
                </item>
                <item>
                    <term>163</term>
                    <description>越南语</description>
                </item>
                <item>
                    <term>177</term>
                    <description>希伯来语</description>
                </item>
                <item>
                    <term>178</term>
                    <description>阿拉伯语</description>
                </item>
                <item>
                    <term>186</term>
                    <description>波罗的语</description>
                </item>
                <item>
                    <term>204</term>
                    <description>西里尔语</description>
                </item>
                <item>
                    <term>238</term>
                    <description>中欧语言</description>
                </item>
            </list>
        </remarks>
        <example>
             <code language="X#">
                * 调用对话框，禁用脚本下拉列表：
                ? GetFont("Arial",12,"B") &amp;&amp; 在对话框中按确定
                * 返回值是字符串：
                * "Arial,12,B"
                * 启用脚本下拉列表，选择西方脚本：
                ? GetFont("Arial",12,"B",0) &amp;&amp; 选择后按确定
                * 返回值示例是字符串：
                * "Verdana,16,N,161"
                * 不做选择退出对话框：
                ? GetFont("Arial",12,"B") &amp;&amp; 在对话框中按取消
                * 返回值是空字符串
                ? GetFont("Arial",12,"B",0) &amp;&amp; 在对话框中按取消
                * 返回值仍然是空字符串
            </code>
        </example>
    </getfont>

    <getnextmodified>
        <summary>
            返回缓冲表或游标中下一个已修改记录的记录号。
        </summary>
        <param name="nRecordNumber">
            指定<b>GetNextModified( )</b>从哪个记录号之后开始搜索下一个已修改的记录。指定0作为nRecordNumber可以确定表或游标中第一个已修改的记录。
        </param>
        <param name="uArea">
            指定<b>GetNextModified( )</b>返回下一个已修改记录号的表或游标的别名。<br/>
            或者<br/>
            指定<b>GetNextModified( )</b>返回下一个已修改记录号的表或游标的工作区。
            如果不指定别名或工作区，<b>GetNextModified( )</b>返回当前选定表或游标中下一个已修改记录的记录号。
        </param>
        <param name="lNoFire">
            指定抑制所有规则的触发。
        </param>
        <returns>
            数值型
        </returns>
        <remarks>
            如果在指定记录之后没有已修改的记录，<b>GetNextModified( )</b>返回0。因此，如果只修改了一条记录，
            要验证其修改，必须首先使用<b>GO TOP</b>命令将游标定位到更改记录之前。
            如果记录的任何字段内容以任何方式更改（即使恢复了原始字段内容）或记录的删除状态发生变化，则认为该记录已被修改。<br/>
            <b>GetNextModified( )</b>只能对启用了表缓冲的表和游标进行操作。
            可以使用<b>CursorSetProp( )</b>启用表缓冲。<br/>
            由于触发器不受<b>GetNextModified( )</b>影响，lNoFire只抑制字段和记录规则，以及"违反索引ID唯一性"错误。
            lNoFire防止将临时数据（如存储在控件中的数据或对当前记录所做的更新）刷新到底层游标。
        </remarks>
        <example>
             <code language="X#">
                LOCAL lnCurRec
                Clear
                Close Databases
                Open Database (HOME(2) + 'data\testdata')
                Use Customer
                * 启用表缓冲。
                Set MultiLocks ON
                =CursorSetProp("Buffering", 5, "customer")
                * 将墨西哥客户的MAXORDAMT增加10%。
                Update Customer Set MaxOrdAmt=MaxOrdAmt * 1.1 Where Country = "Mexico"
                * 从第一个已修改的记录开始。
                lnCurRec = <b>GetNextModified</b>(0)

                * 循环直到处理完所有已修改的记录。
                DO WHILE .T.
                    * 移动到当前已修改的记录。
                    GOTO (m.lnCurRec)
                    * 在此处理已修改的行。
                    ? Customer.Company, Customer.MaxOrdAmt

                    IF Customer.MaxOrdAmt &gt; 8500
                        =TableRevert(.F.)
                    ENDIF

                    ?? Customer.MaxOrdAmt

                    * 从这里获取下一个已修改的记录。
                    lnCurRec = <b>GetNextModified</b>(m.lnCurRec)

                    IF m.lnCurRec = 0 &amp;&amp; 没有更多已修改的记录。
                EXIT
                    ENDIF
                ENDDO

                =TableRevert(.T.)  &amp;&amp; 恢复示例数据并放弃所有更改。
            </code>
        </example>
    </getnextmodified>

    <getobject>
        <summary>
            激活一个自动化对象并创建对该对象的引用。
        </summary>
        <param name="cFileName">
            指定要激活的文件的完整路径和名称。不需要指定应用程序，
            因为OLE动态链接库会根据您提供的文件名确定要启动的应用程序。<br/>
            例如，以下代码启动Microsoft Excel，打开名为BUDGET.XLS的文件，并通过名为MBUDVAR的对象
            变量创建引用：
             <code language="X#">MBUDVAR = GetObject('C:\EXCEL\WORK\BUDGET.XLS')</code>
        </param>
        <param name="Moniker">
            实现IMoniker接口的COM对象的标识符。moniker可以是以下类型之一：文件、项目、
            通用复合、
            反、指针和URL。有关COM moniker的详细信息，请在Microsoft开发者网络上搜索"IMoniker"。
        </param>
        <param name="cClassName">
            指定要检索的对象的类名。某些应用程序可以在同一文件中存储多个对象类型，
            使您可以使用类名来指定要激活的对象。例如，如果文字处理应用程序
            在同一文件中存储其文档、宏定义和工具栏对象，您可以使用以下命令创建对文档文件的引用：
             <code language="X#">MDOCFILE = GetObject('C:\WRDPROC\MYDOC.DOC','WrdProc.Document')</code>
            对于某些服务器应用程序，每次发出<b>GetObject( )</b>时，都会启动该应用程序的另一个实例，
            使用额外的内存。如果应用程序已在运行，您可以通过省略FileName并包含ClassName来防止启动应用程序的其他实例，如下例所示：
             <code language="X#">oleApp = GetObject(, "Excel.Application")</code>
        </param>
        <returns>
            对象引用
        </returns>
        <remarks>
            使用<b>GetObject( )</b>从文件激活自动化对象，并通过内存变量或数组元素分配对该对象的引用。
            如果指定了无效的文件或类名，将显示OLE错误，并且<b>GetObject( )</b>函数返回空字符串。
        </remarks>
        <example>
             <code language="X#">
                *  将"DomainName"替换为域名，将"UserLoginID"
                *  替换为要查找的用户的登录ID。
                oUser = GetObject("WinNT://DomainName/UserLoginID,user")
                ? oUser.FullName
            </code>
        </example>
    </getobject>

    <getpict>
        <summary>
            显示"打开图片"对话框并返回您选择的图片文件名。<br/>
            在 Windows 2000 及更高版本中，您可以通过单击"查看菜单"图标然后选择"缩略图"来预览图像。
            X# 使用缩略图视图作为默认设置，以提供图像的迷你预览。因此，"打开图片"对话框不再包含用于显示图像的框架。
            仅在早于 Windows 2000 的操作系统上运行 X# 时，"打开图片"对话框中才会出现"预览"复选框。
        </summary>
        <param name="cFileExtensions">
            指定在未选择"所有文件"菜单项时，在可滚动列表中显示的图片文件的文件扩展名。<br/>
        </param>
        <param name="cFileNameCaption">
            指定显示在"文件名"文本框左侧的标题。cFileNameCaption 替换了省略 cFileNameCaption 时出现的"文件名"。
        </param>
        <param name="cOpenButtonCaption">
            为"确定"按钮指定标题。
        </param>
        <returns>
            字符数据类型。返回您选择的图片文件的名称。
        </returns>
        <remarks>
            如果您通过按 Esc、选择"取消"按钮或单击"关闭"按钮退出"打开图片"对话框，GetPict() 函数将返回空字符串。
            在命令窗口中键入 <b>GetPict()</b> 显示的"打开图片"对话框使您能够快速定位 X# 支持的所有图形文件。
            在早于 X# 8.0 的版本中，请在"打开图片"对话框中勾选"预览"复选框以显示当前选择的图形文件。<br/>
            下表列出了 X# 支持的图形文件格式。
            <list type="table">
                <listheader>
                    <term>图形格式</term>
                    <description>文件扩展名</description>
                </listheader>
                <item>
                    <term>动画光标</term>
                    <description>.ani</description>
                </item>
                <item>
                    <term>位图</term>
                    <description>.bmp</description>
                </item>
                <item>
                    <term>光标</term>
                    <description>.cur</description>
                </item>
                <item>
                    <term>设备无关位图</term>
                    <description>.dib</description>
                </item>
                <item>
                    <term>可交换图像文件</term>
                    <description>.exif</description>
                </item>
                <item>
                    <term>图形交换格式</term>
                    <description>.gif, .gfa</description>
                </item>
                <item>
                    <term>联合图像专家组，JPEG文件交换格式</term>
                    <description>.jpg, .jpeg, .jpe, .jfif</description>
                </item>
                <item>
                    <term>图标</term>
                    <description>.ico</description>
                </item>
                <item>
                    <term>便携式网络图形</term>
                    <description>.png</description>
                </item>
                <item>
                    <term>标签图像文件格式</term>
                    <description>.tif, .tiff</description>
                </item>
                <item>
                    <term>Windows 增强型图元文件</term>
                    <description>.emf</description>
                </item>
            </list>
            <note name="注意">
                在 X# 中，光标、动画光标和图标文件可以用作图形文件。例如，您可以为图像控件的 Picture 属性指定一个动画光标文件
                （但是，图像控件显示的是光标的静态表示）。>
            </note>
            使用 Clear RESOURCES 命令清除所有缓存的图形文件，包括 .gif 和 .jpg 文件。<br/>

            cFileExtensions 可以采用以下形式：
            <list type="bullet">
                <term>如果 cFileExtensions 包含单个扩展名（例如，.bmp），则只显示具有该扩展名的文件。</term>
                <term>
                    cFileExtensions 还可以包含通配符（* 和 ?）。将显示所有扩展名符合通配符条件的文件。
                    例如，如果 cFileExtensions 是 ?X?，则会显示所有扩展名为 .fxp、.exe 和 .txt 的文件。
                </term>
                <term>如果 cFileExtensions 包含空字符串（""），则显示所有可用的图形文件（例如，扩展名为 .bmp 和 .dib 的文件）。</term>
            </list>
        </remarks>
    </getpict>

    <getprinter>
        <summary>
            显示"打印机"对话框并返回所选打印机的名称。
        </summary>
        <returns>
            GETPRINTER( )返回值
            字符型。<b>GetPrinter( )</b>返回所选打印机的名称。如果您通过按Esc键或单击"取消"或"关闭"退出"打印机"对话框，<b>GetPrinter( )</b>将返回一个空字符串。
        </returns>
        <remarks>
            "打印机"对话框的内容可能因Windows版本而异。
            例如，"打印机"对话框可能只包含打印机名称或包括网络路径。
        </remarks>
        <example>
             <code language="X#">
                Clear
                cPrinter = GETPRINTER( )
                WAIT IIF(EMPTY(cPrinter), '未选择打印机', cPrinter)
            </code>
        </example>
    </getprinter>

    <getresultset>
        <summary>
            检索当前数据会话中由<b>SetResultSet( )</b>标记的游标的工作区号。
        </summary>
        <returns>
            GetResultSet( )返回值<br/>
            数值型。<b>GetResultSet( )</b>返回当前数据会话中标记的游标的工作区号，如果当前数据会话中没有标记的游标，则返回零(0)。
        </returns>
        <remarks>
            <b>GetResultSet( )</b>在X#和X# OLE DB提供程序中受支持。
            您可以在数据库容器(DBC)存储过程中使用<b>GetResultSet( )</b>或将其发送到X# OLE DB提供程序，
            假设游标已由OLE DB提供程序先前打开。
        </remarks>
    </getresultset>

    <imestatus>
        <summary>
            打开或关闭IME（输入法编辑器）窗口，或返回当前IME状态。
        </summary>
        <param name="nExpression">
            打开或关闭IME窗口。备注部分的表格列出了nExpression的值及其对应的IME窗口状态。
        </param>
        <returns>
            数值型
        </returns>
        <remarks>
            有关更多信息，请参阅开发国际化应用程序。<br/>
            此函数对于操作双字节字符集（如平假名和片假名）的语言很有用。
            <list type="table">
                <listheader>
                    <term>nExpression</term>
                    <description>IME窗口操作</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>关闭IME窗口。</description>
                </item>
                <item>
                    <term>1</term>
                    <description>打开IME窗口。</description>
                </item>
            </list>
            如果省略nExpression，<b>ImeStatus( )</b>返回当前IME状态。
            下表列出了IME状态的返回值。使用VERSION(3)确定当前区域设置。<br/>
            以下表格列出了日语区域设置中IME状态的返回值。
            <list type="table">
                <listheader>
                    <term>返回值</term>
                    <description>IME状态</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>未安装IME</description>
                </item>
                <item>
                    <term>1</term>
                    <description>IME开启</description>
                </item>
                <item>
                    <term>2</term>
                    <description>IME关闭</description>
                </item>
                <item>
                    <term>3</term>
                    <description>IME禁用</description>
                </item>
                <item>
                    <term>4</term>
                    <description>平假名模式（双字节）</description>
                </item>
                <item>
                    <term>5</term>
                    <description>片假名模式（双字节）</description>
                </item>
                <item>
                    <term>6</term>
                    <description>片假名模式（单字节）</description>
                </item>
                <item>
                    <term>7</term>
                    <description>字母数字模式（双字节）</description>
                </item>
                <item>
                    <term>8</term>
                    <description>字母数字模式（单字节）</description>
                </item>
            </list><br/>
            以下表格列出了韩语区域设置中IME状态的返回值。
            <list type="table">
                <listheader>
                    <term>返回值</term>
                    <description>IME状态</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>未安装IME</description>
                </item>
                <item>
                    <term>1</term>
                    <description>谚文模式（单字节）</description>
                </item>
                <item>
                    <term>2</term>
                    <description>英文模式（单字节）</description>
                </item>
                <item>
                    <term>11</term>
                    <description>英文模式（双字节）</description>
                </item>
                <item>
                    <term>15</term>
                    <description>谚文模式（双字节）</description>
                </item>
                <item>
                    <term>23</term>
                    <description>汉字转换模式（谚文 + 单字节模式）</description>
                </item>
                <item>
                    <term>31</term>
                    <description>汉字转换模式（谚文 + 双字节模式）</description>
                </item>
            </list>
        </remarks>
    </imestatus>

    <indbc>
        <summary>
            如果指定的数据库对象在当前数据库中，则返回true (.T.)；否则返回false (.F.)。
        </summary>
        <param name="cDatabaseObjectName">
            指定命名连接、字段、索引、表或SQL视图的名称，InDbc( )将为其返回一个逻辑值，
            表示该对象是否在当前数据库中。
        </param>
        <param name="cType">
            指定cDatabaseObjectName的数据库对象类型。
            备注部分的表格列出了cType的值及其对应的数据库对象类型。<br/>
            Connection、Field、Index、Table和View设置不能缩写。
        </param>
        <returns>
            逻辑值
        </returns>
        <remarks>
            当执行<b>InDbc( )</b>时，必须有一个打开的当前数据库；否则X#会生成一个错误消息。
            <list type="table">
                <listheader>
                    <term>cType</term>
                    <description>数据库对象类型</description>
                </listheader>
                <item>
                    <term>Connection</term>
                    <description>命名连接</description>
                </item>
                <item>
                    <term>Field</term>
                    <description>字段</description>
                </item>
                <item>
                    <term>Index</term>
                    <description>索引</description>
                </item>
                <item>
                    <term>Table</term>
                    <description>表</description>
                </item>
                <item>
                    <term>View</term>
                    <description>SQL视图</description>
                </item>
            </list>
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Create Database mydbc  &amp;&amp; 创建一个新数据库
                Create Table mytable (field1 C(10)) &amp;&amp; 自动添加到数据库
                ? 'MyTable在数据库中吗？ '
                ?? InDbc('mytable', 'Table')  &amp;&amp; 返回 .T.
                Close Databases
                Delete Database mydbc DeleteTables
            </code>
        </example>
    </indbc>

    <indexseek>
        <summary>
            在不移动记录指针的情况下，在索引表中搜索第一个索引键与指定表达式匹配的记录。
        </summary>
        <param name="eExpression">
            指定要搜索的索引键表达式。
        </param>
        <param name="lMovePointer">
            指定是否将记录指针移动到匹配的记录。如果lMovePointer为真（.T.）且存在匹配记录，
            则记录指针移动到匹配记录。如果lMovePointer为真（.T.）但不存在匹配记录，
            则记录指针不移动。如果lMovePointer为假（.F.）或省略，即使存在匹配记录，记录指针也不移动。
        </param>
        <param name="uArea">
            指定要搜索索引键的工作区号。<br/>
            或<br/>
            指定要搜索的表别名。如果省略uArea，则搜索当前选定工作区中的表。
        </param>
        <param name="nIndexNumber">
            指定用于搜索索引键的索引文件或标记的编号。nIndexNumber指的是在Use或Set Index中列出的索引文件。
            打开的.IDX文件首先按照它们在Use或Set Index中出现的顺序编号。
            然后，结构化.cdx文件（如果存在）中的标记按照它们创建的顺序编号。
            最后，任何打开的独立.cdx文件中的标记按照它们创建的顺序编号。有关索引编号的更多信息，请参见Set Order。
        </param>
        <param name="cIDXIndexFileName">
            指定用于搜索索引键的.idx文件。
        </param>
        <param name="cTagName">
            指定用于搜索索引键的.cdx文件的标记。标记名可以来自结构化.cdx文件或任何打开的
            独立.cdx文件。<br/>
            如果存在重复的.idx文件和标记名，则.idx文件优先。
        </param>
        <returns>
            逻辑值
        </returns>
        <remarks>
            如果找到匹配项，<b>IndexSeek( )</b>返回真（.T.）；否则返回假（.F.）。
            您只能在设置了索引顺序的表上使用<b>IndexSeek( )</b>，并且只能搜索索引键。
            除非将<b>Set EXACT</b>设置为OFF，否则匹配必须精确。<br/>
            <b>IndexSeek( )</b>提供了一种快速搜索记录的方法，而无需移动记录指针。
            由于记录指针不移动，规则和触发器不会执行。如果<b>IndexSeek( )</b>返回真
            （.T.）表示找到匹配记录，您可以再次执行<b>IndexSeek( )</b>，将第二个参数lMovePointer设置为真
            （.T.）以移动到匹配记录。<br/>
            当您尝试在最近创建的记录中查找值时（使用<b>Insert Into</b>或<b>Append Blank</b>创建），
            <b>IndexSeek( )</b>返回假（.F.），直到记录指针移动。您可以执行<b>GO BOTTOM</b>命令，
            使<b>IndexSeek( )</b>找到最近创建的记录。<br/>
        </remarks>
    </indexseek>

    <inputbox>
        <summary>
            显示一个模态对话框，用于参数化视图输入单个字符串。
        </summary>
        <param name="cInputPrompt">
            指定显示在文本输入框上方的提示。
        </param>
        <param name="cDialogCaption">
            指定在对话框标题栏中显示的文本。
        </param>
        <param name="cDefaultValue">
            指定在文本输入框中显示的默认值。
        </param>
        <param name="nTimeout">
            指定超时值，以1/1000秒为单位。
            在nTimeout中指定零以防止对话框超时。这与省略nTimeout相同。
        </param>
        <param name="cTimeoutValue">
            指定发生超时时返回的值。如果nTimeout设置为零或被省略，则不返回cTimeoutValue。
        </param>
        <param name="cCancelValue">
            指定用户通过选择<b>取消</b>按钮或按Esc键退出对话框时返回的字符值。
        </param>
        <remarks>
            对话框显示一个编辑框和<b>确定</b>和<b>取消</b>按钮。
            <b>确定</b>按钮返回编辑框的内容。
            超时返回cTimeoutValue中指定的文本，如果未指定cTimeoutValue则返回空字符串。
            取消按钮或Esc键返回cCancelValue中指定的文本，如果未指定cCancelValue则返回空字符串。
             <code language="X#">
                Y = "什么都没有"
                Y = InputBox("在此输入","输入 ",Y,5000)
                &amp;&amp; 显示对话框5秒钟，
            </code>
            以下示例显示一个对话框5秒钟，并在主X#窗口中显示返回值。
            如果用户点击确定，编辑框返回文本，可能是默认值"什么都没有"，或用户指定的文本。
            如果用户点击取消或按Esc键，编辑框返回"已取消"。如果用户等待超时时间，
            编辑框关闭并返回"已超时"。
             <code language="X#">
                Clear
                Y = InputBox("在此输入:", "输入标题",  ;
                "什么都没有", 5000, '已超时', '已取消')
                ? Y
            </code>
        </remarks>
    </inputbox>

    <insmode>
        <summary>
            返回当前插入模式，或设置插入模式为开启或关闭。
        </summary>
        <param name="lSetOn">
            打开或关闭插入模式。InsMode(.T.)打开插入模式，InsMode(.F.)关闭插入模式。
        </param>
        <returns>
            返回一个逻辑值，对应于执行InsMode(.T.)或InsMode(.F.)之前的插入模式设置。
        </returns>
        <remarks>
            如果省略可选参数，且插入模式为开启状态（字符在光标前插入），
            InsMode()返回真(.T.)。如果插入模式为关闭状态（字符在插入点覆盖），
            InsMode()返回假(.F.)。
        </remarks>
        <example>
             <code language="X#">
                =InsMode(.T.)  &amp;&amp; 设置插入模式为开启
                ? InsMode()
                = InsMode(!InsMode())  &amp;&amp; 将插入模式切换到相反状态
                ? InsMode()
            </code>
        </example>
    </insmode>

    <isblank>
        <summary>
            判断表达式是否为空。
        </summary>
        <param name="eExpression">
            指定<b>IsBlank( )</b>要评估的表达式。
            eExpression可以是表中的字段、变量或数组元素，或者是一个表达式。
        </param>
        <returns>
            逻辑值。如果表达式eExpression为空，<b>IsBlank( )</b>返回真（.T.）；
            否则，<b>IsBlank( )</b>返回假（.F.）。<br/>
            当字段包含某些特定值时，<b>IsBlank( )</b>对这些字段返回真（.T.）。
            下表列出了各种数据类型字段包含什么值时<b>IsBlank( )</b>会返回真。
            <list type="table">
                <listheader>
                    <term>数据类型</term>
                    <description>字段包含的值</description>
                </listheader>
                <item>
                    <term>
                        <b>Blob</b>
                    </term>
                    <description>空（0h）或仅包含零字节，例如0h00、0h000000等</description>
                </item>
                <item>
                    <term>
                        <b>Character</b>
                    </term>
                    <description>
                        空字符串、空格或无值，如新追加的空白记录或使用<b>Blank</b>清除的记录
                    </description>
                </item>
                <item>
                    <term>
                        <b>Date</b>
                    </term>
                    <description>
                        空日期（{ / / }）或无值，如新追加的空白记录或使用<b>Blank</b>清除的记录
                    </description>
                </item>
                <item>
                    <term>
                        <b>DateTime</b>
                    </term>
                    <description>
                        空日期时间（{ / / : : }）或无值，如新追加的空白记录或使用<b>Blank</b>清除的记录
                    </description>
                </item>
                <item>
                    <term>
                        <b>Float</b>
                    </term>
                    <description>
                        无值，如新追加的空白记录或使用<b>Blank</b>清除的记录
                    </description>
                </item>
                <item>
                    <term>
                        <b>General</b>
                    </term>
                    <description>空，例如没有OLE对象</description>
                </item>
                <item>
                    <term>
                        <b>Logical</b>
                    </term>
                    <description>
                        无值，如新追加的空白记录或使用<b>Blank</b>清除的记录
                    </description>
                </item>
                <item>
                    <term>
                        <b>Memo</b>
                    </term>
                    <description>空，例如没有备忘录内容</description>
                </item>
                <item>
                    <term>
                        <b>Numeric</b>
                    </term>
                    <description>
                        无值，如新追加的空白记录或使用<b>Blank</b>清除的记录
                    </description>
                </item>
                <item>
                    <term>
                        <b>Varbinary</b>
                    </term>
                    <description>空（0h）或仅包含零字节，例如0h00、0h000000等</description>
                </item>
            </list>
            <note name="注意">
                <b>Currency</b>、<b>Integer</b>或<b>Double</b>类型的表达式永远不会为空；
                因此，对于这些表达式类型，<b>IsBlank( )</b>始终返回假（.F.）。
            </note>
        </returns>
        <remarks>
            要创建空白记录，请使用<b>Append Blank</b>和<b>Blank</b>命令。
            您还可以使用<b>Blank</b>清除记录中字段的数据。<br/>
            <b>IsBlank( )</b>与<b>Empty( )</b>和<b>IsNull( )</b>不同。
            例如，如果字符表达式求值为空（即包含空格、制表符、回车符或换行符），<b>Empty( )</b>返回真（.T.）。
            而<b>IsBlank( )</b>仅在字符表达式只包含空字符串（""）或空格时返回真（.T.）。
        </remarks>
        <example>
             <code language="X#">
                Create Table mytable FREE (myfield C(20))
                Append Blank  &amp;&amp; 添加新的空白记录
                Clear
                ? ISBlank(myfield)  &amp;&amp; 显示 .T.
                Replace myfield WITH 'John Smith'  &amp;&amp; 在字段中插入一个值
                ? ISBlank(myfield)  &amp;&amp; 显示 .F.
            </code>
        </example>
    </isblank>

    <isexclusive>
        <summary>
            如果表或数据库以独占方式打开，则返回真（.T.）；否则返回假（.F.）。
        </summary>
        <param name="uArea">
            指定要返回独占使用状态的表的别名。
            如果指定的表别名不存在，X# 会生成错误消息。<br/>
            或<br/>
            指定要返回独占使用状态的表的工作区。
            如果您指定的工作区中没有打开的表，IsExclusive( ) 返回假（.F.）。<br/>
            或<br/>
            指定要返回独占使用状态的数据库的名称。
        </param>
        <param name="nType">
            指定是返回表还是数据库的独占状态。
            remarks 部分的表列出了 nType 的值及其对应的返回状态。<br/>
            要确定数据库的独占状态，必须包含 nType 并将其值设为 2。
        </param>
        <returns>
            逻辑值
        </returns>
        <remarks>
            如果省略可选的 uArea 或 cDatabaseName 参数，IsExclusive( ) 将返回当前选定工作区中打开的表的值。<br/>
            通过在 Use 中包含 Exclusive 关键字，或在打开表之前将 Set Exclusive 设置为 On，可以以独占方式打开表。<br/>
            通过在 Open Database 中包含 Exclusive 关键字，可以以独占方式打开数据库。
            <list type="table">
                <listheader>
                    <term>nType</term>
                    <description>返回的独占状态</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>表</description>
                </item>
                <item>
                    <term>2</term>
                    <description>数据库</description>
                </item>
            </list>
        </remarks>
        <example>
             <code language="X#">
                cExclusive = Set('Exclusive')
                Set Exclusive Off
                Set Path To (Home(2) + 'data\')
                Open Data testdata  &amp;&amp; 打开测试数据库
                Use customer     &amp;&amp; 非独占方式打开
                Use employee IN 0 Exclusive    &amp;&amp; 在另一个工作区以独占方式打开
                IF IsExclusive( )
                REIndex  &amp;&amp; 只有在表以独占方式打开时才能执行
                ELSE
                WAIT '表必须以独占方式打开'
                ENDIF
                Set Exclusive &amp;cExclusive
            </code>
        </example>
    </isexclusive>

    <ismemofetched>
        <summary>
            确定在延迟备注获取期间是否已获取备注字段。
        </summary>
        <param name="uField">
            指定要返回获取状态的备注字段的名称。<br/>
            或<br/>
            指定要返回获取状态的备注字段的字段编号（基于表或游标的物理结构）。
        </param>
        <param name="uArea">
            指定包含要返回获取状态的备注字段的表或游标的工作区。<br/>
            或<br/>
            指定包含要返回获取状态的备注字段的表或游标的别名。
        </param>
        <returns>
            逻辑值。如果指定的备注字段已被获取，则返回逻辑真（.T.），否则返回逻辑假（.F.）。
            对于本地数据，始终返回真（.T.）。如果记录指针位于游标的开头或结尾，则对游标返回空值（.NULL.）。
            使用BOF()函数和EOF()函数来确定记录指针是否位于游标的开头或结尾。
        </returns>
        <remarks>
            对于远程数据，获取备注字段通常需要一段时间，因此您可能选择在绝对需要时才下载备注字段。
            DbGetProp()函数和CursorGetProp()函数中的FetchMemo设置决定是否随视图结果一起检索备注字段或按需检索。
            对于延迟的备注数据（FetchMemo=.F.），当获取备注字段时，IsMemoFetched()返回真（.T.）。<br/>
            IsMemoFetched()适用于备注字段和通用字段。
        </remarks>
    </ismemofetched>

    <isnull>
        <summary>
            如果表达式计算结果为空值，则返回真（.T.）；否则，IsNull()返回假（.F.）。
        </summary>
        <param name="eExpression">
            指定要评估的表达式。
        </param>
        <returns>逻辑值</returns>
        <remarks>
            使用IsNull()来确定字段、内存变量或数组元素的内容是否包含空值，
            或表达式是否计算为空值。
        </remarks>
        <example>
             <code language="X#">
                Store .NULL. To mNullvalue  &amp;&amp; 将空值存储到内存变量
                Clear
                ? mNullvalue  &amp;&amp; 显示内存变量的值
                ? IsNull(mNullvalue)  &amp;&amp; 返回.T.，表示空值
                ? TYPE('mNullvalue')     &amp;&amp; 返回L，表示逻辑值
                ? (mNullvalue = .NULL.)  &amp;&amp; 返回.NULL.，不是检测空值的好方法
            </code>
        </example>
    </isnull>

    <ispen>
        <summary>
            确定最后一次Tablet PC鼠标事件是否为笔点击。
        </summary>
        <remarks>
            如果最后一次Tablet PC鼠标事件是笔点击，IsPen()函数返回逻辑真（.T.）。
            如果最后一次鼠标事件不是笔点击，则返回逻辑假（.F.）。
        </remarks>
    </ispen>

    <istransactable>
        <summary>
            返回一个逻辑值，指示自由表或自由游标是否支持事务。
        </summary>
        <param name="uArea">
            指定IsTrancsactable()用于确定是否支持事务的自由表或自由游标的工作区。<br/>
            或<br/>
            指定IsTrancsactable()用于确定是否支持事务的表或游标的别名。
        </param>
        <returns>
            逻辑值。如果自由表或自由游标支持事务，则返回逻辑真（.T.），
            否则返回逻辑假（.F.）。
        </returns>
        <remarks>
            使用MakeTrancsactable()函数使自由表或自由游标支持事务。
        </remarks>
    </istransactable>

    <isupper>
        <summary>
            确定字符表达式中的第一个字符是否为大写字母。
        </summary>
        <param name="cExpression">
            指定IsUpper()评估的字符表达式。
            cExpression中第一个字符之后的任何字符都将被忽略。
        </param>
        <returns>
            逻辑值
        </returns>
        <remarks>
            如果字符表达式中的第一个字符是大写字母，IsUpper()返回真（.T.）；
            否则，IsUpper()返回假（.F.）。
        </remarks>
        <example>
             <code language="X#">
                ? IsUpper('Redmond')  &amp;&amp; 显示 .T.
                ? IsUpper('redmond')  &amp;&amp; 显示 .F.
            </code>
        </example>
    </isupper>

    <keymatch>
        <summary>
            在索引标记或索引文件中搜索索引键。
        </summary>
        <param name="eIndexKey">
            指定KeyMatch()搜索的索引键。索引文件或索引标记中的索引键由索引表达式确定。
            使用Index创建索引文件或索引标记时指定索引表达式。
            可以使用KEY()和SYS(14)返回索引文件和索引标记的索引表达式。
            有关创建索引文件、索引表达式和索引键的更多信息，请参见Index。<br/>
            如果不包含任何可选参数，KeyMatch()将在主索引文件或主索引标记中搜索您指定的索引键。
            如果没有生效的主索引文件或索引标记（例如，您已发出不带任何参数的Set Order To以将表置于物理记录顺序），X#将生成错误消息。<br/>
        </param>
        <param name="nIndexNumber">
            指定搜索哪个索引文件或索引标记。
            nIndexNumber通常是从1开始的整数，每增加1就搜索额外的索引标记。<br/>
            如果nIndexNumber为1，则搜索主单条目.idx索引文件或主索引标记（如果存在）。<br/>
            随着nIndexNumber增加，会搜索结构复合索引（如果存在）中的后续标记。
            搜索标记的顺序与在结构复合索引中创建标记的顺序相同。<br/>
            随着nIndexNumber继续增加并且结构复合索引中的所有标记都已搜索完毕，
            然后搜索任何打开的独立复合索引中的标记。
            搜索标记的顺序与在独立复合索引中创建标记的顺序相同。<br/>
            如果nIndexNumber大于打开的单条目.idx文件以及结构复合和独立复合索引标记的总数，则会生成错误消息。
        </param>
        <param name="uArea">
            搜索在另一个工作区中打开的索引文件或标记。
            uArea指定工作区编号或表别名。
            如果省略工作区和别名，KeyMatch()将搜索当前工作区中表的打开索引文件或标记。<br/>
            如果没有表具有您指定的别名，X#将生成错误消息。
        </param>
        <returns>
            逻辑值
        </returns>
        <remarks>
            KeyMatch()在索引标记或索引文件中搜索特定的索引键，如果找到索引键则返回真（.T.）；
            否则，KeyMatch()返回假（.F.）。KeyMatch()可用于防止重复的索引键。<br/>
            KeyMatch()将记录指针返回到发出KeyMatch()之前最初所在的记录位置。
        </remarks>
    </keymatch>
    
    <lineno>
        <summary>
            返回程序中正在执行的行号，相对于主程序的第一行。
        </summary>
        <param name="nPos">
            返回相对于当前程序或过程第一行的行号。如果省略参数1，
            则返回相对于主程序第一行的行号。
        </param>
        <returns>
            数值
        </returns>
        <remarks>
            程序行从程序顶部开始计数。注释行、续行和空白行都包含在行号计数中。
            如果程序在执行过程中暂停，LineNo()返回程序暂停时的程序行号。
            如果程序被取消，LineNo()返回0。<br/>
            默认情况下，行号相对于主程序的开始返回。如果调用了一个过程，
            行号从调用程序的顶部继续计数。<br/>
            LineNo()对于调试程序很有用。您可以通过打开断点窗口，
            将类型设置为"当表达式为真时中断"，并在表达式文本框中添加
            <code>LineNo() = n</code>来设置断点，以在特定行号停止程序执行。
        </remarks>
        <example>
             <code language="X#">
                On ERROR DO bug_proc WITH LineNo()
                BRWS  &amp;&amp; 引发错误
                On ERROR
                *** Bug_Proc 错误处理程序 ***
                PROCEDURE bug_proc
                PARAMETERS gnBadLine
                WAIT '错误发生在行: ' + ALLTRIM(STR(gnBadLine))
                RETURN
            </code>
        </example>
    </lineno>

    <loadpicture>
        <summary>
            创建位图、图标或Windows元文件的对象引用。
        </summary>
        <param name="cFileName">
            指定要为其创建对象的磁盘上的图像文件。<br/>
            支持的图像类型列在备注部分
        </param>
        <returns>
            Object
            <b>LoadPicture() 函数</b>返回一个<b>Picture类型的COM对象引用</b>，可以分配给ActiveX控件和VFP的Image对象的<b>PictureVal属性</b>。
            然而，真正的主要接口<b>iPicture</b>只能使用如下代码检索：<br/>
            &amp;nbsp;
            <code language="X#">oIPicture = GETINTERFACE(LoadPicture(GetPict()), "iPicture")</code>
        </returns>
        <remarks>
            <b>支持的图像类型</b>
            <list type="table">
                <listheader>
                    <term>图像类型组</term>
                    <description>文件扩展名</description>
                </listheader>
                <item>
                    <term>位图</term>
                    <description>.bmp, .jpg, .jpeg, .jpe, .jfif, .gif, .giff, .gfa</description>
                </item>
                <item>
                    <term>图标</term>
                    <description>.ico</description>
                </item>
                <item>
                    <term>Windows元文件</term>
                    <description>.wmf</description>
                </item>
                <item>
                    <term>Windows增强型元文件</term>
                    <description>.emf</description>
                </item>
                <item>
                    <term>光标</term>
                    <description>.cur</description>
                </item>
            </list>
            以下限制（在VFP 9 SP2和OlePro32.dll版本6.0.6002.18005上测试）存在：<br/>
            <b>已知限制</b>
            <list type="table">
                <listheader>
                    <term>图像类型组</term>
                    <description>限制和问题</description>
                </listheader>
                <item>
                    <term>位图</term>
                    <description>
                        加载<b>.tif</b>和<b>.png</b>格式会导致OLE错误。
                    </description>
                </item>
                <item>
                    <term>图标</term>
                    <description>
                        允许的图标大小最大为128x128，且颜色不得超过256色。即使图标文件中存储了多个图标，
                        始终只显示最小的图标。图标文件可以包含更多的图标 - 甚至可以有更多颜色和更大尺寸 - 只要其中至少有
                        一个符合上述规则，就不会抛出异常。
                    </description>
                </item>
                <item>
                    <term>光标</term>
                    <description>
                        光标文件的大小不得超过1K，否则会产生OLE错误。包含16色光标的光标文件可以完美加载，
                        但只支持单色输出。加载动画光标（.ani）会引发OLE错误。
                    </description>
                </item>
            </list>
            <b>空图片支持</b>
            如果省略cFileName，则返回"空图片"。
            您可以将GetPict()作为cFileName包含在内，以显示"打开"对话框，从中可以选择位图文件。<br/><br/>
            Picture对象为位图、图标和元文件提供了一个与语言无关的抽象。
            与标准字体对象一样，系统提供了Picture对象的标准实现。
            它的主要接口是<b>iPicture</b>和<b>iPictureDisp</b>。
            Picture对象是通过<b>OleCreatePictureIndirect</b>创建的，并支持<b>iPicture</b>和<b>iPictureDisp</b>接口。
            OLE提供的Picture对象实现了<b>iPicture</b>和<b>iPictureDisp</b>接口的完整语义。
            换句话说，除了<b>iPicture</b>之外，没有必要使用其他接口！<br/>
            <b>LoadPicture() 函数</b>在内部封装了<b>OleAut32.dll</b>中实现的<b>OleCreatePictureIndirect() 函数</b>。
            因此，您可以在网上读到的关于该函数的所有内容（上述和在线内容）也适用于VFP的<b>LoadPicture() 函数</b>。
            <b>LoadPicture() 函数</b>被添加到VFP的词汇表中，以便更容易加载具有COM接口的图像，
            许多ActiveX控件的表现属性需要这些COM接口来设置。<br/>
            例如，ActiveX Outline控件有一个<b>PictureOpen属性</b>，需要COM对象图像引用来设置。
            <b>LoadPicture() 函数</b>返回的COM对象隐藏了其主要接口<b>iPicture</b>。
            与<b>LoadPicture() 函数</b>返回的引用相比，OLE图像的主要<b>iPicture</b>接口是唯一完全功能的接口。
            换句话说，只有<b>iPicture</b>可以在VFP程序中使用而不会产生任何OLE错误。
            因为<b>iPicture</b>是Picture的超集，所以可能更好，它应该在任何地方使用，而不是使用<b>LoadPicture() 函数</b>返回的接口！<br/>
            下面示例部分中的示例#1证明了将哪个OLE图像接口分配给<b>oIMAGE.PICTUREVAL属性</b>并没有区别。
            <b>iPicture</b>接口的IID定义为"{7BF80980-BF32-101A-8BBB-00AA00300CAB}"。 <br/>
            <br/>
            以下两行代码都创建了一个空图片OLE图像对象：
            <code language="X#">
                oIPicture1 = GETINTERFACE(LoadPicture(), "iPicture")
                oIPicture2 = CreateObjectEx("StdPicture","","{7BF80980-BF32-101A-8BBB-00AA00300CAB}")
            </code>
            <b>接口成员</b>
            下表总结了<b>iPicture</b>接口的PEM。<br/>
            <b>iPicture 接口成员</b>
            <list type="table">
                <listheader>
                    <term>PEM</term>
                    <description>名称</description>
                    <description>用途</description>
                    <description>值类型</description>
                    <description>读/写</description>
                </listheader>
                <item>
                    <term>属性</term>
                    <description>Attributes</description>
                    <description>图片当前的位属性集。</description>
                    <description>DWORD (int)</description>
                    <description>只读</description>
                </item>
                <item>
                    <term>属性</term>
                    <description>CurDC</description>
                    <description>此图片当前选入的设备上下文。</description>
                    <description>HDC (long)</description>
                    <description>只读</description>
                </item>
                <item>
                    <term>属性</term>
                    <description>Handle</description>
                    <description>此图片对象管理的图片句柄。</description>
                    <description>OLE_Handle (int)</description>
                    <description>只读</description>
                </item>
                <item>
                    <term>属性</term>
                    <description>Height</description>
                    <description>图片对象中图片的当前高度。</description>
                    <description>OLE_XSIZE_HIMETRIC (long)</description>
                    <description>只读</description>
                </item>
                <item>
                    <term>属性</term>
                    <description>hPal</description>
                    <description>图片的当前调色板（如果有）。</description>
                    <description>OLE_Handle (int)</description>
                    <description>读/写</description>
                </item>
                <item>
                    <term>属性</term>
                    <description>KeepOriginalFormat</description>
                    <description>图片对象的KeepOriginalFormat属性的当前值。</description>
                    <description>Bool</description>
                    <description>读/写</description>
                </item>
                <item>
                    <term>属性</term>
                    <description>Type</description>
                    <description>图片的当前类型。</description>
                    <description>Short (int)</description>
                    <description>只读</description>
                </item>
                <item>
                    <term>属性</term>
                    <description>Width</description>
                    <description>图片对象中图片的当前宽度。</description>
                    <description>OLE_XSIZE_HIMETRIC (long)</description>
                    <description>只读</description>
                </item>
                <item>
                    <term>方法</term>
                    <description>PictureChanged()</description>
                    <description>通知图片对象其图片资源已更改。</description>
                </item>
                <item>
                    <term>方法</term>
                    <description>Render()</description>
                    <description>在指定的设备上下文上绘制图片的指定部分，定位在指定位置。</description>
                </item>
                <item>
                    <term>方法</term>
                    <description>SaveAsFile()</description>
                    <description>以与保存到文件相同的格式将图片数据保存到流中。</description>
                </item>
                <item>
                    <term>方法</term>
                    <description>SelectPicture()</description>
                    <description>
                        将位图图片选入给定的设备上下文，返回图片先前选入的设备上下文
                        以及图片的句柄。
                    </description>
                </item>
            </list>
            <b>Attributes属性</b>据说保存了图片的位属性。实际上，只有两个可以单独设置或叠加的值。
            下表列出了两个可能的值：<br/>
            <b>iPicture.Attributes 枚举</b>
            <list type="table">
                <listheader>
                    <term>常量</term>
                    <descripiton>描述</descripiton>
                    <description>值</description>
                </listheader>
                <item>
                    <term>PICTURE_SCALABLE</term>
                    <description>
                        图片对象是可缩放的，这意味着它可以以与最初创建图片时不同的大小重新绘制。
                        基于元文件的图片被认为是可缩放的；图标和位图图片虽然可以缩放，但不表达此属性，因为两者都涉及位图
                        拉伸而不是真正的缩放。
                    </description>
                    <description>1</description>
                </item>
                <item>
                    <term>PICTURE_TRANSPARENT</term>
                    <description>
                        图片对象包含具有透明区域的图像，因此绘制图片不一定会填充其占据的矩形中的所有空间。
                        元文件和图标图片具有此属性；位图图片没有。
                    </description>
                    <description>2</description>
                </item>
            </list>
            下表列出了<b>iPicture.Type属性</b>的所有可能值：
            <list type="table">
                <listheader>
                    <term>常量</term>
                    <descripiton>描述</descripiton>
                    <description>值</description>
                </listheader>
                <item>
                    <term>PICTYPE_UNINITIALIZED</term>
                    <description>图片对象当前未初始化。此值在VFP中永远不会返回。</description>
                    <description>-1</description>
                </item>
                <item>
                    <term>PICTYPE_NONE</term>
                    <description>要创建一个没有初始化状态的新图片对象。如果使用不带参数的LoadPicture()，VFP会返回此值。</description>
                    <description>0</description>
                </item>
                <item>
                    <term>PICTYPE_BITMAP</term>
                    <description>图片类型是位图。</description>
                    <description>1</description>
                </item>
                <item>
                    <term>PICTYPE_METAFILE</term>
                    <description>图片类型是元文件。</description>
                    <description>2</description>
                </item>
                <item>
                    <term>PICTYPE_ICON</term>
                    <description>图片类型是图标。</description>
                    <description>3</description>
                </item>
                <item>
                    <term>PICTYPE_ENHMETAFILE</term>
                    <description>图片类型是增强型元文件。</description>
                    <description>4</description>
                </item>
            </list>
            COM图像对象的<b>iPicture接口</b>最有趣的方法是<b>render()</b>，它只有在调用<b>iPicture接口</b>时才能完美工作。
            下表总结了<b>render()方法</b>的参数：
            <list type="table">
                <listheader>
                    <term>参数</term>
                    <descripiton>用途</descripiton>
                    <description>比例单位</description>
                </listheader>
                <item>
                    <term>hdc</term>
                    <description>要在其上渲染图像的设备上下文的句柄。</description>
                </item>
                <item>
                    <term>x</term>
                    <description>在 hdc 中放置渲染图像的水平坐标（输出矩形左上角的 X 位置）。</description>
                    <description>像素</description>
                </item>
                <item>
                    <term>y</term>
                    <description>在 hdc 中放置渲染图像的垂直坐标（输出矩形左上角的 Y 位置）。</description>
                    <description>像素</description>
                </item>
                <item>
                    <term>cx</term>
                    <description>目标矩形的水平尺寸（输出矩形的宽度）。</description>
                    <description>像素</description>
                </item>
                <item>
                    <term>cy</term>
                    <description>目标矩形的垂直尺寸（输出矩形的高度）。</description>
                    <description>像素</description>
                </item>
                <item>
                    <term>xSrc</term>
                    <description>源图片中开始复制的水平偏移量。</description>
                    <description>HiMetric</description>
                </item>
                <item>
                    <term>ySrc</term>
                    <description>源图片中开始复制的垂直偏移量。</description>
                    <description>HiMetric</description>
                </item>
                <item>
                    <term>cxSrc</term>
                    <description>从源图片复制的水平范围（图像源裁剪区域的宽度和读取方向）。</description>
                    <description>HiMetric</description>
                </item>
                <item>
                    <term>cySrc</term>
                    <description>从源图片复制的垂直范围（图像源裁剪区域的高度和读取方向）。</description>
                    <description>HiMetric</description>
                </item>
                <item>
                    <term>lprcWBounds</term>
                    <description>
                        如果 hdc 是元文件设备上下文，lprcWBounds 参数指向一个 RECTL 结构，指定底层元文件中的边界矩形。
                        该矩形结构包含窗口范围和窗口原点。这些值对绘制元文件很有用。
                        lprcBounds 指示的矩形嵌套在这个 lprcWBounds 矩形内；它们在同一坐标空间中。
                        如果 hdcDraw 不是元文件设备上下文，lprcWBounds 将为 NULL。如果 hdcDraw 是元文件设备上下文，lprcWBounds 不能为 NULL！
                    </description>
                </item>
            </list>
            该方法返回标准值，如 E_FAIL、E_INVALIDARG 和 E_OUToFMEMORY，以及 S_OK、E_POINTER 和 CTL_E_INVALIDPROPERTYVALUE。
            这些值在 MSDN 上有描述。
            <b>应用</b>
            render 函数有很多参数。其中一些传递像素值，其他传递 HiMetric 值。<br/>
            <b>示例 #3</b> 包含一些有用的转换以及其他支持函数和定义。<br/>
            要了解 <b>render()</b> 如何工作，请尝试以下 VFP 代码；将其逐行输入到 VFP 的命令窗口中：<br/>
            直接输入到 VFP 的命令窗口
            <code language="X#">
                * 定位一个大约 100 x 100 像素的图像
                goPic = LoadPicture(GetPict())
                gIP = GETINTERFACE(m.goPic, "iPicture")
                goForm = CreateObject("Form")
                goForm.Show()
                * 声明访问窗口的_客户区域_
                DECLARE Integer GetDC IN User32 integer HWnd
                * hDC 应该为 0（否则就是错误）！
                hDC = GetDC(goForm.HWnd)
                * 直接在表单的客户区域上渲染图像
                gIP.Render(m.hDC,0,0,100,100,0,gIP.Height,gIP.Width,- gIP.Height,NULL)
                * 声明释放函数
                DECLARE Integer ReleaseDC IN User32 integer HWnd, integer hDC
                * 下一行应该在表单的背景上打印 1 >> "Okay"
                ? ReleaseDC(m.goForm.HWnd, m.hDC)
                * 声明访问_整个_窗口
                DECLARE Integer GetWindowDC IN User32 integer HWnd
                * hDC 现在也引用表单的标题和边框区域！
                hDC = GetWindowDC(goForm.HWnd)
                * 渲染部分覆盖表单的边框和标题
                gIP.Render(m.hDC,0,0,100,100,0,gIP.Height,gIP.Width,- gIP.Height,NULL)
                * 永远不要忘记释放分配的设备上下文
                ? ReleaseDC(m.goForm.HWnd, m.hDC)
            </code>
            <b>iPicture.Render()</b> 适用于在其他不可访问的表单区域（如标题栏或窗口边框）上绘画。
            直接渲染的另一个有趣应用源于不需要 VFP 对象引用就可以进行绘画的事实。
            <b>render() 方法</b>仅使用通用的 Windows 句柄。因此，可以在任何已知的设备上下文上进行渲染。<br/>
            如果遇到所谓的沙漏问题，使用基于 COM 的图像可能是首选的解决方法。
            操作系统在长时间的磁盘访问期间显示沙漏鼠标光标。
            有时 VFP 不能正确重置沙漏鼠标光标。
            因此，用户仍然看到"忙碌工作"图标，尽管 VFP 已经空闲，只要她不触摸鼠标。
            这些磁盘访问最常见的原因是刷新使用 <b>Image.Picture 属性</b>加载到本机 Image-Objects 中的图片。
            相反，将 COM 内存基础对象存储到 Image-Object 的 <b>.PictureVal 属性</b>中，永远不会导致任何磁盘访问。
            因此，刷新后不会再出现沙漏鼠标光标！
            <b>缺点</b>
            <b>iPicture.Render()</b> 在 VFP 引擎之外执行其工作，并且不被 VFP 引擎注意到。
            这就是为什么 VFP 不知道在"行间"绘制了什么。
            每次 VFP 刷新我们刚刚渲染图片的表单区域时，都会清除我们的图像。
            要使渲染输出持久化，必须采取措施防止 VFP 将其清除！
            使用上述沙漏问题解决方法时，还需要注意另一个 BUG！<br/>
            要看看会发生什么，请尝试以下代码：

            <code language="X#">
                LOCAL lnLoop, oComPic1, oComPic2
                oComPic1 = LoadPicture(GetFile())
                oComPic2 = LoadPicture(GetFile())
                TRY
                _Screen.Addobject("oImage","IMAGE")
                CATCH
                FINALLY
                _Screen.oImage.Visible = .T.
                ENDTRY
                For lnLoop = 1 to 100
                _Screen.oImage.PictureVal = m.oComPic1
                _Screen.oImage.PictureVal = m.oComPic2
                Next
                *//
                *\\ 而下一个循环会在某个地方中断：
                For lnLoop = 1 to 100
                _Screen.oImage.PictureVal = m.oComPic1
                _Screen.oImage.PictureVal = m.oComPic1
                _Screen.oImage.PictureVal = m.oComPic1
                _Screen.oImage.PictureVal = m.oComPic2
                Next
            </code>
            可以看到，第一个循环完美执行，而第二个循环在仅几次循环后就会中断，并显示"属性值无效"的错误消息！
            这个 bug 很难追踪，只有在有人试图连续多次分配相同的 COM 引用时才会发生！
            解决这个问题的方法是跟踪实际分配给 Image 的 PictureVal 属性的 COM 引用。
            然后永远不要第二次重新分配相同的引用（用自身的副本覆盖第一个）！
            顺便说一下：你使用哪个接口并不重要。
            错误似乎源于 VFP 的 Image 类实例。
        </remarks>
        <example>
            以下示例显示 COM 图像实例的两个接口（<b>Picture</b> 和 <b>IPicture</b>）
            都可以分配给 VFP 的 <b>Image.PictureVal 属性</b>：
            <code language="X#">
                PUBLIC goPic AS Object, goIPic AS Object
                goPic = LoadPicture(GetPict())
                goIPic = GETINTERFACE(m.goPic, "iPicture")
                _SCREEN.AddObject("oPic1","IMAGE")
                _SCREEN.AddObject("oPic2","IMAGE")
                WITH _SCREEN.oPic1
                .VISIBLE = .T.
                .PICTUREVAL = m.goPic &amp;&amp; "Picture" 接口
                ENDWITH
                WITH _SCREEN.oPic2
                .LEFT = 110
                .VISIBLE = .T.
                .PICTUREVAL = m.goIPic &amp;&amp; "IPicture" 接口
                ENDWITH
                HIDE WINDOWS ALL
                WAIT "按任意键..."
                _SCREEN.RemoveObject("oPic1")
                _SCREEN.RemoveObject("oPic2")
                STORE NULL TO goPic, goIPic
                Clear
                SHOW WINDOWS ALL
            </code>
            以下示例展示了如何查询 COM 图像实例的 <b>iPicture 接口</b>。
            有意地，这个演示代码中没有 Try…Catch…Endtry 部分，所以可能会发生 OLE 错误。
            你需要用不同的图像类型多次运行这个代码片段才能看到它们。
            <code language="X#">
                goPic = LoadPicture(GetPict())
                IF VARTYPE(m.goPic) == "O"
                goIPic = GETINTERFACE(m.goPic, "iPicture")
                IF VARTYPE(m.goIPic) == "O"
                Clear &amp;&amp; 只是一些信息输出：
                WITH m.goIPic
                ?
                ? "'IPicture' 接口的属性："
                ? "Attributes"		,.Attributes
                *\\ 如果加载的是图标，下一行将失败
                ? "CurDC"	,.CurDC
                ? "Handle"	,.Handle
                ? "Height"	,.Height
                *\\ 如果加载的是图标，下一行将失败
                ? "hPal"	,.hPal
                ? "KeepOriginalFormat",.KeepOriginalFormat
                ? "Type"	,.Type
                ? "Width"	,.Width
                ?
                ENDWITH
                ENDIF
                ENDIF
            </code>
            以下代码是在编程 OLE 图像对象时很有用的支持函数和声明的集合。
            <code language="X#">
                * 支持函数和定义
                #DEFINE INCH2MILLIMETER 25.4 &amp;&amp; 1英寸 = 25.4毫米
                #DEFINE INCH2HIMETRICS (INCH2MILLIMETER * 100) &amp;&amp; 1 HIMETRIC = 0.01毫米

                FUNCTION PXL2HIME(tnPixel AS Integer) AS Integer
                    * 像素到HiMetric转换
                    LOCAL lnPixelsOnOneHiMetricUnit AS Integer
                    lnPixelsOnOneHiMetricUnit = INCH2HIMETRICS / GetDPI()
                    RETURN ROUND(lnPixelsOnOneHiMetricUnit * m.tnPixel, 0)
                ENDFUNC

                FUNCTION HIME2PXL(tnHimetric AS Integer) AS Integer
                    * HiMetric到像素转换
                    LOCAL lnPixelsOnOneHiMetricUnit AS Integer
                    lnPixelsOnOneHiMetricUnit = INCH2HIMETRICS / GetDPI()
                    RETURN ROUND(m.tnHimetric / m.lnPixelsOnOneHiMetricUnit, 0)
                ENDFUNC

                FUNCTION GetDPI(tnHDC AS Integer) AS Integer
                    * 获取每英寸点数分辨率
                    * 针对VFP的_SCREEN设备上下文
                    DECLARE Integer GetDeviceCaps IN GDI32 integer hdc, integer nIndex
                    DECLARE Integer GetWindowDC IN User32 integer HWnd
                    DECLARE Integer ReleaseDC IN User32 integer HWnd, integer hDC
                    * 为简单起见，我们假设X和Y维度
                    * 使用相同的DPI分辨率。
                    #DEFINE LOGPIXELSX 88 &amp;&amp; X方向的逻辑像素/英寸
                    #DEFINE LOGPIXELSY 90 &amp;&amp; Y方向的逻辑像素/英寸
                    * 获取VFP的_Screen-hDC以计算分辨率：
                    LOCAL lhDC AS Integer, lnDPI AS Integer
                    STORE 0 TO lhDC, lnDPI
                    lhDC = GetWindowDC(_Screen.HWnd)

                    IF NOT m.lhDC = 0
                        lnDPI = GetDeviceCaps(m.lhDC, LOGPIXELSX)
                    ELSE
                        lnDPI = 96 &amp;&amp; 默认为96 DPI
                    ENDIF

                    * 释放设备上下文
                    = ReleaseDC(_Screen.HWnd, m.lhDC)
                    RETURN m.lnDPI
                ENDFUNC

                FUNCTION GetCanvas(tnHWND AS Integer, tlChild AS Boolean) AS Integer
                    * 获取窗口句柄的hDC（设备上下文句柄）
                    * tlChild = TRUE  := 使用GetDC()
                    * tlChild = FALSE := 使用GetWindowDC()
                    DECLARE Integer GetDC IN User32 integer HWnd
                    DECLARE Integer GetWindowDC IN User32 integer HWnd
                    LOCAL lnHDC AS Integer

                    IF m.tlChild
                        lnHDC = GetDC(m.tnHWND)
                    ELSE
                        lnHDC = GetWindowDC(m.tnHWND)
                    ENDIF

                    RETURN m.lnHDC
                ENDFUNC

                FUNCTION ReleaseCanvas(tnHWND AS Integer, tnHDC AS Integer) AS Integer
                    * 释放借用的hDC
                    DECLARE Integer ReleaseDC IN User32 integer HWnd, integer hDC
                    RETURN ReleaseDC(m.tnHWND, m.tnHDC)
                ENDFUNC

                * 以下函数对于带滚动条的表单（oForm.Scrollbars > 0）不完全可靠
                FUNCTION GetChildAreaCanvas(tnhWnd AS Integer) AS Integer
                    * VFP的'顶级表单'（oForm.ShowWindow = 2）
                    * 在外部窗口内部有一个次级窗口。
                    * 这对于显示滚动条的表单也是如此！
                    LOCAL lnVfpHANDLE AS Integer, lnClienthWnd AS Integer, lnHDC AS Integer
                    * 将给定的Windows hWnd转换为内部VFP WHANDLE
                    lnVfpHANDLE = SYS(2326, m.tnhWnd)
                    * 获取指定X#父窗口的客户端窗口
                    * (WCLIENTWINDOW)的Windows hWnd
                    lnClienthWnd = SYS(2325, m.lnVfpHANDLE)

                    * 检查是否存在WCLIENTWINDOW
                    IF lnClienthWnd = lnVfpHANDLE
                        * 没有WCLIENTWINDOW，返回子窗口的客户区
                        lnHDC = GetCanvas(m.tnhWnd, .T.)
                    ELSE
                        * 存在WCLIENTWINDOW！
                        * 获取该窗口整个客户区的设备上下文句柄：
                        lnHDC = GetCanvas(lnClienthWnd)
                    ENDIF

                    RETURN m.lnHDC
                ENDFUNC
            </code>
        </example>
    </loadpicture>

    <locfile>
        <summary>
            在磁盘上定位文件并返回带路径的文件名。
        </summary>
        <param name="cFileName">
            指定要定位的文件名。如果cFileName只包含文件名，LocFile()首先在X#默认目录或文件夹中搜索。
            如果在默认目录或文件夹中未找到文件，则搜索X#路径。使用Set PATH指定X#路径。<br/>
            如果cFileName包含路径和文件名，则搜索指定位置。如果在指定位置找不到文件，
            LocFile()会搜索X#默认目录或文件夹，然后搜索X#路径。<br/>
            如果找到文件，LocFile()返回文件名和路径。
        </param>
        <param name="cFileExtensions">
            指定要定位的文件扩展名。如果用cFileName指定的文件名不包含扩展名，
            X#将cFileExtensions中列出的文件扩展名应用于文件名并再次搜索文件。<br/>
            当无法找到指定文件时，cFileExtensions还指定在"打开"对话框中显示的文件名扩展名。<br/>
            cFileExtensions可以采用多种形式：
            <list type="bullet">
                <item>如果cFileExtensions包含单个扩展名（例如PRG），则只显示具有该扩展名的文件。</item>
                <item>
                    cFileExtensions还可以包含通配符（*和?）。将显示所有扩展名符合通配符条件的文件。
                    例如，如果cFileExtensions是?X?，则会显示所有扩展名为.fxp、.exe和.txt的文件。
                </item>
                <item>
                    在Windows版X#中，cFileExtensions可以包含文件描述，后跟文件扩展名或用逗号分隔的文件扩展名列表。
                    文件描述显示在"文件类型"列表框中。用冒号（:）分隔文件描述和文件扩展名或文件扩展名列表。
                    用分号（;）分隔多个文件描述及其文件扩展名。
                </item>
            </list>
            例如，如果cFileExtensions为"Text:TXT"，则"文件类型"列表框中会显示文件描述"Text"，
            并显示所有扩展名为.txt的文件。<br/>
            如果cFileExtensions为"Tables:DBF; Files:TXT,BAK"，则"文件类型"列表框中会显示文件描述"Tables"和"Files"。
            从"文件类型"列表框中选择"Tables"时，将显示所有扩展名为.dbf的文件。
            从"文件类型"列表框中选择"Files"时，将显示所有扩展名为.txt和.bak的文件。
        </param>
        <param name="cFileNameCaption">
            指定用于提示用户的文本。该文本显示在输入文件名的文本框左侧。
            如果省略，则显示"文件名："。<br/>
            有关X#文件扩展名和对应的创建者类型列表，请参阅"文件扩展名和文件类型"在线主题。
        </param>
        <returns>
            字符型
        </returns>
        <remarks>
            如果在默认目录或文件夹、X#路径或指定位置中找不到文件，则显示"打开"对话框。
            可以使用"打开"对话框定位文件。从"打开"对话框中选择文件时，
            返回带文件路径的文件名。<br/>
            如果通过选择"取消"、按Esc键或从控制菜单中选择"关闭"来退出"打开"对话框，
            X#会生成错误消息，并且LocFile()不返回值。
        </remarks>
    </locfile>

    <lock>
        <summary>
            尝试锁定表中的一个或多个记录。
        </summary>
        <param name="cRecordNumberList">
            指定一个或多个记录号列表，用于尝试锁定多个记录。
            必须启用 Set MultiLocks，并且必须包含要尝试放置多个记录锁的表的工作区或别名。
            Lock() 尝试锁定您指定的所有记录。cRecordNumberList 中指定的记录号用逗号分隔。
            例如，要尝试锁定表中的前四条记录，cRecordNumberList 必须包含 1,2,3,4。<br/>
            您还可以通过将记录指针移动到要锁定的记录，
            执行 Lock() 或 RLock()，然后对每个额外的记录重复这些步骤来锁定多个记录。<br/>
            在 X# 中，您可以指定 0 作为记录号。指定 0 可以尝试锁定表头。<br/>
            <note name="注意">
                尽量缩短表头锁定的时间，因为当表头被锁定时，其他用户无法向表中添加记录。
            </note>
            使用 UNLock RECORD 0、UNLock 或 UNLock ALL 释放表头锁。
            如果 cRecordNumbers 中指定的所有记录都成功锁定，Lock() 返回 true (.T.)。
            如果 cRecordNumbers 中指定的记录中有一个无法锁定，Lock() 返回 false (.F.)，且不会锁定任何记录。
            但是，任何现有的记录锁仍然保持不变。多重记录锁定是一个累加过程。<br/>
            放置额外的记录锁不会释放其他记录上的锁。
            每个工作区可以锁定的最大记录数约为 8,000。
            锁定整个表总是比锁定少量记录更快。
        </param>
        <param name="uArea">
            尝试锁定特定工作区中打开的表的当前记录。
            uArea 指定工作区号和表别名。
            如果不指定工作区或表别名，Lock() 尝试锁定当前工作区中表的当前记录。
        </param>
        <returns>
            逻辑型
        </returns>
        <remarks>
            Lock() 与 RLock() 相同。<br/>
            对显式锁定记录的更改在记录解锁或记录指针移动之前不会保存。<br/>
            如果成功放置锁，Lock() 返回 true (.T.)。锁定的记录对放置锁的用户可进行读写访问；
            对网络上的所有其他用户仅可进行只读访问。
            执行 Lock() 不能保证记录锁一定会成功放置。
            无法对已被其他用户锁定的记录或已被其他用户锁定的表中的记录放置记录锁。
            如果由于任何原因无法放置记录锁，Lock() 返回 false (.F.)。<br/>
            默认情况下，Lock() 只尝试一次锁定记录。使用 Set REPROCESS 可在首次尝试失败时自动重试记录锁定。
            Set REPROCESS 决定在初始锁定尝试失败时进行锁定尝试的次数或持续时间。
            有关更多信息，请参阅 Set REPROCESS。<br/>
            Set MultiLocks 决定是否可以锁定表中的多个记录。如果 Set MultiLocks 为 OFF（默认值），
            则只能锁定表中的单个记录。当 Set MultiLocks 为 ON 时，可以锁定表中的多个记录。
            有关更多信息，请参阅 Set MultiLocks。<br/><br/>
            <b>解锁记录</b>   表记录只能由放置锁的用户解锁。
            您可以通过发出 UNLock、关闭表或退出 X# 来释放记录锁。
            UNLock 可用于释放当前工作区、特定工作区或所有工作区中的记录锁。
            有关更多信息，请参阅 UNLock。<br/>
            将 Set MultiLocks 从 ON 切换到 OFF 或从 OFF 切换到 ON 会隐式执行 UNLock ALL — 释放所有工作区中的所有记录锁。<br/>
            可以使用 Use、Clear ALL 或 Close Databases 关闭表。<br/>
            有关在网络上记录和文件锁定以及共享表的更多信息，请参阅"共享访问编程"。<br/>
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Open Database (HOME(2) + 'data\testdata')
                Set REPROCESS TO 3 AUTOMATIC
                STORE '1,2,3,4' TO gcRecList
                gcOldExc = Set('EXCLUSIVE')
                Set EXCLUSIVE OFF
                Select 0
                Use employee  &amp;&amp; 打开 Employee 表
                Select 0
                Use customer  &amp;&amp; 打开 Customer 表
                ? Lock('1,2,3,4', 'customer')  &amp;&amp; 锁定 customer 表中的前 4 条记录
                ? RLock(gcRecList, 'employee')  &amp;&amp; 锁定 employee 表中的前 4 条记录
                UNLock IN customer
                UNLock IN employee
                Set EXCLUSIVE &amp;gcOldExc
            </code>
        </example>
    </lock>

    <lookup>
        <summary>
            在表中搜索第一个字段匹配指定表达式的记录。
        </summary>
        <returns>
            字符型、数值型、货币型、浮点型、整型、双精度型、日期型、日期时间型或逻辑型。
        </returns>
        <remarks>
            如果搜索成功，LOOKUP( ) 将记录指针移动到匹配的记录，并返回该记录中指定字段的内容。<br/>
            如果 LOOKUP( ) 未找到搜索表达式，它将返回一个与 ReturnField 长度和数据类型相同的空值。
            记录指针将定位在文件末尾。<br/>
            如果使用 LOOKUP( ) 搜索父表，所有相关子表中的记录指针都将移动到相关记录。<br/>
            此函数无法通过 Rushmore 查询优化进行优化。
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Open Database (HOME(2) + 'data\testdata')
                Use customer Order company  &amp;&amp; 打开 Customer 表
                Clear
                @ 2,2 SAY LOOKUP(contact, 'Ernst Handel', company, 'company')
            </code>
        </example>
    </lookup>

    <maketransactable>
        <summary>
            使自由表或自由游标支持事务。
        </summary>
        <param name="uArea">
            指定将支持事务的表或游标的工作区。<br/>
            或<br/>
            指定将支持事务的表或游标的别名。
        </param>
        <returns>
            逻辑值。如果MakeTrancsactable()成功使自由表或游标支持事务，则返回逻辑真（.T.），
            否则返回逻辑假（.F.）。
        </returns>
        <remarks>
            自由表是未使用ADD Table命令添加到数据库的表。自由游标是从自由表创建或使用Create CURSOR - SQL命令创建的游标。<br/>
            当使用MakeTrancsactable()使自由表或自由游标支持事务时，您可以对该自由表或自由游标使用BEGIN TRANSACTIOn、
            END TRANSACTIOn和ROLLBACK命令。使用IsTrancsactable()函数可以确定自由表或自由游标是否支持事务。
            <note name="注意">
                当使用MakeTrancsactable()使自由表或自由游标支持事务时，该自由表或自由游标在所有打开它的工作区和数据会话中都支持事务。
                MakeTrancsactable()使自由表或自由游标的所有打开实例支持事务，包括单个X#实例中其他数据会话中的实例。
            </note>
            如果不支持事务的自由表在多个数据会话中打开，则无法使其支持事务。
            但是，您可以在其他数据会话中打开已支持事务的自由表。<br/>
            如果启用了行缓冲，则在使自由表或自由游标支持事务之前，如果有未提交的更改，将执行表更新。
            您不能使用MakeTrancsactable()为启用了表缓冲的自由表启用事务。<br/>
            要禁用自由表的事务支持，您必须在所有数据会话中关闭该自由表。
        </remarks>
    </maketransactable>

    <newobject>
        <summary>
            直接从可视化类库（.vcx）文件或程序（.prg）文件创建新的类或对象，无需打开文件。
        </summary>
        <param name="cClassName">
            指定从中创建新类或对象的类或对象。
        </param>
        <param name="cModule">
            指定包含由cClassName指定的类或对象的.vcx文件或X#程序（.prg、.fxp、.mpr、.app、.exe等）。
            默认为.vcx文件。如果指定程序文件，必须包含扩展名。
            <note name="注意">
                类库可以有别名。要指定带有别名的类库中的类或对象，
                请包含类库别名，后跟句点和对象名称。<br/>
                当类存储在程序文件（.prg）中时，尽可能指定已编译的程序名（.fxp）。
                这确保从正确的类定义文件加载类。
            </note>
            如果省略cModule，或为空字符串或空值，X#按以下顺序搜索类或对象：
            <list type="bullet">
                <item>X#基类。</item>
                <item>当前程序中的类。</item>
                <item>使用Set CLASSLIB打开的类库。</item>
                <item>使用Set PROCEDURE打开的过程文件中的类。</item>
                <item>X#程序执行链中的类。</item>
                <item>如果Set OLEOBJECT为ON，则搜索OLE注册表。</item>
            </list>
        </param>
        <param name="cInApplication">
            指定包含您用cModule指定的.vcx文件的X#应用程序（.exe或.app）。
            必须为应用程序包含扩展名。如果省略cModule，或cInApplication为空字符串或空值，则忽略cInApplication。<br/>
            如果要使用cInApplication参数，必须为cModule指定.vcx文件的名称。
            不能传递.prg文件或已编译程序（.fxp）的名称。
        </param>
        <param name="0">
            指定实例化类或对象时不执行类或对象中的任何事件或方法代码。
            此功能在运行时应用程序中不受支持。<br/>
            父类的所有子类或对象也会被实例化。子类或对象中的事件或方法代码不会被执行。<br/>
            此选项提供了查看类或对象结构的能力（例如，使用AMembers()函数），
            而无需在类设计器或窗体设计器中打开类或对象。<br/>
            注意，绝不应执行类或对象中的代码 - 不支持代码执行，可能会使X#不稳定。
            您不应显式调用事件或方法，或设置属性。设置属性可能会调用Access和Assign方法。
        </param>
        <param name="eParameter1">
            指定传递给类或对象的Init事件过程的可选参数。
        </param>
        <param name="eParameter2">
            指定传递给类或对象的Init事件过程的可选参数。
        </param>
        <returns>
            对象
        </returns>
        <remarks>
            要将NEWOBJECT()返回的对象引用分配给变量或数组元素，请使用等号（=）或STORE命令。
            如果分配给变量或数组元素的对象被释放，该变量或数组元素将包含空值。
            要从内存中移除变量或数组元素，请使用RELEASE命令。<br/>
            对于NEWOBJECT()，X#使用ADDITIVE子句为第二个或第三个参数执行内部Set CLASSLIB或Set PROCEDURE，
            其中参数首先用于确定搜索顺序。如果这些参数已存在于Set CLASSLIB或Set PROCEDURE列表中，
            X#会重新排列列表顺序，使它们排在首位。然后X#定位所有类，创建对象，并调用Init事件。
            最后，如果安装未更改列表，X#会恢复原始的Set CLASSLIB或Set PROCEDURE列表。<br/>
            OLE对象使用以下语法创建cClassName：
             <code language="X#">ApplicationName.Class</code>
            例如，要创建支持自动化的Microsoft Excel工作表，请使用以下语法：
             <code language="X#">oExcelSheet = NEWOBJECT('Excel.Sheet')</code>
        </remarks>
    </newobject>

    <normalize>
        <summary>
            将用户提供的表达式转换为X#内部使用的相同形式。
            您可以使用表达式的标准化形式来更准确地与X#命令或函数返回的表达式进行比较。
        </summary>
        <param name="cExpression">
            指定要标准化的字符表达式。
        </param>
        <returns>
            字符型
        </returns>
        <remarks>
            <b>Normalize( )</b> 从字符表达式 cExpression 返回一个字符串，并进行以下更改。<b>Normalize( )</b>：
            <list type="bullet">
                <item>
                    将字符表达式转换为大写。但不会更改嵌入的字符串。
                    嵌入字符串的示例是字符表达式 "LEFT('Hello',1)" 中的 "Hello"。
                </item>
                <item>将字符表达式中任何缩写的X#关键字扩展为其全长。</item>
                <item>将分隔别名和字段名的 -&gt; 运算符转换为句点。</item>
                <item>用句点包围逻辑运算符 AND、OR 和 NOT：.AND. .OR. .NOT.</item>
                <item>在过滤器表达式中，删除术语之间的任何空格。</item>
                <item>
                    检查字符表达式中任何X#命令或函数的语法，但不评估表达式。
                    如果语法不正确，X#会生成语法错误。<b>Normalize( )</b> 不会查找字符表达式中的任何字段、表、内存变量、
                    用户定义函数或其他引用。
                </item>
            </list>
            例如，用户可能在表达式生成器中输入以下索引表达式：
             <code language="X#">UPPE(cust-&gt;lname) + UPPE(cust-&gt;fname)</code>
            虽然这是一个有效的X#索引键表达式，但很难将其与X#函数（如 <b>KEY( )</b>）的返回值进行比较。
            <b>Normalize( )</b> 为上述表达式返回以下字符串：
             <code language="X#">UPPER(CUST.LNAME) + UPPER(CUST.FNAME)</code>
            您可以轻松地将其与 <b>KEY( )</b> 等函数返回的值进行比较。
            这使您能够验证具有用户提供的索引表达式的索引或索引标记的存在。
            此外，您可以使用 Normalize 比较 <b>Set("Filter")</b> 或 <b>Filter( )</b> 的结果。
            例如，您可以创建以下过滤器表达式：
             <code language="X#">
                STORE '"VIRGINIA" $ UPPER(state) AND NOT "MAINE" $ UPPER(state)' TO
                MyFilter
                Use Addresses
                LINK Word.Document.8 "C:\\Documents and Settings\\v-rodhil\\My Documents\\DocStudio\\Projects\\dv_foxhelp91\\cc1ce3c4-1dc6-4d8f-9406-c8bab4d6a40a.xml"
                "OLE_LINK1" \a \r  \* MERGEForMAT STORE '"VIRGINIA" $ UPPER(state) AND NOT "MAINE" $ UPPER(state)' TO
                MyFilter
                Set Filter TO &amp;MyFilter
            </code>
            但是，<b>Set("Filter")</b> 或 <b>Filter( )</b> 返回的值与原始过滤器不完全匹配。
             <code language="X#">? Set("Filter") == MyFilter  &amp;&amp; .F.</code>
            <b>Set("Filter")</b> 或 <b>Filter( )</b> 返回以下内容：
             <code language="X#">"VIRGINIA"$UPPER(STATE).AND..NOT."MAINE"$UPPER(STATE)</code>
            要确保正确比较，请使用：
             <code language="X#">? Normalize(MyFilter) == Set("Filter")  &amp;&amp; .T.</code>
        </remarks>
    </normalize>

    <numlock>
        <summary>
            返回Num Lock键的当前模式，或设置Num Lock键的模式为开启或关闭。
        </summary>
        <param name="lSetOn">
            打开或关闭Num Lock键。如果lSetOn为真(.T.)，则打开Num Lock键；如果lSetOn为假(.F.)，则关闭Num Lock键。
        </param>
        <returns>
            NumLock()返回一个逻辑值，对应于执行NumLock(.T.)或NumLock(.F.)之前的Num Lock键设置。
        </returns>
        <remarks>
            如果Num Lock键开启（按数字键盘上的键返回数字），则NumLock()返回真(.T.)；如果Num Lock关闭（按数字键盘上的键移动光标），则返回假(.F.)。
        </remarks>
        <example>
             <code language="X#">
                gcOldLock = NumLock()  &amp;&amp; 保存原始设置
                WAIT '按任意键打开Num Lock'
                = NumLock(.T.)  &amp;&amp; 打开Num Lock
                WAIT '按任意键关闭Num Lock'
                = NumLock(!NumLock())  &amp;&amp; 将Num Lock切换到相反的值
                WAIT '按任意键恢复原始Num Lock设置'
                = NumLock(gcOldLock)     &amp;&amp; 恢复到原始设置
            </code>
        </example>
    </numlock>

    <nvl>
        <summary>
            从两个表达式中返回一个非空值。
        </summary>
        <returns>
            字符型、日期型、日期时间型、数值型、货币型、逻辑型或空值
        </returns>
        <remarks>
            使用 NVL() 从不支持或不相关的计算或操作中移除空值。
        </remarks>
        <example>
             <code language="X#">
                STORE .NULL. TO glMyNull  &amp;&amp; 包含空值的内存变量
                Clear
                ? NVL(.T., glMyNull)  &amp;&amp; 显示 .T.
                ? NVL(glMyNull, glMyNull)  &amp;&amp; 显示 .NULL.
            </code>
        </example>
    </nvl>

    <oldval>
        <summary>
            返回已修改但尚未更新的字段的原始值。
        </summary>
        <param name="cExpression">
            指定一个表达式，<b>OldVal( )</b>从表或远程数据源返回该表达式的原始值。
            cExpression通常是来自表或远程数据源的字段或由一组字段组成的表达式。
        </param>
        <param name="uArea">
            指定返回原始字段值的表或游标的别名。<br/>
            或<br/>
            指定返回原始字段值的表或游标的工作区。
        </param>
        <returns>
            字符型、货币型、日期型、日期时间型、双精度型、浮点型、整数型、逻辑型、数值型或备注型
        </returns>
        <remarks>
            <b>OldVal( )</b>返回X#表或游标中已使用<b>CursorSetProp( )</b>启用行或表缓冲的记录的原始字段值。<br/>
            如果数据库中的表或游标具有验证规则，<b>OldVal( )</b>不需要启用行或表缓冲即可返回原始字段值。<br/>
            如果在启用行缓冲时将记录指针移动到不同的记录，或者发出<b>TableUpdate( )</b>以提交对记录的更改，
            或者有其他导致更新的操作（如结束事务），则字段将被更新，原始字段值将不再可用。<br/>
            <b>OldVal( )</b>返回的值的数据类型由您在cExpression中指定的表达式决定。<br/>
            即使对于声明为NOT NULL且设置了Set NULL OFF的字段，<b>OldVal( )</b>也可以返回.NULL.。<br/>
            如果在没有可选的uArea参数的情况下发出<b>OldVal( )</b>，则返回当前选定工作区中打开的表或游标的原始字段值。
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Clear
                * 创建新表并添加空白记录
                Create Table employee (cLastName C(10))
                Append Blank
                * 插入初始值
                Insert Into employee (cLastName) VALUES ("Smith")
                * 启用并设置表缓冲
                Set MultiLocks ON  &amp;&amp; 允许表缓冲
                =CursorSetProp("Buffering", 5, "employee" )  &amp;&amp; 启用表缓冲
                * 显示初始值
                =MessageBox("原始cLastName值: "+ cLastName, 0, "结果")
                * 更改记录值并显示结果
                Replace cLastName WITH "Jones"
                =MessageBox("修改后的cLastName值: "+ cLastName, 0, "结果")
                * 将字段的旧值存储到cTemp变量并显示结果
                cTemp=OldVal("cLastName", "employee")
                =MessageBox("原始cLastName值: "+ cTemp, 0, "结果")
                * 更新表并显示最终值
                =TableUpdate(.T.)
                =MessageBox("最终cLastName值: "+ cLastName, 0, "结果")
                * 关闭并删除示例表文件
                Use
                Delete FILE employee.dbf
            </code>
        </example>
    </oldval>

    <payment>
        <summary>
            返回固定利率贷款的每期定期还款金额。
        </summary>
        <param name="nPrincipal">
            指定贷款的初始本金。
        </param>
        <param name="nInterestRate">
            指定每期的固定利率。如果贷款按月还款但利率是年利率，
            则将年利率除以12。
        </param>
        <param name="nPayments">
            指定贷款需要还款的总期数。
        </param>
        <returns>
            数值型
        </returns>
        <remarks>
            Payment( ) 假设周期利率恒定，并假设在每个周期结束时进行还款。
        </remarks>
        <example>
             <code language="X#">
                STORE 100000 to gnPrincipal     &amp;&amp; 100,000元初始本金
                STORE .105/12 TO gnInterest  &amp;&amp; 10.5%年利率
                STORE (20*12) TO gnPayments     &amp;&amp; 20年的月还款
                Clear
                ? Payment(gnPrincipal, gnInterest, gnPayments)  &amp;&amp; 显示 998.38
            </code>
        </example>
    </payment>

    <pcol>
        <summary>
            返回打印机打印头的当前列位置。
        </summary>
        <returns>
            PCol( )返回值
            数值型
        </returns>
        <remarks>
            <b>PCol( )</b>返回的值是相对于当前设置的左打印边距而言的。
            您可以使用Set MARGIN或通过将值存储到系统内存变量_PLOFFSet来设置左边距。<br/>
            <b>PCol( )</b>对于打印文本的相对定位特别有用。<br/>
            您可以使用$运算符代替<b>PCol( )</b>。
        </remarks>
        <example>
             <code language="X#">
                Clear
                @ PROW( ), PCol( )+12 SAY '联系人'
                @ PROW( ), $+12 SAY '联系人'
            </code>
        </example>
    </pcol>

    <primary>
        <summary>
            如果索引标记是主索引标记，则返回真（.T.）；否则返回假（.F.）。
        </summary>
        <param name="nIndexNumber">
            指定Primary( )返回主要状态的索引标记的编号。Primary( )按以下顺序返回主要状态，
            随着nIndexNumber从1增加到结构复合和独立复合索引标记的总数。<br/>
            首先返回结构复合索引中每个标记的主要状态（如果存在）。
            主要状态按照标记在结构索引中创建的顺序返回。<br/>
            接下来返回任何打开的独立复合索引中每个标记的主要状态。
            主要状态按照标记在独立复合索引中创建的顺序返回。<br/>
            如果省略nIndexNumber，Primary( )检查主控制索引标记是否为主索引标记。
            如果没有主控制索引标记，Primary( )返回假（.F.）。
        </param>
        <param name="uArea">
            指定nIndexNumber指定的索引标记的工作区。<br/>
            或<br/>
            指定nIndexNumber指定的索引标记的工作区。<br/>
            如果省略uArea，Primary( )检查当前选定工作区中的索引标记是否为主索引标记。
        </param>
        <returns>
            逻辑值
        </returns>
        <example>
             <code language="X#">
                Close Databases
                Set PATH TO (HOME(2) + 'Data\')   &amp;&amp; 设置数据库路径
                Open Database testdata  &amp;&amp; 打开testdata数据库
                Use Customer     &amp;&amp; 打开客户表

                For nCount = 1 TO TAGCOUNT( )
                    IF !EMPTY(TAG(nCount))  &amp;&amp; 检查索引中的标记
                        ? TAG(nCount)  &amp;&amp; 显示标记名称
                        ? Primary(nCount)     &amp;&amp; 显示主要状态
                    ELSE
                EXIT  &amp;&amp; 当没有更多标记时退出循环
                    ENDIF
                ENDFor
            </code>
        </example>
    </primary>

    <program>
        <summary>
            返回指定程序级别的程序名称、当前执行程序的名称、当前程序级别，或发生错误时正在执行的程序名称。
        </summary>
        <param name="nLevel">
            指定要搜索程序名称的程序级别数。nLevel 参数可以从 0 到程序嵌套深度。
            有关程序嵌套级别的更多信息，请参阅 X# 系统容量中的最大 DO 调用次数。<br/>
            当省略 nLevel 时，<b>Program( )</b> 返回当前执行程序的名称。如果为 nLevel 指定 0 或 1，
            <b>Program( )</b> 返回主程序或最高级程序的名称。<br/>
            如果为 nLevel 指定 –1，<b>Program( )</b> 返回当前程序级别作为数值。
            但是，在命令窗口中使用 <code>Program(–1)</code> 始终返回零 (0)。<br/>
            如果 nLevel 超过程序嵌套深度，<b>Program( )</b> 返回空字符串 ("")。
        </param>
        <returns>
            字符型或数值型。<b>Program( )</b> 返回程序名称、当前程序级别的数字或空字符串。
        </returns>
        <remarks>
            您可以使用 <b>Program( )</b> 来帮助程序从错误中恢复。
            <b>Program( )</b> 函数类似于 SYS(16) - 执行程序文件名。
        </remarks>
        <example>
             <code language="X#">
                ON ERROR DO errhand WITH Program( )
                *** 下一行应该生成一个错误 ***
                Use nodatabase
                ON ERROR     &amp;&amp; 返回系统默认错误处理程序
                PROCEDURE errhand
                PARAMETERS gcProgram
                WAIT '在程序 ' + gcProgram + ' 中发生了一个错误' WINDOW
            </code>
        </example>
    </program>

    <prow>
        <summary>
            返回打印机打印头的当前行号。
        </summary>
        <returns>
            数值型
        </returns>
        <remarks>
            如果您执行 <b>EJECT</b>，X# 会将 <b>PRow( )</b> 重置为 0。<br/>
            <b>PRow( )</b> 对于打印文本的相对定位特别有用。
        </remarks>
        <example>
             <code language="X#">
                @ PRow( ), PCol( ) + 12 SAY '联系人'
                @ PRow( ), $+12 SAY '联系人'
            </code>
        </example>
    </prow>
    
    <prtinfo>
        <summary>
            返回当前指定的打印机设置。
        </summary>
        <param name="nPrinterSetting">
            指定要返回的 X# 打印机设置。备注部分的表格列出了返回的打印机设置类型的描述。
        </param>
        <param name="cPrinterName">
            指定要返回信息的打印机名称。如果省略 cPrinterName，则返回默认打印机的信息。
        </param>
        <returns>
            数值数据类型。以下表格列出了指定特定 nPrinterSetting 值时返回的值。<br/>
            如果 nPrinterSetting 为 1，<b>PrtInfo( )</b> 返回纸张方向如下：
            <list type="table">
                <listheader>
                    <term>返回值</term>
                    <description>纸张方向</description>
                </listheader>
                <item>
                    <term>-1</term>
                    <description>信息不可用</description>
                </item>
                <item>
                    <term>0</term>
                    <description>纵向</description>
                </item>
                <item>
                    <term>1</term>
                    <description>横向</description>
                </item>
            </list>
            如果 nPrinterSetting 为 2，<b>PrtInfo( )</b> 返回纸张大小如下：
            <list type="table">
                <listheader>
                    <term>返回值</term>
                    <description>纸张大小</description>
                </listheader>
                <item>
                    <term>–1 或未列出的值</term>
                    <description>信息不可用。使用 nPrinterSetting = 3 和 nPrinterSetting = 4 返回纸张大小。</description>
                </item>
                <item>
                    <term>1</term>
                    <description>信纸，8 1/2 x 11 英寸</description>
                </item>
                <item>
                    <term>2</term>
                    <description>小型信纸，8 1/2 x 11 英寸</description>
                </item>
                <item>
                    <term>3</term>
                    <description>小报，11 x 17 英寸</description>
                </item>
                <item>
                    <term>4</term>
                    <description>账簿，17 x 11 英寸</description>
                </item>
                <item>
                    <term>5</term>
                    <description>法律文书，8 1/2 x 14 英寸</description>
                </item>
                <item>
                    <term>6</term>
                    <description>声明，5 1/2 x 8 1/2 英寸</description>
                </item>
                <item>
                    <term>7</term>
                    <description>行政公文，7 1/4 x 10 1/2 英寸</description>
                </item>
                <item>
                    <term>8</term>
                    <description>A3，297 x 420 毫米</description>
                </item>
                <item>
                    <term>9</term>
                    <description>A4，210 x 297 毫米</description>
                </item>
                <item>
                    <term>10</term>
                    <description>A4 小号，210 x 297 毫米</description>
                </item>
                <item>
                    <term>11</term>
                    <description>A5，148 x 210 毫米</description>
                </item>
                <item>
                    <term>12</term>
                    <description>B4，250 x 354 毫米</description>
                </item>
                <item>
                    <term>13</term>
                    <description>B5，182 x 257 毫米</description>
                </item>
                <item>
                    <term>14</term>
                    <description>对开本，8 1/2 x 13 英寸</description>
                </item>
                <item>
                    <term>15</term>
                    <description>四开本，215 x 275 毫米</description>
                </item>
                <item>
                    <term>16</term>
                    <description>10 x 14 英寸</description>
                </item>
                <item>
                    <term>17</term>
                    <description>11 x 17 英寸</description>
                </item>
                <item>
                    <term>18</term>
                    <description>便笺，8 1/2 x 11 英寸</description>
                </item>
                <item>
                    <term>19</term>
                    <description>信封 #9，3 7/8 x 8 7/8 英寸</description>
                </item>
                <item>
                    <term>20</term>
                    <description>信封 #10，4 1/8 x 9 1/2 英寸</description>
                </item>
                <item>
                    <term>21</term>
                    <description>信封 #11，4 1/2 x 10 3/8 英寸</description>
                </item>
                <item>
                    <term>22</term>
                    <description>信封 #12，4 1/2 x 11 英寸</description>
                </item>
                <item>
                    <term>23</term>
                    <description>信封 #14，5 x 11 1/2 英寸</description>
                </item>
                <item>
                    <term>24</term>
                    <description>C 尺寸纸</description>
                </item>
                <item>
                    <term>25</term>
                    <description>D 尺寸纸</description>
                </item>
                <item>
                    <term>26</term>
                    <description>E 尺寸纸</description>
                </item>
                <item>
                    <term>27</term>
                    <description>信封 DL，110 x 220 毫米</description>
                </item>
                <item>
                    <term>28</term>
                    <description>信封 C5，162 x 229 毫米</description>
                </item>
                <item>
                    <term>29</term>
                    <description>信封 C3，324 x 458 毫米</description>
                </item>
                <item>
                    <term>30</term>
                    <description>信封 C4，229 x 324 毫米</description>
                </item>
                <item>
                    <term>31</term>
                    <description>信封 C6，114 x 162 毫米</description>
                </item>
                <item>
                    <term>32</term>
                    <description>信封 C65，114 x 229 毫米</description>
                </item>
                <item>
                    <term>33</term>
                    <description>信封 B4，250 x 353 毫米</description>
                </item>
                <item>
                    <term>34</term>
                    <description>信封 B5，176 x 250 毫米</description>
                </item>
                <item>
                    <term>35</term>
                    <description>信封 B6，176 x 125 毫米</description>
                </item>
                <item>
                    <term>36</term>
                    <description>信封，110 x 230 毫米</description>
                </item>
                <item>
                    <term>37</term>
                    <description>信封 Monarch，3 7/8 x 7.5 英寸</description>
                </item>
                <item>
                    <term>38</term>
                    <description>6 3/4 信封，3 5/8 x 6 1/2 英寸</description>
                </item>
                <item>
                    <term>39</term>
                    <description>美国标准折叠纸，14 7/8 x 11 英寸</description>
                </item>
                <item>
                    <term>40</term>
                    <description>德国标准折叠纸，8 1/2 x 12 英寸</description>
                </item>
                <item>
                    <term>41</term>
                    <description>德国法律折叠纸，8 1/2 x 13 英寸</description>
                </item>
            </list>
            如果 nPrinterSetting 为 7，<b>PrtInfo( )</b> 返回默认纸张来源如下：
            <list type="table">
                <listheader>
                    <term>返回值</term>
                    <description>默认纸张来源</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>上层纸盒</description>
                </item>
                <item>
                    <term>2</term>
                    <description>下层纸盒</description>
                </item>
                <item>
                    <term>3</term>
                    <description>中层纸盒</description>
                </item>
                <item>
                    <term>4</term>
                    <description>手动进纸</description>
                </item>
                <item>
                    <term>5</term>
                    <description>信封纸盒</description>
                </item>
                <item>
                    <term>6</term>
                    <description>手动进信封</description>
                </item>
                <item>
                    <term>7</term>
                    <description>自动进纸</description>
                </item>
                <item>
                    <term>8</term>
                    <description>连续进纸</description>
                </item>
                <item>
                    <term>9</term>
                    <description>小型格式</description>
                </item>
                <item>
                    <term>10</term>
                    <description>大型格式</description>
                </item>
                <item>
                    <term>11</term>
                    <description>大容量纸盒</description>
                </item>
                <item>
                    <term>14</term>
                    <description>纸盒</description>
                </item>
                <item>
                    <term>15</term>
                    <description>默认输入纸盒（自动选择）</description>
                </item>
            </list>
            如果 nPrinterSetting 为 8 且 <b>PrtInfo( )</b> 返回负值，返回值表示打印质量如下：
            <list type="table">
                <listheader>
                    <term>返回值</term>
                    <description>打印质量</description>
                </listheader>
                <item>
                    <term>-1</term>
                    <description>草稿</description>
                </item>
                <item>
                    <term>–2</term>
                    <description>低</description>
                </item>
                <item>
                    <term>–3</term>
                    <description>中</description>
                </item>
                <item>
                    <term>–4</term>
                    <description>高</description>
                </item>
            </list>
            如果 nPrinterSetting 为 9，<b>PrtInfo( )</b> 返回一个值，指示彩色打印机是否渲染彩色或单色输出，如下所示：
            <list type="table">
                <listheader>
                    <term>返回值</term>
                    <description>输出颜色</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>单色</description>
                </item>
                <item>
                    <term>2</term>
                    <description>彩色</description>
                </item>
            </list>
            如果 nPrinterSetting 为 10，<b>PrtInfo( )</b> 返回双面打印模式，如下所示：
            <list type="table">
                <listheader>
                    <term>返回值</term>
                    <description>双面打印模式</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>单面打印</description>
                </item>
                <item>
                    <term>2</term>
                    <description>垂直双面打印</description>
                </item>
                <item>
                    <term>3</term>
                    <description>水平双面打印</description>
                </item>
            </list>
            如果 nPrinterSetting 为 12，<b>PrtInfo( )</b> 返回一个值，指示 TrueType® 字体的打印方式，如下所示：

            <list type="table">
                <listheader>
                    <term>返回值</term>
                    <description>TrueType® 字体的打印方式</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>作为位图图形打印</description>
                </item>
                <item>
                    <term>2</term>
                    <description>作为软字体下载</description>
                </item>
                <item>
                    <term>3</term>
                    <description>替换为设备字体</description>
                </item>
            </list>
            如果 nPrinterSetting 为 13，<b>PrtInfo( )</b> 返回一个值，指示输出是否进行整理，如下所示：
            <list type="table">
                <listheader>
                    <term>返回值</term>
                    <description>整理</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>不整理</description>
                </item>
                <item>
                    <term>1</term>
                    <description>整理</description>
                </item>
            </list>
        </returns>
        <remarks>
            您可以在打印机页面设置对话框中设置 X# 打印机设置。有关更多信息，请参阅页面设置对话框。
            <list type="table">
                <listheader>
                    <term>nPrinterSetting</term>
                    <description>XSHARP.H</description>
                    <description>返回的设置</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>PRT_ORIENTATION</description>
                    <description>纸张方向</description>
                </item>
                <item>
                    <term>2</term>
                    <description>PRT_PAPERSIZE</description>
                    <description>纸张大小</description>
                </item>
                <item>
                    <term>3</term>
                    <description>PRT_PAPERLENGTH</description>
                    <description>纸张长度（以 0.1 毫米为增量）</description>
                </item>
                <item>
                    <term>4</term>
                    <description>PRT_PAPERWIDTH</description>
                    <description>纸张宽度（以 0.1 毫米为增量）</description>
                </item>
                <item>
                    <term>5</term>
                    <description>PRT_SCALE</description>
                    <description>打印机输出缩放比例</description>
                </item>
                <item>
                    <term>6</term>
                    <description>PRT_COPIES</description>
                    <description>打印份数</description>
                </item>
                <item>
                    <term>7</term>
                    <description>PRT_DEFASOURCE</description>
                    <description>默认纸张来源</description>
                </item>
                <item>
                    <term>8</term>
                    <description>PRT_PRINTQUAL</description>
                    <description>正值表示水平分辨率（以每英寸点数 DPI 为单位），负值表示打印质量。</description>
                </item>
                <item>
                    <term>9</term>
                    <description>PRT_COLOR</description>
                    <description>指示彩色打印机是否渲染彩色或单色输出的值</description>
                </item>
                <item>
                    <term>10</term>
                    <description>PRT_DUPLEX</description>
                    <description>双面打印模式</description>
                </item>
                <item>
                    <term>11</term>
                    <description>PRT_YRESOLUTION</description>
                    <description>垂直分辨率（以每英寸点数 DPI 为单位）。如果不可用，则返回 -1。</description>
                </item>
                <item>
                    <term>12</term>
                    <description>PRT_TTOPTION</description>
                    <description>指示 TrueType® 字体打印方式的值</description>
                </item>
                <item>
                    <term>13</term>
                    <description>PRT_COLLATE</description>
                    <description>指示输出是否进行整理的值</description>
                </item>
            </list>
        </remarks>
    </prtinfo>

    <putfile>
        <summary>
            调用"另存为"对话框并返回您指定的文件名。
        </summary>
        <param name="cCustomText">
            指定在"另存为"对话框中显示的自定义文本。
        </param>
        <param name="cFileName">
            指定在文本框中显示的默认文件名。
        </param>
        <param name="cFileExtensions">
            指定文件名扩展名。当取消选中"所有文件"复选框时，只有具有指定扩展名的文件名才会显示在"另存为"对话框的可滚动列表中。
            如果输入的文件名中没有包含扩展名，则会自动将cFileExtensions中的第一个扩展名附加到文件名上。
            cFileExtensions参数的长度不能超过254个字符。有关X#文件扩展名和相应的创建者类型的列表，请参阅在线主题"文件扩展名和文件类型"。<br/>
            字符表达式cFileExtensions可以采用以下形式之一：
            <list type="bullet">
                <term>cFileExtensions可以包含单个扩展名，如PRG，这样只显示具有该扩展名的文件名。</term>
                <term>
                    cFileExtensions可以包含用分号分隔的文件名扩展名列表。例如，如果包含PRG;FXP，
                    X#将显示所有扩展名为.prg和.fxp的文件名。
                </term>
                <term>
                    如果文件名具有相同的根名称但不同的扩展名（例如，Customer.prg和Customer.fxp），
                    X#只显示扩展名在cFileExtensions中首先出现的文件名。
                </term>
                <term>
                    cFileExtensions可以包含用竖线分隔的文件名扩展名列表，如PRG|FXP。在这种情况下，
                    X#显示所有列出扩展名的文件名，即使文件具有相同的根名称。
                </term>
                <term>如果cFileExtensions只包含一个分号（;），X#将显示所有没有扩展名的文件名。</term>
                <term>如果cFileExtensions是空字符串，X#将显示当前目录或文件夹中的所有文件名。</term>
                <term>
                    如果cFileExtensions包含MS-DOS通配符，如问号（?）和星号（*），X#将显示所有扩展名符合通配符条件的文件名。
                    例如，如果cFileExtensions为?X?，则会显示所有扩展名为.fxp、.exe、.txt等的文件名。
                </term>
            </list>
        </param>
        <returns>
            字符型
        </returns>
        <remarks>
            使用<b>PutFile( )</b>选择现有文件名或指定新文件名。<b>PutFile( )</b>返回带路径的文件名。
            如果您没有输入文件名，<b>PutFile( )</b>返回默认文件名（由cFileName指定）和扩展名（由cFileExtensions指定）。
            如果您选择取消或按Esc键，<b>PutFile( )</b>返回空字符串。
            您可以使用<b>PutFile( )</b>返回的文件名来命名文件并将其保存到磁盘。
        </remarks>
        <example>
             <code language="X#">
                gcTableName = GetFile('DBF', '打开表:')
                Use (gcTableName)
                gcDelimName = Alias( ) + '.DLM'
                gcDelimFile = PutFile('分隔符文件:', gcDelimName, 'DLM')

                IF EMPTY(gcDelimFile)  &amp;&amp; 按下Esc键
                    CANCEL
                ENDIF

                COPY TO (gcDelimFile) DELIMITED   &amp;&amp; 创建分隔符文件
                MODIFY FILE (gcDelimFile) NOEDIT
            </code>
        </example>
    </putfile>

    <pv>
        <summary>
            返回投资的现值。
        </summary>
        <param name="nPayment">
            指定定期支付金额。nPayment可以为正数或负数。
            <b>PV( )</b>假设在每个周期结束时进行支付。
        </param>
        <param name="nInterestRate">
            指定周期利率。如果投资的利率是年利率，而支付是按月进行的，
            则将年利率除以12。
        </param>
        <param name="nTotalPayments">
            指定支付的总次数。
        </param>
        <returns>
            数值型
        </returns>
        <remarks>
            <b>PV( )</b>根据一系列等额定期支付和固定周期利率计算投资的现值。
        </remarks>
        <example>
             <code language="X#">
                STORE 500 to gnPayment  &amp;&amp; 每月定期支付
                STORE .075/12 TO gnInterest     &amp;&amp; 7.5%年利率
                STORE 48 TO gnPeriods  &amp;&amp; 四年（48个月）
                Clear
                ? PV(gnPayment, gnInterest, gnPeriods)  &amp;&amp; 显示 20679.19
            </code>
        </example>
    </pv>

    <raiseevent>
        <summary>
            您可以使用 <b>RaiseEvent( )</b> 从自定义方法中引发或触发事件。虽然 <b>RaiseEvent( )</b> 主要适用于
            自定义方法，但您也可以用它来引发原生事件和方法。
        </summary>
        <param name="oEventSource">
            指定事件源，必须是有效的 X# 对象。
        </param>
        <param name="cEvent">
            指定要引发的事件、方法或属性的名称。
        </param>
        <param name="eParm1...">
            如果方法有参数，则指定要传递的一个或多个参数。
        </param>
        <returns>
            逻辑数据类型。<b>RaiseEvent( )</b> 始终返回 True (.T.)。
        </returns>
        <remarks>
            对于使用 <b>BINDEVENT( )</b> 绑定到对象的自定义方法，如果直接调用这些方法，X# 会自动引发事件。
            例如，以下代码不会引发事件：
             <code language="X#">oForm.GetMyData(cData)</code>
            相反，要为自定义方法引发事件，您需要进行以下调用：
             <code language="X#">RaiseEvent( oForm, "GetMyData", cData )</code>
            您也可以通过使用 <b>BINDEVENT( )</b> 并将 nFlags 设置为 2 或 3 来改变这种行为。
            您希望引发的事件必须标记为 <b>Public</b>，而不是 <b>Hidden</b> 或 <b>Protected</b>。
            如果您在属性上使用 <b>RaiseEvent( )</b>，X# 会将属性设置为其自身。
            以下示例将 <b>_SCREEN</b> 的 <b>Caption</b> 属性设置为 <b>Caption</b> 的当前值：
             <code language="X#">RaiseEvent( _SCREEN, "Caption" )</code>
            如果您绑定到一个事件（例如，使用 <b>BINDEVENT( )</b>）并且该事件的参数是通过引用传递的，那么引发该事件将会失败。
            X# 会忽略在同一引发事件内对该事件的递归 <b>RaiseEvent( )</b> 调用。
        </remarks>
        <example>
             <code language="X#">RaiseEvent( Form1, "Activate" )</code>
        </example>
    </raiseevent>

    <refresh>
        <summary>
            刷新可更新的 SQL 远程或本地视图，或 <b>CursorAdapter</b> 游标中的数据。
        </summary>
        <param name="nRecords">
            指定要刷新的记录数。如果 nRecords 为 1 或省略 nRecords，则只刷新当前记录。
            如果 nRecords 为 0，则不刷新任何记录。
        </param>
        <param name="nRecordOffset">
            指定刷新开始的当前记录之前的记录数。
            例如，如果当前记录是第 10 条记录，而 nRecordOffset 为 4，则记录刷新从第 6 条记录开始。
            如果 nRecordOffset 为 0 或省略 nRecordOffset，则从当前记录开始刷新。
        </param>
        <param name="uArea">
            指定与 SQL 远程或本地视图关联的游标的别名，或要刷新记录的 <b>CursorAdapter</b> 游标。<br/>
            或<br/>
            指定要刷新记录的游标的工作区。如果省略 uArea，
            则在当前选定的工作区中刷新记录。<br/>
        </param>
        <returns>
            数值类型。<b>Refresh( )</b> 返回刷新的记录数。
        </returns>
        <remarks>
            记录使用定义 SQL 视图或 <b>CursorAdapter</b> 的表中的数据进行刷新。除非另有指定，
            否则在当前选定工作区中打开的 SQL 视图或 <b>CursorAdapter</b> 游标中刷新记录。<br/>
            <b>Refresh( )</b> 不会刷新缓冲记录的内容；但是，可以通过 <b>CurVal( )</b> 函数访问的记录字段值会被刷新。
            有关更多信息，请参阅 CurVal( ) 函数。<br/>
            记录必须具有唯一的主键。如果在基表中找不到记录的键，
            则 SQL 视图或 <b>CursorAdapter</b> 中相应的记录将被标记为删除。<br/>
            调用 <b>Refresh( )</b> 函数可能会对性能产生显著影响，因为该函数会重新执行视图所基于的查询。
            因此，请勿过多地调用此函数。
        </remarks>
    </refresh>

    <requery>
        <summary>
            重新检索 SQL 视图的数据。
        </summary>
        <param name="uArea">
            指定打开 SQL 视图的工作区。<br/>
            或<br/>
            指定 SQL 视图的别名。如果省略 uArea，
            则重新检索当前选定工作区中打开的 SQL 视图的数据。
        </param>
        <returns>
            数值型。如果成功检索数据，<b>Requery( )</b> 返回 1；否则返回 0。
        </returns>
        <remarks>
            当数据源上的数据发生变化时，通常使用 <b>Requery( )</b> 来刷新 SQL 视图。
        </remarks>
    </requery>

    <rgbscheme>
        <summary>
            从指定的颜色方案中返回一个RGB颜色对或RGB颜色对列表。
        </summary>
        <param name="nColorSchemeNumber">
            指定要获取完整RGB颜色列表的颜色方案编号。RGBScheme() 返回10个RGB颜色对。
        </param>
        <param name="nColorPairPosition">
            从颜色方案中返回单个RGB颜色对。nColorPairPosition指定颜色方案中RGB颜色对的位置。
            例如，如果nColorPairPosition为4，则返回第四个RGB颜色对。
        </param>
        <returns>
            字符型
        </returns>
        <remarks>
            使用SCHEME()从颜色方案中返回传统颜色对或颜色对列表。RGB颜色对使用数值来指定颜色。
            传统颜色对使用字母来指定颜色。
        </remarks>
        <example>
             <code language="X#">
                Clear
                ? RGBScheme(4,3)
            </code>
        </example>
    </rgbscheme>

    <savepicture>
        <summary>
            从图片对象引用创建位图（.bmp）文件。
        </summary>
        <param name="oObjectReference">
            指定 SAVEPICTURE( ) 用于创建位图文件的图片对象引用。
        </param>
        <param name="cFileName">
            指定 SAVEPICTURE( ) 创建的位图文件的名称。如果 cFileName 包含路径，则文件将在指定的目录中创建。
            如果已存在同名文件，则会在不发出警告的情况下覆盖该文件，即使 Set SAFETY 为 ON。
        </param>
        <returns>
            逻辑型
        </returns>
        <remarks>
            图片对象引用通常通过 LoadPicture( ) 创建。然而，某些属性（如 OLE Outline 控件的 PictureOpen 属性）
            使用默认的图片对象引用，这可以用来创建位图文件。
        </remarks>
    </savepicture>

    <scheme>
        <summary>
            从指定的颜色方案中返回一个颜色对列表或单个颜色对。
        </summary>
        <param name="nSchemeNumber">
            指定要获取完整颜色对列表的颜色方案编号。SCHEME( ) 返回十个颜色对。
        </param>
        <param name="nColorPairNumber">
            指定颜色方案中一个颜色对的位置，SCHEME( ) 仅返回该颜色对。例如，如果 nColorPairNumber 为 4，
            SCHEME( ) 将返回颜色方案中的第四个颜色对。
        </param>
        <returns>
            字符型
        </returns>
        <example>
             <code language="X#">? SCHEME(4,3)</code>
        </example>
    </scheme>

    <seconds>
        <summary>
            返回自午夜以来经过的秒数。
        </summary>
        <returns>
            SECONDS( )返回值
            数值型。<b>SECONDS( )</b>以十进制格式返回一个数值，精确到1毫秒。
            对于在Windows NT 4.0或更高版本上运行的X#版本，<b>SECONDS( )</b>的精确度为10毫秒。
        </returns>
        <example>
             <code language="X#">
                Clear
                ? SECONDS( )
                ? SECONDS( )/(60 * 60)
            </code>
        </example>
    </seconds>

    <seek>
        <summary>
            在索引表中搜索第一个索引键与指定表达式匹配的记录。
            执行 Seek( ) 相当于依次执行 Seek 和 FOUND( )。<br/>
            X# 不支持对二进制索引进行搜索操作。
        </summary>
        <param name="eExpression">
            指定要搜索的索引键表达式。
        </param>
        <param name="uArea">
            指定要搜索索引键的工作区号。<br/>
            或<br/>
            指定要搜索的表别名。如果省略 uArea，则搜索当前选定工作区中的表。
        </param>
        <param name="uIndex">
            指定用于搜索索引键的索引文件或标记的编号。
            nIndexNumber 指的是在 Use 或 Set Index 中列出的索引文件。打开的 .idx 文件首先按照它们在 Use 或 Set Index 中出现的顺序编号。
            然后，结构化 .cdx 文件（如果存在）中的标记按照它们创建的顺序编号。最后，任何打开的独立 .cdx 文件中的标记按照它们创建的顺序编号。
            有关索引编号的更多信息，请参见 Set Order 命令。
        </param>
        <param name="cIDXIndexFileName">
            指定用于搜索索引键的 .idx 文件。
        </param>
        <param name="cTagName">
            指定用于搜索索引键的 .cdx 文件的标记。
            标记名可以来自结构化 .cdx 文件或任何打开的独立 .cdx 文件。
            如果存在重复的 .idx 文件和标记名，则 .idx 文件优先。
        </param>
        <returns>
            逻辑值。如果找到匹配项并且记录指针移动到匹配记录，Seek( ) 返回 True (.T.)。
            否则，如果未找到匹配项，Seek( ) 返回 False (.F.)，并且如果 Set NEAR 为 OFF，记录指针移动到文件末尾，
            如果 Set NEAR 为 ON，则移动到最接近的匹配记录。
        </returns>
        <remarks>
            您可以在设置了索引顺序的表上使用 Seek( )，或者如果表上未设置索引顺序，可以使用第三个参数 nIndexNumber、cIDXIndexFileName 
            或 cTagName 设置控制索引。除非 Set EXACT 设置为 OFF，否则匹配必须精确。<br/>
            如果省略 nIndexNumber、IDXIndexFileName 和 cTagName 参数，
            Seek( ) 将使用主控索引或索引标记来搜索索引键。<br/>
            如果 Seek( ) 使用非活动索引，则忽略 Set KEY 设置。
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Open Database (HOME(2) + 'Data\testdata')
                Use customer Order cust_id  &amp;&amp; 打开 Customer 表
                ? Seek('CHOPS')  &amp;&amp; 返回 .T.，找到记录
            </code>
        </example>
    </seek>

    <select>
        <summary>
            返回当前选定工作区的编号或最高编号的未使用工作区。
        </summary>
        <param name="uSelect">
            指定 Select( ) 返回工作区的表别名。
        </param>
        <returns>
            数值
        </returns>
        <remarks>
            如果 Set COMPATIBLE 设置为 OFF，Select( ) 返回当前工作区的编号。如果 Set COMPATIBLE 设置为 ON，
            Select( ) 返回编号最高的未使用工作区。
            可以使用 Select 选择（激活）工作区。
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Set COMPATIBLE ON
                Open Database (HOME(2) + 'data\testdata')
                Select 0  &amp;&amp; 未使用的工作区
                Use customer  &amp;&amp; 打开 Customer 表
                Select 0  &amp;&amp; 未使用的工作区
                Use orders  &amp;&amp; 打开 Orders 表
                Clear
                ? Select( )  &amp;&amp; 返回 3，最低可用工作区
            </code>
        </example>
    </select>
    
    <setfldstate>
        <summary>
            为表或游标中的字段或记录分配字段修改或删除状态值。
        </summary>
        <param name="nFieldstate">
            指定字段修改或删除状态的值。<br/>
            备注部分的表列出了字段修改或删除状态值及其对应的修改或删除状态：
        </param>
        <param name="uArea">
            指定要分配修改或删除状态的表或游标的别名。<br/>
            或<br/>
            指定要分配修改或删除状态的表或游标的工作区。
            如果在没有可选 uArea 参数的情况下发出 SetFLDState( )，则为当前选定工作区中打开的表或游标分配字段修改或删除状态值。
        </param>
        <returns>
            逻辑值
        </returns>
        <remarks>
            X# 使用字段状态值来确定更新表或游标中的哪些字段。SetFLDState( ) 使您能够控制
            X# 尝试更新哪些字段，而不管表或游标中哪些字段已被修改。<br/>
            <list type="table">
                <listheader>
                    <term>nFieldstate</term>
                    <description>修改或删除状态</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>字段未被修改或删除状态未改变。</description>
                </item>
                <item>
                    <term>2</term>
                    <description>字段已被修改或删除状态已改变。</description>
                </item>
                <item>
                    <term>3</term>
                    <description>追加记录中的字段未被修改或追加记录的删除状态未改变。</description>
                </item>
                <item>
                    <term>4</term>
                    <description>追加记录中的字段已被修改或追加记录的删除状态已改变。</description>
                </item>
            </list>
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Set MultiLocks ON  &amp;&amp; 必须开启以启用表缓冲
                Set PATH TO (HOME(2) + 'Data\')     &amp;&amp; 设置数据库路径
                Open Database testdata  &amp;&amp; 打开 testdata 数据库
                Use Customer     &amp;&amp; 打开 Customer 表
                = CursorSetProp('Buffering', 5, 'customer')  &amp;&amp; 启用表缓冲
                Clear
                ? GetFldState('cust_id')  &amp;&amp; 显示 1，未修改
                Replace cust_id    WITH '***'  &amp;&amp; 更改字段内容
                ? GetFldState('cust_id')  &amp;&amp; 返回 2，字段已修改
                = SetFLDState('cust_id', 1)  &amp;&amp; 更改字段状态
                ? GetFldState('cust_id')  &amp;&amp; 显示 1，未修改
                = TableRevert(.T.)  &amp;&amp; 放弃所有表更改
            </code>
        </example>
    </setfldstate>
    <setresultset>
        <summary>
            Marks a cursor as a result set in the current data session.<br/>
            Only one cursor per data session can be marked. When marking a new cursor,
            <b>SetResultSet( )</b> clears the marker from any previously marked cursor.
        </summary>
        <param name="uArea">
            Specifies a work area number.<br/>
            Or<br/>
            Specifies the alias of the cursor you want to mark.
        </param>
        <returns>
            Numeric. <b>SetResultSet( )</b> returns the number of the work area of the previously marked cursor in the current data session or zero (0)
            if no cursor is marked in the current data session.
        </returns>
        <remarks>
            <b>SetResultSet( )</b> is supported in X# and the X# OLE DB Provider. You can use <b>SetResultSet( )</b> in a database container (DBC)
            stored procedure or send it to the X# OLE DB Provider, assuming that the cursor has been previously opened by the OLE DB Provider.
            For example, suppose a previous command opens a cursor named MyCursor in the OLE DB Provider. The following line of code retrieves an
            ADO RecordSet for the cursor, MyCursor:
             <code language="X#">oRecordSet = oConn.Execute("SetResultSet('MyCursor')")</code>
            By using <b>SetResultSet( )</b> to mark a cursor or table opened by the X# OLE DB Provider, you can retrieve a rowset created from the
            table or cursor from a database container (DBC) stored procedure. When the OLE DB Provider completes command execution, it creates a
            rowset from the marked cursor, if it exists, then clears the marker flag from the cursor.
            In this scenario, the OLE DB Provider disregards all other return values. For example, if a stored procedure contains a <b>RETURN</b> 
            Value statement and a marked cursor, the OLE DB Provider does not return the value. Instead, it returns the marked cursor as a rowset
            to the calling application. When the rowset closes, the cursor also closes.
            However, even though the OLE DB Provider disregards all return values when a marked cursor exists, you can use <b>SetResultSet( )</b>
            with the <b>RETURN</b> command. For example:
             <code language="X#">RETURN SetResultSet("MyCursor")</code>
            This statement creates and returns a rowset from the marked cursor, not the return value from <b>SetResultSet( )</b>.
        </remarks>
    </setresultset>

    <strconv>
        <summary>
            在单字节、双字节、UNICODE 和特定区域表示之间转换字符表达式。
        </summary>
        <param name="cExpression">
            指定 STRCONV( ) 要转换的字符表达式。
        </param>
        <param name="nConversionSetting">
            指定转换类型。
            备注部分的表列出了 nConversionSetting 的值及执行的转换类型。
        </param>
        <param name="nRegionalIdentifier">
            指定用于转换的区域标识符、代码页或 FontCharSet 值。如果省略 nRegionalIDType，
            则使用区域标识符进行转换。如果省略 nRegionalIdentifier，则默认使用系统区域标识符。
            如果 nRegionalIdentifier 无效或在机器上不受支持，则会生成"无效的区域标识符"错误。
        </param>
        <param name="nRegionalIDType">
            指定是否使用区域标识符、代码页或 FontCharSet 进行转换。
            上面描述的 nRegionalIdentifier 参数用于指定用于转换的实际区域标识符、代码页或 FontCharSet。
        </param>
        <returns>
            字符数据类型。STRCONV( ) 返回转换后的字符表达式。
        </returns>
        <remarks>
            <list type="table">
                <listheader>
                    <term>nRegionalIdentifier </term>
                    <description>语言</description>
                </listheader>
                <item>
                    <term>1029</term>
                    <description>捷克语</description>
                </item>
                <item>
                    <term>1031</term>
                    <description>德语</description>
                </item>
                <item>
                    <term>1033</term>
                    <description>英语（默认）</description>
                </item>
                <item>
                    <term>1034</term>
                    <description>西班牙语</description>
                </item>
                <item>
                    <term>1036</term>
                    <description>法语</description>
                </item>
                <item>
                    <term>1040</term>
                    <description>意大利语</description>
                </item>
                <item>
                    <term>1045</term>
                    <description>波兰语</description>
                </item>
                <item>
                    <term>1046</term>
                    <description>葡萄牙语（巴西）</description>
                </item>
                <item>
                    <term>2070</term>
                    <description>葡萄牙语（葡萄牙）</description>
                </item>
            </list>
            <list type="table">
                <listheader>
                    <term>nRegionalIDType</term>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>（默认）指定 nRegionalIdentifier 参数是区域设置 ID 值。</description>
                </item>
                <item>
                    <term>1</term>
                    <description>指定 nRegionalIdentifier 是代码页值。</description>
                </item>
                <item>
                    <term>2</term>
                    <description>指定 nRegionalIdentifier 是 FontCharSet 值。</description>
                </item>
            </list>
            X# 忽略 base64 和 hexBinary 编码字符串中的无效字符或不正确的长度。<br/>
            此函数对于操作双字节字符集（如平假名和片假名）的语言很有用。
            <list type="table">
                <listheader>
                    <term>nConversionSetting</term>
                    <description>转换</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>
                        将 cExpression 中的单字节字符转换为双字节字符。<br/>
                        仅支持区域设置 ID（通过 nRegionalIdentifier 或 nRegionalIDType 参数指定）。
                    </description>
                </item>
                <item>
                    <term>2</term>
                    <description>将 cExpression 中的双字节字符转换为单字节字符。</description>
                </item>
                <item>
                    <term>3</term>
                    <description>将 cExpression 中的双字节片假名字符转换为双字节平假名字符。</description>
                </item>
                <item>
                    <term>4</term>
                    <description>将 cExpression 中的双字节平假名字符转换为双字节片假名字符。</description>
                </item>
                <item>
                    <term>5</term>
                    <description>将双字节字符转换为 UNICODE（宽字符）。</description>
                </item>
                <item>
                    <term>6</term>
                    <description>将 UNICODE（宽字符）转换为双字节字符。</description>
                </item>
                <item>
                    <term>7</term>
                    <description>将 cExpression 转换为特定区域的小写。</description>
                </item>
                <item>
                    <term>8</term>
                    <description>将 cExpression 转换为特定区域的大写。</description>
                </item>
                <item>
                    <term>9</term>
                    <description>将 cExpression 中的双字节字符转换为 UTF-8</description>
                </item>
                <item>
                    <term>10</term>
                    <description>将 cExpression 中的 Unicode 字符转换为 UTF-8</description>
                </item>
                <item>
                    <term>11</term>
                    <description>将 cExpression 中的 UTF-8 字符转换为双字节字符。</description>
                </item>
                <item>
                    <term>12</term>
                    <description>将 cExpression 中的 UTF-8 字符转换为 UNICODE 字符。</description>
                </item>
                <item>
                    <term>13</term>
                    <description>将 cExpression 中的单字节字符转换为编码的 base64 二进制。</description>
                </item>
                <item>
                    <term>14</term>
                    <description>将 cExpression 中的 base64 编码数据转换为原始未编码数据。</description>
                </item>
                <item>
                    <term>15</term>
                    <description>将 cExpression 中的单字节字符转换为编码的 hexBinary。</description>
                </item>
                <item>
                    <term>16</term>
                    <description>将 cExpression 中的单字节字符转换为解码的 hexBinary。</description>
                </item>
            </list>
        </remarks>
    </strconv>

    <strextract>
        <summary>
            在两个分隔符之间检索字符串。
        </summary>
        <param name="cSearchExpression">
            指定要搜索的字符串。
        </param>
        <param name="cBeginDelim">
            指定cSearchExpression开始的分隔字符。
        </param>
        <param name="cEndDelim">
            指定cSearchExpression结束的分隔字符。
        </param>
        <param name="nOccurrence">
            指定从cSearchExpression中cBeginDelim的第几次出现开始提取。
        </param>
        <param name="nFlag">
            指定对搜索施加的控制类型。
            在nFlag中指定的数字提供了一个位值，根据下表确定选项：
            <list type="table">
                <listheader>
                    <term>位</term>
                    <description>值（可累加）</description>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>1</description>
                    <description>不区分大小写搜索</description>
                </item>
                <item>
                    <term>1</term>
                    <description>2</description>
                    <description>
                        不需要结束分隔符。指定当搜索未找到cEndDelim时，
                        返回从cBeginDelim位置开始的cSearchExpression内容。
                    </description>
                </item>
                <item>
                    <term>2</term>
                    <description>4</description>
                    <description>在返回的表达式中包含分隔符。</description>
                </item>
            </list>
         </param>
        <returns>
            字符型或变长二进制型。<br/>
            结果数据类型由第一个参数的数据类型决定。
        </returns>

        <remarks>
            默认情况下，搜索区分大小写，且必须找到分隔符（未指定nFlag值）。<br/>
            如果cBeginDelim为空字符串，搜索将从cSearchExpression的开头进行，直到找到第一个cEndDelim。
            如果cEndDelim为空字符串，StrExtract()将返回从cBeginDelim的第nOccurrence次出现到cSearchExpression结尾的字符串。
        </remarks>
        <example>
             <code language="X#">
                Clear
                Set PATH TO (HOME(2) + 'Data\')   &amp;&amp;设置客户表路径
                Use customer &amp;&amp; 任意表
                ?cursortoxml(0,"x",1,0,2)   &amp;&amp; 生成包含表前2条记录XML的变量"x"
                ?x         &amp;&amp; 显示XML
                xmlproc(x,0)      &amp;&amp; 解析XML
                PROCEDURE xmlproc(x as String, nLev as Integer)   as void
                LOCAL cTagName, cContents, mterm
                DO WHILE .t.
                cTagName = StrExtract(x,"&lt;","&gt;")
                IF LEN(cTagName) = 0   &amp;&amp; 未找到标签
                ??' ',x   &amp;&amp; 打印原始字符串作为内容
                EXIT
                ENDIF
                IF RIGHT(cTagName,1) = '/'   &amp;&amp; 类似 "&lt;region/&gt;"
                cTagName = LEFT(cTagName, LEN(cTagName)-1)
                cContents=""
                mterm = "&lt;"+cTagName+"/&gt;"   &amp;&amp; "&lt;region/&gt;"
                ELSE
                mterm = "&lt;/"+cTagName+"&gt;"   &amp;&amp; "&lt;/region&gt;"
                cContents = StrExtract(x,"&lt;"+cTagName+"&gt;", mterm,1,2)
                ENDIF
                ?REPLICATE("  ",nLev),nLev+1,PADR(cTagName,20)
                xmlproc(cContents, nLev+1)
                x = StrExtract(x, mterm)   &amp;&amp; 获取剩余的xml
                ENDDO
            </code>
        </example>
    </strextract>

    <sys>
        <summary>
            返回系统信息或设置其行为。
        </summary>
        <param name="nSetting">要查询或更改的设置编号</param>
        <param name="uNewValue">设置的可选新值</param>
    </sys>

    <sysmetric>
        <summary>
            返回操作系统屏幕元素的大小。
        </summary>
        <param name="nScreenElement">
            指定屏幕元素。备注部分的表格展示了nScreenElement的值及其对应的屏幕元素：
        </param>
        <returns>
            字符
        </returns>
        <remarks>
            SysMetric() 返回屏幕元素的大小。屏幕元素包括菜单、窗口、窗口控件和插入点。
            返回值以像素为单位（除非另有说明），可能因不同的显示器、显示驱动程序和视频硬件而有所不同。
            有关屏幕元素的更多信息，请参阅MSDN库中的GetSystemMetrics函数，网址为<b>http://msdn.microsoft.com/library</b>。<br/>
            SysMetric() 使您能够确定在X#中创建的菜单、窗口和窗口控件的大小。
            使用DEFINE WINDOW和DEFINE MENU创建的窗口和菜单使用与操作系统窗口和菜单相同的屏幕元素大小。
            <list type="table">
                <listheader>
                    <term>nScreenElement</term>
                    <description>屏幕元素</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>屏幕宽度</description>
                </item>
                <item>
                    <term>2</term>
                    <description>屏幕高度</description>
                </item>
                <item>
                    <term>3</term>
                    <description>可调整大小的窗口框架宽度</description>
                </item>
                <item>
                    <term>4</term>
                    <description>可调整大小的窗口框架高度</description>
                </item>
                <item>
                    <term>5</term>
                    <description>垂直滚动条上滚动箭头的宽度</description>
                </item>
                <item>
                    <term>6</term>
                    <description>垂直滚动条上滚动箭头的高度</description>
                </item>
                <item>
                    <term>7</term>
                    <description>水平滚动条上滚动箭头的宽度</description>
                </item>
                <item>
                    <term>8</term>
                    <description>水平滚动条上滚动箭头的高度</description>
                </item>
                <item>
                    <term>9</term>
                    <description>窗口标题的高度</description>
                </item>
                <item>
                    <term>10</term>
                    <description>不可调整大小的窗口框架宽度</description>
                </item>
                <item>
                    <term>11</term>
                    <description>不可调整大小的窗口框架高度</description>
                </item>
                <item>
                    <term>12</term>
                    <description>DOUBLE或PANEL窗口框架的宽度</description>
                </item>
                <item>
                    <term>13</term>
                    <description>DOUBLE或PANEL窗口框架的高度</description>
                </item>
                <item>
                    <term>14</term>
                    <description>文本编辑窗口中水平滚动条上滚动框的宽度</description>
                </item>
                <item>
                    <term>15</term>
                    <description>文本编辑窗口中垂直滚动条上滚动框的高度</description>
                </item>
                <item>
                    <term>16</term>
                    <description>最小化窗口图标的宽度</description>
                </item>
                <item>
                    <term>17</term>
                    <description>最小化窗口图标的高度</description>
                </item>
                <item>
                    <term>18</term>
                    <description>最大插入点宽度</description>
                </item>
                <item>
                    <term>19</term>
                    <description>最大插入点高度</description>
                </item>
                <item>
                    <term>20</term>
                    <description>单行菜单栏的高度</description>
                </item>
                <item>
                    <term>21</term>
                    <description>最大化窗口的宽度</description>
                </item>
                <item>
                    <term>22</term>
                    <description>最大化窗口的高度</description>
                </item>
                <item>
                    <term>23</term>
                    <description>日文输入法窗口的高度</description>
                </item>
                <item>
                    <term>24</term>
                    <description>可调整大小的窗口的最小宽度</description>
                </item>
                <item>
                    <term>25</term>
                    <description>可调整大小的窗口的最小高度</description>
                </item>
                <item>
                    <term>26</term>
                    <description>窗口的最小宽度</description>
                </item>
                <item>
                    <term>27</term>
                    <description>窗口的最小高度</description>
                </item>
                <item>
                    <term>28</term>
                    <description>窗口控件的宽度</description>
                </item>
                <item>
                    <term>29</term>
                    <description>窗口控件的高度</description>
                </item>
                <item>
                    <term>30</term>
                    <description>如果存在鼠标硬件则为1；否则为0</description>
                </item>
                <item>
                    <term>31</term>
                    <description>对于Microsoft Windows调试版本为1；否则为0</description>
                </item>
                <item>
                    <term>32</term>
                    <description>如果鼠标按钮交换则为1；否则为0</description>
                </item>
                <item>
                    <term>33</term>
                    <description>半标题窗口的标题栏或标题中按钮的宽度</description>
                </item>
                <item>
                    <term>34</term>
                    <description>半标题窗口标题区域的高度</description>
                </item>
            </list>
        </remarks>
    </sysmetric>

    <tablerevert>
        <summary>
            放弃对缓冲行或缓冲表或游标所做的更改，并恢复远程游标的 OldVal() 数据以及本地表和游标的当前磁盘值。<br/>
            在网络环境中，当前磁盘上的数据可能与打开表或创建游标时磁盘上的数据不同。
            网络上的其他用户可能在表被打开或游标被创建后更改了数据。
        </summary>
        <param name="lAllRows">
            确定是否放弃对表或游标所做的所有更改。下表描述了 lAllRows 的值。
            <list type="table">
                <listheader>
                    <term>lAllRows</term>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>False (.F.)</term>
                    <description>如果启用了表缓冲，则仅放弃对表或游标中当前记录所做的更改。（默认）</description>
                </item>
                <item>
                    <term>True (.T.)</term>
                    <description>如果启用了表缓冲，则放弃对表或游标中所有记录所做的更改。</description>
                </item>
            </list>
            如果启用了行缓冲，X# 将忽略 lAllRows 的值，并放弃对表或游标中当前记录所做的更改。
        </param>
        <param name="uArea">
            指定要放弃更改的表或游标的别名。<br/>
            或<br/>
            指定要放弃更改的表或游标的工作区。
        </param>
        <returns>
            数值数据类型。TableRevert() 返回放弃更改的记录数。
        </returns>
        <remarks>
            TableRevert() 无法放弃对未启用行或表缓冲的表或游标所做的更改。
            如果在未启用行或表缓冲的情况下发出 TableRevert()，X# 将生成错误消息。使用 CursorSetProp() 启用或禁用行和表缓冲。<br/>
            如果在没有可选 uArea 参数的情况下发出 TableRevert()，则会放弃当前选定工作区中打开的表或游标中的更改。<br/>
            TableRevert() 不会将记录指针返回到其原始位置。<br/>
            TableRevert() 对 CursorAdapter 对象的操作方式与其他缓冲游标相同。<br/>
            在 X# 9.0 中，当 TableUpdate() 正在运行时，不能发出 TableRevert() 函数。
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Set MultiLocks ON  &amp;&amp; 必须开启以启用表缓冲
                Set PATH TO (HOME(2) + 'data\')     &amp;&amp; 设置数据库路径
                Open Database testdata  &amp;&amp; 打开 testdata 数据库
                Use Customer     &amp;&amp; 打开 Customer 表
                = CursorSetProp('Buffering', 5, 'customer')  &amp;&amp; 启用表缓冲
                Clear
                ? '原始 cust_id 值: '
                ?? cust_id  &amp;&amp; 显示当前 cust_id 值
                Replace cust_id    WITH '***'  &amp;&amp; 更改字段内容
                ? '新 cust_id 值: '
                ?? cust_id  &amp;&amp; 显示新的 cust_id 值
                = TableRevert(.T.)  &amp;&amp; 放弃所有表更改
                ? '恢复后的 cust_id 值: '
                ?? cust_id  &amp;&amp; 显示恢复后的 cust_id 值
            </code>
        </example>
    </tablerevert>

    <tableupdate>
        <summary>
            提交对缓冲行、缓冲表、游标或游标适配器所做的更改。
        </summary>
        <param name="nRows">
            指定应提交对表或游标所做的哪些更改。
            <note name="Note">
                X#默认为与<b>CursorAdapter</b>对象关联的游标启用乐观行缓冲。
            </note>
            备注部分的表格描述了nRows的值。
        </param>
        <param name="lForce">
            确定X#是否覆盖网络上另一用户对表或游标所做的更改。<br/>
            备注部分的表格描述了lForce的值。
        </param>
        <param name="uArea">
            指定提交更改的表或游标的别名。如果包含表或游标别名，必须包含lForce参数。<br/>
            或<br/>
            指定提交更改的表或游标的工作区。如果包含工作区，必须包含lForce参数。
        </param>
        <param name="cErrorArray">
            指定当nRows = 2且无法提交对记录的更改时创建的数组的名称。
            该数组包含一个单列，其中包含无法提交更改的记录的记录号。
            如果包含数组名称，必须包含表或游标别名uArea或工作区号。<br/>
            <note name="Note">
                如果在更新记录时发生简单提交错误以外的错误，cErrorArray的第一个元素将包含-1，
                然后可以使用<b>AError()</b>来确定无法提交更改的原因。
            </note>
            当cErrorArray存在时，X#将其值传递给<b>CursorAdapter</b>的AfterCursorUpdate事件。
        </param>
        <returns>
            逻辑数据类型。如果所有记录的更改都被提交，<b>TableUpdate()</b>返回True (.T.)。<br/>
            否则，<b>TableUpdate()</b>返回False (.F.)表示失败。不会执行ON ERROR例程。
            可以使用AError()函数获取有关失败原因的信息。<br/>
            <note name="Note">
                当使用表缓冲更新数据，并且在将<b>BatchUpdateCount</b>设置为大于1的值时从多个客户端更新数据源中的表时，
                <b>TableUpdate()</b>始终返回True (.T.)。
            </note>
            因此，在这些情况下避免将<b>BatchUpdateCount</b>设置为大于1的值。
        </returns>
        <remarks>
            <b>TableUpdate()</b>无法提交对未启用行或表缓冲的表或游标所做的更改。
            如果发出<b>TableUpdate()</b>而未启用行或表缓冲，X#会生成错误消息。
            但是，<b>TableUpdate()</b>仍然可以提交对具有验证规则的表或游标的更改。
            要启用或禁用行和表缓冲，请使用<b>CursorSetProp()</b>。<br/>
            如果没有可选的uArea参数发出<b>TableUpdate()</b>，则更改将提交到当前选定工作区中打开的表或游标。<br/>
            如果使用表缓冲并更新多个记录，<b>TableUpdate()</b>会将记录指针移动到最后更新的记录。<br/>
            <note name="Note">
                对不使用键字段的本地表或视图调用<b>TableUpdate()</b>会生成一个长的<b>Where</b>子句来查找更新行。
                <b>Where</b>子句中支持的默认字段数为40。如果收到错误SQL：语句太长（错误1812），
                应该使用更新的键字段或使用SYS(3055)增加<b>Where</b>子句的复杂性。
                如果使用<b>SYS(3055)</b>函数，
                将其值增加到表中字段数的8倍，如以下示例所示：
            </note>
             <code language="X#">SYS(3055, 8 * MIN(40, FCOUNT( ))</code>
            执行批量<b>TableUpdate()</b>操作时，由于开放式数据库连接（ODBC）的工作方式，
            当服务器未生成错误但未更新任何内容时，X#无法检测到冲突，例如，
            没有行匹配<b>Where</b>子句。当使用WhereType设置为DB_KEYANDUPDATable、DB_KEYANDMODIFIED
            或DB_KEYANDTIMESTAMP，并且另一个用户更改了<b>Where</b>子句中的一个基础值，使得更新语句找不到该行时，可能会发生这种情况。<br/>
            <b>与CursorAdapter对象的交互</b>   使用<b>CursorAdapter</b>对象时适用以下行为：
            <list type="bullet">
                <term>
                    <b>TableUpdate()</b>仅对与<b>CursorAdapter</b>对象关联的游标进行操作。
                </term>
                <term>
                    <b>TableUpdate()</b>根据数据源类型和存储在<b>CursorAdapter</b>的<b>InsertCmd</b>、
                    <b>UpdateCmd</b>或<b>DeleteCmd</b>属性中的命令，针对当前游标行或适当的行执行命令。
                </term>
                <term>
                    <b>TableUpdate()</b>将<c>GetFldState(1)</c>的值传递给每个受影响行的以下<b>CursorAdapter</b>事件：
                </term>
                <list type="bullet">
                    <term>BeforeInsert</term>
                    <term>BeforeUpdate</term>
                    <term>BeforeDelete</term>
                </list>
            </list>
            有关<b>GetFldState()</b>的更多信息，请参见GetFldState()函数。<br/>
            <list type="bullet">
                <term>
                    <b>TableUpdate()</b>成功完成会根据通常的<b>TableUpdate()</b>行为重置字段状态。
                </term>
                <term>
                    启用表缓冲时，可以在以下<b>CursorAdapter</b>事件中移出当前记录：
                    <list type="bullet">
                        <term>BeforeInsert</term>
                        <term>AfterInsert</term>
                        <term>BeforeUpdate</term>
                        <term>AfterUpdate</term>
                        <term>BeforeDelete</term>
                        <term>AfterDelete</term>
                    </list>
                </term>
            </list>
            您还可以修改游标中的数据。此功能支持诸如从基表检索自动增量值并将其插入游标等场景。当发生此场景时，<b>CursorAdapter</b>对象应在事件发生后自动返回到
            即将提交更改的记录，并提交更改。<br/>
            在X# 9.0中，当TableUpdate()操作进行时，不能发出TableRevert()函数。<br/>
            通常，CursorAdapter对象使用ADO或ODBC API提供的事务管理功能，X#在TableUpdate()函数成功完成时关闭
            事务。但是，如果您想直接向后端发送事务管理命令，可以将CursorAdaptor对象的UseTransactions属性设置为False (.F.)，CursorAdapter就不会使用
            事务来发送Insert、Update或Delete命令。
            <list type="table">
                <listheader>
                    <term>nRows</term>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>
                        如果启用了行或表缓冲，仅提交对游标中当前行所做的更改。（默认）<br/>
                        使用<b>CursorAdapter</b>对象时，X#仅为该行执行InsertCmd、UpdateCmd或DeleteCmd属性中的适当命令。
                    </description>
                </item>
                <item>
                    <term>1</term>
                    <description>
                        如果启用了表缓冲，提交对表或游标中所有记录所做的更改。<br/>
                        如果启用了行缓冲，仅提交对表或游标中当前记录所做的更改。<br/>
                        使用<b>CursorAdapter</b>对象时，X#为每个受影响的行执行<b>InsertCmd</b>、
                        <b>UpdateCmd</b>和<b>DeleteCmd</b>属性中的适当命令。
                    </description>
                </item>
                <item>
                    <term>2</term>
                    <description>
                        以与nRows = 1相同的方式提交对表或游标所做的更改。
                        但是，当无法提交更改时不会发生错误。X#继续处理表或游标中的任何剩余记录。<br/>
                        如果包含cErrorArray，则在发生错误时创建包含错误信息的数组。
                    </description>
                </item>
            </list>
            为了与以前的X#应用程序兼容，nRows参数还接受False (.F.)和True (.T.)，分别代替0和1。<br/>
            当为nRows指定0或1时，记录指针保持在无法提交更改的记录上。
            要确定无法提交更改的原因，请使用AError()函数。<br/>
            使用<b>CursorAdapter</b>对象并为nRows指定1或2时，除非发生错误，否则必须在同一次调用<b>TableUpdate()</b>期间提交
            以下<b>CursorAdapter</b>事件中对游标所做的所有更改：
            <list type="bullet">
                <term>
                    <b>BeforeInsert</b>
                </term>
                <term>
                    <b>AfterInsert</b>
                </term>
                <term>
                    <b>BeforeDelete</b>
                </term>
                <term>
                    <b>AfterDelete</b>
                </term>
                <term>
                    <b>BeforeUpdate</b>
                </term>
                <term>
                    <b>AfterUpdate</b>
                </term>
            </list>
            X#将nRows的值传递给<b>CursorAdapter</b>的BeforeCursorUpdate事件。<br/><br/>

            <list type="table">
                <listheader>
                    <term>lForce</term>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>False (.F.)</term>
                    <description>
                        从第一条记录开始，向表或游标的末尾继续提交更改。
                        （默认）
                    </description>
                </item>
                <item>
                    <term>True (.T.)</term>
                    <description>
                        覆盖网络上另一用户对表或游标所做的任何更改。<b>Where</b>子句仅使用键字段。
                    </description>
                </item>
            </list>
            使用<b>CursorAdapter</b>对象时，X#将lForce的值传递给以下<b>CursorAdapter</b>事件：
            <list type="bullet">
                <term>BeforeCursorUpdate</term>
                <term>BeforeInsert</term>
                <term>BeforeUpdate</term>
                <term>BeforeDelete</term>
                <term>AfterInsert</term>
                <term>AfterUpdate</term>
                <term>AfterDelete</term>
            </list>
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Create Table employee (cLastName C(10))
                Set MultiLocks ON  &amp;&amp; 必须打开以启用表缓冲。
                = CursorSetProp('Buffering', 5, 'employee' )  &amp;&amp; 启用表缓冲。
                Insert Into employee (cLastName) VALUES ('Smith')
                Clear
                ? '原始cLastName值：'
                ?? cLastName  &amp;&amp; 显示当前cLastName值（Smith）。
                Replace cLastName WITH 'Jones'
                ? '新cLastName值：'
                ?? cLastName  &amp;&amp; 显示新cLastName值（Jones）。
                = TableUpdate(.T.)  &amp;&amp; 提交更改。
                ? '更新后的cLastName值：'
                ?? cLastName  &amp;&amp; 显示当前cLastName值（Jones）。
            </code>
        </example>
    </tableupdate>

    <target>
        <summary>
            返回作为关系目标的表的别名，该关系在 Set RELATION 的 Into 子句中指定。
        </summary>
        <param name="nRelationshipNumber">
            指定关系的编号。包括从 1 到指定工作区中关系数量的数字。
            目标表的别名将按无特定顺序返回，直到 nRelationshipNumber 大于关系数量。
            当 nRelationshipNumber 大于关系数量时，将返回空字符串。<br/>
        </param>
        <param name="uArea">
            返回另一个工作区中目标表的别名。uArea 指定工作区编号和表别名。
            默认情况下，如果不指定工作区或别名，将返回当前工作区中目标表的别名。
        </param>
        <returns>
            字符型
        </returns>
        <example>
             <code language="X#">
                Close Databases
                Open Database (HOME(2) + 'Data\testdata')
                Use orders IN 0 Order order_id
                Use customer IN 0 Order cust_id
                Select orders
                Set RELATION TO cust_id Into customer
                ? TARGET(1)  &amp;&amp; 显示 customer
                ? TARGET(2)  &amp;&amp; 空字符串
            </code>
        </example>
    </target>

    <textmerge>
        <summary>
            提供字符表达式的评估。
        </summary>
        <param name="cExpression">
            指定要评估的字符表达式。
        </param>
        <param name="lRecursive">
            指定是否重复遍历 cExpression 中所有级别的分隔符，评估直到不再有文本合并分隔符。
        </param>
        <param name="cLeftDelim">
            指定用于文本合并搜索的左分隔符。cLeftDelim 限制为两个字符。
        </param>
        <param name="cRightDelim">
            指定用于文本合并搜索的右分隔符。cRightDelim 限制为两个字符。
        </param>
        <returns>
            字符串。表示 cExpression 的值，即合并后的文本。
        </returns>
        <remarks>
            cLeftDelim 和 cRightDelim 参数临时覆盖任何 Set TEXTMERGE DELIMITERS 值。<br/>
            TEXTMERGE( ) 函数响应当前的 Set TEXTMERGE SHOW | NOSHOW 设置。
        </remarks>
        <example>
             <code language="X#">
                Set TEXTMERGE OFF
                TEXT to myvar noshow &amp;&amp;textm
                这是一个测试   &lt;&lt;datetime()&gt;&gt;
                &lt;&lt;program(-1)&gt;&gt;
                &lt;&lt;myvar&gt;&gt;
                textmerge(myvar) (这行是字面量)
                &lt;&lt;doit(myvar)&gt;&gt;   (引起递归
                原始文本结束
                endtext
                ?myvar
                ?"现在开始文本合并"
                ?textmerge(myvar)
                PROCEDURE doit(myvar)
                *  r=i   &amp;&amp; 引起错误
                if program(-1) &gt; 3
                return "结束*********"
                endif
                return textmerge(myvar)
            </code>
        </example>
    </textmerge>

    <ttoc>
        <summary>
            将 <b>DateTime</b> 表达式转换为指定格式的 <b>Character</b> 值。
        </summary>
        <param name="tExpression">
            指定要转换为字符串的 <b>DateTime</b> 表达式。<br/>
            如果 tExpression 仅包含时间，X# 会将默认日期 12/30/1899 添加到 tExpression。如果 tExpression 仅包含日期，
            X# 会添加默认时间 12:00:00 AM（如果 Set HOURS 为 12）或 00:00:00（如果 Set HOURS 为 24）到 tExpression 以生成有效的 DateTime 值。
        </param>
        <param name="nParam">
            <b>1</b>
            以适合索引的格式返回 tExpression 的字符串。返回的字符串具有 14 字符格式，
            yyyymmddhhmmss，不受 <b>Set CENTURY</b>、<b>Set HOURS</b> 或 <b>Set SECONDS</b> 命令的影响。
            有关更多信息，请参见 Set CENTURY、Set HOURS 和 Set SECONDS。
            <b>2</b>
            返回仅包含 tExpression 时间部分的字符串。<br/>
            要控制是否在字符串中包含时间部分的秒数，请设置 <b>Set SECONDS</b> 和 <b>Set DATE</b> 命令。
            <b>Set HOURS</b> 命令决定是否在返回的时间部分后附加 AM 或 PM。<br/>
            有关更多信息，请参见 Set DATE 和 Set HOURS。<br/>
            <note name="注意">
                如果 <b>Set DATE</b> 设置为 <b>LONG</b> 或 <b>SHORT</b>，Windows 控制面板中的时间设置格式将决定
                字符串的格式。
            </note>
            <b>3</b>
            以 XML DateTime 格式返回 tExpression 的字符串。返回的字符串具有 19 字符的 yyyy-mm-ddThh:mm:ss
            格式，不受 <b>Set CENTURY</b>、<b>Set HOURS</b> 或 <b>Set SECONDS</b> 命令设置的影响。
        </param>
        <returns>
            字符型。<b>TTOC( )</b> 将 <b>DateTime</b> 表达式作为字符串返回。
            <note name="注意">
                当传递值 1 或 3 作为第二个参数时，返回的字符串不包括 AM 或 PM 指示符来表示
                中午之前或之后的时间。相反，字符串使用 24 小时制，也称为军用时间。
                例如，时间 18:30:00 等同于 06:30:00 PM。
            </note>
        </returns>
        <remarks>
            如果传递无效值作为第二个参数，<b>TTOC( )</b> 会将无效值视为值 1 处理。
        </remarks>
        <example>
             <code language="X#">
                STORE DATETIME( ) TO gtDateTime
                ? "gtDateTime 的类型为: "+TYPE('gtDateTime')
                gtDateTime = TTOC(gtDateTime)
                ? "gtDateTime 现在的类型为: "+TYPE('gtDateTime')
            </code>
        </example>
    </ttoc>

    <txnlevel>
        <summary>
            返回表示当前事务级别的数值。
        </summary>
        <returns>
            TXNLEVEL( ) 返回值
            数值型
        </returns>
        <remarks>
            使用 BEGIN TRANSACTION 创建事务。当一个事务正在进行时，通过发出 BEGIN TRANSACTION 可以嵌套事务。
            事务可以以这种方式嵌套到五个级别。使用 TXNLEVEL( ) 确定当前事务级别。<br/>
            TXNLEVEL( ) 返回 0 到 5 之间的值。如果没有正在进行的事务，TXNLEVEL( ) 返回 0。
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Open Database (HOME(2) + 'Data\testdata')
                Use Customer     &amp;&amp; 打开客户表
                Clear

                BEGIN TRANSACTION
                    tLevel = ALLTRIM(STR(TXNLEVEL()))
                    =MessageBox("当前事务: " + tLevel, 0, "事务级别")

                    BEGIN TRANSACTION
                        tLevel = ALLTRIM(STR(TXNLEVEL()))
                        =MessageBox("当前事务: " + tLevel, 0, "事务级别")
                    END TRANSACTION
                END TRANSACTION
            </code>
        </example>
    </txnlevel>

    <txtwidth>
        <summary>
            返回一个字符表达式的长度，以指定字体的平均字符宽度为基准。
        </summary>
        <param name="cExpression">
            指定 TXTWIDTH( ) 返回长度的字符表达式。如果只包含 cExpression，则返回主 X# 窗口或活动输出窗口当前字体的字符表达式长度。
            非比例字体始终返回等于 cExpression 中字符数的值。<br/>
            包含可选参数 cFontName、nFontSize 和 cFontStyle 可确定特定字体、字体点大小或字体样式的字符表达式长度。
        </param>
        <param name="cFontName">
            指定字体的名称。包含 cFontName 以返回特定字体的字符表达式长度。
        </param>
        <param name="nFontSize">
            指定与字体点大小对应的数字。包含 nFontSize 以返回特定点大小的字符表达式长度。
        </param>
        <param name="cFontStyle">
            为字符表达式指定特殊字体样式。cFontStyle 是由一个字符或一组字符指定的字体样式代码。
            如果未包含 cFontStyle，则使用普通字体样式。每种字体样式的字符可在备注部分找到。
        </param>
        <returns>
            数值型
        </returns>
        <remarks>
            TXTWIDTH( ) 返回字符表达式 cExpression 所占用的字符数，基于指定字体的平均字符宽度（字体的平均字符宽度称为 foxel）。
            使用 FontMetric(6) 确定字体的平均字符宽度。<br/>
            如果在 TXTWIDTH( ) 中不包含字体，则 TXTWIDTH( ) 返回的值由主 X# 窗口的当前字体决定，
            前提是在发出 TXTWIDTH( ) 时输出指向主 X# 窗口。如果输出指向用户定义的窗口，
            则返回值由该窗口的当前字体决定。
            <list type="table">
                <listheader>
                    <term>字符</term>
                    <description>字体样式</description>
                </listheader>
                <item>
                    <term>B</term>
                    <description>粗体</description>
                </item>
                <item>
                    <term>I</term>
                    <description>斜体</description>
                </item>
                <item>
                    <term>N</term>
                    <description>普通</description>
                </item>
                <item>
                    <term>O</term>
                    <description>轮廓</description>
                </item>
                <item>
                    <term>Q</term>
                    <description>不透明</description>
                </item>
                <item>
                    <term>S</term>
                    <description>阴影</description>
                </item>
                <item>
                    <term>-</term>
                    <description>删除线</description>
                </item>
                <item>
                    <term>T</term>
                    <description>透明</description>
                </item>
                <item>
                    <term>U</term>
                    <description>下划线</description>
                </item>
            </list>
            您可以包含多个字符来指定字体样式的组合。例如，BI 指定粗斜体字体样式。<br/>
            以下命令以 Courier 普通 24 点字体在主 X# 窗口中水平居中显示一条消息：
             <code language="X#">
                @ 25,(WCOLS( )-TXTWIDTH('你好！','Courier ',24)* ;
                FontMetric(6,'Courier ',24)/FontMetric(6))/2  ;
                SAY '你好！' FONT 'Courier ',24
            </code>
        </remarks>
    </txtwidth>

    <vartype>
        <summary>
            返回表达式的数据类型。
            <note name="注意">
                <b>VARTYPE( )</b>类似于<b>TYPE( )</b>函数，但<b>VARTYPE( )</b>更快，且不需要引号
                来包围要返回数据类型的表达式。
            </note>
        </summary>
        <param name="eExpression">
            指定要返回数据类型的表达式。<b>VARTYPE( )</b>返回一个单字符
            表示表达式的数据类型。<br/>
            备注部分的表格列出了<b>VARTYPE( )</b>为每种数据类型返回的字符。
        </param>
        <param name="lNullDataType">
            指定当eExpression包含空值时<b>VARTYPE( )</b>是否返回数据类型。
            备注部分的表格列出了lNullDataType的值。
        </param>
        <returns>
            字符。<b>VARTYPE( )</b>返回一个字符，表示指定表达式的数据类型。
        </returns>
        <remarks>
            <list type="table">
                <listheader>
                    <term>返回值</term>
                    <description>数据类型</description>
                </listheader>
                <item>
                    <term>C</term>
                    <description>
                        <b>字符</b>、<b>备注</b>、<b>可变字符</b>、<b>可变字符</b>（二进制）
                    </description>
                </item>
                <item>
                    <term>D</term>
                    <description>
                        <b>日期</b>
                    </description>
                </item>
                <item>
                    <term>G</term>
                    <description>
                        <b>通用</b>
                    </description>
                </item>
                <item>
                    <term>L</term>
                    <description>
                        <b>逻辑</b>
                    </description>
                </item>
                <item>
                    <term>N</term>
                    <description>
                        <b>数值</b>、<b>浮点</b>、<b>双精度</b>或<b>整数</b>
                    </description>
                </item>
                <item>
                    <term>O</term>
                    <description>对象</description>
                </item>
                <item>
                    <term>Q</term>
                    <description>
                        <b>二进制大对象</b>、<b>可变二进制</b>
                    </description>
                </item>
                <item>
                    <term>T</term>
                    <description>
                        <b>日期时间</b>
                    </description>
                </item>
                <item>
                    <term>U</term>
                    <description>未知或变量不存在</description>
                </item>
                <item>
                    <term>X</term>
                    <description>空值</description>
                </item>
                <item>
                    <term>Y</term>
                    <description>
                        <b>货币</b>
                    </description>
                </item>
            </list>
            <note name="注意">如果eExpression是一个数组，将评估数组中的第一个元素。</note>
            <list>
                <listheader>
                    <term>lNullDataType</term>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>True (.T.)</term>
                    <description>返回eExpression的数据类型。</description>
                </item>
                <item>
                    <term>False (.F.)或省略</term>
                    <description>返回'X'表示eExpression包含空值。</description>
                </item>
            </list>
        </remarks>
    </vartype>

    <wvisible>
        <summary>
            确定指定的窗口是否已被激活且未被隐藏。
        </summary>
        <param name="WindowName">
            指定 WVISIBLE( ) 评估的窗口名称。在 X# 中，您还可以指定工具栏的名称。
            您也可以在 WindowName 中包含空字符串来指定主 X# 窗口。
        </param>
        <returns>
            逻辑型
        </returns>
        <remarks>
            如果指定的窗口已显示或激活且未被隐藏，WVISIBLE( ) 返回真 (.T.)。
            窗口通过 SHOW WINDOW 和 ACTIVATE WINDOW 显示和激活。<br/>
            如果窗口尚未激活，已通过 HIDE WINDOW 隐藏，已通过 DEACTIVATE WINDOW 停用，或不存在，
            WVISIBLE( ) 返回假 (.F.)。
        </remarks>
        <example>
             <code language="X#">
                ACTIVATE WINDOW View
                ? WVISIBLE( "View" ) &amp;&amp; 返回 .T.
                DEACTIVATE WINDOW View
                ? WVISIBLE( "View" ) &amp;&amp; 返回 .F.
            </code>
        </example>
    </wvisible>

    <xmltocursor>
        <summary>
            将XML文本转换为X#游标或表。
        </summary>
        <param name="eExpression">
            指定XML文本或评估为有效XML数据的表达式。eExpression参数可以是X#内存变量、
            备注字段内容、HTTP请求的返回、SOAP方法调用的返回结果、来自XMLDOM的XML或ADO流。<br/>
            <note name="注意">如果未找到eExpression或eExpression无法解析为有效的XML，XMLTOCURSOR()将生成错误。</note>
        </param>
        <param name="cXMLFile">
            指定位于本地计算机或网络上的物理XML文件的名称，以及可选的路径。<br/>
            如果未指定路径，X#将沿X#目录路径搜索XML文件。
        </param>
        <param name="cCursorName">
            指定用于存储结果的游标名称，并在当前工作区创建游标。<br/>
            如果游标名称已存在或已打开，X#将关闭该游标并在未使用的工作区创建一个新游标。
            如果省略cCursorName或传递空字符串("")，X#将创建名为"XMLRESULT"的游标来返回结果。<br/>
            如果cCursorName包含数据且nFlags设置为8192，X#将从XML文件导入的数据附加到现有表或游标。
            表或游标必须打开或正在使用。如果cCursorName为空字符串("")，X#将XML导入到当前工作区中打开的表或游标。
        </param>
        <param name="nFlags">
            指定如何在<b>XMLTOCURSOR()</b>中处理XMLSource eExpression。备注部分的表格描述了nFlags的值。
        </param>
        <returns>
            数值数据类型。<b>XMLTOCURSOR()</b>返回创建的记录数。
        </returns>
        <remarks>
            您可以将<b>XMLTOCURSOR()</b>与X#的OLE DB提供程序一起使用。但是，<b>_VFP</b> <b>VFPXMLProgID</b>属性不
            受支持，因为OLE DB提供程序不支持<b>_VFP</b>系统变量。<br/>
            要将X# OLE DB提供程序与<b>XMLTOCURSOR()</b>一起使用，您必须在安装OLE DB提供程序的计算机上安装MSXML 3.0。<br/><br/>
            对于长度超过约160列的记录，<b>XMLTOCURSOR()</b>会生成语法错误。导致错误的确切列数取决于列名的长度。<br/><br/>
            从XML文档创建游标时，<b>XMLTOCURSOR()</b>不使用<b>Varchar</b>类型。但是，<b>XMLTOCURSOR()</b>
            支持将数据附加到具有<b>Varchar</b>字段的现有游标中。<br/>
            在追加模式下调用<b>XMLTOCURSOR()</b>时，如果没有XML元素名称与任何表或游标列匹配，X#会添加一个空行。<br/><br/>
            <b>XMLTOCURSOR()</b>将<b>Decimal</b>数据类型转换为<b>Numeric</b> 20,19（宽度，精度）。在X# 8.0之前的版本中，
            <b>Decimal</b>映射到<b>Numeric</b> 8,0。<br/><br/>
            <b>数值溢出条件</b>   <b>XMLTOCURSOR()</b>导入包含X#数值溢出条件的XML数据，例如，
            在数值或整数值的位置使用"*******"。如果提供了架构，X#会在结果游标中创建正确的数据类型，但
            将溢出从星号(*)字符更改为0.0或0值。因此，<b>XMLTOCURSOR()</b>使用的XML解析器不会因
            存储在小数类型元素中的字符值而引发错误。<br/>
            有关将XML转换为X#数据的更多信息，请参阅"在XML和X#数据之间转换"。
            <list type="table">
                <listheader>
                    <term>nFlags</term>
                    <description>位</description>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>0000</description>
                    <description>（默认）将第一个参数视为包含XML数据的字符串。</description>
                </item>
                <item>
                    <term>4</term>
                    <description>0100</description>
                    <description>保留数据中的空白，并覆盖XML数据的xml:space属性。</description>
                </item>
                <item>
                    <term>512</term>
                    <description>01000000000</description>
                    <description>
                        指定第一个参数（eExpression或cXMLFile）是包含XML数据文件名称和路径的字符串。
                    </description>
                </item>
                <item>
                    <term>1024</term>
                    <description>10000000000</description>
                    <description>
                        NOCPTRANS – 在结果游标中创建带有NOCPTRANS选项的<b>Character</b>和<b>Memo</b>字段，并将传入元素中的文本或
                        XML值以未翻译的、逐字节的方式插入到<b>Character</b>或<b>Memo</b>字段中。<br/>
                        当与标志1024一起使用时，<b>XMLTOCURSOR( )</b>返回一个用尾随空格填充的字符串，长度等于实际字符串的两倍。
                    </description>
                </item>
                <item>
                    <term>2048</term>
                    <description>100000000000</description>
                    <description>
                        当导入的架构包含具有限制（或分面）的XML架构定义（XSD）架构时使用，
                        totalDigits="19"和fractionDigits="4"。<br/>
                        XSD数据类型值在结果游标中映射为X# <b>Currency</b>数据类型。
                    </description>
                </item>
                <item>
                    <term>4096</term>
                    <description>1000000000000</description>
                    <description>
                        禁用<b>base64</b>解码。<br/>
                        在X#中，base64编码仅用于编码二进制数据。
                    </description>
                </item>
                <item>
                    <term>8192</term>
                    <description>1100000000</description>
                    <description>
                        指定cCursorName是现有表或游标的名称或别名，并将指定XML文件中的数据导入到
                        现有表或预定义游标中。<br/>
                        如果cCursorName包含数据，则从XML文件导入的数据将附加到现有数据。
                        如果cCursorName为空字符串（""），则XML文件中的数据将导入到当前工作区的表或游标中。<br/>
                        当XML架构不可用或不实用时，将nFlags设置为8192可能很有用。
                    </description>
                </item>
                <item>
                    <term>32768</term>
                    <description>0x8000</description>
                    <description>表示应使用代码页。</description>
                </item>
                <item>
                    <term>65536</term>
                    <description>0x10000</description>
                    <description>将XML Char字段映射到原生Fox Varchar字段。如果未指定，XML Char字段将映射到Fox Character字段。</description>
                </item>
                <item>
                    <term>131072</term>
                    <description>0x20000</description>
                    <description>
                        将XML base64Binary字段映射到原生Fox Varbinary字段（如果小于255字节）或Blob字段（如果大于此长度）。
                        如果未指定，XML base64Binary字段将映射到Fox Memo字段。
                    </description>
                </item>
            </list>
            使用标志8192时，请注意以下几点：
            <list type="bullet">
                <term>
                    您必须确保表架构以适当的方式匹配传入的XML元素。
                    X#按照本主题中的数据类型匹配表所述强制执行cCursorName中的数据类型，但不对数据类型做其他假设。
                    尝试导入不兼容的值会生成相应的消息。
                </term>
                <term>
                    如果XML包含或引用架构，且架构中的数据类型与游标或表的数据类型冲突，
                    则使用游标或表中的数据类型。
                </term>
                <term>
                    XML文件中的元素名称映射到cCursorName中的列名。此外，X#仅从XML文件中
                    与cCursorName中列名匹配的元素名称导入数据。
                </term>
                <term>
                    游标或表的列数可以少于XML文件中的列数，但必须至少有一个匹配的列。
                    游标或表可以有额外的列，这些列不对应XML文件中的元素。
                </term>
                <term>
                    如果表包含自动递增字段，当<b>AutoIncERROR</b>设置为<b>ON</b>时，<b>XMLTOCURSOR( )</b>将失败。
                    将<b>AutoIncERROR</b>设置为<b>OFF</b>或使用<b>CursorSetProp( )</b>关闭目标表中的自动递增，
                    可以使<b>XMLTOCURSOR( )</b>成功。目标表的自动递增字段根据指定的值递增，
                    源表中的值不会被复制。
                </term>
            </list>
            下表描述了将nFlags设置为8192时的数据类型匹配限制。
            <list type="table">
                <listheader>
                    <term>X#数据类型</term>
                    <description>行为</description>
                </listheader>
                <item>
                    <term>
                        <b>Character</b>、<b>Character</b> (Binary)、<b>Memo</b>、<b>Memo</b> (Binary)
                    </term>
                    <description>
                        接受任何数据，但截断超出<b>Character</b>列长度的任何数据。
                    </description>
                </item>
                <item>
                    <term>
                        <b>Currency</b>
                    </term>
                    <description>
                        接受<b>Currency</b>类型接受范围内的数值数据，但截断此范围之外的数字。
                    </description>
                </item>
                <item>
                    <term>
                        <b>Date</b>
                    </term>
                    <description>
                        接受XML格式的日期和dateTime值。<br/>
                        X#将XML日期和dateTime格式转换为相应的X#日期。
                        X#仅保留XML日期或dateTime值的M/D/Y部分。
                    </description>
                </item>
                <item>
                    <term>
                        <b>DateTime</b>
                    </term>
                    <description>
                        X#将XML日期和dateTime格式转换为相应的X#日期，并丢弃超出X#支持范围的精度。
                    </description>
                </item>
                <item>
                    <term>
                        <b>Double</b>
                    </term>
                    <description>
                        接受<b>Double</b>类型接受范围内的数值数据，但截断此范围之外的数字。
                    </description>
                </item>
                <item>
                    <term>
                        <b>Integer</b>
                    </term>
                    <description>
                        接受<b>Integer</b>类型接受范围内的整数数据，但截断此范围之外的数字。
                    </description>
                </item>
                <item>
                    <term>
                        <b>Logical</b>
                    </term>
                    <description>接受值True、.T.、1、False、.F.和0。</description>
                </item>
                <item>
                    <term>
                        <b>Numeric</b>、<b>Float</b>
                    </term>
                    <description>
                        接受有或没有小数的数值数据，但根据X#规则截断这些类型接受范围之外的数字
                        或替换为数值溢出指示符（"*************"）。
                    </description>
                </item>
            </list>
        </remarks>
    </xmltocursor>

    <xmlupdategram>
        <summary>
            将缓冲表或游标中的更改镜像到XML UpdateGram中，并返回包含UpdateGram的字符串。<br/>
            XML UpdateGram表示X#表或游标中已更改部分的前后状态。通过额外的处理，
            您可以使用UpdateGram将这些更改提交到XML UpdateGram文档所代表的数据。
            <note name="注意">
                要使用<b>XMLUpdateGRAM( )</b>，您必须使用<b>Set MultiLocks ON</b>并启用表缓冲。
            </note>
            <note name="提示">
                在调用<b>XMLUpdateGRAM( )</b>之前，您应该通过对现有游标和表调用<b>CursorSetProp( )</b>
                并使用<b>KeyFieldList</b>属性来指定键字段列表。如果不指定键字段，
                前后表示中都将包含表中的所有字段。如果指定一个或多个键字段，只有这些字段会出现在前部分。
            </note>
        </summary>
        <param name="cAliasList">
            指定要包含在XML UpdateGram中的打开表或游标的逗号分隔列表，可以按名称或工作区号列出，或两者的任意组合。
            如果不为cAliasList指定值或指定空字符串（""），X#将使用当前数据会话中所有包含缓冲更改的打开表和游标。
        </param>
        <param name="nFlags">
            指定是否返回格式化文件。备注部分的表格列出了nFlags的累加标志。
        </param>
        <param name="cSchemaLocation">
            指定映射架构（如果存在）的名称和位置。
            <note name="注意">您必须提供映射架构。</note>
            例如，假设您将名为<c>mySchema.xsd</c>的架构传递给cSchemaLocation，创建的UpdateGram将包含一个映射架构属性，
            如以下XML所示：
             <code language="X#">
                &lt;ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram"&gt;
                &lt;updg:sync mapping-schema="mySchema.xsd" &gt;
                &lt;updg:before&gt;
            </code>
        </param>
        <returns>
            字符数据类型。<b>XMLUpdateGRAM( )</b>返回一个包含XML UpdateGram的字符串。
        </returns>
        <remarks>
            您可以将<b>XMLUpdateGRAM( )</b>与X#的OLE DB提供程序一起使用。但是，<b>_VFP</b> <b>VFPXMLProgID</b>属性不受支持，
            因为OLE DB提供程序不支持<b>_VFP</b>系统变量。
            <note name="注意">
                要将X# OLE DB提供程序与<b>XMLUpdateGRAM( )</b>一起使用，
                您必须在安装OLE DB提供程序的计算机上安装MSXML 3.0。
            </note>
            SQL Server和Visual Studio支持DiffGram格式来更新XML。但是，SQL XML需要映射架构来支持此格式。
            因此，<b>XMLUpdateGRAM( )</b>不支持此格式。<br/>
            为避免<b>XMLUpdateGRAM( )</b>在包含<b>Memo</b>或<b>General</b>字段的表上可能产生的错误，
            请使用<b>CursorSetProp( )</b>函数。以下示例展示了如何通过使用<b>CursorSetProp( )</b>设置
            <b>KeyFieldList</b>属性来在XML UpdateGram中包含备注数据：
             <code language="X#">
                Set MultiLocks ON
                Create CURSOR Test (mField M, cField I AutoInc)
                Insert Into Test (mField) VALUES ("123456789")
                Insert Into Test (mField) VALUES ("23456789")
                Insert Into Test (mField) VALUES ("3456789")
                Insert Into Test (mField) VALUES ("456789")
                CursorSetProp("Buffering",5)
                CursorSetProp("keyfieldlist",'cField')
                Update Test Set mField = "XXXXXXX" Where cField &lt; 3
                StrToFile(XMLUpdateGRAM(),'xmlupdate.txt')
                MODIFY FILE xmlupdate.txt
                RETURN
            </code>
            要将XML UpdateGram中的备注数据写入SQL Server，您必须在SQL Server上使用显式架构，
            并在XML UpdateGram中引用该架构。<br/>
            与<b>CURSORTOXML( )</b>函数不同，<b>XMLUpdateGRAM( )</b>忽略<b>Set Fields</b>语句，直接从底层游标读取。
            要在调用<b>XMLUpdateGRAM( )</b>之前更改表结构，您必须将数据复制到新游标中。例如，
            要将<b>Numeric</b>字段更改为<b>Currency</b>字段，以下示例使用SQL <b>Select</b>语句创建新游标，
            并将该游标与<b>XMLUpdateGRAM( )</b>一起使用。该示例将Total_Price字段转换为货币字段，使用
            <b>CursorSetProp( )</b>启用缓冲，使用<b>Replace</b>命令添加销售税，并使用
            <b>XMLUpdateGRAM( )</b>函数创建XML UpdateGram。
             <code language="X#">
                Select OrderID, CustID, NTOM(Total_Price) as Total_Price;
                From Orders Into CURSOR New_Orders READWRITE
                CursorSetProp("Buffering", 5, "New_Orders")
                Replace Total_Price WITH (Total_Price * 1.083)
                cXMLUpdg = XMLUpdateGRAM("New_Orders")
            </code>
            使用标志32768时，标志16和32的设置可能会影响应用哪个代码页，这取决于您要写入XML的数据类型。
            以下表格显示了可能的设置组合及每种组合应用的代码页。<br/>
            对于使用32768标志设置写入的XML文档，应用以下代码页。
            <list type="table">
                <item>
                    <term>标志16</term>
                    <description>标志32</description>
                    <description>设置标志32768</description>
                </item>
                <item>
                    <term>未设置</term>
                    <description>未设置</description>
                    <description>
                        XML文档：Windows-1252。
                        Unicode数据：代码页1252。
                        字符数据：默认代码页，除非字段标记为<b>NOCPTRANS</b>。
                    </description>
                </item>
                <item>
                    <term>True (.T)</term>
                    <description>未设置</description>
                    <description>
                        XML文档：游标的<b>CodePage</b>属性。如果XMLField <b>CodePage</b>属性大于零(0)
                        且与游标的代码页不匹配，则报告错误。<br/>
                        Unicode数据：游标对象的<b>Code page</b>属性。<br/>
                        字符数据：无。改用来自X#表(.dbf)的原始数据。
                    </description>
                </item>
                <item>
                    <term>未设置</term>
                    <description>设置</description>
                    <description>
                        XML文档：UTF-8代码页。<br/>
                        Unicode数据：UTF-8代码页。<br/>
                        字符数据：默认代码页，除非字段标记为<b>NOCPTRANS</b>，
                        在这种情况下不会进行额外的字符转换为UTF-8。
                    </description>
                </item>
                <item>
                    <term>设置</term>
                    <description>设置</description>
                    <description>
                        XML文档：UTF-8代码页。<br/>
                        Unicode数据：UTF-8代码页。<br/>
                        字符数据：默认代码页，除非字段标记为<b>NOCPTRANS</b>，
                        在这种情况下，使用<b>SYS(3005)</b>设置将数据转换为UTF-8。
                    </description>
                </item>
            </list>
            对于未设置32768标志写入的XML文档，应用以下代码页。
            <list type="table">
                <item>
                    <term>标志16</term>
                    <description>标志32</description>
                    <description>不带32768标志</description>
                </item>
                <item>
                    <term>未设置</term>
                    <description>未设置</description>
                    <description>
                        XML文档：Windows-1252。<br/>
                        Unicode数据：代码页1252。<br/>
                        字符数据：默认代码页，除非字段标记为<b>NOCPTRANS</b>。
                    </description>
                </item>
                <item>
                    <term>True (.T)</term>
                    <description>未设置</description>
                    <description>
                        XML文档：游标的<b>CodePage</b>属性。
                        字符数据：无。改用来自X#表(.dbf)的原始数据。
                        Unicode数据：游标对象的代码页属性。
                    </description>
                </item>
                <item>
                    <term>未设置</term>
                    <description>设置</description>
                    <description>
                        XML文档：UTF-8代码页。
                        Unicode数据：UTF-8代码页。
                        字符数据：默认代码页，除非字段标记为<b>NOCPTRANS</b>，在这种情况下不会进行额外的字符转换为UTF-8。
                    </description>
                </item>
                <item>
                    <term>设置</term>
                    <description>设置</description>
                    <description>
                        XML文档：UTF-8代码页。<br/>
                        Unicode数据：UTF-8代码页。<br/>
                        字符数据：默认代码页，除非字段标记为<b>NOCPTRANS</b>，在这种情况下，
                        它们使用当前<b>SYS(3005)</b>设置的代码页转换为UTF-8。
                    </description>
                </item>
            </list>
            有关将XML转换为X#数据的更多信息，请参阅"在XML和X#数据之间转换"。
            <list type="table">
                <listheader>
                    <term>nFlag</term>
                    <description>位</description>
                    <description>输出描述</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>0000</description>
                    <description>（默认）使用UTF-8格式的XML。</description>
                </item>
                <item>
                    <term>1</term>
                    <description>0001</description>
                    <description>使用未格式化的XML，例如连续字符串XML。</description>
                </item>
                <item>
                    <term>2</term>
                    <description>0010</description>
                    <description>用开放和关闭元素包围空元素，例如&lt;cc04&gt;&lt;/cc04&gt;。</description>
                </item>
                <item>
                    <term>4</term>
                    <description>0100</description>
                    <description>保留字段中的空白。</description>
                </item>
                <item>
                    <term>8</term>
                    <description>1000</description>
                    <description>将Memo字段包装在CDATA部分中。</description>
                </item>
                <item>
                    <term>16</term>
                    <description>10000</description>
                    <description>输出编码。</description>
                </item>
                <item>
                    <term>32</term>
                    <description>100000</description>
                    <description>输出编码。</description>
                </item>
                <item>
                    <term>32768</term>
                    <description>无</description>
                    <description>表示应使用代码页。</description>
                </item>
            </list>
            <note name="注意">
                当输出编码为UTF-8（默认）时，XML声明不包含Encoding=属性
                （无编码属性 = UTF-8）。
            </note>
            当输出编码设置为默认为游标或表的代码页时，编码属性将根据以下表格写入。
            <note name="注意">通过组合第4位和第5位（0010000）设置编码标志。</note>
            <list type="table">
                <listheader>
                    <term>编码标志</term>
                    <description>第4位和第5位</description>
                    <description>描述</description>
                </listheader>
                <item>
                    <term>+0</term>
                    <description>00</description>
                    <description>（默认）Windows 1252</description>
                </item>
                <item>
                    <term>+16</term>
                    <description>01</description>
                    <description>将输出编码属性设置为游标的代码页。</description>
                </item>
                <item>
                    <term>+32</term>
                    <description>10</description>
                    <description>将输出编码属性设置为UTF-8（无字符转换）。</description>
                </item>
                <item>
                    <term>+48</term>
                    <description>11</description>
                    <description>将输出编码属性设置为UTF-8，并将双字节字符转换为UTF-8。</description>
                </item>
            </list>
        </remarks>
    </xmlupdategram>

    <execscript>
        <summary>
            允许您在运行时从变量、表格和其他文本中执行多行代码。
        </summary>
        <param name="cExpression">
            表示要作为代码执行的文本、变量、字符串类型或备注。
        </param>
        <param name="eParameter1">
            可选。指定传递给脚本的参数，该脚本在第一行有 PARAMETERS 或 LPARAMETERS 语句。
        </param>
        <param name="eParameter2">
            可选。指定传递给脚本的参数，该脚本在第一行有 PARAMETERS 或 LPARAMETERS 语句。
        </param>
        <param name="eParameterN">
            可选。指定传递给脚本的参数，该脚本在第一行有 PARAMETERS 或 LPARAMETERS 语句。
        </param>
        <returns>
            返回值是 cExpression 中脚本返回的值。如果脚本没有返回值，X# 返回 NIL。
        </returns>
        <remarks>
            ExecScript() 允许您执行代码块而无需先编译。<br/>
            您可以在脚本中使用所有允许的语句，创建对象，
            设置它们的属性，调用方法和调用函数。<br/>
        </remarks>
        <example>
            <code language="X#">?ExecScript("? 'Hello world from X# ExecScript'")</code>
        </example>
    </execscript>
</Runtimefunctions>
