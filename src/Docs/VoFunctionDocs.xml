<?xml version="1.0" encoding="utf-8"?>
<Runtimefunctions>
  <aadd>
    <summary>
      Add a new element to the end of an array.
    </summary>

    <param name="aTarget">The array to add a new element to.</param>
    <param name="uNewElement">
      The value assigned to the new element.<br/>
      If <paramref name="uNewElement" /> is another array, the new element in the target array will contain a reference to the array specified by <paramref name="uNewElement" />, rather than the array itself.
    </param>
    <param name="nElement">
      The position within the array of the element to which the new value is assigned. If <paramref name="nElement">nElement</paramref> is not specified, the value is assigned to the last element.
    </param>
    <returns>
      The value of <paramref name="uNewElement" />.
    </returns>
    <remarks>
      AAdd() increases the actual length of the target array by one. <br/>
      The newly created array element is assigned the value specified by <paramref name="uNewElement" />.<br/>
      AAdd() is used to dynamically increase the size of an array. <br/>
      It is useful for building dynamic lists or queues. <br/>
      A good example of this is the GetList array used to hold Get objects.<br/>
      AAdd() is similar to ASize() but only adds one element at a time; ASize() can change an array to a specified size.<br/>
      AAdd(), however, has the advantage that it can assign a value to the new element, while ASize() cannot.<br/>
      AAdd() seems similar to AIns(), but they are different: AIns() moves elements within an array, but it does not change the array's length.<br/>
    </remarks>
    <example>
      These examples show what happens when you invoke AAdd() more than once:
      <code language="X#">
        LOCAL aArray AS ARRAY
        aArray := {}&#0009;&#0009;&#0009;&#0009;&#0009;// aArray is an empty array
        AAdd(aArray, 5)&#0009;&#0009;&#0009;// aArray is {5}
        AAdd(aArray, 10)&#0009;&#0009;&#0009;// aArray is {5, 10}
        AAdd(aArray, {12, 10})&#0009;&#0009;// aArray is {5, 10, {12, 10}}
        AAdd(aArray, 1, 2 )&#0009;&#0009;// aArray is  5, 2, 10, {12, 10}}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AIns'>AIns</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASize'>ASize</seealso>
  </aadd>
  <abs>
    <summary>
      Return the absolute value of a numeric expression, regardless of its sign.
    </summary>

    <param name="nValue">The numeric expression to evaluate.</param>
    <returns>
      A positive number or 0.
    </returns>
    <remarks>
      Absolute value is the same as <paramref name="nValue" /> if <paramref name="nValue" /> is greater than or equal to 0.<br/>
      It is the negation of <paramref name="nValue" /> if <paramref name="nValue" /> is less than 0.<br/>
      Abs() lets you get the difference between the magnitude of<br/>
      two numbers, where magnitude is the distance from the origin or zero.
    </remarks>
    <example>
      These examples show typical results from Abs():
      <code language="X#">
        nNum1 := 100
        nNum2 := 150
        ? nNum1 - nNum2&#0009;&#0009;&#0009;&#0009;// -50
        ? ABS(nNum1 - nNum2)&#0009;&#0009;&#0009;//  50
        ? ABS(nNum2 - nNum1)&#0009;&#0009;&#0009;//  50
        ? ABS(-12)&#0009;&#0009;&#0009;&#0009;&#0009;//  12
        ? ABS(0)&#0009;&#0009;&#0009;&#0009;&#0009;//  0
        nSouth := -5
        nNorth := 4
        ? ABS(nSouth) - ABS(nNorth)&#0009;&#0009;// 1
        ? ABS(nSouth) &gt; ABS(nNorth)&#0009;&#0009;// TRUE
        ? nSouth &gt; nNorth&#0009;&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AbsFloat'>AbsFloat</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsInt'>AbsInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsLong'>AbsLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal4'>AbsReal4</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal8'>AbsReal8</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsShort'>AbsShort</seealso>
  </abs>
  <absfloat>
    <summary>
      Return the absolute value of a strongly typed numeric expression, regardless of its sign.
    </summary>

    <param name="fValue">The floating point number to evaluate.</param>
    <returns>
      A positive number or 0.
    </returns>
    <remarks>
      AbsFloat() is the same as Abs() except that it is strongly typed.<br/>
      For more information, see Abs().
    </remarks>
    <example>
      These examples show typical results from AbsFloat():
      <code language="X#">
        LOCAL fNum1 := 99.99 AS FLOAT
        LOCAL fNum2 := 149.99 AS FLOAT
        ? fNum1 - fNum2&#0009;&#0009;&#0009;&#0009;// -50.00
        ? AbsFloat(fNum1 - fNum2)&#0009;&#0009;//  50.00
        ? AbsFloat(fNum2 - fNum1)&#0009;&#0009;//  50.00
        ? AbsFloat(-12)&#0009;&#0009;&#0009;&#0009;//  12
        ? AbsFloat(0)&#0009;&#0009;&#0009;&#0009;//  0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Abs'>Abs</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsInt'>AbsInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsLong'>AbsLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal4'>AbsReal4</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal8'>AbsReal8</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsShort'>AbsShort</seealso>
  </absfloat>
  <absint>
    <summary>
      Return the absolute value of a strongly typed numeric expression, regardless of its sign.
    </summary>

    <param name="liValue">The 32-bit integer to evaluate.</param>
    <returns>
      A positive number or 0.
    </returns>
    <remarks>
      AbsInt() is the same as Abs() except that it is strongly typed.<br/>
      For more information, see Abs().
    </remarks>
    <example>
      These examples show typical results from AbsInt():
      <code language="X#">
        LOCAL iNum1 := 100 AS INT
        LOCAL iNum2 := 150 AS INT
        ? iNum1 - iNum2&#0009;&#0009;&#0009;&#0009;// -50
        ? AbsInt(iNum1 - iNum2)&#0009;&#0009;//  50
        ? AbsInt(iNum2 - iNum1)&#0009;&#0009;//  50
        ? AbsInt(-12)&#0009;&#0009;&#0009;&#0009;//  12
        ? AbsInt(0)&#0009;&#0009;&#0009;&#0009;//  0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Abs'>Abs</seealso>
    <seealso cref='O:XSharp.RT.Functions.AbsFloat'>AbsFloat</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsLong'>AbsLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal4'>AbsReal4</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal8'>AbsReal8</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsShort'>AbsShort</seealso>
  </absint>
  <abslong>
    <summary>
      Return the absolute value of a strongly typed numeric expression, regardless of its sign.
    </summary>

    <param name="liValue">The 32-bit integer to evaluate.</param>
    <returns>
      A positive number or 0.
    </returns>
    <remarks>
      AbsLong() is the same as Abs() except that it is strongly typed. <br/>
      For more information, see Abs().
    </remarks>
    <example>
      These examples show typical results from AbsLong():
      <code language="X#">
        LOCAL liNum1 := 100 AS LONGINT
        LOCAL liNum2 := 150 AS LONGINT
        ? liNum1 - liNum2&#0009;&#0009;&#0009;&#0009;// -50
        ? AbsLong(liNum1 - liNum2)&#0009;&#0009;&#0009;//  50
        ? AbsLong(liNum2 - liNum1)&#0009;&#0009;&#0009;//  50
        ? AbsLong(-12)&#0009;&#0009;&#0009;&#0009;&#0009;//  12
        ? AbsLong(0)&#0009;&#0009;&#0009;&#0009;&#0009;//  0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Abs'>Abs</seealso>
    <seealso cref='O:XSharp.RT.Functions.AbsFloat'>AbsFloat</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsInt'>AbsInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal4'>AbsReal4</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal8'>AbsReal8</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsShort'>AbsShort</seealso>
  </abslong>
  <absreal4>
    <summary>
      Return the absolute value of a strongly typed numeric expression, regardless of its sign.
    </summary>

    <param name="r4Value">The 32-bit floating point number to evaluate.</param>
    <returns>
      A positive number or 0.
    </returns>
    <remarks>
      AbsReal4() is the same as Abs() except that it is strongly typed.<br/>
      For more information, see Abs().
    </remarks>
    <example>
      These examples show typical results from AbsReal4():
      <code language="X#">
        LOCAL r4Num1 := 99.99 AS REAL4
        LOCAL r4Num2 := 149.99 AS REAL4
        ? r4Num1 - r4Num2&#0009;&#0009;&#0009;&#0009;// -50.00
        ? AbsReal4(r4Num1 - r4Num2)&#0009;&#0009;&#0009;//  50.00
        ? AbsReal4(r4Num2 - r4Num1)&#0009;&#0009;&#0009;//  50.00
        ? AbsReal4(-12)&#0009;&#0009;&#0009;&#0009;&#0009;//  12
        ? AbsReal4(0)&#0009;&#0009;&#0009;&#0009;&#0009;//  0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Abs'>Abs</seealso>
    <seealso cref='O:XSharp.RT.Functions.AbsFloat'>AbsFloat</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsInt'>AbsInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsLong'>AbsLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal8'>AbsReal8</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsShort'>AbsShort</seealso>
  </absreal4>
  <absreal8>
    <summary>
      Return the absolute value of a strongly typed numeric expression, regardless of its sign.
    </summary>

    <param name="r8Value">The 64-bit floating point number to evaluate.</param>
    <returns>
      A positive number or 0.
    </returns>
    <remarks>
      AbsReal8() is the same as Abs() except that it is strongly typed.<br/>
      For more information, see Abs().
    </remarks>
    <example>
      These examples show typical results from AbsReal8():
      <code language="X#">
        LOCAL r8Num1 := 99.99 AS REAL8
        LOCAL r8Num2 := 149.99 AS REAL8
        ? r8Num1 - r8Num2&#0009;&#0009;&#0009;&#0009;// -50.00
        ? AbsReal8(r8Num1 - r8Num2)&#0009;&#0009;&#0009;//  50.00
        ? AbsReal8(r8Num2 - r8Num1)&#0009;&#0009;&#0009;//  50
        ? AbsReal8(-12)&#0009;&#0009;&#0009;&#0009;&#0009;//  12
        ? AbsReal8(0)&#0009;&#0009;&#0009;&#0009;&#0009;//  0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Abs'>Abs</seealso>
    <seealso cref='O:XSharp.RT.Functions.AbsFloat'>AbsFloat</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsInt'>AbsInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsLong'>AbsLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal4'>AbsReal4</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsShort'>AbsShort</seealso>
  </absreal8>
  <absshort>
    <summary>
      Return the absolute value of a strongly typed numeric expression, regardless of its sign.
    </summary>

    <param name="siValue">The 16-bit integer to evaluate.</param>
    <returns>
      A positive number or 0.
    </returns>
    <remarks>
      AbsShort() is the same as Abs() except that it is strongly typed.<br/>
      For more information, see Abs().
    </remarks>
    <example>
      These examples show typical results from AbsShort():
      <code language="X#">
        LOCAL siNum1 := 100 AS SHORTINT
        LOCAL siNum2 := 150 AS SHORTINT
        ? siNum1 - siNum2&#0009;&#0009;&#0009;&#0009;// -50
        ? AbsShort(siNum1 - siNum2)&#0009;&#0009;&#0009;//  50
        ? AbsShort(siNum2 - siNum1)&#0009;&#0009;&#0009;//  50
        ? AbsShort(-12)&#0009;&#0009;&#0009;&#0009;&#0009;//  12
        ? AbsShort(0)&#0009;&#0009;&#0009;&#0009;&#0009;//  0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Abs'>Abs</seealso>
    <seealso cref='O:XSharp.RT.Functions.AbsFloat'>AbsFloat</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsInt'>AbsInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsLong'>AbsLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal4'>AbsReal4</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal8'>AbsReal8</seealso>
  </absshort>
  <aclone>
    <summary>
      Duplicate a multidimensional array.
    </summary>

    <param name="aSource">The array to duplicate.</param>
    <returns>
      A duplicate of <paramref name="aSource" />.
    </returns>
    <remarks>
      AClone() creates a complete duplicate of <paramref name="aSource" />.<br/>
      If <paramref name="aSource" /> contains subarrays, AClone() creates matching subarrays and fills them with copies of the values in the <paramref name="aSource" /> subarrays.<br/>
      To copy subarrays by reference instead of creating new ones, use ACloneShallow().
    </remarks>
    <example>
      This example creates an array, then duplicates it using AClone().<br/>
      The first array is then altered, but the duplicate copy is unaffected:
      <code language="X#">
        LOCAL aOne, aTwo AS ARRAY
        aOne := {1, 2, 3}&#0009;&#0009;&#0009;// aOne is {1, 2, 3}
        aTwo := AClone(aOne)&#0009;&#0009;&#0009;// aTwo is {1, 2, 3}
        aOne[1] := 99&#0009;&#0009;&#0009;&#0009;// aOne is {99, 2, 3}
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// but aTwo is still {1,2,3}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ACloneShallow'>ACloneShallow</seealso>
    <seealso cref='O:XSharp.RT.Functions.ACopy'>ACopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.ADel'>ADel</seealso>
    <seealso cref='O:XSharp.RT.Functions.AIns'>AIns</seealso>
    <seealso cref='O:XSharp.RT.Functions.AReplicate'>AReplicate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASize'>ASize</seealso>
  </aclone>
  <acloneshallow>
    <summary>
      Duplicate an array without its subarrays.
    </summary>

    <param name="aSource">The array to duplicate.</param>
    <returns>
      A duplicate of <paramref name="aSource" /> without its subarrays.
    </returns>
    <remarks>
      ACloneShallow() creates a duplicate of <paramref name="aSource" />.<br/>
      Unlike AClone(), ACloneShallow() does not check to see if <paramref name="aSource" /> contains subarrays and does not copy them if they exist.<br/>
      ACloneShallow() also works differently from AClone() in that AClone() duplicates by recursively traversing the source array.<br/>
      ACloneShallow() first builds the target array structure from information derived directly from the source array, then copies the first-dimension values to the target.<br/>
      If an element of the source array is a subarray, the target array will contain a reference to the subarray.
    </remarks>
    <example>
      This example creates an array and duplicates it using ACloneShallow().<br/>
      Moreover, by changing an element in the source subarray that automatically affects the target subarray, it<br/>
      illustrates that subarrays are copied by reference:
      <code language="X#">
        LOCAL aSource, aTarget, aSourceSubArray AS ARRAY
        aSourceSubArray := {3,4,5}
        aSource := {1, 2, aSourceSubArray}
        aTarget := ACloneShallow(aSource)
        // aTarget is {1, 2, {3,4,5}}
        // Now change the source subarray
        aSourceSubArray[3] := 100
        // The change is also reflected in aTarget
        // aTarget is {1, 2, {3,4,100}}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AClone'>AClone</seealso>
  </acloneshallow>
  <arraycommon>
    <param name="nStart">
      The starting element.<br/>
      A negative value starts from the end.<br/>
      If <paramref name="nCount" /> is positive, the default value is 1; if <paramref name="nCount" /> is negative, the default value is the length of the array.
    </param>
    <param name="nCount">
      The number of elements to process from <paramref name="nStart" />.<br/>
      A negative value starts from the end.<br/>
      The default is all elements to the end of the array.
    </param>

  </arraycommon>
  <acopy>
    <summary>
      Copy elements from one array to another.
    </summary>
    <include file="VoFunctionDocs.xml" path="Runtimefunctions/arraycommon/*" />
    <param name="aSource">The array to copy elements from.</param>
    <param name="aTarget">The array to copy elements to.</param>
    <param name="nTargetPos">
      The starting element position in <paramref name="aTarget" /> to receive elements from <paramref name="aSource" />. <br/>
      The default value is 1.
    </param>
    <returns>
      A reference to <paramref name="aTarget" />.
    </returns>
    <remarks>
      ACopy() copies elements from <paramref name="aSource" /> to <paramref name="aTarget" />. <br/>
      <paramref name="aTarget" /> must already exist and be large enough to hold the copied elements. <br/>
      If <paramref name="aSource" /> has more elements, some elements will not be copied.
      ACopy() copies values of all data types. <br/>
      If an element of <paramref name="aSource" /> is a subarray, the corresponding element in <paramref name="aTarget" /> will contain only a reference to the subarray. <br/>
      Thus, ACopy() will not create a complete duplicate of a multidimensional array. <br/>
      To do this, use the AClone() function.
    </remarks>
    <example>
      This example creates two arrays, each filled with a value. <br/>
      The first two elements from the source array are then copied into the target array:
      <code language="X#">
        LOCAL nCount := 2, nStart := 1, aOne, aTwo
        aOne := {1, 1, 1}
        aTwo := {2, 2, 2}
        ACopy(aOne, aTwo, nStart, nCount)
        // aTwo is now {1, 1, 2}
      </code>
      This example copies an array in reverse order into another array:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL a1, a2 AS ARRAY
        &#0009;a1 := {1, 2, 3, 4, 5}
        &#0009;a2: = ArrayCreate(ALen(a1))
        &#0009;&#0009;// Start from end and step backwards
        &#0009;ACopy(a1, a2, -1, - 0xFFFF, 1)&#0009;// reverse array
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AClone'>AClone</seealso>
    <seealso cref='O:XSharp.RT.Functions.ADel'>ADel</seealso>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AFill'>AFill</seealso>
    <seealso cref='O:XSharp.RT.Functions.AIns'>AIns</seealso>
    <seealso cref='O:XSharp.RT.Functions.AReplicate'>AReplicate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASort'>ASort</seealso>
  </acopy>
  <acot>
    <summary>
      Calculate the arc cotangent of a number.
    </summary>

    <param name="nNum">Any numeric value.</param>
    <returns>
      A number between -PI/2 and PI/2, representing the angle, in radians, whose cotangent is equal to <paramref name="nNum" />.
    </returns>
    <remarks>
    </remarks>
    <example>
      This examples uses ACot() to find the angle whose cotangent is 20:
      <code language="X#">? ACot(20)&#0009;&#0009;&#0009;// .05 radians</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ATan'>ATan</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cos'>Cos</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cot'>Cot</seealso>
    <seealso cref='O:XSharp.RT.Functions.Sin'>Sin</seealso>
    <seealso cref='O:XSharp.RT.Functions.Tan'>Tan</seealso>
  </acot>
  <adel>
    <summary>
      Delete an array element.
    </summary>

    <param name="aTarget">The array to delete an element from.</param>
    <param name="dwPosition">The position of the element to delete.</param>
    <returns>
      A reference to <paramref name="aTarget" />.
    </returns>
    <remarks>
      When an element is deleted from an array, its content is lost, and all elements from that position to the end of the array are shifted up one element.<br/>
      The last element in the array becomes NIL.
    </remarks>
    <example>
      This example creates an array of three elements, then deletes the second element.<br/>
      The third element is moved up one position, and the new third element is assigned a NIL:
      <code language="X#">
        LOCAL aArray
        aArray := {1, 2, 3}&#0009;&#0009;// aArray is now {1, 2, 3}
        ADel(aArray, 2)&#0009;&#0009;&#0009;// aArray is now {1, 3, NIL}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ACopy'>ACopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.ADel'>ADel</seealso>
    <seealso cref='O:XSharp.RT.Functions.AFill'>AFill</seealso>
    <seealso cref='O:XSharp.RT.Functions.AIns'>AIns</seealso>
  </adel>
  <adir>
    <summary>
      Fill a series of arrays with directory information.
      Note:<br/>
      ADir() is a compatibility function and therefore not recommended.<br/>
      It is superseded by the Directory() function, which returns all file information in a multidimensional array.
    </summary>

    <param name="cFileSpec">
      The file specification for the directory search.<br/>
      Besides a file name, this specification may include an optional drive, directory, and extension.<br/>
      The file name and extension may include the standard wildcard characters (* and ?).<br/>
      If you do not specify a drive and directory, this function uses the SetDefault() setting.
    </param>
    <param name="acFileNames">
      The array to fill with the file names matching <paramref name="cFileSpec" />.<br/>
      Each element will contain the file name and extension as a string, in all uppercase letters.
    </param>
    <param name="anSizes">
      The array to fill with the sizes of the corresponding files in <paramref name="acFileNames" />.
    </param>
    <param name="adDates">
      The array to fill with the dates of the corresponding files in <paramref name="acFileNames" />.
    </param>
    <param name="acTimes">
      The array to fill with the times of the corresponding files in <paramref name="acFileNames" />, in the form hh:mO:ss.
    </param>
    <param name="acAttributes">
      The array to fill with attributes of the corresponding files in <paramref name="acFileNames" />.<br/>
      If <paramref name="acAttributes" /> is specified, hidden, system, and directory files are included as well as normal files.<br/>
      If <paramref name="acAttributes" /> is not specified, only normal files are included.
    </param>
    <returns>
      The number of files matching the directory skeleton described in <paramref name="cFileSpec" />.
    </returns>
    <remarks>
      ADir() performs two basic operations.<br/>
      First, it returns the number of files matching the file specification.<br/>
      Second, it fills a series of arrays with file names, sizes, dates, times, and attributes.<br/>
      Note that all of the array arguments must exist prior to calling this function and must be of a large enough size to hold the function results.
      <note type="tip">
        If you specify <paramref name="acAttributes" />, and <paramref name="cFileSpec" /> contains a pattern, such as "*.*" or "*.", that matches directory names, directories are included in <paramref name="acFileNames" />.<br/>
        They are indicated with an attribute value of "D."<br/>
        If ADir() is executed within a subdirectory, the first two entries of <paramref name="acFileNames" /> are "." and "..", the parent and current directory aliases.<br/>
        The date and time of last update are reported for directories, but the size of a directory is always 0.
      </note>
    </remarks>
    <example>
      This example creates an array to hold the names of all .TXT files in the current default directory, then uses AEval() to list them to the console:
      <code language="X#">
        LOCAL aFiles AS ARRAY
        aFiles := ArrayCreate(ADir("*.txt"))
        ADir("*.txt", aFiles)
        AEval(aFiles, {|element| QOut(element)})
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScan'>AScan</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASort'>ASort</seealso>
    <seealso cref='O:XSharp.RT.Functions.Directory'>Directory</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDefault'>SetDefault</seealso>
  </adir>
  <adjustfname>
    <summary>
      Remove spaces from a file name specified as a string.
    </summary>

    <param name="cFileName">The file name you want to adjust.</param>
    <returns>
      <paramref name="cFileName" /> with all spaces removed.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example shows how AdjustFName() removes the spaces from a file name without affecting the original file name:
      <code language="X#">
        cFile := "  BadFileName    .DBF"
        ? AdjustFName(cFile)    // "BadFileName.DBF"
        ? cFile                 // "  BadFileName    .DBF"
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AdjustFNameA'>AdjustFNameA</seealso>
  </adjustfname>
  <adjustfnamea>
    <summary>
      Remove spaces from a file name specified as a string, changing the contents of the original file name as well as the returned file name.
    </summary>

    <param name="cFileName">The file name you want to adjust.</param>
    <returns>
      <paramref name="cFileName" /> with all spaces removed.
    </returns>
    <remarks>
      AdjustFNameA() is the same as AdjustFName(), except that AdjustFNameA() removes the spaces from the original file name as well as those in the return value.
    </remarks>
    <example>
      This example shows how AdjustFNameA() returns a new file name with spaces removed and adjusts the original file name as well:
      <code language="X#">
        cFile := "  BadFileName    .DBF"
        ? AdjustFNameA(cFile)   // "BadFileName.DBF"
        ? cFile                 // "BadFileName.DBF"
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AdjustFName'>AdjustFName</seealso>
  </adjustfnamea>
  <aeval>
    <summary>
      Execute a code block for each element in an array.
    </summary>

    <param name="aArray">The array to traverse.</param>
    <param name="cbBlock">The code block to execute.</param>
    <include file="VoFunctionDocs.xml" path="Runtimefunctions/arraycommon/*" />
    <returns>
      A reference to <paramref name="aArray" />.<br/>
      The return value of the code block or is ignored — to assign the return value to each element in the array, use the AEvalA() function.
    </returns>
    <remarks>
      AEval() passes the element value and the element index as arguments.
      AEval() makes no assumptions about the contents of the array elements it is passing.<br/>
      It is assumed that the supplied code block knows what type of data will be in each element.
      AEval() is similar to DBEval() which executes code for each record of a database file.<br/>
      Like DBEval(), AEval() can be used as a primitive for the construction of iteration commands for both simple and complex array structures.
      <note type="tip">
        In Visual Objects 2 different functions were introduced: AEval() and AEvalOld(). The difference between these functions was that AEval() was only calling the codeblock with one parameter (the element in the array), where AEvalOld() was also passing in a second parameter (the array index). Inside X# this difference no longer exists. So AEval() and AEvalOld() are doing the same thing in X#.
      </note>
    </remarks>
    <example>
      This example displays the contents of a one-dimensional array:
      <code language="X#">
        LOCAL aArray[6]
        AFill(aArray, "Hi All!") // Fill up all elements
        AEval(aArray, {|Element| QOut(Element)})
      </code>
      This example uses AEval() to display an array of file names and file sizes returned from the Directory() function:
      <code language="X#">
        LOCAL aFiles := Directory("*.dbf")
        LOCAL nTotal := 0
        AEval(aFiles, {|aDBFFile | QOut(PadR(aDBFFile[F_NAME], 10), ;
        &#0009;&#0009;aDBFFile[F_SIZE], nTotal += aDBFFile[F_SIZE]})
        ? "Total bytes:", nTotal
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEvalA'>AEvalA</seealso>
    <seealso cref='O:XSharp.RT.Functions.AEvalOld'>AEvalOld</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanBinExact'>AScanBinExact</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanExact'>AScanExact</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbEval'>DBEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.QOut'>QOut</seealso>
    <seealso cref='O:XSharp.RT.Functions.SEval'>SEval</seealso>
  </aeval>
  <aevala>
    <summary>
      Execute a code block for each element in an array and assign the return value to each element in the array.
    </summary>

    <param name="aArray">The array to traverse.</param>
    <param name="cbBlock">The code block to execute.</param>
    <include file="VoFunctionDocs.xml" path="Runtimefunctions/arraycommon/*" />
    <returns>
      A reference to <paramref name="aArray" />.
    </returns>
    <remarks>
      AEvalA() is similar to AEval() in that they both evaluate a code block once for each element of an array,
      passing the element value as an argument.<br/>
      The difference is that while AEval() ignores the return value of the code block,
      AEvalA() assigns the return value to the array element.<br/>
      See AEval() for details.
    </remarks>
    <example>
      This example uses AEvalA() to create an array of file names in lowercase:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL aFiles := Directory("*.dbf")
        &#0009;LOCAL nTotal AS SHORTINT
        &#0009;AEvalA(aFiles,{|aDBFFile| LOWER(PadR(aDBFFile[F_NAME], 10))})
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbEval'>DBEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.QOut'>QOut</seealso>
    <seealso cref='O:XSharp.RT.Functions.SEval'>SEval</seealso>
  </aevala>
  <aevalold>
    <summary>
      Execute a code block for each element in an array.
    </summary>

    <param name="aArray">The array to traverse.</param>
    <param name="cbBlock">The code block to execute.</param>
    <include file="VoFunctionDocs.xml" path="Runtimefunctions/arraycommon/*" />
    <returns>
      A reference to <paramref name="aArray" />.<br/>
      The return value of the code block is ignored.<br/>
      To assign the return value of the code block to each element in the array, use the AEvalA() function.
    </returns>
    <remarks>
      AEvalOld() passes the element value and the element index as arguments.<br/>
      AEvalOld() makes no assumptions about the contents of the array elements it is passing.<br/>
      It is assumed that the supplied code block knows what type of data will be in each element.
      AEvalOld() is similar to DBEval() which executes code for each record of a database file.<br/>
      Like DBEval(), AEvalOld() can be used as a primitive for the construction of iteration commands for both simple and complex array structures.
      <note type="tip">
        In Visual Objects 2 different functions were introduced: AEval() and AEvalOld(). The difference between these functions was that AEval() was only calling the codeblock with one parameter (the element in the array), where AEvalOld() was also passing in a second parameter (the array index). Inside X# this difference no longer exists. So AEval() and AEvalOld() are doing the same thing in X#.
      </note>
    </remarks>
    <example>
      This example uses AEvalOld() to display an array of file names and file sizes returned from the Directory() function:
      <code language="X#">
        LOCAL aFiles := Directory("*.dbf")
        LOCAL nTotal := 0
        AEvalOld(aFiles, {| aDBFFile | QOut(PadR(aDBFFile[F_NAME], 10), ;
        &#0009;&#0009;aDBFFile[F_SIZE]), aDBFFile[F_SIZE]), nTotal += aDBFFile[F_SIZE]})
        ? "Total Bytes:", nTotal
      </code>
      This next example changes the contents of the array element depending on a condition.<br/>
      If the condition is false, array elements are merely displayed.<br/>
      Notice the use of the code block arguments:
      <code language="X#">
        LOCAL aArray[6]
        AFill      (aArray, "old")
        AEvalOld   (aArray, {|cValue, nIndex| IF(cValue == "old",;
        ArrayPut (aArray, nIndex,"new"),QOut(cValue))})
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AEvalA'>AEvalA</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbEval'>DBEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.QOut'>QOut</seealso>
    <seealso cref='O:XSharp.RT.Functions.SEval'>SEval</seealso>
  </aevalold>
  <afields>
    <summary>
      Fill arrays with the structure of the current database file.
      Note:<br/>
      AFields() is a compatibility function and therefore not recommended.<br/>
      It is superseded by DBStruct(), which does not require the existence of any arrays prior to invocation and returns a multidimensional array containing the current database file structure.
    </summary>

    <param name="acFieldNames">The array to fill with field names.</param>
    <param name="acTypes">
      The array to fill with the type of fields in <paramref name="acFieldNames" />.
    </param>
    <param name="anWidths">
      The array to fill with the widths of fields in <paramref name="acFieldNames" />.
    </param>
    <param name="anDecimals">
      The array to fill with the number of decimals defined for fields in <paramref name="acFieldNames" />.<br/>
      If the field type is not numeric, the system assigns 0 to <paramref name="anDecimals" />.
    </param>
    <returns>
      The number of fields or the length of the shortest array argument, whichever is less.<br/>
      If no arguments are specified, or if there is no file in use in the current work area, AFields() returns 0.
    </returns>
    <remarks>
      AFields() fills a series of arrays (structure attribute arrays) with the structure of the database file currently open, one element in each array per field.<br/>
      AFields() works like ADir(), filling a series of existing arrays with information.
      To use AFields(), you must first create the arrays to hold the database structure information, each with the same number of elements as the number of fields (that is, FCount()).  Once the structure attribute arrays exist, you can then invoke AFields() to fill them with information about each field.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example uses AFields() with an aliased expression to fill arrays with the structure of SALES.DBF, open in an unselected work area:
      <code language="X#">
        PROCEDURE Start()
        &#0009;LOCAL acFieldNames, aTypes, aWidths, ;
        &#0009;&#0009;&#0009;aDecimals AS ARRAY
        &#0009;USE sales NEW
        &#0009;USE customer NEW
        &#0009;acFieldNames := Sales-&gt;(ArrayNew(FCount()))
        &#0009;acTypes      := Sales-&gt;(ArrayNew(FCount()))
        &#0009;anWidths     := Sales-&gt;(ArrayNew(FCount()))
        &#0009;anDecimals   := Sales-&gt;(ArrayNew(FCount()))
        &#0009;Sales-&gt;(AFields(acFieldNames, acTypes, anWidths, anDecimals))
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ADir'>ADir</seealso>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScan'>AScan</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreate'>DBCreate</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbStruct'>DBStruct</seealso>
    <seealso cref='O:XSharp.RT.Functions.FCount'>FCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldName'>FieldName</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.RT.Functions.Type'>Type</seealso>
  </afields>
  <afill>
    <summary>
      Fill array elements with a specified value.
    </summary>

    <param name="aTarget">The array to fill.</param>
    <param name="uValue">The value to place in each array element.</param>
    <include file="VoFunctionDocs.xml" path="Runtimefunctions/arraycommon/*" />
    <returns>
      A reference to <paramref name="aTarget" />.
    </returns>
    <remarks>
      AFill() fills the specified array with a single value of any data type by assigning <paramref name="uValue" /> to each array element in the specified range.
      Using AFill with a multidimensional array could overwrite subarrays used for the other dimensions of the array.
    </remarks>
    <example>
      This example creates a 3-element array.<br/>
      The array is then filled with the logical value FALSE.  Finally, elements in positions 2 and 3 are assigned the new value TRUE:
      <code language="X#">
        LOCAL aLogic[3]&#0009;&#0009;&#0009;// aLogic is {NIL, NIL, NIL}
        AFill(aLogic, FALSE)&#0009;&#0009;// aLogic is {FALSE, FALSE, FALSE}
        AFill(aLogic, TRUE, 2, 2)&#0009;&#0009;// aLogic is {FALSE, TRUE, TRUE}
      </code>
      This example fills up the individual rows of a multidimensional array:
      <code language="X#">
        LOCAL a2[3][3]&#0009;//a 2-dimensional array
        AFill(a2[1], "One")
        AFill(a2[2], "Two")
        AFill(a2[3], "Three")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AAdd'>AAdd</seealso>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AReplicate'>AReplicate</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbStruct'>DBStruct</seealso>
    <seealso cref='O:XSharp.RT.Functions.Directory'>Directory</seealso>
  </afill>
  <ains>
    <summary>
      Insert an element into an array and assign it a NIL value.
    </summary>

    <param name="aTarget">The array into which the element will be inserted.</param>
    <param name="dwPosition">The position at which the element will be inserted.</param>
    <returns>
      A reference to <paramref name="aTarget" />.
    </returns>
    <remarks>
      AIns() inserts a new element into a specified array.<br/>
      The newly inserted element is NIL until a new value is assigned to it.<br/>
      After the insertion, the last element in the array is discarded, and all elements after the new element are shifted down one position.
      &#0009;AIns() must be used carefully with multidimensional arrays.<br/>
      Using AIns() in a multidimensional array discards the last element in the specified target array which, if it is an array element, will cause one or more dimensions to be lost.<br/>
      To insert a new dimension into an array, first add a new element to the end of the array using AAdd() or ASize() before using AIns().
    </remarks>
    <example>
      This example demonstrates the effect of using AIns() on an array:
      <code language="X#">
        LOCAL aArray AS ARRAY
        aArray := {1, 2, 3}&#0009;&#0009;&#0009;// aArray is now {1, 2, 3}
        AIns(aArray, 2)&#0009;&#0009;&#0009;// aArray is now {1, NIL, 2}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AAdd'>AAdd</seealso>
    <seealso cref='O:XSharp.RT.Functions.ACopy'>ACopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.ADel'>ADel</seealso>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval </seealso>
    <seealso cref='O:XSharp.RT.Functions.AFill'>AFill</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASize'>ASize</seealso>
  </ains>
  <alen>
    <summary>
      Return the number of elements in an array.
    </summary>

    <param name="aTarget">The array to count.</param>
    <returns>
      The number of elements in the array.<br/>
      If the array is empty, ALen() returns 0.
    </returns>
    <remarks>
      If the array is multidimensional, subarrays count as one element.<br/>
      This means that the ALen() of a multidimensional array simply returns the length of the first dimension.<br/>
      To determine the number of elements in other dimensions, use ALen() on the subarrays, as shown in the example below.  (Note that multidimensional arrays in X# need not have uniform dimensions.)
    </remarks>
    <example>
      This example creates a literal 2-dimensional array, then returns the array and the number of elements in the subarray that is contained in the first element of the array:
      <code language="X#">
        LOCAL aArray := {{1, 2}, {1, 2}, {1, 2}}
        ? ALen(aArray)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 3
        ? ALen(aArray[1])&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 2
      </code>
      This example navigates a multidimensional array using ALen():
      <code language="X#">
        LOCAL aArray := {{1, 2}, {1, 2}, {1, 2}}
        LOCAL nRow, nColumn AS SHORTINT
        LOCAL nRowCount, nColumnCount AS SHORTINT
        nRowCount = ALen(aArray)
        FOR nRow := 1 UPTO nRowCount
        &#0009;nColumnCount = ALen(aArray[nRow])
        &#0009;FOR nColumn := 1 UPTO nColumnCount
        &#0009;&#0009;? nRow, nColumn, aArray[nRow][nColumn]
        &#0009;NEXT
        NEXT
      </code>
      In this example, a function returns an array of numeric values that describe the dimensions of a multidimensional array.<br/>
      The function assumes that the array has uniform dimensions:
      <code language="X#">
        FUNCTION Dimensions(aArray)
        &#0009;LOCAL aDims := {}
        &#0009;DO WHILE IsArray(aArray)
        &#0009;&#0009;AADD(aDims, ALen(aArray))
        &#0009;&#0009;aArray := aArray[1]
        &#0009;ENDDO
        &#0009;RETURN (aDims)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AAdd'>AAdd</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASize'>ASize</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
  </alen>
  <alias>
    <summary>
      Return the alias of a specified work area as a string.
    </summary>

    <param name="uWorkArea">
      Any work area name or number.<br/>
      If not specified, the alias of the current work area is returned.
    </param>
    <returns>
      If there is no database file in use, Alias() returns a NULL_STRING.
    </returns>
    <remarks>
      Alias() is the inverse of Select(). Alias() returns the alias name given the work area number, while Select() returns the work area number given the alias name.
    </remarks>
    <example>
      This example returns the name of the previously selected work area:
      <code language="X#">
        USE file1 NEW ALIAS Test1
        nOldArea := Select()
        USE file2 NEW ALIAS Test2
        QOut(Alias(nOldArea))&#0009;&#0009;&#0009;// Returns: Test1
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias0'>Alias0</seealso>
    <seealso cref='O:XSharp.RT.Functions.Alias0Sym'>Alias0Sym</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSelect'>DBSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbAlias'>VODBAlias</seealso>
  </alias>
  <alias0>
    <summary>
      Return the alias of the current work area as a string.
    </summary>
    <returns>
      If there is no database file in use, Alias0() returns a NULL_STRING.
    </returns>
    <remarks>
      Alias0() is the same as Alias() except that Alias0() accepts no arguments.  (This is indicated by the "0" in the function name.)<br/>
      Therefore, when no argument is required, Alias0() should be used instead of Alias() to increase program efficiency.
      <br/>



      This example returns the name of the current work area:
      <code language="X#">
        USE file1 NEW ALIAS Test1
        QOut(Alias0())&#0009;&#0009;// Returns: Test1
      </code>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias'>Alias</seealso>
    <seealso cref='O:XSharp.RT.Functions.Alias0Sym'>Alias0Sym</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSelect'>DBSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbAlias'>VODBAlias</seealso>
  </alias0>
  <alias0sym>
    <summary>
      Return the alias of the current work area as a symbol.
    </summary>
    <returns>
      If there is no database file in use for the current work area, Alias0Sym() returns a NULL_SYMBOL.
    </returns>
    <remarks>
      Alias0Sym() is the same as Alias0() except that it returns the alias as a symbol.
      <br/>



      This example returns the name of the current work area:
      <code language="X#">
        USE mydbf
        QOut(Alias0Sym())&#0009;&#0009;&#0009;// Returns: "MYDBF"
        QOut(Alias0Sym() = #MYDBF)&#0009;&#0009;// Returns: TRUE
      </code>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias'>Alias</seealso>
    <seealso cref='O:XSharp.RT.Functions.Alias0'>Alias0</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbAliasSym'>VODBAliasSym</seealso>
  </alias0sym>
  <alltrim>
    <summary>
      Remove leading and trailing spaces from a string.
    </summary>

    <param name="cString">The string to trim.</param>
    <returns>
      A trimmed string, with leading and trailing spaces removed.
    </returns>
    <remarks>
      AllTrim() is related to LTrim() and RTrim(), which remove leading and trailing spaces, respectively.<br/>
      The inverse of AllTrim(), LTrim(), and RTrim() are the PadC(), PadL(), and PadR() functions, which center, left-justify, and right-justify strings by padding them with fill characters.
    </remarks>
    <example>
      This example creates a string with both leading and trailing spaces, then trims them with AllTrim():
      <code language="X#">
        LOCAL cString AS STRING
        cString := SPACE(10) + "string" + SPACE(10)
        ? SLen(cString)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 26
        ? SLen(ALLTRIM(cString))&#0009;&#0009;&#0009;&#0009;&#0009;// 6
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadC'>PadC</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadL'>PadL</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadR'>PadR</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.Trim'>Trim</seealso>
  </alltrim>
  <altd>
    <summary>
      Programmatically define a breakpoint in an application.
    </summary>
    <remarks>
      AltD() is operational only if the application is being executed by the Debugger.
    </remarks>
    <example>
      This example shows how to define a breakpoint in a function using AltD():
      <code language="X#">
        FUNCTION Bad()
        &#0009;...
        &#0009;AltD()&#0009;&#0009;&#0009;// Programmatic breakpoint
        &#0009;...
        &#0009;RETURN Value
      </code>
    </example>
  </altd>
  <ampm>
    <summary>
      Convert a 24-hour military time to a 12-hour clock time.
    </summary>

    <param name="c24HrTime">A valid military time in the form hh:mO:ss, where hh is hours in 24-hour format, mm is minutes, and ss is seconds.</param>
    <returns>
      An 11-character string in 12-hour format with either "am" or "pm."<br/>
      If <paramref name="cTime" /> does not represent a valid military time, a NULL_STRING is returned.
    </returns>
    <remarks>
    </remarks>
    <example>
      These examples use AmPm():
      <code language="X#">
        ? AmPm("10:45:23")&#0009;&#0009;&#0009;&#0009;// 10:45:23 am
        ? AmPm("22:45:23")&#0009;&#0009;&#0009;&#0009;// 10:45:23 pm
        ? AmPm("10:45:23Hello")&#0009;&#0009;&#0009;// NULL_STRING
        ? AmPm("1045")&#0009;&#0009;&#0009;&#0009;&#0009;// NULL_STRING
        ? AmPm("10:45")&#0009;&#0009;&#0009;&#0009;&#0009;// NULL_STRING
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
  </ampm>
  <ansi2oem>
    <summary>
      Convert a string of ANSI characters to OEM characters.
    </summary>

    <param name="cAnsiString">A source string of ANSI characters.</param>
    <returns>
      A converted string of OEM characters.
    </returns>
    <remarks>
      Ansi2Oem() changes the individual characters in the source string to matching characters from the OEM character set.<br/>
      This may need to be done because certain symbols, such as ä, have different code values in the ANSI and OEM character sets.  DOS applications creating a file with ä as part of the file name use the OEM code values and place 132 into the directory entry.  But Windows applications with ANSI code values use 228 for ä and thus cannot find the file.<br/>
      To get around this problem, you can use Ansi2Oem() to convert ANSI file names to the OEM character set.
      Also, if characters written to files by Windows applications are in the ANSI character set, the same character conversion problem might arise when DOS applications read the file.
    </remarks>
    <example>
      This example writes the string "aá.TXT" to a DOS file.  Note that á has the code value 225 in the ANSI character set, while in the OEM character set, code value 225 corresponds to the ß character.<br/>
      The FWrite() functions assume raw binary data and thus does not automatically convert ANSI to OEM.  (If desired, you could do the conversion yourself or use other functions such as FWriteText().)
      <code language="X#">FWrite(ptrFileHandle, Ansi2Oem("aá.txt"))</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2OemA'>Ansi2OemA</seealso>
    <seealso cref='O:XSharp.RT.Functions.Ansi2OemBuff'>Ansi2OemBuff</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
  </ansi2oem>
  <ansi2oema>
    <summary>
      Convert a string of ANSI characters to OEM characters, changing the contents of the original string as well as the returned string.
    </summary>

    <param name="cAnsiString">A source string of ANSI characters.</param>
    <returns>
      A converted string of OEM characters.
    </returns>
    <remarks>
      Ansi2OemA() is the same as Ansi2Oem(), except that Ansi2OemA() also replaces the contents of the original string with OEM characters.
    </remarks>
    <example>
      This example converts the contents of a string containing the characters ßä from ANSI to OEM.
      <code language="X#">
        LOCAL cString AS STRING
        cString := "ßä"
        Ansi2OEMA(cString)&#0009;&#0009;// Converts ßä to OEM
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.RT.Functions.Ansi2OemBuff'>Ansi2OemBuff</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2AnsiA'>Oem2AnsiA</seealso>
  </ansi2oema>
  <ansi2oembuff>
    <summary>
      Convert a specified number of ANSI characters in a source buffer to a buffer of corresponding OEM characters.
    </summary>

    <param name="pszTarget">A pointer to the buffer that will contain the converted string.</param>
    <param name="pszSource">A pointer to the buffer that contains the string to convert.</param>
    <param name="dwCount">The number of characters to convert.</param>
    <returns>
      A pointer to the buffer that contains the converted string.
    </returns>
    <remarks>
      Ansi2OemBuff() is similar to Ansi2Oem(), except that the resulting string is stored in the buffer pointed to by <paramref name="pszTarget" />.<br/>
      Also, the <paramref name="dwCount" /> argument lets you specify the number of characters to be converted.
      <note type="tip">
        You are responsible for allocating space for the buffer pointed to by <paramref name="pszTarget" />.<br/>
        Using an unallocated buffer pointer can have adverse results.
      </note>
    </remarks>
    <example>
      This example uses Ansi2OemBuff() to convert the contents of the ANSI string "ßä" to the OEM character set.  Note that the source string is also used as a target string:
      <code language="X#">
        LOCAL cStr := "ßä"
        Ansi2OemBuff(PSZ(_CAST, cStr), PSZ(_CAST, cStr), SLen(cStr))
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.Core.Functions.Ansi2OemA'>Ansi2OemA</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2AnsiA'>Oem2AnsiA</seealso>
  </ansi2oembuff>
  <areplicate>
    <summary>
      To create an array and fill its elements with a default value.
    </summary>

    <param name="xFill">The value with which to fill the array.</param>
    <param name="nElements">The size of the array.</param>
    <returns>
      An array <paramref name="nElements" /> elements long, each element containing <paramref name="xFill" />.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example creates an array of 10 elements and fills it with zeros:
      <code language="X#">aNewArray := AReplicate(0, 10)</code>
      This example creates an array of 5 elements and fills it with "Empty" strings:
      <code language="X#">aEmptyArray := AReplicate("Empty", 5)</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AClone'>AClone</seealso>
    <seealso cref='O:XSharp.RT.Functions.ACopy'>ACopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.AFill'>AFill</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayBuild'>ArrayBuild</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayCreate'>ArrayCreate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayInit'>ArrayInit</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayNew'>ArrayNew</seealso>
  </areplicate>
  <arraybuild>
    <summary>
      Create an empty array.
    </summary>
    <returns>
    </returns>
    <remarks>
      ArrayBuild() creates an empty array.<br/>
      It is the functional form of an empty array assignment like this:
      <code language="X#">aMyArray := {}</code>
      Note, however, that within the generic {} you are allowed to list other values while ArrayBuild() does not take any arguments.
      To create uninitialized arrays of specified length, see ArrayCreate() and ArrayNew().<br/>
      To create initialized arrays, see ArrayInit().
    </remarks>
    <example>
      This example creates an empty array using the ArrayBuild() function, then shows the equivalent action by assigning a literal array:
      <code language="X#">
        aArray := ArrayBuild()
        aArray := {}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AReplicate'>AReplicate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayCreate'>ArrayCreate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayInit'>ArrayInit</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayNew'>ArrayNew</seealso>
  </arraybuild>
  <arraycreate>
    <summary>
      Create an uninitialized, one-dimensional array.
    </summary>

    <param name="dwElements">The number of elements in the array.</param>
    <returns>
    </returns>
    <remarks>
      ArrayCreate() returns an uninitialized array with only one dimension.<br/>
      To create uninitialized multidimensional arrays, see ArrayNew().
    </remarks>
    <example>
      This example creates a one-dimensional array of five elements using ArrayCreate(), then shows the equivalent action by assigning a literal array of NIL values:
      <code language="X#">
        LOCAL aArray AS ARRAY
        aArray := ArrayCreate(5)
        aArray := {NIL, NIL, NIL, NIL, NIL}
      </code>
      This example creates an array of numbers and puts values in the elements:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL aArray AS ARRAY
        &#0009;aArray := ArrayCreate(3)
        &#0009;ArrayPut(aArray, 1, 1)
        &#0009;ArrayPut(aArray, 2, 10)
        &#0009;ArrayPut(aArray, 3, 100)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AReplicate'>AReplicate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayBuild'>ArrayBuild</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayInit'>ArrayInit</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayNew'>ArrayNew</seealso>
  </arraycreate>
  <arraydeprotect>
    <summary>
      Removes write protection from an entire array.
    </summary>

    <param name="aTarget">The array to deprotect.</param>
    <returns>
      TRUE if the array was successfully deprotected; otherwise, FALSE.
    </returns>
    <remarks>
      ArrayDeprotect() removes the protection placed on an array by the ArrayProtect() function, allowing their values to be changed.
    </remarks>
    <example>
      This example stores values to array elements, protects the elements, then removes the protection so they can be changed:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL aWriteProtect AS ARRAY
        &#0009;aWriteProtect := ArrayCreate(2)
        &#0009;ArrayPut(aWriteProtect, 1, "Origin")
        &#0009;ArrayPut(aWriteProtect, 2, "Origin")
        &#0009;ArrayProtect(aWriteProtect)
        &#0009;// Write allowed in calling function
        &#0009;ArrayPut(aWriteProtect, 1, "Main Function")
        &#0009;// Write not allowed in called function
        &#0009;TryChange(aWriteProtect)
        &#0009;ArrayDeprotect(aWriteProtect)
        &#0009;// Write allowed (no protection)
        &#0009;TryChange(aWriteProtect)
        FUNCTION TryChange(aPassed)
        &#0009;ArrayPut(aPassed, 1, "Sub Function")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ArrayProtect'>ArrayProtect</seealso>
  </arraydeprotect>
  <arrayget>
    <summary>
      Read an array element.
    </summary>

    <param name="aTarget">The array to read.</param>
    <param name="dwElement">The number of the element to read.</param>
    <returns>
      The value held by the element.
    </returns>
    <remarks>
      ArrayGet() reads and returns an array element's value.
    </remarks>
    <example>
      This example creates an array and prints the values:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL aStates[3]
        &#0009;LOCAL i AS SHORTINT
        &#0009;ArrayPut(aStates, 1, "Montana")
        &#0009;ArrayPut(aStates, 2, "Wyoming")
        &#0009;ArrayPut(aStates, 3, "Idaho")
        &#0009;FOR i := 1 UPTO ALen(aStates)
        &#0009;&#0009;QOut(ArrayGet(aStates, i))
        &#0009;NEXT
        &#0009;// Below we print the same array in two different
        &#0009;// ways from the above:
        &#0009;// Functional equivalent of FOR...NEXT
        &#0009;AEval(aStates, {|Element| QOut(Element)})
        &#0009;// Using [] to get an array element
        &#0009;FOR i := 1 UPTO ALen(aStates)
        &#0009;&#0009;QOut(aStates[i])
        &#0009;NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ArrayPut'>ArrayPut</seealso>
  </arrayget>
  <arrayinit>
    <summary>
      Create an initialized array.
    </summary>

    <param name="wElements">The number of elements.</param>
    <param name="aValues">Data to initialize array with</param>
    <returns>
      An initialized array with the specified number of elements and referenced values in each element.
    </returns>
    <remarks>
      ArrayInit() builds an array with the specified number of elements and initializes the elements with the pointer contents.<br/>
      At least <paramref name="wElements" /> data of type USUAL must be at the location referenced by <paramref name="" />.<br/>
      To create an uninitialized array, see ArrayNew().
    </remarks>
    <example>
      This example creates and initializes a 2-element array.<br/>
      An existing DIM array serves as the pointer to the initialized data:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL aOffsets AS ARRAY
        &#0009;LOCAL DIM aDimPoint[2] AS USUAL
        &#0009;aDimPoint[1] := "Hello"
        &#0009;aDimPoint[2] := "World!"
        &#0009;aOffsets := ArrayInit(2, @aDimPoint)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AReplicate'>AReplicate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayBuild'>ArrayBuild</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayCreate'>ArrayCreate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayNew'>ArrayNew</seealso>
  </arrayinit>
  <arraynew>
    <summary>
      Create an uninitialized array with the specified number of elements and dimensions.
    </summary>

    <param name="wElementList">
      A comma-separated list representing the number of elements in each dimension.<br/>
      If more than one element number is specified, a multidimensional array is created with the number of dimensions equal to the number of arguments in <paramref name="wElementList" />.
    </param>
    <returns>
      An array of specified dimensions.
    </returns>
    <remarks>
      In X#, there are several ways to create an array:
      &#0009;Declare an array using a declaration statement such as LOCAL or STATIC.
      &#0009;Create an array using a PRIVATE or PUBLIC statement.
      &#0009;Assign a literal array to an existing variable.
      &#0009;Use the ArrayNew() function.<br/>
      ArrayNew() has the advantage that it can create arrays within expressions or code blocks.
      You can also use the ArrayBuild() function to create empty arrays, the ArrayCreate() function to create one-dimensional arrays, or ArrayInit() to create initialized arrays.
    </remarks>
    <example>
      This example creates a one-dimensional array of five elements using the ArrayNew() function, then shows the equivalent action by assigning a literal array of NIL values:
      <code language="X#">
        LOCAL aArray AS ARRAY
        aArray := ArrayNew(5)
        aArray := {NIL, NIL, NIL, NIL, NIL}
      </code>
      This example shows three different statements which create the same multidimensional array:
      <code language="X#">
        aArray := ArrayNew(3, 2)
        aArray := {{NIL, NIL}, {NIL, NIL}, {NIL, NIL}}
        aArray := {ArrayCreate(2), ArrayCreate(2), ArrayCreate(2)}
      </code>
      This example creates a multidimensional array:
      <code language="X#">aArray := ArrayNew(3, 2, 5)</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AAdd'>AAdd</seealso>
    <seealso cref='O:XSharp.RT.Functions.AClone'>AClone</seealso>
    <seealso cref='O:XSharp.RT.Functions.ACopy'>ACopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.ADel'>ADel</seealso>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AFill'>AFill</seealso>
    <seealso cref='O:XSharp.RT.Functions.AIns'>AIns</seealso>
    <seealso cref='O:XSharp.RT.Functions.AReplicate'>AReplicate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayBuild'>ArrayBuild</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayCreate'>ArrayCreate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayInit'>ArrayInit</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScan'>AScan</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASize'>ASize</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASort'>ASort</seealso>
    <seealsocmd>LOCAL</seealsocmd>
    <seealsocmd>PRIVATE</seealsocmd>
    <seealsocmd>PUBLIC</seealsocmd>
    <seealsocmd>STATIC</seealsocmd>
  </arraynew>
  <arrayprotect>
    <summary>
      Protect an array from change in all functions except the one in which it was declared.
    </summary>

    <param name="aTarget">The array to protect.</param>
    <returns>
      TRUE if the array was successfully protected; otherwise, FALSE.
    </returns>
    <remarks>
      ArrayProtect() protects array values from change once you assign values to them.<br/>
      The function in which the array is declared can still write to the array.
    </remarks>
    <example>
      This example stores values to array elements, protects the elements, then removes the protection so they can be changed by sub-functions:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL aWriteProtect AS ARRAY
        &#0009;aWriteProtect := ArrayCreate(2)
        &#0009;ArrayPut(aWriteProtect, 1, "Origin")
        &#0009;ArrayPut(aWriteProtect, 2, "Origin")
        &#0009;ArrayProtect(aWriteProtect)
        &#0009;// Write allowed in calling function
        &#0009;ArrayPut(aWriteProtect, 1, "Main Function")
        &#0009;// Write not allowed in called function
        &#0009;TryChange(aWriteProtect)
        &#0009;ArrayDeprotect(aWriteProtect)
        &#0009;// Write allowed (no protection)
        &#0009;TryChange(aWriteProtect)
        FUNCTION TryChange(aPassed)
        &#0009;ArrayPut(aPassed, 1, "Sub Function")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ArrayDeProtect'>ArrayDeprotect</seealso>
  </arrayprotect>
  <arrayput>
    <summary>
      Write a value to an array element.
    </summary>

    <param name="aTarget">The array to write to.</param>
    <param name="dwElement">The number of the array element to receive the value.</param>
    <param name="uValue">The value to write to the array element.</param>
    <returns>
      The value assigned.
    </returns>
    <remarks>
      ArrayPut() writes values to specified array elements.<br/>
      If a value is already there, it is overwritten.
    </remarks>
    <example>
      This example writes values to array elements:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL aStates[2]
        &#0009;ArrayPut(aStates, 1, "Montana")
        &#0009;ArrayPut(aStates, 2, "Wyoming")
        &#0009;// Below we get the same result by using []
        &#0009;aStates[1] := "Montana"
        &#0009;aStates[2] := "Wyoming"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ArrayGet'>ArrayGet</seealso>
  </arrayput>
  <arraystore>
    <summary>
      Store an array to a buffer.
    </summary>

    <param name="aSource">The array to be stored to a buffer.</param>
    <param name="Buff">A pointer to the buffer.</param>
    <param name="dwLen">The length of the buffer.</param>
    <returns>
      The number of bytes stored to the buffer.
    </returns>
    <remarks>
      Stores the contents of an array into the buffer pointed by <paramref name="Buff" />.  You should insure that the buffer is allocated and is large enough before writing to it.
    </remarks>
    <example>
      This example writes an array's elemental values to a buffer.<br/>
      A DIM array serves as the destination pointer:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL DIM aDestination[4] AS USUAL
        &#0009;LOCAL aList[4]
        &#0009;ArrayPut(aList, 1, 1)
        &#0009;ArrayPut(aList, 2, 3)
        &#0009;ArrayPut(aList, 3, 5)
        &#0009;ArrayPut(aList, 4, 7)
        &#0009;ArrayStore(aList, @aDestination, 4*6)
        &#0009;? aDestination[1]&#0009;&#0009;// Result: 1
        &#0009;? aDestination[2]&#0009;&#0009;// Result: 3
        &#0009;? aDestination[3]&#0009;&#0009;// Result: 5
        &#0009;? aDestination[4]&#0009;&#0009;// Result: 7
      </code>
    </example>
  </arraystore>
  <arrayswap>
    <summary>
      Replace an array element with a new value and return the old value.
    </summary>

    <param name="aTarget">The array whose element will be replaced with a new value.</param>
    <param name="dwElement">The number of the element to be replaced.</param>
    <param name="uNewValue">The new value.</param>
    <returns>
      The value that was replaced by <paramref name="uNewValue" />.
    </returns>
    <remarks>
      ArraySwap() replaces the element specified with a new value.
    </remarks>
    <example>
      This example swaps the second and third elements of an array:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL aList[4]
        &#0009;ArrayPut(aList, 1, "First")
        &#0009;ArrayPut(aList, 2, "Second")
        &#0009;ArrayPut(aList, 3, "Third")
        &#0009;ArrayPut(aList, 4, "Fourth")
        &#0009;aList[3] := ArraySwap(aList, 2, aList[3])
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ArrayPut'>ArrayPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayGet'>ArrayGet</seealso>
  </arrayswap>
  <asc>
    <summary>
      Convert a character to its ASCII value.
    </summary>

    <param name="cString">The character to convert to a number.</param>
    <returns>
      A number from 0 to 255, representing the ASCII code of <paramref name="cString" />.
    </returns>
    <remarks>
      Asc() is a character conversion function that returns the ASCII value of the leftmost character in a string.<br/>
      Asc() is used primarily on expressions requiring numeric calculations on the ASCII value of a character.  Chr() and Asc() are inverse functions.
    </remarks>
    <example>
      These examples illustrate various results of Asc():
      <code language="X#">
        ? Asc("A")&#0009;&#0009;&#0009;&#0009;// 65
        ? Asc("Apple")&#0009;&#0009;&#0009;&#0009;// 65
        ? Asc("a")&#0009;&#0009;&#0009;&#0009;&#0009;// 97
        ? Asc("Z") - Asc("A")&#0009;&#0009;// 25
        ? Asc(NULL_STRING)&#0009;&#0009;&#0009;// 0
        ? Asc(Chr(0))&#0009;&#0009;&#0009;&#0009;// 0
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Chr'>Chr</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Val'>Val</seealso>
  </asc>
  <ascan>
    <summary>
      Scan an array until a value is found or a code block returns TRUE.
    </summary>

    <param name="aTarget">The array to scan.</param>
    <param name="uSearch">
      The value to scan for.<br/>
      Unless this argument is a code block, it must match the data type of the elements in <paramref name="aTarget" />.
    </param>
    <include file="VoFunctionDocs.xml" path="Runtimefunctions/arraycommon/*" />
    <returns>
      If <paramref name="uSearch" /> is a code block, AScan() returns the position of the first element for which the code block returns TRUE.<br/>
      Otherwise, AScan() returns the position of the first matching element.<br/>
      AScan() returns 0 if no match is found
    </returns>
    <remarks>
      If <paramref name="uSearch" /> is not a code block, its value is compared to the first target element.<br/>
      If there is no match, AScan() proceeds to the next element in the array.<br/>
      This process continues until either a match is found or the range of elements to scan is exhausted.<br/>

      If <paramref name="uSearch" /> is a code block, AScan() scans <paramref name="aTarget" />, executing the code block for each element accessed.<br/>
      As each element is encountered, AScan() passes the element's value as an argument to the code block, then performs an Eval() on the code block.<br/>
      The scanning operation stops when the code block returns TRUE or when the range of elements to scan is exhausted.
      Note:  Values are compared using the = operator.<br/>
      For exact matching (that is, using the == operator), use AScanExact().
    </remarks>
    <example>
      This example demonstrates scanning a 3-element array, using both a string and a code block as search criteria.<br/>
      The code block criteria shows how to perform a case-insensitive search:
      <code language="X#">
        aArray := {"Tom", "Mary", "Sue"}
        ? AScan(aArray, "Mary")&#0009;&#0009;&#0009;&#0009;// 2
        ? AScan(aArray, "mary")&#0009;&#0009;&#0009;&#0009;// 0
        ? AScan(aArray, ;
        &#0009;&#0009;{|x| Upper(x) = "MARY"})&#0009;// 2
      </code>
      This example demonstrates scanning for multiple instances of a search argument after a match is found:
      <code language="X#">
        LOCAL aArray := {"Tom", "Mary", "Sue", "Mary"}
        LOCAL nStart := 1
        LOCAL iAtEnd, iPos AS INT
        // Get last array element position
        iAtEnd := 4
        DO WHILE (iPos := AScan(aArray, "Mary", nStart)) &gt; 0
        &#0009;? iPos, aArray[iPos]
        &#0009;// Get new starting position and test boundary condition
        &#0009;IF (nStart += iPos) &gt; iAtEnd
        &#0009;&#0009;EXIT
        &#0009;ENDIF
        ENDDO
      </code>
      This example scans a 2-dimensional array using a code block.  Note that the argument aVal in the code block is an array:
      <code language="X#">
        LOCAL aArr := {}
        AAdd(aArr,{"one", "two"})
        AAdd(aArr,{"three", "four"})
        AAdd(aArr,{"five", "six"})
        ? AScan(aArr, {|aVal| aVal[2] = "four"})&#0009;&#0009;// 2
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanBin'>AScanBin</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanBinExact'>AScanBinExact</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanExact'>AScanExact</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
  </ascan>
  <ascanbin>
    <summary>
      Scan a sorted array until a value is found or a code block returns 0.
    </summary>

    <param name="aTarget">The sorted array to scan.</param>
    <param name="uSearch">
      The value to scan for.<br/>
      Unless this argument is a code block, it must match the data type of the elements in <paramref name="aTarget" />.<br/>
      If <paramref name="uSearch" /> is a code block, it should return a numeric value that indicates the outcome of the comparison: a positive value indicates that <paramref name="uSearch" /> is greater than the current array element, a 0 stands for equality, and a negative value indicates that <paramref name="uSearch" /> is less than the current array element.
    </param>
    <returns>
      If <paramref name="uSearch" /> is a code block, AScanBin() returns the position of the element if the code block returned a value of zero.<br/>
      Otherwise, AScanBin() returns the position of a matching element.<br/>
      If multiple occurrences of the same element exist, the returned match is not necessarily the lowest numbered element since AScanBin() uses a binary search algorithm.<br/>
      AScanBin() returns 0 if no match is found.
    </returns>
    <remarks>
      AScanBin() scans an array for a specified value.
      If <paramref name="uSearch" /> is a code block, AScanBin() scans <paramref name="aTarget" />, by using a binary search algorithm and executes the code block for each element accessed.<br/>
      As each element is encountered, AScanBin() passes the element's value as an argument to the code block, then performs an Eval() on the code block.<br/>
      The scanning operation stops when the code block returns a value of zero or when the range of elements to scan is exhausted.
      Note:  Values are compared using the = operator.<br/>
      For exact matching (that is, using the == operator), use AScanBinExact().
    </remarks>
    <example>
      This example demonstrates scanning a 3-element array, using both a string and a code block as search criteria.<br/>
      The code block criteria shows how to perform a case-insensitive search:
      <code language="X#">
        aArray := {"Tom", "Mary", "Sue"}
        ASort(aArray)
        ? AScanBin(aArray, "Mary")&#0009;&#0009;&#0009;&#0009;// 1
        ? AScanBin(aArray, "mary")&#0009;&#0009;&#0009;&#0009;// 0
        ? AScanBin(aArray, ;
        &#0009;&#0009;{|x| MyCompare(x, "MARY")})&#0009;&#0009;// 1
        FUNCTION MyCompare(cElement, cSearch) AS SHORTINT
        &#0009;LOCAL siRet := 0 AS SHORTINT
        &#0009;cElement := Upper(cElement)
        &#0009;IF cSearch &gt; cElement
        &#0009;&#0009;siRet := 1
        &#0009;ELSEIF cSearch &lt; cElement
        &#0009;&#0009;siRet := -1
        &#0009;&#0009;// ELSE defaults to the initial value of 0
        &#0009;ENDIF
        &#0009;RETURN siRet
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScan'>AScan</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanBinExact'>AScanBinExact</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanExact'>AScanExact</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
  </ascanbin>
  <ascanbinexact>
    <summary>
      Scan a sorted array until there is an exact match or a code block returns 0.
    </summary>

    <param name="aTarget">The sorted array to scan.</param>
    <param name="uSearch">
      The value to scan for.<br/>
      Unless this argument is a code block, it must match the data type of the elements in <paramref name="aTarget" />.<br/>
      If <paramref name="uSearch" /> is a code block, it should return a numeric value that indicates the outcome of the comparison: a positive value indicates that <paramref name="uSearch" /> is greater than the current array element, a 0 stands for equality, and a negative value indicates that <paramref name="uSearch" /> is less than the current array element.
    </param>
    <returns>
      If <paramref name="uSearch" /> is a code block, AScanBinExact() returns the position of the element if the code block returned 0.<br/>
      Otherwise, AScanBinExact() returns the position of an exact-matching element.<br/>
      If multiple occurrences of the same element exist, the returned exact match is not necessarily the lowest numbered element since AScanBinExact() uses a binary search algorithm.<br/>
      AScanBinExact() returns 0 if no exact match is found.
    </returns>
    <remarks>
      AScanBinExact() is the same as AScanBin() except that == is used for matching instead of =.
    </remarks>
    <example>
      This example shows the difference between AScanBinExact() and AScanBin():
      <code language="X#">
        aArray := {"Larger", "Largest"}&#0009;// Already sorted
        ? "Larger" = "Large"&#0009;&#0009;&#0009;// TRUE
        ? "Larger" == "Large"&#0009;&#0009;&#0009;// FALSE
        ? AScanBin(aArray, "Large")&#0009;&#0009;// 1
        ? AScanBinExact(aArray, "Large")&#0009;// 0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScan'>AScan</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanBin'>AScanBin</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
  </ascanbinexact>
  <ascanexact>
    <summary>
      Scan an array until there is an exact match or a code block returns TRUE.
    </summary>

    <param name="aTarget">The array to scan.</param>
    <param name="uSearch">
      The value to scan for.<br/>
      Unless this argument is a code block, it must match the data type of the elements in <paramref name="aTarget" />.
    </param>
    <include file="VoFunctionDocs.xml" path="Runtimefunctions/arraycommon/*" />
    <returns>
      If <paramref name="uSearch" /> is a code block, AScanExact() returns the position of the element if the code block returned TRUE.<br/>
      Otherwise, AScanExact() returns the position of the first exact-matching element.<br/>
      AScanExact() returns 0 if no exact match is found.
    </returns>
    <remarks>
      AScanExact() is the same as AScan() except that == is used for matching instead of =.
    </remarks>
    <example>
      This example shows the difference between AScanExact() and AScan():
      <code language="X#">
        aArray := {"Larger", "Large"}
        ? "Larger" = "Large"&#0009;&#0009;&#0009;// TRUE
        ? "Larger" == "Large"&#0009;&#0009;&#0009;// FALSE
        ? AScan(aArray, "Large")&#0009;&#0009;&#0009;// 1
        ? AScanExact(aArray, "Large")&#0009;&#0009;// 2
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScan'>AScan</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanBin'>AScanBin</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
  </ascanexact>
  <asend>
    <summary>
      Invoke a method for every element in an array of objects.
    </summary>

    <param name="aTarget">The array to process.</param>
    <param name="symMethod">The method name, specified without parentheses.</param>
    <param name="MethodArgList">
      A comma-separated list of arguments to pass to <paramref name="symMethod" />.
    </param>
    <returns>
      A reference to <paramref name="aTarget" />.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example sends a simple message to an array of objects for evaluation.<br/>
      Each elemental object evaluates the message in turn:
      <code language="X#">
        CLASS Greet
        METHOD Salut(cRest) CLASS Greet
        &#0009;? Hello", cRest
        &#0009;RETURN
        END CLASS
        FUNCTION Start()
        &#0009;LOCAL oAlpha, oBeta, oGamma, oDelta, oEpsilon ;
        &#0009;&#0009;AS OBJECT
        &#0009;LOCAL aBunch AS ARRAY
        &#0009;oAlpha   := Greet{}
        &#0009;oBeta    := Greet{}
        &#0009;oGamma    := Greet{}
        &#0009;oDelta   := Greet{}
        &#0009;oEpsilon := Greet{}
        &#0009;aBunch := {oAlpha, oBeta, oGamma, oDelta, oEpsilon}
        &#0009;ASend(aBunch, #Salut, "world")
        &#0009;// Equivalent output
        &#0009;AEval(aBunch, {|aTemp| aTemp:Salut("world")})
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.Send'>Send</seealso>
  </asend>
  <ashexstring>
    <summary>
      Convert a value to a hexadecimal string.
    </summary>

    <param name="uValue">A value of any type.</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses AsHexString() to display the hexadecimal dumps of different expressions:
      <code language="X#">
        LOCAL cAlpha AS STRING
        LOCAL siSum AS SHORTINT
        cAlpha := "ABCDEF"
        siSum := 100
        ? AsHexString(cAlpha)&#0009;&#0009;// 41 42 43 44 45 46
        ? AsHexString(siSum)&#0009;&#0009;// 00000064
        ? AsHexString("abcdef")&#0009;&#0009;// 61 62 63 64 65 66
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsSymbol'>AsSymbol</seealso>
  </ashexstring>
  <asize>
    <summary>
      Grow or shrink an array.
    </summary>

    <param name="aTarget">The array to grow or shrink.</param>
    <param name="dwLength">The new size of the array.</param>
    <returns>
      A reference to <paramref name="aTarget" />.
    </returns>
    <remarks>
      ASize() changes the actual length of <paramref name="aTarget" />.<br/>
      The array is shortened or lengthened to match the specified length.<br/>
      If the array is shortened, elements at the end of the array are lost.<br/>
      If the array is lengthened, new elements are added to the end of the array and assigned NIL.
      ASize() is similar to AAdd(), which adds a single new element to the end of an array and optionally assigns a new value at the same time.  Note that ASize() is different from AIns() and ADel(), which do not actually change the array's length.
    </remarks>
    <example>
      These examples demonstrate adding new elements and deleting existing elements:
      <code language="X#">
        LOCAL aArray AS ARRAY
        aArray := {1}&#0009;&#0009;&#0009;// aArray is {1}
        ASize(aArray, 3)&#0009;&#0009;// aArray is {1, NIL, NIL}
        ASize(aArray, 1)&#0009;&#0009;// aArray is {1}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AAdd'>AAdd</seealso>
    <seealso cref='O:XSharp.RT.Functions.ADel'>ADel</seealso>
    <seealso cref='O:XSharp.RT.Functions.AFill'>AFill</seealso>
    <seealso cref='O:XSharp.RT.Functions.AIns'>AIns</seealso>
  </asize>
  <asortcommon>
    <summary>
      Sort an array.
    </summary>

    <param name="aTarget">The array to sort.</param>
    <param name="nStart">
      The starting element.<br/>
      The default value is 1.
    </param>
    <param name="nCount">
      The number of elements to process from <paramref name="nStart" />.<br/>
      The default is all elements to the end of the array.
    </param>
    <returns>
      A reference to <paramref name="aTarget" />.
    </returns>

  </asortcommon>
  <asort>
    <include file="VoFunctionDocs.xml" path="Runtimefunctions/asortcommon/*" />
    <param name="cbOrder">
      A code block used to determine the sort order.<br/>
      This argument is used to change the sorting order to descending or dictionary order.<br/>
      Each time it is evaluated, two elements from the target array are passed as arguments.<br/>
      The code block returns TRUE if the elements are in sorted order.  See the examples below.<br/>

      &#0009;The default sorting order is ascending:<br/>

      &#0009;&#0009;Elements with low values are sorted toward the beginning of the array (the first element).<br/>

      &#0009;&#0009;Elements with high values are sorted toward the end of the array (the last element)
    </param>
    <remarks>
      ASort() sorts all or part of an array.<br/>
      The array may contains USUALs of mixed types.<br/>
      Data types that can be sorted include character, date, logical, and numeric.
      Strings are sorted in ASCII sequence; logical values are sorted with FALSE as the low value; date values are sorted chronologically; and numeric values are sorted by magnitude.
      &#0009;ASort() will not directly sort a multidimensional array.<br/>
      To sort a multidimensional array, you must supply a code block which properly handles the subarrays.
    </remarks>
    <example>
      This example creates an array of five unsorted elements, sorts the array in ascending order, then sorts the array in descending order using a code block:
      <code language="X#">
        aArray := {3, 5, 1, 2, 4}
        ASort(aArray)&#0009;&#0009;&#0009;&#0009;&#0009;// {1, 2, 3, 4, 5}
        ASort(aArray,,, {|x, y| x &gt;= y})&#0009;// {5, 4, 3, 2, 1}
      </code>
      This example sorts a mixed-type array.
      <code language="X#">
        LOCAL  a := {"Z", "A", "one", 2, 1, "Three"}
        ASort(a)
      </code>
      This example sorts an array of strings in ascending order, independent of case.<br/>
      It does this by using a code block that converts the elements to uppercase before they are compared:
      <code language="X#">
        aArray := {"Fred", "Kate", "ALVIN", "friend"}
        ASort(aArray,,, {|x, y| Upper(x) &lt;= Upper(y)})&#0009;// {ALVIN, FRED, FRIEND, KATE}
      </code>
      This example sorts a multidimensional array using the second element of each subarray:
      <code language="X#">
        aKids := {{"Mary", 14}, {"Joe", 23}, {"Art", 16}}
        aSortKids := ASort(aKids,,, {|x, y| x[2] &lt;= y[2]})&#0009;// {{"Mary", 14}, {"Art", 16}, {"Joe", 23}}
      </code>
      Note:<br/>
      The &lt; and &gt; operators can be used in the codeblock if you are sure that there will be no duplicates; otherwise,
      it is more appropriate to use &lt;= and &gt;=, as they properly allow for duplicate values.
    </example>
    <seealso cref='O:XSharp.RT.Functions.AScan'>AScan</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASortFunc'>ASortFunc</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASortEx'>AsortEx</seealso>
  </asort>
  <asortex>
    <include file="VoFunctionDocs.xml" path="Runtimefunctions/asortcommon/*" />
    <param name="compBlock">
      The codeblock that is called to sort the elements. Should return signed integer, like IComparer.Compare
    </param>
    <remarks>
      ASortEx() sorts all or part of an array.<br/>
      The array may contains USUALs of mixed types.<br/>
    </remarks>
    <example>
      This example creates an array of five unsorted elements, sorts the array in ascending order, then sorts the array in descending order using a code block:
      <code language="X#">
        LOCAL testArray AS ARRAY
        testArray  := {"Fred", "Kate", "Fred", "ALVIN", "friend"}
        ASortEx(testArray, 1,ALen(testArray), {|a,b|
        if upper(a) &lt; upper(b)
         return -1
     elseif upper(a) &gt; upper(b)
        return 1
        endif
        return 0
        })
        // The sort order after the code has run is ALVIN, Fred, Fred, friend, Kate
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ASort'>ASort</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASortFunc'>AsortFunc</seealso>
    <seealso cref='M:System.Collections.IComparer.Compare'>IComparer.Compare</seealso>
  </asortex>
  <asortfunc>
    <include file="VoFunctionDocs.xml" path="Runtimefunctions/asortcommon/*" />
    <param name="compFunction">
      The function that is called to sort the elements. Should return signed integer, like IComparer.Compare
    </param>
    <remarks>
      ASortFunc() sorts all or part of an array.<br/>
    </remarks>
    <example>
      This example creates an array of five unsorted elements, sorts the array in ascending order:
      <code language="X#">
        LOCAL FUNCTION SortFunc(a as usual,b as usual) AS INT
          if upper(a) &lt; upper(b)
            return -1
          elseif upper(a) &gt;> upper(b)
              return 1
          endif
          return 0
        END FUNCTION
        LOCAL testArray AS ARRAY
        testArray  := {"Fred", "Kate", "Fred", "ALVIN", "friend"}
        ASortFunc(testArray, 1,ALen(testArray), SortFunc)
        // The sort order after the code has run is ALVIN, Fred, Fred, friend, Kate
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ASort'>ASort</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASortEx'>AsortEx</seealso>
    <seealso cref='M:System.Collections.IComparer.Compare'>IComparer.Compare</seealso>
  </asortfunc>

  <aspadr>
    <summary>
      Convert a value to a right-padded string.
    </summary>

    <param name="uValue">The value to be converted.</param>
    <param name="wLen">The length of the padded string.</param>
    <returns>
      A right-padded string of length <paramref name="wLen" /> containing the converted value.
    </returns>
    <remarks>
      AsPadR(<paramref name="uValue" />, <paramref name="wLen" />) is like specifying PadR(AsString(<paramref name="uValue" />), <paramref name="wLen" />, " ").
    </remarks>
    <example>
      This example uses AsPadR() to compare a number with the contents of a character field:
      <code language="X#">? _FIELD-&gt;cRegion == AsPadR(2048, 10)</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsString'>AsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadR'>PadR</seealso>
  </aspadr>
  <asstring>
    <summary>
      Convert a value to a string.
    </summary>

    <param name="uValue">The value to be converted.</param>
    <returns>
      A string containing the converted value.<br/>
      The converted string is dynamically allocated.
    </returns>
    <remarks>
    </remarks>
    <example>
      These examples show how to use AsString():
      <code language="X#">
        LOCAL cNum AS STRING
        LOCAL cDate AS STRING
        cNum := AsString(123456)
        &#0009;// Convert an empty date
        cDate := AsString(0.0.0)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsPadr'>AsPadR</seealso>
    <seealso cref='O:XSharp.RT.Functions.AsSymbol'>AsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTOC'>LToC</seealso>
  </asstring>
  <assymbol>
    <summary>
      Convert a string or a PSZ to a symbol.
    </summary>

    <param name="uValue">
      The value to be converted.<br/>
      Possible data types for <paramref name="uValue" /> are STRING, PSZ, or SYMBOL.
    </param>
    <returns>
      The converted value as a symbol.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example converts a string to a symbol.<br/>
      One reason for doing this is to boost performance, since symbol comparisons are faster than string comparisons.
      <code language="X#">
        symFind := AsSymbol("ALongPassword!")
        &#0009;// Do a faster search
        AScan(aSymList, symFind)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsHexString'>AsHexString</seealso>
    <seealso cref='O:XSharp.RT.Functions.AsString'>AsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.String2Atom'>String2Atom</seealso>
    <seealso cref='O:XSharp.RT.Functions.String2Symbol'>String2Symbol</seealso>
  </assymbol>
  <at>
    <summary>
      Return the position of the first occurrence of a substring within a string.
    </summary>

    <param name="cSearch">The substring to search for.</param>
    <param name="cTarget">The string in which to search.  (To start at a specific offset, use At3().)</param>
    <returns>
      The position of the first occurrence of <paramref name="cSearch" /> within <paramref name="cTarget" />.<br/>
      If <paramref name="cSearch" /> is not found, At() returns 0.
    </returns>
    <remarks>
      If you only need to know whether a substring exists within another string, use the InStr() function or the $ operator.<br/>
      To find the last occurrence of a substring within a string, use RAt().
      Both the At() and RAt() functions are used with Substr(), Left(), and Right() to extract substrings.
    </remarks>
    <example>
      These examples show typical uses of At():
      <code language="X#">
        ? At("a", "abcde")&#0009;&#0009;&#0009;// 1
        ? At("bcd", "abcde")&#0009;&#0009;// 2
        ? At("a", "bcde")&#0009;&#0009;&#0009;// 0
      </code>
      This example uses strong typing to split a string based on the position of a comma within the target string:
      <code language="X#">
        LOCAL cTarget AS STRING
        cTarget := "Langtree, Lilly"
        ? Substr(cTarget, 1, At(",", cTarget) - 1)&#0009;// Langtree
        ? Substr(cTarget, At(",", cTarget) + 2)&#0009;&#0009;// Lilly
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At2'>At2</seealso>
    <seealso cref='O:XSharp.Core.Functions.At3'>At3</seealso>
    <seealso cref='O:XSharp.Core.Functions.AtC'>AtC</seealso>
    <seealso cref='O:XSharp.Core.Functions.AtC2'>AtC2</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATCLine'>AtCLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATCLine2'>AtCLine2</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATLine'>AtLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATLine2'>AtLine2</seealso>
    <seealso cref='O:XSharp.Core.Functions.Instr'>InStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.Core.Functions.Occurs'>Occurs</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </at>
  <at2>
    <summary>
      Return the position of the first occurrence of a substring within a string.
    </summary>

    <param name="cSearch">The substring for which to search.</param>
    <param name="cTarget">The string in which to search.  (To start at a specific offset, use At3().)</param>
    <returns>
      The position of the first occurrence of <paramref name="cSearch" /> within <paramref name="cTarget" />.<br/>
      If <paramref name="cSearch" /> is not found, At2() returns 0.
    </returns>
    <remarks>
      At2() is like At() except that it returns a WORD.  See At() for more information.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.At3'>At3</seealso>
  </at2>
  <at3>
    <summary>
      Return the position of the first occurrence of a substring within a string, starting at a specified position.
    </summary>

    <param name="cSearch">The substring to search for.</param>
    <param name="cTarget">The string in which to search.</param>
    <param name="dwOffset">
      The position in the string at which to start searching.<br/>
      A value of zero corresponds to the first byte.
    </param>
    <returns>
      The position of the first occurrence of <paramref name="cSearch" /> within <paramref name="cTarget" />.<br/>
      If <paramref name="cSearch" /> is not found, At3() returns 0.
    </returns>
    <remarks>
      At3() is the same as At(), except that you can specify an offset that tells where to start searching.
    </remarks>
    <example>
      These examples show typical uses of At3():
      <code language="X#">
        ? At3("a", "abcdeabc", 2)&#0009;&#0009;// 6
        ? At3("a", "bcde", 1)&#0009;&#0009;// 0
      </code>
      This example displays the position of every occurrence of a string within the source:
      <code language="X#">
        LOCAL dwOffset<br/>
        AS DWORD
        LOCAL dwFound := 1 AS DWORD
        LOCAL cSource AS STRING
        LOCAL cSearch AS STRING
        cSource := "Now know-how is valued"
        cSearch := "ow"
        DO WHILE dwFound != 0
        &#0009;? dwFound := At3(cSearch, cSource, wOffset)
        &#0009;dwOffset := dwFound + SLen(cSearch)
        END
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.At2'>At2</seealso>
    <seealso cref='O:XSharp.Core.Functions.AtC'>AtC</seealso>
    <seealso cref='O:XSharp.Core.Functions.Occurs'>Occurs</seealso>
  </at3>
  <atail>
    <summary>
      Return the highest numbered element of an array.
    </summary>

    <param name="aTarget">The array.</param>
    <returns>
      The contents of the last array element.
    </returns>
    <remarks>
      ATail() returns the highest numbered element of an array.<br/>
      It can be used in applications as shorthand for <paramref name="aArray" />[ALen(<paramref name="aArray" />)] when you need to obtain the last element of an array.
    </remarks>
    <example>
      The following example creates a literal array and returns the last element of the array:
      <code language="X#">
        aArray := {"a", "b", "c", "d"}
        ? ATail(aArray)&#0009;&#0009;&#0009;// d
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ALen'>ALen</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
  </atail>

  <acos>
    <summary>
      Returns the arc cosine of a specified numeric expression.
    </summary>
    <param name="nExpression">

      Specifies a numeric expression whose arc cosine ACOS( ) returns. The value of nExpression can range from –1 through +1. The value returned by ACOS( ) ranges from 0 through pi (3.141592). The number of decimal places ACOS( ) returns is determined by SET DECIMALS.
      Use RTOD( ) to convert radians to degrees.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The arc cosine is returned in radians.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? RTOD(ACOS(0))  // Displays 90.00
        STORE -1 to gnArcAngle
        ? RTOD(ACOS(gnArcAngle))  // Displays 180.00
        ? RTOD(ACOS(SQRT(2)/2))  // Displays 45.00
      </code>
    </example>
  </acos>
  <asin>
    <summary>
      Returns in radians the arc sine of a numeric expression.
    </summary>
    <param name="nExpression">

      Specifies the numeric expression whose arc sine ASIN( ) returns. The value of nExpression can range from +1 through –1, and the value ASIN( ) returns can range from –pi/2 through +pi/2 ( –1.57079 to 1.57079). The number of decimal places in the display of the result can be specified with SET DECIMALS.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      Use RTOD( ) to convert radians to degrees.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? RTOD(ASIN(0))  // Returns 0.00
        STORE 1 to gnArcAngle
        ? RTOD(ASIN(gnArcAngle))  // Returns 90.00
        ? RTOD(ASIN(SQRT(2)/2))  // Returns 45.00
      </code>
    </example>
  </asin>


  <atan2>
    <summary>
      Returns the angle whose tangent is the quotient of two specified numbers.
    </summary>

    <param name="nX">Any numeric value.</param>
    <param name="nY">Any numeric value.</param>
    <returns>
      Returns the angle whose tangent is the quotient of two specified numbers.
    </returns>
  </atan2>
  <pi>
    <summary>
      Returns the numeric constant pi.
    </summary>
    <returns>
      PI( )Return Value
      Numeric
    </returns>
    <remarks>
      The numeric constant pi (3.141592) is the ratio of the circumference of a circle to its diameter.
      The number of decimal places displayed in the value returned by <b>PI( )</b> is determined by SET DECIMALS.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? PI( ) // Displays 3.14
        STORE 2.30 TO gnRadius
        STORE PI( ) * gnRadius^2 TO gnArea
        ? gnArea  // Displays 16.6190
      </code>
    </example>
  </pi>
  <rtod>
    <summary>
      Converts radians to its equivalent in degrees.
      You can use RTOD( ) when working with the X# trigonometric functions COS( ), SIN( ), and TAN( ).
    </summary>
    <param name="nExpression">

      Specifies a numeric expression representing a radian value.
    </param>
    <returns>
      Numeric data type. RTOD( ) returns the number of degrees converted from the number of radians.
    </returns>
    <remarks>
      To convert degrees to radians, use the DTOR( ) function.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? RTOD(ACOS(0))  // Displays 90.00
        STORE -1 to gnArcAngle
        ? RTOD(ACOS(gnArcAngle))  // Displays 180.00
        ? RTOD(ACOS(SQRT(2)/2)) // Displays 45.00
      </code>
    </example>

  </rtod>
  <dtor>
    <summary>
      Converts degrees to radians.
    </summary>
    <param name="nExpression">

      Specifies the numeric expression whose value you want to convert to radians. An angle expressed in a degree:minute:second format should be converted to its decimal equivalent.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      DTOR( ) converts the value of a numeric expression given in degrees to an equivalent value in radians. DTOR( ) is useful for working with the X# trigonometric functions: ACOS( ), ASIN( ), COS( ), SIN( ), TAN( ).
      Use RTOD( ) to convert radians to degrees.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? DTOR(0)  // Displays 0.00
        ? DTOR(45) // Displays 0.79
        ? DTOR(90) // Displays 1.57
        ? DTOR(180)  // Displays 3.14
        ? COS(DTOR(90))  // Displays 0.00
      </code>
    </example>

  </dtor>
  <atan>
    <summary>
      Calculate the arc tangent of a number.
    </summary>

    <param name="nNum">Any numeric value.</param>
    <returns>
      A number between -PI/2 and PI/2, representing the angle, in radians, whose tangent is equal to <paramref name="nNum" />.
    </returns>
    <remarks>
      <note type="tip">
        The result only spans half a circle (from -PI/2 to PI/2).<br/>
        This implies that Tan() and ATan() are not inverse functions for values that do not lie between -PI/2 and PI/2. In other words, ATan(Tan(<paramref name="n" />)) does not always return <paramref name="n" />.  See the example below.
      </note>
    </remarks>
    <example>
      This example shows that, for a value of -1+PI, ATan() is not the inverse of Tan() but, for a value of -1, ATan() is the inverse of Tan().<br/>
      This is because the tangent of -1+PI is equal to Tan(-1+PI) or -1.56.<br/>
      The tangent of -1 is also equal to Tan(-1) or -1.56.<br/>
      The ATan() of -1.56 is ATan(-1.56) or -1.  Thus ATan(Tan(-1)) equals -1.  But ATan(Tan(-1+PI)) equals -1 which is not equal to -1+PI.
      <code language="X#">
        ? ATan(Tan(-1+PI)) <paramref name="" /> -1+PI&#0009;&#0009;// TRUE
        ? ATan(Tan(-1)) = -1&#0009;&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ACot'>ACot</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cos'>Cos</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cot'>Cot</seealso>
    <seealso cref='O:XSharp.RT.Functions.Sin'>Sin</seealso>
    <seealso cref='O:XSharp.RT.Functions.Tan'>Tan</seealso>
  </atan>
  <atc>
    <summary>
      Return the position of the first occurrence of a substring within a string, without regard for case.
    </summary>

    <param name="cSearch">The substring to search for.</param>
    <param name="cTarget">The string in which to search.</param>
    <returns>
      The position of the first occurrence of <paramref name="cSearch" /> within <paramref name="cTarget" />.<br/>
      If <paramref name="cSearch" /> is not found, AtC() returns 0.
    </returns>
    <remarks>
      If you only need to know whether a substring exists within another string, use the InStr() function or the $ operator.<br/>
      To find the last occurrence of a substring within a string, use RAt().
    </remarks>
    <example>
      These examples show typical use of AtC():
      <code language="X#">
        ? AtC("bcd", "ABCDE")&#0009;&#0009;// 2
        ? AtC("a", "bcde")&#0009;&#0009;&#0009;// 0
        ? AtC("a", "AbCdE")&#0009;&#0009;&#0009;// 1
      </code>
      This example uses strong typing to do the same thing more efficiently:
      <code language="X#">
        LOCAL cSearch AS STRING
        LOCAL cTarget AS STRING
        cSearch := "a"
        cTarget := "AbCdE"
        ? AtC(cSearch, cTarget)&#0009;&#0009;// 1
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.AtC2'>AtC2</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATCLine'>AtCLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.Instr'>InStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Occurs'>Occurs</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
  </atc>
  <atc2>
    <summary>
      Return the position of the first occurrence of a substring within a string, without regard for case.
    </summary>

    <param name="cSearch">The substring for which to search.</param>
    <param name="cTarget">The string in which to search.</param>
    <returns>
      The position of the first occurrence of <paramref name="cSearch" /> within <paramref name="cTarget" />.<br/>
      If <paramref name="cSearch" /> is not found, AtC2() returns 0.
    </returns>
    <remarks>
      AtC2() is like AtC() except that it returns a WORD.  See AtC() for more information.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AtC'>AtC</seealso>
  </atc2>
  <atcline>
    <summary>
      Return the line number of the first occurrence of a substring within a multiple line string, without regard for case.
    </summary>

    <param name="cSearch">The substring to search for.</param>
    <param name="cTarget">The string in which to search.</param>
    <returns>
      The position of the first occurrence of <paramref name="cSearch" /> within <paramref name="cTarget" />.<br/>
      If <paramref name="cSearch" /> is not found, AtCLine() returns 0.
    </returns>
    <remarks>
      If you only need to know whether a substring exists within another string, use the InStr() function or the $ operator.
    </remarks>
    <example>
      These examples show typical use of AtCLine():
      <code language="X#">
        LOCAL cBigString AS STRING
        cBigString := "This is the first line" + ;
        &#0009;CRLF + "This is the second line" + ;
        &#0009;CRLF + "This is the third line"
        ? AtCLine("tHiRd", cBigString)&#0009;&#0009;&#0009;// 3
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATCLine2'>AtCLine2</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATLine'>AtLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.Instr'>InStr</seealso>
  </atcline>
  <atcline2>
    <summary>
      Return the line number of the first occurrence of a substring within a multiple line string, without regard for case.
    </summary>

    <param name="cSearch">The substring for which to search.</param>
    <param name="cTarget">The string in which to search.</param>
    <returns>
      The position of the first occurrence of <paramref name="cSearch" /> within <paramref name="cTarget" />.<br/>
      If <paramref name="cSearch" /> is not found, AtCLine2() returns 0.
    </returns>
    <remarks>
      AtCLine2() is like AtCLine() except that it returns a WORD.  See AtCLine() for more information.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ATCLine'>AtCLine</seealso>
  </atcline2>
  <atline>
    <summary>
      Return the line number of the first occurrence of a substring within a multiple line string.
    </summary>

    <param name="cSearch">The substring to search for.</param>
    <param name="cTarget">The string in which to search.</param>
    <returns>
      The position of the first occurrence of <paramref name="cSearch" /> within <paramref name="cTarget" />.<br/>
      If <paramref name="cSearch" /> is not found, AtLine() returns 0.
    </returns>
    <remarks>
      If you only need to know whether a substring exists within another string, use the InStr() function or the $ operator.
    </remarks>
    <example>
      These examples show typical use of AtLine():
      <code language="X#">
        LOCAL cBigString AS STRING
        cBigString := "This is the first line" + ;
        &#0009;CRLF + "This is the second line" + ;
        &#0009;CRLF + "This is the third line"
        ? AtLine("third", cBigString)&#0009;&#0009;&#0009;// 3
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At Function</seealso>
    <seealso cref='O:XSharp.Core.Functions.AtC'>AtC Function</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATCLine'>AtCLine Function</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATLine2'>AtLine2 Function</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrTran'>StrTran Function</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr Function</seealso>
  </atline>
  <atline2>
    <summary>
      Return the line number of the first occurrence of a substring within a multiple line string.
    </summary>

    <param name="cSearch">The substring for which to search.</param>
    <param name="cTarget">The string in which to search.</param>
    <returns>
      The position of the first occurrence of <paramref name="cSearch" /> within <paramref name="cTarget" />.<br/>
      If <paramref name="cSearch" /> is not found, AtLine2() returns 0.
    </returns>
    <remarks>
      AtLine2() is like AtLine() except that it returns a WORD.  See AtLine() for more information.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ATLine'>AtLine</seealso>
  </atline2>
  <atranslate>
    <summary>
      Translate a value to another value, using a two-dimensional array as a lookup table.<br/>
      The shape of the array matches that returned by DBServer:GetLookupTable.
    </summary>

    <param name="aLookupTable">
      A rectangular array dimensioned n by 2.<br/>
      A lookup table has two elements, each of which is a single-dimensioned array, and the two arrays have the same length.  (This is the type of array returned by DBServer:GetLookupTable.) The first linear array is used to look up the value, and the second is used to get the translated value.
    </param>
    <param name="uValue">
      A value to be translated.<br/>
      The value should match the types of the values in the first column of the <paramref name="aLookupTable" /> array.
    </param>
    <param name="lSoftSeek">
      Indicates whether soft seeking should be used.<br/>
      If TRUE, the first value greater than <paramref name="uValue" /> is used to yield the return value; if FALSE, only exact matches yield a return value.<br/>
      This argument is optional; if omitted, FALSE is assumed.  (This default does not depend on SetSoftSeek().)
    </param>
    <returns>
      The looked-up value from the second column of the array, of whatever data type the array contains.<br/>
      If no match is found (with soft seeking off), or if <paramref name="uValue" /> is greater than all the elements in the lookup table (with soft seeking on), it returns NIL.
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </atranslate>
  <between>
    <summary>
      Determine if a value is between two other values.
    </summary>
    <param name="uValue">
      A value of any type to compare to <paramref name="uMin" /> and <paramref name="uMax" />.
    </param>
    <param name="uMin">
      The minimum value to compare with.<br/>
      This must be of the same type as <paramref name="uValue" /> except that numerics of different types are allowed.
    </param>
    <param name="uMax">
      TThe maximum value to compare with.
      This must be of the same type as <paramref name="uValue" /> except that numerics of different types are allowed.
    </param>
    <returns>
      TRUE if the value is greater than or equal to the minimum and less than or equal to the maximum otherwise, FALSE.
    </returns>
    <remarks>
      Between() can be used to do advanced searching on polymorphic data types.<br/>
      For example, it can determine whether
      &#0009;A character falls between 2 other characters, either in the alphabet or the ASCII chart
      &#0009;A date falls between 2 other dates
      &#0009;A number falls between 2 other numbers
      <note type="tip">
        String comparisons:  String comparisons are nation-dependent.  Be aware that a character can fall between 2 other characters in the ANSI character set but not in the OEM character set.  Thus, when passing strings you may often need to specify whether the ANSI or the OEM character set should be used.
        Floating point comparisons:  SetFloatDelta() affects the outcome of Between().
      </note>
    </remarks>
    <example>
      These examples show what would happen if you use Between() to search for the letters "cd" in a list of the alphabet:
      <code language="X#">
        ? Between("cd", "ab", "ef")&#0009;// TRUE
        ? Between("cd", "gh", "kl")&#0009;// FALSE
      </code>
      This example determines whether today's date is between 12/12/93 and 12/12/94:
      <code language="X#">
        // Return value depends on today's date
        ? Between(Today(), 93.12.12, 94.12.12)
      </code>
      This example does comparisons based on numbers:
      <code language="X#">? Between(2, 1, 3)&#0009;&#0009;// TRUE</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.RT.Functions.Max'>Max</seealso>
    <seealso cref='O:XSharp.Core.Functions.Max'>Max</seealso>
    <seealso cref='O:XSharp.RT.Functions.Min'>Min</seealso>
    <seealso cref='O:XSharp.Core.Functions.Min'>Min</seealso>
    <seealso cref='O:XSharp.RT.Functions.SetFloatDelta'>SetFloatDelta</seealso>
  </between>

  <bin2date>
    <summary>
      Convert a string containing a 32-bit binary date to a date data type.
    </summary>

    <param name="cString">A 32-bit binary date represented as a string — least significant byte first.  Only the first 4 bytes are used by the function; all others are ignored.</param>
    <returns>
      A date value that corresponds to the date specified in <paramref name="cString" />.<br/>
      If <paramref name="cString" /> is not a valid binary date, Bin2Date() returns a NULL_DATE.
    </returns>
    <remarks>
      Bin2Date() is a conversion function that converts the first 4 bytes of a string to a date.  Typical applications include reading foreign file types in their native format then saving, reading, decrypting, and transmitting date types in their compressed binary form instead of in strings.<br/>
      Its inverse is Date2Bin().
    </remarks>
    <example>
      This example illustrate Bin2Date():
      <code language="X#">? Bin2Date("!$%" + Chr(0))&#0009;// 03/09/52</code>
      This example shows the inverse relationship of Bin2Date() and Date2Bin():
      <code language="X#">? Bin2Date(Date2Bin(Today()))&#0009;// Today's date</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2date>
  <bin2dw>
    <summary>
      Convert a string containing a 32-bit unsigned integer to a double word.
    </summary>

    <param name="cUnsignedInt">A 32-bit unsigned integer represented as a string — least significant byte first.  Only the first 4 bytes are used by the function; all others are ignored. </param>
    <returns>
    </returns>
    <remarks>
      Bin2DW() is a conversion function that converts the first 4 bytes of a string to a double word.  Typical applications include reading foreign file types in their native format then saving, reading, decrypting, and transmitting numeric data in their compressed binary form instead of in strings.<br/>
      Its inverse is DW2Bin().
    </remarks>
    <example>
      This example is passed 4 ASCII characters and returns a number that is 10 digits long:
      <code language="X#">? Bin2DW("abcd")&#0009;&#0009;// 1684234849</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2dw>
  <bin2f>
    <summary>
      Convert a string containing a 80-bit floating point number to a float value.
    </summary>

    <param name="cFloat">An 80-bit floating point number represented as a string — least significant byte first.</param>
    <returns>
    </returns>
    <remarks>
      Bin2F() is a conversion function that converts a binary string into a floating point number.  Typical applications include reading foreign file types in their native format then saving, reading, decrypting, and transmitting numeric data in their compressed binary form instead of in strings.<br/>
      Its inverse is F2Bin().
    </remarks>
    <example>
      This example decrypts a converted floating point numeric back to its original format:
      <code language="X#">
        FUNCTION Start()
        LOCAL cEncrypt AS STRING
        LOCAL fDecrypt AS FLOAT
        cEncrypt := F2Bin(12365789.96587)&#0009;// Encrypting
        fDecrypt := Bin2F(cEncrypt)&#0009;&#0009;// Decrypting
        ? fDecrypt&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 12365789.96587
        RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2f>
  <bin2i>
    <summary>
      Convert a string containing a 16-bit signed integer to a short integer.
    </summary>

    <param name="cSignedInt">A 16-bit signed integer represented as a string — least significant byte first.  Only the first 2 bytes are used by the function; all others are ignored.</param>
    <returns>
    </returns>
    <remarks>
      Bin2I() is a conversion function that converts the first 2 bytes of a string to a short integer.  Typical applications include reading foreign file types in their native format then saving, reading, decrypting, and transmitting long numeric data in their compressed binary form instead of in strings.
      Positive numbers with 2 digits or less will not save disk space when converted.<br/>
      For numbers that fall between 0 and 255, you can use Chr() or _Chr().
      The inverse of Bin2I() is I2Bin().
    </remarks>
    <example>
      This example opens a database file using file functions and reads the date of last update (bytes 1-3).<br/>
      The result is the same as LUpdate():
      <code language="X#">
        ptrHandle := FOpen2("sales.dbf", FO_READ)&#0009;// Point to byte 1 in the file
        FSeek(ptrHandle, 1, FS_SET)&#0009;&#0009;&#0009;// Read date of last update
        siYear  := Bin2I(FReadStr(ptrHandle, 1) + _Chr(0))
        siMonth := Bin2I(FReadStr(ptrHandle, 1) + _Chr(0))
        siDay   := Bin2I(FReadStr(ptrHandle, 1) + _Chr(0))
        ? NTrim(siMonth), NTrim(siDay), NTrim(siYear)
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2i>
  <bin2l>
    <summary>
      Convert a string containing a 32-bit signed integer to a long integer.
    </summary>

    <param name="cSignedInt">A 32-bit signed integer represented as a string — least significant byte first.  Only the first 4 bytes are used by the function; all others are ignored.</param>
    <returns>
    </returns>
    <remarks>
      Bin2L() is a conversion function that converts the first 4 bytes of a string to a long integer.  Typical applications include reading foreign file types in their native format then saving, reading, decrypting, and transmitting numeric data in their compressed binary form instead of in strings.<br/>
      Its inverse is L2Bin().
    </remarks>
    <example>
      This example opens a database file using file functions and reads the number of records (bytes 4-7).<br/>
      The result is the same as LastRec():
      <code language="X#">
        ptrHandle := FOpen2("sales.dbf", FO_READ)&#0009;// Sales.dbf contains 84 records
        FSeek(ptrHandle, 4, FS_SET)&#0009;&#0009;&#0009;// Point to byte 4
        cRecords := Space(4)
        FRead(ptrHandle, @cRecords, 4)&#0009;&#0009;&#0009;// Read the number of records
        ? LTrim(Str(Bin2L(cRecords)))&#0009;&#0009;&#0009;// 84
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2l>
  <bin2logic>
    <summary>
      Convert a string containing an 8-bit logical into a logical value.
    </summary>

    <param name="pszLogical">An 8-bit logical represented as a string.</param>
    <returns>
    </returns>
    <remarks>
      Bin2Logic() is a conversion function that converts the first byte of a string to a logical.  Typical applications include saving data in their native format, data decryption, and transmitting logical data in their binary form.<br/>
      Its inverse is Logic2Bin().
    </remarks>
    <example>
      This example opens a file using file functions, reads the first byte as a binary logical, then converts it into a logical value:
      <code language="X#">
        ptrHandle := FOpen("sales.txt", FO_READ)
        cByte := Space(1)
        FRead(ptrHandle, @cByte, 1)
        ? Bin2Logic(cByte)))&#0009;&#0009;&#0009;// Returns either TRUE or FALSE
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Logic2Bin'>Logic2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTOC'>LToC</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2logic>
  <bin2real4>
    <summary>
      Convert a string containing a 32-bit floating point number to a Real4 value.
    </summary>

    <param name="cFloat">A 32-bit floating point number represented as a string — least significant byte first.  Only the first 4 bytes are used by the function; all others are ignored. </param>
    <returns>
    </returns>
    <remarks>
      Bin2Real4() is a conversion function that converts the first 4 bytes of a string to a 32-bit floating point number.  Typical applications include reading foreign file types in their native format then saving, reading, decrypting, and transmitting numeric data in their compressed binary form instead of in strings.<br/>
      Its inverse is Real42Bin().
    </remarks>
    <example>
      This example shows that Real42Bin() is the inverse of Bin2Real4():
      <code language="X#">
        cString := Real42Bin(1245633.25)
        ? cString&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 4-byte string
        ? Bin2Real4(cString)&#0009;&#0009;&#0009;// 1245633.25
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2real4>
  <bin2real8>
    <summary>
      Convert a string containing a 32-bit floating point number to a Real8 value.
    </summary>

    <param name="cFloat">A 32-bit floating point number represented as a string — least significant byte first.  Only the first 8 bytes are used by the function; all others are ignored. </param>
    <returns>
    </returns>
    <remarks>
      Bin2Real8() is a conversion function that converts the first 8 bytes of a string to a 32-bit floating point number.  Typical applications include reading foreign file types in their native format then saving, reading, decrypting, and transmitting numeric data in their compressed binary form instead of in strings.<br/>
      Its inverse is Real82Bin().
    </remarks>
    <example>
      This example shows that Real82Bin() is the inverse of Bin2Real8():
      <code language="X#">
        cString := Real82Bin(1245633.25)
        ? cString&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 8-byte string
        ? Bin2Real8(cString)&#0009;&#0009;&#0009;// 1245633.25
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real82Bin'>Real82Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2real8>
  <bin2w>
    <summary>
      Convert a string containing a 16-bit unsigned integer to a word.
    </summary>

    <param name="cUnsignedInt">A 16-bit unsigned integer represented as a string — least significant byte first.  Only the first 2 bytes are used by the function; all others are ignored.</param>
    <returns>
    </returns>
    <remarks>
      Bin2W() is a conversion function that converts the first 2 bytes of a string to a word.  Typical applications include reading foreign file types in their native format then saving, reading, decrypting, and transmitting numeric data in their compressed binary form instead of in strings.<br/>
      Its inverse is W2Bin().
    </remarks>
    <example>
      This example opens a database file using file functions and reads the number of bytes per record (bytes 10-11).<br/>
      The result is the same as RecSize():
      <code language="X#">
        ptrHandle := FOpen2("sales.dbf", FO_READ)
        // Note: The length of a record in sales.dbf is 124
        // Point to byte 10, the first record size byte
        FSeek(ptrHandle, 10, FS_SET)
        cRecSize := Space(2)&#0009;&#0009;&#0009;// Read record size
        FRead(ptrHandle, @cRecSize, 2)
        ? NTrim(Bin2W(cRecSize)))&#0009;&#0009;&#0009;// 124
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2w>
  <blobdirectexport>
    <summary>
      Export the contents of a binary large object (BLOB) pointer to a file.
      Note:<br/>
      A BLOB file (.DBV or .FPT) is used for storing memo field information, as an alternative to the standard .DBT file mechanism supported by some RDDs.<br/>
      It is a more powerful and efficient mechanism for storing and retrieving large amounts of data than using .DBT files.  X# supplies the DBFCDX driver, which uses the BLOB file storage mechanism by default, and the DBFBLOB driver, which you can use as an inherited driver with other RDDs.
    </summary>

    <param name="nPointer">
      A pointer to the BLOB data.<br/>
      This pointer can be obtained using BLOBDirectPut(), BLOBDirectExport(), or DBFieldInfo(DBS_BLOB_POINTER, <paramref name="nFieldPos" />).
    </param>
    <param name="cTargetFile">
      The name of the target file where the BLOB data will be written, including an optional drive, directory, and extension.  See SetDefault() and SetPath() for file searching and creation rules.  No default extension is assumed.<br/>

      &#0009;If <paramref name="cTargetFile" /> does not exist, it is created.<br/>
      If it exists, this function attempts to open the file in exclusive mode and, if successful, the file is written to without warning or error.<br/>
      If access is denied because, for example, another process is using the file, NetErr() is set to TRUE.
    </param>
    <param name="kMode">
      A constant defining the copy mode, as shown in the table below:<br/>

      <list>
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>BLOB_EXPORT_APPEND</term>
          <description>Appends to the file</description>
        </item>
        <item>
          <term>BLOB_EXPORT_OVERWRITE</term>
          <description>Overwrites the file — this is the default</description>
        </item>

      </list>
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example extracts an array of pointers from the BLOB file's root area, then uses one of the pointers to export a picture to a file:
      <code language="X#">
        FUNCTION PutPix()
        &#0009;LOCAL cPixFile AS STRING
        &#0009;LOCAL nPointer
        &#0009;LOCAL aBLOBPtrs AS ARRAY
        &#0009;cPixFile := "picture.gif"
        &#0009;// Customer database with a picture of
        &#0009;// each customer stored in a field called Pix
        &#0009;USE customer NEW VIA "DBFCDX"
        &#0009;// Assumes that the program previously
        &#0009;// stored an array of direct BLOB pointers
        &#0009;// into the root area of the BLOB file.
        &#0009;// The picture that we want is assumed to
        &#0009;// be the second array element.
        &#0009;aBLOBPtrs := BLOBRootGet()
        &#0009;nPointer := aBLOBPtrs[2]
        &#0009;// Export picture pointed to by nPointer to a file
        &#0009;IF !BLOBDirectExport(nPointer, cPixFile, ;
        &#0009;&#0009;BLOB_EXPORT_OVERWRITE)
        &#0009;&#0009;&#0009;Alert("Export of picture " + cPixFile + ";
        &#0009;&#0009;&#0009;&#0009;failed!")
        &#0009;ELSE
        &#0009;&#0009;// Code for displaying picture would go here
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBDirectImport'>BLOBDirectImport</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBExport'>BLOBExport</seealso>
  </blobdirectexport>
  <blobcommon>
    <param name="nStart">
      The starting position.<br/>
      If <paramref name="nStart" /> is positive, the starting position is relative to the leftmost character in <paramref name="nPointer" />.<br/>
      If <paramref name="nStart" /> is negative, it is relative to the rightmost character in <paramref name="nPointer" />.<br/>
      If <paramref name="nStart" /> is omitted, it is assumed to be 1.
    </param>
    <param name="nCount">
      The number of bytes of data to retrieve, beginning at <paramref name="nStart" />.<br/>
      If <paramref name="nCount" /> is larger than the amount of data stored, excess data is ignored.<br/>
      If omitted, the function retrieves to the end of the data.
    </param>
    <param name="nPointer">
      A pointer to the BLOB data.<br/>
      This pointer can be obtained using BLOBDirectPut(), BLOBDirectImport(), or DBFieldInfo(DBS_BLOB_POINTER, <paramref name="nFieldPos" />).
    </param>

  </blobcommon>
  <blobdirectget>
    <summary>
      Retrieve data stored in a BLOB file without referencing a specific field.
    </summary>
    <include file="VoFunctionDocs.xml" path="Runtimefunctions/blobcommon/*" />
    <returns>
      The data retrieved from the BLOB file.<br/>
      The data type of the return value depends on the actual data stored.<br/>
      Use ValType() or UsualType() to determine the data type.
    </returns>
    <remarks>
      BLOBDirectGet() retrieves data stored in a BLOB file without the need to reference a particular field in the database file.<br/>
      It is particularly useful when accessing data that is larger than 64 KB, (such as memo fields created with the BLOBImport() function).
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example illustrates storing setup information in a BLOB file, then selectively retrieving the stored information:
      <code language="X#">
        FUNCTION PutSettings(aColors AS ARRAY,;
        &#0009;aPaths AS ARRAY, aPassWords AS ARRAY) AS VOID
        &#0009;LOCAL aSettings AS ARRAY
        &#0009;USE setup NEW VIA DBFBLOB
        &#0009;aSettings := {}
        &#0009;AADD(aSettings, BLOBDirectPut(0, aColors))
        &#0009;AADD(aSettings, BLOBDirectPut(0, aPaths))
        &#0009;AADD(aSettings, BLOBDirectPut(0, aPassWords))
        &#0009;BLOBRootPut(aSettings)
        &#0009;CLOSE
        FUNCTION GetColors() AS ARRAY
        &#0009;LOCAL aSettings   AS ARRAY
        &#0009;LOCAL aColors     AS ARRAY
        &#0009;USE setup NEW VIA DBFBLOB
        &#0009;aSettings := BLOBRootGet()
        &#0009;aColors := BLOBDirectGet(aSettings[1])
        &#0009;CLOSE
        &#0009;RETURN aColors
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBDirectPut'>BLOBDirectPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBGet'>BLOBGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBImport'>BLOBImport</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
    <seealso cref='O:XSharp.RT.Functions.ValType'>ValType</seealso>
  </blobdirectget>
  <blobdirectimport>
    <summary>
      Import a file into a BLOB file and return a pointer to the data.
    </summary>

    <param name="nOldPointer">
      A pointer to the BLOB data which will be released after the import.<br/>
      This pointer can be obtained using BLOBDirectPut(), BLOBDirectImport(), or DBFieldInfo(DBS_BLOB_POINTER, <paramref name="nFieldPos" />).  Passing 0 disables the release of data.<br/>

      &#0009;If specified, BLOBDirectImport() releases the space associated with <paramref name="nOldPointer" /> for reuse by other data.<br/>
      Therefore, it is illegal to use <paramref name="nOldPointer" /> with any of the BLOB functions after passing it as an argument to this function.<br/>
      Use the function's return value to refer to the newly stored data.
    </param>
    <param name="cSourceFile">
      The name of the file from which to read the BLOB data, including an optional drive, directory, and extension.  
      See SetDefault() and SetPath() for file searching and creation rules.  No default extension is assumed.<br/>
      This function attempts to open <paramref name="cSourceFile" /> in shared mode.<br/>
      If the file does not exist, a runtime error is raised.<br/>
      If the file is successfully opened, the operation proceeds.<br/>
      If access is denied because, for example, another process has exclusive use of the file, NetErr() is set to TRUE.
    </param>
    <returns>
      A numeric pointer to the BLOB image stored in <paramref name="cSourceFile" />.
    </returns>
    <remarks>
      BLOBDirectImport() provides a mechanism for copying the contents of a file into a BLOB file.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      BLOBDirectImport() is used in conjunction with BLOBDirectExport() to transfer 
      data back and forth between external files and BLOB files.  
      You can use BLOBDirectImport() with a variety of file types, including graphics images, 
      word processor files, and printer fonts.<br/>
      These two functions are excellent for creating databases of documents, graphics, sounds, and so on.
      After importing a file with BLOBDirectImport(), nNewPointer, the return value, is the only 
      way to access the data from the BLOB file.<br/>
      It is up to you, the developer, to provide permanent storage for this reference (see example below)
      Note:  DBFieldInfo(DBS_BLOB_TYPE, <paramref name="nFieldPos" />) will return "C" (string) for any memo field created using BLOBDirectImport().
    </remarks>
    <example>
      This example imports a .BMP file to be part of an array of startup data.<br/>
      The data, stored in the root area of the BLOB file, could then be used to display 
      the application's startup screen:
      <code language="X#">
        FUNCTION PutPix()
        &#0009;LOCAL cBMPFile AS STRING
        &#0009;LOCAL aSettings AS ARRAY
        &#0009;cBMPFile := "logo.bmp"
        &#0009;aSettings := {}
        &#0009;// Customer database where startup parameters
        &#0009;// are stored for convenience
        &#0009;USE customer NEW VIA "DBFCDX"
        &#0009;// Get default path settings
        &#0009;AAdd(aSettings, StartPaths())
        &#0009;// Get default color settings
        &#0009;AAdd(aSettings, DefaultColors())
        &#0009;// Get company logo for display at startup.
        &#0009;// There is nothing to free because this
        &#0009;// is the first time importing.
        &#0009;nPointer := BLOBDirectImport(0, cBMPFile)
        &#0009;AAdd(aSettings, nPointer)
        &#0009;// Store the settings in the root area of
        &#0009;// the customer.fpt file
        &#0009;BLOBRootPut(aSettings)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBDirectExport'>BLOBDirectExport</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBImport'>BLOBImport</seealso>
  </blobdirectimport>
  <blobdirectput>
    <summary>
      Put data in a BLOB file without referencing a specific field.
    </summary>

    <param name="nOldPointer">
      A reference to previously stored BLOB data.<br/>
      This reference can be obtained using BLOBDirectPut(), BLOBDirectImport(), or DBFieldInfo(DBS_BLOB_POINTER, <paramref name="nFieldPos" />).<br/>
      If other than 0, the data referenced by <paramref name="nOldPointer" /> is replaced by <paramref name="uBLOB" />; otherwise, <paramref name="uBLOB" /> is added to the current contents of the BLOB file.<br/>

      &#0009;<br/>

      &#0009;Important!<br/>
      If specified, BLOBDirectPut() releases the space associated with <paramref name="nOldPointer" /> for reuse by other data.<br/>
      Therefore, it is illegal to use <paramref name="nOldPointer" /> with any of the BLOB functions after passing it as an argument to this function.<br/>
      Use the function's return value to refer to the newly stored data.
    </param>
    <param name="uBLOB">
      The data you want to put into the BLOB file.  <paramref name="uBLOB" /> can be any X# usual data type, except code block and object.
    </param>
    <returns>
      A numeric pointer to the <paramref name="uBLOB" /> data.
    </returns>
    <remarks>
      BLOBDirectPut() stores variable length BLOB data without creating a link with a particular memo field in a database file.
      After adding data to a BLOB file using BLOBDirectPut(), you should store the function's return value, as this is the only way to access the data from the BLOB file.<br/>
      It is up to you, the developer, to provide permanent storage for this reference (see BLOBRootPut()).
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example illustrates storing setup information in a BLOB file, then selectively retrieving the stored information:
      <code language="X#">
        FUNCTION PutSettings(aColors AS ARRAY,;
        &#0009;aPaths AS ARRAY, aPassWords AS ARRAY) AS VOID
        LOCAL aSettings AS ARRAY
        &#0009;USE setup NEW VIA DBFBLOB
        &#0009;aSettings := {}
        &#0009;AADD(aSettings, BLOBDirectPut(0, aColors))
        &#0009;AADD(aSettings, BLOBDirectPut(0, aPaths))
        &#0009;AADD(aSettings, BLOBDirectPut(0, aPassWords))
        &#0009;BLOBRootPut(aSettings)
        &#0009;CLOSE
        FUNCTION GetColors() AS ARRAY
        &#0009;LOCAL aSettings AS ARRAY
        &#0009;LOCAL aColors   AS ARRAY
        &#0009;USE setup NEW VIA DBFBLOB
        &#0009;aSettings := BLOBRootGet()
        &#0009;aColors := BLOBDirectGet(aSettings[1])
        &#0009;CLOSE
        &#0009;RETURN aColors
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBDirectGet'>BLOBDirectGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBExport'>BLOBExport</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBGet'>BLOBGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBImport'>BLOBImport</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootPut'>BLOBRootPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
  </blobdirectput>
  <blobexport>
    <summary>
      Copy the contents of a BLOB, identified by its memo field number, to a file.
    </summary>

    <param name="nFieldPos">The position of the field in the database file structure.</param>
    <param name="cTargetFile">
      The name of the target file where the BLOB data will be written, including an optional drive, directory, and extension.  See SetDefault() and SetPath() for file searching and creation rules.  No default extension is assumed.<br/>

      &#0009;If <paramref name="cTargetFile" /> does not exist, it is created.<br/>
      If it exists, this function attempts to open the file in exclusive mode and, if successful, the file is written to without warning or error.<br/>
      If access is denied because, for example, another process is using the file, NetErr() is set to TRUE.
    </param>
    <param name="kMode">
      A constant defining the copy mode, as shown in the table below:<br/>

      <list>
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>BLOB_EXPORT_APPEND</term>
          <description>Appends to the file</description>
        </item>
        <item>
          <term>BLOB_EXPORT_OVERWRITE</term>
          <description>Overwrites the file — this is the default</description>
        </item>

      </list>
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example exports the contents of a field that stores a picture to a .GIF file, so that the file can be programmatically displayed:
      <code language="X#">
        FUNCTION ShowPix()
        &#0009;LOCAL cPixFile := "picture.gif" AS STRING
        &#0009;LOCAL nPos
        &#0009;// Customer database with a picture of each
        &#0009;// customer stored in a field called Pix
        &#0009;USE customer NEW VIA "DBFCDX"
        &#0009;nPos := FIELDPOS("Pix")
        &#0009;// Export the BLOB file's data
        &#0009;// for the current Pix field
        &#0009;IF !BLOBExport(nPos, cPixFile,;
        &#0009;&#0009;BLOB_EXPORT_OVERWRITE)
        &#0009;&#0009;&#0009;Alert("Export of picture " + cPixFile + ";
        &#0009;&#0009;&#0009;&#0009;failed!")
        &#0009;ELSE
        &#0009;&#0009;// Code for displaying picture would go here
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBDirectExport'>BLOBDirectExport</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBImport'>BLOBImport</seealso>
  </blobexport>
  <blobget>
    <summary>
      Get the contents of a BLOB, identified by its memo field number.
    </summary>

    <param name="nFieldPos">The position of the field in the database file structure.</param>
    <include file="VoFunctionDocs.xml" path="Runtimefunctions/blobcommon/*" />
    <returns>
      The BLOB data retrieved from the memo field.<br/>
      The data type of the return value depends on the actual data stored.<br/>
      Use ValType() or UsualType() to determine the data type.<br/>
      If the indicated field is not a memo field, BLOBGet() returns NIL.
    </returns>
    <remarks>
      BLOBGet() is very similar to FieldGet().  However, because string type variables cannot be larger than 64 KB, FieldGet() will raise a runtime error when attempting to retrieve memo fields of this magnitude or greater.
      BLOBGet() will also raise an error if you attempt to retrieve a field greater than this magnitude; however, you can retrieve any subset of the BLOB data by using an <paramref name="nCount" /> less than 64 KB.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      Note:  BLOB data less than 64 KB can be retrieved from a memo field using standard means (for example, referring to the field by name in an expression or using the FieldGet() function).
    </remarks>
    <example>
      This example imports information from a word processing document into a field, then uses BLOBGet() to extract the first 25 characters of the field:
      <code language="X#">
        FUNCTION GetFirst25()
        &#0009;LOCAL nPos
        &#0009;LOCAL cStr AS STRING
        &#0009;USE customer NEW INHERIT FROM {"DBFBLOB"}
        &#0009;// Field that contains word processor
        &#0009;// documentation
        &#0009;nPos := FIELDPOS("WP_DOC")
        &#0009;// Import a file (can be larger than 64 KB), then
        &#0009;// obtain the first 25 characters to show to the
        &#0009;// user
        &#0009;IF BLOBImport(nPos, "c:\application\temp.doc")
        &#0009;&#0009;cStr := BLOBGet(nPos, 1, 25)
        &#0009;ELSE
        &#0009;&#0009;cStr := "Error: could not import file!"
        &#0009;ENDIF
        CLOSE
        RETURN cStr
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBDirectGet'>BLOBDirectGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBDirectPut'>BLOBDirectPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBImport'>BLOBImport</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetSym'>FieldGetSym</seealso>
  </blobget>
  <blobimport>
    <summary>
      Read the contents of a file as a BLOB, identified by a memo field number.
    </summary>

    <param name="nFieldPos">The position of the field in the database file structure.</param>
    <param name="cSourceFile">
      The name of the file from which to read the BLOB data, including an optional drive, directory, and extension.  
      See SetDefault() and SetPath() for file searching and creation rules.  No default extension is assumed.<br/>
      This function attempts to open <paramref name="cSourceFile" /> in shared mode.<br/>
      If the file does not exist, a runtime error is raised.<br/>
      If the file is successfully opened, the operation proceeds.<br/>
      If access is denied because, for example, another process has exclusive use of the file, NetErr() is set to TRUE.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      BLOBImport() provides a mechanism for copying the contents of a file into a memo field as BLOB data.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      BLOBImport() is used in conjunction with BLOBExport() to transfer BLOB data back 
      and forth between files and memo fields.  You can use BLOBImport() with a variety of file types, 
      including graphics images, word processor files, and printer fonts.<br/>
      These two functions are excellent for creating databases of documents, graphics, sounds, and so on.
      Note:  DBFieldInfo(DBS_BLOB_TYPE, <paramref name="nFieldPos" />) will return "C" (string) for 
      any memo field created using BLOBImport().
    </remarks>
    <example>
      This example imports information from a word processing document into a field, 
      then uses BLOBGet() to extract the first 25 characters of the field:
      <code language="X#">
        FUNCTION Populate()
        &#0009;USE customer NEW INHERIT FROM {"DBFBLOB"}
        &#0009;// Construct unique file name based on last
        &#0009;// name and id
        &#0009;DO WHILE .NOT. EOF()
        &#0009;&#0009;GetPix("Pix", SUBSTR(LastName, 1, 4) + CustID)
        &#0009;&#0009;Customer-&gt;DBSkip()
        &#0009;ENDDO
        FUNCTION GetPix(cPixField, cPixFile)
        &#0009;LOCAL nPos
        &#0009;nPos := FIELDPOS(cPixField)
        &#0009;// Import the picture file into indicated field
        &#0009;IF !BLOBImport(nPos, cPixFile)
        &#0009;&#0009;Alert("Import of picture " + cPixFile + "; failed!")
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBExport'>BLOBExport</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
  </blobimport>
  <blobrootget>
    <summary>
      Retrieve the data from the root area of a BLOB file.
    </summary>
    <returns>
      The data retrieved from the root of the BLOB file.<br/>
      The data type of the return value depends on the actual data stored.<br/>
      Use ValType() or UsualType() to determine the data type.  Note that BLOBRootGet() returns NIL if the root reference has never been written to with BLOBRootPut().
    </returns>
    <remarks>
      BLOBRootGet() allows the retrieval of a BLOB from the root of a BLOB file in a work area.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      Note:  Because the root data does not reference a particular record in the database file, the DBRLock() will not protect this root storage reference.<br/>
      Therefore, if the database file is opened in shared mode, you should use BLOBRootLock() before calling BLOBRootGet().
    </remarks>
    <example>
      This example uses BLOBRootGet() to read system settings from a BLOB file into an array, then demonstrates how to allow the user to modify the settings are restore them in the BLOB file:
      <code language="X#">
        FUNCTION UpdateSettings()
        &#0009;LOCAL aSettings AS ARRAY
        &#0009;USE customer NEW SHARED VIA "DBFCDX"
        &#0009;IF BLOBRootLock()
        &#0009;&#0009;// Get any existing settings
        &#0009;&#0009;aSettings := BLOBRootGet()
        &#0009;&#0009;IF EMPTY(aSettings)
        &#0009;&#0009;&#0009;// This function would populate aSettings
        &#0009;&#0009;&#0009;// with default data
        &#0009;&#0009;&#0009;aSettings := GetDefaultSettings()
        &#0009;&#0009;ENDIF
        &#0009;&#0009;// This function would allow the user to
        &#0009;&#0009;// modify the settings.
        &#0009;&#0009;IF ModifySettings(aSettings)
        &#0009;&#0009;&#0009;// Finally, store the settings
        &#0009;&#0009;&#0009;BLOBRootPut(aSettings)
        &#0009;&#0009;ENDIF
        &#0009;&#0009;BLOBRootUnLock()
        &#0009;ELSE
        &#0009;&#0009;aSettings := {}
        &#0009;&#0009;Alert("Could not obtain a lock on the root;
        &#0009;&#0009;&#0009;area")
        &#0009;ENDIF
        &#0009;CLOSE
        &#0009;RETURN aSettings
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootLock'>BLOBRootLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootPut'>BLOBRootPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUseArea'>DBUseArea</seealso>
  </blobrootget>
  <blobrootlock>
    <summary>
      Obtain a lock on the root area of a BLOB file.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      Use BLOBRootLock() when accessing the database file in shared mode to obtain a lock on the root area of a BLOB file for reading from or writing to the root area.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example illustrates how to properly lock and unlock the root area of a BLOB file for a database file opened in shared mode.
      <code language="X#">
        FUNCTION GetSettings()
        &#0009;LOCAL aCustSettings AS ARRAY
        &#0009;// Open a customer file in shared mode
        &#0009;USE customer NEW SHARED INHERIT FROM {"DBFBLOB"}
        &#0009;IF BLOBRootLock()
        &#0009;&#0009;aCustSettings := BLOBRootGet()
        &#0009;&#0009;BLOBRootUnLock()
        &#0009;ELSE
        &#0009;&#0009;Alert("Could not obtain root lock of Customer;
        &#0009;&#0009;&#0009;file")
        &#0009;ENDIF
        &#0009;CLOSE
        &#0009;RETURN aCustSettings
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootGet'>BLOBRootGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootPut'>BLOBRootPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootUnlock'>BLOBRootUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUseArea'>DBUseArea</seealso>
  </blobrootlock>
  <blobrootput>
    <summary>
      Store data in the root area of a BLOB file.
    </summary>

    <param name="uBLOB">
      The data you want to put into the BLOB file's root area.  <paramref name="uBLOB" /> can be any X# usual data type, except code block and object.
    </param>
    <returns>
      TRUE if successful; otherwise FALSE.
    </returns>
    <remarks>
      BLOBRootPut() allows the storage of one — and only one — piece of data to a BLOB file's root area (there is no size limitation on this one piece of data).<br/>
      After storing the new data, BLOBRootPut() releases the space associated with any data previously stored in the BLOB file's root area.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      Note:  Because the root data does not reference a particular record in the database file, the DBRLock() will not protect this root storage reference.<br/>
      Therefore, if the database file is opened in shared mode, you should use BLOBRootLock() before calling BLOBRootPut().
    </remarks>
    <example>
      This example uses BLOBRootPut() to store system settings to a BLOB file after modification:
      <code language="X#">
        FUNCTION UpdateSettings()
        &#0009;LOCAL aSettings AS ARRAY
        &#0009;USE customer NEW SHARED VIA "DBFCDX"
        &#0009;IF BLOBRootLock()
        &#0009;&#0009;// Get any existing settings
        &#0009;&#0009;aSettings := BLOBRootGet()
        &#0009;&#0009;IF EMPTY(aSettings)
        &#0009;&#0009;&#0009;// This function would populate aSettings
        &#0009;&#0009;&#0009;// with default data
        &#0009;&#0009;&#0009;aSettings := GetDefaultSettings()
        &#0009;&#0009;ENDIF
        &#0009;&#0009;// This function would allow the user to
        &#0009;&#0009;// modify the settings.
        &#0009;&#0009;IF ModifySettings(aSettings)
        &#0009;&#0009;&#0009;// Finally, store the settings
        &#0009;&#0009;&#0009;BLOBRootPut(aSettings)
        &#0009;&#0009;ENDIF
        &#0009;&#0009;BLOBRootUnLock()
        &#0009;ELSE
        &#0009;&#0009;aSettings := {}
        &#0009;&#0009;Alert("Could not obtain a lock on the root;
        &#0009;&#0009;&#0009;area")
        &#0009;ENDIF
        &#0009;CLOSE
        &#0009;RETURN aSettings
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootGet'>BLOBRootGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootLock'>BLOBRootLock</seealso>
  </blobrootput>
  <blobrootunlock>
    <summary>
      Release the lock on a BLOB file's root area.
    </summary>
    <returns>
    </returns>
    <remarks>
      Use BLOBRootUnLock() to release a lock previously obtained using BLOBRootLock().
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      Note:<br/>
      The only functions that require the use of BLOBRootLock() or BLOBRootUnLock() are BLOBRootGet() and BLOBRootPut().
    </remarks>
    <example>
      This example illustrates how to properly lock and unlock the root area of a BLOB file for a database file opened in shared mode.
      <code language="X#">
        FUNCTION GetSettings()
        &#0009;LOCAL aCustSettings AS ARRAY
        &#0009;// Open a customer file in shared mode
        &#0009;USE customer NEW SHARED INHERIT FROM {"DBFBLOB"}
        &#0009;IF BLOBRootLock()
        &#0009;&#0009;aCustSettings := BLOBRootGet()
        &#0009;&#0009;BLOBRootUnLock()
        &#0009;ELSE
        &#0009;&#0009;Alert("Could not obtain root lock of Customer;
        &#0009;&#0009;&#0009;file")
        &#0009;ENDIF
        &#0009;CLOSE
        &#0009;RETURN aCustSettings
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootLock'>BLOBRootLock</seealso>
  </blobrootunlock>
  <bof>
    <summary>
      Determine when beginning-of-file is encountered.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      TRUE after an attempt to skip backward beyond the first logical record in a database file or if the database file contains no records; otherwise, FALSE.<br/>
      If there is no database file open in the work area, BOF() returns TRUE.
    </returns>
    <remarks>
      BOF() is a database function used to test for a boundary condition when you are moving the record pointer backward through a database file using the DBSkip() function.<br/>
      An example is a screen paging routine that pages forward or backward through the database file based on a user key stroke.  When the user attempts to page backward, you would use BOF() to test for a beginning-of-file condition before using DBSkip() to move the record pointer and repaint the screen.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      DBSkip(), VODBSkip(), and the SKIP command are the only record movement operations that can set BOF() to TRUE.  Once BOF() is set to TRUE, it retains its value until there is another attempt to move the record pointer.
    </remarks>
    <example>
      This example demonstrates BOF() by attempting to move the record pointer before the first record:
      <code language="X#">
        USE sales NEW
        QOut(RECNO(), BOF())&#0009;&#0009;// Result: 1 FALSE
        DBSkip(-1)
        QOut(RECNO(), BOF())&#0009;&#0009;// Result: 1 TRUE
      </code>
      This example uses aliased expressions to query the value of BOF() in unselected work areas:
      <code language="X#">
        USE sales NEW
        USE customer NEW
        USE invoices NEW
        QOut(sales-&gt;BOF(), customer-&gt;BOF())
      </code>
      This example uses a parameter to the BOF() function to eveluate the value of BOF() in unselected work areas:
      <code language="X#">
        USE sales NEW
        USE customer NEW
        USE invoices NEW
        QOut(BOF("sales"), BOF("customer"))
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSkip'>DBSkip</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbBof'>VODBBOF</seealso>
    <seealso cref='P:VO.DbServer.BoF'>DBServer:BoF</seealso>
  </bof>
  <break>
    <summary>
      Branch out of a BEGIN SEQUENCE...END construct.
    </summary>

    <param name="uValue">
      The value passed to the RECOVER clause.  Note that <paramref name="uValue" /> is not optional; however, NIL can be specified if there is no break value.
    </param>
    <returns>
      The value passed to the RECOVER clause.
    </returns>
    <remarks>
      _Break() is identical in functionality to the BREAK statement
    </remarks>
    <example>
      This example installs an error handler code block that uses a _Break() to get to the line immediately after the RECOVER:
      <code language="X#">
        FUNCTION Start()
        &#0009;// Declare "Export Local" for code block
        &#0009;// efficiency
        &#0009;LOCAL cbSaveHandler
        &#0009;LOCAL oError
        &#0009;// Set up your own error block.<br/>
        If an error
        &#0009;// occurs, your error block will invoke a BREAK
        &#0009;// that will take you to the RECOVER line.
        &#0009;cbSaveHandler := ErrorBlock({|x| _Break(x)})
        &#0009;BEGIN SEQUENCE
        &#0009;&#0009;USE myfile
        &#0009;&#0009;// If error here, the installed code block
        &#0009;&#0009;// is executed and the _Break() in it gets
        &#0009;&#0009;// you to the line after RECOVER statement
        &#0009;RECOVER USING oError
        &#0009;&#0009;// You will get via the _Break() only if an
        &#0009;&#0009;// error occurs that invokes the installed error handler
        &#0009;&#0009;? "Error opening file"
        &#0009;&#0009;InKey(0)
        &#0009;&#0009;QUIT&#0009;&#0009;// NOTE
        &#0009;END
        &#0009;// Restore the default error handler
        &#0009;ErrorBlock(cbSaveHandler)
      </code>
    </example>
    <seealsocmd>BEGIN SEQUENCE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.CanBreak'>CanBreak</seealso>
  </break>
  <buffer>
    <summary>
      Return an uninitialized string of a specified size.
    </summary>

    <param name="dwSize">The number of bytes to return.</param>
    <returns>
      A string of <paramref name="dwSize" /> bytes.<br/>
      If <paramref name="dwSize" /> is 0, Buffer() returns a NULL_STRING.
    </returns>
    <remarks>
      Buffer() is similar to Space() but with random contents.  You should use it, instead of Space(), in cases where an initialization character is not needed.
    </remarks>
    <example>
      This example uses Buffer() to allocate a string then fills it in with the data read from FRead3():
      <code language="X#">
        cBuff := Buffer(8)
        FRead3(ptrHandle, Ptr(_CAST, cBuff), 8)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
    <seealso cref='O:XSharp.Core.Functions.Replicate'>Replicate</seealso>
    <seealso cref='O:XSharp.Core.Functions.Space'>Space</seealso>
  </buffer>
  <canbreak>
    <summary>
      Check whether a break occurs within the BEGIN SEQUENCE...END construct.
    </summary>
    <returns>
    </returns>
    <remarks>
      If the code is not within a BEGIN SEQUENCE...END construct, the break behaves like the QUIT command.  Note that the break can be invoked by either the _Break() function or the BREAK statement executing within the BEGIN SEQUENCE...END construct.
    </remarks>
    <example>
      This example shows the two possible results of CanBreak():
      <code language="X#">
        BEGIN SEQUENCE
        ? CanBreak()&#0009;&#0009;&#0009;&#0009;// TRUE
        END SEQUENCE? CanBreak()&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealsocmd>BEGIN SEQUENCE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions._Break'>_Break</seealso>
    <seealsocmd>QUIT</seealsocmd>
  </canbreak>
  <cast2psz>
    <summary>
      Check a strongly typed string for NULL_STRING and return a valid (non-zero) PSZ.
    </summary>

    <param name="cString">The string to convert.</param>
    <returns>
      A non-zero PSZ if successful; otherwise, NULL_PSZ.
    </returns>
    <remarks>
      Cast2Psz() is useful for many Windows or DLL functions that require a PSZ in their argument list.<br/>
      It checks whether <paramref name="cString" /> is a NULL_STRING.<br/>
      If this is the case, String2Psz() returns a static pointer to a byte containing 0x00.<br/>
      Otherwise, it returns the <paramref name="cString" /> argument as a PSZ.
      Do use Cast2Psz() to initialize your own PSZ variable, because it remains the same dynamic string and its location will be changed by the next call to the "garbage collector."
    </remarks>
    <example>
      See the String2Psz() example.
    </example>
    <seealso cref='O:XSharp.RT.Functions.Psz2String'>Psz2String</seealso>
    <seealso cref='O:XSharp.RT.Functions.String2Psz'>String2Psz</seealso>
  </cast2psz>
  <cdow>
    <summary>
      Extract the name of the day of the week from a date.
    </summary>

    <param name="dDate">The date from which to extract the day of the week.</param>
    <returns>
      The name of the day of the week, where the first letter is uppercase and the rest of the string is lowercase.<br/>
      For an invalid or NULL_DATE, CDoW() returns a NULL_STRING.
    </returns>
    <remarks>
      CDoW() is a date conversion function used in formatting date displays for reports, labels, screens, and so on.<br/>
      This function is nation-dependent.
    </remarks>
    <example>
      These examples illustrate CDoW():
      <code language="X#">
        ? Today()&#0009;&#0009;&#0009;&#0009;&#0009;// 06/05/93
        ? CDoW(Today())&#0009;&#0009;&#0009;// Tuesday
        ? CDoW(Today() + 7)&#0009;&#0009;&#0009;// Tuesday
        ? CDoW(CToD("06/12/93"))&#0009;&#0009;// Sunday
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CToD'>CToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.Day'>Day</seealso>
    <seealso cref='O:XSharp.RT.Functions.DoW'>DoW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Today'>Today</seealso>
  </cdow>
  <ceil>
    <summary>
      Round a number up to the next highest integer.
    </summary>

    <param name="nNumber">The number to round.</param>
    <returns>
      The integer part (no decimals) of the nearest number that is greater than or equal to <paramref name="nNumber" />.  Since both <paramref name="nNumber" /> and the return value are data type USUAL, you are not limited to the size of an integer.
    </returns>
    <remarks>
      Ceil() rounds a positive number with a fractional portion up to the next highest integer and returns the integer portion of a negative number.
    </remarks>
    <example>
      These examples illustrate Ceil() on a positive and a negative value:
      <code language="X#">
        ? Ceil(1.6)&#0009;&#0009;&#0009;// 2
        ? Ceil(-1.6)&#0009;&#0009;&#0009;&#0009;// -1 (since -1 &gt; -2)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Floor'>Floor</seealso>
    <seealso cref='O:XSharp.RT.Functions.Frac'>Frac</seealso>
    <seealso cref='O:XSharp.RT.Functions.Integer'>Integer</seealso>
    <seealso cref='O:XSharp.RT.Functions.Round'>Round</seealso>
  </ceil>
  <chareven>
    <summary>
      Return the even-numbered characters in a string.
    </summary>

    <param name="cString">The string whose even-numbered characters you want to return.</param>
    <returns>
      Every other character in the string, starting from the second character.
    </returns>
    <remarks>
    </remarks>
    <example>
      These examples display every even character in a string:
      <code language="X#">
        ? CharEven("A1B2C3")&#0009;&#0009;&#0009;// 123
        ? CharEven("1234567890")&#0009;&#0009;&#0009;// 24680
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.CharMix'>CharMix</seealso>
    <seealso cref='O:XSharp.Core.Functions.CharOdd'>CharOdd</seealso>
  </chareven>
  <charmix>
    <summary>
      Return a string whose odd-numbered characters and even-numbered characters are from 2 different strings.
    </summary>

    <param name="cOdd">The string whose characters will constitute the odd-numbered characters in the returned string.</param>
    <param name="cEven">The string whose characters will constitute the even-numbered characters in the returned string.</param>
    <returns>
      A string in which characters from <paramref name="cOdd" /> and <paramref name="cEven" /> appear alternately.<br/>
      The length of <paramref name="cOdd" /> determines the length of the returned string: the length is twice the length of <paramref name="cOdd" />, assuming that <paramref name="cEven" /> contains at least one character:
      &#0009;A longer <paramref name="cEven" /> string is cut down to the length of <paramref name="cOdd" />.
      &#0009;A shorter <paramref name="cEven" /> is processed from beginning to end, wrapping to the beginning again until there are no more characters in <paramref name="cOdd" />.
      If <paramref name="cEven" /> contains less than one character, a NULL_STRING is returned.
    </returns>
    <remarks>
      CharMix() provides a convenient way to recombine strings extracted from CharOdd() and CharEven().
    </remarks>
    <example>
      This example mixes 2 strings:
      <code language="X#">? CharMix("13579", "24680")&#0009;// 1234567890</code>
      This example  shuffles the cards in a game:
      <code language="X#">
        Function Start()
        &#0009;LOCAL cPoker AS STRING
        &#0009;cPoker := "AKJQ0123456789"
        &#0009;? Shuffle(cPoker, 10)&#0009;// Q37A048K159J26
        &#0009;RETURN TRUE
        FUNCTION Shuffle(cDeck AS STRING, ;
        &#0009;&#0009;siShuffles AS SHORTINT) AS STRING PASCAL
        &#0009;// Assumes even number of cards.
        &#0009;// Length of cDeck is divisible by 2
        &#0009;LOCAL siCounter AS SHORTINT
        &#0009;LOCAL siCards AS SHORTINT
        &#0009;siCards := SLen(cDeck)
        &#0009;// First and last cards are not shuffled;
        &#0009;// so add/pad blank cards
        &#0009;siCards += 2
        &#0009;cDeck := PadC(cDeck, siCards)
        &#0009;FOR siCounter := 1 UPTO siShuffles
        &#0009;&#0009;// Cut the deck in half and shuffle
        &#0009;&#0009;cDeck := CharMix(Substr3(cDeck, 1,;
        &#0009;&#0009;siCards/2), Substr2(cDeck, (siCards/2)+1))
        &#0009;NEXT
        &#0009;RETURN Substr3(cDeck, 2, siCards-2)
        &#0009;// Exclude added blank cards
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.CharEven'>CharEven</seealso>
    <seealso cref='O:XSharp.Core.Functions.CharOdd'>CharOdd</seealso>
  </charmix>
  <charodd>
    <summary>
      Return the odd-numbered characters in a string.
    </summary>

    <param name="cString">The string whose odd-numbered characters you want to return.</param>
    <returns>
      Every other character in the string, starting from the first character.
    </returns>
    <remarks>
    </remarks>
    <example>
      The SaveScreenOld() function, whose return value maintains compatibility with the CA-Clipper SaveScreen() function, stores the screen contents in a buffer such that the odd bytes contain the actual screen characters and the even bytes contain the corresponding screen attributes.  CharOdd() is useful in extracting the screen contents from such a buffer.
      This example saves the screen contents of the first row and redisplays it in many different colors on the next row:
      <code language="X#">
        Function Start()
        &#0009;LOCAL i AS SHORTINT
        &#0009;LOCAL cBuffer AS STRING
        &#0009;LOCAL cCharacters, cAttributes AS STRING
        &#0009;LOCAL cSong AS STRING
        &#0009;cSong := "Show me your true colors!"
        &#0009;?? cSong
        &#0009;cBuffer := SaveScreenOld(0, 0, 0, 79)
        &#0009;cCharacters := CharOdd(cBuffer)
        &#0009;cAttributes := CharEven(cBuffer)
        &#0009;// Change the attributes
        &#0009;SEvalA(cAttributes, {|| Chr(i++)}, 1,;
        &#0009;&#0009;&#0009;&#0009;SLen(cSong))
        &#0009;// Redisplay with new attributes
        &#0009;RestScreenOld(1, 0, 1, 79,;
        &#0009;&#0009;&#0009;&#0009;CharMix(cCharacters, cAttributes))
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.CharEven'>CharEven</seealso>
    <seealso cref='O:XSharp.Core.Functions.CharMix'>CharMix</seealso>
  </charodd>
  <charpos>
    <summary>
      Return a character based on its position in a string.
    </summary>

    <param name="cString">The string that you want to extract a character from.</param>
    <param name="wPosition">
      The position of the character within <paramref name="cString" />.
    </param>
    <returns>
      The character located at the specified position.
    </returns>
    <remarks>
      CharPos(<paramref name="cString" />, <paramref name="wPosition" />) extracts a substring from the specified string for a length of one character.  Functionally, it is the same as Substr(<paramref name="cString" />, <paramref name="wPosition" />, 1).
      <br/>



      This example extracts single letters from a name and displays them individually:
      <code language="X#">
        FUNCTION SayName()
        &#0009;LOCAL siCount AS SHORTINT
        &#0009;LOCAL cName := "Biff Styvesent"
        &#0009;FOR siCount := 1 UPTO Len(cName)
        &#0009;&#0009;?? CharPos(cName, siCount)
        &#0009;NEXT
      </code>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </charpos>
  <checkinstanceof>
    <summary>
      Determine if an object is an instance of a particular class.
    </summary>

    <param name="oObject">The object to check for.</param>
    <param name="symClassName">
      The class that <paramref name="oObject" /> may be an instance of.
    </param>
    <returns>
      TRUE if <paramref name="oObject" /> is an instance of <paramref name="symClassName" />; otherwise, an error is generated.  FALSE is returned if you choose to ignore the error.
      If <paramref name="oObject" /> is a NULL_OBJECT, a FALSE is returned but no error is generated.
    </returns>
    <remarks>
      An instance of an inherited class is also an instance of the original (super) class.  However, an instance of a super class is not an instance of any of its inherited classes.
      CheckInstanceOf() is similar to IsInstanceOf(), except that it also generates an error message if the specified object is not an instance of the specified class.
    </remarks>
    <example>
      These examples illustrate CheckInstanceOf() on inherited classes:
      <code language="X#">
        CLASS Person
        &#0009;EXPORT name, sign
        CONSTRUCTOR(tName, tSign)
        &#0009;name := tName
        &#0009;sign := tSign
        END CLASS
        CLASS Male INHERIT Person
        &#0009;EXPORT prefers
        END CLASS
        FUNCTION CheckArgument()
        &#0009;LOCAL x, y AS OBJECT
        &#0009;x := Person{"Dude", "president"}
        &#0009;y := Male{"Charlie", "VP"}
        &#0009;? CheckInstanceOf(x, #Person)&#0009;&#0009;// TRUE
        &#0009;? CheckInstanceOf(x, #Male)&#0009;&#0009;// FALSE
        &#0009;? CheckInstanceOf(y, #Person)&#0009;&#0009;// TRUE
        &#0009;? CheckInstanceOf(y, #Male)&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ClassName'>ClassName</seealso>
    <seealso cref='O:XSharp.RT.Functions.CreateInstance'>CreateInstance</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsInstanceOf'>IsInstanceOf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsInstanceOfUsual'>IsInstanceOfUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethodUsual'>IsMethodUsual</seealso>
  </checkinstanceof>
  <chr>
    <summary>
      Convert an ASCII code to a character value.
    </summary>

    <param name="dwCode">An ASCII code from 0 to 255.</param>
    <returns>
      A single character that corresponds to <paramref name="dwCode" />.
    </returns>
    <remarks>
      Chr() is the inverse of Asc().  Chr() serves a number of common tasks including:
      &#0009;Sending control codes and graphics characters to the screen or printer
      &#0009;Ringing the bell
      &#0009;Converting InKey() return values to characters
      &#0009;Stuffing the keyboard buffer
      Chr(0) has a length of 1 and is treated like any other character; this lets you send it to any device or file, including a database file.
      <note type="tip">
        _Chr() is an operator that does the same thing as the Chr() function.<br/>
        As an operator, it is evaluated at compile time and can be used in DEFINE, GLOBAL, or STATIC LOCAL statements to specify initial values.  Because it does not incur the overhead of a function call, it is more efficient.  Here is an example:
        <code language="X#">DEFINE CRLF := _Chr(ASC_CR) + _Chr(ASC_LF)</code>
      </note>
    </remarks>
    <example>
      These examples illustrate Chr() with various arguments:
      <code language="X#">
        ? Chr(Asc("A") + 32)&#0009;&#0009;// a
        ? Chr(7)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Bell sounds
        ? Chr(72)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// H
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Asc'>Asc</seealso>
  </chr>
  <classcount>
    <summary>
      Return the number of classes available to your application.
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example illustrates ClassCount():
      <code language="X#">
        FUNCTION Start()
        &#0009;? ClassCount(), "classes are available."
        &#0009;// 5 classes are available.
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ClassList'>ClassList</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTree'>ClassTree</seealso>
  </classcount>
  <classlist>
    <summary>
      Return an array of symbols corresponding to the classes available to your application.
    </summary>
    <returns>
      An array of all class names as a symbol.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example illustrates ClassList():
      <code language="X#">
        CLASS MyClass
        END CLASS...
        FUNCTION PrintClass()
        &#0009;LOCAL aClass AS ARRAY
        &#0009;aClass := ClassList()
        &#0009;// Predefined system classes are listed first.
        &#0009;FOR i := 1 UPTO ALen(aClass)
        &#0009;&#0009;QOut(aClass[i])
        &#0009;NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ClassCount'>ClassCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTree'>ClassTree</seealso>
  </classlist>
  <classname>
    <summary>
      Get the class name of an object.
    </summary>

    <param name="oObject">An object whose class name you want to get.</param>
    <returns>
      The class to which <paramref name="oObject" /> belongs.<br/>
      If <paramref name="oObject" /> is not an instance of a class, a NULL_SYMBOL is returned.
    </returns>
    <remarks>
    </remarks>
    <example>
      These examples illustrate ClassName():
      <code language="X#">
        CLASS Person
        &#0009;EXPORT cName, cSign
        CONSTRUCTOR(tName, tSign)
        &#0009;cName := tName
        &#0009;cSign := tSign
        END CLASS
        CLASS Female INHERIT Person
        &#0009;EXPORT prefers
        END CLASS
        FUNCTION CheckClass()
        &#0009;LOCAL oY AS OBJECT
        &#0009;oY := Female{"Ms.", "Wonderful"}
        &#0009;IF ClassName(oY)&#0009;= #Female&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;
        &#0009;&#0009;? "The woman belongs to the Female class."
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CheckInstanceOf'>CheckInstanceOf</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassCount'>ClassCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTree'>ClassTree</seealso>
  </classname>
  <classtree>
    <summary>
      Get the class hierarchy of an object.
    </summary>

    <param name="oObject">An object whose class hierarchy you want to get.</param>
    <returns>
      An array of class names from which <paramref name="oObject" /> has been derived.<br/>
      The last element of the array contains the root class from which subsequent classes in the array inherit.
    </returns>
    <remarks>
      ClassTree() shows what other classes, if any, the class of the object inherits from.
    </remarks>
    <example>
      These examples illustrate ClassTree() with multiple inheritances:
      <code language="X#">
        CLASS Person
        &#0009;EXPORT name, sign
        CONSTRUCTOR(tName, tSign)
        &#0009;name := tName
        &#0009;sign := tSign
        END CLASS
        CLASS Male INHERIT Person
        &#0009;EXPORT prefers
        END CLASS
        CLASS OldMale INHERIT Male
        &#0009;EXPORT age
        END CLASS
        FUNCTION InheritanceTree()
        &#0009;LOCAL y AS OBJECT
        &#0009;LOCAL a AS ARRAY
        &#0009;y := OldMale{"Charlie", "dude"}
        &#0009;a := ClassTree(y)
        &#0009;? ArrayGet(a, 1)&#0009;&#0009;&#0009;// OLDMALE
        &#0009;? ArrayGet(a, 2)&#0009;&#0009;&#0009;// MALE
        &#0009;? ArrayGet(a, 3)&#0009;&#0009;&#0009;// PERSON
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ClassCount'>ClassCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassList'>ClassList</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassName'>ClassName</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTreeClass'>ClassTreeClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.OOPTree'>OOPTree</seealso>
    <seealso cref='O:XSharp.RT.Functions.OOPTreeClass'>OOPTreeClass</seealso>
  </classtree>
  <classtreeclass>
    <summary>
      Get the class hierarchy of a class.
    </summary>

    <param name="symClass">A symbol representing the class name whose class hierarchy you want to get.</param>
    <returns>
      An array of class names from which <paramref name="oObject" /> has been derived.<br/>
      The last element of the array contains the root class from which subsequent classes in the array inherit.
    </returns>
    <remarks>
      ClassTreeClass() shows what other classes, if any, the specified class inherits from.
    </remarks>
    <example>
      These examples illustrate ClassTreeClass() with multiple inheritances:
      <code language="X#">
        CLASS Person
        &#0009;EXPORT name, sign
        CONSTRUCTOR(tName, tSign)
        &#0009;name := tName
        &#0009;sign := tSign
        END CLASS

        CLASS Male INHERIT Person
        &#0009;EXPORT prefers
        END CLASS
        CLASS OldMale INHERIT Male
        &#0009;EXPORT age
        END CLASS
        FUNCTION InheritanceTree()
        &#0009;LOCAL a AS ARRAY
      </code>
      &#0009;
      <code language="X#">
        &#0009;a := ClassTreeClass(#OldMale)
        &#0009;? ArrayGet(a, 1)&#0009;&#0009;&#0009;// OLDMALE
        &#0009;? ArrayGet(a, 2)&#0009;&#0009;&#0009;// MALE
        &#0009;? ArrayGet(a, 3)&#0009;&#0009;&#0009;// PERSON
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ClassCount'>ClassCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassList'>ClassList</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassName'>ClassName</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTreeClass'>ClassTreeClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.OOPTree'>OOPTree</seealso>
    <seealso cref='O:XSharp.RT.Functions.OOPTreeClass'>OOPTreeClass</seealso>
  </classtreeclass>
  <cls>
    <summary>
      Clear the terminal window and position the cursor at row and column 0.
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      These examples illustrate CLS():
      <code language="X#">
        FUNCTION Start()
        QOut("Clear the screen.")
        WAIT
        CLS()
        RETURN
      </code>
    </example>
  </cls>
  <cmonth>
    <summary>
      Extract the name of the month from a date.
    </summary>

    <param name="dDate">The date from which to extract the month of the date.</param>
    <returns>
      The name of the month, where the first letter is uppercase and the rest of the string is lowercase.<br/>
      For an invalid or NULL_DATE, CMonth() returns a NULL_STRING.
    </returns>
    <remarks>
      CMonth() is a date conversion function useful for creating formatted date strings that can be used in reports, labels, screens, and so on.<br/>
      This function is nation-dependent.
    </remarks>
    <example>
      These examples illustrate CMonth():
      <code language="X#">
        ? CMonth(Today())&#0009;&#0009;&#0009;&#0009;&#0009;// September
        ? CMonth(Today() + 45)&#0009;&#0009;&#0009;&#0009;// October
        ? Substr3(CMonth(Today()), 1, 3) +;
        &#0009;Str(Day(Today()))&#0009;&#0009;&#0009;// Sep 1
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CDoW'>CDoW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Day'>Day</seealso>
    <seealso cref='O:XSharp.RT.Functions.Month'>Month</seealso>
    <seealso cref='O:XSharp.Core.Functions.NToCMonth'>NToCMonth</seealso>
    <seealso cref='O:XSharp.RT.Functions.Today'>Today</seealso>
    <seealso cref='O:XSharp.RT.Functions.Year'>Year</seealso>
  </cmonth>
  <col>
    <summary>
      Return the current column position of the cursor in the terminal window.
    </summary>
    <returns>
      The column in which the cursor is currently located.<br/>
      This value can range from 0 to MaxCol().
    </returns>
    <remarks>
      The value returned by Col() changes whenever the cursor position changes in the terminal window; for example, both console and full-screen commands can change the cursor position.  In addition, Col() is automatically set to 0 whenever a CLEAR, CLEAR SCREEN, or CLS() is executed.
    </remarks>
    <example>
      This example displays a file name at a specified row and column:
      <code language="X#">
        FUNCTION Start()
        LOCAL cErrorMessage AS STRING
        LOCAL cFileName AS STRING
        cErrorMessage := "File not found."
        cFileName := "customer.dbf"
        SetPos(1, 10)
        QQout(cFileName)
        SetPos(Row(), Col() + 2)
        QQOut(cErrorMessage)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.cls'>CLS</seealso>
    <seealso cref='O:XSharp.RT.Functions.QOut'>QOut</seealso>
    <seealso cref='O:XSharp.RT.Functions.Row'>Row</seealso>
  </col>
  <collect>
    <summary>
      Call the garbage collector if a watermark is reached.
    </summary>
    <returns>
    </returns>
    <remarks>
      Collect() calls the garbage collector if a watermark is reached.<br/>
      A watermark is a point at which garbage collection is appropriate as determined by the system.
      Literal or hard-coded strings are static and cannot be collected.  Strings which are dynamic can be collected.<br/>
      For example, in MyFunc("hello"), the literal string "hello" is not collectable, while in MyFunc(Time()), the string returned from Time() is collectable.
      Strings, floats, arrays, and object are dynamic and collectable objects unless they are literals..
    </remarks>
    <example>
      These examples illustrate Collect():
      <code language="X#">
        ? CollectCount()&#0009;&#0009;// 4
        Collect()
        ? CollectCount()&#0009;&#0009;// This could be either 5
        &#0009;&#0009;&#0009;&#0009;&#0009;// or 4 depending on whether garbage
        &#0009;&#0009;&#0009;&#0009;&#0009;// collection was performed or not.
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CollectCount'>CollectCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.CollectForced'>CollectForced</seealso>
    <seealso cref='O:XSharp.VO.Functions.Memory'>Memory</seealso>
    <seealso cref='O:XSharp.RT.Functions.RegisterAxit'>RegisterAxit</seealso>
    <seealso cref='O:XSharp.VO.Functions.RegisterKid'>RegisterKid</seealso>
  </collect>
  <collectcount>
    <summary>
      Count the number of garbage collections performed by the system.
    </summary>
    <returns>
      The number of garbage collections.
    </returns>
    <remarks>
      CollectCount() determines how many times garbage collection was performed in your application.<br/>
      This tells you how much of your system resources are being devoted to garbage collection.<br/>
      If the garbage collector is being called too frequently, memory might be low,  resulting in a degradation in performance.
      CollectCount() is the same as Memory(MEMORY_COLLECT).
    </remarks>
    <example>
      These examples show that after every call to CollectForced(), the return value of CollectCount() is increased by 1:
      <code language="X#">
        ? CollectCount()&#0009;&#0009;&#0009;// 1
        CollectForced()
        ? CollectCount()&#0009;&#0009;&#0009;// 2
        CollectForced()
        ? CollectCount()&#0009;&#0009;&#0009;// 3
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Collect'>Collect</seealso>
    <seealso cref='O:XSharp.RT.Functions.CollectForced'>CollectForced</seealso>
    <seealso cref='O:XSharp.VO.Functions.Memory'>Memory</seealso>
  </collectcount>
  <collectforced>
    <summary>
      Call the garbage collector.
    </summary>
    <returns>
    </returns>
    <remarks>
      CollectForced() calls the garbage collector regardless of whether a watermark has been reached.
      Literal or hard-coded strings are static and cannot be collected.  Strings which are dynamic can be collected.<br/>
      For example, in MyFunc("hello") the literal string "hello" is not collectable, while in MyFunc(Time()) the string returned from Time() is collectable.
      Strings, floats, arrays, and object are dynamic and collectable objects unless they are literals.
    </remarks>
    <example>
      These examples illustrate CollectForced():
      <code language="X#">
        ? CollectCount()&#0009;&#0009;&#0009;&#0009;// 1
        CollectForced()
        ? CollectCount()&#0009;&#0009;&#0009;&#0009;// 2
        CollectForced()
        ? CollectCount()&#0009;&#0009;&#0009;&#0009;// 3
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Collect'>Collect</seealso>
    <seealso cref='O:XSharp.RT.Functions.CollectCount'>CollectCount</seealso>
  </collectforced>
  <concatatom>
    <summary>
      Concatenate two symbols.
    </summary>

    <param name="s1">The first symbol to concatenate.</param>
    <param name="s2">The second symbol to concatenate.</param>
    <returns>
      The concatenated symbol.<br/>
      This symbol is added to the atom table if it is not already there.
    </returns>
    <remarks>
      ConcatAtom() lets you concatenate 2 symbols, the same way you concatenate strings with the "+" operator.
      To perform more complicated string operations, convert symbols to strings (using Symbol2String()).
    </remarks>
    <example>
      These examples illustrate ConcatAtom():
      <code language="X#">
        ? ConcatAtom(#HEL, #LO)&#0009;&#0009;&#0009;// #HELLO
        ? ConcatAtom(#GOOD,#BYE) = #GOODBYE&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ConcatAtom3'>ConcatAtom3</seealso>
  </concatatom>
  <concatatom3>
    <summary>
      Concatenate three symbols.
    </summary>

    <param name="s1">The first symbol to concatenate.</param>
    <param name="s2">The second symbol to concatenate.</param>
    <param name="s3">The third symbol to concatenate.</param>
    <returns>
      The concatenated symbol.<br/>
      This symbol is added to the atom table if it is not already there.
    </returns>
    <remarks>
      ConcatAtom3() lets you concatenate 3 symbols, the same way you concatenate strings with the "+" operator.
      To perform more complicated string operations, convert symbols to strings (using Symbol2String()).
    </remarks>
    <example>
      These examples illustrate ConcatAtom3():
      <code language="X#">
        ? ConcatAtom3(#UN,#BELIEV,#ABLE)&#0009;
        &#0009;// UNBELIEVABLE
        ? ConcatAtom3(#GOOD,#BYE,#GIRL) = #GOODBYEGIRL
        &#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ConcatAtom'>ConcatAtom</seealso>
  </concatatom3>
  <concatatom4>
    <summary>
      Concatenate four symbols.
    </summary>

    <param name="s1">The first symbol to concatenate.</param>
    <param name="s2">The second symbol to concatenate.</param>
    <param name="s3">The third symbol to concatenate.</param>
    <param name="s4">The fourth symbol to concatenate.</param>
    <returns>
      The concatenated symbol.<br/>
      This symbol is added to the atom table if it is not already there.
    </returns>
    <remarks>
      ConcatAtom4() lets you concatenate 4 symbols, the same way you concatenate strings with the "+" operator.
      To perform more complicated string operations, convert symbols to strings (using Symbol2String()).
    </remarks>
    <seealso cref='O:XSharp.RT.Functions.ConcatAtom'>ConcatAtom</seealso>
  </concatatom4>
  <concatatom5>
    <summary>
      Concatenate four symbols.
    </summary>

    <param name="s1">The first symbol to concatenate.</param>
    <param name="s2">The second symbol to concatenate.</param>
    <param name="s3">The third symbol to concatenate.</param>
    <param name="s4">The fourth symbol to concatenate.</param>
    <param name="s5">The fifth symbol to concatenate.</param>
    <returns>
      The concatenated symbol.<br/>
      This symbol is added to the atom table if it is not already there.
    </returns>
    <remarks>
      ConcatAtom5() lets you concatenate 5 symbols, the same way you concatenate strings with the "+" operator.
      To perform more complicated string operations, convert symbols to strings (using Symbol2String()).
    </remarks>
    <seealso cref='O:XSharp.RT.Functions.ConcatAtom'>ConcatAtom</seealso>
  </concatatom5>
  <condate>
    <summary>
      Format a set of numbers representing a year, month, and day as a date.
    </summary>

    <param name="dwYear">
      A valid year.<br/>
      If the century digits are not specified, the century is determined by the rules of SetEpoch().
    </param>
    <param name="dwMonth">A number from 1 through 12 representing a valid month.</param>
    <param name="dwDay">
      A number representing a valid day of <paramref name="dwMonth" />.
    </param>
    <returns>
      The date that corresponds to the passed arguments.<br/>
      If any of the arguments specified do not represent a valid year, month, or day, a NULL_DATE is returned.
    </returns>
    <remarks>
      ConDate() converts the given numbers to a date.<br/>
      The display of dates is controlled by SetCentury().
    </remarks>
    <example>
      These examples illustrate ConDate():
      <code language="X#">
        ? ConDate(93, 10, 25)&#0009;&#0009;// 10/25/93
        ? ConDate(2093, 10, 25)&#0009;&#0009;// 10/25/93
        ? SetCentury(TRUE)
        ? ConDate(2093, 10, 25)&#0009;&#0009;// 10/25/2093
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ConTime'>ConTime</seealso>
    <seealso cref='O:XSharp.Core.Functions.Days'>Days</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetCentury'>SetCentury</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetEpoch'>SetEpoch</seealso>
  </condate>
  <contime>
    <summary>
      Format a set of numbers representing an hour, minute, and second as a time string.
    </summary>

    <param name="dwHour">The number of hours, up to 23.</param>
    <param name="dwMinute">The number of minutes, up to 59.</param>
    <param name="dwSeconds">The number of minutes, up to 59.</param>
    <returns>
      A (military) time that corresponds to the passed arguments in the format HH:MO:SS without AM/PM notation
    </returns>
    <remarks>
    </remarks>
    <example>
      These examples illustrate ConTime():
      <code language="X#">
        ? ConTime(10, 59, 59)&#0009;&#0009;// 10:59:59
        ? ConTime(22, 59, 59)&#0009;&#0009;// 22:59:59
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AmPm'>AmPm</seealso>
    <seealso cref='O:XSharp.RT.Functions.ConDate'>ConDate</seealso>
    <seealso cref='O:XSharp.Core.Functions.ElapTime'>ElapTime</seealso>
    <seealso cref='O:XSharp.Core.Functions.Seconds'>Seconds</seealso>
    <seealso cref='O:XSharp.Core.Functions.Secs'>Secs</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetTimeSep'>SetTimeSep</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
    <seealso cref='O:XSharp.RT.Functions.TString'>TString</seealso>
  </contime>
  <cos>
    <summary>
      Calculate the cosine of a number.
    </summary>

    <param name="nNum">An angle in radians.</param>
    <returns>
      The cosine of the specified angle.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses Cos() to calculate the cosine of 0 and PI:
      <code language="X#">
        ? Cos(0)&#0009;&#0009;&#0009;&#0009;//  1.00
        ? Cos(PI)&#0009;&#0009;&#0009;&#0009;&#0009;// -1.00
      </code>
      This example finds the cosine of a 60-degree angle.<br/>
      The first step is to convert 60 degrees to radians.<br/>
      This is done by dividing the angle by 180/PI:
      <code language="X#">? Cos(60/(180/PI))&#0009;&#0009;//  0.50</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Cot'>Cot</seealso>
    <seealso cref='O:XSharp.RT.Functions.Sin'>Sin</seealso>
    <seealso cref='O:XSharp.RT.Functions.Tan'>Tan</seealso>
  </cos>
  <cot>
    <summary>
      Calculate the cotangent of a value.
    </summary>

    <param name="nNum">An angle in radians.</param>
    <returns>
      The cotangent of the specified angle.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses Cot() to show that cotangent is the same as cosine over sine:
      <code language="X#">
        ? Cot(1.5)&#0009;&#0009;&#0009;&#0009;// 0.07
        ? Cos(1.5)&#0009;&#0009;&#0009;&#0009;// 0.07
        ? Sin(1.5)&#0009;&#0009;&#0009;&#0009;// 1.00
        ? Cos(1.5) / Sin(1.5)&#0009;&#0009;// 0.07
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ACot'>ACot</seealso>
    <seealso cref='O:XSharp.RT.Functions.ATan'>ATan</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cos'>Cos</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cot'>Cot</seealso>
    <seealso cref='O:XSharp.RT.Functions.Sin'>Sin</seealso>
    <seealso cref='O:XSharp.RT.Functions.Tan'>Tan</seealso>
  </cot>
  <cparamcount>
    <summary>
      Return the number of arguments that a code block is expecting.
    </summary>

    <param name="oCodeBlock">The code block to examine.</param>
    <returns>
      The number of arguments that <paramref name="cbBlock" /> is expecting.
    </returns>
    <remarks>
      When printing a code block (via functions like QOut()) the number of arguments is displayed in hexadecimal notation within the code block's | | pair
    </remarks>
    <example>
      This example uses CParamCount() to determine what calculation to perforO:
      <code language="X#">
        DEFINE N_LENGTH := 10
        DEFINE N_WIDTH  :=  5
        DEFINE N_HEIGHT :=  2
        Function Start()
        &#0009;LOCAL cbRectangle AS CODEBLOCK
        &#0009;cbRectangle := {|x, y| x * y}
        &#0009;? Size(cbRectangle)&#0009;&#0009;&#0009;// 50
        &#0009;RETURN TRUE
        FUNCTION Size(cbArea) AS LONGINT
        &#0009;LOCAL siDimensions AS SHORTINT
        &#0009;LOCAL liArea AS LONGINT
        &#0009;siDimensions := CParamCount(cbArea)
        &#0009;DO CASE
        &#0009;CASE siDimensions = 1&#0009;&#0009;// Length
        &#0009;&#0009;liArea := Eval(cbArea, N_LENGTH)
        &#0009;CASE siDimensions = 2&#0009;&#0009;// Area
        &#0009;&#0009;liArea := Eval(cbArea, N_LENGTH, N_WIDTH)
        &#0009;CASE siDimensions = 3&#0009;&#0009;// Volume
        &#0009;&#0009;liArea := Eval(cbArea, N_LENGTH, N_WIDTH,;
        &#0009;&#0009;&#0009;N_HEIGHT)
        &#0009;ENDCASE
        &#0009;RETURN liArea
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FParamCount'>FParamCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.MParamCount'>MParamCount</seealso>
  </cparamcount>
  <createinstance>
    <summary>
      Create an object.
    </summary>
    <param name="type">The type object that descrives the the object that needs to be created.</param>
    <param name="symClassName">The name of the class for which you want to create an object.</param>
    <param name="InitArgList">
      A comma-separated list of arguments to pass to the Init() method of <paramref name="symClassName" /> (see example below).
    </param>
    <returns>
    </returns>
    <remarks>
      CreateInstance() is the functional way to create an object of a particular class.<br/>
      It is essentially the same as creating an object through an invocation of {}, but is useful in situations where a functional form is needed.
    </remarks>
    <example>
      This example shows how an object is created using CreateInstance():
      <code language="X#">
        CLASS Person
        &#0009;EXPORT name, sign
        CONSTRUCTOR(tName, tSign)
        &#0009;name := tName
        &#0009;sign := tSign
        END CLASS

        FUNCTION Start()
        &#0009;LOCAL x AS OBJECT
        &#0009;// Pass the class name as symbol and also
        &#0009;// specify all Init() method arguments.
        &#0009;x :=  CreateInstance(#PERSON, "Odile", "H")
        &#0009;? x:name&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Odile
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IsInstanceOf'>IsInstanceOf</seealso>
  </createinstance>
  <createvothread>
    <summary>
      Create a new thread.
    </summary>

    <param name="pSecAttr">
      Pointer to a _WINSECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by child processes.<br/>
      If lpThreadAttributes is NULL, the handle cannot be inherited.<br/>
      For more information, see the WIN32 function, CreateThread().
    </param>
    <param name="nStackSize">
      Stack size in bytes for the new thread.<br/>
      If this argument is 0, the stack size defaults to the same size as that of the primary thread of the process.
    </param>
    <param name="pFunc">
      Entry point of the new thread, typically the address of a function declared with the PASCAL calling convention.<br/>
      Its prototype is: ThreadFunc( pArguments AS PTR ) AS DWORD PASCAL.
    </param>
    <param name="pParam">
      Pointer or any other 32-bit parameter passed to the thread entry point <paramref name="pFunc" /> as the argument.
    </param>
    <param name="dwFlags">
      Additional flags to control the thread creation.<br/>

      &#0009;Note:  Consult your Microsoft Win32 Software Development Kit documentation for detailed information about the WIN32 function, CreateThread().
    </param>
    <param name="pdwID">Pointer to a DWORD that receives the thread identifier.</param>
    <returns>
      Handle of the new thread, if successful; otherwise, NULL_PTR.
    </returns>
    <remarks>
      CreateVOThread() is a wrapper function for the Win32 function,  CreateThread(). All arguments are passed to that function after notifying the runtime that a new thread is created by a X# process.
    </remarks>
    <example>
      The following sample features three different threads:
      <code language="X#">
        STRUCT _THREADDATA
        &#0009;MEMBER nThread<br/>
        AS INT
        &#0009;// MEMBER xy  <br/>
        AS ...
        FUNC Start
        &#0009;LOCAL DIM adw[3]  <br/>
        AS PTR
        &#0009;LOCAL DIM pData[3]<br/>
        AS PTR
        &#0009;LOCAL pTData      <br/>
        AS _THREADDATA
        &#0009;LOCAL i             AS DWORD
        &#0009;LOCAL nID           AS DWORD
      </code>
      &#0009;
      <code language="X#">
        &#0009;FOR i := 1 TO 3
        &#0009;&#0009;pTData := MemAlloc(_SIZEOF(_THREADDATA))
        &#0009;&#0009;IF pTData != NULL_PTR
        &#0009; &#0009;&#0009;pTData.nThread := i
        &#0009; &#0009;&#0009;pData[i] := pTData
        &#0009;&#0009;ENDIF
        &#0009;&#0009;adw[i] := CreateVOThread( NULL_PTR, 0,;
        @__ThreadFunc(),;
        pTData, 0,;
        @nID )
        &#0009;NEXT
        &#0009;WaitForMultipleObjects( 3, @adw, TRUE, INFINITE )
        &#0009;FOR i := 1 TO 3
        &#0009;&#0009;IF pData[i] != NULL_PTR
        &#0009;&#0009; MemFree(pData[i])
        &#0009;&#0009;ENDIF
        &#0009;NEXT
        &#0009;WAIT "DONE"
        &#0009;RETURN NIL
        STATIC FUNC __ThreadFunc ( pTData AS _THREADDATA )<br/>
        AS DWORD PASCAL
        &#0009;LOCAL i   AS DWORD
        &#0009;LOCAL n   AS DWORD
        &#0009;n := pTData.nThread
        &#0009;FOR i := 1 TO 100
        &#0009;&#0009;_DebOut32("Thread " + NTrim(n) )
        &#0009;&#0009; Sleep(1)
        &#0009;NEXT
        &#0009;ExitVOThread(0)
      </code>
    </example>
  </createvothread>
  <crypt>
    <summary>
      Encrypt or decrypt a string.
    </summary>

    <param name="cSource">The string that will be encrypted or decrypted.</param>
    <param name="cKey">The encryption/decryption key to be used.</param>
    <returns>
      The encrypted/decrypted string.
    </returns>
    <remarks>
      This function can be used to encrypt or decrypt any string.  Note that the encryption key is very important for decrypting the string later on.  Without the proper key (i.e., the same key used to encrypt the string), the data will be unusable.
    </remarks>
    <example>
      This sample will encrypt a string and then decrypt the string:
      <code language="X#">
        LOCAL a, b, c AS STRING
        LOCAL cKey as STRING
        a := "The quick brown fox jumps over the lazy dog."
        cKey := "CAT"
        b := Crypt(a, cKey)
        c := Crypt(b, cKey)
        ? a&#0009;&#0009;// The quick brown fox jumps over the lazy dog.
        ? b&#0009;&#0009;// ú¿C_6g[‡N%ì*„k ÙYñƒ---à-øÃFé†ÈbÓÈã_ø´Ù¢ù½Ÿ
        ? c&#0009;&#0009;// The quick brown fox jumps over the lazy dog.
      </code>
    </example>



  </crypt>
  <crypta>
    <summary>
      Encrypt or decrypt a string, changing the contents of the original string as well as returning the encrypted string.
    </summary>

    <param name="cSource">The string that will be encrypted or decrypted.</param>
    <param name="cKey">The encryption/decryption key to be used.</param>
    <returns>
      The encrypted/decrypted string.
    </returns>
    <remarks>
      This function is identical to Crypt() except that it also changes the original string <paramref name="cSource" />.  Note that the encryption key is very important for decrypting the string later on.  Without the proper key (i.e., the same key used to encrypt the string), the data will be unusable.
    </remarks>
    <example>
      This sample will encrypt a string and then decrypt the string:
      <code language="X#">
        LOCAL a AS STRING
        LOCAL cKey as STRING
        a := "The quick brown fox jumps over the lazy dog."
        cKey := "CAT"
        ? a
        // The quick brown fox jumps over the lazy dog.
        ? CryptA(a, cKey)
        // ú¿C_6g[‡N%ì*„k ÙYñƒ---à-øÃFé†ÈbÓÈã_ø´Ù¢ù½Ÿ
        ? a
        // ú¿C_6g[‡N%ì*„k ÙYñƒ---à- øÃFé†ÈbÓÈã_ø´Ù¢ù½Ÿ
        CryptA(a, cKey)
        ? a
        // The quick brown fox jumps over the lazy dog.
      </code>
    </example>



  </crypta>
  <ctod>
    <summary>
      Convert a date string to date format.
    </summary>

    <param name="cDate">
      A string of numbers representing the month, day, and year,
      separated by any character other than a number.
      The month, day, and year digits must be in the format set by SetDateFormat() or SetDateCountry().
      If the century digits are not specified, the century is determined by the rules of SetEpoch().
    </param>
    <returns>
      The date value that corresponds to the numbers specified in <paramref name="cDate" />.<br/>
      If <paramref name="cDate" /> is not a valid date, CToD() returns a NULL_DATE.
    </returns>
    <remarks>
      CToD() is a character conversion function that converts a date value originally formatted as a string to a date data type.  <br/>

      To initialize a NULL_DATE, specify <paramref name="cDate" /> as a NULL_STRING.  Keep in mind, however, that you can obtain empty date (or even non-empty dates), without incurring a function call overhead, by just specifying a date literal such as 92.07.22.  <br/>

      Moreover , when a strongly typed variable is declared as having the DATE type, it is automatically initialized to an empty date.
      CToD() is the inverse of DToC(), which converts a date value to a string.  <br/>

      DToS() also converts a date value to a string, and, since it is in the form of yyyymmdd, it is usually the preferred form for indexing a date in combination with a string.
    </remarks>
    <example>
      This example simply applies CToD() to a string:
      <code language="X#">? CToD("05/15/64")&#0009;&#0009;&#0009;&#0009;&#0009;// 05/15/64</code>
      This example compares the return value of CToD() with a hard-coded date:
      <code language="X#">? CToD("05/15/64") = 64.05.15&#0009;&#0009;// .T.</code>
      This example shows that a declared strongly typed DATE variable is initialized to an empty date:
      <code language="X#">
        LOCAL dInit AS DATE
        ? CToD(NULL_STRING) = dInit&#0009;&#0009;&#0009;// .T.
        ? CToD(NULL_STRING) = NULL_DATE&#0009;&#0009;// .T.
      </code>
      This example demonstrates the inverse relationship between CToD() and DToC():
      <code language="X#">? CToD(DToC(Today())) = Today()&#0009;&#0009;// .T.</code>
    </example>

  </ctod>
  <ctodansi>
    <summary>
      Convert an ANSI date string to date format.
    </summary>

    <param name="cDate">
      A string in the ANSI form yyyy.mm.dd, where yy, mm, and dd represent year, month, and day respectively.  <br/>

      The year, month, and day can be separated by any character other than a number.<br/>

      <paramref name="cDate" /> is always interpreted as an ANSI string and is not dependent on SetDateFormat() or SetDateCountry().<br/>

      If the century digits are not specified, the century is determined by the rules of SetEpoch().
    </param>
    <returns>
      The date value that corresponds to the numbers specified in <paramref name="cDate" />.  <br/>

      If <paramref name="cDate" /> is not a valid ANSI date, CToDAnsi() returns a NULL_DATE.
    </returns>
    <remarks>
      CToDAnsi() is a character conversion function that converts an ANSI date string to a date data type.
    </remarks>
    <example>
      This examples simply applies CToDAnsi() to a string:
      <code language="X#">? CToDAnsi("84/10/23")&#0009;&#0009;&#0009;&#0009;// 10/23/84</code>
      This example shows the effect of SetCentury():
      <code language="X#">
        SetCentury(TRUE)
        ? CToDAnsi("2084/10/23")&#0009;&#0009;&#0009;&#0009;// 10/23/2084
        ? CToDAnsi("90$05$14")&#0009;&#0009;&#0009;&#0009;// 05/14/1990
      </code>
      This example shows that CToDAnsi() is not nation-dependent:
      <code language="X#">
        SetDateCountry(GERMAN)
        ? CToDAnsi("84/10/23")&#0009;&#0009;&#0009;&#0009;// 23.10.1984
      </code>
    </example>

  </ctodansi>
  <curdir>
    <summary>
      Return the current Windows directory.
    </summary>

    <param name="cDrive">
      The letter of the disk drive to query.  <br/>

      SetDefault() is ignored; the Windows default is used unless you specify a drive.
    </param>
    <returns>
      The current directory of the drive specified by <paramref name="cDrive" />, without either leading or trailing backslash (\) characters.
      <br/>


      If an error occurs, or the current directory of the specified drive is the root directory, CurDir() returns a NULL_STRING.
      Please note that another Windows task might change the current directory of a non-default drive, thereby affecting the return value of CurDir() when it is used to query non-default drives.
    </returns>
    <remarks>
    </remarks>
    <example>
      These examples illustrate various CurDir() results:
      <code language="X#">
        ? CurDir("e:")&#0009;&#0009;// NULL_STRING, root directory
        ? CurDir("c")&#0009;&#0009;&#0009;// vo\source
        ? CurDir("c:")&#0009;&#0009;&#0009;// vo\source
        ? CurDir()&#0009;&#0009;&#0009;// NULL_STRING, root directory
        ? CurDir("a")&#0009;&#0009;&#0009;// NULL_STRING, drive not ready
      </code>
      This example changes the current Windows directory to a new value if it does not match a specified directory:
      <code language="X#">
        IF CurDir("c:") != "vo\source"
        &#0009;DirChange("\vo\source")
        ENDIF
      </code>
    </example>
  </curdir>
  <curdrive>
    <summary>
      Return the current Windows drive.
    </summary>
    <returns>
      The letter of the current drive, without a trailing colon.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example illustrates the relationship between CurDrive() and DiskChange() and shows that CurDrive() is unaffected by SetDefault():
      <code language="X#">
        FUNCTION DriveTest()
        &#0009;? CurDrive()&#0009;&#0009;&#0009;// C
        &#0009;SetDefault("A")
        &#0009;? CurDrive()&#0009;&#0009;&#0009;// C
        &#0009;DiskChange("A")
        &#0009;? CurDrive()&#0009;&#0009;&#0009;// A
        &#0009;DiskChange("C")
        &#0009;? CurDrive()&#0009;&#0009;&#0009;// C
      </code>
    </example>
  </curdrive>
  <date2bin>
    <summary>
      Convert a date to a 32-bit binary date string.
    </summary>

    <param name="dValue">The date value to convert.</param>
    <returns>
    </returns>
    <remarks>
      Date2Bin() is a conversion function that converts a date data type into a 4-byte string.  Typical applications include reading foreign file types in their native format and then saving, reading, decrypting, and transmitting date types in their compressed binary form instead of in strings.<br/>
      Its inverse is Bin2Date().
    </remarks>
    <example>
      This example uses Date2Bin() to record today's date to a debugging file:
      <code language="X#">
        FUNCTION RecordDate() AS LOGIC
        &#0009;LOCAL nh
        &#0009;LOCAL lSuccess := FALSE AS LOGIC
        &#0009;nh := FOpen2("debug.doc", FO_READWRITE)
        &#0009;// Assumes that file debug.doc already exists
        &#0009;IF nh != F_ERROR
        &#0009;&#0009;FWrite(nh, Date2Bin(Today()))
        &#0009;&#0009;FClose(nh)
        &#0009;&#0009;lSuccess := TRUE
        &#0009;ELSE
        &#0009;&#0009;? "An error occurred when opening debug.doc"
        &#0009;&#0009;? FError()
        &#0009;ENDIF
        &#0009;RETURN lSuccess
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </date2bin>
  <day>
    <summary>
      Extract the number of the day of the month from a date.
    </summary>

    <param name="dDate">The date.</param>
    <returns>
      The day of the month, as a number in the range 0 to 31.  <br/>

      If the day is February 29 and the year is not a leap year, Day() returns 0.  <br/>

      For an invalid or NULL_DATE, Day() returns 0.
    </returns>
    <remarks>
      Day()  is a date conversion function that is useful when you require a numeric day value during calculations for such things as periodic reports.
      Day() is a member of a group of functions that return components of a date value as numbers.  <br/>

      The group includes Month() and Year() to return the month and year values as numerics.  <br/>

      CDoW() is a related function that allows you to return the name of the day from a date value.
    </remarks>
    <example>
      These examples show the Day() function used several ways:
      <code language="X#">
        ? Today()&#0009;&#0009;&#0009;&#0009;&#0009;// 09/01/90
        ? Day(Today())&#0009;&#0009;&#0009;&#0009;// 1
        ? Day(Today()) + 1&#0009;&#0009;&#0009;// 2
        ? Day(0.0.0)&#0009;&#0009;&#0009;&#0009;&#0009;// 0
      </code>
      This example uses Day() in combination with CMonth() and Year() to format a date value:
      <code language="X#">
        ? CMonth(Today()) + Str(Day(Today())) + ;
        &#0009;"," + Str(Year(Today()))&#0009;&#0009;// June 15, 1990
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CDoW'>CDoW</seealso>
    <seealso cref='O:XSharp.RT.Functions.CMonth'>CMonth</seealso>
    <seealso cref='O:XSharp.RT.Functions.DoW'>DoW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Month'>Month</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Today'>Today</seealso>
    <seealso cref='O:XSharp.RT.Functions.Year'>Year</seealso>
  </day>
  <days>
    <summary>
      Convert a specified number of seconds to days.
    </summary>

    <param name="nSeconds">The number of seconds to convert to days.</param>
    <returns>
      The number of days to the nearest day.
    </returns>
    <remarks>
      Days() converts a given number of seconds to the whole number of days.  <br/>

      The remainder under 24 hours can be obtained by the TString() function (see example below).
    </remarks>
    <example>
      This example uses Days() and TString() to show that 300,000 is equal to 3 days, 11 hours, and 20 minutes:
      <code language="X#">
        ? Days(300000)&#0009;&#0009;&#0009;&#0009;// 3
        ? TString(300000)&#0009;&#0009;&#0009;// 11:20:00
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.TString'>TString</seealso>
  </days>
  <dbapp>
    <summary>
      Import records from a database file.
    </summary>

    <param name="cSourceFile">
      The name of the database file from which to add records, including an optional drive, directory, and extension.  <br/>

      See SetDefault() and SetPath() for file searching and creation rules.  <br/>

      The default extension for database files is determined by the RDD .<br/>

      &#0009;This function attempts to open <paramref name="cSourceFile" /> in shared mode.  <br/>

      If the file does not exist, a runtime error is raised.<br/>
      If the file is successfully opened, the operation proceeds.  <br/>

      If access is denied because, for example, another process has exclusive use of the file, NetErr() is set to TRUE.
    </param>
    <param name="acFields">
      The list of fields to append from <paramref name="cSourceFile" />.  <br/>
      The default is all fields.<br/>
      Only fields with the same names and types in both files are appended.  <br/>
      If fields with the same name do not match in data type, a runtime error is raised.
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <param name="cDriver">
      The name of the RDD that will service the work area.  <br/>

      If not specified, the default RDD as determined by RDDSetDefault() is used.
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/acrdds/*"/>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      By default, this function adds record to the database file in the currently selected work area.  <br/>

      It can be made to operate on an unselected work area by specifying it within an aliased expression.
      DBApp() does not require that the database file be used exclusively or locked with FLock() to perform its operation.  <br/>

      As each record is added, X# automatically arbitrates contention for the new record.
      DBApp() is the functional equivalent of the APPEND FROM command, specified without a DELIMITED or SDF clause.
    </remarks>
    <example>
      The following example adds records from the OLD.DBF file:
      <code language="X#">DBApp("old.dbf")</code>
    </example>
    <seealsocmd>APPEND FROM</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbAppDelim'>DBAppDelim</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbAppSdf'>DBAppSDF</seealso>
    <seealso cref='O:VO.DbServer.AppendDB'>DBServer:AppendDB method</seealso>
  </dbapp>
  <dbappdelim>
    <summary>
      Import records from a delimited text file.
    </summary>

    <param name="cSourceFile">
      The name of the delimited text file from which to add records, including an optional drive, directory, and extension.<br/>

      See SetDefault() and SetPath() for file searching and creation rules.  <br/>

      The default extension is .TXT.<br/>

      This function attempts to open <paramref name="cSourceFile" /> in shared mode.  <br/>

      If the file does not exist, a runtime error is raised.<br/>
      If the file is successfully opened, the operation proceeds.<br/>

      If access is denied because, for example, another process has exclusive use of the file, NetErr() is set to TRUE.
    </param>
    <param name="cDelim">
      The delimiter used to separate fields in <paramref name="cSourceFile" />.  <br/>

      The default delimiter is a double quote mark.
    </param>
    <param name="acFields">
      A list of fields to copy from <paramref name="cSourceFile" />.  <br/>
      The default is all fields.
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      DBAppDelim() is the functional equivalent of the APPEND FROM DELIMITED command.
      It is the same as the DBApp() function except that it can be used only with text files.  <br/>

      See APPEND FROM and DBApp() for more information.
    </remarks>
    <example>
      The following example appends records from a text file named SRCDELIM.TXT:
      <code language="X#">
        USE test NEW
        DBAppDelim("srcdelim.txt")
      </code>
    </example>
    <seealsocmd>APPEND FROM</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbApp'>DBApp</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbAppSdf'>DBAppSDF</seealso>
    <seealso cref='O:VO.DbServer.AppendDelimited'>DBServer:AppendDelimited</seealso>
  </dbappdelim>
  <dbappend>
    <summary>
      Add a new record to a database file.
    </summary>

    <param name="lReleaseLocks">
      A logical data type that, if TRUE, clears all pending record locks, then appends the next record.  <br/>

      If FALSE, all pending record locks are maintained, and the new record is added to the end of the lock list.  <br/>

      The default value is TRUE.
    </param>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.  <br/>

      If successfully added, each field in the record is set to the empty value for its data type, and the new record becomes the current record.
    </returns>
    <remarks>
      By default, this function operates on the database file in the currently selected work area.  <br/>

      It can be made to operate on an unselected work area by specifying it within an aliased expression.
      DBAppend(TRUE) performs the same function as the APPEND BLANK command.  <br/>

      For more information, refer to APPEND BLANK.
      <note type="tip">
        Logical records:  DBAppend() does not respect logical visibility.  <br/>

        That is, if the record is successfully added, it becomes the current record, regardless of any order or filter condition.
        Shared mode:  <br/>

        For a shared database, DBAppend() automatically places a record lock on the new record.  <br/>

        If the record cannot be locked, NetErr() is set to TRUE, indicating that the record was not added, and execution continues.
      </note>
    </remarks>
    <example>
      The following example appends a blank record, checks for a NetErr() condition, and updates the data:
      <code language="X#">
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", ;
        &#0009;&#0009;&#0009;&#0009;TRUE)
        ... <paramref name="Statements" />
        DBAppend()
        IF !NetErr()
        &#0009;Sales-&gt;FirstName := cFirst
        &#0009;Sales-&gt;LastName := cLast
        ELSE
        &#0009;QOut("Append operation failed")
        ENDIF
      </code>
      The following example first locks a record and then appends a blank record to the SALES database without releasing the record locks in the current lock list.<br/>
      It also checks for errors:
      <code language="X#">
        USE sales NEW
        DBRLock()&#0009;&#0009;// Lock the current record
        // Add a new record but keep the old lock
        IF DBAppend(FALSE) .AND. !NetErr()
        &#0009;? "Multiple records are locks"
        ELSE
        &#0009;? "An error has occurred!"
        ENDIF
      </code>
    </example>
    <seealsocmd>APPEND BLANK</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbAppend'>VODBAppend</seealso>
    <seealso cref='O:VO.DbServer.Append'>DBServer:Append</seealso>
  </dbappend>
  <dbappsdf>
    <summary>
      Import records from an SDF file.
    </summary>

    <param name="cSourceFile">
      The name of the SDF file from which to add records, including an optional drive, directory, and extension.<br/>

      See SetDefault() and SetPath() for file searching and creation rules.  <br/>

      The default extension is .TXT.<br/>

      This function attempts to open <paramref name="cSourceFile" /> in shared mode.  <br/>

      If the file does not exist, a runtime error is raised.<br/>
      If the file is successfully opened, the operation proceeds.<br/>
      If access is denied because, for example, another process has exclusive use of the file, NetErr() is set to TRUE.
    </param>
    <param name="acFields">
      A list of fields to copy from <paramref name="cSourceFile" />.<br/>
      The default is all records.
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      DBAppSDF() is the functional equivalent of the APPEND FROM SDF command.
      It is the same as the DBApp() function except that it can be used only with SDF files.  See APPEND FROM and DBApp() for more information.
    </remarks>
    <example>
      The following example appends text from an SDF file:
      <code language="X#">
        USE test NEW
        DBAppSDF("srcsdf")
      </code>
    </example>
    <seealsocmd>APPEND FROM</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbApp'>DBApp</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbAppDelim'>DBAppDelim</seealso>
    <seealso cref='O:VO.DbServer.AppendSDF'>DBServer:AppendSDF</seealso>
  </dbappsdf>
  <dbclearfilter>
    <summary>
      Clear a logical filter condition.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBClearFilter() performs the same function as the SET FILTER command with no expression specified.  <br/>

      For more information, refer to SET FILTER.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      <note type="tip">
        Logical records:  DBClearFilter() affects the logical visibility of records in a work area.<br/>
        For more information, refer to DBSetFilter() and the SET FILTER command.
      </note>
    </remarks>
    <example>
      The following example sets a filter, lists data as filtered, and then clears the filter:
      <code language="X#">
        USE employee NEW
        DBSetFilter({|| Age &lt; 40}, "Age &lt; 40")
        GO TOP
        LIST Employee-&gt;Name
        DBClearFilter()
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFilter'>DBFilter</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetFilter'>DBSetFilter</seealso>
    <seealsocmd>SET FILTER</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbClearFilter'>VODBClearFilter</seealso>
    <seealso cref='O:VO.DbServer.ClearFilter'>DBServer:ClearFilter</seealso>
  </dbclearfilter>
  <dbclearindex>
    <summary>
      Remove orders from the order list in a work area and close associated index files.
    </summary>

    <param name="uOrder">
      The name of the order to clear or a number representing its position in the order list.  <br/>

      Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.  <br/>

      If not specified, all orders in the specified index file (or the entire work area, if no index file is specified) are cleared.  <br/>

      Invalid values are ignored.
    </param>
    <param name="cIndexFile">
      The name of an index file, including an optional drive and directory (no extension should be specified).  <br/>

      Use this argument with <paramref name="uOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.  <br/>

      Use it alone to close only those orders associated with the specified file.<br/>

      If <paramref name="cIndexFile" /> is not open by the current process, a runtime error is raised.
    </param>
    <returns>
      TRUE if successful; otherwise FALSE.
    </returns>
    <remarks>
      All pending updates are written to disk prior to closing the index files.  <br/>

      Once the files are closed and the order list cleared, the database file returns to its natural order.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      The following example closes index files if any are open:
      <code language="X#">
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", ;
        &#0009;&#0009;&#0009;TRUE)
        Sales-&gt;DBSetIndex("FirstName")
        Sales-&gt;DBSetIndex("LastName")
        // Are there any open index files?
        IF Sales-&gt;DBOrderInfo(DBOI_NUMBER) &gt; 0
        &#0009;Sales-&gt;DBClearIndex()&#0009;&#0009;// Close index files
        ENDIF
        // Copy to SDF in natural order
        COPY TO temp SDF
      </code>
    </example>
    <seealsocmd>CLOSE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
    <seealso cref='O:VO.DbServer.ClearFilter'>DBServer:ClearFilter</seealso>
  </dbclearindex>
  <dbclearordercondition>
    <summary>
      Clear the condition and scope for an order.
    </summary>
    <returns>
    </returns>
    <remarks>
      This function calls OrdCondSet() with its default arguments to clear the order condition.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrderCondition'>DBSetOrderCondition</seealso>
    <seealso cref='O:VO.DbServer.SetOrderCondition'>DBServer:SetOrderCondition</seealso>
  </dbclearordercondition>
  <dbclearrelation>
    <summary>
      Clear any active relations.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      TRUE if successful; otherwise FALSE.
    </returns>
    <remarks>
      DBClearRelation() performs the same function as the SET RELATION command with no clauses specified.  <br/>

      For more information, refer to the SET RELATION command.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      The following example sets a relation, lists data, and then clears the relation:
      <code language="X#">
        USE employee NEW
        USE department NEW INDEX dept
        SELECT Employee
        DBSetRelation("Department", ;
        &#0009;{|| Employee-&gt;Dept}, "Employee-&gt;Dept")
        LIST Employee-&gt;Name, Department-&gt;Name
        DBClearRelation()
      </code>
    </example>
    <seealso cref='O:VO.DbServer.ClearRelation'>DBServer:ClearRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetRelation'>DBSetRelation</seealso>
    <seealsocmd>SET RELATION</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbClearRelation'>VODBClearRelation</seealso>
  </dbclearrelation>
  <dbcloseall>
    <summary>
      Close all files in all work areas.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBCloseAll() releases all occupied work areas from use.<br/>
      It is equivalent to calling DBCloseArea() on every occupied work area.
      DBCloseAll() has the same effect as the CLOSE DATABASES command.<br/>
      For more information, refer to the CLOSE command.
    </remarks>
    <example>
      The following example closes all work areas:
      <code language="X#">
        cLast := "Winston"
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", TRUE)
        Sales-&gt;DBSetIndex("salefnam")
        Sales-&gt;DBSetIndex("salelnam")
        DBUseArea(TRUE, "DBFNTX", "colls", "Colls", TRUE)
        Colls-&gt;DBSetIndex("collffnam")
        Colls-&gt;DBSetIndex("colllnam")
        // Select "Sales" work area
        IF (Sales-&gt;DBSeek(cLast))
        &#0009;IF Sales-&gt;Deleted()
        &#0009;&#0009;IF Sales-&gt;RLock()
        &#0009;&#0009;&#0009;Sales-&gt;DBRecall()
        &#0009;&#0009;&#0009;QOut("Record deleted: ", Sales-&gt;Deleted())
        &#0009;&#0009;ENDIF
        &#0009;ENDIF
        ELSE
        &#0009;QOut("Not found")
        ENDIF
        DBCloseAll()&#0009;&#0009;&#0009;&#0009;// Close all work areas
      </code>
    </example>
    <seealsocmd>CLOSE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbCloseArea'>DBCloseArea</seealso>
    <seealso cref='O:VO.DbServer.Close'>DBServer:Close</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbCloseAll'>VODBCloseAll</seealso>
  </dbcloseall>
  <dbclosearea>
    <summary>
      Close all files in a work area.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBCloseArea() releases a work area from use.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      DBCloseArea() is equivalent to the CLOSE command or the USE command with no clauses.<br/>
      For more information, refer to the USE and CLOSE commands.
    </remarks>
    <example>
      The following example closes a file via an alias reference:
      <code language="X#">
        cLast := "Winston"
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", TRUE)
        Sales-&gt;DBSetIndex("salefnam")
        Sales-&gt;DBSetIndex("salelnam")
        DBUseArea(TRUE, "DBFNTX", "colls", "Colls", TRUE)
        Colls-&gt;DBSetIndex("collfnam")
        Colls-&gt;DBSetIndex("colllnam")
        // Select "Sales" work area
        IF Sales-&gt;DBSeek(cLast)
        &#0009;IF Sales-&gt;Deleted() .AND. ;
        &#0009;&#0009;Sales-&gt;RLock()
        &#0009;&#0009;QOut("Record deleted: ", Sales-&gt;Deleted())
        &#0009;ENDIF
        ELSE
        &#0009;QOut("Not found")
        &#0009;Colls-&gt;DBCloseArea()
        ENDIF
      </code>
    </example>
    <seealsocmd>CLOSE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbCloseAll'>DBCloseAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCommit'>DBCommit</seealso>
    <seealso cref='O:VO.DbServer.Close'>DBServer:Close</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUseArea'>DBUseArea</seealso>
    <seealsocmd>USE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbCloseArea'>VODBCloseArea</seealso>
  </dbclosearea>
  <dbcommit>
    <summary>
      Flush all pending updates in one work area.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBCommit() causes all updates to the work area to be written to disk.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      All updated database and order buffers are written to DOS, and a DOS Commit request is issued for the database file and any index files associated with the work area.
      DBCommit() performs the same function as the DBCommitAll() function, except that it operates only on the current or aliased work area.
      <note type="tip">
        Shared mode:  DBCommit() makes database updates visible to other processes.<br/>
        To insure data integrity, issue DBCommit() before an unlock operation.
        &#0009;DBCommit() uses DOS interrupt 21h function 68h to perform the solid-disk write.<br/>
        It is up to the network software to properly implement this request.  Check with the network software vendor to see if this is supported.
      </note>
    </remarks>
    <example>
      In this example, DBCommit() is used to force a write to disk after a series of memory variables are assigned to field variables:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL cName, cAmount
        &#0009;USE sales EXCLUSIVE NEW
        &#0009;cName := Sales-&gt;Name
        &#0009;cAmount := Sales-&gt;Amount
        &#0009;@ 10, 10 GET cName
        &#0009;@ 11, 10 GET cAmount
        &#0009;READ
        &#0009;IF Updated()
        &#0009;&#0009;IF DBAppend()
        &#0009;&#0009;&#0009;REPLACE Sales-&gt;Name WITH cName
        &#0009;&#0009;&#0009;REPLACE Sales-&gt;Amount WITH cAmount
        &#0009;&#0009;&#0009;Sales-&gt;DBCommit()
        &#0009;&#0009;ENDIF
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCloseAll'>DBCloseAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCommitAll'>DBCommitAll</seealso>
    <seealso cref='O:VO.DbServer.Commit'>DBServer:Commit</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLock'>DBUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbCommit'>VODBCommit</seealso>
  </dbcommit>
  <dbcommitall>
    <summary>
      Flush all pending updates in all work areas.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBCommitAll() causes all pending updates to all work areas to be written to disk.<br/>
      It is equivalent to calling DBCommit() for every occupied work area.
      For more information, refer to DBCommit().
      <note type="tip">
        DBCommitAll() uses DOS interrupt 21h function 68h to perform the solid-disk write.<br/>
        It is up to the network software to properly implement this request.  Check with the network software vendor to see if this is supported.
      </note>
    </remarks>
    <example>
      The following example writes all pending updates to disk:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL cLast := "Winston"
        &#0009;DBUseArea(TRUE, "DBFNTX", "sales", ;
        &#0009;&#0009;&#0009;&#0009;"Sales", TRUE)
        &#0009;Sales-&gt;DBSetIndex("salefnam")
        &#0009;Sales-&gt;DBSetIndex("salelnam")
        &#0009;DBUseArea(TRUE, "DBFNTX", "colls", "Colls", ;
        &#0009;&#0009;&#0009;&#0009;TRUE)
        &#0009;Colls-&gt;DBSetIndex("collfnam")
        &#0009;Colls-&gt;DBSetIndex("colllnam")
        &#0009;IF Sales-&gt;DBSeek(cLast)
        &#0009;&#0009;IF Sales-&gt;Deleted() .AND. Sales-&gt;RLock()
        &#0009;&#0009;&#0009;Sales-&gt;DBRecall()
        &#0009;&#0009;&#0009;QOut("Deleted record recalled.")
        &#0009;&#0009;ENDIF
        &#0009;ELSE
        &#0009;&#0009;QOut("Not found")
        &#0009;ENDIF
        &#0009;// Processing done, write updates to disk and
        &#0009;// close files
        &#0009;DBCommitAll()
        &#0009;DBCloseAll()
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCloseAll'>DBCloseAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCommit'>DBCommit</seealso>
    <seealso cref='O:VO.DbServer.Commit'>DBServer:Commit</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLock'>DBUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbCommitAll'>VODBCommitAll</seealso>
  </dbcommitall>
  <dbcontinue>
    <summary>
      Resume a pending locate condition.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBContinue() is the functional form of the CONTINUE command.<br/>
      For more information, see the CONTINUE command.
    </remarks>
    <example>
      The following example searches for all occurrences of the name "Winston":
      <code language="X#">
        DBUseArea(TRUE, "DBFNTX", "address", "Address",;
        &#0009;&#0009;&#0009;&#0009;TRUE)
        LOCATE FOR UPPER(Address-&gt;Name) == "WINSTON"
        DO WHILE Found()
        &#0009;? RECNO()
        &#0009;DBContinue()
        ENDDO
      </code>
    </example>
    <seealsocmd>CONTINUE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbLocate'>DBLocate</seealso>
    <seealso cref='O:VO.DbServer.Continue'>DBServer:Continue</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbContinue'>VODBContinue</seealso>
  </dbcontinue>
  <dbcopy>
    <summary>
      Export records to a new database file.
    </summary>

    <param name="cTargetFile">
      The name of the target file, including an optional drive, directory, and extension.  See SetDefault() and SetPath() for file searching and creation rules.<br/>
      The default extension for database files is determined by the RDD.<br/>
      For text files, it is .TXT.<br/>

      &#0009;If <paramref name="cTargetFile" /> does not exist, it is created.<br/>
      If it exists, this function attempts to open the file in exclusive mode and, if successful, the file is overwritten without warning or error.<br/>
      If access is denied because, for example, another process is using the file, NetErr() is set to TRUE.  <br/>

      &#0009;DBCreate() creates the specified file in ANSI or OEM character set format, based on the SetAnsi() setting.  (For more information, refer to the SetAnsi() function.)
    </param>
    <param name="acFields">
      A list of fields to copy to <paramref name="cTargetFile" />.<br/>
      The default is all fields.
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <param name="cDriver">
      The name of the RDD that will service the work area.<br/>
      If not specified, the default RDD as determined by RDDSetDefault() is used.
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/acrdds/*"/>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      By default, this function copies records from the database file in the currently selected work area to a new file.
      It can be made to operate on an unselected work area by specifying it within an aliased expression.
      If SetDeleted() is FALSE, deleted records in the source file are copied to <paramref name="cTargetFile" /> where they retain their deleted status.<br/>
      If SetDeleted() is TRUE, however, no deleted records are copied.  Similarly, if a filter has been set, invisible records are not copied.
      DBCopy() is the functional equivalent of the COPY TO command, specified without a DELIMITED or SDF clause.
    </remarks>
    <example>
      The following example copies records from the current database file to a new database file:
      <code language="X#">
        USE Test NEW
        DBCopy("newdb.dbf")
      </code>
    </example>
    <seealsocmd>COPY TO</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbCopyDelim'>DBCopyDelim</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCopySDF'>DBCopySDF</seealso>
    <seealso cref='O:VO.DbServer.CopyDB'>DBServer:CopyDB</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </dbcopy>
  <dbcopydelim>
    <summary>
      Export records to a new delimited text file.
    </summary>

    <param name="cTargetFile">
      The name of the target file, including an optional drive, directory, and extension.  See SetDefault() and SetPath() for file searching and creation rules.<br/>
      The default extension for database files is determined by the RDD .<br/>
      For text files, it is .TXT.<br/>

      &#0009;If <paramref name="cTargetFile" /> does not exist, it is created.<br/>
      If it exists, this function attempts to open the file in exclusive mode and, if successful, the file is overwritten without warning or error.<br/>
      If access is denied because, for example, another process is using the file, NetErr() is set to TRUE.
    </param>
    <param name="cDelim">
      The delimiter used to separate fields in <paramref name="cTargetFile" />.<br/>
      The default delimiter is a double quote mark.
    </param>
    <param name="acFields">
      A list of fields to copy to <paramref name="cTargetFile" />.<br/>
      The default is all fields.
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      DBCopyDelim() is the functional equivalent of the COPY TO DELIMITED command.
      It is the same as DBCopy() except that it copies records to a delimited text file.  See COPY TO and DBCopy() for more information.
    </remarks>
    <example>
      The following example copies records from the current database file to a delimited text file:
      <code language="X#">
        USE Test NEW
        IF Used()
        &#0009;DBCopyDelim("newdelim")
        ENDIF
      </code>
    </example>
    <seealsocmd>COPY TO</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbCopy'>DBCopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCopySDF'>DBCopySDF</seealso>
    <seealso cref='O:VO.DbServer.CopyDelimited'>DBServer:CopyDelimited</seealso>
  </dbcopydelim>
  <dbcopysdf>
    <summary>
      Export records to a new SDF file.
    </summary>

    <param name="cTargetFile">
      The name of the target file, including an optional drive, directory, and extension.  See SetDefault() and SetPath() for file searching and creation rules.<br/>
      The default extension for database files is determined by the RDD .<br/>
      For text files, it is .TXT.<br/>

      &#0009;If <paramref name="cTargetFile" /> does not exist, it is created.<br/>
      If it exists, this function attempts to open the file in exclusive mode and, if successful, the file is overwritten without warning or error.<br/>
      If access is denied because, for example, another process is using the file, NetErr() is set to TRUE.
    </param>
    <param name="acFields">
      A list of fields to copy to <paramref name="cTargetFile" />.<br/>
      The default is all fields.
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      DBCopySDF() is the functional equivalent of the COPY TO SDF command.
      It is the same as DBCopy() except that it copies records to an SDF file.  See COPY TO and DBCopy() for more information.
    </remarks>
    <example>
      The following example copies records from the current database file to an SDF file:
      <code language="X#">
        USE Test NEW
        IF Used()
        &#0009;DBCopySDF("newsdf")
        ENDIF
      </code>
    </example>
    <seealsocmd>COPY TO</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbCopy'>DBCopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCopyDelim'>DBCopyDelim</seealso>
    <seealso cref='O:VO.DbServer.CopySDF'>DBServer:CopySDF</seealso>
  </dbcopysdf>
  <dbcopystruct>
    <summary>
      Create an empty database file with field definitions from another database file.
    </summary>

    <param name="cTargetFile">
      The name of the target database file, including an optional drive, directory, and extension.  See SetDefault() and SetPath() for file searching and creation rules.<br/>
      The default extension for database files is determined by the RDD .<br/>

      &#0009;If <paramref name="cTargetFile" /> does not exist, it is created.<br/>
      If it exists, this function attempts to open the file in exclusive mode and, if successful, the file is overwritten without warning or error.<br/>
      If access is denied because, for example, another process is using the file, NetErr() is set to TRUE.  <br/>

      &#0009;DBCopyStruct() creates the specified file in ANSI or OEM character set format, based on the SetAnsi() setting.  (For more information, refer to the SetAnsi() function.)
    </param>
    <param name="acStruct">
      A one-dimensional array of field names to copy to the new database file.<br/>
      The default is all fields.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      DBCopyStruct() is the functional equivalent of the COPY STRUCTURE command.
    </remarks>
    <example>
      The following example copies the structure of the current database file to a new database file:
      <code language="X#">
        USE Test NEW
        IF Used()
        &#0009;DBCopyStruct("c:\savestru\test")
        ENDIF
      </code>
    </example>
    <seealsocmd>COPY STRUCTURE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbCopyXStruct'>DBCopyXStruct</seealso>
    <seealso cref='O:VO.DbServer.CopyStructure'>DBServer:CopyStructure</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbStruct'>DBStruct</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </dbcopystruct>
  <dbcopyxstruct>
    <summary>
      Copy the field definitions in a database file structure to a structure-extended file as data.
    </summary>

    <param name="cTargetFile">
      The name of the target structure-extended database file, including an optional drive, directory, and extension.  See SetDefault() and SetPath() for file searching and creation rules.<br/>
      The default extension for database files is determined by the RDD .<br/>

      &#0009;If <paramref name="cTargetFile" /> does not exist, it is created.<br/>
      If it exists, this function attempts to open the file in exclusive mode and, if successful, the file is overwritten without warning or error.<br/>
      If access is denied because, for example, another process is using the file, NetErr() is set to TRUE.  <br/>

      &#0009;DBCreate() creates the specified file in ANSI or OEM character set format, based on the SetAnsi() setting.  (For more information, refer to the SetAnsi() function.)
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBCopyXStruct() creates a database file whose contents is the structure of the current database file, with a record for the definition of each field.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      The structure-extended database file has the following structure:
      Name&#0009;Type&#0009;Length&#0009;Decimals&#0009;
      Field_Name&#0009;Character&#0009;10&#0009;&#0009;
      Field_Type&#0009;Character&#0009;1&#0009;&#0009;
      Field_Len&#0009;Numeric&#0009;3&#0009;0&#0009;
      Field_Dec&#0009;Numeric&#0009;3&#0009;0&#0009;
      Used in application programs, DBCopyXStruct() permits you to create or modify the structure of a database file programmatically.<br/>
      To create a new database file from the structure-extended file, use CREATE FROM.<br/>
      If you need an empty structure-extended file, use CREATE.
      DBCopyXStruct() is the functional implementation of the COPY STRUCTURE EXTENDED command.
      <note type="tip">
        Character field lengths greater than 255:  Field lengths greater than 255 are represented as a combination of the Field_Dec and Field_Len fields.<br/>
        After performing DBCopyXStruct(), you can use the following formula to determine the length of any character field:
        <code language="X#">
          nFieldLen := If((Field_Type = "C" .AND. ;
          &#0009;&#0009;Field_Dec != 0), Field_Dec * 256 + ;
          &#0009;&#0009;Field_Len, Field_Len)
        </code>
      </note>
    </remarks>
    <example>
      The following example creates a new structure-extended file:
      <code language="X#">
        USE test
        IF Used()
        &#0009;DBCopyXStruct("stru.dbf")
        ENDIF
      </code>
    </example>
    <seealsocmd>COPY STRUCTURE EXTENDED</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbCopyStruct'>DBCopyStruct</seealso>
    <seealso cref='O:VO.DbServer.CopyStructure'>DBServer:CopyStructure</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </dbcopyxstruct>
  <dbcreate>
    <summary>
      Create a database file from a database structure array.
    </summary>

    <param name="cTargetFile">
      The name of the new database file, including an optional drive, directory, and extension.  See SetDefault() and SetPath() for file searching and creation rules.<br/>
      The default extension for database files is determined by the RDD .<br/>

      &#0009;If <paramref name="cTargetFile" /> does not exist, it is created.<br/>
      If it exists, this function attempts to open the file in exclusive mode and, if successful, the file is overwritten without warning or error.<br/>
      If access is denied because, for example, another process is using the file, NetErr() is set to TRUE.  <br/>

      &#0009;DBCreate() creates the specified file in ANSI or OEM character set format, based on the SetAnsi() setting.  (For more information, refer to the SetAnsi() function.)
    </param>
    <param name="aStruct">
      An array containing field descriptions in the format returned by DBStruct().<br/>
      This array defines the structure for the new database file.
    </param>
    <param name="cDriver">
      The name of the RDD that will service the work area.<br/>
      If not specified, the default RDD as determined by RDDSetDefault() is used.
    </param>
    <param name="lNew">
      TRUE opens the database file in a new work area (first available).  FALSE opens it in the current work area.  <paramref name="lNew" /> is useful only when <paramref name="lOpen" /> has a value of TRUE. The default is FALSE.
    </param>
    <param name="cAlias">
      The alias to be associated with the work area where the file is opened.  Within a single application, X# will not accept duplicate aliases.  <paramref name="cAlias" /> is useful only when <paramref name="lOpen" /> has a value of TRUE.<br/>
      The default alias is the eight-letter database file name .
    </param>
    <param name="cDelim">
      The delimiter for fields within a delimited database file.<br/>
      If you are using one of the supplied RDDs for processing .DBF files, the delimiter should be a NULL_STRING, which is the default if the<br/>

      &#0009;argument is omitted.
    </param>
    <param name="lOpen">
      TRUE specifies that an existing database file be opened; FALSE specifies that that a new database file be opened.<br/>
      The default is FALSE.<br/>
      This can be used to open existing SDF and delimited files, which do not have a structure in the header — in which case, <paramref name="aStruct" /> should be used.
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/acrdds/*"/>
    <returns>
      TRUE if the requested actions are successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBCreate() creates a database file from an array containing the structure of the file.  DBCreate() is similar to the CREATE FROM command, which creates a new database file structure from a structure-extended file.
      Before using DBCreate(), you must first create the <paramref name="aStruct" /> array and fill it with the field definition arrays, according to the structure in the table above.  You can create the array programmatically or by using DBStruct().
      There are some specific rules for creating a field definition array, including:
      -&#0009;Specify all field attributes with a value of the proper data type for the attribute.<br/>
      The decimals attribute must be specified — even for non-numeric fields.<br/>
      If the field does not have a decimals attribute, specify 0.
      -&#0009;Specify the type attribute using the first letter of the data type as a minimum.<br/>
      Use longer and more descriptive terms for readability.<br/>
      For example, both "C" and "Character" can be specified as the type attribute for character fields.
      -&#0009;Unlike the CREATE FROM command, DBCreate() does not use the decimals attribute to specify the high-order part of the field length.  Specify the field length directly, regardless of its magnitude.
    </remarks>
    <example>
      The following example demonstrates DBCreate():
      <code language="X#">
        USE test
        IF Used()
        &#0009;DBCreate("newdb.dbf", DBStruct(), "",;
        &#0009;&#0009;&#0009;&#0009;&#0009;TRUE,"", "", FALSE)
        ENDIF
      </code>
      This example creates an empty array and then adds field definition subarrays using the AAdd() function before creating PEOPLE.DBF.  You might use this technique to add field definitions to your structure array dynamically:
      <code language="X#">
        aDBF := {}
        AAdd(aDBF, {"Name", "C", 25, 0})
        AAdd(aDBF, {"Address", "C", 1024, 0})
        AAdd(aDBF, {"Phone", "N", 13, 0})
        DBCreate("people", aDBF)
      </code>
      This next example performs the same types of actions as the example above, but it declares the structure array as a two-dimensional array, and then uses subscript addressing to specify the field definitions.<br/>
      The database file is created using the DBFMDX RDD:
      <code language="X#">
        LOCAL aDBF[1][4]
        aDBF[1][DBS_NAME] := "Name"
        aDBF[1][DBS_TYPE] := "Character"
        aDBF[1][DBS_LEN]  := 25
        aDBF[1][DBS_DEC]  := 0
        DBCreate("Name", aDBF, "DBFMDX")
      </code>
    </example>
    <seealsocmd>COPY STRUCTURE EXTENDED</seealsocmd>
    <seealsocmd>CREATE FROM</seealsocmd>
    <seealso cref='O:VO.DbServer.CopyStructure'>DBServer:CopyStructure</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbStruct'>DBStruct</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </dbcreate>
  <dbcreateindex>
    <summary>
      Create an index file and add an order to it.
    </summary>

    <param name="cIndexFile">
      The name of the target index file, including an optional drive, directory, and extension.  See SetDefault() and SetPath() for file searching and creation rules.<br/>
      The default extension is determined by the RDD and can be obtained using DBOrderInfo(DBOI_INDEXEXT).<br/>

      &#0009;In RDDs that support production indexes, the production index file is assumed if <paramref name="cIndexFile" /> is not specified.<br/>

      &#0009;If <paramref name="cIndexFile" /> does not exist, it is created.<br/>

      &#0009;If <paramref name="cIndexFile" /> exists, DBCreateIndex() must first obtain exclusive use of the file.<br/>
      If successful, the file is overwritten without warning or error.<br/>
      If the attempt is unsuccessful because, for example, the file is open by another process, NetErr() is set to TRUE.
    </param>
    <param name="cKeyValue">
      The order key expression specified as a string.<br/>
      This is the key expression that is stored in the index file and used for such purposes as locating key values and recreating the order.<br/>

      &#0009;Although <paramref name="cKeyValue" /> is optional, it is highly recommended that you specify this argument.  Without it, the order will be properly created using <paramref name="cbKeyValue" />, but the key expression will be stored in the index file as a NULL_STRING, rendering the order unusable for subsequent access.
    </param>
    <param name="cbKeyValue">
      The order key expression specified as a code block.<br/>
      This code block is used to initially create the order.<br/>
      If you do not supply <paramref name="cbKeyValue" />, it is macro-compiled from <paramref name="cKeyValue" /> (for example, {||&amp;<paramref name="cKeyValue" />}).<br/>

      &#0009;The data type of the key expression and all other limitations, including the length of the key and the key expression, are determined by the RDD.
    </param>
    <param name="lUnique">
      TRUE creates a unique order by including only those records with unique key values; FALSE uses all records in the database file.<br/>
      If <paramref name="lUnique" /> is omitted, the SetUnique() setting is used.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      By default, this function creates an index file for the database file associated with the currently selected work area.<br/>
      It can be made to operate on an unselected work area by specifying it within an aliased expression.
      DBCreateIndex() uses the current DBSetOrderCondition() to determine the conditions for the order (for example, its scope, for condition, and while condition).
      If there are other open index files in the work area, they are closed.<br/>
      After the new index file is created, an order is added to the file using the index file name and the specified key.<br/>
      The index file is opened (in the same mode as its associated database file), the controlling order for the work area is set, and the database file is positioned to the first logical record.
      Note:<br/>
      If the RDD supports multiple orders per index file, add subsequent orders to the index file using DBCreateOrder().
      <note type="tip">
        Side effects:&#0009;DBCreateIndex() is guaranteed to create an order that, when made the controlling order, will impose the specified logical order on the database.<br/>
        The key expression is not necessarily evaluated at any particular time, by any particular means, or on any particular record or series of records.<br/>
        If the key expression relies on information external to the database file or work area, the effect is unpredictable.<br/>
        If the key expression changes the state of the work area (for example, by moving to a different record or changing the contents of a record), the effect is unpredictable.
        Key evaluation:&#0009;Before the key expression is evaluated, the associated work area is automatically selected as the current work area; the previously selected work area is automatically restored afterward.
      </note>
    </remarks>
    <example>
      This example creates an index file, EMPNAME, indexed on the Name field:
      <code language="X#">
        USE employee NEW
        Employee-&gt;DBCreateIndex("EmpName", "Name", ;
        &#0009;{|| Employee-&gt;Name})
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearIndex'>DBClearIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
    <seealso cref='O:VO.DbServer.CreateIndex'>DBServer:CreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbReindex'>DBReindex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrder'>DBSetOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrderCondition'>DBSetOrderCondition</seealso>
    <seealsocmd>INDEX</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.NetErr'>NetErr</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
  </dbcreateindex>
  <dbcreateorder>
    <summary>
      Create or replace an order in an index file.
    </summary>

    <param name="cOrder">
      The name of the order to be created.<br/>
      For single-order index files, the file name without an extension or path, is the default order name.<br/>
      For multiple-order index files, the order name is required.
    </param>
    <param name="cIndexFile">
      The name of the target index file, including an optional drive, directory, and extension.  See SetDefault() and SetPath() for file searching and creation rules.<br/>
      The default extension is determined by the RDD and can be obtained using DBOrderInfo(DBOI_INDEXEXT).<br/>

      &#0009;In RDDs that support production indexes , the production index file (that is, one with the same name as the database file) is assumed if <paramref name="cIndexFile" /> is not specified.<br/>

      &#0009;If <paramref name="cIndexFile" /> does not exist, it is created.<br/>

      &#0009;If <paramref name="cIndexFile" /> exists, the INDEX command must first obtain exclusive use of the file.<br/>
      If the attempt is unsuccessful because, for example, the file is open by another process, NetErr() is set to TRUE.  <br/>

      &#0009;If the attempt is successful and the RDD specifies that index files can contain only a single order, the current contents of the file is overwritten with the new order.<br/>
      If the RDD specifies that index files can contain multiple orders, the order is added to <paramref name="cIndexFile" /> if it does not already exist; otherwise it is replaced.
    </param>
    <param name="cKeyValue">
      The order key expression specified as a string.<br/>
      This is the key expression that is stored in the index file and used for such purposes as locating key values and recreating the order.<br/>

      &#0009;Although <paramref name="cKeyValue" /> is optional, it is highly recommended that you specify this argument.  Without it, the order will be properly created using <paramref name="cbKeyValue" />, but the key expression will be stored in the index file as a NULL_STRING, rendering the order unusable for subsequent access.
    </param>
    <param name="cbKeyValue">
      The order key expression specified as a code block.<br/>
      This code block is used to initially create the order.<br/>
      If you do not supply <paramref name="cbKeyValue" />, it is macro-compiled from <paramref name="cKeyValue" /> (for example, {||&amp;<paramref name="cKeyValue" />}).<br/>

      &#0009;The data type of the key expression and all other limitations, including the length of the key and the key expression, are determined by the RDD.
    </param>
    <param name="lUnique">
      TRUE creates a unique order by including only those records with unique key values; FALSE uses all records in the database file.<br/>
      If <paramref name="lUnique" /> is omitted, the SetUnique() setting is used.Note that keys from deleted records are also included in the index, and may hide keys from non-deleted records.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      DBCreateOrder() uses the current DBSetOrderCondition() to determine the conditions for the order (for example, its scope, for condition, and while condition).
      After it is created (or replaced), the new order is added to the order list for the work area.  Other orders already associated with the work area, including the controlling order, are unaffected.
      Note:<br/>
      Although this function is designed to work with both single-order and multiple-order index files, you may find it is easier to use DBCreateIndex() for creating single-order index files.
      <note type="tip">
        Side effects:&#0009;DBCreateOrder() is guaranteed to create an order that, when made the controlling order, will impose the specified logical order on the database.<br/>
        The key expression is not necessarily evaluated at any particular time, by any particular means, or on any particular record or series of records.<br/>
        If the key expression relies on information external to the database file or work area, the effect is unpredictable.<br/>
        If the key expression changes the state of the work area (for example, by moving to a different record or changing the contents of a record), the effect is unpredictable.
        Key evaluation:&#0009;Before the key expression is evaluated, the associated work area is automatically selected as the current work area; the previously selected work area is automatically restored afterward.
      </note>
    </remarks>
    <example>
      This example creates the order CUACCT and adds it to the production index file CUSTOMER:
      <code language="X#">
        USE customer VIA "DBFMDX" NEW
        Customer-&gt;DBCreateOrder("CuAcct", "Customer", ;
        &#0009;"Acct", {|| Customer-&gt;Acct})
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearIndex'>DBClearIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbReindex'>DBReindex</seealso>
    <seealso cref='O:VO.DbServer.CreateOrder'>DBServer:CreateOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrder'>DBSetOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrderCondition'>DBSetOrderCondition</seealso>
    <seealsocmd>INDEX</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
  </dbcreateorder>
  <dbdelete>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <summary>
      Mark the current record for deletion.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      Records marked for deletion can be filtered using SetDeleted() or removed from the file using DBPack().
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      DBDelete() is the functional equivalent of the DELETE command with a scope of the current record.<br/>
      For more information, refer to DELETE.
      <note type="tip">
        Logical records:&#0009;If SetDeleted() is TRUE, deleted records are not logically visible.  That is, database operations which operate on logical records will not consider records marked for deletion.  Note, however, that if SetDeleted() is TRUE when the current record is marked for deletion, the record remains visible until it is no longer the current record.
        Shared mode:&#0009;For a shared database, DBDelete() requires the current record to be locked.
      </note>
    </remarks>
    <example>
      The following example deletes a record after a successful record lock:
      <code language="X#">
        cLast := "Winston"
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", TRUE)
        Sales-&gt;DBSetIndex("LastName")
        IF Sales-&gt;DBSeek(cLast)
        &#0009;IF Sales-&gt;RLock()
        &#0009;&#0009;Sales-&gt;DBDelete()
        &#0009;&#0009;QOut("Record deleted: ", Sales-&gt;Deleted())
        &#0009;ELSE
        &#0009;&#0009;QOut("Unable to lock record...")
        &#0009;ENDIF
        ELSE
        &#0009;QOut("Not found")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRecall'>DBRecall</seealso>
    <seealso cref='O:VO.DbServer.Delete'>DBServer:Delete</seealso>
    <seealsocmd>DELETE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.Deleted'>Deleted</seealso>
    <seealsocmd>RECALL</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbDelete'>VODBDelete</seealso>
  </dbdelete>
  <dbdeleteorder>
    <summary>
      Remove an order from an open index file.
    </summary>

    <param name="uOrder">
      The name of the order to be removed or a number representing its position in the order list.<br/>
      Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.<br/>
      If the order cannot be found, a runtime error is raised.
    </param>
    <param name="cIndexFile">
      The name of an index file, including an optional drive and directory (no extension should be specified).<br/>
      Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.<br/>

      &#0009;If <paramref name="cIndexFile" /> is not open by the current process, a runtime error is raised.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBDeleteOrder() requires that the current database be open in exclusive mode.<br/>
      If this condition is not met when DBDeleteOrder() is invoked, a runtime error is raised.
      DBDeleteOrder() deletes one order from a multiple-order index file and removes the order from the current order list.
      To delete the entire index file, use a regular file handling function such as Windows DeleteFile().
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      Note:<br/>
      The RDD determines the order capacity of an index file, and DBDeleteOrder() is supported only by RDDs with multiple-order capabilities.<br/>
      For single-order index files, you must delete the entire file.
      <br/>



      Third-party RDD suppliers may define specific behaviors for this function.
    </remarks>
    <example>
      In this example, since both open index files may contain an order named CUACCT, the DBDeleteOrder() function distinguishes which index file to use:
      <code language="X#">
        USE customer VIA "DBFMDX" NEW
        Customer-&gt;DBSetIndex("customer")
        Customer-&gt;DBSetIndex("custtemp")
        Customer-&gt;DBDeleteOrder("cuacct", "customer")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:VO.DbServer.DeleteOrder'>DBServer:DeleteOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
  </dbdeleteorder>
  <dbdriver>
    <summary>
      Return the default RDD for the application.
    </summary>
    <returns>
      The name of the RDD that will be used to activate and manage applications when no driver is explicitly specified.<br/>
      If this RDD is not available to the application, the call has no effect.
    </returns>
    <remarks>
      To set the default RDD, use RDDSetDefault().
    </remarks>
    <example>
      The following example checks the default RDD to report the default extension for the index files:
      <code language="X#">
        IF DBDriver() == "DBFMDX"
        &#0009;QOut(".MDX extension")
        ENDIF
      </code>
    </example>
    <seealso cref='P:VO.DbServer.Driver'>DBServer:Driver</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddName'>RDDName</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddName'>VODBRDDName</seealso>
  </dbdriver>
  <dbeval>
    <summary>
      Evaluate a code block for each record that matches a specified scope and/or condition.
    </summary>

    <param name="cbExecute">The code block to execute for each record that matches the scope and conditions.</param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      On each iteration, DBEval() evaluates the specified code block.
      All records within the scope or matching the condition are processed until end-of-file is reached.
      DBEval() is similar to AEval(), which executes code for each element in an array.
      Like AEval(), DBEval() can be used as a primitive for the construction of commands that process database files.
      In fact, many of the X# database processing commands are created using DBEval().
    </remarks>
    <example>
      This example uses DBEval() to enhance the DBList() function:
      <code language="X#">
        GLOBAL siFCount
        FUNCTION MyListAll(cFile AS STRING) AS LOGIC PASCAL
        &#0009;LOCAL lRetCode AS LOGIC
        &#0009;USE test
        &#0009;IF Used()
        &#0009;&#0009;siFCount := FCount()
        &#0009;&#0009;cbDisp  := {|| ShowFields()}
        &#0009;&#0009;GO TOP
        &#0009;&#0009;lRetCode := DBEval(cbDisp)
        &#0009;ENDIF
        &#0009;RETURN lRetCode
        FUNCTION ShowFields() AS VOID PASCAL
        &#0009;LOCAL i AS WORD
        &#0009;IF Deleted()
        &#0009;&#0009;QOut("*")
        &#0009;ELSE
        &#0009;&#0009;QOut()
        &#0009;ENDIF
        &#0009;FOR i := 1 UPTO siFCount
        &#0009;&#0009;QQOut(FieldGet(i))
        &#0009;&#0009;QQOut(" ")
        &#0009;NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:VO.DbServer.Eval'>DBServer:Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbEval'>VODBEval</seealso>
  </dbeval>
  <dbf>
    <summary>
      Return the name of the alias.
      Note:  DBF() is a compatibility function and is no longer recommended.<br/>
      It is superseded by Alias0().  See Alias0() for more information.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      The alias of the work area as a string.<br/>
      If there is no active database file in the work area, DBF() returns a NULL_STRING.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias'>Alias</seealso>
    <seealso cref='P:VO.DbServer.Alias'>DBServer:Alias</seealso>
    <seealso cref='P:VO.DbServer.AliasSym'>DBServer:AliasSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.Used'>Used</seealso>
  </dbf>
  <dbfieldinfo>
    <summary>
      Return and optionally change information about a field.
    </summary>

    <param name="kInfoType">
      Specifies the type of information.<br/>
      The constants are described in the Constants section below.  Note, however, that not all constants are supported for all RDDs.<br/>
      See the remarks section for a list of the constants that are supported.
    </param>
    <param name="nFieldPos">
      The position of the field in the database file structure or a numeric pointer to a BLOB.  Only certain <paramref name="kInfoType" /> constants designed to work with BLOB fields — all noted in the Constants section below — allow specifying the field using a pointer; all others require specifying the field by its position.
    </param>
    <param name="uNewSetting">
      If specified, this parameter is used to change the value of a setting.<br/>
      The data type (and whether <paramref name="uNewSetting" /> can be specified), depends on the <paramref name="kInfoType" /> constant and is documented in the Constants section below.<br/>
    </param>
    <returns>
      If <paramref name="uNewSetting" /> is not specified, DBFieldInfo() returns the current setting.<br/>
      If <paramref name="uNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      DBFieldInfo() retrieves information about the state of a field (column).
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      <include file="RTComments.xml" path="Comments/DBS_Constants/*"  />
      The field information that is available is defined by the RDD.  
      In the DBF work area model, this is limited to the information stored in the DBF file structure 
      (that is, name, length, number of decimals, and data type) plus the field alias that can be changed at runtime.
      To support RDDs for other database models (such as dictionary based databases) that store more information about 
      each field or column, the X# RDD API has been enhanced.<br/>
      The DBFieldInfo() and VODBFieldInfo() functions are designed to allow for 
      additional <paramref name="kInfoType" /> values that can be defined by third-party RDD developers.
    </remarks>
    <example>
      The following examples use DBFieldInfo() to retrieve field information:
      <code language="X#">
        QOut(DBFieldInfo(DBS_NAME, 1))
        // Same as FieldName(1)
        FUNCTION DBOutStruct() AS ARRAY PASCAL
        &#0009;LOCAL aStruct AS ARRAY
        &#0009;LOCAL wFcount AS DWORD
        &#0009;LOCAL i       AS DWORD
        &#0009;aStruct := {}
        &#0009;wFcount := FCount()
        &#0009;FOR i := 1 UPTO wFcount
        &#0009;&#0009;AAdd(aStruct, {FieldName(i), ;
        &#0009;&#0009;DBFieldInfo(DBS_TYPE, i)  , ;
        &#0009;&#0009;DBFieldInfo(DBS_LEN, i)   , ;
        &#0009;&#0009;DBFieldInfo(DBS_DEC, i)}&#0009;)
        &#0009;NEXT
        &#0009;RETURN aStruct
      </code>
      The next example illustrates using the third parameter to assign an alias to a field name:
      <code language="X#">
        FUNCTION Start()
        &#0009;USE datebook
        &#0009;DBFieldInfo(DBS_ALIAS, FieldPos("Name"), "NewName")
        &#0009;? Name&#0009;&#0009;&#0009;// Displays name field
        &#0009;? NewName&#0009;&#0009;&#0009;// Also displays name field
      </code>
      &#0009;
      &#0009;
      &#0009;
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRecordInfo'>DBRecordInfo</seealso>
    <seealso cref='O:VO.DbServer.FieldInfo'>DBServer:FieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddInfo'>RDDInfo</seealso>
  </dbfieldinfo>
  <dbfilter>
    <summary>
      Return a filter.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      The filter condition defined in a work area.<br/>
      If no filter has been set, DBFilter() returns a NULL_STRING.
    </returns>
    <remarks>
      DBFilter() is a database function used to save and re-execute an active filter by returning the filter expression as a string.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      This function operates like the DBRelation() and DBRSelect() functions, which save and re-execute the linking expression of a relation within a work area.
      <note type="tip">
        Declared variables:&#0009;A string returned by DBFilter() cannot operate correctly when recompiled and executed using the macro operator (&amp;) if the original filter expression contained references to local or static variables or is otherwise dependent on compile-time declarations.
      </note>
    </remarks>
    <example>
      This example opens two database files, sets two filters, then displays the filter expressions for both work areas:
      <code language="X#">
        USE customer INDEX customer NEW
        SET FILTER TO Last = "Smith"
        USE invoices INDEX invoices NEW
        SET FILTER TO CustId = "Smi001"
        SELECT customer
        QOut(DBFilter())
        // Result: Last = "Smith"
        QOut(Invoices-&gt;DBFilter())
        // Result: Custid = "Smi001"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRelation'>DBRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRSelect'>DBRSelect</seealso>
    <seealso cref='P:VO.DbServer.Filter'>DBServer:Filter</seealso>
    <seealsocmd>SET FILTER</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbFilter'>VODBFilter</seealso>
  </dbfilter>
  <dbgetselect>
    <summary>
      Return the work area number.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      A number that indicates the workarea number.
    </returns>
    <remarks>
      DBGetSelect() is the recommended way to get the number of the currently selected work area. It does not, however, retrieve any information about the occupation of this work area by a database.
    </remarks>
    <example>
      The following example checks for a current work area:
      <code language="X#">
        IF !USED(DBGetSelect())
        &#0009;QOut("No work area in use.")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbGetSelect'>VODBGetSelect</seealso>
  </dbgetselect>
  <dbgobottom>
    <summary>
      Move to the last logical record.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      DBGoBottom() is the functional equivalent of the GO BOTTOM command.<br/>
      For more information, refer to the GO command.
      <note type="tip">
        Logical records:&#0009;DBGoBottom() operates on logical records.<br/>
        If the work area has an active order list, DBGoBottom() moves to the last record in controlling order.<br/>
        If a filter is set, only records which meet the filter condition are considered.
        Shared mode:&#0009;For a shared file, moving to a different record can cause updates to the current record to become visible to other processes.
      </note>
    </remarks>
    <example>
      The following example uses DBGoBottom() to position the record pointer on the last logical record:
      <code language="X#">
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", TRUE)
        Sales-&gt;DBSetIndex("lastname")
        Sales-&gt;DBGoBottom()
        IF Sales-&gt;Last == "Winston"
        &#0009;IF Sales-&gt;RLock()
        &#0009;&#0009;Sales-&gt;DBDelete()
        &#0009;&#0009;QOut("Record deleted: ", Sales-&gt;Deleted())
        &#0009;ELSE
        &#0009;&#0009;QOut("Unable to lock record...")
        &#0009;ENDIF
        END
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bof'>BOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoTop'>DBGoTop</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealso cref='O:VO.DbServer.GoBottom'>DBServer:GoBottom</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSkip'>DBSkip</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealsocmd>GO</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbGoBottom'>VODBGoBottom</seealso>
  </dbgobottom>
  <dbgoto>
    <summary>
      Move to a record specified by record number.
    </summary>

    <param name="uRecID">
      The record number to go to.<br/>
      If <paramref name="uRecID" /> does not exist, the work area is positioned to LastRec() + 1, and both EOF() and BOF() return TRUE.
    </param>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      DbGoTo() performs the same function as the GO command.<br/>
      For more information, refer to the GO command.
      <note type="tip">
        Logical records:&#0009;DBGoTo() does not respect logical visibility.  That is, if the specified record exists, it will become the current record regardless of any order or filter condition.
        Shared mode:&#0009;For a shared file, moving to a different record can cause updates to the current record to become visible to other processes.
      </note>
    </remarks>
    <example>
      The following example uses DbGoTo() to iteratively process every fourth record:
      <code language="X#">
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", TRUE)
        // Toggle every fourth record
        DO WHILE !EOF()
        &#0009;DBGoTo(RecNo() + 4)
        &#0009;Sales-&gt;Group := "Bear"
        ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bof'>BOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoBottom'>DBGoBottom</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoTop'>DBGoTop</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealso cref='O:VO.DbServer.GoTo'>DBServer:GoTo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSkip'>DBSkip</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealsocmd>GO</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbGoto'>VODBGoTo</seealso>
  </dbgoto>
  <dbgotop>
    <summary>
      Move to the first logical record.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      DBGoTop() performs the same function as the GO TOP command.
      <note type="tip">
        Logical records:&#0009;DBGoTop() operates on logical records.<br/>
        If the work area has an active order list, DBGoTop() moves to the first record in the controlling order.<br/>
        If a filter is set, only records which meet the filter condition are considered.
        Shared mode:&#0009;For a shared file, moving to a different record can cause updates to the current record to become visible to other processes.
      </note>
    </remarks>
    <example>
      This example demonstrates the typical use of DBGoTop():
      <code language="X#">
        DBGoTop()
        WHILE (!EOF())
        &#0009;QOut(_FIELD-&gt;Name)
        &#0009;DBSkip()
        END
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bof'>BOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoBottom'>DBGoBottom</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealso cref='O:VO.DbServer.GoTop'>DBServer:GoTop</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSkip'>DBSkip</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealsocmd>GO</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbGoTop'>VODBGoTop</seealso>
  </dbgotop>
  <dbinfo>
    <summary>
      Return and optionally change information about a database file open in a work area.
    </summary>

    <param name="kInfoType">
      Specifies the type of information.<br/>
      The constants are described in the Constants section below.  Note, however, that not all constants are supported for all RDDs.<br/>
    </param>
    <param name="uNewSetting">
      If specified, this parameter is used to change the value of a setting.<br/>
      The data type (and whether <paramref name="uNewSetting" /> can be specified), depends on the <paramref name="kInfoType" /> constant and is documented in the Constants section below.<br/>
    </param>
    <returns>
      If <paramref name="uNewSetting" /> is not specified, RDDInfo() returns the current setting.<br/>
      If <paramref name="uNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      <include file="RTComments.xml" path="Comments/DBI_Constants/*"  />
    </remarks>
    <example>
      The following examples return work area information:
      <code language="X#">
        ? DBInfo(DBI_GETHEADERSIZE)&#0009;// Same as Header()
        ? DBInfo(DBI_LASTUPDATE)&#0009;&#0009;// Same as LUpdate()
        ? DBInfo(DBI_GETRECSIZE)&#0009;&#0009;// Same as RecSize()
        ? DBInfo(DBI_FULLPATH)&#0009;&#0009;// Full path name
      </code>
      The following example will display all RDDs used in the current workarea:
      <code language="X#">
        FUNCTION RddTest()
        &#0009;LOCAL n, i AS INT
        &#0009;LOCAL rddList AS _RDDLIST
        &#0009;USE Demo NEW
        &#0009;rddList := DBInfo(DBI_RDD_LIST)
        &#0009;? "Involved Rdds: ", rddList.uiRddCount
        &#0009;FOR i := 1 UPTO rddList.uiRddCount
        &#0009;&#0009;&#0009;? rddList.atomRddName[I]
        &#0009;NEXT I
        &#0009;MemFree(rddList)
        &#0009;RETURN
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRecordInfo'>DBRecordInfo</seealso>
    <seealso cref='O:VO.DbServer.FieldInfo'>DBServer:FieldInfo</seealso>
    <seealso cref='O:VO.DbServer.Info'>DBServer:Info</seealso>
    <seealso cref='O:VO.DbServer.RecordInfo'>DBServer:RecordInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbInfo'>VODBInfo</seealso>
  </dbinfo>
  <dbjoin>
    <summary>
      Create a new database file by merging records/fields from two work areas.
    </summary>

    <param name="cAlias">
      The alias identifier for the work area to join with.<br/>
      If there is no open database associated with <paramref name="cAlias" />, a runtime error is raised.
    </param>
    <param name="cTargetFile">
      The name of the target database file, including an optional drive, directory, and extension.  See SetDefault() and SetPath() for file searching and creation rules.<br/>
      The default extension for database files is determined by the RDD .<br/>

      &#0009;If <paramref name="cTargetFile" /> does not exist, it is created.<br/>
      If it exists, this function attempts to open the file in exclusive mode and, if successful, the file is overwritten without warning or error.<br/>
      If access is denied because, for example, another process is using the file, NetErr() is set to TRUE.
    </param>
    <param name="acFields">
      The projection of fields from both work areas into the new database file.<br/>
      To specify fields in the secondary work area, reference them with the alias operator (-&gt;).<br/>
      If <paramref name="acFields" /> is not specified, all fields from the source database file are included in the target database file.
    </param>
    <param name="cbForCondition">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/cbfor/*" />
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBJoin() is the functional equivalent of the JOIN command.
    </remarks>
    <example>
      The following example demonstrates DBJoin():
      <code language="X#">
        USE joinme
        IF Used()
        &#0009;DBJoin("test2", "merge.dbf")
        ENDIF
      </code>
    </example>
    <seealso cref='O:VO.DbServer.Join'>DBServer:Join</seealso>
    <seealsocmd>JOIN</seealsocmd>
  </dbjoin>
  <dblocate>
    <summary>
      Search for the first record that matches the specified condition and scope.
    </summary>

    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />

    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      DBLocate() is the functional form of the LOCATE command.
      DBLocate() searches from the beginning record of the scope.<br/>
      It terminates when a match is found or the end of the scope is reached.<br/>
      If it is successful, the matching record becomes the current record and Found() returns TRUE.
      If it is unsuccessful, Found() returns FALSE and the position of the record pointer depends on the scope.
      Each work area can have its own locate condition.
      The condition remains active until you execute another locate condition in that work area or the application terminates.
      DBLocate() works with DBContinue().  Once DBLocate() has been issued, you can resume the search from the current record pointer position with DBContinue().
      There are, however, some exceptions.  Both the scope and <paramref name="cbWhileCondition" /> apply only to the initial DBLocate() function and are not operational for any subsequent DBContinue() functions.<br/>
      To continue a pending locate condition with a scope or <paramref name="cbWhileCondition" />, use DBSkip(); then DBLocate() with the <paramref name="lRest" /> and <paramref name="cbWhileCondition" /> arguments instead of DBContinue().
    </remarks>
    <example>
      This example sequentially searches for a string:
      <code language="X#">
        PROCEDURE Start()
        &#0009;DBUseArea(TRUE,, "sales")
        &#0009;&#0009;DBLocate({||"Widget" == Sales-&gt;Name},,,-1)
        &#0009;IF Found()
        &#0009;&#0009;QOut("I have a widget.")
        &#0009;ELSE
        &#0009;&#0009;QOut("Not found.")
        &#0009;ENDIF
        &#0009;RETURN
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbContinue'>DBContinue</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealso cref='O:VO.DbServer.Locate'>DBServer:Locate</seealso>
    <seealsocmd>LOCATE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbLocate'>VODBLocate</seealso>
  </dblocate>
  <dbmemoext>
    <summary>This returns the memo extension of the file in the current workarea. For example DBT or FPT.</summary>
    <returns>The memo extension of the file (if any). When no file is open than the default memo extension for the default RDD is returned.</returns>
  </dbmemoext>
  <dbmemofield>
    <summary>
      Return the memo field pointer of a DBF record.
    </summary>

    <param name="uField">
      The name, number, or symbol representing the desired memo field.<br/>
      If omitted, defaults to the first memo field in the database, if any.
    </param>
    <returns>
      The contents of the specified memo field within the DBF record, if successful; otherwise, NIL.
    </returns>
    <remarks>
      DBMemoField() returns the 10-byte value of a memo field within the DBF.<br/>
      This value can be used for special purposes, because it's actually a pointer (or offset) of the appropriate memo block within the associated memo file.
    </remarks>
    <example>
      The following example demonstrates the DBMemoField() function:
      <code language="X#">
        FUNC TestMField
        &#0009;LOCAL n         AS INT
        &#0009;LOCAL cMemoOffs AS STRING
        &#0009;USE demo1 VIA "DBFCDX"
        &#0009;n := FieldPos("comment")
        &#0009;DO WHILE !EOF()
        &#0009;cMemoOffs := DBMemoField(n)
        &#0009;? RECNO(), cMemoOffs
        &#0009;SKIP
        &#0009;ENDDO
        &#0009;CLOSE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
  </dbmemofield>
  <dborderinfo>
    <summary>
      Return and optionally change information about orders and index files.
    </summary>

    <param name="kInfoType">
      Specifies the type of information.<br/>
      The constants are listed below.  Note, however, that not all constants are supported for all RDDs.<br/>

      &#0009;Important!  DBOI_USER is a constant that returns the minimum value that third-party RDD developers can use for defining new <paramref name="kInfoType" /> parameters.  Values less than DBOI_USER are reserved for Computer Associates development.
    </param>
    <param name="cIndexFile">
      The name of an index file, including an optional drive and directory (no extension should be specified).<br/>
      Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.<br/>

      &#0009;If <paramref name="cIndexFile" /> is not open by the current process, a runtime error is raised.
    </param>
    <param name="uOrder">
      The name of the order about which you want to obtain information or a number representing its position in the order list.  (For single-order index files, the order name is the eight-letter index file name.)<br/>
      Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.  Invalid values are ignored.<br/>

      &#0009;If no index file or order is specified, the controlling order is assumed.
    </param>
    <param name="uNewSetting">
      If specified, this parameter is used to change the value of a setting.<br/>
      The data type (and whether <paramref name="uNewSetting" /> can be specified), depends on the <paramref name="kInfoType" /> constant and is documented in the Constants section below.<br/>
    </param>
    <returns>
      If <paramref name="uNewSetting" /> is not specified, DBOrderInfo() returns the current setting.<br/>
      If <paramref name="uNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      <include file="RTComments.xml" path="Comments/DBOI_Constants/*"  />
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example uses DBOI_NAME to save the current controlling order.<br/>
      After changing to a new controlling order, it uses the saved value to restore the original order:
      <code language="X#">
        USE customer INDEX name, serial NEW
        cOrder := DBOrderInfo(DBOI_NAME)&#0009;&#0009;// name
        Customer-&gt;DBSetOrder("serial")
        ? DBOrderInfo(DBOI_NAME)&#0009;&#0009;&#0009;// serial
        Customer-&gt;DBSetOrder(cOrder)
        ? DBOrderInfo(DBOI_NAME)&#0009;&#0009;&#0009;// name
      </code>
      This example uses aliased expressions to return the default index file extension (using DBOI_INDEXEXT) in two different work areas:
      <code language="X#">
        USE sales INDEX all_sales VIA "DBFCDX" NEW
        USE customer INDEX name, serial VIA "DBFNTX" NEW
        ? Sales-&gt;DBOrderInfo(DBOI_INDEXEXT)&#0009;// .CDX
        ? Customer-&gt;DBOrderInfo(DBOI_INDEXEXT)&#0009;// .NTX
      </code>
      In this example, DBOrderInfo(DBOI_INDEXEXT) checks for the existence of the CUSTOMER index file independent of the RDD linked into the current work area:
      <code language="X#">
        USE customer NEW
        IF !File("customer" + DBOrderInfo(DBOI_INDEXEXT))
        &#0009;Customer-&gt;DBCreateIndex("customer", "CustName",;
        &#0009;&#0009;{|| Customer-&gt;CustName})
        ENDIF
      </code>
      This example accesses the key expression of several orders from the same index file:
      <code language="X#">
        USE customer INDEX all_cust VIA "DBFMDX" NEW
        Customer-&gt;DBSetOrder("serial")
        ? DBOrderInfo(DBOI_EXPRESSION,, "name")
        // Result: key expression for name order
        ? DBOrderInfo(DBOI_EXPRESSION,, "serial")
        // Result: key expression for serial order
      </code>
      This example uses DBOrderInfo() as part of a TOTAL ON key expression.  Since DBOrderInfo() returns the expression as a string, it is specified using a macro expression to force evaluation of the key expression:
      <code language="X#">
        USE sales INDEX salesman NEW
        TOTAL ON &amp;(DBOrderInfo(DBOI_EXPRESSION)) ;
        &#0009;FIELDS SaleAmount TO summary
      </code>
      In this example, ALL_CUST.MDX contains three orders named CUACCT, CUNAME, CUZIP.<br/>
      The DBOI_INDEXNAME constant is used to display the name of the index file using one of its orders:
      <code language="X#">
        USE customer VIA "DBFNTX" NEW
        Customer-&gt;DBSetIndex("all_cust")
        ? DBOrderInfo(DBOI_INDEXNAME,, "cuname")
        // Returns: all_cust
      </code>
      The following example searches for CUNAME in the order list:
      <code language="X#">
        USE customer VIA "DBFNTX" NEW
        Customer-&gt;DBSetIndex("cuacct")
        Customer-&gt;DBSetIndex("cuname")
        Customer-&gt;DBSetIndex("cuzip")
        ? DBOrderInfo(DBOI_NUMBER,, "cuname")&#0009;// 2
      </code>
      This example retrieves the "for condition" from an order:
      <code language="X#">
        USE customer NEW
        INDEX ON Customer-&gt;Acct TO customer ;
        &#0009;FOR Customer-&gt;Acct &gt; "AZZZZZ"
        ? DBOrderInfo(DBOI_CONDITION,, "customer")
        // Returns: Customer-&gt;Acct &gt; "AZZZZZ"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRecordInfo'>DBRecordInfo</seealso>
    <seealso cref='O:VO.DbServer.FieldInfo'>DBServer:FieldInfo</seealso>
    <seealso cref='O:VO.DbServer.Info'>DBServer:Info</seealso>
    <seealso cref='O:VO.DbServer.OrderInfo'>DBServer:OrderInfo</seealso>
    <seealso cref='O:VO.DbServer.RecordInfo'>DBServer:RecordInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddInfo'>RDDInfo</seealso>
  </dborderinfo>
  <dbpack>
    <summary>
      Remove all records marked for deletion from a database file, rebuild all active orders, and recover all physical space occupied by the deleted records.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      This function requires that the current database be open in exclusive mode (see SetExclusive()).<br/>
      If this condition is not met when the function is invoked, a runtime error is raised. <br/>


      Otherwise, the operation proceeds and, upon termination, resets the record pointer to the first logical record in the current work area.
      Warning!  DBPack() does not create backup files.  You may want to make a backup of the file before issuing this function call; otherwise, you will not be able to recover deleted records.
      Tip:  Packing large database files can be a time-consuming process and is, therefore, not recommended in a high-volume transaction application.  By modifying the application design, you can remove the necessity of physically removing records from the database file.  Simply filter the deleted records with SetDeleted(TRUE) or DBSetFilter(!Deleted()) and reuse deleted records instead of adding new ones.
    </remarks>
    <example>
      The following example uses DBPack() with an aliased expression to remove from a file all records that have been marked for deletion:
      <code language="X#">
        Address-&gt;DBPack()
        // Operate on the Address alias
      </code>
    </example>
    <seealso cref='O:VO.DbServer.Pack'>DBServer:Pack</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetExclusive'>SetExclusive</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbDelete'>VODBDelete</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbPack'>VODBPack</seealso>
  </dbpack>
  <dbrecall>
    <summary>
      Restore the current record if it has been marked for deletion.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      DBRecall() performs the same function as the RECALL command.<br/>
      For more information, refer to the DELETE and RECALL commands.
      <note type="tip">
        Logical records:&#0009;Reinstating a deleted record affects the record's logical visibility if SetDeleted() is TRUE.<br/>
        For more information, refer to the DBDelete() function and the DELETE and RECALL commands.
        Shared mode:&#0009;For a shared database, DBRecall() requires the current record to be locked.
      </note>
    </remarks>
    <example>
      The following example recalls a record if it is deleted and attempts to lock the record if successful:
      <code language="X#">
        cLast := "Winston"
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", TRUE)
        Sales-&gt;DBSetIndex("LastName")
        IF Sales-&gt;DBSeek(cLast)
        &#0009;IF Sales-&gt;Deleted()
        &#0009;&#0009;IF Sales-&gt;RLock()
        &#0009;&#0009;&#0009;Sales-&gt;DBRecall()
        &#0009;&#0009;&#0009;QOut("Record recalled")
        &#0009;&#0009;ELSE
        &#0009;&#0009;&#0009;QOut("Unable to lock record...")
        &#0009;&#0009;ENDIF
        &#0009;ENDIF
        ELSE
        &#0009;QOut("Not found")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDelete'>DBDelete</seealso>
    <seealso cref='O:VO.DbServer.Recall'>DBServer:Recall</seealso>
    <seealsocmd>DELETE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.Deleted'>Deleted</seealso>
    <seealsocmd>RECALL</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbRecall'>VODBRecall</seealso>
  </dbrecall>
  <dbrecordinfo>
    <summary>
      Retrieve field definition information about a record.
    </summary>

    <param name="kInfoType">
      Determines what type of information is retrieved.<br/>
      The constants are listed below.
    </param>
    <param name="uRecID">
      The ID of the record that you want information on.<br/>
      If omitted, the current record is reported on.
    </param>
    <param name="uNewValue">This parameter is reserved for RDDs that allow you to change the information rather than just retrieve it.  None of the supplied RDDs support this argument.  Either omit the argument or specify it as NIL.</param>
    <returns>
    </returns>
    <remarks>
      <include file="RTComments.xml" path="Comments/DBRI_Constants/*"  />
    </remarks>

    <example>
      The following examples retrieve record information:
      <code language="X#">
        DBRecordInfo(DBRI_RECSIZE)
        // Same as RecSize()
        DBRecordInfo(DBRI_LOCKED, 200)
        // Is record 200 locked?
        DBRecordInfo(DBRI_DELETED, 201)
        // Is record 201 deleted?
        DBRecordInfo(DBRI_FORCEREFRESH)
        // Reread the current record into the buffer
        DBRecordInfo(DBRI_RECNO, 230)
        // On which position is record 230?
        // If no orders are active, the position is 230,
        // otherwise the relative position within the
        // order will be returned.
        DBRecordInfo(DBRI_BUFFPTR)
        // Return pointer to current record in the buffer
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddInfo'>RDDInfo</seealso>
  </dbrecordinfo>
  <dbreindex>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <summary>
      Rebuild all orders in the order list of a work area.
    </summary>
    <returns>
      TRUE if successful; otherwise FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      All orders are rebuilt, respecting uniqueness and descending order flags and the for condition specified when the order was created.<br/>
      After the orders are rebuilt, the work area is positioned to the first logical record in the controlling order.
      Although this operation will work in both shared and exclusive mode, exclusive mode is highly recommended.  See SetExclusive() for more information.
      Caution!  DBReindex() does not recreate the header of the index file when it recreates the order.  Because of this, DBReindex() does not help if there is corruption of the file header.<br/>
      To guarantee a valid index, always use DBCreateIndex() in place of DBReindex() to rebuild damaged index files
    </remarks>
    <example>
      This example issues a DBReindex() if a particular record is not found:
      <code language="X#">
        DBUseArea(TRUE,, "Address")
        DBGoBottom()
        DBUseArea(TRUE,, "customer",, FALSE)
        &#0009;//Opens the file exclusively
        DBSetIndex("CustID")
        DBSeek(Address-&gt;Cust_ID)
        IF !Found()
        &#0009;? "Referential integrity failure:"
        &#0009;? "The last Address record was not found in the"
        &#0009;? "Customer index file. Index is not up-to-date"
        &#0009;? "or the record is missing.  Reindexing ..."
        &#0009;IF !DBReindex()
        &#0009;&#0009;? "Reindexing failed"
        &#0009;&#0009;DBCloseAll()
        &#0009;&#0009;QUIT
        &#0009;ENDIF
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
    <seealso cref='O:VO.DbServer.CreateOrder'>DBServer:CreateOrder</seealso>
    <seealso cref='O:VO.DbServer.Reindex'>DBServer:Reindex</seealso>
    <seealso cref='O:VO.DbServer.SetIndex'>DBServer:SetIndex DBServer:SetOrderCondition</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrderCondition'>DBSetOrderCondition</seealso>
    <seealsocmd>REINDEX</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetExclusive'>SetExclusive</seealso>
    <seealsocmd>USE</seealsocmd>
  </dbreindex>
  <dbrelation>
    <summary>
      Return the linking expression of a specified relation.
    </summary>

    <param name="nRelation">
      The position of the desired relation in the list of current work area relations.<br/>
      The relations are numbered according to the order in which they were defined by relation setting.
    </param>
    <returns>
      The linking expression defined to <paramref name="nRelation" />.<br/>
      If there is no relation set for <paramref name="nRelation" />, DBRelation() returns a NULL_STRING.
    </returns>
    <remarks>
      DBRelation() is a database function to determine the linking expression and work area of an existing relation.
      DBRelation() returns the linking expression defined by the TO clause.  DBRSelect() returns the work area linked as defined by the INTO clause.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      <note type="tip">
        Declared variables:&#0009;A string returned by DBRelation() cannot operate correctly when recompiled and executed using the macro operator (&amp;) if the original expression contained references to local or static variables, or otherwise depends on compile-time declarations.
      </note>
    </remarks>
    <example>
      This example opens three database files, sets two child relations from the parent work area, and then displays the linking expression to the second child work area:
      <code language="X#">
        USE invoices INDEX invoices NEW
        USE backorder INDEX backorder NEW
        USE customer INDEX customer NEW
        SET RELATION TO custnum INTO invoices, OrderNum ;
        &#0009;&#0009;INTO backorder
        QOut(DBRelation(2))&#0009;&#0009;&#0009;&#0009;// Result: Ordernum
      </code>
      Later you can query the same linking expression from an unselected work area by using an aliased expression like this:
      <code language="X#">
        USE archive NEW
        QOut(Customer-&gt;DBRelation(2))
        // Result: OrderNum
      </code>
      This example is a function, Relation(), that returns the results of both DBRelation() and DBRSelect() as an array:
      <code language="X#">
        FUNCTION Relation(nRelation)
        &#0009;RETURN {;
        &#0009;&#0009;&#0009;&#0009;DBRelation(nRelation), ;
        &#0009;&#0009;&#0009;&#0009;Alias(DBRSelect(nRelation)) ;
        &#0009;&#0009;&#0009;}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFilter'>DBFilter</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRSelect'>DBRSelect</seealso>
    <seealso cref='O:VO.DbServer.Relation'>DBServer:Relation</seealso>
    <seealsocmd>SET RELATION</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbRelation'>VODBRelation</seealso>
  </dbrelation>
  <dbrlock>
    <summary>
      Lock a record in a shared database file, optionally retaining previous record locks.
    </summary>

    <param name="uRecId">
      The ID (usually a record number) of the record to be locked.<br/>
      If specified, record locks held by the current process are retained.<br/>
      If not specified, all locks held by the current process are released and the current record is assumed.
    </param>
    <returns>
      TRUE if the record lock is obtained; otherwise, FALSE.<br/>
      An attempt to lock a record in an empty database returns TRUE.
    </returns>
    <remarks>
      If a database file is opened in shared mode, you must obtain a record lock before attempting any operation that writes to the database file.
      For each invocation of DBRLock(), there is one attempt to lock the target record, and the result is returned as a logical value.<br/>
      An attempt to obtain a record lock fails if another process currently has a file lock or record lock on the target record.
      If DBRLock() is successful, the record is locked and other processes are prevented from updating the record until the lock is released.  DBRLock() provides a shared lock, allowing other users read-only access to the locked record while allowing only the current process to modify it.
      A record lock remains in effect until you explicitly unlock it (with DBUnLock(), for example), close the database file, or attempt another file or record lock (with RLock() or DBRLock() with no argument).  DBRLock() when specified with an argument does not release records locks held by the current process.  Instead, it adds the newly locked records to the lock list (see DBRLockList()).
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      This feature is useful since DBRLock() does not automatically attempt a record lock for related files.
    </remarks>
    <example>
      This example deletes a record from a shared database file DBRLock():
      <code language="X#">
        USE customer INDEX custname SHARED NEW
        SEEK "Smith"
        IF Found()
        &#0009;IF Customer-&gt;DBRLock()
        &#0009;&#0009;DELETE
        &#0009;&#0009;QOut("Smith deleted")
        &#0009;ELSE
        &#0009;&#0009;QOut("Record in use by another")
        &#0009;ENDIF
        ELSE
        &#0009;QOut("Smith not in customer file")
        ENDIF
        CLOSE
      </code>
      This example specifies DBRLock() as an aliased expression to lock a record in an unselected work area:
      <code language="X#">
        USE sales SHARED NEW
        USE customer SHARED NEW
        IF !Sales-&gt;DBRLock()
        &#0009;QOut("The current sales record is in use")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLockList'>DBRLockList</seealso>
    <seealso cref='O:VO.DbServer.LockCurrentRecord'>DBServer:LockCurrentRecord</seealso>
    <seealso cref='O:VO.DbServer.LockSelection'>DBServer:LockSelection</seealso>
    <seealso cref='P:VO.DbServer.RLockList'>DBServer:RLockList</seealso>
    <seealso cref='O:VO.DbServer.RLockVerify'>DBServer:RLockVerify</seealso>
    <seealso cref='O:VO.DbServer.UnLock'>DBServer:UnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLock'>DBUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUseArea'>DBUseArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.Flock'>FLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.RLock'>RLock</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetExclusive'>SetExclusive</seealso>
    <seealsocmd>UNLOCK</seealsocmd>
    <seealsocmd>USE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbRlock'>VODBRLock</seealso>
  </dbrlock>
  <dbrlocklist>
    <summary>
      Get a list of locked records.
    </summary>
    <returns>
      An array with the numbers of the currently locked records.
    </returns>
    <remarks>
      DBRLock() can be used to obtain multiple record locks in a single work area.<br/>
      This function returns the numbers of all locked records in an array.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      The following example shows all currently locked records:
      <code language="X#">
        aRecs := DBRLockList()
        n := ALen(aRecs)
        ? "Locked records: ", n
        ?
        FOR i := 1 UPTO n
        &#0009;? "Locked record ", aRecs[i]
        NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:VO.DbServer.LockCurrentRecord'>DBServer:LockCurrentRecord</seealso>
    <seealso cref='O:VO.DbServer.LockSelection'>DBServer:LockSelection</seealso>
    <seealso cref='P:VO.DbServer.RLockList'>DBServer:RLockList</seealso>
    <seealso cref='O:VO.DbServer.RLockVerify'>DBServer:RLockVerify</seealso>
    <seealso cref='O:VO.DbServer.UnLock'>DBServer:UnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.RecNo'>RecNo</seealso>
  </dbrlocklist>
  <dbrselect>
    <summary>
      Return the work area number of a relation.
    </summary>

    <param name="nRelation">
      The position of the desired relation in the list of work area relations.<br/>
      The relations are numbered according to the order in which they were defined by relation setting.
    </param>
    <returns>
      The work area number of the specified relation.<br/>
      If there is no relation set for <paramref name="nRelation" />, DBRSelect() returns 0.
    </returns>
    <remarks>
      DBRSelect() is a database function used in combination with DBRelation() to determine the work area and linking expression of an existing relation.  DBRSelect() returns the work area defined by the INTO clause.  DBRelation() returns the linking expression defined by the TO clause.<br/>
      To determine the alias of the relation instead of the work area number, use the expression Alias(DBRSelect(<paramref name="nRelation" />)).
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example opens three database files, sets two child relations from the parent work area, then displays the linking expression to the second child work area as well as the target work area of the relation:
      <code language="X#">
        USE invoices INDEX invoices NEW
        USE backorder INDEX backorder NEW
        USE customer INDEX customer NEW
        SET RELATION TO custnum INTO customer, ;
        &#0009;&#0009;Ordernum INTO Backorder
        QOut(DBRelation(2), DBRSelect(2))
        // Result: Ordernum 3
        QOut(Alias(DBRSelect(2))
        // Result: BackOrder
      </code>
      Later you can query the same information from an unselected work area by using an aliased expression:
      <code language="X#">
        USE archive NEW
        QOut(Customer-&gt;DBRelation(2))
        // Result: Ordernum
        QOut(Customer-&gt;DBRSelect(2))
        // Result: 3
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFilter'>DBFilter</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRelation'>DBRelation</seealso>
    <seealsocmd>SET RELATION</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbRSelect'>VODBRSelect</seealso>
  </dbrselect>
  <dbrunlock>
    <summary>
      Release all or specified record locks.
    </summary>

    <param name="uRecID">
      A unique value guaranteed by the structure of the data file to reference a specific item in a data source (database).  In a database file, <paramref name="uRecID" /> is the record number.  In other data formats, <paramref name="uRecID" /> is the unique primary key value.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBRUnLock() releases the lock on <paramref name="uRecID" /> and removes it from the lock list.<br/>
      If <paramref name="uRecID" /> is not specified, all record locks are released.
    </remarks>
    <example>
      The following example unlocks a range of records:
      <code language="X#">
        PROCEDURE dbRUnLockRange(nLo AS SHORTINT, nHi AS SHORTINT)
        &#0009;LOCAL nCounter
        &#0009;// UnLock the records in the range from nLo to nHi
        &#0009;FOR nCounter := nLo UPTO nHi
        &#0009;&#0009;DBRUnLock(nCounter)
        &#0009;NEXT
        &#0009;RETURN
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRLockList'>DBRLockList</seealso>
    <seealso cref='O:VO.DbServer.RLockVerify'>DBServer:RLockVerify</seealso>
    <seealso cref='O:VO.DbServer.UnLock'>DBServer:UnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.RLock'>RLock</seealso>
  </dbrunlock>
  <dbseek>
    <summary>
      Move to the record having the specified key value in the controlling order.
    </summary>

    <param name="uKey">Specifies the key value associated with the desired record.</param>
    <param name="lSoftSeek">
      Determines how the work area is positioned if the specified key value is not found: TRUE performs a soft seek; FALSE does not.<br/>
      If <paramref name="lSoftSeek" /> is omitted, the current SetSoftSeek() setting is used.
    </param>
    <param name="lLast">
      TRUE seeks the last occurrence of the specified key value.  FALSE, the default, seeks the first occurrence.  <paramref name="lLast" /> only applies to CDX indexes.
    </param>
    <returns>
      TRUE if the specified key value was found; otherwise, FALSE.
    </returns>
    <remarks>
      DBSeek() moves to the first logical record whose key value is equal to <paramref name="uKey" />.<br/>
      If such a record is found, it becomes the current record and DBSeek() returns TRUE.<br/>
      Otherwise, DBSeek() returns FALSE and the positioning of the work area is as follows: for a normal (not soft) seek, the work area is positioned to LastRec() + 1 and EOF() returns TRUE; for a soft seek, the work area is positioned to the first record whose key value is greater than the specified key value.<br/>
      If no such record exists, the work area is positioned to LastRec() + 1 and EOF() returns TRUE.
      For a work area with no controlling order, DBSeek() has no effect.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      DBSeek() performs the same function as the SEEK command.<br/>
      For more information, refer to the SEEK command.
      <note type="tip">
        Logical records:&#0009;DBSeek() operates on logical records.  Records are processed in controlling order.<br/>
        If a filter is set, only records which meet the filter condition are considered.
        Shared mode:&#0009;For a shared file, moving to a different record can cause updates to the current record to become visible to other processes.
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbGoBottom'>DBGoBottom</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoTop'>DBGoTop</seealso>
    <seealso cref='O:VO.DbServer.Seek'>DBServer:Seek</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSkip'>DBSkip</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.Found'>Found</seealso>
    <seealsocmd>SEEK</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetSoftSeek'>SetSoftSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbSeek'>VODBSeek</seealso>
  </dbseek>
  <dbselect>
    <summary>
      Select a new work area and retrieve the current work area.
    </summary>

    <param name="nNew">The work area number for the new work area.</param>
    <returns>
      The work area number for the old work area.
    </returns>
    <remarks>
      DBSelect() allows you to change the current work area and also retrieve the number of the current work area.<br/>
      This is useful in a group programming project or when writing black-box general routines: each time a module changes the environment by selecting a new work area, you must save and restore the old environment.
    </remarks>
    <example>
      The following example sets a new work area and stores the number of the current work area:
      <code language="X#">
        nOld := 0
        nNew : = 10
        nOld := DBSelect(nNew)
        ...
        // Restore the old work area
        DBSelect(nOld)
        ? "New work area            :", Select()
        ? "Workarea selected before :", nOld
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.VoDbSelect'>VODBSelect</seealso>
  </dbselect>
  <dbselectarea>
    <summary>
      Change the current work area.
    </summary>

    <param name="uArea">A number that specifies the work area to be selected. or the alias of the work area to be selected.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBSelectArea() causes the specified work area to become the current work area.<br/>
      All subsequent database operations will apply to this work area unless another work area is explicitly specified for an operation.
      DBSelectArea() performs the same function as the SELECT command.<br/>
      For more information, refer to the SELECT command.
      <note type="tip">
        Selecting 0:&#0009;Selecting work area 0 causes the lowest numbered unoccupied work area to become the current work area.
        Aliased expressions:&#0009;The alias operator (-&gt;) can temporarily select a work area while an expression is evaluated and automatically restore the previously selected work area afterward.
      </note>
    </remarks>
    <example>
      The following example selects a work area via the alias name:
      <code language="X#">
        cLast := "Winston"
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", TRUE)
        Sales-&gt;DBSetIndex("salefnam")
        Sales-&gt;DBSetIndex("salelnam")
        DBUseArea(TRUE, "DBFNTX", "colls", "Colls", TRUE)
        Colls-&gt;DBSetIndex("collfnam")
        Colls-&gt;DBSetIndex("colllnam")
        DBSelectArea("Sales")&#0009;&#0009;// Select Sales workarea
        DBSelectArea("Colls")&#0009;&#0009;// Select Colls workarea
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbUseArea'>DBUseArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>SELECT</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
    <seealsocmd>USE</seealsocmd>
  </dbselectarea>
  <dbsetdriver>
    <summary>
      Return and optionally change the default RDD driver for the application.
      Note:  DBSetDriver() is a compatibility function and is no longer recommended.<br/>
      It is superseded by the RDDSetDefault() function.  See RDDSetDefault() for more information.
    </summary>

    <param name="cNewSetting">
      The name of the RDD that will be used to activate and manage applications when no driver is explicitly specified.<br/>
      If this RDD is not available to the application, the call has no effect.
    </param>
    <returns>
      If <paramref name="cNewSetting" /> is not specified, DBSetDriver() returns the current default RDD.<br/>
      If <paramref name="cNewSetting" /> is specified, the previous default RDD is returned.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example makes the DBFMDX driver the default RDD.<br/>
      If the RDD is unavailable, a message is issued:
      <code language="X#">
        DBSetDriver("DBFMDX")
        IF DBSetDriver() != "DBFMDX"
        &#0009;QOut("DBFMDX driver not available")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
  </dbsetdriver>
  <dbsetfilter>
    <summary>
      Set a filter condition.
    </summary>

    <param name="cbCondition">A code block that expresses the filter condition in executable form.</param>
    <param name="cCondition">
      An optional character value that expresses the filter condition in textual form.<br/>
      If <paramref name="cCondition" /> is omitted, the DBFilter() function will return an empty string for the work area.
    </param>
    <returns>
      TRUE if the current record meets the filter condition; otherwise, FALSE.
    </returns>
    <remarks>
      DBSetFilter() sets a logical filter condition.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      When a filter is set, records which do not meet the filter condition are not logically visible. <br/>
      That is, database operations which act on logical records will not consider these records.
      The filter expression can be a code block (<paramref name="bCondition" />) or both a code block and equivalent text (<paramref name="cCondition" />).<br/>
      If both versions are supplied, they must express the same condition.<br/>
      DBSetFilter() performs the same function as the SET FILTER command.<br/>
      For more information, refer to the SET FILTER command.
      <note type="tip">
        If the RDD you are using supports optimization, use SET OPTIMIZE to control whether the RDD will
        optimize the filter search based on the available orders in the work area.
      </note>
      <note type="tip">
        <b>Logical records: </b><br/>
        DBSetFilter() affects the logical visibility of records (see above).
        <br/><b>Side effects:</b><br/>Setting a filter condition is only guaranteed to restrict visibility of certain records as described above.<br/>
        The filter expression is not necessarily evaluated at any particular time, by any particular means, or on any particular record or series of records.<br/>
        If the filter expression relies on information external to the database file or work area, the effect is unpredictable.<br/>
        If the filter expression changes the state of the work area (for example, by moving to a different record or changing the contents of a record), the effect is unpredictable.
        <br/><b>Evaluation context:</b><br/>
        When the filter expression is evaluated, the associated work area is automatically selected as the current work area before the evaluation; the previously selected work area is automatically restored afterward.
      </note>
    </remarks>
    <example>
      This example limits data access to records in which the Age field value is less than 40:
      <code language="X#">
        USE employee NEW
        DBSetFilter({|| Age &lt; 40}, "Age &lt; 40")
        DBGoTop()
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearFilter'>DBClearFilter</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbFilter'>DBFilter</seealso>
    <seealso cref='O:VO.DbServer.SetFilter'>DBServer:SetFilter</seealso>
    <seealsocmd>SET FILTER</seealsocmd>
    <seealsocmd>SET OPTIMIZE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbSetFilter'>VODBSetFilter</seealso>
  </dbsetfilter>
  <dbsetfound>
    <summary>
      Set the found flag.
    </summary>

    <param name="lFnd">The new setting for the found flag: TRUE or FALSE</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      The found flag is set after database search functions, such as DBSeek() or DBLocate().  In a group programming project or when writing black-box general routines, you do not want modules to have any side effects.  DBSetFound() gives you more control over a global environmental setting.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example sets the found flag to true:
      <code language="X#">
        USE employee NEW
        DBSetFilter({|| Age &lt; 40}, "Age &lt; 40")
        DBSetFound(TRUE)
        DBGoTop()
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbLocate'>DBLocate</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealso cref='O:VO.DbServer.Locate'>DBServer:Locate</seealso>
    <seealso cref='O:VO.DbServer.Seek'>DBServer:Seek</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbSetFound'>VODBSetFound</seealso>
  </dbsetfound>
  <dbsetindex>
    <summary>
      Open an index file and add all its orders to the order list in a work area.
    </summary>

    <param name="cIndexFile">
      The name of the index files to open, including an optional drive, directory, and extension for each.  See SetDefault() and SetPath() for file searching and creation rules.<br/>
      The default extension is determined by the RDD and can be obtained using DBOrderInfo(DBOI_INDEXEXT).<br/>

      If <paramref name="cIndexFile" /> does not exist, a runtime error is raised.<br/>
      If it exists, this function attempts to open the file in the same mode as the corresponding database file.<br/>
      If access is denied because, for example, another process is using the file and this one is asking for exclusive use, NetErr() is set to TRUE.<br/>
      Otherwise, the file open is successful.<br/>

      <b>Concurrency conflicts </b> with index files are rare since they should be used with only one database file.<br/>
      If a concurrency problem arises, it will normally be when you attempt to open the database file.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      If the order list for the work area is empty when DBSetIndex() is issued, the first order in the index file becomes the controlling order.<br/>
      If there are orders already associated with the work area, they are unaffected — the new orders are simply added to the current order list.<br/>
      After the new index file is opened (using the same open mode as its associated database file), the work area is positioned to the first logical record in the controlling order.
      Opening an index file imposes a logical order (defined by the controlling order) on the records in a database file and may also filter the records according to a for condition or a unique flag.<br/>
      This means that when you process the database file, the records will appear in the order determined by the controlling order and filtered records, although still physically present in the database file, will be inaccessible.
      <note type="tip">
        Except for production index files supported by some RDDs, index files are not opened automatically when you open the corresponding database file.<br/>
        To ensure that index files are accurately maintained, you should either open them prior to making any updates to their corresponding database files or rebuild them at a later time with DBReindex().
      </note>
    </remarks>
    <example>
      The following example opens multiple index files:
      <code language="X#">
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", TRUE)
        Sales-&gt;DBSetIndex("FirstName")
        Sales-&gt;DBSetIndex("LastName")
        IF Sales-&gt;DBSeek(cLast)
        &#0009;IF Sales-&gt;Deleted() .AND. Sales-&gt;RLock()
        &#0009;&#0009;Sales-&gt;DBRecall()
        &#0009;&#0009;QOut("Deleted record has been recalled.")
        &#0009;ENDIF
        ELSE
        &#0009;QOut("Not found")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearIndex'>DBClearIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbReindex'>DBReindex</seealso>
    <seealso cref='O:VO.DbServer.CreateIndex'>DBServer:CreateIndex</seealso>
    <seealso cref='O:VO.DbServer.CreateOrder'>DBServer:CreateOrder</seealso>
    <seealso cref='O:VO.DbServer.OrderInfo'>DBServer:OrderInfo</seealso>
    <seealso cref='O:VO.DbServer.Reindex'>DBServer:Reindex</seealso>
    <seealso cref='O:VO.DbServer.SetOrder'>DBServer:SetOrder</seealso>
    <seealso cref='O:VO.DbServer.SetIndex'>DBServer:SetIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrder'>DBSetOrder</seealso>
    <seealso cref='O:XSharp.Core.Functions.NetErr'>NetErr</seealso>
    <seealsocmd>SET INDEX</seealsocmd>
    <seealsocmd>USE</seealsocmd>
  </dbsetindex>
  <dbsetorder>
    <summary>
      Set the controlling order for a work area.
    </summary>

    <param name="uOrder">
      The name of the new controlling order or a number representing its position in the order list.<br/>
      Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.  Specifying a value of 0 has the special effect of returning the database file to its natural order.  Specifying an invalid value will raise a runtime error.
    </param>
    <param name="cIndexFile">
      The name of an index file, including an optional drive and directory (no extension should be specified).<br/>
      Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.<br/>
      If <paramref name="cIndexFile" /> is not open by the current process, a runtime error is raised.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBSetOrder() controls which of the orders in a work area's order list is the controlling order.<br/>
      The controlling order is the one that determines the logical order of records in the work area.  Before using this function, use DBSetIndex() to add orders from an index file to the order list.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example sets the second named order, AGE, as the controlling order:
      <code language="X#">
        USE employee NEW
        Employee-&gt;DBSetIndex("name")
        Employee-&gt;DBSetIndex("age")
        DBSetOrder("age")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearIndex'>DBClearIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbReindex'>DBReindex</seealso>
    <seealso cref='O:VO.DbServer.CreateIndex'>DBServer:CreateIndex</seealso>
    <seealso cref='O:VO.DbServer.CreateOrder'>DBServer:CreateOrder</seealso>
    <seealso cref='O:VO.DbServer.Reindex'>DBServer:Reindex</seealso>
    <seealso cref='O:VO.DbServer.SetIndex'>DBServer:SetIndex</seealso>
    <seealso cref='O:VO.DbServer.SetOrder'>DBServer:SetOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
    <seealsocmd>SET ORDER</seealsocmd>
  </dbsetorder>
  <dbsetordercondition>
    <summary>
      Set the condition and scope to use in creating the next order.
    </summary>

    <param name="cForCondition">
      A string that specifies the for condition for the order.<br/>
      This string is returned by DBOrderInfo(DBOI_CONDITION, [<paramref name="cIndexFile" />], <paramref name="cOrder" />).<br/>
      If you do not need this information, you can specify a NULL_STRING.
    </param>
    <param name="cbForCondition">
      A code block that defines a condition (called the for condition) that each record within the scope must meet in order to be processed.<br/>
      If a record does not meet the specified condition, it is ignored and the next record is processed.  Duplicate key values are not added to the index file when a for condition is used.<br/>
      The default is NIL.<br/>

      &#0009;This condition (not <paramref name="cForCondition" />) is the one that is actually used to create the order.<br/>
      Unlike the while condition and other scoping information, the for condition is stored as part of the index file and is used when updating or rebuilding the order with DBReindex().<br/>
      Any limitations on the for condition are determined by the RDD.
    </param>
    <param name="lAll">
      A value of TRUE specifies a scope of all records.<br/>
      Use FALSE if you want to indicate other record scoping conditions (that is, <paramref name="nNext" />, <paramref name="nRecord" />, or <paramref name="lRest" />).<br/>
      The default is FALSE.
    </param>
    <param name="cbWhileCondition">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/cbwhile/*" /><br/>

      The while condition is used only to create the order.<br/>
      It is not stored in the index file and not used for updating or reindexing purposes.<br/>
      The default is NIL.
    </param>
    <param name="cbEval">
      A code block that is evaluated at intervals specified by <paramref name="nInterval" />.<br/>
      This is useful in producing a status bar or odometer that monitors the ordering progress.<br/>
      The return value of <paramref name="cbEval" /> must be a logical value.<br/>
      If <paramref name="cbEval" /> returns FALSE, indexing halts.<br/>
      The default is NIL.
    </param>
    <param name="nInterval">
      A numeric expression that determines the number of times <paramref name="cbEval" /> is evaluated.<br/>
      This argument offers a performance enhancement by evaluating the condition at intervals instead of for every record processed.<br/>
      To step through every record, you can specify a value of 0.<br/>
      The default is 0.
    </param>
    <param name="nStart">
      The starting record number.<br/>
      To start at the beginning of the file, specify a value of 0.<br/>
      The default is 0.<br/>

      &#0009;You define the scope using one of these three, mutually exclusive arguments (use 0 or FALSE for the others).<br/>
      The default is all records.  Record scoping information is used only to create the order.<br/>
      It is not stored in the index file and not used for index updates and reindexing purposes.
    </param>
    <param name="nNext">
      The number of records to process, starting at <paramref name="nStart" />.  Specify 0 to ignore this argument.
    </param>
    <param name="nRecord">A single record number to process.  Specify 0 to ignore this argument.</param>
    <param name="lRest">
      TRUE processes only records from <paramref name="nStart" /> to the end of the file.  FALSE processes all records.
    </param>
    <param name="lDescend">
      Specifies whether the keyed pairs be sorted in decreasing or increasing order of value.  TRUE results in descending order.  FALSE results in ascending order.<br/>
      The default is FALSE.
    </param>
    <param name="lAdditive">
      Specifies whether open orders should remain open while the new order is being created.  TRUE specifies that they should remain open.  FALSE specifies that all open order should be closed.<br/>
      The default is FALSE.
    </param>
    <param name="lCurrent">
      Specifies whether only records in the controlling order — and within the current range as specified by OrdSetScope() — will be included in this order.  TRUE specifies that the controlling order and range should be used to limit the scope of the newly created order.  FALSE specifies that all records in the database file are included in the order.<br/>
      The default is FALSE.
    </param>
    <param name="lCustom">
      Specifies whether the new order will be a custom built order (for RDDs that this feature).  TRUE specifies that a custom built order will be created.<br/>
      A custom built order is initially empty, giving you complete control over order maintenance.<br/>
      The system does not automatically add and delete keys from a custom built order.  Instead, you explicitly add and delete keys using OrdKeyAdd() and OrdKeyDel().  FALSE specifies a standard, system-maintained order.<br/>
      The default is FALSE.
    </param>
    <param name="lNoOptimize">
      Specifies whether the FOR condition will be optimized (for RDDs that support this feature).  TRUE optimizes the FOR condition, and FALSE does not.<br/>
      The default is FALSE.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      Unless you specify otherwise with DBSetOrderCondition(), new orders that you create will use default scoping rules, processing all records in the work area.
      DBSetOrderCondition() allows you to specify conditions and scoping rules that records must meet in order to be included in the next order created.
      Creating a new order, then, automatically resets the work area to use the default scoping rules.
      Thus, if scoping is required, you must reset DBSetOrderCondition() each time you create a new order.
      This function is essential if you want to create conditional orders using DBCreateOrder() and DBCreateIndex() because these functions do not support arguments to do this.
    </remarks>
    <example>
      The following example sets the condition for the creation of orders:
      <code language="X#">
        LOCAL cFor AS STRING
        LOCAL lAll, lRest, lDescend AS LOGIC
        LOCAL cbForCondition, cbWhileCondition, cbEval AS USUAL
        LOCAL nStep, nStart, nNext, nRecord AS SHORTINT
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// For condition string format
        cFor := 'Upper(Name) = "MELISSA"'
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Actual for condition
        cbForCondition := {|| Upper(Name) = "MELISSA"}
        lAll := TRUE
        cbWhileCondition := {|| TRUE}&#0009;&#0009;// While all
        cbEval := {|| Name + City}&#0009;&#0009;// Indexing code
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// block
        nStep := 0&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Step through all
        nStart := 0&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// From top
        nNext := 0&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// All
        nRecord := 0&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// All records
        lRest := FALSE&#0009;&#0009;&#0009;&#0009;&#0009;// ALL
        lDescend :=  FALSE&#0009;&#0009;&#0009;&#0009;// Ascending
        DBSetOrderCondition(cFor, cbForCondition, lAll,cbWhileCondition, cbEval, ;
        &#0009; nStep, nStart, nNext, nRecord, lRest, lDescend)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
    <seealso cref='O:VO.DbServer.CreateIndex'>DBServer:CreateIndex</seealso>
    <seealso cref='O:VO.DbServer.CreateOrder'>DBServer:CreateOrder</seealso>
    <seealso cref='O:VO.DbServer.OrderInfo'>DBServer:OrderInfo</seealso>
    <seealso cref='O:VO.DbServer.OrderScope'>DBServer:OrderScope</seealso>
    <seealso cref='O:VO.DbServer.OrderKeyAdd'>DBServer:OrderKeyAdd</seealso>
    <seealso cref='O:VO.DbServer.OrderKeyDel'>DBServer:OrderKeyDel</seealso>
    <seealso cref='O:VO.DbServer.SetOrderCondition'>DBServer:SetOrderCondition</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealsocmd>INDEX</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyAdd'>OrdKeyAdd</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyDel'>OrdKeyDel</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdScope'>OrdScope</seealso>
  </dbsetordercondition>
  <dbsetrelation>
    <summary>
      Relate a specified work area to the current work area.
    </summary>

    <param name="xAlias">The number of the child work area., or the alias of the child work area.</param>
    <param name="cbKey">A code block that expresses the relational expression in executable form.</param>
    <param name="cKey">
      An optional character value that expresses the relational expression in textual form.<br/>
      If <paramref name="cKey" /> is supplied, it must be equivalent to <paramref name="cbKey" />.<br/>
      If <paramref name="cKey" /> is omitted, DBRelation() returns a NULL_STRING for the relation.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBSetRelation() relates the work area specified by <paramref name="nArea" /> or <paramref name="cAlias" /> (the child work area) to the current work area (the parent work area).<br/>
      Any existing relations remain active.
      Relating work areas synchronizes the child work area with the parent work area.<br/>
      This is achieved by automatically repositioning the child work area whenever the parent work area moves to a new record.<br/>
      If there is a controlling order in the child work area, moving the parent work area causes an automatic seek operation in the child work area; the seek key is based on the expression specified by <paramref name="cbKey" /> and/or <paramref name="cKey" />.<br/>
      If the child work area has no controlling order, moving the parent work area causes an automatic "go to" in the child work area; the record number for the "go to" is based on the expression specified by <paramref name="cbKey" /> and/or <paramref name="cKey" />.
      DBSetRelation() performs the same function as the SET RELATION command with the ADDITIVE clause.<br/>
      For more information, refer to the SET RELATION command.
      <note type="tip">
        Side effects:&#0009;DBSetRelation() is only guaranteed to synchronize the work areas as described above.<br/>
        The relational expression is not necessarily evaluated at any particular time, by any particular means, or on any particular record or series of records.<br/>
        If the relational expression relies on information external to the parent work area or its associated database file, the effect is unpredictable.<br/>
        If the expression changes the state of either work area (for example, by moving to a different record or changing the contents of a record), the effect is unpredictable.
        Evaluation context:&#0009;When the relational expression is evaluated, the parent work area is automatically selected as the current work area before the evaluation; the previously selected work area is automatically restored afterward.
        Soft seeking:&#0009;Seek operations that occur as part of relational positioning are never soft seeks.<br/>
        If a relational movement is unsuccessful, the child work area is positioned to LastRec() + 1, its Found() status returns FALSE, and its EOF() status returns TRUE.
      </note>
    </remarks>
    <example>
      This example demonstrates a typical use of the DBSetRelation() function:
      <code language="X#">
        USE employee NEW
        USE department NEW INDEX dept
        SELECT employee
        DBSetRelation("Department", {|| Employee-&gt;Dept}, "Employee-&gt;Dept")
        LIST Employee-&gt;Name, Department-&gt;Name
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearRelation'>DBClearRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRelation'>DBRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRSelect'>DBRSelect</seealso>
    <seealso cref='O:VO.DbServer.ClearRelation'>DBServer:ClearRelation</seealso>
    <seealso cref='O:VO.DbServer.Relation'>DBServer:Relation</seealso>
    <seealso cref='O:VO.DbServer.SetRelation'>DBServer:SetRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.Found'>Found</seealso>
    <seealsocmd>SET RELATION</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbSetRelation'>VODBSetRelation</seealso>
  </dbsetrelation>
  <dbsetrestoreworkarea>
    <summary>
      Control the behavior of the RDD classes with regard to restoring old workareas.
    </summary>

    <param name="lNewSetting">The new setting for workarea restoring</param>
    <returns>
      The old setting for workarea restoring
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='T:VO.DbServer'>DbServer Class</seealso>
  </dbsetrestoreworkarea>
  <dbsetselect>
    <summary>
      Select a new work area.
    </summary>

    <param name="nNewArea">The number of the new work area.</param>
    <returns>
      The newly selected work area.
    </returns>
    <remarks>
    </remarks>
    <example>
      The following example sets a new work area:
      <code language="X#">
        LOCAL nNewArea
        nNewArea := DBSetSelect(9)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbSetSelect'>VODBSetSelect</seealso>
  </dbsetselect>
  <dbskip>
    <summary>
      Move the record pointer relative to the current record.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>

    <param name="nRecords">
      The number of logical records to move, relative to the current record.<br/>
      A positive value means to skip forward, and a negative value means to skip backward.<br/>
      If <paramref name="nRecords" /> is omitted, a value of 1 is assumed.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      Attempting to skip forward beyond the last record positions the work area to LastRec() + 1 and EOF() returns TRUE.<br/>
      Attempting to skip backward beyond the first record positions the work area to the first record and BOF() returns TRUE.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      DBSkip() is the functional equivalent of the SKIP command.<br/>
      For more information, refer to the SKIP command.
      <note type="tip">
        Logical records:&#0009;DBSkip() operates on logical records.<br/>
        If the work area has an active order list, records are considered in controlling order.<br/>
        If a filter is set, only records which meet the filter condition are considered.
        Shared mode:&#0009;For a shared file, moving to a different record can cause updates to the current record to become visible to other processes.
      </note>
    </remarks>
    <example>
      This example demonstrates a typical use of the DBSkip() function:
      <code language="X#">
        DBGoTop()
        DO WHILE (!EOF())
        &#0009;QOut(_FIELD-&gt;Name)
        &#0009;DBSkip()
        ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bof'>BOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoBottom'>DBGoBottom</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoTop'>DBGoTop</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealso cref='O:VO.DbServer.GoBottom'>DBServer:GoBottom</seealso>
    <seealso cref='O:VO.DbServer.GoTop'>DBServer:GoTop</seealso>
    <seealso cref='O:VO.DbServer.Seek'>DBServer:Seek</seealso>
    <seealso cref='O:VO.DbServer.Skip'>DBServer:Skip</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealsocmd>SKIP</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbSkip'>VODBSkip</seealso>
  </dbskip>
  <dbsort>
    <summary>
      Copy records to a database file in sorted order.
    </summary>

    <param name="cTargetFile">
      The name of the target database file to write the sorted records, including an optional drive, directory, and extension.  See SetDefault() and SetPath() for file searching and creation rules.<br/>
      The default extension for database files is determined by the RDD .<br/>

      If <paramref name="cTargetFile" /> does not exist, it is created.<br/>
      If it exists, this function attempts to open the file in exclusive mode and, if successful, the file is overwritten without warning or error.<br/>
      If access is denied because, for example, another process is using the file, NetErr() is set to TRUE.
    </param>
    <param name="acFields">The sort keys, specified as an array of field names.  You may optionally add, after the field name, /A (to sort in dictionary order), /C (to ignore capitalization), or /D (to sort in descending order). The default setting is /A.</param>
    <param name="acOutPutFields">
      A list of fields to copy to <paramref name="cTargetFile" />.<br/>
      The default is all fields
    </param>
    <param name="lNoOpt" >Disable (Rushmore) optimizations (not supported yet).</param>
    <param name="lDesc">Should the default sort order be Descending</param>

    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      DBSort() copies records from the current work area to another database file in sorted order.
      X# sorts character fields in accordance with the ASCII value of each character
      within the string.
      Numeric fields are sorted in numeric order, date fields are sorted chronologically,
      and logical fields are sorted with TRUE as the high value.
      Memo fields cannot be sorted.
      DBSort() performs as much of its operation as possible in memory, then it spools
      to a uniquely named temporary disk file.<br/>
      This temporary file can be as large as the size of the source database file.
      Note also that DBSort() uses up three file handles: the source database file,
      the target database file, and the temporary file.
      If the database is opened in shared mode, you must lock the file to be sorted with FLock().
      DBSort() is the functional equivalent of the SORT command.
      <note type="tip">
        Deleted Source Records: <br/>
        If SetDeleted() is TRUE, VODBSort() copies deleted records to the target database file;
        however, the deleted records do not retain their deleted status.
        No record is marked for deletion in the target file regardless of its status in the source file.<br/>
        If SetDeleted() is FALSE, deleted records are not copied to the target database file.
        Similarly, filtered records are ignored during a sort and are not included in the target
        file.<br/>
      </note>
    </remarks>
    <example>
      The following example sorts a database on two fields (ignoring case) and uses
      it as the current file:
      <code language="X#">
        IF DBSort("sortdb.dbf", {"Last/C", "First/C"})
        &#0009;DBCloseArea()
        &#0009;USE sortdb NEW
        ENDIF
      </code>
    </example>
    <seealso cref='O:VO.DbServer.Sort'>DBServer:Sort</seealso>
    <seealsocmd>SORT</seealsocmd>
  </dbsort>
  <dbstruct>
    <summary>
      Create an array containing the structure of a database file.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>

    <returns>
      The structure of the database file in an array whose length is equal to the number
      of fields in the database file.<br/>
      Each element of the array is a subarray containing information for one field.<br/>
      The subarrays have the following format:
      <include file="RTComments.xml" path="Comments/DbStruct_Constants/*"  />
      If there is no database file in use in the work area, DBStruct() will generate
      a runtime error.
    </returns>
    <remarks>
      DBStruct() operates like COPY STRUCTURE EXTENDED by creating an array of structure
      information rather than a database file of structure information.<br/>
      There is another function, DBCreate(), that can create a database file from
      the structure array.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example opens two database files, then creates an array containing the
      database structure using DBStruct() within an aliased expression.<br/>
      The field attributes are then listed using AEval():
      <code language="X#">
        LOCAL aStruct
        USE customer NEW
        USE invoices NEW
        aStruct := Customer-&gt;DBStruct()
        AEval(aStruct, {|aField|QOut(aField[DBS_NAME]),;
        QOut(aField[DBS_TYPE]), QOut(aField[DBS_LEN]),;
        QOut(aField[DBS_DEC]), QOut(aField[DBS_ALIAS])})
      </code>
    </example>
    <seealsocmd>COPY STRUCTURE EXTENDED</seealsocmd>
    <seealso cref='O:VO.DbServer.CopyStructure'>DBServer:CopyStructure</seealso>
  </dbstruct>
  <dbsymselect>
    <summary>
      Select a new work area by specifying its alias as a symbol.
    </summary>

    <param name="symAlias">The alias of the work area you want to select.</param>
    <returns>
      The number of the new work area selected.
    </returns>
    <remarks>
    </remarks>
    <example>
      The following example selects a new work area:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL symAlias AS SYMBOL
        &#0009;USE test NEW
        &#0009;USE demo NEW
        &#0009;symAlias := SysFindAtom("test")
        &#0009;wSelect := DBSymSelect(symAlias)
        &#0009;? "Selected area: ", wSelect
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.VoDbSymSelect'>VODBSymSelect</seealso>
  </dbsymselect>
  <dbtosb>
    <summary>
      Convert double-byte kana characters in a string to their single-byte equivalents.
    </summary>

    <param name="cMBTarget">The string to convert.</param>
    <returns>
      <paramref name="cMBTarget" /> with the specified characters changed.
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.SBTODB'>SBToDB</seealso>
  </dbtosb>
  <dbtotal>
    <summary>
      Summarize records by key value to a database file.
    </summary>

    <param name="cTargetFile">
      The name of the target database file to write the totaled records, including an optional drive, directory, and extension.  See SetDefault() and SetPath() for file searching and creation rules.<br/>
      The default extension for database files is determined by the RDD .<br/>

      &#0009;If <paramref name="cTargetFile" /> does not exist, it is created.<br/>
      If it exists, this function attempts to open the file in exclusive mode and, if successful, the file is overwritten without warning or error.<br/>
      If access is denied because, for example, another process is using the file, NetErr() is set to TRUE.
    </param>
    <param name="cbKey">A key expression specified as a code block.</param>
    <param name="acFields">The fields to be totaled specified as an array of strings.</param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />

    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      DBTotal() is the functional equivalent of the TOTAL command.
    </remarks>
    <example>
      The following example produces totals for the Salary and Age fields:.
      <code language="X#">
        DBTotal("totals", {||Last}, {"salary", ;
        &#0009;&#0009;&#0009;&#0009;"age"})
      </code>
    </example>
    <seealso cref='O:VO.DbServer.Total'>DBServer:Total</seealso>
    <seealsocmd>TOTAL</seealsocmd>
  </dbtotal>
  <dbtrans>
    <summary>
      Transfer records to an open database file.
    </summary>

    <param name="wTarget">The work area number of the destination file.</param>
    <param name="aStruct">
      An array containing field descriptions in the format returned by DBStruct().<br/>
      This array contains the structure of the source file.
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      DBTrans() copies records from one work area to another open database file.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      <note type="tip">
        Deleted source records:
        &#0009;If SetDeleted() is FALSE, records are copied; however, the deleted records do not retain their deleted status.  No record is marked for deletion in the target file regardless of its status in the source file
        &#0009;If SetDeleted() is TRUE, deleted records are not copied to the target database file.  Similarly, filtered records are ignored during a copy and are not included in the target file.
      </note>
    </remarks>
    <example>
      The following example appends the contents of file TESTFROM.DBF to TESTTO.DBF:
      <code language="X#">
        USE testto
        IF !Used()
        &#0009;? "Error opening TESTTO.DBF"
        ELSE
        &#0009;siTo := VODBGetSelect()
        &#0009;USE testfrom NEW
        &#0009;IF !Used()
        &#0009;&#0009;? "Error opening TESTFROM.DBF"
        &#0009;ELSE
        &#0009;&#0009;siFrom := VODBGetSelect()
        &#0009;&#0009;aStruct := DBStruct()
        &#0009;&#0009;DBTrans(siTo, aStruct)
        &#0009;&#0009;CLOSE
        &#0009;&#0009;DBSetSelect(siTo)
        &#0009;ENDIF
        &#0009;CLOSE
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCopy'>DBCopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbStruct'>DBStructFunction</seealso>
    <seealsocmd>SORT</seealsocmd>
  </dbtrans>
  <dbunlock>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <param name="nRecord">
      The record number of the record to be locked.<br/>
    </param>
    <summary>
      Release all locks or a specified lock for a work area.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBUnLock() releases any record or file locks obtained by the current process for a work area.  DBUnLock() is only meaningful on a shared database.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      <note type="tip">
        Shared mode:&#0009;Releasing locks can cause updates to the database to become visible to other processes.
      </note>
    </remarks>
    <example>
      The following example illustrates a basic use of the DBUnLock() function:
      <code language="X#">
        cLast := "Winston"
        USE sales SHARED NEW VIA "DBFNTX"
        Sales-&gt;DBSetIndex("lastname")
        IF Sales-&gt;DBSeek(cLast)
        &#0009;IF Sales-&gt;RLock()
        &#0009;&#0009;Sales-&gt;DBDelete()
        &#0009;&#0009;QOut("Record deleted: ", Sales-&gt;Deleted())
        &#0009;&#0009;Sales-&gt;DBUnLock()
        &#0009;ELSE
        &#0009;&#0009;QOut("Unable to lock record...")
        &#0009;ENDIF
        ELSE
        &#0009;QOut("Not found")
        ENDIF
      </code>
    </example>
    <seealso cref='O:VO.DbServer.UnLock'>DBServer:UnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLockAll'>DbUnLockAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.Flock'>FLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.RLock'>RLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbUnLock'>VODBUnLock</seealso>
  </dbunlock>
  <dbunlockall>
    <summary>
      Release all locks for all work areas.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DbUnLockAll() releases any record or file locks obtained by the current process for any work area.
      DbUnLockAll() is only meaningful on a shared database.<br/>
      It is equivalent to calling DBUnLock() on every occupied work area.
    </remarks>
    <example>
      The following example marks a record for deletion if an RLock() attempt is successful, then clears all locks in all work areas:
      <code language="X#">
        cLast := "Winston"
        USE sales SHARED NEW VIA "DBFNTX"
        Sales-&gt;DBSetIndex("salefnam")
        Sales-&gt;DBSetIndex("salelnam")
        USE colls SHARED NEW VIA "DBFNTX"
        Colls-&gt;DBSetIndex("collfnam")
        Colls-&gt;DBSetIndex("colllnam")
        IF Colls-&gt;DBSeek(cLast)
        &#0009;IF Colls-&gt;Deleted()
        &#0009;&#0009;QOut("Record deleted: ", Colls-&gt;Deleted())
        &#0009;&#0009;IF Colls-&gt;RLock()
        &#0009;&#0009;&#0009;Colls-&gt;DBRecall()
        &#0009;&#0009;&#0009;QOut("Record recalled...")
        &#0009;&#0009;ENDIF
        &#0009;ENDIF
        ELSE
        &#0009;QOut("Not found")
        &#0009;DbUnLockAll()&#0009;&#0009;&#0009;// Remove all locks in
        ENDIF&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// all work areas
      </code>
    </example>
    <seealso cref='O:VO.DbServer.UnLock'>DBServer:UnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLock'>DBUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.Flock'>FLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.RLock'>RLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbUnLockAll'>VODbUnLockAll</seealso>
  </dbunlockall>
  <dbupdate>
    <summary>
      Replace fields in the current work area with values from another work area, based on the specified key expression.
    </summary>

    <param name="cAlias">
      The alias identifier for the source work area used to update records in the current work area.<br/>
      If there is no open database file associated with the specified alias, a runtime error is raised.
    </param>
    <param name="cbKey">A code block defining the expression that defines matching records in the source work area.</param>
    <param name="lRand">
      Random access flag.<br/>
      If TRUE, the current work area must be ordered (using an index order) by <paramref name="cbKey" /> but the source work area records can be in any order.<br/>
      If FALSE, both the current work area and the source work area must be ordered (logically or physically) by Eval(<paramref name="cbKey" />).
    </param>
    <param name="cbReplace">A code block defining how fields in the current work area should be replaced.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      For a shared database, DBUpdate() requires a file lock on the current database file.<br/>
      The source database file can be open in any mode.
      DBUpdate() is the functional equivalent of the UPDATE command.
      <note type="tip">
        Deleted records:&#0009;If SetDeleted() is FALSE, deleted records in both source files are processed.  Records in the file being updated retain their deleted status and are not affected by the deleted status of records in the source file.<br/>
        If SetDeleted()is TRUE, however, no deleted records are processed from either source file
      </note>
    </remarks>
    <example>
      The following example updates the current work area from the TEST2 database (note the condition imposed by the <paramref name="bReplace" /> evaluation):
      <code language="X#">
        DBUpdate("test2", {||Last},, ;
        &#0009;&#0009;&#0009;&#0009;{||_FIELD-&gt;Salary := 0.00})
      </code>
    </example>
    <seealso cref='O:VO.DbServer.Update'>DBServer:Update</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUpdate'>DBUpdate</seealso>
    <seealso cref='O:XSharp.RT.Functions.Flock'>FLock</seealso>
    <seealsocmd>UPDATE</seealsocmd>
  </dbupdate>
  <dbusearea>
    <summary>
      Open a database file.
    </summary>

    <param name="lNewArea">
      Specifies whether the file is to be opened in a new work area.  TRUE selects the lowest numbered unoccupied work area as the current work area before the use operation.<br/>
      If <paramref name="lNewArea" /> is FALSE or omitted, the current work area is used (if the work area is occupied, it is closed first).
    </param>
    <param name="cDriver">
      The name of the RDD that will service the work area.<br/>
      If not specified, the default RDD as determined by RDDSetDefault() is used.
    </param>
    <param name="cDataFile">
      The name of the database file to open, including an optional drive, directory, and extension.<br/>
      If the database file has a corresponding memo file, it is also opened.<br/>
      The default extension for database and memo files is determined by the RDD.<br/>

      &#0009;If the database file or its corresponding memo file does not exist, a runtime error is raised.  See SetDefault() and SetPath() for file searching and creation rules.
    </param>
    <param name="cAlias">
      An identifier name to associate with the work area when <paramref name="cDataFile" /> is opened.<br/>
      If not specified, the alias defaults to the database file name.  Duplicate alias names are not allowed within a single application.
    </param>
    <param name="lShared">
      TRUE attempts to open <paramref name="cDataFile" /> for shared use.  FALSE attempts to open <paramref name="xcDataFile" /> for exclusive (non-shared) use, denying all other processes access until the database file is closed.If <paramref name="lShared" /> is omitted, the current SetExclusive() setting determines whether shared access is allowed.  However, it is highly recommended that you specify the open mode as part of the USE command rather than relying on SetExclusive() to determine it for you.
    </param>
    <param name="lReadOnly">
      TRUE attempts to open <paramref name="cDataFile" /> with a read-only attribute, prohibiting updates to the work area.  FALSE attempts to open <paramref name="cDataFile" /> with a read-write attribute, allowing updates.<br/>
      If <paramref name="lReadOnly" /> is omitted, the default value is FALSE.<br/>
      If <paramref name="cDataFile" /> cannot be accessed using the indicated attribute, a runtime error is raised.
    </param>
    <param name="aStruct">
      An array containing field descriptions in the format returned by DBStruct().<br/>

      &#0009;This argument does not apply to DBF files.<br/>
      It is intended for use with file formats that do not store field descriptions.<br/>
      For example, if you use an RDD that supports SDF or delimited files, you can use this argument to define the file structure, which can then be used with other commands or functions to access the field descriptions.  Here is an example of this argument:<br/>

      <code language="X#">
        &#0009;{"First", "C", 35, 0};<br/>

        &#0009;{"Last", "C", 35, 0};<br/>

        &#0009;{"Birthday", "D", 8, 0}}<br/>

        &#0009;? First&#0009;&#0009;&#0009;&#0009;&#0009;// Return: Josie
      </code>
    </param>
    <param name="cDelim">
      The delimiter for fields within a delimited database file.<br/>
      If you are using one of the supplied RDDs for processing .DBF files , the delimiter should be a NULL_STRING, which is the default if the argument is omitted.
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/acrdds/*"/>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBUseArea() is a functional equivalent of the USE command.<br/>
      For more information, refer to the USE command.
    </remarks>
    <example>
      This example is a typical use of the DBUseArea() function:
      <code language="X#">DBUseArea(TRUE, "DBFMDX", "employees")</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCloseArea'>DBCloseArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbStruct'>DBStruct</seealso>
    <seealso cref='O:XSharp.Core.Functions.NetErr'>NetErr</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
    <seealsocmd>USE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbUseArea'>VODBUseArea</seealso>
  </dbusearea>
  <dbzap>
    <summary>
      Remove all records from open files.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DBZap() permanently removes all records from files open in the work area.<br/>
      This includes the database file, index files, and associated memo file.  Disk space previously occupied by the zapped files is released to the operating system.<br/>
      If all the records in the database file are marked for deletion, DBZap() performs the same operation as DBPack(), but is almost instantaneous.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      This operation requires that the current database be open in exclusive mode (see SetExclusive()).<br/>
      If this condition is not met when the function is invoked, a runtime error is raised.  <br/>
      Otherwise, the operation proceeds and, upon termination, resets the record pointer to the first logical record in the current work area.
    </remarks>
    <example>
      This example demonstrates a typical DBZap() operation:
      <code language="X#">
        USE sales EXCLUSIVE NEW
        IF !NetErr()
        &#0009;SET INDEX TO sales, branch, salesman
        &#0009;IF DBZap()
        &#0009;&#0009;? "Zapped OK"
        &#0009;ELSE
        &#0009;&#0009;? "Error detected during ZAP"
        &#0009;ENDIF
        &#0009;CLOSE sales
        ELSE
        &#0009;? "Error detected when opening the file"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDelete'>DBDelete</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbPack'>DBPack</seealso>
    <seealso cref='O:VO.DbServer.Delete'>DBServer:Delete</seealso>
    <seealso cref='O:VO.DbServer.Zap'>DBServer:Zap</seealso>
    <seealsocmd>DELETE</seealsocmd>
    <seealsocmd>PACK</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetExclusive'>SetExclusive</seealso>
  </dbzap>
  <debout>
    <summary>
      Write information to the Debug Terminal Program
    </summary>

    <param name="uValueList">
      A comma-separated list of expressions of any data type to display to the debug window.<br/>
      If DebOut() is specified without arguments, a carriage return/linefeed pair is displayed.
    </param>
    <returns>
    </returns>
    <remarks>
      DebOut() helps when debugging X# applications. It uses the same mechanism as the Operating Systems OutPutDebugString() functions.
      To see the output you need to run a special program that intercepts this output. You can download such a program from
      http://www.sysinternals.com
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions._DebOut32'>_DebOut32</seealso>
    <seealso cref='O:XSharp.Core.Functions.DebOut32'>DebOut32</seealso>
  </debout>
  <debout32>
    <summary>
      Write information to the Debug Terminal Program
    </summary>

    <param name="pszText">String that gets written to the Debug Terminal Program</param>
    <returns>
    </returns>
    <remarks>
      DebOut32() helps when debugging X# applications. It uses the same mechanism as the Operating Systems OutPutDebugString() functions.
      To see the output you need to run a special program that intercepts this output. You can download such a program from
      http://www.sysinternals.com
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions._DebOut32'>_DebOut32</seealso>
    <seealso cref='O:XSharp.RT.Functions.DebOut'>DebOut</seealso>
  </debout32>
  <decodebase64>
    <summary>
      Decode a file from an e-mail transfer.
    </summary>

    <param name="cAttachment">The attachment text to decode.</param>
    <param name="hDestination">Handle of the file to which the decoded text is to be written.</param>
    <returns>
      The number of bytes that were decoded.
    </returns>
    <remarks>
      Base64 decoding is used to read file attachments from messages sent over the Internet.
    </remarks>
    <example>
      Assuming that the mail message received was properly parsed and the attachment portion was saved to <paramref name="cFilePart" />, this is how you could decode the attachment:
      <code language="X#">
        hOut := FCreate("Attachment.txt")
        IF hfOut != F_ERROR
        &#0009;nTotalBytes := DecodeBase64(cFilePart, hOut)
        &#0009;TextBox{,"Decode", "Bytes Decoded: " + ;
        &#0009;&#0009;&#0009;AsString(nTotalBytes)}:Show()
        ENDIF
        FClose(hfOut)
      </code>
      For a more complete example of DecodeBase64(), including how to parse an e-mail message, see the Mime Decoding sample application (CAVOxx\SAMPLES\INTERNET\MIME\MDECODE.AEF).
    </example>
    <seealso cref="T:VO.CEmail">CLASS CEmail</seealso>
    <seealso cref="T:VO.CMailAbstract">CLASS CMailAbstract</seealso>
    <seealso cref="T:VO.CSmtp">CLASS CSmtp</seealso>
    <seealso cref='O:XSharp.Core.Functions.EncodeBase64'>EncodeBase64</seealso>
  </decodebase64>
  <default>
    <summary>
      Assign a default value to a NIL argument.
    </summary>

    <param name="uVar">
      The variable to which the default value will be assigned.  <paramref name="uVar" /> must be passed by reference to the Default() function.
    </param>
    <param name="uDefault">The default value to assign.</param>
    <returns>
    </returns>
    <remarks>
      Default() assigns <paramref name="uDefault" /> to <paramref name="uVar" /> if <paramref name="uVar" /> is equal to NIL.<br/>
      It is functionally equivalent to either of these code samples:
      <code language="X#">
        IF uVar = NIL
        &#0009;uVar := uDefault
        ENDIF
        IF IsNil(uVar)
        &#0009;uVar := uDefault
        ENDIF
      </code>
      Instead of Default(@<paramref name="uVar" />, 0), you could use EnforceNumeric(@<paramref name="uVar" />), which, besides checking <paramref name="uVar" /> against NIL, calls the error system if <paramref name="uVar" /> is neither numeric nor NIL.  You could also use EnforceType() whenever <paramref name="uDefault" /> is the empty value (EmptyUsual()) for its data type; this raises an error if <paramref name="uVar" /> is not a specific data type.<br/>
      Therefore, instead of calling Default(@<paramref name="uVar" />, NULL_STRING), you could call EnforceType(@<paramref name="uVar" />, STRING).
    </remarks>
    <example>
      This example uses Default() to check all parameters in a function:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL cCA1, cCA2
        &#0009;LOCAL nScore
        &#0009;LOCAL dDate
        &#0009;cCA1 := "CA"
        &#0009;cCA2 := "California"
        &#0009;// nScore and dDate are NIL
        &#0009;CheckArgs(cCA1, nScore, cCA2, dDate)
        &#0009;RETURN TRUE
        FUNCTION CheckArgs(uOne, uTwo, uThree, uFour)
        &#0009;Default(@uOne, "CA-VO")
        &#0009;// NIL argument is assigned a value:
        &#0009;Default(@uTwo, 0)
        &#0009;Default(@uThree, NULL_STRING)
        &#0009;// NIL argument is assigned a value:
        &#0009;Default(@uFour, 0.0.0)
        &#0009;RETURN TRUE
      </code>
      Instead of using CheckArgs(), the following example, besides checking for NIL, checks for the correct data types and raises an error if incorrect types are passed:
      <code language="X#">
        FUNCTION CheckArgs2(uOne, uTwo, uThree, uFour)
        &#0009;Default(@uOne, "CA-VO")
        &#0009;EnforceNumeric(@uTwo)
        &#0009;EnforceType(@uThree, STRING)
        &#0009;EnforceType(@uFour, DATE)
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EmptyUsual'>EmptyUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceNumeric'>EnforceNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
  </default>
  <deferrorgen>
    <summary>
      Convert an ErrInfo structure to an Error object.
    </summary>
    <param name="strucErrorInfo">A pointer to an ErrInfo structure.</param>
    <returns>
      A Error object whose properties match the information in the indicated ErrInfo structure.
    </returns>
    <remarks>
      This function is automatically installed by ErrorGen() as the default error function before
      your application begins execution.
      Thus, unless another error function is installed using ErrorFunc(), DefErrorGen() will
      be used by all subsystems that create an Error object from an ErrInfo structure.
    </remarks>
    <example>
    </example>
    <seealso cref='T:XSharp.Error'>Error Class</seealso>
    <seealsocmd>ErrorGen</seealsocmd>
  </deferrorgen>
  <deleted>
    <summary>
      Return the deleted status of the current record.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      TRUE if the current record is marked for deletion; otherwise, FALSE.<br/>
      If there is no database file in use in the work area, Deleted() returns FALSE.
    </returns>
    <remarks>
      Deleted() determines if the current record in the active work area is marked for deletion.  Since each work area with an open database file can have a current record, each work area has its own Deleted() value.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      In applications, Deleted() is generally used to query the deleted status as a part of record processing conditions, or to display the deleted status as a part of screens and reports.
    </remarks>
    <example>
      This example uses Deleted() in the current and in an unselected work area:
      <code language="X#">
        USE customer NEW
        USE sales NEW
        QOut(Deleted())&#0009;&#0009;&#0009;// Result: FALSE
        Delete
        QOut(Deleted())&#0009;&#0009;&#0009;// Result: TRUE
        QOut(Customer-&gt;Deleted())&#0009;// Result: FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDelete'>DBDelete</seealso>
    <conceptualLink target="cmd_Delete" />
    <seealso cref='O:XSharp.Core.Functions.SetDeleted'>SetDeleted</seealso>
  </deleted>
  <deletestorage>
    <summary>
      Deletes a storage in a storage file that contains persistent information about an OLE object.
    </summary>

    <param name="cFileName">The name of the storage file.</param>
    <param name="cStorage">The name of the storage to be deleted from the storage file.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealsocmd>GetStorageNames</seealsocmd>
  </deletestorage>
  <descend>
    <summary>
      Create a descending order key value.
    </summary>

    <param name="uValue">Any valid expression of string, date, logical, or numeric type.  Memo type is treated in the same way as string type.</param>
    <returns>
      An inverted expression of the same data type as the <paramref name="uValue" />, except for dates which return a numeric value.<br/>
      If <paramref name="uValue" /> is Chr(0), Descend() returns Chr(0).
    </returns>
    <remarks>
      Descend() is a conversion function that returns the inverted form of the specified expression.  You can use it as part of the key expression when you create an order with the INDEX command or the DBCreateIndex() or DBCreateOrder() functions.<br/>
      To subsequently perform a lookup with the SEEK command of DBSeek() function, specify Descend() in the search expression.
      The preferred way to create a descending order is to use the DESCEND clause of the INDEX command or set the <paramref name="lDescend" /> flag to TRUE using the DBSetOrderCondition() before creating the order.<br/>
      This has the same effect as using the Descend() function in the order key expression, but without the performance penalty during updates.<br/>
      If you create a descending order in this manner, you do not need to use the Descend() function during a seek operation.
    </remarks>
    <example>
      This example uses Descend() in an order key expression to impose descending date order on the database file:
      <code language="X#">
        USE sales NEW
        INDEX ON Descend(SaleDate) TO salesdate
      </code>
      Later, use Descend() to SEEK a key value:
      <code language="X#">SEEK Descend(dFindDate)</code>
      You could use the DESCEND keyword instead of Descend(), which is the recommended practice:
      <code language="X#">
        USE sales NEW
        INDEX ON SaleDate TO salesdate DESCEND
      </code>
      Then, you would seek the key value in the normal  manner:
      <code language="X#">Sales-&gt;DBSeek(dFindDate)</code>
      This example illustrates how to create a descending order using more than one data type.  Here, the key is created using the concatenation of date and character fields after the appropriate type conversion has taken place.<br/>
      This example uses Str() instead of DToS() since Descend() of a date returns a numeric value:
      <code language="X#">
        USE sales NEW
        INDEX ON Str(Descend(SaleDate)) + salesman TO;
        &#0009;lastsale
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrderCondition'>DBSetOrderCondition</seealso>
    <seealsocmd>INDEX</seealsocmd>
    <seealsocmd>SEEK</seealsocmd>
  </descend>



  <dirchange>
    <summary>
      Change the current Windows directory.
    </summary>

    <param name="pszDir">The name of the directory to change to, including the drive.</param>
    <returns>
      0 if successful; -1 if there is an argument error; otherwise, the DOS error code.
    </returns>
    <remarks>
      DirChange() changes the current subdirectory or determines if a directory exists.  Be aware that if, after issuing a DirChange(), you change to another drive (via DiskChange(), for example), another Windows task might change the directory of the disk on which your original DirChange() was issued.
    </remarks>
    <example>
      This example uses DirChange():
      <code language="X#">
        siError :=  DirChange("c:\dos")
        IF siError != 0
        &#0009;? DOSErrString(siError)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.CurDir'>CurDir</seealso>
    <seealso cref='O:XSharp.RT.Functions.DirMake'>DirMake</seealso>
    <seealso cref='O:XSharp.RT.Functions.DirRemove'>DirRemove</seealso>
    <seealso cref='O:XSharp.RT.Functions.DiskChange'>DiskChange</seealso>
    <seealso cref='O:XSharp.Core.Functions.WorkDir'>WorkDir</seealso>
  </dirchange>
  <directory>
    <summary>
      Create an array of directory and file information.
    </summary>

    <param name="cFileSpec">
      The file specification for the search.  Besides a file name, this specification can include an optional drive, directory, and extension.<br/>
      The file name and extension can include the standard wildcard characters (* and ?).<br/>
      If you do not specify a drive and directory, the Windows defaults are used.
    </param>
    <param name="uAttributes">
      Specifies inclusion of files with special attributes in the returned information.  
      <paramref name="uAttributes" /> can be a string or a numeric.  When specified as a 
      string it can contain one or more of the characters listed in the table below.  
      When specified as a numeric it can contain one or more of the constants listed in 
      the following table:<br/>

      <list type="table">
        <listheader>
          <term>Character</term>
          <description>Constant&#0009;Description</description>
        </listheader>
        <item>
          <term>D</term>
          <description>FA_DIRECTORY&#0009;Directory</description>
        </item>
        <item>
          <term>H</term>
          <description>FC_HIDDEN&#0009;Hidden</description>
        </item>
        <item>
          <term>S</term>
          <description>FC_SYSTEM&#0009;System</description>
        </item>
        <item>
          <term>V</term>
          <description>FA_VOLUME&#0009;Volume label</description>
        </item>
      </list>
      To specify more than one constant, you can either add attributes together using the + operator, or use the _Or() operator, as in this example: _Or(FC_SYSTEM, FC_HIDDEN).<br/>
      To specify more than one string, simply concatenate them, as in "SH."<br/>

      <paramref name="uAttributes" /> specifies a criterion to satisfy in addition to any "visible" files that match the <paramref name="cFileSpec" />.  Visible files do not include directories, volumes, or hidden or system files — all other files are visible, regardless of the status of their read or archive attributes.<br/>
      To include only visible files, omit this argument.<br/>

      Note:To specify volume labels only, to the exclusion of all other files, specify FA_VOLUME or "V" as the sole <paramref name="uAttributes" /> argument.
    </param>
    <returns>
      An array of subarrays, with each subarray containing information about each file matching <paramref name="cFileSpec" />.<br/>
      The subarray elements are referenced as follows (see example below):
      <include file="RTComments.xml" path="Comments/FileAttributes/*"  />
      If no files are found matching <paramref name="cFileSpec" /> or if <paramref name="cFileSpec" /> 
      is an illegal path or file specification, Directory() returns an empty array.
    </returns>
    <remarks>
      Directory() returns information about files in the current or specified directory.  You can use it to perform actions on groups of files.  In combination with AEval(), you can define a block that can be applied to all files matching the specified <paramref name="cFileSpec" />.
    </remarks>
    <example>
      This example obtains an array of information about all files and directories in the current directory then lists the names of the files using AEval() and QOut():
      <code language="X#">
        aDirectory := Directory("*.*", "D")
        AEval(aDirectory, {|aFile| QOut(aFile[F_NAME])})
      </code>
      This example obtains an array of information about all files in the current directory:
      <code language="X#">aDirectory := Directory("*.*")</code>
      This example displays the name, size, date, time, and attribute of each file that matches the file specification *.PRG:
      <code language="X#">
        Function Start()
        &#0009;LOCAL aDir AS ARRAY
        &#0009;LOCAL i AS DWORD
        &#0009;LOCAL wLen AS DWORD
        &#0009;aDir := Directory("*.prg")
        &#0009;wLen := ALen(aDir)
        &#0009;FOR i := 1 UPTO wLen
        &#0009;&#0009;? aDir[i][F_NAME], aDir[i][F_SIZE],;
        &#0009;&#0009;  aDir[i][F_DATE], aDir[i][F_TIME],;
        &#0009;&#0009;  aDir[i][F_ATTR]
        &#0009;NEXT
        &#0009;// Instead of the above FOR loop, you could
        &#0009;// use the AEval() array iterator function as
        &#0009;// follows:
        &#0009;AEval(aDir, {|aSub| QOut(aSub[F_NAME],;
        &#0009;&#0009;aSub[F_SIZE], aSub[F_DATE], aSub[F_TIME],;
        &#0009;&#0009;aSub[F_ATTR])})
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealsocmd>_Or</seealsocmd>
    <seealsocmd>operator__OrADir</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.Core.Functions.CurDir'>CurDir</seealso>
  </directory>
  <dirmake>
    <summary>
      Create a directory.
    </summary>

    <param name="pszNewDir">
      The name of the directory to create, including an optional drive.<br/>
      If you do not specify a drive, the Windows default is used.
    </param>
    <returns>
      0 if successful; -1 if there is an argument error; otherwise, the DOS error code.
    </returns>
    <remarks>
      DirMake() creates a specified directory.  You must have sufficient rights to create a directory.<br/>
      To create nested subdirectories, you must create each subdirectory separately, starting from the top-level directory that you want to create (see example below.)
    </remarks>
    <example>
      This example assumes that C:\VO exists and uses DirMake() twice to create a nested subdirectory under it:
      <code language="X#">
        DirMake("c:\vo\one")&#0009;&#0009;&#0009;// Create top-most one
        siResult := DirMake("c:\vo\one\two")
        IF siResult != 0
        &#0009;? DOSErrString(siResult)&#0009;// check DOS error ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DirChange'>DirChange</seealso>
    <seealso cref='O:XSharp.RT.Functions.DirRemove'>DirRemove</seealso>
  </dirmake>
  <dirremove>
    <summary>
      Remove a directory.
    </summary>

    <param name="pszDirName">
      The name of the directory to erase, including an optional drive.<br/>
      If you do not specify a drive, the Windows default is used.
    </param>
    <returns>
      0 if successful; -1 if there is an argument error; otherwise, the DOS error code.
    </returns>
    <remarks>
      DirRemove() removes a specified directory. You must have sufficient rights to delete a directory.<br/>
      A directory must be empty in order to be deleted.  So, to delete a directory that contains subdirectories, you must first delete the subdirectories (see example below).
    </remarks>
    <example>
      This example uses DirRemove() to delete a subdirectory named C:\VO\ONE, which only contains an empty subdirectory named C:\VO\ONE\TWO:
      <code language="X#">
        DirRemove("c:\vo\one\two")&#0009;&#0009;// First delete lowest dir
        siResult := DirRemove("c:\vo\one")
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Then delete higher dir
        ? DOSErrString(siResult)&#0009;&#0009;&#0009;// check DOS error if any
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DirChange'>DirChange</seealso>
    <seealso cref='O:XSharp.RT.Functions.DirMake'>DirMake</seealso>
  </dirremove>
  <diskchange>
    <summary>
      Change the current disk drive.
    </summary>

    <param name="pszDrive">The letter of the disk drive to change.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses DiskChange() to change to drive D:
      <code language="X#">
        IF DiskChange("D:")
        &#0009;? "Successfully changed"
        ELSE
        &#0009;? "Not changed"
        ENDIF
      </code>
      This example builds a string that contains all currently available drives on your systeO:
      <code language="X#">
        FUNCTION AllDrives()
        &#0009;LOCAL wI AS DWORD
        &#0009;LOCAL cDrives AS STRING
        &#0009;cDrives := NULL_STRING
        &#0009;FOR wI := 1 UPTO 27&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;
        &#0009;&#0009;IF DiskChange(Chr(wI +64))
        &#0009;&#0009;&#0009;cDrives := cDrives + Chr(wI+64)
        &#0009;&#0009;ENDIF
        &#0009;NEXT
        &#0009;RETURN cDrives
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.CurDrive'>CurDrive</seealso>
    <seealso cref='O:XSharp.RT.Functions.DirChange'>DirChange</seealso>
    <seealso cref='O:XSharp.Core.Functions.DiskFree'>DiskFree</seealso>
    <seealso cref='O:XSharp.Core.Functions.DiskName'>DiskName</seealso>
  </diskchange>
  <diskfree>
    <summary>
      Return the space available on a specified disk.
    </summary>

    <param name="cDrive">
      The letter of the disk drive to query, for  example "C:", "A:". The drive can also be identified by a number, where 1 is drive A, 2 is B, 3 is C, and so on.<br/>
      If you do not specify a drive, the Windows default is used.
    </param>
    <returns>
      The number of bytes of empty space on the specified disk drive.
    </returns>
    <remarks>
      DiskFree() determines the number of available bytes remaining on the specified disk drive.<br/>
      It is useful when copying or sorting to another drive to determine if there is enough space available before initiating the operation.
    </remarks>
    <example>
      This example is a function that demonstrates the use of DiskFree() to back up a database file to another drive:
      <code language="X#">
        FUNCTION BackUp(cTargetFile, cTargetDrive)
        &#0009;LOCAL nSpaceNeeded
        &#0009;LOCAL lSuccess := FALSE
        &#0009;// Calculate the size of the open file
        &#0009;nSpaceNeeded := Integer((RecSize() * ;
        &#0009;&#0009;&#0009;&#0009;&#0009;LastRec()) + Header() + 1)
        &#0009;IF DiskFree(cTargetDrive) &lt; nSpaceNeeded
        &#0009;&#0009;lSuccess := FALSE
        &#0009;ELSE
        &#0009;&#0009;// Close the database file before copying
        &#0009;   DBCloseArea()
        &#0009;&#0009;FCopy("sales.dbf", cTargetDrive + ":"+ cTargetFile)
        &#0009;&#0009;lSuccess := TRUE
        &#0009;ENDIF
        &#0009;RETURN lSuccess
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.DiskSpace'>DiskSpace</seealso>
    <seealso cref='O:XSharp.RT.Functions.Header'>Header</seealso>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
    <seealso cref='O:XSharp.RT.Functions.RecSize'>RecSize</seealso>
  </diskfree>
  <diskname>
    <summary>
      Return the current Windows drive.
    </summary>
    <returns>
      The letter of the current drive, without a trailing colon.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example illustrates the relationship between DiskName() and DiskChange() and shows that DiskName() is unaffected by SetDefault():
      <code language="X#">
        FUNCTION DriveTest()
        &#0009;? DiskName()&#0009;&#0009;&#0009;// C
        &#0009;SetDefault("A")
        &#0009;? DiskName()&#0009;&#0009;&#0009;// C
        &#0009;DiskChange("A")
        &#0009;? DiskName()&#0009;&#0009;&#0009;// A
        &#0009;DiskChange("C")
        &#0009;? DiskName()&#0009;&#0009;&#0009;// C
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.CurDir'>CurDir</seealso>
    <seealso cref='O:XSharp.Core.Functions.CurDrive'>CurDrive</seealso>
    <seealso cref='O:XSharp.RT.Functions.DiskChange'>DiskChange</seealso>
    <seealso cref='O:XSharp.Core.Functions.WorkDir'>WorkDir</seealso>
  </diskname>
  <diskspace>
    <summary>
      Return the capacity of the specified disk.
    </summary>

    <param name="nDrive">The number of the disk drive to query, where 1 is drive A, 2 is B, 3 is C, and so on. The drive can also be identified as a string, for example "C:", "A:".   If you do not specify a drive, the Windows default is used.</param>
    <returns>
      The capacity of the specified disk drive in bytes.
    </returns>
    <remarks>
      DiskSpace() determines the capacity of the specified disk drive in bytes.
      This function is only accurate for disk drives up to 2 gigabytes in size.<br/>
      For larger drives, please refer to the GetDiskFreeSpaceEx() Windows API function.
    </remarks>
    <example>
      This example displays the capacity of the C drive in a TextBox:
      <code language="X#">
        TextBox{, "C Drive Capacity", AsString( DiskSpace(3) ) }:Show()
        TextBox{, "C Drive Capacity", AsString( DiskSpace("C:") ) }:Show()
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.DiskFree'>DiskFree</seealso>
    <seealso cref='O:XSharp.RT.Functions.Header'>Header</seealso>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
    <seealso cref='O:XSharp.RT.Functions.RecSize'>RecSize</seealso>
  </diskspace>
  <doserror>
    <summary>
      Return the last DOS error code associated with an activation of the runtime error block.
    </summary>

    <param name="nNewDosCode">A DOS error number that changes the value returned by DOSError().  You can use it, for example, to reset the error code when trying to preserve the environment in black-box modules or when trying to counteract the side-effects from other modules.</param>
    <returns>
      The number of the last DOS error.<br/>
      If the failed operation has no associated DOS error, DOSError() returns 0.
    </returns>
    <remarks>
      When a runtime error occurs and the operation has an associated DOS error, DOSError() is set to that error code.<br/>
      This value is retained until another runtime error occurs or until you set the value of DOSError() by specifying the <paramref name="nNewDosCode" /> argument.
      With file functions, FError() returns the same value as DOSError().
    </remarks>
    <example>
      The following example displays the DOS error code as a string:
      <code language="X#">
        FUNCTION Start()
        &#0009;Dir AA:&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Bad device
        &#0009;QOut(DOSErrString(DOSError()))&#0009;
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Path not found
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.DosErrString'>DOSErrString</seealso>
    <seealso cref='O:XSharp.RT.Functions.ErrorBlock'>ErrorBlock</seealso>
    <seealso cref='O:XSharp.Core.Functions.ErrorLevel'>ErrorLevel</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.GetDosError'>GetDOSError</seealso>
  </doserror>
  <doserrstring>
    <summary>
      Return a description string for a DOS error number.
    </summary>

    <param name="dwError">The DOS error number that you want a description for.</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      The following example displays the DOS error code as a string:
      <code language="X#">
        FUNCTION Start()
        &#0009;Dir AA:&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Bad device
        &#0009;QOut(DOSErrString(DOSError()))&#0009;
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Path not found
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.DosError'>DOSError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.GetDosError'>GetDOSError</seealso>
  </doserrstring>
  <dow>
    <summary>
      Extract the number of the day of the week from a date.
    </summary>

    <param name="dDate">The date.</param>
    <returns>
      The day of the week as a number from 1 to 7, where 1 is Sunday, 2 is Monday, and so on.<br/>
      For an invalid or NULL_DATE, DoW() returns 0.
    </returns>
    <remarks>
      DoW() is a date conversion function that converts a date value to a number identifying the day of the week.<br/>
      It is useful when you want date calculations on a weekly basis.  DoW() is similar to CDoW(), which returns the day of week as a string instead of a number.
    </remarks>
    <example>
      These examples illustrate CDoW() and its relationship to DoW():
      <code language="X#">
        ? TODAY()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 09/01/98
        ? DOW(TODAY())&#0009;&#0009;&#0009;&#0009;&#0009;// 3
        ? CDOW(TODAY())&#0009;&#0009;&#0009;&#0009;// Tuesday
        ? DOW(TODAY() - 2)&#0009;&#0009;&#0009;&#0009;// 1
        ? CDOW(TODAY() – 2)&#0009;&#0009;&#0009;&#0009;// Sunday
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CDoW'>CDoW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Day'>Day</seealso>
    <seealso cref='O:XSharp.RT.Functions.Today'>Today</seealso>
  </dow>
  <dtoc>
    <summary>
      Convert a date to a string.
    </summary>

    <param name="dDate">The date value to convert.</param>
    <returns>
      A string representation of <paramref name="dDate" />, formatted in the current date format.<br/>
      A NULL_DATE returns a string of spaces equal in length to the current date format.
    </returns>
    <remarks>
      DToC() is a date conversion function used for formatting purposes when you want to display the date in the SetDateFormat() or SetDateCountry() format or when a string is required (in a LABEL FORM, for example).<br/>
      If you need a specialized date format, you can use Transform() or a custom expression.
      Since DToS() is in the form of yyyymmdd, it is usually the preferred form for indexing a date in combination with a string.
    </remarks>
    <example>
      These examples show general uses of DToC():
      <code language="X#">
        ? TODAY()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 09/01/98
        ? DTOC(TODAY())&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 09/01/98
        ? "Today is " + DTOC(TODAY())&#0009;&#0009;&#0009;&#0009;// Today is 09/01/98
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CToD'>CToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToS'>DToS</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetCentury'>SetCentury</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDateCountry'>SetDateCountry</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDateFormat'>SetDateFormat</seealso>
    <seealso cref='O:XSharp.RT.Functions.Today'>Today</seealso>
    <seealso cref='O:XSharp.RT.Functions.Transform'>Transform</seealso>
  </dtoc>
  <dtos>
    <summary>
      Convert a date value to a string formatted as yyyymmdd.
    </summary>

    <param name="dDate">The date value to convert.</param>
    <returns>
      An 8-character string in the format yyyymmdd.<br/>
      If <paramref name="dDate" /> is a NULL_DATE, a string of eight spaces is returned.<br/>
      The return value is not affected by the current date format.
    </returns>
    <remarks>
      DToS() is a date conversion function that is used when creating order keys consisting of a date value and a string.  DToS() converts a date value to a string that can be concatenated to any other string.<br/>
      The return value is structured to preserve date order (year, month, and day).
    </remarks>
    <example>
      These examples simply apply DToS() to a date:
      <code language="X#">
        ? TODAY()&#0009;&#0009;&#0009;&#0009;// 09/01/98
        ? DTOS(TODAY())&#0009;&#0009;&#0009;// 19980901
      </code>
      This example applies DToS() to a date literal and reports its length:
      <code language="X#">? SLen(DTOS(0.0.0)&#0009;&#0009;&#0009;// 8</code>
      This example demonstrates how to create an order with a compound date and character key using DToS():
      <code language="X#">
        USE sales NEW
        INDEX ON DTOS(SaleDate) + LastName TO datename
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CToD'>CToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToC'>DToC</seealso>
    <seealso cref='O:XSharp.RT.Functions.SToD'>SToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.Today'>Today</seealso>
  </dtos>
  <dw2bin>
    <summary>
      Convert a double word to a string containing a 32-bit unsigned integer.
    </summary>

    <param name="dwValue">The value to convert.  Decimal digits are truncated.</param>
    <returns>
      A 4-byte string containing a 32-bit unsigned integer.
    </returns>
    <remarks>
      DW2Bin() is a conversion function that converts a double word to a 4-byte string.  Typical applications include reading foreign file types in their native format and then saving, reading, decrypting, and transmitting numeric data in their compressed binary form instead of in strings.<br/>
      Its inverse is Bin2DW().
    </remarks>
    <example>
      This example uses DW2Bin() to record our current memory settings to a debugging file:
      <code language="X#">
        FUNCTION RecordMemory() AS LOGIC
        &#0009;LOCAL nh
        &#0009;LOCAL lSuccess := FALSE AS LOGIC
        &#0009;nh := FOpen2("debug.doc", FO_READWRITE)
        &#0009;// Assumes that file debug.doc already exists
        &#0009;IF nh != F_ERROR
        &#0009;&#0009;FWrite3(nh, DW2Bin(Memory(1)), 4)
        &#0009;&#0009;FWrite3(nh, DW2Bin(Memory(2)), 4)
        &#0009;&#0009;FWrite3(nh, DW2Bin(Memory(3)), 4)
        &#0009;&#0009;FClose(nh)
        &#0009;&#0009;lSuccess := TRUE
        &#0009;ELSE
        &#0009;&#0009;? "An error occurred when opening debug.doc"
        &#0009;&#0009;FError()
        &#0009;ENDIF
        &#0009;RETURN lSuccess
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </dw2bin>
  <elaptime>
    <summary>
      Return the difference between two time strings.
    </summary>

    <param name="cStartTime">The starting time in the form hh:mO:ss.</param>
    <param name="cEndTime">The ending time in the form hh:mO:ss.</param>
    <returns>
      The amount of time that has elapsed from <paramref name="cStartTime" /> to <paramref name="cEndTime" /> as a time string in the format hh:mO:ss.
    </returns>
    <remarks>
      ElapTime() calculates the difference between two time strings by subtracting <paramref name="cStartTime" /> from <paramref name="cEndTime" />.
    </remarks>
    <example>
      These examples illustrate ElapTime():
      <code language="X#">
        ? ElapTime("03:02:01", "09:09:09")&#0009;&#0009;// 06:07:08
        ? ElapTime("09:05:12", "23:10:07")&#0009;&#0009;// 14:04:55
        // Time elapsed from 11pm to 5am
        ? ElapTime("23:00:00", "05:00:00")&#0009;&#0009;// 06:00:00
        // Time elapsed from 5am to 11pm
        ? ElapTime("05:00:00", "23:00:00")&#0009;&#0009;// 18:00:00
        ? ElapTime(Time(), "20:01:03")&#0009;&#0009;
        // Depends on current time
      </code>
      <br/>



      System Library
    </example>
    <seealso cref='O:XSharp.Core.Functions.Seconds'>Seconds</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
  </elaptime>
  <empty>
    <summary>
      Determine if the result of an expression is empty.
    </summary>

    <param name="uValue">
      An expression of any data type.<br/>
      The criteria for determining whether a value is considered empty depends on the data type of <paramref name="uValue" />, according to the following rules:<br/>

      <list type="table">
        <listheader>
          <term>Data Type</term>
          <description>Contents</description>
        </listheader>
        <item>
          <term>Array</term>
          <description>NULL_ARRAY or empty array</description>
        </item>
        <item>
          <term>Code block</term>
          <description>NULL_CODEBLOCK</description>
        </item>
        <item>
          <term>Date</term>
          <description>NULL_DATE</description>
        </item>
        <item>
          <term>Logic</term>
          <description>FALSE</description>
        </item>
        <item>
          <term>NIL</term>
          <description>NIL</description>
        </item>
        <item>
          <term>VOID</term>
          <description>TRUE</description>
        </item>
        <item>
          <term>Numeric</term>
          <description>0</description>
        </item>
        <item>
          <term>Object</term>
          <description>NULL_OBJECT</description>
        </item>
        <item>
          <term>PSZ</term>
          <description>NULL_PSZ</description>
        </item>
        <item>
          <term>PTR</term>
          <description>NULL_PTR </description>
        </item>
        <item>
          <term>String</term>
          <description>Spaces, tabs, carriage return/line feed, or NULL_STRING</description>
        </item>
        <item>
          <term>Symbol</term>
          <description>NULL_SYMBOL</description>
        </item>
      </list>
    </param>
    <returns>
      TRUE if the expression results in an empty value; otherwise, FALSE.
    </returns>


    <seealso cref='O:XSharp.RT.Functions.ALen'>ALen</seealso>
    <seealso cref='O:XSharp.RT.Functions.EmptyUsual'>EmptyUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsSpace'>IsSpace</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.Core.Functions.SLen'>SLen</seealso>
  </empty>
  <emptytyped>
    <summary>
      Determine if the result of an expression is empty.
    </summary>

    <param name="uValue">
      The value to check for 'emptyness'
    </param>
    <param name="oObject">
      The value to check for 'emptyness'
    </param>
    <returns>
      TRUE if the expression results in an empty value; otherwise, FALSE.
    </returns>


    <seealso cref='O:XSharp.RT.Functions.ALen'>ALen</seealso>
    <seealso cref='O:XSharp.RT.Functions.EmptyUsual'>EmptyUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsSpace'>IsSpace</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.Core.Functions.SLen'>SLen</seealso>
  </emptytyped>
  <emptyfield>
    <summary>
      Determine if field number n in the current workarea is empty.
    </summary>

    <param name="n">The field number in the current workarea.</param>
    <returns>
      TRUE if the field is empty; otherwise FALSE.
    </returns>


  </emptyfield>
  <emptyrecord>
    <summary>
      Determine if the current record in the current workarea is empty.
    </summary>
    <returns>
      TRUE if the record is empty; otherwise FALSE.
    </returns>


  </emptyrecord>
  <emptyusual>
    <summary>
      Return the empty value of a specified data type.
    </summary>

    <param name="kType">
      The data type whose empty value is desired.<br/>
      The constants defining all X# data types are listed in the table below.
    </param>
    <returns>
      The empty value of the data type specified by <paramref name="kType" />.<br/>
      These values are as follows:
      <list type="table">
        <listheader>
          <term>
            <paramref name="kType" />
          </term>
          <description>Empty Value</description>
        </listheader>
        <item>
          <term>ARRAY</term>
          <description>NULL_ARRAY or empty array</description>
        </item>
        <item>
          <term>BYTE, DWORD</term>
          <description>0</description>
        </item>
        <item>
          <term>FLOAT, INT</term>
          <description>0</description>
        </item>
        <item>
          <term>LONGINT, REAL4</term>
          <description>0</description>
        </item>
        <item>
          <term>
            REAL8, SHORTINT
          </term>
          <description>0</description>
        </item>
        <item>
          <term>WORD</term>
          <description>0</description>
        </item>
        <item>
          <term>CODEBLOCK</term>
          <description>NULL_CODEBLOCK</description>
        </item>
        <item>
          <term>DATE</term>
          <description>NULL_DATE</description>
        </item>
        <item>
          <term>LOGIC</term>
          <description>FALSE</description>
        </item>
        <item>
          <term>OBJECT</term>
          <description>NULL_OBJECT</description>
        </item>
        <item>
          <term>PSZ</term>
          <description>NULL_PSZ</description>
        </item>
        <item>
          <term>PTR</term>
          <description>NULL_PTR </description>
        </item>
        <item>
          <term>STRING</term>
          <description>Spaces, tabs, carriage return/line feed, or NULL_STRING</description>
        </item>
        <item>
          <term>SYMBOL</term>
          <description>NULL_SYMBOL</description>
        </item>
        <item>
          <term>USUAL</term>
          <description>
            NIL
          </description>
        </item>
        <item>
          <term>VOID</term>
          <description>NIL</description>
        </item>
      </list>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example shows the result of EmptyUsual() for different data types:
      <code language="X#">
        &#0009;? EmptyUsual(LOGIC)&#0009;&#0009;&#0009;&#0009;// FALSE
        &#0009;? EmptyUsual(SHORTINT)&#0009;&#0009;// 0
        &#0009;? EmptyUsual(STRING)&#0009;&#0009;&#0009;// NULL_STRING
      </code>
      This example passes the result of the EmptyUsual() function to the Empty() function:
      <code language="X#">
        &#0009;? Empty(EmptyUsual(DATE))&#0009;&#0009;&#0009;// TRUE
        &#0009;? Empty(EmptyUsual(LONGINT))&#0009;// TRUE
        &#0009;? Empty(EmptyUsual(SYMBOL))  &#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.Empty'>Empty</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceNumeric'>EnforceNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
  </emptyusual>
  <enable3dcontrols>
    <summary>
      Note - This function has no purpose in 32 bit programs. It is included for backward compatibility with 16 bit applications only.
      <br/>



      Determines whether controls on windows created with the GUI classes are displayed using a sculpted, three-dimensional look.
    </summary>
    <returns>
    </returns>
    <remarks>
      Controls (such as edit controls) that are displayed on a window are, by default, displayed using a flat, one-dimensional look.  You can, however, assign various color attributes to the controls, using, for example, the Control:Background or TextControl:TextColor properties.  Invoking Enable3DControls() causes them to be displayed with shading, producing a sculpted, three-dimensional effect, and disables all color attributes.
      Note:  Enable3DControls() affects controls on windows created with the GUI classes (such as data windows) only.<br/>
      It has no effect on the terminal emulation window.
    </remarks>
    <example>
      The Standard Application invokes this function in the App:Start() method, as illustrated in the example below.<br/>
      If you prefer the one-dimensional look, simply delete the call to Enable3DControls():
      <code language="X#">
        METHOD Start() CLASS App
        &#0009;LOCAL oWindow AS Window
        &#0009;Enable3DControls()
        &#0009;oWindow := StandardShellWindow{SELF}
        &#0009;oWindow:Show()
        &#0009;SELF:Exec()
      </code>
    </example>
  </enable3dcontrols>
  <encodebase64>
    <summary>
      Encode a file for e-mail transfer.
    </summary>

    <param name="hSource">Handle of the file to encode.</param>
    <param name="hDestination">Handle of the file to which the encoded text is to be written.</param>
    <returns>
      The number of bytes that were encoded.
    </returns>
    <remarks>
      Base64 encoding is used to transmit files attached to messages over the Internet.
    </remarks>
    <example>
      <code language="X#">
        hOut := FCreate("C:\MyFiles\MailOut.txt")
        IF hfOut != F_ERROR
        &#0009;hIn := FOpen("C:\MyFiles\Source.txt", FO_READ)
        &#0009;IF hIn != F_ERROR
        &#0009;&#0009;nTotalBytes := EncodeBase64(hIn, hOut)
        &#0009;&#0009;TextBox{,"Encode", "Bytes Encoded: " + ;
        &#0009;&#0009;&#0009;AsString(nTotalBytes)}:Show()
        ENDIF
        ENDIF
        FClose(hfOut)
        FClose(hf)
      </code>
      For a more complete example of EncodeBase64(), see the Mime Encoding sample application (CAVOxx\SAMPLES\INTERNET\MIME\MENCODE.AEF).
    </example>
    <seealsocmd>CLASS CEmail</seealsocmd>
    <seealsocmd>CLASS CMailAbstract</seealsocmd>
    <seealsocmd>CLASS CSmtp</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.DecodeBase64'>DecodeBase64</seealso>
  </encodebase64>
  <enforcenumeric>
    <summary>
      Make sure a variable is a numeric.
    </summary>

    <param name="u">
      The variable to check.<br/>
      If <paramref name="u" /> is NIL, a value of 0 is assigned to it.
      If <paramref name="u" /> is not passed by reference and is not a numeric, the error system aborts the program.
      If <paramref name="u" /> is passed by reference but is not a numeric, the error system is called up and a value of 0 is assigned to <paramref name="u" />.
    </param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses EnforceNumeric() to ensure that an argument is a numeric, initialized to 0:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL nOne
        &#0009;LOCAL nTwo
        &#0009;LOCAL cName
        &#0009;CheckNumbers()
        FUNCTION CheckNumbers(nOne, nTwo)
        &#0009;EnforceNumeric(@nOne)&#0009;// Assigns 0 since NIL
        &#0009;Default(@nTwo, 100)&#0009;&#0009;// Assigns 100 since NIL
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EmptyUsual'>EmptyUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
  </enforcenumeric>
  <enforcetype>
    <summary>
      Make sure a variable is of a certain type.
    </summary>

    <param name="u">
      The variable to check.<br/>
      If <paramref name="u" /> is NIL and is passed by reference, the EmptyUsual() of the
      data type specified by <paramref name="dwType" /> is assigned to it.<br/>
      If <paramref name="u" /> is not passed by reference and is not of the
      data type specified by <paramref name="dwType" />, the error system aborts the program.<br/>
      If <paramref name="u" /> is passed by reference but
      is not of the data type specified by <paramref name="dwType" />, the error system is called up and the EmptyUsual() of the data type
      specified by <paramref name="dwType" /> is assigned to <paramref name="u" />.
    </param>
    <param name="dwType">The data type to enforce.</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses EnforceType() to ensure all arguments are of the correct type:
      <code language="X#">
        FUNCTION CheckArgs(cName, nScore, dDate, nMoney)
        &#0009;EnforceType(@cName, STRING)
        &#0009;EnforceType(@nScore, SHORTINT)
        &#0009;&#0009;// Assigns 0 if NIL
        &#0009;EnforceType(@dDate, DATE)
        &#0009;EnforceType(@nMoney, LONGINT)&#0009;// Assigns 0 if NIL
        &#0009;EnforceType(@nOne, SHORTINT)&#0009;// Assigns 0 if NIL
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EmptyUsual'>EmptyUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceNumeric'>EnforceNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
  </enforcetype>
  <eof>
    <summary>
      Determine when end-of-file is encountered.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      TRUE when an attempt is made to move the record pointer beyond the last logical record in a database file or if the database file contains no records; otherwise, FALSE.<br/>
      If there is no database file open in the work area, EOF() returns TRUE.
    </returns>
    <remarks>
      EOF() is a database function used to test for an end-of-file boundary condition when the record pointer is
      moving forward through a database file.<br/>
      Any command that can move the record pointer can set EOF().<br/>

      The most typical application is as a part of the <paramref name="lCondition" /> argument of a DO WHILE construct that
      sequentially processes records in a database file.  Here <paramref name="lCondition" /> would include a test for .NOT.
      EOF(), forcing the DO WHILE loop to terminate when EOF() returns TRUE.<br/>

      EOF() and Found() are often used interchangeably to test whether a SEEK, FIND, or LOCATE command failed.  <br/>

      With these commands, however, Found() is preferred.<br/>

      When EOF() returns TRUE, the record pointer is positioned at LastRec() + 1 regardless of
      whether there is an active filter setting or SetDeleted() is TRUE.<br/>

      Further attempts to move the record pointer forward return the same result without error.  <br/>

      Once EOF() is set to TRUE, it retains its value until there is another attempt to move the record pointer.<br/>

      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      This example demonstrates EOF() by deliberately moving the record pointer beyond the last record:
      <code language="X#">
        USE sales
        DBGoBottom()
        QOut(EOF())&#0009;&#0009;&#0009;// Result: FALSE
        SKIP
        QOut(EOF())&#0009;&#0009;&#0009;// Result: TRUE
      </code>
      This example uses aliased expressions to query the value of EOF() in unselected work areas:
      <code language="X#">
        USE sales NEW
        USE customer NEW
        QOut(Sales-&gt;EOF())
        QOut(Customer-&gt;EOF())
      </code>
      This example illustrates how EOF() can be used as part of a condition for sequential database file operations:
      <code language="X#">
        USE sales INDEX custnum NEW
        DO WHILE !(Sales-&gt;EOF())
        &#0009;nOldCust := Sales-&gt;CustNum
        &#0009;nTotalAmount := 0
        &#0009;DO WHILE nOldCust = Sales-&gt;CustNum .AND. ;
        &#0009;&#0009;&#0009;&#0009;!(Sales-&gt;EOF()
        &#0009;&#0009;QOut(Sales-&gt;CustNum, ;
        &#0009;&#0009;&#0009;Sales-&gt;Description, ;
        &#0009;&#0009;&#0009;Sales-&gt;SaleAmount)
        &#0009;&#0009;nTotalAmount += Sales-&gt;SaleAmount
        &#0009;&#0009;SKIP
        &#0009;ENDDO
        &#0009;QOut("Total amount: ", nTotalAmount)
        ENDDO
      </code>
      You could have written the EOF check in the code above with an alias parameter to EOF() as well:
      <code language="X#">
        DO WHILE !EOF("Sales")
        &#0009;.
        &#0009;.
        ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bof'>BOF</seealso>
    <seealsocmd>DO WHILE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.Found'>Found</seealso>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
    <seealsocmd>LOCATE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.RecNo'>RecNo</seealso>
    <seealsocmd>SEEK</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbEof'>VODBEOF</seealso>
    <seealso cref='P:VO.DbServer.EoF'>DBServer:EoF</seealso>
  </eof>
  <errorbuild>
    <summary>Create an error object from an exception.</summary>
    <param name="pErrInfo">An exception object to base the Error object on.</param>

  </errorbuild>
  <errorblock>
    <summary>
      Return and optionally change the code block that is executed when a runtime error occurs.
    </summary>

    <param name="cbNewSetting">The code block to execute whenever a runtime error occurs.</param>
    <returns>
      If <paramref name="cbNewSetting" /> is not specified, ErrorBlock() returns the current setting.<br/>
      If <paramref name="cbNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      X# defines a default error handling code block that determines what to do when a runtime error occurs.  ErrorBlock() lets you override this default error handling mechanism with one that you define.
      Specify the error handler as a code block with the following forO:
      <code language="X#">
        {|<paramref name="oError" />| <paramref name="uList" />}
      </code>
      where <paramref name="oError" /> is an error object containing information about the error and <paramref name="uList" /> is a comma-separated list of USUAL
      expressions that call the function that actually handles the errors.  <br/>

      Within the code block, messages can be sent to the error object to obtain information about the error.  <br/>

      A return value of TRUE from the error handling code block retries the failed operation, whereas a return value of FALSE resumes processing.
      The error handling code block can be specified either as a list of expressions or as a call to a function.  <br/>

      A call to a function is more useful since you can use X# control statements instead of expressions.  <br/>

      This is particularly the case if there is a BEGIN SEQUENCE or LabelPush() pending and you want to BREAK to the nearest RECOVER statement.<br/>

      As this implies, error handling code blocks can be used in combination with BEGIN SEQUENCE...END control structures.  <br/>

      Within an error handling code block, you handle device, low-level, and common errors that have a general recovery mechanism.  <br/>

      If the operation needs specific error handling, define a BEGIN SEQUENCE or LabelPush(), then BREAK to the RECOVER statement, returning the error object for local processing.  See the example below.
      For more information on the structure and operations of error objects, refer to the Error Class entry.<br/>

    </remarks>
    <example>
      This code fragment posts, then calls an error handling code block when there is an error within a BEGIN SEQUENCE construct:
      <code language="X#">
        LOCAL cbErrorHandler, cbLastHandler, oError
        cbErrorHandler := {|oError|MyErrorHandler(oError)}
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Save current handler
        cbLastHandler := ErrorBlock(cbErrorHandler)
        BEGIN SEQUENCE
        &#0009;.
        &#0009;. <paramref name="OperationStatements" />
        &#0009;.
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Receive error object from BREAK
        RECOVER USING oErrorInfo
        &#0009;.
        &#0009;. <paramref name="RecoveryStatements" />
        &#0009;.
        END
        ErrorBlock(cbLastHandler)&#0009;&#0009;&#0009;// Restore handler
        FUNCTION MyErrorHandler(oError)
        &#0009;BREAK oError
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Return error object to RECOVER
      </code>
      This example improves on the previous example.  Instead of setting up ErrorBlock({|oError| _Break(oError)}) which just does a BREAK without taking advantage of the facilities of
      the error system (for example, VOERROR.LOG), you could set up an Init method for the Error class as follows:
    </example>
    <seealsocmd>BEGIN SEQUENCE</seealsocmd>
    <seealsocmd>ErrorSys</seealsocmd>
  </errorblock>
  <errorcount>
    <summary>
      Return the number of errors that have occurred during program execution.
    </summary>

    <param name="wValue">Resets the error count for the application to the specified value.</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      These example produces an intentional error and shows the return value of ErrorCount():
      <code language="X#">
        FUNCTION Start()
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Produce an error and get the error count
        LOCAL oError, nVal
        BEGIN SEQUENCE
        &#0009;oError := ErrorBlock({|| _Break(NIL)})
        &#0009;nVal := 0
        &#0009;? 1/nVal&#0009;&#0009;&#0009;// Divide by 0 error
        END
        ErrorBlock(oError)
        ? ErrorCount()&#0009;&#0009;&#0009;&#0009;// 1
        ErrorCount(0)&#0009;&#0009;&#0009;&#0009;// Reset error count to zero
      </code>
    </example>
  </errorcount>
  <errorgen>
    <summary>
      Reinstall the default error function.
    </summary>
    <returns>
    </returns>
    <remarks>
      The ErrorGen() procedure, because it is declared with the _INIT1 keyword, executes automatically at the startup of every X# application to install the default error handling function, DefErrorGen().<br/>
      If you choose to install your own error handling function and want to reinstall the default one at any point during your application, simply call ErrorGen().
    </remarks>
    <example>
    </example>
    <seealsocmd>DefErrorGen</seealsocmd>
    <seealso cref='O:XSharp.VO.Functions.ErrorFunc'>ErrorFunc</seealso>
    <seealsocmd>ErrorSys</seealsocmd>
  </errorgen>
  <errorlevel>
    <summary>
      Retrieve and optionally set the X# return code.
    </summary>

    <param name="dwNewSetting">
      The new return code setting.<br/>
      This can be a value between 0 and 255.<br/>
      The default initial value is 0.<br/>

      &#0009;When a X# program terminates, the return code is set to 1 if the process ends with a fatal error.<br/>
      If the process ends normally, the return code is set to 0 (unless ErrorLevel() was set to something else in the program).<br/>

      &#0009;Typically, you would set a return code with ErrorLevel() to indicate an error state to the program that invoked the current X# program.  In most cases, this is the application batch file.  Here you would test the return code using the DOS ErrorLevel command.  (Refer to your DOS manual for more information.)
    </param>
    <returns>
      If <paramref name="dwNewSetting" /> is not specified, ErrorLevel() returns the current setting.<br/>
      If <paramref name="dwNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      <note type="tip">
        After a RUN command, a return value of less than 32 from ErrorLevel(), indicates an error.  (Refer to the Windows API WinExec() function for more information.)
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.DosError'>DOSError</seealso>
    <seealso cref='O:XSharp.Core.Functions._Quit'>QUIT</seealso>
  </errorlevel>
  <errornew>
    <summary>
      Create a new error object.
      Note:  ErrorNew() is a compatibility function and is no longer recommended.<br/>
      It is superseded by a direct call to the Error class constructor (Error{}) which creates an error object directly.
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses ErrorNew() to create a new error object:
      <code language="X#">
        LOCAL oError AS ERROR
        oError := ErrorNew()
      </code>
      This example does the same thing as the one above but does it more efficiently by creating the error object directly:
      <code language="X#">
        LOCAL oError AS ERROR
        oError := Error{}
      </code>
    </example>
  </errornew>
  <errorstackoptions>
    <summary>
    </summary>

    <param name="ulAddProcFile">(Optional) LOGIC: Should the Module name be included in the call stack</param>
    <param name="uliStackLength">(Optional) LONG: Number of levels to include in the call stack of errors</param>
    <param name="ulAddLevelNumber">(Optional) LOGIC: Should the level number be included in the call stack</param>
    <param name="uliUntilExecOrDispatch">(Optional) LONG: Number of Dispatch(), Eval() or Exec() levels to include in the call stack.</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </errorstackoptions>
  <errorsys>
    <summary>
      Reinstall the default error handler.
    </summary>
    <returns>
    </returns>
    <remarks>
      The ErrorSys() procedure, because it is declared with the _INIT1 keyword, executes automatically at the startup of every X# application to install the default error handler.<br/>
      If you choose to install your own error handler and want to reinstall the default one at any point during your application, simply call ErrorSys().
      The source code for the default error handler is defined in the ERRORSYS.PRG file, located in your X#  \SAMPLES directory.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ErrorBlock'>ErrorBlock</seealso>
    <seealsocmd>ErrorGen</seealsocmd>
  </errorsys>
  <errstring>
    <summary>
      Return an error message associated with a system-generated error code.
    </summary>

    <param name="dwNewReturnCode">The error code exported by an error object.</param>
    <returns>
      The message string associated with the error code.  Error messages are nation-dependent.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example displays the error message associated with a protection error:
      <code language="X#">
        FUNCTION Start()
        &#0009;QOut("EG_PROTECTION:", ErrString(EG_PROTECTION))
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.DosError'>DOSError</seealso>
  </errstring>
  <eval>
    <summary>
      Evaluate a code block or an object's Eval() method.
    </summary>

    <param name="obj">
      The code to execute.<br/>
      Its Eval() method is used.
    </param>
    <param name="block">
      The code to execute.<br/>
      If an object is specified, its Eval() method is used.
    </param>
    <param name="uCodeBlock">
      The code to execute.<br/>
      If an object is specified, its Eval() method is used.
    </param>
    <param name="args">A list of arguments that can be sent to the code block or the method to be evaluated.</param>
    <returns>
      The value of the last expression within the code block.
    </returns>
    <remarks>
      The X# compiler usually compiles a code block at compile time.<br/>
      If you  need to compile a code block from a string at runtime, use the macro operator (&amp;).
      Eval() is often used to create iterator functions.<br/>
      These are functions, like AEval(), ASort(), AScan(), and DBEval(), that apply a code block to each member of a data structure.<br/>
      For example, AEval() can be used to apply a code block to each element within an array.
    </remarks>
    <example>
      This example creates a code block that increments a number, then evaluates it:
      <code language="X#">
        cbBlock := {|nArg| nArg + 1}
        ? Eval(cbBlock, 1)&#0009;&#0009;&#0009;&#0009;&#0009;// 2
      </code>
      This example demonstrates compiling a code block at runtime using the macro operator (&amp;):
      <code language="X#">
        // Compile a string to a code block
        cbBlock := &amp;("{|nArg| nArg + 1}")
        // Evaluate the code block
        ? Eval(cbBlock, 1)&#0009;&#0009;&#0009;&#0009;&#0009;// 2
      </code>
      This example applies Eval() to an object:
      <code language="X#">
        CLASS Greet
        METHOD Eval(cStr) CLASS Greet
        ? "hello", cStr
        FUNCTION Start()
        &#0009;LOCAL oHello AS OBJECT
        &#0009;oHello := Greet{}
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Call the Eval() method of the class:
        &#0009;Eval(oHello, "there") &#0009;// hello there
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanBinExact'>AScanBinExact</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanExact'>AScanExact</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbEval'>DBEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.SEval'>SEval</seealso>
  </eval>
  <evaluate>
    <summary>
      Evaluate an expression contained in a string.
    </summary>

    <param name="cString">The string containing the expression to evaluate.</param>
    <returns>
      The value of the expression.
    </returns>
    <remarks>
      Evaluate() invokes the macro compiler each time it evaluates an expression.<br/>
      Alternatively, you could use MCompile() to compile an expression only once, then use MExec() to execute the compiled form as often as you want.
    </remarks>
    <example>
      This example shows typical uses of Evaluate():
      <code language="X#">
        LOCAL cVar AS STRING
        cVar := "World"
        World := "Hello"&#0009;// World is a PRIVATE variable
        ? Evaluate(cVar)&#0009;// Hello
        ? Evaluate("2+3")&#0009;// 5
        Two := 2&#0009;// Two is a PRIVATE variable
        Evaluate("Two+3")&#0009;// 5
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MAssign'>MAssign</seealso>
    <seealso cref='O:XSharp.RT.Functions.MCompile'>MCompile</seealso>
    <seealso cref='O:XSharp.RT.Functions.MExec'>MExec</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrEvaluate'>StrEvaluate</seealso>
  </evaluate>
  <exp>
    <summary>
      Calculate the numeric value of a natural logarithm.
    </summary>

    <param name="nExponent">The power to which e is to be raised.</param>
    <returns>
      A floating point number that is equivalent to the value e raised to <paramref name="nExponent" />.
    </returns>
    <remarks>
      Exp() calculates the value y (the antilogarithm) of the following equation:
      <code language="X#">e^x = y</code>
      where e is the base of natural logarithms (2.71828...) and x is <paramref name="nExponent" />.
      Exp() and Log() are inverse functions.
    </remarks>
    <example>
      This example demonstrates several invocations of Exp():
      <code language="X#">
        ? Exp(1)&#0009;&#0009;&#0009;&#0009;&#0009;// 2.72
        SetDecimal(10)
        ? Exp(1)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 2.7182818285
        ? Log(Exp(1))&#0009;&#0009;&#0009;&#0009;// 1.0000000000
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.LOG'>Log</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pow'>Pow</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetFixed'>SetFixed</seealso>
  </exp>
  <f2bin>
    <summary>
      Convert a float to a string containing an 80-bit floating point number.
    </summary>

    <param name="fValue">The value to convert.</param>
    <returns>
      A string representing a floating point number.
    </returns>
    <remarks>
      F2Bin() is a conversion function that converts a string to a floating point number.  Typical applications include reading foreign file types in their native format and then saving, reading, decrypting, and transmitting numeric data in their compressed binary form instead of in strings.<br/>
      Its inverse is Bin2F().
    </remarks>
    <example>
      This example saves the return value from the Seconds() function into a debugging binary file:
      <code language="X#">
        FUNCTION StoreData() AS LOGIC
        &#0009;LOCAL nh
        &#0009;LOCAL lSuccess := FALSE AS LOGIC
        &#0009;nh := FOpen2("debug.bin", FO_READWRITE)
        &#0009;// Assumes that file debug.doc already exists
        &#0009;IF nh != F_ERROR
        &#0009;&#0009;FWrite(nh, F2Bin(Seconds()))
        &#0009;&#0009;FClose(nh)
        &#0009;&#0009;lSuccess := TRUE
        &#0009;ELSE
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;ENDIF
        &#0009;RETURN lSuccess
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </f2bin>
  <fact>
    <summary>
      Calculate the factorial of a number.
    </summary>

    <param name="wValue">A positive number.</param>
    <returns>
    </returns>
    <remarks>
      The factorial of an integer n is computed as follows:
      <code language="X#">Factorial(n)=n*(n-1)*(n-2) ... 3*2*1</code>
      The factorial of 0 is defined to be 1.
    </remarks>
    <example>
      This example uses Fact() to compute the factorial of 5, then it verifies the result:
      <code language="X#">
        ? Fact(5)&#0009;&#0009;&#0009;&#0009;&#0009;// 120
        // Verify
        ? 5*4*3*2*1&#0009;&#0009;&#0009;&#0009;&#0009;// 120
      </code>
    </example>
  </fact>
  <fattr2string>
    <summary>
      Display file attributes as a string.
    </summary>

    <param name="dwAttributes">
      One or more of the following constants, indicating the file attribute(s) to return (file attributes are returned by FAttrib()):<br/>

      <br/>



      &#0009;Constant&#0009;Returns<br/>

      &#0009;FA_DIRECTORY&#0009;D<br/>

      &#0009;FA_VOLUME&#0009;V<br/>

      &#0009;FC_ARCHIVED&#0009;A<br/>

      &#0009;FC_HIDDEN&#0009;H<br/>

      &#0009;FC_NORMAL&#0009;NULL_STRING<br/>

      &#0009;FC_READONLY&#0009;R<br/>

      &#0009;FC_SYSTEM&#0009;S&#0009;
    </param>
    <returns>
      One or more of the characters indicated in the table above, depending upon what file attribute constants were specified in <paramref name="dwAttributes" />.<br/>
      If multiple attributes are present, the characters are concatenated as a string.  You can use the string search function, At(), to determine if a particular property is set (see example below).
    </returns>
    <remarks>
    </remarks>
    <example>
      This examples shows the return values from FAttr2String():
      <code language="X#">
        ? FAttr2String(FC_HIDDEN)&#0009;&#0009;&#0009;&#0009;&#0009;// H
        ? FAttr2String(FC_HIDDEN + FC_SYSTEM)&#0009;&#0009;// HS
      </code>
      This example uses FAttr2String() to find out if the file named ABC.DBF is a read-only file:
      <code language="X#">
        FFirst("abc.dbf", FC_NORMAL)
        IF At(FAttr2String(FAttrib()), "R") &gt; 0
        &#0009;// Attribute string contains "R" so file is read-only
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
  </fattr2string>
  <fattrib>
    <summary>
      Determine the attributes of the file found after FFCount(), FFirst(), or FNext().
    </summary>
    <returns>
      A value indicating the attributes of the current file.
      The constants in the following table can be used individually or added together to determine which attributes are applicable:
      Constant&#0009;Description&#0009;
      FA_DIRECTORY&#0009;Directory&#0009;
      FA_VOLUME&#0009;Volume&#0009;
      FC_ARCHIVED&#0009;Archived&#0009;
      FC_HIDDEN&#0009;Hidden&#0009;
      FC_NORMAL&#0009;Read/write&#0009;
      FC_READONLY&#0009;Read-only&#0009;
      FC_SYSTEM&#0009;System&#0009;
      Note:<br/>
      It is not uncommon for a file to have more than one attribute.<br/>
      For example, it may be read-only and archived, which would be represented as FC_READONLY + FC_ARCHIVED or _Or(FC_READONLY, FC_ARCHIVED).
    </returns>
    <remarks>
      Since FFCount() and FFirst() cannot distinguish files based on their read and archive attributes, FAttrib() can be useful in determining these attributes.<br/>
      For example, if FAttrib() returns FC_NORMAL, you know that the current file is read/write and not archived, and if it is FC_ARCHIVED (or FC_NORMAL + FC_ARCHIVED), you know the file is read/write and archived.
    </remarks>
    <example>
      This example uses FAttrib() in conjunction with FFirst() and FNext():
      <code language="X#">
        // Find the first file matching docu*.txt
        ? FFirst("docu*.txt", FC_NORMAL)
        ? FAttrib()&#0009;&#0009;&#0009;//  32 (FC_ARCHIVED)
        ? FNext()&#0009;&#0009;&#0009;&#0009;// Next file matching docu*.txt
        ? FAttrib()&#0009;&#0009;&#0009;//  33
        // 33 is FC_READONLY + FC_ARCHIVED
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FDate'>FDate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFCount'>FFCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFirst'>FFirst</seealso>
    <seealso cref='O:XSharp.Core.Functions.FName'>FName</seealso>
    <seealso cref='O:XSharp.Core.Functions.FNext'>FNext</seealso>
    <seealso cref='O:XSharp.Core.Functions.FSize'>FSize</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTime'>FTime</seealso>
  </fattrib>
  <fchsize>
    <summary>
      Change the size of a file opened with a low-level file function.
    </summary>

    <param name="ptrHandle">The handle of the open file whose size you want to change.</param>
    <param name="dwOffset">The new length to which the file should be set.</param>
    <returns>
      The new length of the file if successful; otherwise, F_ERROR.  FError() can be used to determine the specific error.
    </returns>
    <remarks>
      FChSize() truncates or extends a file to a specified length.<br/>
      The file should be open for writing and its handle must be available.<br/>
      If the file size is increased, null characters (Chr(0)) are appended.
    </remarks>
    <example>
      This example uses FChSize() in conjunction with FOpen2():
      <code language="X#">
        LOCAL hFile
        hFile := FOpen2("docs.txt", F0_READWRITE)
        IF hFile != F_ERROR
        &#0009;IF FChSize(hFile, 100) != F_ERROR
        &#0009;&#0009;? "Size successfully changed to 100"
        &#0009;ELSE
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;ENDIF
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
  </fchsize>
  <fclose>
    <summary>
      Close an open file and write the buffers to disk.
    </summary>

    <param name="ptrHandle">The handle of the open file you want to close.</param>
    <returns>
      FALSE if an error occurs while writing; otherwise, TRUE.
    </returns>
    <remarks>
      FClose() is a low-level file function that closes files and forces the associated buffers to be written to disk.<br/>
      If the operation fails, FClose() returns FALSE and FError() can be used to determine the specific error.<br/>
      For example, attempting to use FClose() with an invalid handle returns FALSE and FError() returns error 6, invalid handle.
    </remarks>
    <example>
      This example uses FClose() to close a newly created file and displays an error message if the close fails:
      <code language="X#">
        ptrHandle := FCreate("testfile", FC_NORMAL)
        IF !FClose(ptrHandle)
        &#0009;? DOSErrString(FError())
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
  </fclose>
  <fcommit>
    <summary>
      Flush file buffers.
    </summary>

    <param name="ptrHandle">The handle of the open file you want to flush.</param>
    <returns>
    </returns>
    <remarks>
      FCommit() writes to a file the contents of its buffers.<br/>
      If files are being shared in a multi-user or multi-tasking environment, FCommit() is helpful in allowing each user to see the latest contents of the file.<br/>
      The disk-write also protects you against possible data loss due to a system crash.
    </remarks>
    <example>
      This example uses FCommit() to ensure that buffers are written to the disk:
      <code language="X#">
        LOCAL ptrFile AS PTR
        ptrFile := FOpen2("myfile.txt", F0_READWRITE + FO_SHARED)
        FWrite3(ptrFile, Space(550), 550)
        // Keep other users/tasks updated
        FCommit(ptrFile)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FFlush'>FFlush</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
  </fcommit>
  <fcopy>
    <summary>
      Copy a file to a new file or to a device.
    </summary>

    <param name="cSourceFile">
      The name of the source file to copy, including an optional drive, directory, and extension.<br/>

      &#0009;If <paramref name="cSourceFile" /> does not exist, a runtime error is raised.<br/>
      If it exists, this function attempts to open the file in shared mode and, if successful, it proceeds.<br/>
      If access is denied because, for example, another process has exclusive use of the file, NetErr() is set to TRUE.
    </param>
    <param name="cTargetFile">
      The name of the target file, including an optional drive, directory, and extension.<br/>

      &#0009;If <paramref name="cTargetFile" /> does not exist, it is created.<br/>
      If it exists, this function attempts to open the file in exclusive mode and, if successful, the file is overwritten without warning or error.<br/>
      If access is denied because, for example, another process is using the file, NetErr() is set to TRUE.  <br/>

      &#0009;See SetDefault() and SetPath() for file searching and creation rules.<br/>
      This function does not supply a default extension for either file name.<br/>

      &#0009;<paramref name="cTargetFile" /> can also be the name of the target device specified without a trailing colon.  When you specify one of the following device names: PRN, LPT1, LPT2, LPT3, COM1, or COM2, FCopy() searches the Windows registry for a Device entry to use for the printing device.<br/>
      If there is no Device entry, it looks for the Devices entries and presents the user with a list box of devices from which to choose.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      FCopy() is the functional form of the COPY FILE command.
    </remarks>
    <example>
      This example copies a file from the default drive and directory into MYDIR directory on the D drive:
      <code language="X#">? FCopy("thisfile.txt",; "d:\mydir\thisfile.txt")</code>
    </example>
    <seealso >COPY FILE</seealso>
    <!--<seealso href="XSharp.chm::/command_copy_file.html" >COPY FILE</seealso>
    <seealso href="ms-its:XSharp.chm::/command_copy_file.html" >COPY FILE</seealso>
    <seealso href="MSITStore:XSharp.chm::/command_copy_file.html" >COPY FILE</seealso>
    <seealso href="mk:@ms-its:XSharp.chm::/command_copy_file.html" >COPY FILE</seealso>
    <seealso href="mk:MSITStore::XSharp.chm::/command_copy_file.html" >COPY FILE</seealso>-->
    <seealso cref='O:XSharp.Core.Functions.DiskSpace'>DiskSpace</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDefault'>SetDefault</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPath'>SetPath</seealso>
  </fcopy>
  <fcount>
    <summary>
      Return the number of fields in the current database file.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      If there is no database file open, FCount() returns 0.
    </returns>
    <remarks>
      FCount() is useful in applications containing data-independent programs that can operate on any database file.<br/>
      These include generalized import/export and reporting programs.  Typically, you use FCount() to establish the upper limit of a FOR...NEXT or DO WHILE loop that processes a single field at a time.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      This example uses FCount() to return the number of fields in the current and an unselected work area:
      <code language="X#">
        USE Sales NEW
        USE Customer NEW
        ? FCount()&#0009;&#0009;&#0009;&#0009;&#0009;// Result: 5
        ? Sales -&gt;(FCount())&#0009;&#0009;&#0009;// Result: 8
      </code>
      This example uses FCount() to declare an array with field information:
      <code language="X#">
        LOCAL aFields := ARRAY(FCount())
        AFields(aFields)
      </code>
      This example uses FCount() as the upper boundary of a FOR loop that processes the list of current work area fields:
      <code language="X#">
        LOCAL nField
        USE Sales NEW
        FOR nField := 1 UPTO FCount()
        &#0009;? FIELDNAME(nField)
        NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AFields'>AFields</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldName'>FieldName</seealso>
    <seealso cref='O:XSharp.RT.Functions.Type'>Type</seealso>
  </fcount>
  <fcreate>
    <summary>
      Create a file or open and truncate an existing file.
    </summary>

    <param name="cFileName">
      The name of the file to create, including an optional drive, directory, and extension.  SetDefault() and SetPath() settings are ignored; the Windows default is used unless you specify a drive and directory as part of the file name.  No extension is assumed.<br/>
      If the file already exists, its length is truncated to 0 without warning.<br/>

      &#0009;This function sets NetErr() in case of a concurrency control conflict.
    </param>
    <param name="kAttributes">
      One of the following constants indicating the attribute to be set when creating the file:<br/>

      &#0009;Constant&#0009;Description<br/>

      &#0009;FC_ARCHIVED&#0009;Archived file<br/>

      &#0009;FC_HIDDEN&#0009;Hidden file<br/>

      &#0009;FC_NORMAL&#0009;Normal read/write file<br/>

      &#0009;FC_READONLY&#0009;Read-only file<br/>

      &#0009;FC_SYSTEM&#0009;System file&#0009;
    </param>
    <returns>
      The DOS file handle number of the new file.<br/>
      If an error occurs, FCreate() returns  F_ERROR.  FError() can be used to determine the specific error.
    </returns>
    <remarks>
      FCreate() is a low-level file function that either creates a new file or opens an existing file and truncates it to 0 length.<br/>
      If <paramref name="cFileName" /> does not exist, it is created and opened for writing.<br/>
      If it does exist and can be opened for writing, it is truncated to 0 length.
      When FCreate() successfully creates a new file, the file is left open in compatibility sharing mode and read/write access mode.<br/>
      The file attribute specified by <paramref name="nAttribute" /> is applied to the new file when it is closed, allowing you to write to a newly created read-only file.<br/>
      For a list of access modes, see FOpen().
      Since a file handle is required in order to identify an open file to other file functions, always assign the return value from FCreate() to a variable for later use.
    </remarks>
    <example>
      This example creates a file called TESTFILE and opens it for reading and writing:
      <code language="X#">
        IF (ptrHandle := FCreate("testfile")) = F_ERROR
        &#0009;? DOSErrString(FError())
        ELSE
        &#0009;FWrite(ptrHandle, "Hello there")
        &#0009;FClose(ptrHandle)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate2'>FCreate2</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
  </fcreate>
  <fcreate2>
    <summary>
      Create a file or open and truncate an existing file, specifying two strongly typed arguments.
    </summary>

    <param name="cFileName">
      The name of the file to create, including an optional drive, directory, and extension.  SetDefault() and SetPath() settings are ignored; the Windows default is used unless you specify a drive and directory as part of the file name.  No extension is assumed.<br/>
      If the file already exists, its length is truncated to 0 without warning.<br/>

      &#0009;This function sets NetErr() in case of a concurrency control conflict.
    </param>
    <param name="dwAttributes">
      One of the following constants indicating the attribute to be set when creating the file:<br/>

      &#0009;Constant&#0009;Description<br/>

      &#0009;FC_ARCHIVED&#0009;Archived file<br/>

      &#0009;FC_HIDDEN&#0009;Hidden file<br/>

      &#0009;FC_NORMAL&#0009;Normal read/write file<br/>

      &#0009;FC_READONLY&#0009;Read-only file<br/>

      &#0009;FC_SYSTEM&#0009;System file&#0009;
    </param>
    <returns>
      The DOS file handle number of the new file.<br/>
      If an error occurs, FCreate2() returns  F_ERROR.  FError() can be used to determine the specific error.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example creates a file called TESTFILE.TXT and opens it for reading and writing:
      <code language="X#">
        ptrHandle := FCreate2("testfile.txt", FC_NORMAL)
        IF ptrHandle = F_ERROR
        &#0009;? DOSErrString(FError())
        ELSE
        &#0009;FWrite(ptrHandle, "Hello there")
        &#0009;FClose(ptrHandle)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
  </fcreate2>
  <fdate>
    <summary>
      Return the date stamp of the file found by FFCount(), FFirst(), or FNext().
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses FDate() to find out when files were last updated:
      <code language="X#">
        // Find the first file matching *.txt
        IF FFirst("*.txt", FC_NORMAL)
        &#0009;? FDate()&#0009;&#0009;&#0009;&#0009;&#0009;// 08/13/98
        ENDIF
        // Next file matching *.txt
        IF FNext()&#0009;&#0009;&#0009;&#0009;
        &#0009;? FDate()&#0009;&#0009;&#0009;&#0009;&#0009;// 08/21/98
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFCount'>FFCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFirst'>FFirst</seealso>
    <seealso cref='O:XSharp.Core.Functions.FName'>FName</seealso>
    <seealso cref='O:XSharp.Core.Functions.FNext'>FNext</seealso>
    <seealso cref='O:XSharp.Core.Functions.FSize'>FSize</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTime'>FTime</seealso>
  </fdate>
  <feof>
    <summary>
      Determine if the file pointer is positioned at the end-of-file.
    </summary>

    <param name="ptrHandle">The handle of an open file.</param>
    <returns>
      TRUE if the file pointer is at end-of-file; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example checks for end-of-file after attempting to move 101 bytes:
      <code language="X#">
        LOCAL ptrHandle AS PTR
        ptrHandle := FOpen("docu.txt")
        FSeek(ptrHandle, 101)
        ? FEOF(ptrHandle)
      </code>
      This example reads the entire file, one line at a time, until it reaches the end-of-file:
      <code language="X#">
        ptrHandle := FOpen2("docs.txt", FO_READ)
        IF ptrHandle != F_ERROR
        &#0009;DO WHILE !FEOF(ptrHandle)
        &#0009;&#0009;? FReadLine2(ptrHandle, 80)
        &#0009;ENDDO
        ENDIF
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTell'>FTell</seealso>
  </feof>
  <ferase>
    <summary>
      Delete a file from disk.
    </summary>

    <param name="cFileName">The file name, including an optional drive, directory, and extension.  SetDefault() and SetPath() settings are ignored; the Windows default is used unless you specify a drive and directory as part of the file name.  No extension is assumed.</param>
    <returns>
      TRUE if the operation succeeds; otherwise, FALSE.  In the case of a failure, FError() can be used to determine the specific error.
    </returns>
    <remarks>
      FErase() is the same as the ERASE command but returns a value and can be specified within an expression.
      Warning!  Files must be closed before removing them with FErase().
    </remarks>
    <example>
      This example deletes a set of files matching a wildcard pattern:
      <code language="X#">
        AEval(Directory("*.bak"), {|aFile|;
        &#0009;&#0009;&#0009;&#0009;FErase(aFile[F_NAME])})
      </code>
      This example erases a file and displays a message if the operation fails:
      <code language="X#">
        IF .NOT. FErase("afile.txt")
        &#0009;? DOSErrString(FError())
        ENDIF
      </code>
    </example>
    <seealsocmd>CLOSE</seealsocmd>
    <seealsocmd>ERASE</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FRename'>FRename</seealso>
  </ferase>
  <ferror>
    <summary>
      Get or set the error code for a file operation.
    </summary>

    <param name="nError">
      A subsequent error code to set FError() to.<br/>
      These are additional error codes used by X#:
    </param>
    <param name="Error">Meaning&#0009;</param>
    <param name="256">Disk full&#0009;</param>
    <param name="257">EOF was already reached when a read was tried&#0009;</param>
    <returns>
      The error from the last file operation or the last user-specified setting.<br/>
      If there was no error, FError() returns 0.
    </returns>
    <remarks>
      FError() is a low-level file function that indicates an error after a file function is used.<br/>
      These functions include FClose(), FCreate(), FErase(), FOpen(), FRead(), FReadStr(), and FRename().  FError() retains its value until the next execution of a file function.
    </remarks>
    <example>
      This example tests FError() after the creation of a file and displays an error message if the create fails:
      <code language="X#">
        ptrHandle := FCreate("temp.txt", FC_NORMAL)
        IF ptrHandle == F_ERROR
        &#0009;? FError()
        &#0009;? DOSErrString(FError())
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.DosError'>DOSError</seealso>
    <seealso cref='O:XSharp.Core.Functions.DosErrString'>DOSErrString</seealso>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FErase'>FErase</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.FRename'>FRename</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.GetDosError'>GetDOSError</seealso>
  </ferror>
  <ffcount>
    <summary>
      Return the number of files that match a given file specification and attribute.
    </summary>

    <param name="pszFileSpec">
      The names of the files to include, including an optional drive, directory, and extension.<br/>
      The file name and extension can include the standard wildcard characters (* and ?).<br/>
      If the drive and directory are omitted, the Windows default is used.
    </param>
    <param name="dwAttributes">
      One or more of the following constants indicating the file attributes to be used with <paramref name="pszFileSpec" /> as search criteria:<br/>

      <br/>



      &#0009;Constant&#0009;Description<br/>

      &#0009;FA_DIRECTORY&#0009;Directory<br/>

      &#0009;FA_VOLUME&#0009;Volume<br/>

      &#0009;FC_HIDDEN&#0009;Hidden<br/>

      &#0009;FC_NORMAL&#0009;Visible<br/>

      &#0009;FC_SYSTEM&#0009;System<br/>

      &#0009;To specify more than one constant, you can either add attributes together, as in FC_SYSTEM + FC_HIDDEN, or use the _Or() operator, as in _Or(FC_SYSTEM, FC_HIDDEN).<br/>

      &#0009;<paramref name="dwAttributes" /> specifies a criterion to satisfy in addition to any "visible" files that match the <paramref name="pszFileSpec" />.  Visible files do not include directories, volumes, or hidden or system files — all other files are visible, regardless of the status of their read or archive attributes.<br/>
      To include only visible files, use FC_NORMAL as the <paramref name="dwAttributes" /> argument.<br/>

      &#0009;Note:To specify volume labels only, to the exclusion of all other files, specify FA_VOLUME as the sole <paramref name="dwAttributes" /> argument.
    </param>
    <returns>
      The number of files matching the specified criteria.<br/>
      If no match is found, it returns zero.
    </returns>
    <remarks>
      FFCount() also finds the first file matching the specified criteria.<br/>
      Therefore, it is not necessary to call FFirst() immediately after FFCount().  Instead, retrieve the necessary information about the first matching file using other related functions (such as FName(), FSize(), FAttrib(), FTime(), or FDate()), then call FNext() to move on to the next file.<br/>
      This technique is illustrated in the example below.
    </remarks>
    <example>
      This example uses FFCount() in conjunction with FNext() and FName() to display all files matching "C:\DOCS\*.TXT":
      <code language="X#">
        dwMatches := FFCount("c:\docs\*.txt", FC_NORMAL)
        FOR i:= 1 UPTO dwMatches
        &#0009;? FName()
        &#0009;FNext()
        NEXT
      </code>
      This example illustrates the <paramref name="dwAttributes" /> argument, extending the file search to include hidden files and directories, as well as visible files:
      <code language="X#">
        dwCnt := FFCount("c:\i*.*", FC_HIDDEN + FA_DIRECTORY)
        FOR i:= 1 UPTO dwCnt
        &#0009;? FName()
        &#0009;FNext()
        NEXT
      </code>
    </example>
    <seealsocmd>_Or</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
    <seealso cref='O:XSharp.RT.Functions.FCount'>FCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.FDate'>FDate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFirst'>FFirst</seealso>
    <seealso cref='O:XSharp.Core.Functions.FName'>FName</seealso>
    <seealso cref='O:XSharp.Core.Functions.FNext'>FNext</seealso>
    <seealso cref='O:XSharp.Core.Functions.FSize'>FSize</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTime'>FTime</seealso>
    <seealso cref='O:XSharp.Core.Functions.GetFAttr'>GetFAttr</seealso>
    <seealso cref='O:XSharp.Core.Functions.GetFMask'>GetFMask</seealso>
  </ffcount>
  <ffirst>
    <summary>
      Find the first file that matches a given file specification or attribute.
    </summary>

    <param name="pszFileSpec">
      The file specification for the search.  Besides a file name, this specification can include an optional drive, directory, and extension.<br/>
      The file name and extension can include the standard wildcard characters (* and ?).<br/>
      If the drive and directory are omitted, the Windows default is used.
    </param>
    <param name="kAttributes">
      One or more of the following constants indicating the file attributes to be used with <paramref name="pszFileSpec" /> as search criteria:<br/>

      &#0009;Constant&#0009;Description<br/>

      &#0009;FA_DIRECTORY&#0009;Directory<br/>

      &#0009;FA_VOLUME&#0009;Volume<br/>

      &#0009;FC_HIDDEN&#0009;Hidden<br/>

      &#0009;FC_NORMAL&#0009;Visible<br/>

      &#0009;FC_SYSTEM&#0009;System<br/>

      &#0009;To specify more than one constant, you can either add attributes together, as in FC_SYSTEM + FC_HIDDEN, or use the _Or() operator, as in _Or(FC_SYSTEM, FC_HIDDEN).<br/>

      &#0009;<paramref name="kAttributes" /> specifies a criterion to satisfy in addition to any "visible" files that match the <paramref name="pszFileSpec" />.  Visible files do not include directories, volumes, or hidden or system files — all other files are visible, regardless of the status of their read or archive attributes.<br/>
      To include only visible files, use FC_NORMAL as the <paramref name="kAttributes" /> argument.<br/>

      &#0009;Note:To specify volume labels only, to the exclusion of all other files, specify FA_VOLUME as the sole <paramref name="kAttributes" /> argument.
    </param>
    <returns>
      TRUE if a match is found; otherwise, FALSE.
    </returns>
    <remarks>
      FFirst() gets the first matching file; use FNext() to find subsequent matching files.
      FFCount() returns the number of matches.  FAttrib(), FDate(), FName(), FSize(), and FTime() return the attribute, date stamp, name, size, and time stamp of the matching file, respectively.
    </remarks>
    <example>
      This example uses FFirst() to find a file:
      <code language="X#">
        IF FFirst("c:\docs\*.txt", FC_NORMAL)
        &#0009;? "A file was found"
        ELSE
        &#0009;? "A file was not found"
        ENDIF
      </code>
      This example illustrates the <paramref name="kAttributes" /> argument, extending the file search to include hidden files and directories, as well as visible files:
      <code language="X#">
        IF FFirst("c:\i*.*", FC_HIDDEN + FA_DIRECTORY)
        &#0009;? "A file was found"
        ELSE
        &#0009;? "A file was not found"
        ENDIF
      </code>
    </example>
    <seealsocmd>_Or</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
    <seealso cref='O:XSharp.Core.Functions.FDate'>FDate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFCount'>FFCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.FName'>FName</seealso>
    <seealso cref='O:XSharp.Core.Functions.FNext'>FNext</seealso>
    <seealso cref='O:XSharp.Core.Functions.FSize'>FSize</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTime'>FTime</seealso>
    <seealso cref='O:XSharp.Core.Functions.GetFAttr'>GetFAttr</seealso>
    <seealso cref='O:XSharp.Core.Functions.GetFMask'>GetFMask</seealso>
  </ffirst>
  <fflock>
    <summary>
      Lock a portion of an open file.
    </summary>

    <param name="ptrHandle">The handle of the open file you want to lock.</param>
    <param name="offset">
      The file offset at which to start locking.<br/>
      A value of zero corresponds to the first byte of the file.
    </param>
    <param name="length">The number of bytes to lock.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      FFLock() locks a specified portion of a file.<br/>
      This prevents other processes from accessing that portion.
      More than one portion of a file can be locked, but the same byte should not be locked more than once.<br/>
      It is also possible to lock past the end of a file.<br/>
      This allows you to append to a file in a multi-user environment.
    </remarks>
    <example>
      This example uses FFLock() to lock 100 bytes of a file starting at offset 300:
      <code language="X#">
        ptrHandle := FOpen2("c:\data\myfile.txt", ;
        &#0009;&#0009;FO_READWRITE + FO_SHARED)
        IF FFLock(ptrHandle, 300, 100)
        &#0009;? "Locked OK"
        ENDIF
      </code>
      This example implements an FFLock() with an optional retry:
      <code language="X#">
        FUNCTION FileLock(ptrHandle AS PTR,;
        &#0009;&#0009;dwOffset AS DWORD, dwLength AS DWORD,;
        &#0009;&#0009;wSeconds AS DWORD) AS LOGIC PASCAL
        &#0009;LOCAL lForever AS LOGIC
        &#0009;IF FFLock(ptrHandle, dwOffset, dwLength)
        &#0009;&#0009;RETURN TRUE&#0009;&#0009;&#0009;// Locked
        &#0009;ENDIF
        &#0009;// If wSeconds is zero, retry until successful
        &#0009;lForever := (wSeconds = 0)
        &#0009;DO WHILE (lForever .OR. wSeconds &gt; 0)
        &#0009;&#0009;IF FFLock(ptrHandle, dwOffset, dwLength)
        &#0009;&#0009;&#0009;RETURN TRUE&#0009;// Locked
        &#0009;&#0009;ENDIF
        &#0009;&#0009;InKey(.5)&#0009;&#0009;&#0009;// Wait up
        &#0009;&#0009;nSeconds -= 1
        &#0009;ENDDO
        &#0009;RETURN FALSE&#0009;&#0009;&#0009;&#0009;// Not locked
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FFUnLock'>FFUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
  </fflock>
  <fflush>
    <summary>
      Flush to disk a file opened with a low-level file function.
    </summary>

    <param name="ptrHandle">The handle of the open file you want to flush.</param>
    <param name="lCommit">When you pass TRUE for this parameter then also all intermediate buffers are flushed.</param>
    <returns>
    </returns>
    <remarks>
      FFlush() writes buffers to disk, thus releasing the memory used by those buffers.<br/>
      If files are being shared in a multi-user or multi-tasking environment, FFlush() allows each user to see the latest contents of the file.
      By flushing data from memory, FFlush() can also protect against possible data loss due to a system crash.
      Calling the method with 2 parameters and a second parameter with the value TRUE will significantly slow down your apps!
      The with 1 parameter works the same as calling FFlush() with a value of FALSE for the second parameter.
    </remarks>
    <example>
      This example uses FFlush() to flush data automatically after waiting for a key press:
      <code language="X#">
        ptrHandle := FOpen2("docs.txt", ;
        &#0009;&#0009;FO_READWRITE + FO_SHARED)
        IF ptrHandle != F_ERROR
        &#0009;FWrite(ptrHandle, Space(100))&#0009;
        &#0009;nKey := Inkey(50)
        &#0009;FFlush(ptrHandle)&#0009;&#0009;&#0009;// Save data
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FCommit'>FCommit</seealso>
  </fflush>
  <ffunlock>
    <summary>
      UnLock a portion of an opened file.
    </summary>

    <param name="ptrHandle">The handle of the opened file you want to unlock.</param>
    <param name="offset">The file offset at which to start unlocking.</param>
    <param name="length">The number of bytes to unlock.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      FFUnLock() unlocks a specified portion of a file.<br/>
      This permits other processes to access that portion.<br/>
      The unlocked portion must have been previously locked.
    </remarks>
    <example>
      This example uses FFLock() and FFUnLock() to lock and then unlock the first 300 bytes of a file:
      <code language="X#">
        ptrHandle := FOpen2("c:\data\myfile.txt", ;
        &#0009;&#0009;FO_READWRITE + FO_SHARED)
        IF FFLock(ptrHandle, 0, 300)
        &#0009;? "Locked OK"
        &#0009;IF FFUnLock(ptrHandle, 0, 300)
        &#0009;&#0009;? "UnLocked OK"
        &#0009;ENDIF
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FFLock'>FFLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
  </ffunlock>
  <fgets>
    <summary>
      Read a line from an open file.
    </summary>

    <param name="ptrHandle">The handle of the file to read from.</param>
    <param name="nMax">
      The maximum number of characters to read per line.  FGets() will read until a hard carriage return (Chr(13)) is reached, end-of-file is encountered, or <paramref name="nMax" /> characters are read.<br/>
      The default value for <paramref name="nMax" /> is 256.
    </param>
    <returns>
      The line read.  When the end-of-file is reached, FGets() returns a NULL_STRING and FError() is set to 257.
    </returns>
    <remarks>
      This function is the same as FReadLine().  Both functions are assumed to handle raw binary data and are not dependent upon the status of SetAnsi().  FReadText() and FRead4(), on the other hand, are dependent upon SetAnsi().
    </remarks>
    <example>
      This example uses FGets() to read an entire file without specifying a value for <paramref name="nMax" />:
      <code language="X#">
        ptrHandle := FOpen2("docs.txt", FO_READ)
        IF ptrHandle != F_ERROR
        &#0009;DO WHILE !FEOF(ptrHandle)
        &#0009;&#0009;? FGets(ptrHandle)
        &#0009;ENDDO
        ENDIF
        FClose(ptrHandle)
      </code>
      The following example provides a utility that displays and counts all occurrences of a string within a file:
      <code language="X#">
        FUNCTION Grep(cSearch, cFile AS STRING) ;
        &#0009;&#0009;AS DWORD PASCAL
        &#0009;LOCAL handle AS PTR
        &#0009;LOCAL Count AS DWORD
        &#0009;LOCAL Line AS STRING
        &#0009;handle := FOpen2(cFile, FO_READ)
        &#0009;cSearch := Upper(cSearch)
        &#0009;DO WHILE !FEOF(handle)
        &#0009;&#0009;line := Upper(FGets(handle))
        &#0009;&#0009;IF InStr(cSearch, line)
        &#0009;&#0009;&#0009;? line
        &#0009;&#0009;&#0009;Count += 1
        &#0009;&#0009;ENDIF
        &#0009;ENDDO
        &#0009;RETURN Count
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FGetS2'>FGets2</seealso>
    <seealso cref='O:XSharp.RT.Functions.FReadLine'>FReadLine</seealso>
  </fgets>
  <fgets2>
    <summary>
      Read a line from an open file, specifying two strongly typed arguments.
    </summary>

    <param name="ptrHandle">The handle of the file to read from.</param>
    <param name="dwMax">
      The maximum number of characters to read per line.  FGets2() will read until a hard carriage return (Chr(13)) is reached, end-of-file is encountered, or <paramref name="dwMax" /> characters are read.<br/>
      The default value for <paramref name="dwMax" /> is 256.
    </param>
    <returns>
      The line read.  When the end-of-file is reached, FGets2() returns a NULL_STRING and FError() is set to 257.
    </returns>
    <remarks>
      This function is the same as FReadLine2().  Both functions are assumed to handle raw binary data and are not dependent upon the status of SetAnsi().  FReadText() and FRead4(), on the other hand, are dependent upon SetAnsi().
    </remarks>
    <example>
      This example uses FGets2() to read an entire file with a maximum of 80 characters per line:
      <code language="X#">
        ptrHandle := FOpen2("docs.txt", FO_READ)
        IF ptrHandle != F_ERROR
        &#0009;DO WHILE !FEOF(ptrHandle)
        &#0009;&#0009;? FGets2(ptrHandle, 80)
        &#0009;ENDDO
        ENDIF
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FGetS'>FGets</seealso>
    <seealso cref='O:XSharp.RT.Functions.FReadLine'>FReadLine</seealso>
  </fgets2>
  <fieldblock>
    <summary>
      Return a set-get code block for a field that is identified by its name.
    </summary>

    <param name="cFieldName">
      The name of the field to which the set-get block will refer.  When executed with an argument, the code block created by this function assigns the value of the argument to <paramref name="cFieldName" />.<br/>
      If omitted, the code block retrieves the value of <paramref name="cFieldName" />.
    </param>
    <returns>
      A runtime code block (implemented as an object) that, when evaluated, sets (assigns) or gets (retrieves) the value of the given field.<br/>
      If <paramref name="cFieldName" /> does not exist in the current work area, FieldBlock() returns NULL_OBJECT.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      Note that the specified field variable does not have to exist when the code block is created but must exist before the code block is executed.
      <note type="tip">
        Work area:<br/>
        The code block returned by FieldBlock() sets or gets the value of the specified field in whatever work area is current when the block is run.<br/>
        For example, given work areas 1 and 2, both containing field FName:
        <code language="X#">
          DBSetSelect(1)
          _FIELD-&gt;FName := "Kate"
          DBSetSelect(2)
          _FIELD-&gt;FName := "Cindy"
          cbFName := FieldBlock("FName")
          DBSetSelect(1)
          ? EVAL(cbFName)&#0009;&#0009;&#0009;&#0009;&#0009;// "Kate"
          DBSetSelect(2)
          ? EVAL(cbFName)&#0009;&#0009;&#0009;&#0009;&#0009;// "Cindy"
        </code>
        Use FieldWBlock() to provide a set-get block for a field in a specific work area.
      </note>
    </remarks>
    <example>
      This example compares FieldBlock() to a code block created using the macro operator.  Note that using FieldBlock() avoids the speed and size overhead of the macro operator:
      <code language="X#">
        // Set-Get block defined using macro operator
        cbSetGet := &amp;("{|SetVal| If(SetVal == NIL,;
        &#0009;&#0009;&#0009;&#0009;&#0009; FName, FName := SetVal)}")
        // Set-Get block defined using FieldBlock()
        // cbSetGet created here is the functional
        // equivalent of cbSetGet above
        cbSetGet := FieldBlock("FName")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldBlockSym'>FieldBlockSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldWBlock'>FieldWBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarBlock'>MemVarBlock</seealso>
  </fieldblock>
  <fieldblocksym>
    <summary>
      Return a set-get code block for a field that is identified by a symbol.
    </summary>

    <param name="symFieldName">
      A symbol that is the name of the field to which the set-get block will refer.  When executed with an argument, the code block created by this function assigns the value of the argument to <paramref name="symFieldName" />.<br/>
      If omitted, the code block retrieves the value of <paramref name="symFieldName" />.
    </param>
    <returns>
      A runtime code block (implemented as an object) that, when evaluated, sets (assigns) or gets (retrieves) the value of the given field.<br/>
      If <paramref name="symFieldName" /> does not exist in the current work area, FieldBlockSym() returns NULL_OBJECT.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      Note that the specified field variable does not have to exist when the code block is created but must exist before the code block is executed.
      <note type="tip">
        Work area:<br/>
        The code block returned by FieldBlockSym() sets or gets the value of the specified field in whatever work area is current when the block is run.<br/>
        For example, given work areas 1 and 2, both containing field FName:
        <code language="X#">
          DBSetSelect(1)
          _FIELD-&gt;FName := "Kate"
          DBSetSelect(2)
          _FIELD-&gt;FName := "Cindy"
          cbFName := FieldBlockSym(#FNAME)
          DBSetSelect(1)
          ? EVAL(cbFName)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// "Kate"
          DBSetSelect(2)
          ? EVAL(cbFName)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// "Cindy"
        </code>
        Use FieldWBlock() to provide a set-get block for a field in a specific work area.
      </note>
    </remarks>
    <example>
      This example compares FieldBlockSym() to a code block created using the macro operator.  Note that using FieldBlockSym() avoids the speed and size overhead of the macro operator:
      <code language="X#">
        // Set-Get block defined using macro operator
        cbSetGet := &amp;("{|SetVal| If(SetVal == NIL, FName, FName := SetVal)}")
        // Set-Get block defined using FieldBlockSym()
        String2Symbol("FName")
        cbSetGet := FieldBlockSym(#FNAME)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldBlock'>FieldBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldWBlock'>FieldWBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarBlock'>MemVarBlock</seealso>
  </fieldblocksym>
  <fieldget>
    <summary>
      Get the contents of a field that is identified by its position.
    </summary>

    <param name="nFieldPos">The position of the field in the database file structure for the current work area.</param>
    <returns>
      The value of the specified field.<br/>
      If <paramref name="nFieldPos" /> does not correspond to the position of any
      field in the current database file, FieldGet() will generate a runtime error. Only in the Xbase++ dialect a NIL will be returned.
    </returns>
    <remarks>
      FieldGet() retrieves the value of a field using its position within the database file structure rather than its field name.  Within generic database service functions this allows, among other things, the retrieval of field values without use of the macro operator.
      <note type="tip">
        FieldGet() can be used with a BLOB field (that is, a memo field associated with a BLOB file), provided the length of the field does not exceed 64 KB.<br/>
        For BLOB fields longer than 64 KB, use the BLOBGet() function instead.
      </note>
    </remarks>
    <example>
      This example compares FieldGet() to functionally equivalent code that uses the macro operator to retrieve the value of a field:
      <code language="X#">
        LOCAL nFieldPos := 1, FName, FVal
        USE customer NEW
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Using macro operator
        FName := FIELDNAME(nFieldPos)&#0009;&#0009;&#0009;// Get field name
        FVal := &amp;FName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Get field value
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Using FieldGet()
        FVal := FieldGet(nFieldPos)&#0009;&#0009;&#0009;&#0009;// Get field value
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBGet'>BLOBGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetSym'>FieldGetSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPut'>FieldPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutSym'>FieldPutSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldGet'>VODBFieldGet</seealso>
  </fieldget>
  <fieldgetalias>
    <summary>
      Get the contents of a field that is identified by a work area alias and the field name.
    </summary>

    <param name="symAlias">The work area alias.</param>
    <param name="symFieldName">The field name.</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses FieldGetAlias() to query the contents of fields in two work areas:
      <code language="X#">
        USE region1 NEW
        USE region2 NEW
        SELECT region1
        _FIELD-&gt;FName := "Kate"
        SELECT region2
        _FIELD-&gt;FName := "Cindy"
        QOut(FieldGetAlias(#REGION1, #FNAME))&#0009;// Kate
        QOut(FieldGetAlias(#REGION2, #FNAME))&#0009;// Cindy
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetArea'>FieldGetArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldGet'>VODBFieldGet</seealso>
  </fieldgetalias>
  <fieldgetarea>
    <summary>
      Get the contents of a field that is identified by its work area and a symbol.
    </summary>

    <param name="dwWorkArea">
      The work area in which <paramref name="symFieldName" /> is located.
    </param>
    <param name="symFieldName">A symbol that corresponds to the field name.</param>
    <returns>
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example uses FieldGetArea():
      <code language="X#">
        USE region1 NEW
        nSelect1 := VODBGetSelect()
        USE region2 NEW
        nSelect2 := VODBGetSelect()
        VODBSetSelect(nSelect1)
        _FIELD-&gt;FName := "Kate"
        VODBSetSelect(nSelect2)
        _FIELD-&gt;FName := "Cindy"
        // The following line prints Kate
        ? FieldGetArea(nSelect1, #FNAME)
        // The following line prints Cindy
        ? FieldGetArea(nSelect2, #FNAME)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldGet'>VODBFieldGet</seealso>
  </fieldgetarea>
  <fieldgetsym>
    <summary>
      Retrieve the contents of a field that is identified by its symbolic name.
    </summary>

    <param name="symField">The symbolic name of the field in the database file structure for the current work area.</param>
    <returns>
      The value of the specified field.<br/>
      If <paramref name="symField" /> does not correspond to a field in the current database file, FieldGetSym() returns NIL.
    </returns>
    <remarks>
      FieldGetSym() retrieves the value of a field using its symbolic field name within the database file structure, rather than the string representation of the field name.
      Note:  FieldGetSym() can be used with a BLOB field (that is, a memo field associated with a BLOB file), provided the length of the field does not exceed 64KB.<br/>
      For BLOB fields longer than 64KB, use the BLOBGet() function instead.
    </remarks>
    <example>
      This example retrieves the contents of the Lastname field in the TestDBF database:
      <code language="X#">
        USE TestDBF NEW
        DO WHILE !EOF()
        &#0009;? FieldGetSym(#Lastname)&#0009;// Smith
        &#0009;Skip
        ENDDO
        USE
        WAIT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBGet'>BLOBGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutSym'>FieldPutSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldGet'>VODBFieldGet</seealso>
  </fieldgetsym>
  <fieldname>
    <summary>
      Return the name of a field as a string.
    </summary>
    <param name="dwFieldPos">The position of the field in the database file structure.</param>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      The name of the specified field as a string.<br/>
      If <paramref name="dwFieldPos" /> does not correspond to an existing field in the database file or if no database file is open, FieldName() returns a NULL_STRING.
    </returns>
    <remarks>
      FieldName() returns a field name using an index to the position of the field name in the database structure.<br/>
      Use it in data-independent applications where the field name is unknown.<br/>
      If information for more than one field is required, use DBStruct().
      If you need additional database file structure information, use Type() and Len().<br/>
      For example, to obtain the number of decimal places for a numeric field, use the following expression:
      <code language="X#">
        Len(Substr(Str(<paramref name="idField" />), RAt(".", Str(<paramref name="idField" />)) + 1))
      </code>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      These examples illustrate FieldName() used with several other functions:
      <code language="X#">
        USE sales
        QOut(FIELDNAME(1))&#0009;&#0009;&#0009;&#0009;// Result: BRANCH
        QOut(FCount())&#0009;&#0009;&#0009;&#0009;&#0009;// Result: 5
        QOut(LEN(FIELDNAME(0)))&#0009;&#0009;&#0009;// Result: 0
        QOut(LEN(FIELDNAME(40)))&#0009;&#0009;&#0009;// Result: 0
      </code>
      This example uses FieldName() to list the name and type of each field in CUSTOMER.DBF:
      <code language="X#">
        USE customer NEW
        FOR nField := 1 UPTO FCount()
        &#0009;? FIELDNAME(nField), DBFieldInfo(DBS_TYPE, nField)
        NEXT
      </code>
      This example accesses fields in unselected work areas using aliased expressions:
      <code language="X#">
        USE sales NEW
        USE customer NEW
        USE invoices NEW
        QOut(Sales-&gt;FIELDNAME(1))&#0009;&#0009;// Result: SaleNum
        QOut(Customer-&gt;FIELDNAME(1))&#0009;&#0009;// Result: CustNum
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbStruct'>DBStruct</seealso>
    <seealso cref='O:XSharp.RT.Functions.FCount'>FCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldSym'>FieldSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.RT.Functions.Type'>Type</seealso>
    <seealso cref='O:XSharp.RT.Functions.ValType'>ValType</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldInfo'>VODBFieldInfo</seealso>
  </fieldname>
  <fieldpos>
    <summary>
      Return the position of a field.
    </summary>
    <param name="cFieldName">The name of the field.</param>
    <param name="nArea">
      Specifies the work area number for the table.
    </param>
    <returns>
      The position of the specified field within the list of fields associated with the work area.<br/>
      If the work area has no field with the specified name, FieldPos() returns 0.
    </returns>
    <remarks>
      FieldPos() is the inverse of the FieldName() function.  FieldPos() is most often used with the FieldPut() and FieldGet() functions.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      This example demonstrates a typical specification of the FieldPos() function:
      <code language="X#">
        USE customer NEW
        QOut(FIELDPOS("Name"))&#0009;&#0009;&#0009;&#0009;&#0009;// Result: 1
        QOut(FieldGet(FIELDPOS("Name")))&#0009;&#0009;&#0009;// Result: Kate
      </code>
      This example uses FieldPos() to return the position of a specified field in a unselected work area:
      <code language="X#">
        USE customer NEW
        USE invoices NEW
        QOut(Customer-&gt;FIELDPOS("Name"))&#0009;&#0009;&#0009;// Result: 1
        QOut(Customer-&gt;FieldGet(FIELDPOS("Name")))&#0009;// Result: Kate
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.CharPos'>CharPos</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldName'>FieldName</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPosSym'>FieldPosSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPut'>FieldPut</seealso>
  </fieldpos>
  <fieldpossym>
    <summary>
      Return the position of a field that is identified by a symbol.
    </summary>

    <param name="sFieldName">A symbol that corresponds to the name of the field.</param>
    <returns>
      The position of the specified field within the list of fields associated with the work area.<br/>
      If the work area has no field with the specified name, FieldPosSym() returns 0.
    </returns>
    <remarks>
      FieldPosSym() is the inverse of the FieldName() function.  FieldPosSym() is most often used with the FieldPut() and FieldGet() functions.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example demonstrates a typical specification of the FieldPosSym() function:
      <code language="X#">
        USE customer NEW
        QOut(FieldPosSym(#Name))&#0009;&#0009;&#0009;&#0009;// Result: 1
        QOut(FieldGet(FieldPosSym(#NAME)))&#0009;&#0009;&#0009;// Result: Kate
      </code>
      This example uses FieldPosSym() to return the position of a specified field in a unselected work area:
      <code language="X#">
        USE customer NEW
        USE invoices NEW
        QOut(Customer-&gt;FieldPosSym(#Name))&#0009;&#0009;&#0009;// Result: 1
        QOut(Customer-&gt;FieldGet(FieldPosSym(#Name)))&#0009;// Result: Kate
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPos'>FieldPos</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPut'>FieldPut</seealso>
  </fieldpossym>
  <fieldput>
    <summary>
      Set the value of a field identified by its position.
    </summary>

    <param name="nFieldPos">The position of the field in the database file structure.</param>
    <param name="uNewValue">
      The value to assign to the field.<br/>
      The data type of this expression must match the data type of the field.
    </param>
    <returns>
      The value assigned to the field.
      If <paramref name="nFieldPos" /> does not correspond to the position of any field in the database file, FieldPut() will generate an error.
      The exception to this is the XBase++ dialect where an invalid <paramref name="nFieldPos" /> will not generate an exception but will return NIL.
    </returns>
    <remarks>
      FieldPut() allows you to set the value of a field using its position within the database file structure rather than its field name.  Within generic database service functions this allows, among other things, the setting of field values without use of the macro operator.
      Note:  FieldPut() can be used with a BLOB field (that is, a memo field associated with a BLOB file), provided the length of the field does not exceed 64 KB.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      Shared mode:<br/>
      For a shared database, this function requires a record lock.
    </remarks>
    <example>
      This example compares FieldPut() to functionally equivalent code that uses the macro operator to set the value of a field:
      <code language="X#">
        // Using macro operator
        FName := FIELDNAME(nFieldPos)&#0009;&#0009;&#0009;&#0009;// Get field name
        _FIELD-&gt;&amp;FName := FVal&#0009;&#0009;&#0009;&#0009;&#0009;// Set field value
        // Using FieldPut()
        FieldPut(nFieldPos, FVal)&#0009;&#0009;&#0009;&#0009;&#0009;// Set field value
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetSym'>FieldGetSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutSym'>FieldPutSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldPut'>VODBFieldPut</seealso>
  </fieldput>
  <fieldputalias>
    <summary>
      Set the value of a field identified by its work area alias and field name.
    </summary>

    <param name="symAlias">
      The alias of the work area in which <paramref name="symField" /> is located.
    </param>
    <param name="symField">The field name.</param>
    <param name="uNewValue">
      The value to assign to the field.<br/>
      The data type of this expression must match the data type of the field.
    </param>
    <returns>
      The value assigned to the field.<br/>
      If <paramref name="symField" /> does not correspond to any field in the work area specified by <paramref name="symAlias" />, FieldPutAlias() returns NIL.
    </returns>
    <remarks>
      This function allows you to set the value of a field using a symbol that specifies the field name.  Within generic database service functions, this allows the setting of field values without the use of the macro operator, among other things.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      Shared mode:<br/>
      For a shared database, this function requires a record lock.
    </remarks>
    <example>
      This example uses FieldPutAlias() to set field values in two different work areas:
      <code language="X#">
        USE region1 NEW
        USE region2 NEW
        FieldPutAlias(#REGION1, #FNAME, "Kate")
        FieldPutAlias(#REGION2, #FNAME, "Cindy")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetAlias'>FieldGetAlias</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPut'>FieldPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutArea'>FieldPutArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutSelect'>FieldPutSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldPut'>VODBFieldPut</seealso>
  </fieldputalias>
  <fieldputselect>
    <summary>
      Set the value of a field identified by its work area alias and field name.
    </summary>

    <param name="symAlias">
      The alias of the work area in which <paramref name="symField" /> is located.
    </param>
    <param name="symField">The field name.</param>
    <param name="uNewValue">
      The value to assign to the field.<br/>
      The data type of this expression must match the data type of the field.
    </param>
    <returns>
      The value assigned to the field.<br/>
      If <paramref name="symField" /> does not correspond to any field in the work area specified by <paramref name="symAlias" />, FieldPutAlias() returns NIL.
    </returns>
    <remarks>
      This function allows you to set the value of a field using a symbol that specifies the field name.  Within generic database service functions, this allows the setting of field values without the use of the macro operator, among other things.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      Shared mode:<br/>
      For a shared database, this function requires a record lock.
    </remarks>
    <example>
      This example uses FieldPutSelect() to set field values in two different work areas:
      <code language="X#">
        USE region1 NEW
        USE region2 NEW
        FieldPutSelect(#REGION1, #FNAME, "Kate")
        FieldPutSelect(#REGION2, #FNAME, "Cindy")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetAlias'>FieldGetAlias</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPut'>FieldPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutAlias'>FieldPutAlias</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutArea'>FieldPutArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldPut'>VODBFieldPut</seealso>
  </fieldputselect>
  <fieldputarea>
    <summary>
      Set the value of a field identified by its work area number and field name.
    </summary>

    <param name="dwWorkArea">
      The work area in which <paramref name="symField" /> is located.
    </param>
    <param name="symField">The field name.</param>
    <param name="uNewValue">
      The value to assign to the field.<br/>
      The data type of this expression must match the data type of the field.
    </param>
    <returns>
      The value assigned to the field.<br/>
      If <paramref name="symField" /> does not correspond to any field in the work area specified by <paramref name="dwWorkArea" />, FieldPutArea() returns NIL.
    </returns>
    <remarks>
      FieldPutArea() allows you to set the value of a field using a symbol that specifies the field name.  Within generic database service functions this allows, among other things, the setting of field values without use of the macro operator.
      Shared mode:<br/>
      For a shared database, this function requires a record lock.
    </remarks>
    <example>
      This example uses FieldPutArea() to set field values:
      <code language="X#">
        USE sales NEW
        USE region1 NEW
        USE region2 NEW
        String2Symbol("FName")
        FieldPutArea(Select("region1"), #FNAME, "Kate")
        FieldPutArea(Select("region2"), #FNAME, "Cindy")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetArea'>FieldGetArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPut'>FieldPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldPut'>VODBFieldPut</seealso>
  </fieldputarea>
  <fieldputsym>
    <summary>
      Set the value of a field that is identified by its symbolic name.
    </summary>

    <param name="symField">The symbolic name of the field in the database file structure for the current work area.</param>
    <param name="uNewValue">
      The value to assign to the field.<br/>
      The data type of this expression must match the data type of the field.
    </param>
    <returns>
      The value assigned to the field.<br/>
      If <paramref name="symField" /> does not correspond to a field in the current database file, FieldPutSym() returns NIL.
    </returns>
    <remarks>
      FieldPutSym() assigns a new value to a field using its symbolic field name within the database file structure, rather than the string representation of field name.
      Note:  FieldPutSym() can be used with a BLOB field (that is, a memo field associated with a BLOB file), provided the length of the field does not exceed 64KB.
    </remarks>
    <example>
      This example sets a new value for the contents of the Firstname field in the TestDBF database:
      <code language="X#">
        USE TestDBF NEW
        FieldPutSym(#Firstname, "Marijo")
        ? FieldGetSym(#Firstname)&#0009;&#0009;&#0009;// Marijo
        USE
        WAIT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldGetSym'>FieldGetSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPut'>FieldPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldGet'>VODBFieldGet</seealso>
  </fieldputsym>
  <fieldsym>
    <summary>
      Return the name of a field as a symbol.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>

    <param name="dwFieldPos">The position of the field in the database file structure.</param>
    <returns>
      The name of the specified field as a symbol.<br/>
      If <paramref name="dwFieldPos" /> does not correspond to an existing field in a database file or if no database file is open, FieldSym() returns NULL_SYMBOL.
    </returns>
    <remarks>
      FieldSym() returns a field name as a symbol, using an index to the position of the field name in the database structure.<br/>
      Use it in data-independent applications where the field name is unknown.<br/>
      If information for more than one field is required, use DBStruct().
      If you need additional database file structure information, use Type() and Len().<br/>
      For example, to obtain the number of decimal places for a numeric field, use the following expression:
      <code language="X#">
        Len(Substr(Str(<paramref name="idField" />), RAt(".", Str(<paramref name="idField" />)) + 1))
      </code>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      These examples illustrate FieldSym() used with several other functions:
      <code language="X#">
        USE sales
        QOut(FieldSym(1))&#0009;&#0009;&#0009;&#0009;// Result: BRANCH
        QOut(FCount())&#0009;&#0009;&#0009;&#0009;&#0009;// Result: 5
        QOut(LEN(FieldSym(0)))&#0009;&#0009;&#0009;// Result: 0
        QOut(LEN(FieldSym(40)))&#0009;&#0009;&#0009;// Result: 0
      </code>
      This example uses FieldSym() to list the name and type of each field in CUSTOMER.DBF:
      <code language="X#">
        USE customer NEW
        FOR nField := 1 UPTO FCount()
        &#0009;QOut(PadR(FieldSym(nField), 10),;
        &#0009;&#0009;&#0009;VALTYPE(&amp;(FieldSym(nField))))
        NEXT
      </code>
      This example accesses fields in unselected work areas using aliased expressions:
      <code language="X#">
        USE sales NEW
        USE customer NEW
        USE invoices NEW
        QOut(Sales-&gt;FieldSym(1))&#0009;&#0009;&#0009;// Result: Salenum
        QOut(Customer-&gt;FieldSym(1))&#0009;&#0009;// Result: Custnum
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbStruct'>DBStruct</seealso>
    <seealso cref='O:XSharp.RT.Functions.FCount'>FCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldName'>FieldName</seealso>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.RT.Functions.Type'>Type</seealso>
    <seealso cref='O:XSharp.RT.Functions.ValType'>ValType</seealso>
  </fieldsym>
  <fieldwblock>
    <summary>
      Return a set-get code block for a field, specified as a string, in a specified work area.
    </summary>

    <param name="cFieldName">The name of the field.</param>
    <param name="dwWorkArea">The work area number where the field resides.</param>
    <returns>
      A runtime code block (implemented as an object) that, when evaluated, sets (assigns) or gets (retrieves) the value of <paramref name="cFieldName" /> in the work area designated by <paramref name="dwWorkArea" />.<br/>
      If <paramref name="cFieldName" /> does not exist in the specified work area, FieldWBlock() returns NULL_OBJECT.
    </returns>
    <remarks>
      FieldWBlock() builds a code block.  When evaluated with the Evaluate() function, the code block first selects the designated <paramref name="dwWorkArea" />.<br/>
      If an argument was passed, the code block then assigns the value of the argument to <paramref name="cFieldName" />.<br/>
      If no argument was passed, the code block retrieves the value of <paramref name="cFieldName" />.<br/>
      The original work area is then reselected before the code block returns control.
      Note that the specified field variable does not have to exist when the code block is created but must exist before the code block is executed.
    </remarks>
    <example>
      This example compares FieldWBlock() to a code block created using the macro operator.  Note that using FieldWBlock() avoids the speed and size overhead of the macro operator:
      <code language="X#">
        // Set-Get block for work area 1 defined with macro operator
        cbSetGet := &amp;("{|SetVal| If(SetVal == NIL, ;
        &#0009;1-&gt;FName, 1-&gt;FName := SetVal)}")
        // Set-Get block defined using FieldWBlock()
        // cbSetGet created here is the functional equivalent of cbSetGet above
        cbSetGet := FieldWBlock("FName", 1)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldBlock'>FieldBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldWBlockSym'>FieldWBlockSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarBlock'>MemVarBlock</seealso>
  </fieldwblock>
  <fieldwblocksym>
    <summary>
      Return a set-get code block for a field, specified as a symbol, in a specified work area.
    </summary>

    <param name="symFieldname">The name of the field.</param>
    <param name="dwWorkArea">The work area number where the field resides.</param>
    <returns>
      A runtime code block (implemented as an object) that, when evaluated, sets (assigns) or gets (retrieves) the value of <paramref name="symFieldName" /> in the work area designated by <paramref name="dwWorkArea" />.<br/>
      If <paramref name="symFieldName" /> does not exist in the specified work area, FieldWBlockSym() returns NULL_OBJECT.
    </returns>
    <remarks>
      FieldWBlockSym() builds a code block.  When evaluated with the Evaluate() function, the code block first selects the designated <paramref name="dwWorkArea" />.<br/>
      If an argument was passed, the code block then assigns the value of the argument to <paramref name="symFieldName" />.<br/>
      If no argument was passed, the code block retrieves the value of <paramref name="symFieldName" />.<br/>
      The original work area is then reselected before the code block returns control.
      Note that the specified field variable does not have to exist when the code block is created but must exist before the code block is executed.
    </remarks>
    <example>
      This example compares FieldWBlockSym() to a code block created using the macro operator.  Note that using FieldWBlockSym() avoids the speed and size overhead of the macro operator:
      <code language="X#">
        // Set-Get block for work area 1 defined with macro operator
        cbSetGet := &amp;("{|SetVal| If(SetVal == NIL, ;
        &#0009;1-&gt;FName, 1-&gt;FName := SetVal)}")
        // Set-Get block defined using FieldWBlockSym()
        // cbSetGet created here is the functional
        // equivalent of cbSetGet above
        cbSetGet := FieldWBlockSym(#FName, 1)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldBlock'>FieldBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldWBlock'>FieldWBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarBlock'>MemVarBlock</seealso>
  </fieldwblocksym>
  <file>
    <summary>
      Determine if any file matches a given file specification.
    </summary>

    <param name="cFileSpec">
      The file specification for the search.  Besides a file name, this specification can include an optional drive, directory, and extension.<br/>
      The file name and extension can include the standard wildcard characters (* and ?).<br/>
      If you do not specify a drive and directory, this function searches only the SetDefault() and SetPath() settings.  Note also that File() does not recognize hidden or system files in its search.If <paramref name="cFileSpec" /> is longer than 127 characters and has no path VO searches in the current directory only
    </param>
    <returns>
      TRUE if any file matches the <paramref name="cFileSpec" /> pattern; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example illustrates how File() attempts to find files:
      <code language="X#">
        ? File("sales.dbf")&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        ? File("\apps\dbf\sales.dbf")&#0009;&#0009;&#0009;// TRUE
        SetPath("\apps\dbf")
        ? File("sales.dbf")&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
        SetPath("")
        SetDefault("\apps\dbf\")
        ? File("sales.dbf")&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
        ? File("*.dbf")&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FPathName'>FPathName</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDefault'>SetDefault</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPath'>SetPath</seealso>
  </file>
  <floatformat>
    <summary>
      Set the display format for a floating point numeric.
    </summary>

    <param name="fValue">Any numeric value.</param>
    <param name="iLen">
      The desired length of the display of <paramref name="fValue" />, including decimal digits, decimal point, and sign.<br/>
      A value of -1 means that only significant digits to the left of the decimal point will be displayed (any left padding will be suppressed).
    </param>
    <param name="iDec">
      The desired number of decimal digits in the display of <paramref name="fValue" />.<br/>
      A value of -1 means that only significant digits to the right of the decimal point will be displayed (any right padding will be suppressed).
    </param>
    <returns>
    </returns>
    <remarks>
      FloatFormat() is used to format floating point numbers.  Note that FloatFormat() affects only the display format of numbers and not the actual numeric precision of calculations.
    </remarks>
    <example>
      These examples use FloatFormat() to display the same number using three different formats.  Note the number of leading spaces in each result:
      <code language="X#">
        ? FloatFormat(1234.546, 12,2)&#0009;&#0009;//  1234.54
        ? FloatFormat(1234.546, -1,4)&#0009;&#0009;//  1234.5460
        ? Floatformat(1234.546, 12,-1)&#0009;&#0009;//  1234.546
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDigit'>SetDigit</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
  </floatformat>
  <flock>
    <summary>
      Lock an opened and shared database file.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      TRUE if the lock succeeded; otherwise, FALSE.
    </returns>
    <remarks>
      If a database file is opened in shared mode, you must obtain a file lock before attempting any operation that updates the database file with a scope or a condition.
      For each invocation of FLock(), there is one attempt to lock the database file (and other related files, such as index and memo files), and the result is returned as a logical value.<br/>
      A file lock fails if another process currently has a file or record lock for the same database file.
      If FLock() is successful, the file lock is locked and other processes are prevented from making updates until the lock is released.  FLock() provides a shared lock, allowing other users read-only access to the locked file while allowing only the current process to modify it.
      A file lock remains in effect until you close the database, explicitly unlock it (with DBUnLock(), for example), or attempt another file or record lock (with RLock() or DBRLock()).
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      This feature is useful since FLock() does not automatically attempt a file lock for related files.
    </remarks>
    <example>
      This example uses FLock() for a batch update of prices in INVENTORY.DBF:
      <code language="X#">
        USE inventory SHARED NEW
        IF Inventory-&gt;FLock()
        &#0009;REPLACE ALL Inventory-&gt;Price WITH ;
        &#0009;&#0009;&#0009;Inventory-&gt;Price * 1.1
        ELSE
        &#0009;QOut("File not available")
        ENDIF
      </code>
      This example attempts a file lock in an unselected work area:
      <code language="X#">
        USE sales NEW
        USE customer NEW
        IF !Sales-&gt;FLock()
        &#0009;QOut("Sales is in use")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLock'>DBUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUseArea'>DBUseArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.RLock'>RLock</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetExclusive'>SetExclusive</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFlock'>VODBFLock</seealso>
  </flock>
  <floor>
    <summary>
      Round a number down to the next lowest integer.
    </summary>

    <param name="nNum">The number to round.</param>
    <returns>
      The nearest integer that is less than or equal to <paramref name="nNum" />.
    </returns>
    <remarks>
      Floor() rounds a negative value with a fractional portion down to the preceding integer and returns the integer portion of a positive number.
    </remarks>
    <example>
      This example uses Floor() on a positive and a negative number:
      <code language="X#">
        ? Floor(1.6)&#0009;&#0009;&#0009;// 1
        ? Floor(-1.6)&#0009;&#0009;&#0009;// -2 (since -2 &lt; -1)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Ceil'>Ceil</seealso>
    <seealso cref='O:XSharp.RT.Functions.Integer'>Integer</seealso>
    <seealso cref='O:XSharp.RT.Functions.Round'>Round</seealso>
  </floor>
  <fname>
    <summary>
      Return the name of the file found by FFCount(), FFirst(), or FNext().
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses FName() to return the names of files matching *.TXT:
      <code language="X#">
        ? FFirst("*.txt", FC_NORMAL)
        ? FName()&#0009;&#0009;&#0009;&#0009;// Return first file matched
        ? FNext()&#0009;&#0009;&#0009;&#0009;// Find next file matching *.txt
        ? FName()&#0009;&#0009;&#0009;&#0009;// Return second file matched
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
    <seealso cref='O:XSharp.Core.Functions.FDate'>FDate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFCount'>FFCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFirst'>FFirst</seealso>
    <seealso cref='O:XSharp.Core.Functions.FNext'>FNext</seealso>
    <seealso cref='O:XSharp.Core.Functions.FSize'>FSize</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTime'>FTime</seealso>
  </fname>
  <fnext>
    <summary>
      Find the next file that matches the file previously found by FFirst().
    </summary>
    <returns>
      TRUE if another file was found; otherwise, FALSE.
    </returns>
    <remarks>
      FNext() finds the next file that matches the original FFirst() or FFCount() search.  In other words, FFirst() gets the first matching file and FNext() finds subsequent matching files.  When FNext() returns FALSE, there are no more files left to match.
      FFCount() returns the number of matches.   FAttrib(), FDate(), FName(), FSize(), and FTime() return the attribute, date stamp, name, size, and time stamp of the current matching file, respectively.
    </remarks>
    <example>
      This example uses FFirst() and FNext() to get all visible files matching "C:\DOCS\*.TXT":
      <code language="X#">
        IF FFirst("c:\docs\*.txt", FC_NORMAL)
        &#0009;? FName()&#0009;&#0009;&#0009;// Return first file matched
        &#0009;DO WHILE FNext()&#0009;// Find next match
        &#0009;&#0009;? FName()&#0009;&#0009;// Return second file matched
        &#0009;ENDDO
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
    <seealso cref='O:XSharp.Core.Functions.FDate'>FDate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFCount'>FFCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFirst'>FFirst</seealso>
    <seealso cref='O:XSharp.Core.Functions.FName'>FName</seealso>
    <seealso cref='O:XSharp.Core.Functions.FSize'>FSize</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTime'>FTime</seealso>
  </fnext>
  <fopen>
    <summary>
      Open a file.
    </summary>

    <param name="cFileName">
      The file name, including an optional drive, directory, and extension.  SetDefault() and SetPath() settings are ignored; the Windows default is used unless you specify a drive and directory as part of the file name.  No extension is assumed.<br/>

      &#0009;This function sets NetErr() in case of a concurrency control conflict.
    </param>
    <param name="kMode">
      The DOS open mode, which determines the accessibility of the file.<br/>
      The open mode is composed of elements from the two types of modes: Access mode + Sharing mode.  Specifying an access mode constant indicates how the opened file is to be accessed; the sharing mode determines how other processes can access the file.  <br/>

      &#0009;Available open and sharing mode constants are listed below:<br/>

      &#0009;Access Modes&#0009;Operation<br/>

      &#0009;FO_READ&#0009;Open for reading (default)<br/>

      &#0009;FO_READWRITE&#0009;Open for reading or writing<br/>

      &#0009;FO_WRITE&#0009;Open for writing<br/>

      <br/>



      &#0009;Sharing Modes&#0009;Operation<br/>

      &#0009;FO_COMPAT&#0009;Compatibility mode (default)<br/>

      &#0009;FO_DENYNONE&#0009;Allow others to read or write<br/>

      &#0009;FO_DENYREAD&#0009;Prevent others from reading<br/>

      &#0009;FO_DENYWRITE&#0009;Prevent others from writing<br/>

      &#0009;FO_EXCLUSIVE&#0009;Exclusive use<br/>

      &#0009;FO_SHARED&#0009;Same as FO_DENYNONE<br/>

      &#0009;The default open mode is non-sharable and read-only.<br/>
      If just the access mode is used, the file is opened as non-sharable.
    </param>
    <returns>
      The file handle of the opened file in the range of 0 to 32,767.<br/>
      This value is similar to an alias in the database system and is required to identify the open file to other file functions.<br/>
      It is, therefore, important to assign the return value to a variable for later use, as in the example below.
      If an error occurs, FOpen() returns F_ERROR.  FError() can be used to determine the specific error.
    </returns>
    <remarks>
      FOpen() is a low-level file function that opens an existing file for reading and writing, depending on the <paramref name="kMode" /> argument.
      Note that in order for two processes to use the same file simultaneously, both files should be opened in FO_SHARED sharing mode.
      Whenever there is an error, FError() can be used to determine the specific error.<br/>
      For example, if the file does not exist, FOpen() returns F_ERROR and FError() returns 2 to indicate that the file was not found.
    </remarks>
    <example>
      This example uses FOpen() to open a file with  sharable read/write status and displays an error message if the open fails:
      <code language="X#">
        ptrHandle := FOpen("temp.txt")
        IF ptrHandle = F_ERROR
        &#0009;? DOSErrString(FError())
        ENDIF
      </code>
      This example uses FOpen() to open a file with an optional retry if FOpen() fails:
      <code language="X#">
        FUNCTION NetOpen(cFile AS STRING,;
        &#0009;&#0009;wMode AS DWORD, wSeconds AS DWORD);
        &#0009;&#0009;AS LOGIC PASCAL
        &#0009;LOCAL lForever AS LOGIC
        &#0009;// Retry forever if wSeconds is zero
        &#0009;lForever := (wSeconds = 0)
        &#0009;DO WHILE (lForever .OR. wSeconds &gt; 0)
        &#0009;&#0009;IF FOpen(cFile, wMode) != F_ERROR
        &#0009;&#0009;RETURN TRUE  &#0009;&#0009;// Open succeeds
        &#0009;&#0009;ENDIF
        &#0009;&#0009;InKey(1)&#0009;&#0009;&#0009;// Wait one second
        &#0009;&#0009;wSeconds -= 1
        &#0009;ENDDO
        &#0009;RETURN FALSE&#0009;&#0009;&#0009;// Open fails
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen2'>FOpen2</seealso>
  </fopen>
  <fopen2>
    <summary>
      Open a file, specifying two strongly-typed arguments.
    </summary>

    <param name="cFileName">
      The file name, including an optional drive, directory, and extension.  SetDefault() and SetPath() settings are ignored; the Windows default is used unless you specify a drive and directory as part of the file name.  No extension is assumed.<br/>

      &#0009;This function sets NetErr() in case of a concurrency control conflict.
    </param>
    <param name="kMode">
      This argument is the same as <paramref name="kMode" /> used with FOpen().  See FOpen() for details.
    </param>
    <returns>
      The file handle of the opened file in the range of 0 to 32,767.<br/>
      If an error occurs, FOpen2() returns F_ERROR.  FError() can be used to determine the specific error.
    </returns>
    <remarks>
      Note that in order for two processes to use the same file simultaneously, both files should be opened in FO_SHARED sharing mode.
    </remarks>
    <example>
      This example uses FOpen2() to open a file with sharable read/write status and displays an error message if the open fails:
      <code language="X#">
        ptrHandle := FOpen2("temp.txt",;
        &#0009;FO_READWRITE + FO_SHARED)
        IF ptrHandle = F_ERROR
        &#0009;? DOSErrString(FError())
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
  </fopen2>
  <found>
    <summary>
      Determine if the previous search operation succeeded.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      TRUE if the last search was successful; otherwise, FALSE.  Found() will also return FALSE if there is no database open in the work area.
    </returns>
    <remarks>
      Found() determines whether a search operation, such as DBSeek(), DBLocate(), DBContinue(), or DBSetRelation(), succeeded.  When any of these commands are executed, Found() is set to TRUE if there is a match; otherwise, it is set to FALSE.
      If the search command is LOCATE or CONTINUE, a match is the next record meeting the scope and condition.<br/>
      If the search command is FIND, SEEK or SET RELATION, a match is the first key in the controlling order that equals the search argument.<br/>
      If the key value equals the search argument, Found() is TRUE; otherwise, it is FALSE.
      The value of Found() is retained until another record movement command is executed.<br/>
      Unless the command is another search command, Found() is automatically set to FALSE.  You can also use DBSetFound() to manually set this flag.
      Each work area has a Found() value.<br/>
      This means that if one work area has a relation set to a child work area, querying Found() in the child returns TRUE if there is a match.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      This example illustrates the behavior of Found() after a record movement command:
      <code language="X#">
        USE sales INDEX sales
        SEEK "1000"
        QOut(Found())&#0009;&#0009;&#0009;// Result: FALSE
        SEEK "100"
        QOut(Found())&#0009;&#0009;&#0009;// Result: TRUE
        SKIP
        QOut(Found())&#0009;&#0009;&#0009;// Result: FALSE
      </code>
      This example tests a Found() value in an unselected work area using an aliased expression:
      <code language="X#">
        USE sales INDEX sales NEW
        USE customer INDEX customer NEW
        SET RELATION TO CustNum INTO sales
        SEEK "Smith"
        QOut(Found(), Sales-&gt;Found())
      </code>
      This code fragment processes all CUSTOMER records with the key value "Smith" using Found() to determine when the key value changes:
      <code language="X#">
        USE customer INDEX customer NEW
        SEEK "Smith"
        DO WHILE Found()
        &#0009;.
        &#0009;. <paramref name="Statements" />
        &#0009;.
        &#0009;SKIP
        &#0009;LOCATE REST WHILE Name == "Smith"
        ENDDO
      </code>
    </example>
    <seealsocmd>CONTINUE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbSetFound'>DBSetFound</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealsocmd>LOCATE</seealsocmd>
    <seealsocmd>SEEK</seealsocmd>
    <seealsocmd>SET RELATION</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbFound'>VODBFound</seealso>
  </found>
  <fparamcount>
    <summary>
      Return the number of local arguments that a function with the CLIPPER calling convention is expecting.
    </summary>

    <param name="symFunction">
      The symbol of the function to examine.<br/>
      The function must use the CLIPPER calling convention.
    </param>
    <returns>
    </returns>
    <remarks>
      Only arguments that are declared within the parentheses of the function are counted.<br/>
      Therefore, arguments that are declared with the PARAMETERS statement do not count.
    </remarks>
    <example>
      This example uses FParamCount() with PCount() to determine the number of missing arguments:
      <code language="X#">
        Missing("hi")
        FUNCTION Missing(uOne, uTwo, uThree)
        &#0009;? FParamCount(#Missing) - PCount(),;
        &#0009;&#0009;"Missing arguments"&#0009;// 2 Missing arguments
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CParamCount'>CParamCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.MParamCount'>MParamCount</seealso>
  </fparamcount>
  <fpathname>
    <summary>
      Return the name and path of the file that was used by File().
    </summary>
    <returns>
      The complete name, including path, of the file that was last used by File().  Note that the system might also use File() internally.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses FPathName() after calling File:
      <code language="X#">
        SetDefault("\vo")
        ? File("*.exe")
        ? FPathName()&#0009;&#0009;&#0009;&#0009;// C:\VO\EXISTS.EXE
        ? File("d:\backup\notexist.txt")
        ? FPathName()&#0009;&#0009;&#0009;&#0009;// D:\BACKUP\NOTEXIST.TXT
        SetDefault("c:\backup")
        File("exists.txt")&#0009;&#0009;&#0009;// c:\backup\exists.txt
        ? FPathName()
        SetDefault("c:\vo\data")
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.File'>File</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDefault'>SetDefault</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPath'>SetPath</seealso>
    <seealso cref='O:XSharp.RT.Functions.SplitPath'>SplitPath</seealso>
  </fpathname>
  <fputs>
    <summary>
      Write a string, a carriage-return character, and a linefeed character to an open file.
    </summary>

    <param name="ptrHandle">The handle of the file to write to.</param>
    <param name="cBuffer">The string to write.</param>
    <param name="nBytes">
      The number of bytes in <paramref name="cBuffer" /> to write, beginning at the current file pointer position.<br/>
      If <paramref name="nBytes" /> is not specified, the value of SLen(<paramref name="cBuffer" />) is used.
    </param>
    <returns>
      The number of bytes written.<br/>
      If the value returned is equal to <paramref name="nBytes" /> + 2, the operation was successful.<br/>
      If the return value is less than <paramref name="nBytes" /> + 2 or 0, this means that the length of  <paramref name="cBuffer" /> was less than <paramref name="nBytes" />, or the disk is full, or another error has occurred.
    </returns>
    <remarks>
      FPuts() is a low-level file function that writes data to an open file from a string buffer.  You can either write all or a portion of the buffer contents.  Writing begins at the current file position, and the function returns the actual number of bytes written.
      This function is assumed to handle raw binary data and is not dependent upon the status of SetAnsi().  FWriteText() and FWrite4(), on the other hand, are dependent upon SetAnsi().
    </remarks>
    <example>
      This example uses FPuts() to write lines starting at the beginning of a file.<br/>
      The carriage-return/linefeed pair increase the return value by 2:
      <code language="X#">
        ptrHandle := FOpen2("c:\data\sales", FO_READWRITE)
        ? FPuts(ptrHandle, "Line1")&#0009;&#0009;&#0009;&#0009;//  7
        ? FPuts(ptrHandle, "Line1", 2)&#0009;&#0009;&#0009;&#0009;//  4
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FWriteLine'>FWriteLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.FPutS3'>FPuts3</seealso>
  </fputs>
  <fputs3>
    <summary>
      Write a string, a carriage-return character, and a linefeed character to an open file, specifying three strongly-typed arguments.
    </summary>

    <param name="ptrHandle">The handle of the file to write to.</param>
    <param name="cBuffer">The string to write.</param>
    <param name="dwBytes">
      The number of bytes in <paramref name="cBuffer" /> to write, beginning at the current file pointer position.
    </param>
    <returns>
      The number of bytes written.<br/>
      If the value returned is equal to <paramref name="dwBytes" /> + 2, the operation was successful.<br/>
      If the return value is less than <paramref name="dwBytes" /> + 2 or 0, this means that the length of  <paramref name="cBuffer" /> was less than <paramref name="dwBytes" />, or the disk is full, or another error has occurred.
    </returns>
    <remarks>
      This function is assumed to handle raw binary data and is not dependent upon the status of SetAnsi().  FWriteText() and FWrite4(), on the other hand, are dependent upon SetAnsi().
    </remarks>
    <example>
      This example uses FPuts3() to write 5 bytes. The carriage-return/linefeed pair increase the return value by 2:
      <code language="X#">
        ptrHandle := FOpen2("c:\data\sales", FO_READWRITE)
        ? FPuts3(ptrHandle, "Line1", 5)&#0009;&#0009;&#0009;//  7
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FWriteLine'>FWriteLine</seealso>
  </fputs3>
  <frac>
    <summary>
      Return the fractional portion of a number.
    </summary>

    <param name="fValue">The number whose fractional portion you want to return.</param>
    <returns>
    </returns>
    <remarks>
      A number may contain a fractional portion following its integer portion.<br/>
      This function returns only the fractional portion.
    </remarks>
    <example>
      This example uses Frac() to implement the logic of a vending machine or a change machine:
      <code language="X#">
        FUNCTION GiveChange(fMoney AS FLOAT) AS VOID PASCAL
        LOCAL fChange AS FLOAT
        ? "Dollars: $", Integer(fMoney)
        fChange := Frac(fMoney)
        // While there is a cent left
        DO WHILE fChange &gt;= 0.01
        &#0009;// Must check low amounts first:
        &#0009;DO CASE
        &#0009;CASE fChange &lt; 0.05
        &#0009;&#0009;? "Pay a cent"
        &#0009;&#0009;fChange -= 0.01
        &#0009;CASE fChange &lt; 0.10
        &#0009;&#0009;? "Pay a nickel (5 cents)"
        &#0009;&#0009;fChange -= 0.05
        &#0009;CASE fChange &lt; 0.25
        &#0009;&#0009;? "Pay a dime (10 cents)"
        &#0009;&#0009;fChange -= 0.10
        &#0009;CASE fChange &lt; 0.5
        &#0009;&#0009;? "Pay a quarter (25 cents)"
        &#0009;&#0009;fChange -= 0.25
        &#0009;OTHERWISE
        &#0009;&#0009;? "Pay half a dollar"
        &#0009;&#0009;fChange -= 0.50
        &#0009;ENDCASE
        ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Integer'>Integer</seealso>
  </frac>
  <fread>
    <summary>
      Read characters from a file into a buffer variable that is passed by reference.
    </summary>

    <param name="ptrHandle">The handle of the file to read from.</param>
    <param name="cBufferVar">
      A variable used to store data read from the specified file.<br/>
      If the length of <paramref name="cBufferVar" /> is less than <paramref name="dwBytes" />, a new string whose length is the minimum of <paramref name="dwBytes" /> and the remaining bytes in the file is allocated.  <paramref name="cBufferVar" /> must be passed by reference and, therefore, must be prefaced by the pass-by-reference operator (@).
    </param>
    <param name="dwBytes">The number of bytes to read into the buffer.</param>
    <returns>
      The number of bytes successfully read.<br/>
      A return value less than <paramref name="dwBytes" /> or 0 indicates end-of-file or some other read error.  FError() can be used to determine the specific error.
    </returns>
    <remarks>
      FRead() reads from the file starting at the current DOS file pointer position, advancing the file pointer by the number of bytes read.<br/>
      All characters are read, including control, null, and high-order (above Chr(127)) characters.
      FRead() is similar in some respects to both FReadStr() and FSeek().  FReadStr() reads a specified number of bytes from a file up to the next null (Chr(0)) character.  FSeek() moves the file pointer without reading.
      This function is assumed to handle raw binary data and is not dependent upon the status of SetAnsi().  FReadText() and FRead4(), on the other hand, are dependent upon SetAnsi().
    </remarks>
    <example>
      This example uses FRead() after successfully opening a file to read 128 bytes into a buffer area:
      <code language="X#">
        DEFINE F_BLOCK := 128
        ...
        cBuffer := Space(F_BLOCK)
        ptrHandle := FOpen2("temp.txt", FO_READ)
        IF FError() != 0
        &#0009;? DOSErrString(FError())
        ELSE
        &#0009;IF FRead(ptrHandle, @cBuffer, F_BLOCK) <paramref name="" /> F_BLOCK
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;ENDIF
        &#0009;FClose(ptrHandle)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead3'>FRead3</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadText'>FReadText</seealso>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </fread>
  <fread3>
    <summary>
      Read characters from a file into an allocated buffer.
    </summary>

    <param name="ptrHandle">The handle of the file to read from.</param>
    <param name="ptrBufferVar">
      Pointer to an allocated buffer used to store data read from the specified file.<br/>
      The length of this variable must be greater than or equal to <paramref name="dwBytes" />.
    </param>
    <param name="dwBytes">The number of bytes to read into the buffer.</param>
    <returns>
      The number of bytes successfully read.<br/>
      A return value less than <paramref name="dwBytes" /> or 0 indicates end-of-file or some other read error.  FError() can be used to determine the specific error.
    </returns>
    <remarks>
      FRead3() is the same as FRead(), except that the name of the buffer variable is a pointer and is not passed by reference.
      See FRead() for details.
      This function is assumed to handle raw binary data and is not dependent upon the status of SetAnsi().  FReadText() and FRead4(), on the other hand, are dependent upon SetAnsi().
    </remarks>
    <example>
      This example uses FRead3() after successfully opening a file to read 128 bytes into a buffer area:
      <code language="X#">
        DEFINE F_BLOCK := 128
        Function Start()
        &#0009;LOCAL cBuffer AS PTR
        &#0009;cBuffer := MemAlloc(F_BLOCK)
        &#0009;IF cBuffer = NULL PTR
        &#0009;&#0009;RETURN FALSE
        &#0009;ENDIF
        &#0009;ptrHandle := FOpen2("temp.txt", FO_READ)
        &#0009;IF ptrHandle = F_ERROR
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;&#0009;RETURN FALSE
        &#0009;ELSE
        &#0009;&#0009;IF FRead3(ptrHandle, cBuffer, F_BLOCK) <paramref name="" /> F_BLOCK
        &#0009;&#0009;&#0009;? DOSErrString(FError())
        &#0009;&#0009;&#0009;RETURN FALSE
        &#0009;&#0009;ENDIF
        &#0009;&#0009;FClose(ptrHandle)
        &#0009;ENDIF
        &#0009;MemFree(cBuffer)
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.RT.Functions.FReadText3'>FReadText3</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </fread3>
  <fread4>
    <summary>
      Read characters from a file into an allocated buffer.
    </summary>

    <param name="ptrHandle">The handle of the file to read from.</param>
    <param name="ptrBufferVar">
      Pointer to an allocated buffer used to store data read from the specified file.<br/>
      The length of this variable must be greater than or equal to <paramref name="dwBytes" />.
    </param>
    <param name="dwBytes">The number of bytes to read into the buffer.</param>
    <param name="lAnsi">If FALSE an OEM to ANSI conversion is made.</param>
    <returns>
      The number of bytes successfully read.<br/>
      A return value less than <paramref name="dwBytes" /> or 0 indicates end-of-file or some other read error.  FError() can be used to determine the specific error.
    </returns>
    <remarks>
      FRead4() is the same as FRead3(), except that it provides you with the option of doing an OEM to ANSI conversion.
    </remarks>
    <example>
      This example uses FRead4() after successfully opening a file to read 128 bytes into a buffer area:
      <code language="X#">
        DEFINE F_BLOCK := 128
        Function Start()
        &#0009;LOCAL cBuffer AS PTR
        &#0009;cBuffer := MemAlloc(F_BLOCK)
        &#0009;IF cBuffer = NULL PTR
        &#0009;&#0009;RETURN FALSE
        &#0009;ENDIF
        &#0009;ptrHandle := FOpen2("temp.txt", FO_READ)
        &#0009;IF ptrHandle = F_ERROR
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;&#0009;RETURN FALSE
        &#0009;ELSE
        &#0009;&#0009;IF FRead4(ptrHandle, cBuffer, F_BLOCK, FALSE) != F_BLOCK
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;&#0009;&#0009;RETURN FALSE
        &#0009;&#0009;ENDIF
        &#0009;&#0009;FClose(ptrHandle)
        &#0009;ENDIF
        &#0009;MemFree(cBuffer)
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2OEM</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>OEM2Ansi</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </fread4>
  <freadline>
    <summary>
      Read a line from an open file.
    </summary>

    <param name="ptrHandle">The handle of the file to read from.</param>
    <param name="nMax">
      The maximum number of characters to read per line.  FReadLine() will read until a hard carriage return (Chr(13)) is reached, end-of-file is encountered,  or <paramref name="nMax" /> characters are read.<br/>
      The default value for <paramref name="nMax" /> is 256.
    </param>
    <returns>
      The line read.  When the end-of-file is reached, FReadLine() returns a NULL_STRING and FError() is set to 257.
    </returns>
    <remarks>
      This function is the same as FGets().  Both functions are assumed to handle raw binary data and are not dependent upon the status of SetAnsi().  FReadText() and FRead4(), on the other hand, are dependent upon SetAnsi().
    </remarks>
    <example>
      This example uses FReadLine() to read an entire file without specifying a value for <paramref name="nMax" />:
      <code language="X#">
        ptrHandle := FOpen2("docs.txt", FO_READ)
        IF ptrHandle != F_ERROR
        &#0009;DO WHILE !FEOF(ptrHandle)
        &#0009;&#0009;? FReadLine(ptrHandle)
        &#0009;ENDDO
        ENDIF
        FClose(ptrHandle)
      </code>
      The following example provides a utility that displays and counts all occurrences of a string within a file:
      <code language="X#">
        FUNCTION Grep(cSearch, cFile AS STRING) ;
        &#0009;&#0009;AS DWORD PASCAL
        &#0009;LOCAL handle AS PTR
        &#0009;LOCAL Count AS DWORD
        &#0009;LOCAL Line AS STRING
        &#0009;Line := " "
        &#0009;handle := FOpen2(file, FO_READ)
        &#0009;cSearch := Upper(cSearch)
        &#0009;DO WHILE !FEOF(handle)
        &#0009;&#0009;line := Upper(FReadLine(handle))
        &#0009;&#0009;IF InStr(cSearch, line)
        &#0009;&#0009;&#0009;? line
        &#0009;&#0009;Count += 1
        &#0009;&#0009;ENDIF
        &#0009;ENDDO
        &#0009;RETURN Count
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FGetS'>FGets</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadLine2'>FReadLine2</seealso>
  </freadline>
  <freadline2>
    <summary>
      Read a line from an open file, specifying two strongly-typed arguments.
    </summary>

    <param name="ptrHandle">The handle of the file to read from.</param>
    <param name="dwMax">
      The maximum number of characters to read per line.  FReadLine2() will read until a hard carriage return (Chr(13)) is reached, end-of-file is encountered,  or <paramref name="dwMax" /> characters are read.<br/>
      The default value for <paramref name="dwMax" /> is 256.
    </param>
    <returns>
      The line read.  When the end-of-file is reached while attempting to read, FReadLine2() returns a NULL_STRING and FError() is set to 257.
    </returns>
    <remarks>
      This function is the same as FGets2().  Both functions are assumed to handle raw binary data and are not dependent upon the status of SetAnsi().  FReadText() and FRead4(), on the other hand, are dependent upon SetAnsi().
    </remarks>
    <example>
      This example uses FReadLine2() to read an entire file with a maximum of 80 characters per line:
      <code language="X#">
        hF := FOpen2("docs.txt", FO_READ)
        IF hF != F_ERROR
        &#0009;DO WHILE !FEOF(hF)
        &#0009;&#0009;? FReadLine2(hF, 80)
        &#0009;ENDDO
        ENDIF
        FClose(hF)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FGetS'>FGets</seealso>
    <seealso cref='O:XSharp.RT.Functions.FReadLine'>FReadLine</seealso>
  </freadline2>
  <freadstr>
    <summary>
      Read characters from a file.
    </summary>

    <param name="ptrHandle">The handle of the file to read from.</param>
    <param name="dwBytes">
      The number of bytes to read, beginning at the current DOS file pointer position.  Characters are read up to <paramref name="dwBytes" /> or until end-of-file is encountered.<br/>
      The file pointer is then moved forward <paramref name="dwBytes" />.<br/>
      If <paramref name="dwBytes" /> is greater than the number of bytes from the pointer position to the end of the file, the file pointer is positioned at the last byte in the file.
    </param>
    <returns>
      A string.<br/>
      A NULL_STRING indicates an error or end-of-file.<br/>
      If end-of-file is reached while reading, FError() is set to 257.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example displays the ASCII values of the first 16 bytes of a text file:
      <code language="X#">
        ptrHandle := FOpen2("new.txt", FC_NORMAL)
        IF ptrHandle = F_ERROR
        &#0009;? DOSErrString(FError())
        ELSE
        &#0009;cString := FReadStr(ptrHandle, 16)
        &#0009;? cString
        &#0009;FClose(ptrHandle)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
  </freadstr>
  <freadtext>
    <summary>
      Read characters from a file into a buffer variable that is passed by reference.
    </summary>

    <param name="ptrHandle">The handle of the file to read from.</param>
    <param name="cBufferVar">
      A variable used to store data read from the specified file.<br/>
      If the length of <paramref name="cBufferVar" /> is less than <paramref name="dwBytes" />, a new string whose length is the minimum of <paramref name="dwBytes" /> and the remaining bytes in the file is allocated.  <paramref name="cBufferVar" /> must be passed by reference and, therefore, must be prefaced by the pass-by-reference operator (@).
    </param>
    <param name="dwBytes">The number of bytes to read into the buffer.</param>
    <returns>
      The number of bytes successfully read.<br/>
      A return value less than <paramref name="dwBytes" /> or 0 indicates end-of-file or some other read error.  FError() can be used to determine the specific error.
    </returns>
    <remarks>
      FReadText() is the same as FRead() except that an OEM to ANSI conversion is made if SetAnsi() is FALSE.
    </remarks>
    <example>
      This example uses FRead() after successfully opening a file to read 128 bytes into a buffer area:
      <code language="X#">
        DEFINE F_BLOCK := 128
        ...
        cBuffer := Space(F_BLOCK)
        ptrHandle := FOpen("temp.txt")
        IF FError() != 0
        &#0009;? DOSErrString(FError())
        ELSE
        &#0009;IF FReadText(ptrHandle, @cBuffer, F_BLOCK) <paramref name="" /> F_BLOCK
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;ENDIF
        &#0009;FClose(ptrHandle)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.RT.Functions.FReadText3'>FReadText3</seealso>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </freadtext>
  <freadtext3>
    <summary>
      Read characters from a file into an allocated buffer, with possible OEM to ANSI conversion, based on the current SetAnsi() setting.
    </summary>

    <param name="ptrHandle">The handle of the file to read from.</param>
    <param name="ptrBufferVar">
      Pointer to an allocated buffer used to store data read from the specified file.<br/>
      The length of this variable must be greater than or equal to <paramref name="dwBytes" />.
    </param>
    <param name="dwBytes">The number of bytes to read into the buffer.</param>
    <returns>
      The number of bytes successfully read.<br/>
      A return value less than <paramref name="dwBytes" /> or 0 indicates end-of-file or some other read error.  FError() can be used to determine the specific error.
    </returns>
    <remarks>
      FReadText3() is the same as FRead3(), except that an OEM to ANSI conversion is made when SetAnsi() is FALSE.
    </remarks>
    <example>
      This example uses FReadText3() after successfully opening a file to read 128 bytes into a buffer area:
      <code language="X#">
        DEFINE F_BLOCK := 128
        Function Start()
        &#0009;LOCAL cBuffer AS PTR
        &#0009;cBuffer := MemAlloc(F_BLOCK)
        &#0009;IF cBuffer = NULL PTR
        &#0009;&#0009;RETURN FALSE
        &#0009;ENDIF
        &#0009;ptrHandle := FOpen("temp.txt")
        &#0009;IF ptrHandle = F_ERROR
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;&#0009;RETURN FALSE
        &#0009;ELSE
        &#0009;&#0009;IF FReadText3(ptrHandle, cBuffer, F_BLOCK) <paramref name="" /> F_BLOCK
        &#0009;&#0009;&#0009;? DOSErrString(FError())
        &#0009;&#0009;&#0009;RETURN FALSE
        &#0009;&#0009;ENDIF
        &#0009;&#0009;FClose(ptrHandle)
        &#0009;ENDIF
        &#0009;MemFree(cBuffer)
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadText'>FReadText</seealso>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </freadtext3>
  <frename>
    <summary>
      Change the name of a file.
    </summary>

    <param name="cOldFile">The original file name, including an optional drive, directory, and extension.  SetDefault() and SetPath() settings are ignored; the Windows default is used unless you specify a drive and directory as part of the file name.  No extension is assumed.</param>
    <param name="cNewFile">
      The new file name, including an optional drive, directory, and extension.  SetDefault() and SetPath() settings are ignored; the Windows default is used unless you specify a drive and directory as part of the file name.  No extension is assumed.<br/>
      If the source directory is different from the target directory, the file moves to the target directory.<br/>
      If <paramref name="cNewFile" /> exists or is currently open, FRename() fails and returns FALSE.
    </param>
    <returns>
      TRUE if the operation succeeds; otherwise, FALSE.  In the case of a failure, FError() can be used to determine the specific error.
      Warning!  Files must be closed before renaming.<br/>
      Attempting to rename an open file will produce unpredictable results.  When a database file is renamed, the associated memo file, if any, must also be renamed.  Failure to do so can compromise the integrity of your databases.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example demonstrates a file rename:
      <code language="X#">
        IF !FRename("oldfile.txt", "newfile.txt")
        &#0009;? DOSErrString(FError())
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FErase'>FErase</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.File'>File</seealso>
    <seealsocmd>RENAME</seealsocmd>
  </frename>
  <frewind>
    <summary>
      Set the file pointer at the top of an open file.
    </summary>

    <param name="ptrHandle">The handle of the open file.</param>
    <returns>
    </returns>
    <remarks>
      FRewind() sets the file pointer to the beginning of a file.<br/>
      It is the same as issuing an FSeek() to go to the top-of-file.
    </remarks>
    <example>
      This example uses FRewind() to go back to the top-of-file:
      <code language="X#">
        hF := Fopen2("c:\vo.txt", FO_READ)
        FSeek(hF, 10, FS_SET)&#0009;&#0009;// Move by 10 bytes
        FRewind(hF)&#0009;&#0009;&#0009;&#0009;&#0009;// Move back to the top
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FEof'>FEOF</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTell'>FTell</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
  </frewind>
  <fseek>
    <summary>
      Set the file pointer to a new position.
    </summary>

    <param name="ptrHandle">The handle of the open file.</param>
    <param name="nOffset">
      The number of bytes to move the file pointer, from the position defined by <paramref name="nOrigin" />.<br/>
      It can be a positive or negative number.<br/>
      A positive number moves the pointer forward in the file, and a negative number moves the pointer backward.<br/>
      If <paramref name="nOrigin" /> is the end-of-file, <paramref name="nOffset" /> must be 0 or negative.
    </param>
    <param name="kOrigin">
      One of the following constants indicating the starting location of the file pointer, telling where to start searching the file:<br/>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Seeks from</description>
        </listheader>
        <item>
          <term>FS_END</term>
          <description>End-of-file   </description>
        </item>
        <item>
          <term>FS_RELATIVE</term>
          <description>Current pointer position  </description>
        </item>
        <item>
          <term>FS_SET</term>
          <description>Beginning-of-file </description>
        </item>
      </list>
    </param>
    <returns>
      The new position of the file pointer, relative to the beginning of the file (position 0).  (The original position of the file pointer does not matter.)
    </returns>
    <remarks>
      FSeek() is a low-level file function that moves the file pointer forward or backward in an open file without actually reading the contents of the specified file.<br/>
      The file pointer cannot be moved beyond the beginning or end-of-file boundaries.
    </remarks>
    <example>
      This example uses FSeek() to determine the length of a file by seeking from the end-of-file.<br/>
      Then, the file pointer is reset to the beginning-of-file:
      <code language="X#">
        // Open the file read-only
        IF (ptrHandle := FOpen2("temp.txt", FO_READ)) != F_ERROR
        &#0009;// Get length of the file
        &#0009;nLength := FSeek(ptrHandle, 0, FS_END)
        &#0009;// Reset file position to beginning-of-file
        &#0009;FSeek(ptrHandle, 0)
        &#0009;FClose(ptrHandle)
        ELSE
        &#0009;? DOSErrString(FError())
        ENDIF
      </code>
      This example positions the file pointer at the last byte in a file:
      <code language="X#">
        FUNCTION FileBottom(ptrHandle) AS LONGINT
        &#0009;RETURN (FSeek(ptrHandle, 0, FS_END))
      </code>
      This example positions the file pointer at the first byte in a file (same as the Rewind() function):
      <code language="X#">
        FUNCTION FileTop(ptrHandle) AS LONGINT
        &#0009;RETURN (FSeek(ptrHandle, 0))
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.FRewind'>FRewind</seealso>
    <seealso cref='O:XSharp.Core.Functions.FSeek3'>FSeek3</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTell'>FTell</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
  </fseek>
  <fseek3>
    <summary>
      Set the file pointer to a new position, specifying three strongly-typed arguments.
    </summary>

    <param name="ptrHandle">The handle of the open file.</param>
    <param name="liOffset">
      The number of bytes to move the file pointer from the position defined by <paramref name="dwOrigin" />.<br/>
      It can be a positive or negative number.<br/>
      A positive number moves the pointer forward in the file, and a negative number moves the pointer backward.
    </param>
    <param name="dwOrigin">
      The same as <paramref name="nOrigin" /> with FSeek(), except required.  See FSeek() for details.
    </param>
    <returns>
      The new position of the file pointer, relative to the beginning of the file (position 0).  (The original position of the file pointer does not matter.)
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses the third argument to report the current position of the file pointer in a specified file (same as FTell()):
      <code language="X#">
        FUNCTION FilePos(ptrHandle) AS LONGINT
        &#0009;RETURN(FSeek3(ptrHandle, 0, FS_RELATIVE))
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTell'>FTell</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
  </fseek3>
  <fsize>
    <summary>
      Return the size of the file found by FFCount(), FFirst(), or FNext().
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses FSize() to see the size of files named DOCS*.DOC:
      <code language="X#">
        ? FFirst("docs*.doc", FC_NORMAL)
        ? FSize()&#0009;&#0009;&#0009;// Size of the first file matched
        ? FNext()&#0009;&#0009;&#0009;// Find next file with docs*.doc
        ? FSize()&#0009;&#0009;&#0009;// Size of the next file matched
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
    <seealso cref='O:XSharp.Core.Functions.FDate'>FDate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFCount'>FFCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFirst'>FFirst</seealso>
    <seealso cref='O:XSharp.Core.Functions.FName'>FName</seealso>
    <seealso cref='O:XSharp.Core.Functions.FNext'>FNext</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTime'>FTime</seealso>
  </fsize>
  <ftell>
    <summary>
      Return the current position of the file pointer.
    </summary>

    <param name="ptrHandle">The handle of the file to examine.</param>
    <returns>
      The current position of the file pointer, relative to the beginning of the file.
    </returns>
    <remarks>
      FTell() gets the current file position.<br/>
      This corresponds to the current physical byte offset for files opened in binary mode.
    </remarks>
    <example>
      This example uses FTell() to reflect the file pointer position before and after an FWrite() and an FSeek():
      <code language="X#">
        hF := FOpen2("myfile.txt", FO_READWRITE)
        IF hF != F_ERROR
        &#0009;? FTell(hF)&#0009;&#0009;&#0009;&#0009;//  0
        &#0009;FWrite3(hF, "Hello", 5)
        &#0009;? FTell(hF)&#0009;&#0009;&#0009;&#0009;//  5
        &#0009;FSeek3(hF, 10, FS_SET)
        &#0009;? FTell(hF)&#0009;&#0009;&#0009;&#0009;//  10
        ELSE
        &#0009;? "Open failed"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
  </ftell>
  <ftime>
    <summary>
      Return the time stamp of the file found by FFCount(), FFirst(), or FNext().
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses FTime() to find out what time the files were last updated:
      <code language="X#">
        // Find the first file matching *.txt
        ? FFirst("*.txt", FC_NORMAL)&#0009;&#0009;&#0009;// TRUE
        ? FTime()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 13:18:26
        // Get the next file matching *.txt
        ? FNext()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
        ? FTime()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 17:53:06
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
    <seealso cref='O:XSharp.Core.Functions.FDate'>FDate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFCount'>FFCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFirst'>FFirst</seealso>
    <seealso cref='O:XSharp.Core.Functions.FName'>FName</seealso>
    <seealso cref='O:XSharp.Core.Functions.FNext'>FNext</seealso>
    <seealso cref='O:XSharp.Core.Functions.FSize'>FSize</seealso>
  </ftime>
  <fwrite>
    <summary>
      Write a string to an open file.
    </summary>

    <param name="ptrHandle">The handle of the file to write to.</param>
    <param name="cBuffer">The string to write.</param>
    <param name="nBytes">
      The number of bytes in <paramref name="cBuffer" /> to write, beginning at the current file pointer position.<br/>
      If omitted, the entire contents of <paramref name="cBuffer" /> is written.
    </param>
    <returns>
      The number of bytes written.<br/>
      If the value returned is equal to <paramref name="nBytes" />, the operation was successful.<br/>
      If the return value is less than <paramref name="nBytes" /> or 0, this means that the length of <paramref name="cBuffer" /> is less than <paramref name="nBytes" />, or the disk is full, or another error has occurred.  FError() can be used to determine the specific error.  When a disk full error occurs, FError() is set to 256.
      FWrite() and FWrite3 are assumed to handle raw binary data and are not dependent upon the status of SetAnsi().  FWriteText() and FWrite4(), on the other hand, are dependent upon SetAnsi().
    </returns>
    <remarks>
    </remarks>
    <example>
      This example copies the contents of one file to another:
      <code language="X#">
        DEFINE F_BLOCK := 512
        ...
        cBuffer := Space(F_BLOCK)
        nInfile := FOpen2("temp.txt", FO_READ)
        nOutfile := FCreate("newfile.txt", FC_NORMAL)
        lDone := FALSE
        DO WHILE !lDone
        &#0009;nBytesRead := FRead(nInfile, @cBuffer,;
        &#0009;F_BLOCK)
        &#0009;IF FWrite(nOutfile, cBuffer) &lt; SLen(cBuffer)
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;&#0009;lDone := TRUE
        &#0009;ELSE
        &#0009;&#0009;lDone := (nBytesRead = 0)
        &#0009;ENDIF
        ENDDO
        FClose(nInfile)
        FClose(nOutfile)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </fwrite>
  <fwrite3>
    <summary>
      Write the contents of a buffer to an open file.
    </summary>

    <param name="ptrHandle">The handle of the file to write to.</param>
    <param name="ptrBuffer">A pointer to the buffer to write.</param>
    <param name="dwBytes">
      The number of bytes in <paramref name="ptrBuffer" /> to write, beginning at the current file pointer position.
    </param>
    <returns>
      The number of bytes written.<br/>
      If the value returned is equal to <paramref name="dwBytes" />, the operation was successful.<br/>
      If the return value is less than <paramref name="dwBytes" /> or 0, this means that the length of <paramref name="ptrBuffer" /> is less than <paramref name="dwBytes" />, or the disk is full, or another error has occurred.  FError() can be used to determine the specific error.
    </returns>
    <remarks>
      FWrite3() is a strongly-typed version of FWrite().  Moreover, the second argument in FWrite3() is a pointer to a buffer, instead of a string.  See FWrite() for details.
    </remarks>
    <example>
      This example writes the contents of a PSZ to a file:.
      <code language="X#">
        LOCAL pszBuff AS PSZ
        LOCAL ptrHandle AS PTR
        pszBuff := "hello" // psz converted data
        ptrHandle := FOpen2("temp.bin", FO_READWRITE)
        IF ptrHandle != F_ERROR
        &#0009;FWrite3(ptrHandle, pszBuff, PszLen(pszBuff)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </fwrite3>
  <fwrite4>
    <summary>
      Write the contents of a buffer to an open file, with an ANSI to OEM conversion option.
    </summary>

    <param name="ptrHandle">The handle of the file to write to.</param>
    <param name="ptrBuffer">A pointer to the buffer to write</param>
    <param name="dwBytes">
      The number of bytes in <paramref name="ptrBuffer" /> to write, beginning at the current file pointer position.
    </param>
    <param name="lAnsi">If FALSE , an ANSI to OEM conversion is made.</param>
    <returns>
      The number of bytes written.<br/>
      If the value returned is equal to <paramref name="dwBytes" />, the operation was successful.<br/>
      If the return value is less than <paramref name="dwBytes" /> or 0, this means that the length of <paramref name="ptrBuffer" /> is less than <paramref name="dwBytes" />, or the disk is full, or another error has occurred.  FError() can be used to determine the specific error.
    </returns>
    <remarks>
      FWrite4() is the same as FWrite3() except that it provides the option of doing an ANSI to OEM conversion.
    </remarks>
    <example>
      This example writes the contents of a PSZ to a file while performing an ANSI to OEM conversion:
      <code language="X#">
        LOCAL pszBuff AS PSZ
        LOCAL ptrHandle AS PTR
        pszBuff := "hello" // psz converted data
        ptrHandle := FOpen2("temp.bin", FO_READWRITE)
        IF ptrHandle != F_ERROR
        &#0009;FWrite4(ptrHandle, pszBuff,;
        &#0009;PszLen(pszBuff), FALSE)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </fwrite4>
  <fwriteline>
    <summary>
      Write a string, a carriage-return character, and a linefeed character to an open file.
    </summary>

    <param name="ptrHandle">The handle of the file to write to.</param>
    <param name="cBuffer">The string to write.</param>
    <param name="nBytes">
      The number of bytes in <paramref name="cBuffer" /> to write, beginning at the current file pointer position.<br/>
      If <paramref name="nBytes" /> is not specified, the value of SLen(<paramref name="cBuffer" />) is used.
    </param>
    <returns>
      The number of bytes written.<br/>
      If the value returned is equal to <paramref name="nBytes" /> + 2, the operation was successful.<br/>
      If the return value is less than <paramref name="nBytes" /> + 2 or 0, this means that the length of  <paramref name="cBuffer" /> was less than <paramref name="nBytes" />, or the disk is full, or another error has occurred.
    </returns>
    <remarks>
      FWriteLine() is a low-level file function that writes data to an open file from a string buffer.  You can either write all or a portion of the buffer contents.  Writing begins at the current file position, and the function returns the actual number of bytes written.
      This function is assumed to handle raw binary data and is not dependent upon the status of SetAnsi().  FWriteText() and FWrite4(), on the other hand, are dependent upon SetAnsi().
    </remarks>
    <example>
      This example uses FWriteLine() to write lines starting at the beginning of a file.<br/>
      The carriage-return/linefeed pair increase the return value by 2:
      <code language="X#">
        hF := FOpen2("c:\data\sales", FO_READWRITE)
        IF hF != F_ERROR
        &#0009;? FWriteLine(hF, "Line1")&#0009;&#0009;// 7
        &#0009;? FWriteLine(hF, "Line1", 2)&#0009;// 4
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FPutS'>FPuts</seealso>
    <seealso cref='O:XSharp.Core.Functions.FWriteLine3'>FWriteLine3</seealso>
  </fwriteline>
  <fwriteline3>
    <summary>
      Write a string, a carriage-return character, and a linefeed character to an open file, specifying two strongly-typed arguments.
    </summary>

    <param name="ptrHandle">The handle of the file to write to.</param>
    <param name="cBuffer">The string to write.</param>
    <param name="dwBytes">
      The number of bytes in <paramref name="cBuffer" /> to write, beginning at the current file pointer position.
    </param>
    <returns>
      The number of bytes written.<br/>
      If the value returned is equal to <paramref name="dwBytes" /> + 2, the operation was successful.<br/>
      If the return value is less than <paramref name="dwBytes" /> + 2 or 0, this means that the length of  <paramref name="cBuffer" /> was less than <paramref name="dwBytes" />, or the disk is full, or another error has occurred.
    </returns>
    <remarks>
      This function is assumed to handle raw binary data and is not dependent upon the status of SetAnsi().  FWriteText() and FWrite4(), on the other hand, are dependent upon SetAnsi().
    </remarks>
    <example>
      This example uses FWriteLine3() to write 5 bytes. The carriage-return/linefeed pair increase the return value by 2:
      <code language="X#">
        hF := FOpen2("c:\data\sales", FO_READWRITE)
        IF hF != F_ERROR
        &#0009;? FWriteLine3(hF, "Line1", 5)&#0009;&#0009;//  7
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FPutS3'>FPuts3</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWriteLine'>FWriteLine</seealso>
  </fwriteline3>
  <fwritetext>
    <summary>
      Write a string to an open file, with SetAnsi() dependency.
    </summary>

    <param name="ptrHandle">The handle of the file to write to.</param>
    <param name="cBuffer">The string to write.</param>
    <param name="nBytes">
      The number of bytes in <paramref name="cBuffer" /> to write, beginning at the current file pointer position.<br/>
      If omitted, the entire contents of <paramref name="cBuffer" /> is written.
    </param>
    <returns>
      The number of bytes written.<br/>
      If the value returned is equal to <paramref name="nBytes" />, the operation was successful.<br/>
      If the return value is less than <paramref name="nBytes" /> or 0, this means that the length of <paramref name="cBuffer" /> is less than <paramref name="nBytes" />, or the disk is full, or another error has occurred.  FError() can be used to determine the specific error.
    </returns>
    <remarks>
      FWriteText() is the same as FWrite() except that an ANSI to OEM conversion is made if SetAnsi() is FALSE.
    </remarks>
    <example>
      This example copies the contents of one file to another.
      <code language="X#">
        DEFINE F_BLOCK := 512
        ...
        cBuffer := Space(F_BLOCK)
        // turn on OEM <paramref name="=" /> ANSI conversions
        SetAnsi(FALSE)
        nInfile := FOpen2("temp.txt", FO_READ)
        nOutfile := FCreate("newfile.txt", FC_NORMAL)
        lDone := FALSE
        DO WHILE !lDone
        &#0009;nBytesRead := FReadText(nInfile, @cBuffer, F_BLOCK)
        &#0009;IF FWriteText(nOutfile, cBuffer) &lt;
        &#0009;&#0009;SLen(cBuffer)
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;&#0009;lDone := TRUE
        &#0009;ELSE
        &#0009;&#0009;lDone := (nBytesRead = 0)
        &#0009;ENDIF
        ENDDO
        FClose(nInfile)
        FClose(nOutfile)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </fwritetext>
  <fwritetext3>
    <summary>
      Write the contents of a buffer to an open file, with SetAnsi() dependency.
    </summary>

    <param name="ptrHandle">The handle of the file to write to.</param>
    <param name="ptrBuffer">A pointer to the buffer to write.</param>
    <param name="dwBytes">
      The number of bytes in <paramref name="ptrBuffer" /> to write, beginning at the current file pointer position.
    </param>
    <returns>
      The number of bytes written.<br/>
      If the value returned is equal to <paramref name="dwBytes" />, the operation was successful.<br/>
      If the return value is less than <paramref name="dwBytes" /> or 0, this means that the length of <paramref name="ptrBuffer" /> is less than <paramref name="dwBytes" />, or the disk is full, or another error has occurred.  FError() can be used to determine the specific error.
    </returns>
    <remarks>
      FWriteText3() is the same as FWrite3() except that an ANSI to OEM conversion is made if SetAnsi() is FALSE.
    </remarks>
    <example>
      This example writes the contents of a PSZ to a file.
      <code language="X#">
        LOCAL pszBuff AS PSZ
        LOCAL ptrHandle AS PTR
        pszBuff := "hello" // psz converted data
        ptrHandle := FOpen2("temp.bin", FO_READWRITE)
        IF ptrHandle != F_ERROR
        &#0009;FWriteText3(ptrHandle, pszBuff, PszLen(pszBuff))
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite3'>FWrite3</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </fwritetext3>
  <getamext>
    <summary>
      Returns a string representing the morning extension for time strings in 12-hour format.
    </summary>
    <returns>
    </returns>
    <remarks>
      Time strings formatted using the 12-hour time format have an extension to specify if the time is in the morning or the evening.  GetAMExt() returns the current setting for the extension identifying morning time strings (that is, those between 12:00:00 midnight and just before 12:00:00 noon).<br/>
      A typical extension for morning time strings is "AM", which is how the function derives its name.
      The initial default for the morning extension is affected by SetInternational(), which you can refer to for more information.<br/>
      Use SetAMExt() to change the value of this setting.
    </remarks>
    <example>
      This example turns on the SetInternational() flag, causing the time string extensions to be determined by International settings in the Windows Control Panel:
      <code language="X#">
        SetInternational(#Windows)
        ? GetAMExt()&#0009;// Return value varies between systems
        ? GetPMExt()&#0009;// Typically, AM and PM are displayed
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetPMExt'>GetPMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAMExt'>SetAMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAmPm'>SetAMPM</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
  </getamext>
  <getapplocaleid>
    <summary>
      Gets the locale ID that the runtime uses for comparing strings when running in Windows collation mode (SetCollation(#Windows)).
    </summary>
    <returns>
      The current installed Locale.
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.SetAppLocaleID'>SetAppLocaleId</seealso>
  </getapplocaleid>

  <getcurpath>
    <summary>
      Get the current X# search path for opening file.
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses GetCurPath() to specify the directory where a file is to be processed:
      <code language="X#">FCreate2(GetCurPath() + "newfile.txt", FC_NORMAL)</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetPath'>SetPath</seealso>
  </getcurpath>
  <getdateformat>
    <summary>
      Return the current date format.
    </summary>
    <returns>
      The default date format supplied with X# or a customized date format defined via the SetDateFormat() or SetDateCountry() functions.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example returns the default date format:
      <code language="X#">
        FUNCTION Start()
        &#0009;QOut(GetDateFormat())&#0009;// Result: MM/DD/YY
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetDateCountry'>SetDateCountry</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDateFormat'>SetDateFormat</seealso>
  </getdateformat>
  <getdefault>
    <summary>
      Return the X# default drive and directory.
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses GetDefault() to display the default drive:
      <code language="X#">
        FUNCTION Start
        &#0009;? GetDefault()&#0009;&#0009;&#0009;// NULL_STRING
        &#0009;SetDefault("c:\vo\prg")
        &#0009;? GetDefault()&#0009;&#0009;&#0009;// c:\vo\prg\
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetDefault'>SetDefault</seealso>
  </getdefault>
  <getdefaultdir>
    <summary>
      Return the current SetDefault() setting.
    </summary>
    <returns>
    </returns>
    <remarks>
      Return the current SetDefault() setting. The string ends with a trailing "\".
    </remarks>
    <example>
      This example uses GetDefaultDir() to display the location of the error log file:
      <code language="X#">
        FUNCTION Start()
        &#0009;? GetDefaultDir()&#0009;&#0009;&#0009;// NULL_STRING
        &#0009;SetDefault("c:\vo\prg")
        &#0009;? GetDefaultDir()&#0009;&#0009;&#0009;// c:\vo\prg
      </code>
    </example>
    <seealso  cref="M:XSharp.Core.Functions.SetDefault">SetDefault</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetErrorLog'>SetErrorLog</seealso>
  </getdefaultdir>
  <getdllmajorversion>
    <summary>
      Return the major version number of a DLL
    </summary>

    <param name="cDLL">The name of the DLL whose version you want to read</param>
    <returns>
    </returns>
    <remarks>
      Return the current major Version number of a DLL
      <br/>



      The DLL must contain a function called DllGetVersion which fills in a _WINDLLVERSIONINFO structure. This convention for determining DLL version is followed by Windows DLLs such as Shell32.DLL
    </remarks>
    <example>
    </example>
    <seealsocmd>GetShellMajorVersion Function</seealsocmd>
  </getdllmajorversion>
  <getdoserror>
    <summary>
      Return the DOS error code from any application.
    </summary>
    <returns>
    </returns>
    <remarks>
      The value of GetDOSError() is an extended DOS error code which is never cleared.<br/>
      The application which sets this error code need not be the current application or even a X# application.  By contrast, on every DOS call in a X# application, the value of DOSError() is set to the current DOS error if there was an error or is cleared to 0 if there was no error.
    </remarks>
    <example>
      In this example, DOSError() indicates that the last DOS call in the current application did not generate an error.  By contrast, GetDOSError() indicates that a DOS error occurred in the system previously:
      <code language="X#">
        ? DOSError()&#0009;&#0009;&#0009;// 0
        ? GetDOSError()&#0009;&#0009;// 2
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.DosError'>DOSError</seealso>
  </getdoserror>
  <getenv>
    <summary>
      Retrieve the contents of a DOS environment variable.
    </summary>

    <param name="cEnvVariable">The name of the environment variable whose contents you want to retrieve.  (Note that GetEnv() is not case-sensitive.)</param>
    <returns>
      The contents of the specified environment variable.<br/>
      If the variable cannot be found, GetEnv() returns a NULL_STRING.
    </returns>
    <remarks>
      GetEnv() lets you retrieve information from the DOS environment into an application program.  Typically, this is configuration information — including path names — that describe the location of files (database, index, label, or reports).
      Note:  Instead of using environment variables for configuring your application, you may want to consider using registry settings.
      <note type="tip">
        Empty return value:<br/>
        If you are certain that an environment variable exists and yet GetEnv() always returns a NULL_STRING, be sure there are no spaces between the environment variable name and the first character of the string assigned to it in the DOS SET command.
      </note>
    </remarks>
    <example>
      This example retrieves the current DOS path setting, making it the current X# path:
      <code language="X#">
        cPath := GetEnv("PATH")
        SET PATH TO (cPath)
      </code>
      This example uses environment variables to configure the specific locations of files.  When you set up a system, define environment variables that contain the location of various file types, like this:
      <code language="X#">
        C&gt;SET LOC_DBF=<paramref name="DatabaseFilePath" />
        C&gt;SET LOC_NTX=<paramref name="IndexFilePath" />
        C&gt;SET LOC_RPT=<paramref name="ReportFilePath" />
      </code>
      In the configuration section of your application program, assign the contents of the environment variables to variables.<br/>
      Then when you access a file, preface the reference with the path, as follows:
      <code language="X#">
        cDdfDirectory := GetEnv("LOC_DBF")
        USE (cDdfDirectory + "invoices.dbf")
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegInt'>QueryRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegString'>QueryRTRegString</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetEnv'>SetEnv</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegInt'>SetRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegString'>SetRTRegString</seealso>
  </getenv>
  <getfattr>
    <summary>
      Convert file attributes to numbers.
    </summary>

    <param name="uAttributes">
      One or more of the following constants or strings:<br/>

      &#0009;Character&#0009;Constant&#0009;Description<br/>

      &#0009;A&#0009;FC_ARCHIVED&#0009;Archived<br/>

      &#0009;D&#0009;FA_DIRECTORY&#0009;Directory<br/>

      &#0009;H&#0009;FC_HIDDEN&#0009;Hidden<br/>

      &#0009;NULL_STRING&#0009;FC_NORMAL&#0009;Read/write<br/>

      &#0009;R&#0009;FC_READONLY&#0009;Read-only<br/>

      &#0009;S&#0009;FC_SYSTEM&#0009;System<br/>

      &#0009;V&#0009;FA_VOLUME&#0009;Search for the DOS volume label and exclude all other files<br/>

      &#0009;To specify more than one constant, you can either add attributes together, as in FC_SYSTEM + FC_HIDDEN, or use the _Or() operator, as in _Or(FC_SYSTEM, FC_HIDDEN).<br/>
      To specify more than one string, simply concatenate them, as in "SH."
    </param>
    <returns>
      A number that represents the file attribute specified.<br/>
      This number could represent two or more file attributes added together.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses GetFAttr() to return file attributes as a number:
      <code language="X#">
        ? GetFAttr(FA_DIRECTORY)&#0009;&#0009;&#0009;&#0009;// 16
        ? GetFAttr(FC_ARCHIVED + FC_READONLY)&#0009;// 33
        ? GetFAttr("AR")&#0009;&#0009;&#0009;&#0009;&#0009;// 33
        // Below GetFAttr() converts a string
        // to the required numeric format
        ? FFirst("*.txt", GetFAttr("H"))
      </code>
    </example>
    <seealsocmd>_Or</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
  </getfattr>
  <getfmask>
    <summary>
      Prepare a file specification for wildcard searching.
    </summary>

    <param name="cString">The name of a drive and/or directory and/or file.</param>
    <returns>
      If <paramref name="cString" /> ends with ":" or "\", the modified <paramref name="cString" /> +"*.*" is returned; otherwise <paramref name="cString" /> is returned.
    </returns>
    <remarks>
      If <paramref name="cString" /> ends with ":" or "\", indicating that <paramref name="cString" /> is a drive or directory, "*.*" is added.<br/>
      This enables searching through all files in the drive or directory specified.
    </remarks>
    <example>
      This example uses GetFMask() to add a wild-card search to the arguments passed to Dir() and File().
      <code language="X#">
        LOCAL cOrigin AS STRING
        LOCAL cSearch AS STRING
        cOrigin := "c:"
        cSearch := GetFMask(cOrigin)
        ? cSearch&#0009;&#0009;&#0009;&#0009;&#0009;// c:*.*
        Dir(cSearch)
        File(cSearch)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FFirst'>FFirst</seealso>
  </getfmask>

  <getfolderpath>
    <summary>
      Return a folder path as a string.
    </summary>

    <param name="nFolder">A constent or an integer that represents the folder you require the path of.</param>
    <param name="CSIDL_PERSONAL"> := 0x0005 // My Documents</param>
    <param name="CSIDL_MYMUSIC"> := 0x000d // "My Music" folder</param>
    <param name="CSIDL_APPDATA"> := 0x001A // Application Data, new for NT4</param>
    <param name="CSIDL_LOCAL_APPDATA"> := 0x001C // non roaming, user\Local Settings\Application Data</param>
    <param name="CSIDL_INTERNET_CACHE"> := 0x0020</param>
    <param name="CSIDL_COOKIES"> := 0x0021</param>
    <param name="CSIDL_HISTORY"> := 0x0022</param>
    <param name="CSIDL_COMMON_APPDATA"> := 0x0023 // All Users\Application Data</param>
    <param name="CSIDL_WINDOWS"> := 0x0024 // GetWindowsDirectory()</param>
    <param name="CSIDL_SYSTEM"> := 0x0025 // GetSystemDirectory()</param>
    <param name="CSIDL_PROGRAM_FILES"> := 0x0026 // C:\Program Files</param>
    <param name="CSIDL_MYPICTURES"> := 0x0027 // My Pictures, new for Win2K</param>
    <param name="CSIDL_PROGRAM_FILES_COMMON"> := 0x002b // C:\Program Files\Common</param>
    <param name="CSIDL_COMMON_DOCUMENTS"> := 0x002e // All Users\Documents</param>
    <param name="CSIDL_RESOURCES"> := 0x0038 // %windir%\Resources\, For theme and other windows resources.</param>
    <param name="CSIDL_RESOURCES_LOCALIZED">
      := 0x0039 // %windir%\Resources\<paramref name="LangID" />, for theme and other windows specific resources.
    </param>
    <param name="CSIDL_COMMON_ADMINTOOLS"> := 0x002f // All Users\Start Menu\Programs\Administrative Tools</param>
    <param name="CSIDL_ADMINTOOLS"> := 0x0030</param>
    <param name="lCreate">TRUE to create nominated folder, FALSE to retrieve </param>
    <param name="hToken">Only needed in special cases. See SHGetFolderPath API func.</param>
    <param name="dwFlags">Only needed in special cases. See SHGetFolderPath API func.</param>
    <returns>
      The path to the requested folder as a string.
      <br/>



      This requires IE4 (Shell 4.71) or later.
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </getfolderpath>
  <getnatdll>
    <summary>
      Get the current DLL for nation-dependent operations and messages.
    </summary>
    <returns>
      The name of the current nation-dependent DLL.
    </returns>
    <remarks>
      The default library for nation-dependent operations is VO28NAT.DLL, but you can change it using SetNatDLL().  GetNatDLL() returns the current setting for the nation-dependent DLL.
    </remarks>
    <example>
      This example shows the difference in the return value of GetNatDLL() before and after a call to SetNatDLL():
      <code language="X#">
        ? GetNatDLL()&#0009;&#0009;&#0009;&#0009;// VO28NAT.DLL
        ? SetNatDLL("GERMAN.DLL")&#0009;&#0009;// .T.
        ? GetNatDLL()&#0009;&#0009;&#0009;&#0009;// GERMAN.DLL
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetNatDLL'>SetNatDLL</seealso>
  </getnatdll>
  <getpmext>
    <summary>
      Returns a string representing the evening extension for time strings in 12-hour format.
    </summary>
    <returns>
    </returns>
    <remarks>
      Time strings formatted using the 12-hour time format have an extension to specify if the time is in the morning or the evening.  GetPMExt() returns the current setting for the extension identifying evening time strings (that is, those between 12:00:00 noon and just before 12:00:00 midnight).<br/>
      A typical extension for evening time strings is "PM", which is how the function derives its name.
      The initial default for the evening extension is affected by SetInternational(), which you can refer to for more information.<br/>
      Use SetPMExt() to change the value of this setting.
      Note:<br/>
      If SetInternational(#Windows) is in effect, the evening extension is also displayed as part of the 24-hour time format.<br/>
      This is a Windows standard that is not specific to X#.
    </remarks>
    <example>
      This example turns on the SetInternational() flag, causing the time string extensions to be determined by International settings in the Windows Control Panel:
      <code language="X#">
        SetInternational(#Windows)
        ? GetAMExt()&#0009;&#0009;&#0009;// Return value varies between systems
        ? GetPMExt()&#0009;&#0009;&#0009;// Typically, AM and PM are displayed
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetAMExt'>GetAMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAmPm'>SetAMPM</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPMExt'>SetPMExt</seealso>
  </getpmext>
  <getshellmajorversion>
    <summary>
      Return the major version number of a DLL
    </summary>
    <returns>
    </returns>
    <remarks>
      Returns the major version number of the Windows Shell, SHELL32.DLL.
    </remarks>
    <example>
    </example>
    <seealsocmd>GetDLLMajorVersion Function</seealsocmd>
  </getshellmajorversion>
  <getstoragenames>
    <summary>
      Fills up the passed array with the names of the storages in the OLEObject storage file.
    </summary>

    <param name="cFileName">The name of the storage file.</param>
    <param name="cStorages">The name of the array.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      The following example is from the OLE Container application in \CAVOxx\SAMPLES\OLE\CONT:
      <code language="X#">
        METHOD FileLoad() CLASS ContainerShell
        LOCAL oOle AS DraggableOleObject
        LOCAL oOD AS OpenDialog
        LOCAL aStgNames AS ARRAY
        LOCAL i AS INT
        LOCAL oCont AS Container
        (oOD := OpenDialog{SELF, "*.CDF"}):Show()
        aStgNames := {}
        IF (!EMPTY(oOD:FileName) .and. GetStorageNames(oOD:FileName, aStgNames))
        &#0009;oCont := SELF:FileNew()
        &#0009;oCont:Caption := oOD:FileName
        &#0009;IF (oCont != NULL_OBJECT)
        &#0009;  FOR i:=1 TO ALen(aStgNames)
        &#0009;&#0009;oOle := DraggableOleObject{oCont}
        &#0009;&#0009;IF (oOle:ImportFromStorage(oOD:Filename, aStgNames[i]))
        &#0009;&#0009;oCont:SetupOLEObject(oOle, NIL, TRUE)
        &#0009;  &#0009;ELSE
        &#0009;&#0009;oOle:Destroy()
        &#0009;&#0009;ENDIF
        &#0009;  NEXT
        &#0009;ENDIF
        ENDIF
      </code>
      <br/>



      OLE Library
    </example>
    <seealsocmd>DeleteStorage</seealsocmd>
  </getstoragenames>
  <getsystemmessage>
    <summary>
      Convert a system error code to a text message.
    </summary>

    <param name="dwId">A DWord system error code. This is usually the result of GetLastError().</param>
    <returns>
      The system message associated with the error code passed in.
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </getsystemmessage>
  <gettickcountlow>
    <summary>
      Get the number of 1/10000 seconds that have elapsed since Windows was started.
    </summary>
    <returns>
      The number of 1/10000 seconds (milliseconds/10) that have elapsed since Windows was last started.
    </returns>
    <remarks>
      Because of the range of a DWORD, after 5 days there will be a numeric overflow.
    </remarks>
    <example>
      This example returns the number of seconds since Windows was started:
      <code language="X#">
        ? "Windows has been running for",;
        GetTickCountLow()/10000, "seconds"
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Seconds'>Seconds</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
  </gettickcountlow>
  <gettimesep>
    <summary>
      Return the current separation character used in time strings.
    </summary>
    <returns>
      The ASCII value of the current time separator (the character being used to separate hours, minutes and seconds in time strings).  Since the default time separator is a colon (:), GetTimeSep() returns 58 by default.  Note that you can use the Chr() function to convert this return value to a character.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses GetTimeSep() to display the current time separator:
      <code language="X#">
        ? TIME()&#0009;&#0009;&#0009;&#0009;// 08:31:53
        ? GetTimeSep()&#0009;&#0009;&#0009;// 58
        ? CHR(GetTimeSep())&#0009;&#0009;// :
        SetTimeSep(ASC("*"))&#0009;&#0009;// Set time separator to *
        ? TIME()&#0009;&#0009;&#0009;&#0009;// 08*31*56
        ? GetTimeSep()&#0009;&#0009;&#0009;// 42
        ? CHR(GetTimeSep())&#0009;&#0009;// *
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Asc'>Asc</seealso>
    <seealso cref='O:XSharp.Core.Functions.Chr'>Chr</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetTimeSep'>SetTimeSep</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
  </gettimesep>
  <hardcr>
    <summary>
      Replace all soft carriage returns (Chr(141)) in a string with hard carriage returns (Chr(13)).
    </summary>

    <param name="cString">The string to convert.</param>
    <returns>
    </returns>
    <remarks>
      Soft carriage returns are added by MemoEdit() when lines wrap.  X# console commands, like REPORT and LABEL FORM, do not automatically convert soft carriage returns to hard carriage returns; therefore, in order to display long strings and memo fields containing soft carriage returns, you must convert them.
    </remarks>
    <example>
      This examples uses HardCR() to display a memo field that has been formatted with the automatic word wrapping of MemoEdit():
      <code language="X#">
        USE sales NEW
        ? HARDCR(sales-&gt;Notes)
      </code>
      This example formats a string:
      <code language="X#">
        ? HARDCR(_Chr(141) + _Chr(10))
        // Result: _Chr(13) + _Chr(10)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Chr'>Chr</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemoTran'>MemoTran</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrTran'>StrTran</seealso>
  </hardcr>
  <header>
    <summary>
      Return the length of the database file header.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      The number of bytes in the header of the database file.<br/>
      If no database file is in use, Header() returns a 0.
    </returns>
    <remarks>
      Header() is used with LastRec(), RecSize(), and DiskSpace() to create procedures for backing up files.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      This example determines the header size of the SALES.DBF:
      <code language="X#">
        USE sales NEW
        QOut(Header())&#0009;&#0009;&#0009;// Result: 258
      </code>
      This example defines a pseudofunction, DBFSize(), that uses Header() with RecSize() and LastRec() to calculate the size of the current database file in bytes:
      <code language="X#">define DBFSize() ((RecSize() * LastRec()) + Header() + 1)</code>
      Later you can use DBFSize() as you would any function:
      <code language="X#">
        USE sales NEW
        USE customer NEW
        QOut(DBFSize())
        QOut(Sales-&gt;DBFSize())
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.Core.Functions.DiskSpace'>DiskSpace</seealso>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
    <seealso cref='O:XSharp.RT.Functions.RecSize'>RecSize</seealso>
  </header>
  <hibyte>
    <summary>
      Return the high-order (leftmost) byte in a number.
    </summary>

    <param name="wValue">The number whose high-order byte you want to get.</param>
    <returns>
    </returns>
    <remarks>
      Related data can be stored in the high-order and low-order words of a variable.<br/>
      Therefore, instead of creating and returning a 2-element array, it may be more efficient to return a word whose 2 bytes contain separate information.
    </remarks>
    <example>
      This example applies HiByte() and LoByte() to a binary number.<br/>
      It also displays the high-order and low-order portions of the binary number as 2 separate numbers:
      <code language="X#">
        bHi := HiByte(0b0000000011111111)
        bLow := LoByte(0b0000000011111111)
        // High-order bits
        ? 0b00000000&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 0
        ? bHi&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 0
        // Low-order bits
        ? 0b11111111&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 255
        ? bLow&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 255
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.HiWord'>HiWord</seealso>
    <seealso cref='O:XSharp.Core.Functions.LoByte'>LoByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.LoWord'>LoWord</seealso>
  </hibyte>
  <hiword>
    <summary>
      Return the high-order (leftmost) word in a number.
    </summary>

    <param name="dwValue">The number whose high-order word you want to get.</param>
    <returns>
    </returns>
    <remarks>
      Related data can be stored in the high-order and low-order words of a variable.<br/>
      Therefore, instead of creating and returning a 2-element array, it may be more efficient to return a double word whose 2 words contain separate information.<br/>
      Also, many Windows API functions receive data in a LONGINT argument.<br/>
      Usually the high-order and low-order words of this argument contain different information about a window and its messages.  HiWord() can be used to extract the high-order word of this argument.
    </remarks>
    <example>
      This example applies HiWord() and LoWord() to a binary number.<br/>
      It also displays the high-order and low-order portions of the binary number as 2 separate numbers:
      <code language="X#">
        ? HiWord(0b00001000100000011111111100001111)
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;//  2177
        ? LoWord(0b00001000100000011111111100001111)
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 65295
        // High-order bits
        ? 0b0000100010000001&#0009;&#0009;&#0009;&#0009;//  2177
        // Low-order bits
        ? 0b1111111100001111&#0009;&#0009;&#0009;&#0009;// 65295
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.HiByte'>HiByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.LoByte'>LoByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.LoWord'>LoWord</seealso>
  </hiword>
  <i2bin>
    <summary>
      Convert a short integer to a string containing a 16-bit signed integer.
    </summary>

    <param name="siValue">The value to convert.  Decimal digits are truncated.</param>
    <returns>
    </returns>
    <remarks>
      I2Bin() is a conversion function that converts a short integer to a 2-byte string.  Typical applications include reading foreign file types in their native format and then saving, reading, decrypting, and transmitting numeric data in their compressed binary form instead of in strings.<br/>
      Its inverse is Bin2I().
    </remarks>
    <example>
      This example opens a database file using file functions and writes a new date of the last update to bytes 1-3:
      <code language="X#">
        ptrHandle = FOpen2("sales.dbf", FO_READWRITE)
        // Convert date of last update to int
        cYear := I2Bin(1990)
        // The more efficient _Chr() is used instead of
        // I2Bin() since the return fits in one byte
        cMonth := _Chr(12)
        cDay := _Chr(15)
        // Point to the date of last update
        FSeek(ptrHandle, 1, FS_SET)
        // Write new update date using only the first
        // byte
        FWrite3(ptrHandle, cYear, 1)
        FWrite3(ptrHandle, cMonth, 1)
        FWrite3(ptrHandle, cDay, 1)
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </i2bin>
  <incollect>
    <summary>
      Check whether the application is in a garbage collection phase.
    </summary>
    <returns>
      TRUE if the application is collecting garbage; otherwise, FALSE.
    </returns>
    <remarks>
      Inside Axit() methods and within routines that are registered to be called at the time of garbage collection, InCollect() might be TRUE.  In such cases, you should avoid altering dynamic objects or call UnregisterAxit() to terminate the registration of Axit() methods or garbage collection routines.
    </remarks>
    <example>
      This example checks whether the application is in garbage collection before clearing out a string and calling UnregisterAxit():
      <code language="X#">
        Method AXIT() CLASS CaptainCautious
        IF !InCollect()
        &#0009;cInstanceVar := ""
        &#0009;UnregisterAxit(SELF)
      </code>
      &#0009;
      <code language="X#">
        ENDIF
        RETURN NIL
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.RegisterAxit'>RegisterAxit</seealso>
    <seealso cref='O:XSharp.RT.Functions.UnRegisterAxit'>UnregisterAxit</seealso>
  </incollect>
  <indexcount>
    <summary>Returns the # of open indexes in the current workarea</summary>
  </indexcount>
  <indexext>
    <summary>
      Return the default index file extension for a work area as defined by its RDD.
    </summary>
    <returns>
      A string indicating the default index file extension for a work area as defined by its RDD.
    </returns>
    <remarks>
      This function is provided for compatibility only.<br/>
      The recommended function for obtaining the default index file extension is DBOrderInfo(DBOI_INDEXEXT).
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </indexext>
  <indexhplock>
    <summary>
      Return and optionally change the setting that determines whether to use the High Performance (HP) locking schema for newly created .NTX files.
    </summary>

    <param name="lNewSetting">
      TRUE uses the HP locking schema.  FALSE uses the standard locking schema as defined by NewIndexLock().<br/>
      The initial default is FALSE, which can be changed using the HPLock entry (1 means TRUE and 0 means FALSE) in the X# section of WIN.INI.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, IndexHPLock() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      By default, this function sets the index locking schema for the current work area.<br/>
      It can be made to operate on an unselected work area by specifying it within an aliased expression.  Thus, you can set a separate flag for each work area.  You cannot, however, use index files with different locking schema in the same work area.
      This setting affects only newly created index files.<br/>
      It has no effect on existing files, in which locking schema is determined by information stored in the file's header record.
      Note:<br/>
      This function applies only if you are using the DBFNTX RDD.
      Important!<br/>
      If your application must share data with an Xbase product, either simultaneously or at different times, do not set IndexHPLock(TRUE) or include HPLock=1 in the X# settings in WIN.INI.  Doing so will make your .NTX files incompatible with these products.
    </remarks>
    <example>
      This example illustrates the status of IndexHPLock() after several calls to the function:
      <code language="X#">
        ? IndexHPLock()&#0009;&#0009;// FALSE (initial setting)
        ? IndexHPLock(TRUE)&#0009;// FALSE (previous setting)
        ? IndexHPLock()&#0009;&#0009;// TRUE  (current setting)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
  </indexhplock>
  <indexkey>
    <summary>
      Return the key expression of a specified order.
    </summary>

    <param name="nPosition">
      The position of the order in the order list of the work area.<br/>
      A value of 0 specifies the controlling order, without regard to its actual position in the list.
    </param>
    <returns>
      The key expression of the specified order.<br/>
      If there is no corresponding order or if no database file is open, IndexKey() returns a NULL_STRING.
    </returns>
    <remarks>
      This function is provided for compatibility only.<br/>
      The recommended function for obtaining the key expression of an order is DBOrderInfo(DBOI_EXPRESSION,, <paramref name="nPosition" />).
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </indexkey>
  <indexord>
    <summary>
      Return the position of the controlling order within the order list.
    </summary>
    <returns>
      The position of the controlling order.<br/>
      A value of 0 indicates either that no database file is open or that there is no controlling order and records are being accessed in natural order.
    </returns>
    <remarks>
      This function is provided for compatibility only.<br/>
      The recommended function for obtaining the position of the controlling order is DBOrderInfo(DBOI_NUMBER).
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </indexord>
  <inlist>
    <summary>
      Indicate whether the first expression in a series is repeated later in the series.
    </summary>
    <param name="uValue">
      The value that is looked up in the list. This can be any data type.
    </param>
    <param name="uValueList">
      A list of expressions separated by commas.<br/>
      These expressions should be the same data type as the expression in <paramref name="uValue" /><br/>
      If one or more of these expressions are not the same type as the first expression,
      a runtime error may happening indicating a data type mismatch.
    </param>
    <returns>
      TRUE if the first expression matches any of the other listed expressions; otherwise, FALSE.
    </returns>
    <example>
      This examples use InList() to indicate whether the first expression in each series is repeated later in the series:
      <code language="X#">
        ? InList("b", "a", "b", "c")&#0009;&#0009;// TRUE
        ? InList("d", "a", "b", "c")&#0009;&#0009;// FALSE
        nJack  := 11
        nQueen := 12
        nKing  := 13
        nAce   := 14
        ? InList(nJack, nQueen, nKing, nAce) &#0009;// FALSE
        ? InList(nJack, nAce, nJack, nQueen, nKing) &#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Instr'>InStr</seealso>
  </inlist>
  <instr>
    <summary>
      Indicate whether a substring is contained in a string.
    </summary>

    <param name="cSearch">The substring to search for.</param>
    <param name="cTarget">The string in which to search.</param>
    <returns>
      TRUE if the substring was found; otherwise, FALSE.
    </returns>
    <remarks>
      InStr() is a strongly typed version of the $ operator.
    </remarks>
    <example>
      This example uses InStr() to indicate if a specific substring is part of a longer string:
      <code language="X#">
        LOCAL cSearch AS STRING
        LOCAL cTarget AS STRING
        cSearch := "Bend"
        cTarget := "Indian Bend Road"
        IF InStr(cSearch, cTarget)
        &#0009;? "Found It"
        END
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.RT.Functions.InList'>InList</seealso>
    <seealso cref='O:XSharp.RT.Functions.InListExact'>InList</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </instr>
  <integer>
    <summary>
      Truncate or floor a number with decimal digits to a whole number.
    </summary>

    <param name="nValue">The number to truncate or floor.</param>
    <returns>
      The whole number to the left of the decimal point.  Since both <paramref name="uValue" /> and the return value are data type USUAL, you are not limited to the size of an integer.
    </returns>
    <remarks>
      Integer() converts a numeric value to an integer by taking the floor of the number. Note – this is not the same as truncation except for positive integers — it is not rounding.  Integer() is useful in operations where the decimal portion of a number is not needed.
      Note that a loss of precision on floating numbers might be significant.<br/>
      For example, you might not know that a number is internally represented as 0.99999999999999999, because, when that number is displayed with QOut() or passed to the Str() function, internal rounding returns a value of 1.0.
      When a number like that is passed to the Integer() function, however, its decimal portion is truncated and a value of zero is returned.<br/>
      If this is not what you had intended, you can use Round(<paramref name="nValue" />, 0) instead of Integer().
      <note type="tip">
        Integer() is the same as the Int() function in CA-Clipper, but INT is a reserved word in X#.
        Under X#, Int() is a conversion operator.  With numbers that are not greater than a short integer, it yields the same results as Integer() and maintains compatibility with CA-Clipper.
      </note>
    </remarks>
    <example>
      These examples demonstrate the results of various invocations of the Integer() function:
      <code language="X#">
        ? Integer(100.00)&#0009;&#0009;// 100
        ? Integer(.5)&#0009;&#0009;&#0009;// 0
        ? Integer(-100.75)&#0009;&#0009;// -100
        ? Integer(-1.2)&#0009;&#0009;// -1
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Ceil'>Ceil</seealso>
    <seealso cref='O:XSharp.RT.Functions.Floor'>Floor</seealso>
    <seealso cref='O:XSharp.RT.Functions.Frac'>Frac</seealso>
    <seealso cref='O:XSharp.RT.Functions.Round'>Round</seealso>
  </integer>
  <isaccess>
    <summary>
      Check whether a particular access method can be sent to an object.
    </summary>

    <param name="oObject">An object.</param>
    <param name="symAccess">The access method name.</param>
    <returns>
      TRUE if the specified access method is defined for the class of the specified object; otherwise, FALSE.
      <br/>



      This example checks if x and y of CLASS MyClass are true instance variables or if they are overridden by an access:
      <code language="X#">
        CLASS MyClass
        &#0009;EXPORT x
        ACCESS y CLASS MyClass
        FUNCTION Start()
        &#0009;LOCAL o AS MyClass
        &#0009;o := MyClass{}
        ?IsAccess(o,#x)&#0009;&#0009;&#0009;// FALSE
        ?IsAccess(o,#y)&#0009;&#0009;&#0009;// TRUE
      </code>
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IsAssign'>IsAssign</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethod'>IsMethod</seealso>
  </isaccess>
  <isalnum>
    <summary>
      Determine if the leftmost character in a string is alphanumeric.
    </summary>

    <param name="pszString">The string to examine.</param>
    <returns>
      TRUE if the first character in <paramref name="pszString" /> is either alphabetic or numeric; FALSE if the string begins with any character other than a number or letter.
    </returns>
    <remarks>
      This function is nation-dependent.  In the US version, for example, an alphanumeric character is a number from '0' to '9' or an uppercase or lowercase English letter from A to Z.
    </remarks>
    <example>
      These examples demonstrate various results of IsAlNum():
      <code language="X#">
        ? IsAlNum("AbcDe")&#0009;&#0009;// TRUE
        ? IsAlNum("aBcDE")&#0009;&#0009;// TRUE
        ? IsAlNum("1BCde")&#0009;&#0009;// TRUE
        ? IsAlNum(".Steve")&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsAlpha'>IsAlpha</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsDigit'>IsDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsSpace'>IsSpace</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsXDigit'>IsXDigit</seealso>
  </isalnum>
  <isalpha>
    <summary>
      Determine if the leftmost character in a string is alphabetic.
    </summary>

    <param name="pszString">The string to examine.</param>
    <returns>
      TRUE if the first character in <paramref name="pszString" /> is alphabetic; FALSE if the string begins with a digit or any other non-alphabetic character.
    </returns>
    <remarks>
      This function is nation-dependent.  In the US version, for example, an alphabetic character  is any uppercase or lowercase English letter from A to Z.
    </remarks>
    <example>
      These examples demonstrate various results of IsAlpha():
      <code language="X#">
        ? IsAlpha("Carl")&#0009;&#0009;&#0009;// TRUE
        ? IsAlpha("aBcDE")&#0009;&#0009;// TRUE
        ? IsAlpha("1BCde")&#0009;&#0009;// TRUE
        ? IsAlpha("..Flemming")&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsAlNum'>IsAlNum</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsDigit'>IsDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
  </isalpha>
  <isappthemed>
    <summary>
      Return the theme setting for the current application.
    </summary>
    <returns>
      Reports whether the current application's user interface displays using visual styles. A visual style can be turned off in Control Panel, so that an application can support visual styles but not have a visual style applied at a given time.
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </isappthemed>
  <isarray>
    <summary>
      Determine if a value is an array.
    </summary>

    <param name="uValue">The value to examine.</param>
    <returns>
      TRUE if the value is an array; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses IsArray() to determine a course of action:
      <code language="X#">
        DO CASE
        &#0009;CASE IsArray(uValue)
        &#0009;&#0009;AEval(uValue, cbBlock)
        &#0009;CASE IsString(uValue)
        &#0009;&#0009;SEval(uValue, cbBlock)
        &#0009;OTHERWISE
        &#0009;&#0009;Eval(cbBlock)
        ENDCASE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsClass'>IsClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsCodeBlock'>IsCodeBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsInstanceOfUsual'>IsInstanceOfUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </isarray>
  <isassign>
    <summary>
      Check whether a particular assign method can be sent to an object.
    </summary>

    <param name="oObject">An object.</param>
    <param name="symAssign">The assign method name.</param>
    <returns>
      TRUE if the specified assign method is defined for the class of the specified object; otherwise, FALSE.
      <br/>



      This example checks if x and y of CLASS MyClass are true instance variables or if they are overridden by an assign:
      <code language="X#">
        CLASS MyClass
        &#0009;EXPORT x
        ASSIGN y(a) CLASS MyClass
        FUNCTION Start()
        &#0009;LOCAL o AS MyClass
        &#0009;o := MyClass{}
        ?IsAssign(o,#x)&#0009;&#0009;&#0009;// FALSE
        ?IsAssign(o,#y)&#0009;&#0009;&#0009;// TRUE
      </code>
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IsAccess'>IsAccess</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethod'>IsMethod</seealso>
  </isassign>
  <isbdigit>
    <summary>
      Determine if the leftmost character in a string is a binary digit (0 or 1).
    </summary>

    <param name="pszString">The string to examine.</param>
    <returns>
      TRUE if the first character of the string is 0 or 1; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      These examples demonstrate various results of IsBDigit():
      <code language="X#">
        ? IsBDigit("AbcDe")&#0009;&#0009;// FALSE
        ? IsBDigit("1abcd")&#0009;&#0009;// TRUE
        ? IsBDigit("012345")&#0009;// TRUE
        ? IsBDigit("21345")&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsAlpha'>IsAlpha</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsDigit'>IsDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsXDigit'>IsXDigit</seealso>
  </isbdigit>
  <isclass>
    <summary>
      Determine if a class exists.
    </summary>

    <param name="symClassName">The symbol of the class to examine.</param>
    <returns>
      TRUE if the class exists; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example shows that IsClass() returns TRUE for a declared class name:
      <code language="X#">
        CLASS Cars&#0009;&#0009;&#0009;// Declare a class named Cars
        ? IsClass(#Cars)&#0009;&#0009;// TRUE
      </code>
      This example uses IsClass() to decide how to manipulate colors:
      <code language="X#">
        LOCAL uColor AS USUAL
        IF IsClass(#CustomPalette)
        &#0009;uColor := CustomPalette{}
        ELSE
        &#0009;uColor := SetColor()
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsClassOf'>IsClassOf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsCodeBlock'>IsCodeBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
  </isclass>
  <isclassof>
    <summary>
      Determine if one class is a subclass of another class.
    </summary>

    <param name="symClassName">The symbol of the class to examine.</param>
    <param name="symSuperClassName">The symbol of the superclass to examine.</param>
    <returns>
      TRUE if <paramref name="symClassName" /> inherits from <paramref name="symSuperClassName" />; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      The following example shows the result of IsClassOf() when queried:
      <code language="X#">
        CLASS A
        CLASS B INHERIT A
        CLASS C
        FUNCTION CheckClasses()
        ? IsClassOf(#B, #A)      // TRUE
        ? IsClassOf(#B, #C)      // FALSE
        ? IsClassOf(#C, #A)      // FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IsClass'>IsClass</seealso>
  </isclassof>
  <iscodeblock>
    <summary>
      Determine if a value is a code block.
    </summary>

    <param name="uValue">The value to examine.</param>
    <returns>
      TRUE if the value is a code block; otherwise, FALSE.
    </returns>
    <remarks>
      IsCodeBlock() identifies both runtime and compile-time code blocks as code blocks.<br/>
      UsualType(), on the other hand, identifies runtime code blocks as objects.
    </remarks>
    <example>
      This example uses IsCodeBlock() and UsualType() on a runtime code block:
      <code language="X#">
        LOCAL cbRunTime
        // Create code block at runtime
        cbRunTime := &amp;("{||TRUE}")
        ? UsualType(cbRunTime)&#0009;&#0009;&#0009;&#0009;// OBJECT
        ? IsCodeBlock(cbRunTime)&#0009;&#0009;&#0009;&#0009;// TRUE
      </code>
      This example uses IsCodeBlock() and UsualType() on a compile-time code block:
      <code language="X#">
        LOCAL cbCompileTime
        // Code block known at compile-time
        cbCompileTime := {||TRUE}
        ? UsualType(cbCompileTime)&#0009;&#0009;&#0009;// CODEBLOCK
        ? IsCodeBlock(cbCompileTime)&#0009;&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsClass'>IsClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </iscodeblock>
  <isdate>
    <summary>
      Determine if a value is a DATE.
    </summary>

    <param name="uValue">The value to examine.</param>
    <returns>
      TRUE if the value is a DATE data type; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses IsDate() to determine whether any data conversion is needed:
      <code language="X#">
        IF IsString(uValue)
        &#0009;uValue := CToD(uValue)
        ELSEIF !IsDate(uValue)
        &#0009;uValue := Today()
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </isdate>
  <isdigit>
    <summary>
      Determine if the leftmost character in a string is a digit (that is, a numeric digit between 0 and 9).
    </summary>

    <param name="pszString">The string to examine.</param>
    <returns>
      TRUE if the first character of the string is a number from 0 to 9; otherwise; FALSE.
    </returns>
    <remarks>
      IsDigit() is useful when you need to know if the current string is a number before converting it to a numeric value with the Val() function.
    </remarks>
    <example>
      These examples demonstrate various results of IsDigit():
      <code language="X#">
        ? IsDigit("AbcDe")&#0009;&#0009;&#0009;&#0009;// FALSE
        ? IsDigit("1abcd")&#0009;&#0009;&#0009;&#0009;// TRUE
        ? IsDigit(".12345")&#0009;&#0009;&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsAlpha'>IsAlpha</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsBDigit'>IsBDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsXDigit'>IsXDigit</seealso>
  </isdigit>
  <isfloat>
    <summary>
      Determine if a value is a FLOAT.
    </summary>

    <param name="uValue">The value to examine.</param>
    <returns>
      TRUE if the value is the FLOAT data type; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses IsFloat() to determine how to format numeric data for display:
      <code language="X#">
        IF IsFloat(uValue)
        &#0009;nDecimal := 2
        ELSE
        &#0009;nDecimal := 0
        ENDIF
        ? Str(uValue, 10, nDecimal)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </isfloat>
  <isinstanceof>
    <summary>
      Determine if an object is an instance of a class.
    </summary>

    <param name="oObject">The object to check for.</param>
    <param name="symClassName">A symbolic representation of the class.</param>
    <returns>
      TRUE if <paramref name="oObject" /> is an instance of <paramref name="symClassName" />; otherwise, FALSE.
    </returns>
    <remarks>
      An instance of an inherited class is also an instance of the original (super) class.  However, an instance of a super class is not an instance of any of its inherited classes.
      IsInstanceOf() is similar to CheckInstanceOf() except that it does not generate an error message if the specified object is not an instance of the specified class.
    </remarks>
    <example>
      These examples illustrates IsInstanceOf() on inherited classes:
      <code language="X#">
        CLASS Employee
        &#0009;EXPORT name, age
        CONSTRUCTOR(tName, tAge)
        &#0009;name := tName
        &#0009;age := tAge
        END CLASS
        CLASS Programmer INHERIT Employee
        END CLASS
        CLASS Assembler INHERIT Programmer
        END CLASS
        FUNCTION CheckArgument()
        &#0009;LOCAL x, y AS OBJECT
        &#0009;x := Employee{"John", "25"}
        &#0009;y := Assembler{"Bill", "30"}
        &#0009;? IsInstanceOf(x, #Employee)&#0009;&#0009;// TRUE
        &#0009;? IsInstanceOf(x, #Programmer)&#0009;&#0009;// FALSE
        &#0009;? IsInstanceOf(x, #Assembler)&#0009;&#0009;// FALSE
        &#0009;? IsInstanceOf(y, #Employee)&#0009;&#0009;// TRUE
        &#0009;? IsInstanceOf(y, #Programmer)&#0009;&#0009;// TRUE
        &#0009;? IsInstanceOf(y, #Assembler)&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CheckInstanceOf'>CheckInstanceOf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsInstanceOfUsual'>IsInstanceOfUsual</seealso>
  </isinstanceof>
  <isinstanceofusual>
    <summary>
      Determine if an object inside a USUAL is an instance of a class.
    </summary>

    <param name="uObject">A USUAL type containing the object to check for.</param>
    <param name="symClassName">A symbolic representation of the class.</param>
    <returns>
      TRUE if <paramref name="uObject" /> is an instance of <paramref name="symClassName" />; otherwise, FALSE.
    </returns>
    <remarks>
      IsInstanceOfUsual() is used to determine whether the polymorphic value <paramref name="uObject" /> belongs to a class whose symbol is <paramref name="symClassName" />.<br/>
      An instance of an inherited class is also an instance of the super class.  However, an instance of a super class is not an instance of any of its inherited classes.
      IsInstanceOfUsual() is the same as the following: UsualType(<paramref name="uObject" />) = OBJECT .AND. IsInstanceOf(<paramref name="uObject" />, <paramref name="symClassName" />).  Thus, it should be used instead of IsInstanceOf() in situations where it is not known whether a variable is an object.
      IsInstanceOfUsual()() is also similar to CheckInstanceOf() except that it does not generate an error message if the specified object is not an instance of the specified class.
    </remarks>
    <example>
      This example uses IsInstanceOfUsual() to check whether a USUAL variable is an object of a specific class:
      <code language="X#">
        CLASS Cars
        &#0009;EXPORT Wheels
        LOCAL uMercedes
        uMercedes := Cars{}
        ? IsInstanceOfUsual(uMercedes, #Cars)&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CheckInstanceOf'>CheckInstanceOf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsInstanceOf'>IsInstanceOf</seealso>
  </isinstanceofusual>
  <iskanji>
    <summary>
      Determine if the first character of a string is a kanji character.
    </summary>

    <param name="cMBTarget">The string to examine.</param>
    <returns>
      TRUE if the first character in <paramref name="cMBTarget" /> is a kanji character; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.DBToSB'>DBToSB</seealso>
    <seealso cref='O:XSharp.VO.Functions.ToJNum'>ToJNum</seealso>
    <seealso cref='O:XSharp.VO.Functions.SBTODB'>SBToDB</seealso>
  </iskanji>
  <islogic>
    <summary>
      Determine if a value is a logical.
    </summary>

    <param name="uValue">The value to examine.</param>
    <returns>
      TRUE if the value is the LOGIC data type; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses IsLogic() to display the possible results of a survey:
      <code language="X#">
        IF IsLogic(uValue)
        &#0009;IF uValue
        &#0009;&#0009;? "Responded Yes"
        &#0009;ELSE
        &#0009;&#0009;? "Responded No"
        &#0009;ENDIF
        ELSEIF IsNil(uValue)
        &#0009;? "Did not respond"
        ELSE
        &#0009;? "Other response or transmission error"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </islogic>
  <islong>
    <summary>
      Determine if a value is a LONGINT.
    </summary>

    <param name="uValue">The value to examine.</param>
    <returns>
      TRUE if the value is the LONGINT data type; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses IsLong() to determine the appropriate conversion function:
      <code language="X#">
        IF IsLong(uValue)
        &#0009;cTransmit := L2Bin(uValue)
        ELSEIF IsFloat(uValue)&#0009;
        &#0009;cTransmit := F2Bin(uValue)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </islong>
  <islower>
    <summary>
      Determine if the leftmost character in a string is a lowercase letter.
    </summary>

    <param name="pszString">The string to examine.</param>
    <returns>
      TRUE if the first character of the string is a lowercase letter; otherwise, FALSE.
    </returns>
    <remarks>
      IsLower() is the inverse of IsUpper(), which determines whether a character begins with an uppercase character.
      Both IsLower() and IsUpper() relate to the Lower() and Upper() functions, which actually convert lowercase characters to uppercase, and vice versa.
      This function is nation-dependent.
    </remarks>
    <example>
      These examples demonstrate various results of IsLower():
      <code language="X#">
        ? IsLower("aBcDe")&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
        ? IsLower("AbcDe")&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        ? IsLower("1abcd")&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        ? IsLower("abcd")&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsAlpha'>IsAlpha</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsDigit'>IsDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.Lower'>Lower</seealso>
    <seealso cref='O:XSharp.Core.Functions.Upper'>Upper</seealso>
  </islower>
  <ismethod>
    <summary>
      Check whether a particular method can be sent to an object.
    </summary>

    <param name="oObject">An object.</param>
    <param name="symMethod">The method name, specified without parentheses.</param>
    <returns>
      TRUE if the specified method is defined for the class of the specified object; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses IsMethod() to check whether an object is capable of making sounds:
      <code language="X#">
        CLASS Animal
        &#0009;EXPORT sound, weight
        CONSTRUCTOR(s, w)
        &#0009;sound := s
        &#0009;weight := w
        METHOD Speaks CLASS
        &#0009;QOut(sound)
        END CLASS

        CLASS Programmer
        &#0009;EXPORT language
        CONSTRUCTOR(lang)
        &#0009;language := lang
        METHOD Speaks
        &#0009;QOut(language)
        &#0009;QOut("Hello World")
        &#0009;QOut(Chr(7))
        END CLASS
        Function Start()
        &#0009;LOCAL dog AS Animal
        &#0009;LOCAL hacker AS Programmer
        &#0009;dog := Animal{"Bark Bark!", 50}
        &#0009;hacker := Programmer{"VO"}
        &#0009;IF IsMethod(dog, #Speaks)
        &#0009;&#0009;dog:Speaks()&#0009;// Says Bark Bark
        &#0009;ENDIF
        &#0009;IF IsMethod(hacker, #Speaks)
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Says VO, Hello World, rings a bell
        &#0009;&#0009;hacker:Speaks()&#0009;
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CheckInstanceOf'>CheckInstanceOf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethodClass'>IsMethodClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethodUsual'>IsMethodUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.NoMethod'>NoMethod</seealso>
  </ismethod>
  <ismethodclass>
    <summary>
      Check whether a particular method can be sent to a class.
    </summary>

    <param name="symClass">A class name as symbol.</param>
    <param name="symMethod">The method name, specified without parentheses.</param>
    <returns>
      TRUE if the specified method is defined for the class of the specified object; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses IsMethodClass() to check whether a class is capable of making sounds:
      <code language="X#">
        CLASS Animal
        &#0009;EXPORT sound, weight
        CONSTRUCTOR(s, w)
        &#0009;sound := s
        &#0009;weight := w
        METHOD Speaks
        &#0009;QOut(sound)
        END CLASS
        CLASS Programmer
        &#0009;EXPORT language
        CONSTRUCTOR(lang)
        &#0009;language := lang
        METHOD Speaks
        &#0009;QOut(language)
        &#0009;QOut("Hello World")
        &#0009;QOut(Chr(7))
        END CLASS

        Function Start()
        &#0009;LOCAL dog AS Animal
        &#0009;LOCAL hacker AS Programmer
        &#0009;dog := Animal{"Bark Bark!", 50}
        &#0009;hacker := Programmer{"VO"}
        &#0009;IF IsMethodClass(#Animal, #Speaks)
        &#0009;&#0009;dog:Speaks()&#0009;&#0009;&#0009;&#0009;// Says Bark Bark
        &#0009;ENDIF
        &#0009;IF IsMethodClass(#Programmer, #Speaks)
        &#0009;&#0009;hacker:Speaks()&#0009;&#0009;&#0009;// Says VO
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Says Hello World
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Rings a bell
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CheckInstanceOf'>CheckInstanceOf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethod'>IsMethod</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethodUsual'>IsMethodUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.NoMethod'>NoMethod</seealso>
  </ismethodclass>
  <ismethodusual>
    <summary>
      Check whether a particular method can be sent to an object inside a USUAL.
    </summary>

    <param name="uObject">A USUAL containing an object.</param>
    <param name="symMethod">The method name, specified without parentheses.</param>
    <returns>
      TRUE if the specified method is defined for the class of the specified object; otherwise, FALSE.
    </returns>
    <remarks>
      IsMethodUsual() is used to determine whether the polymorphic value <paramref name="uObject" /> is an object that has a method <paramref name="symMethod" />.  IsMethodUsual() is the same as the following: UsualType(<paramref name="uObject" />) = OBJECT .AND. IsMethod(<paramref name="uObject" />, <paramref name="symMethod" />).  Thus it should be used instead of IsMethod() in situations where it is not known whether a variable is an object.
    </remarks>
    <example>
      This example uses IsMethodUsual() to check whether a particular method can be sent.<br/>
      If there is an object and a particular method for it exists, it issues the method; otherwise, it calls a function:
      <code language="X#">
        IF IsMethodUsual(uO, #GoTop)
        &#0009;uO:GoTop()
        ELSE
        &#0009;MyGoTop()&#0009;
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CheckInstanceOf'>CheckInstanceOf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethod'>IsMethod</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethodClass'>IsMethodClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.NoMethod'>NoMethod</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </ismethodusual>
  <isnil>
    <summary>
      Determine if a value is NIL.
    </summary>

    <param name="uValue">The value to examine.</param>
    <returns>
      TRUE if the value is NIL; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses IsNil() to determine whether to query users for a file name:
      <code language="X#">
        FUNCTION GetFile(cFile)
        &#0009;IF IsNil(cFile)
        &#0009;&#0009;? "Input missing file name"
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceNumeric'>EnforceNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsClass'>IsClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </isnil>
  <isnumeric>
    <summary>
      Determine if a value is a numeric.
    </summary>

    <param name="uValue">The value to examine.</param>
    <returns>
      TRUE if the value is a numeric; otherwise, FALSE.
    </returns>
    <remarks>
      IsNumeric() is equivalent to UsualType(<paramref name="uValue" /> = LONG .OR. UsualType(<paramref name="uValue" /> = FLOAT.
    </remarks>
    <example>
      This example uses IsNumeric() to determine the formatting to be used:
      <code language="X#">
        IF IsNumeric(uValue)
        &#0009;? Str3(uValue, 7, 2)
        ELSE
        &#0009;? uValue
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </isnumeric>
  <isobject>
    <summary>
      Determine if a value is an object.
    </summary>

    <param name="uValue">The value to examine.</param>
    <returns>
      TRUE if the value is an object; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses IsObject() to check whether a correct argument was passed:
      <code language="X#">
        FUNCTION OOpsCheck(uObject) AS LOGIC
        &#0009;LOCAL lSuccess AS LOGIC
        &#0009;LOCAL aObject AS ARRAY
        &#0009;lSuccess := IsObject(uObject)
        &#0009;IF lSuccess
        &#0009;&#0009;// Display object contents
        &#0009;&#0009;aObject := Object2Array(uObject)
        &#0009;&#0009;FOR i := UPTO ALen(aObject)
        &#0009;&#0009;&#0009;QOut(aObject[i])
        &#0009;&#0009;NEXT
        &#0009;ELSE
        &#0009;&#0009;? "Object is required"
        &#0009;ENDIF
        &#0009;RETURN lSuccess
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsClass'>IsClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethodUsual'>IsMethodUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </isobject>
  <isptr>
    <summary>
      Determine if a value is a pointer.
    </summary>

    <param name="uValue">The value to examine.</param>
    <returns>
      TRUE if the value is a pointer; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses IsPtr() to check whether a conversion to a pointer is needed:
      <code language="X#">
        IF !IsPtr(uValue)
        &#0009;uValue := Ptr(_CAST, uValue)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </isptr>
  <isspace>
    <summary>
      Determine if the leftmost character in a string is a blank (that is, Chr(9) through Chr(13) or Chr(32)).
    </summary>

    <param name="pszString">The string to examine.</param>
    <returns>
      TRUE if the first character is blank; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      These examples illustrate IsSpace() applied to various values:
      <code language="X#">
        LOCAL cString2Examine AS STRING
        cString2Examine := Chr(9) + "Hello"
        ? IsSpace(Substr(cString2Examine, 1, 1))&#0009;// TRUE
        ? IsSpace(Substr(cString2Examine, 2, 1))&#0009;// TRUE
        ? IsSpace(Substr(cString2Examine, 3, 1))&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsAlpha'>IsAlpha</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsDigit'>IsDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsXDigit'>IsXDigit</seealso>
  </isspace>
  <isstring>
    <summary>
      Determine if a value is a string.
    </summary>

    <param name="uValue">The value to examine.</param>
    <returns>
      TRUE if the value is a string; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses IsString() to determine whether to query users for a file name:
      <code language="X#">
        FUNCTION TBDemo(cFile)
        &#0009;IF !IsString(cFile)
        &#0009;&#0009;cFile := Space(12)
        &#0009;&#0009;? "Input correct file name"
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsString'>AsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </isstring>
  <issymbol>
    <summary>
      Determine if a value is a symbol.
    </summary>

    <param name="uValue">The value to examine.</param>
    <returns>
      TRUE if the value is a symbol; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses IsSymbol() to check whether a variable contains a symbol:
      <code language="X#">
        IF IsSymbol(uValue) .AND.;
        uValue != NULL_SYMBOL
        &#0009;? "Symbol is" + Symbol2String(uValue)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsSymbol'>AsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsClass'>IsClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethodUsual'>IsMethodUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </issymbol>
  <isupper>
    <summary>
      Determine if the leftmost character in a string is uppercase.
    </summary>

    <param name="pszString">The string to examine.</param>
    <returns>
      TRUE if the first character is an uppercase letter; otherwise, FALSE.
    </returns>
    <remarks>
      IsUpper() is the inverse of IsLower().  Both IsUpper() and IsLower() relate to the Upper() and Lower() functions, which actually convert uppercase characters to lowercase, and vice versa.
      This function is nation-dependent.
    </remarks>
    <example>
      These examples illustrate IsUpper() applied to various values:
      <code language="X#">
        ? IsUpper("AbCdE")&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
        ? IsUpper("aBCdE")&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        ? IsUpper("$abcd")&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        ? IsUpper("8ABCD")&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsAlpha'>IsAlpha</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsDigit'>IsDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsSpace'>IsSpace</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsXDigit'>IsXDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.Lower'>Lower</seealso>
    <seealso cref='O:XSharp.Core.Functions.Upper'>Upper</seealso>
  </isupper>
  <isvoobject>
    <summary>
      Determine if the given object is a valid VO Object.
    </summary>

    <param name="oObject">The object to examine.</param>
    <returns>
      TRUE if the object is a valid VO object; otherwise, FALSE.
    </returns>
    <remarks>
      IsVoObject() can be used to test any object for the following -
      It does NOT check -
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.IsVOString'>IsVoString</seealso>
  </isvoobject>
  <isvostring>
    <summary>
      Determine if the given string is a valid VO string.
    </summary>

    <param name="cString">The string to examine.</param>
    <returns>
      TRUE if the string is a valid VO string; otherwise, FALSE.
    </returns>
    <remarks>
      IsVoString() can be used to test any string for the following -
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.IsVOObject'>IsVoObject</seealso>
  </isvostring>
  <isxdigit>
    <summary>
      Determine if the leftmost character in a string is a hex character (that is, digits from 1 through 9 and letters from A through F).
    </summary>

    <param name="pszString">The string to examine.</param>
    <returns>
      TRUE if the first character is hex; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      These examples illustrate IsXDigit() applied to various values:
      <code language="X#">
        ? IsXDigit("3FDE")&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
        ? IsXDigit("hjku")&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsAlpha'>IsAlpha</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsDigit'>IsDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
  </isxdigit>
  <ivarget>
    <summary>
      Return the contents of an exported instance variable.
    </summary>

    <param name="oObject">The object containing the exported instance variable.</param>
    <param name="symInstanceVar">The exported instance variable to get.</param>
    <returns>
      The value of <paramref name="symInstanceVar" />.
    </returns>
    <remarks>
      IVarGet() returns the contents of an exported instance variable.<br/>
      The symbol of this instance variable can be stored inside <paramref name="symInstanceVar" /> at runtime.<br/>
      Therefore, the instance variable does not have to be known at compile-time.<br/>
      The class operator (:) also returns the contents of an exported instance variable, but the instance variable must be known at compile-time.
    </remarks>
    <example>
      This example uses IVarGet() to retrieve the contents of an exported instance variable.  Note that the contents of cTrick cannot be retrieved via IVarGet() since it is an INSTANCE variable.
      <code language="X#">
        CLASS GetVars
        &#0009;EXPORT cName
        &#0009;INSTANCE cTrick
        CONSTRUCTOR CLASS GetVars
        &#0009;cName := "Eve"
        &#0009;cTrick := "Apple"
        END CLASS

        FUNCTION Start()
        &#0009;LOCAL oVars AS OBJECT
        &#0009;oVars := GetVars{}
        &#0009;? IVarGet(oVars, #cName)&#0009;&#0009;&#0009;// Eve
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarGetSelf'>IVarGetSelf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IVarPut'>IVarPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarGet'>MemVarGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.VarGet'>VarGet</seealso>
  </ivarget>
  <ivargetinfo>
    <summary>
      Get information about how a particular instance variable (or access method) was declared.
    </summary>

    <param name="oObject">The object containing the instance variable.</param>
    <param name="symInstanceVar">The instance variable that you want information about.</param>
    <returns>
      A numeric value that can be interpreted as follows:
      wIvarInfo&#0009;Description&#0009;
      0&#0009;Not found&#0009;
      1&#0009;INSTANCE declaration&#0009;
      2&#0009;EXPORT declaration&#0009;
      3&#0009;ACCESS declaration&#0009;
      Note:  PROTECT and HIDDEN variables cannot be tested with this function.
    </returns>
    <remarks>
      IVarGetInfo() tests for an instance variable or access method of a given name and returns a numeric value indicating how (or if) the variable was declared.
    </remarks>
    <example>
      This example illustrates the various return values for IVarGetInfo():
      <code language="X#">
        CLASS A
        &#0009;INSTANCE x
        &#0009;EXPORT y
        ACCESS z CLASS A
        FUNCTION Start()
        &#0009;LOCAL o AS A
        &#0009;o := a{}
        ? IVarGetInfo(o,#x)&#0009;&#0009;&#0009;// 1
        ? IVarGetInfo(o,#y)&#0009;&#0009;&#0009;// 2
        ? IVarGetInfo(o,#z)&#0009;&#0009;&#0009;// 3
        ? IVarGetInfo(o,#none)&#0009;&#0009;&#0009;// 0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarPutInfo'>IVarPutInfo</seealso>
  </ivargetinfo>
  <ivargetself>
    <summary>
      Return the contents of an instance variable.
    </summary>

    <param name="oObject">The object containing the instance variable.</param>
    <param name="symInstanceVar">The instance variable to get.</param>
    <returns>
      The value of <paramref name="symInstanceVar" />.
    </returns>
    <remarks>
      IVarGetSelf() returns the contents of a specific EXPORT or INSTANCE variable.<br/>
      The scope throughout the function call is SELF.
    </remarks>
    <example>
      This example uses IVarGetSelf() to retrieve the contents of both EXPORT and INSTANCE variables:
      <code language="X#">
        CLASS GetVars
        &#0009;EXPORT cName
        &#0009;INSTANCE cPhone
        &#0009;PROTECT cID
        &#0009;HIDDEN cPassWord
        CONSTRUCTOR CLASS GetVars
        &#0009;cName := "Adam"&#0009;
        &#0009;cPhone := "4460"
        END CLASS

        FUNCTION Start()
        &#0009;LOCAL oVars AS OBJECT
        &#0009;oVars := GetVars{}
        &#0009;? IVarGetSelf(oVars, #cName)&#0009;&#0009;&#0009;// Adam
        &#0009;? IVarGetSelf(oVars, #cPhone)&#0009;&#0009;&#0009;// 4460
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarGet'>IVarGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.IVarPutSelf'>IVarPutSelf</seealso>
    <seealso cref='O:XSharp.RT.Functions.VarGet'>VarGet</seealso>
  </ivargetself>
  <ivarlist>
    <summary>
      Store all instance variables of an object into an array.
    </summary>

    <param name="oObject">The object containing the instance variable to store.</param>
    <returns>
      An array of symbols containing the name of all instance variables and access methods of <paramref name="oObject" />.
    </returns>
    <remarks>
      This conversion can offer you additional flexibility in manipulating data and can allow you to utilize powerful array functions, such as AEval() and AScan().<br/>
      The scope throughout the function call is SELF.
    </remarks>
    <example>
      This example uses IVarList() to store INSTANCE and EXPORT instance variables into an array.<br/>
      It then prints the stored instance variables.  (Note that the password is not stored in the array because it is a protected instance variable.)
      <code language="X#">
        CLASS Person
        &#0009;EXPORT name
        &#0009;INSTANCE grade
        &#0009;PROTECT password
        CONSTRUCTOR(tname, tgrade, tpassword)
        &#0009;name := tname
        &#0009;grade := tgrade
        &#0009;password := tpassword
        END CLASS

        FUNCTION MakeArray() AS VOID
        &#0009;LOCAL x AS OBJECT
        &#0009;LOCAL a AS ARRAY
        &#0009;x := Person{"Randal", "A", "123"}
        &#0009;a := IVarList(x)
        &#0009;// Print them
        &#0009;FOR i := UPTO ALen(a)
        &#0009;&#0009;QOut(a[i])
        &#0009;NEXT
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// NAME
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// GRADE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IvarListClass'>IVarListClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.MethodList'>MethodList</seealso>
    <seealso cref='O:XSharp.RT.Functions.Object2Array'>Object2Array</seealso>
  </ivarlist>
  <ivarlistclass>
    <summary>
      Store all instance variables of a class into an array.
    </summary>

    <param name="symClass">The class containing the instance variable to store.</param>
    <returns>
      An array of symbols containing the name of all instance variables and access methods of <paramref name="symClass" />.
    </returns>
    <remarks>
      This conversion can offer you additional flexibility in manipulating data and can allow you to utilize powerful array functions, such as AEval() and AScan().<br/>
      The scope throughout the function call is SELF.
      Note that this function does not store PROTECT or HIDDEN instance variables.
    </remarks>
    <example>
      This example uses IVarListClass() to store INSTANCE and EXPORT instance variables into an array.<br/>
      It then prints the stored instance variables.  (Note that the password is not stored in the array because it is a protected instance variable.)
      <code language="X#">
        CLASS Person
        &#0009;EXPORT name
        &#0009;INSTANCE grade
        &#0009;PROTECT password
        CONSTRUCTOR(tname, tgrade, tpassword)
        &#0009;name := tname
        &#0009;grade := tgrade
        &#0009;password := tpassword
        END CLASS

        FUNCTION MakeArray() AS VOID
        &#0009;LOCAL a AS ARRAY
        &#0009;a := IVarListClass(#Person)
        &#0009;// Print them
        &#0009;FOR i := UPTO ALen(aObject)
        &#0009;&#0009;QOut(a[i])
        &#0009;NEXT
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// NAME
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// GRADE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IvarList'>IVarList</seealso>
    <seealso cref='O:XSharp.RT.Functions.MethodListClass'>MethodListClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.Object2Array'>Object2Array</seealso>
  </ivarlistclass>
  <ivarput>
    <summary>
      Assign a value to an exported instance variable.
    </summary>

    <param name="oObject">The object containing the exported instance variable.</param>
    <param name="symInstanceVar">The exported instance variable to assign a value to.</param>
    <param name="uValue">The value to assign to the exported instance variable.</param>
    <returns>
      The value assigned to <paramref name="symInstanceVar" /> (<paramref name="uValue" />).
    </returns>
    <remarks>
      Instead of modifying an instance variable through the := or = operators, IVarPut() provides a way to practice encapsulated object-oriented programming by safeguarding against accidental modification to an instance variable.
    </remarks>
    <example>
      This example uses IVarPut() to assign a value to an exported instance variable.
      <code language="X#">
        CLASS GetVars
        &#0009;EXPORT cName
        &#0009;INSTANCE cPhone
        FUNCTION Start()
        &#0009;LOCAL oVars AS OBJECT
        &#0009;oVars := GetVars{}
        &#0009;? IVarPut(oVars, #cName, "VO")&#0009;&#0009;// VO
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarGet'>IVarGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.IVarPutSelf'>IVarPutSelf</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarPut'>MemVarPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.VarPut'>VarPut</seealso>
  </ivarput>
  <ivarputinfo>
    <summary>
      Get information about how a particular instance variable (or assign method) was declared.
    </summary>

    <param name="oObject">The object containing the instance variable.</param>
    <param name="symInstanceVar">The instance variable that you want information about.</param>
    <returns>
      A numeric value that can be interpreted as follows:
      wIvarInfo&#0009;Description&#0009;
      0&#0009;Not found&#0009;
      1&#0009;INSTANCE declaration&#0009;
      2&#0009;EXPORT declaration&#0009;
      3&#0009;ASSIGN declaration&#0009;
      Note:  PROTECT and HIDDEN variables cannot be tested with this function.
    </returns>
    <remarks>
      IVarPutInfo() tests for an instance variable or assign method of a given name and returns a numeric value indicating how (or if) the variable was declared.
    </remarks>
    <example>
      This example illustrates the various return values for IVarPutInfo():
      <code language="X#">
        CLASS A
        &#0009;INSTANCE x
        &#0009;EXPORT y
        ASSIGN z(value) CLASS A
        &#0009;z := value
        &#0009;RETURN value
      </code>
      &#0009;
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL o AS A
        &#0009;o := a{}
        ? IVarPutInfo(o,#x)&#0009;&#0009;&#0009;// 1
        ? IVarPutInfo(o,#y)&#0009;&#0009;&#0009;// 2
        ? IVarPutInfo(o,#z)&#0009;&#0009;&#0009;// 3
        ? IVarPutInfo(o,#none)&#0009;&#0009;&#0009;// 0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarGetInfo'>IVarGetInfo</seealso>
  </ivarputinfo>
  <ivarputself>
    <summary>
      Assign a value to an instance variable.
    </summary>

    <param name="oObject">The object containing the instance variable.</param>
    <param name="symInstanceVar">The instance variable to assign a value to.</param>
    <param name="uValue">The value to assign to the instance variable.</param>
    <returns>
      The value assigned to <paramref name="symInstanceVar" /> (<paramref name="uValue" />).
    </returns>
    <remarks>
      IVarPutSelf() assigns a value to a specific EXPORT or INSTANCE variable.
    </remarks>
    <example>
      This example uses IVarPut() to assign a value to both EXPORT and INSTANCE variables.
      <code language="X#">
        CLASS GetVars
        &#0009;EXPORT cName
        &#0009;INSTANCE cPhone
        &#0009;PROTECT cID
        &#0009;HIDDEN cPassWord
        FUNCTION Start()
        &#0009;LOCAL oVars AS OBJECT
        &#0009;oVars := GetVars{}
        &#0009;? IVarPutSelf(oVars, #cName, "Adam")&#0009;// Adam
        &#0009;? IVarPutSelf(oVars, #cPhone, "4460")&#0009;// 4460
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarGetSelf'>IVarGetSelf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IVarPut'>IVarPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.VarPut'>VarPut</seealso>
  </ivarputself>
  <l2bin>
    <summary>
      Convert a long integer to a string containing a 32-bit signed integer.
    </summary>

    <param name="liValue">The value to convert.  Decimal digits are truncated.</param>
    <returns>
    </returns>
    <remarks>
      L2Bin() is a conversion function that converts a long integer into a 4-byte string.  Typical applications include reading foreign file types in their native format and then saving, reading, decrypting, and transmitting numeric data in their compressed binary form instead of in strings.<br/>
      Its inverse is Bin2L().
    </remarks>
    <example>
      This example creates a new binary file, then writes a series of numbers to the files using L2Bin() to convert the numeric value to 32-bit binary forO:
      <code language="X#">
        LOCAL nNumber, ptrHandle
        ptrHandle := FCreate("MyFile", FC_NORMAL)
        FOR nNumber := 1 UPTO 100
        &#0009;FWrite3(ptrHandle, L2BIN(nNumber), 4)
        NEXT
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </l2bin>
  <lastrec>
    <summary>
      Return the number of the last record in a database file.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      The number of physical records in a database file.  Filtering or deleted settings have no effect on the return value.  LastRec() returns 0 if there is no database file in use.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      This example illustrates the relationship between LastRec(), RecCount(), and COUNT:
      <code language="X#">
        USE sales NEW
        QOut(LastRec(), RecCount())
        // Result: 84 84
        SET FILTER TO Salesman = "1001"
        COUNT TO nRecords
        QOut(nRecords, LastRec())&#0009;// Result: 14 84
      </code>
      This example uses an aliased expression to access the number of records in a open database file in an unselected work area:
      <code language="X#">
        USE sales NEW
        USE customer NEW
        QOut(LastRec(), Sales-&gt;LastRec())
      </code>
    </example>
    <seealsocmd>COUNT</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbLastRec'>VODBLastRec</seealso>
  </lastrec>
  <left>
    <summary>
      Extract a substring beginning with the first character in a string.
    </summary>

    <param name="cString">The string from which to extract characters.</param>
    <param name="dwCount">The number of characters to extract.</param>
    <returns>
      The leftmost <paramref name="dwCount" /> characters of <paramref name="cString" />.<br/>
      If <paramref name="dwCount" /> is negative or 0, Left() returns a NULL_STRING.<br/>
      If <paramref name="dwCount" /> is larger than the length of the string, Left() returns the entire string.
    </returns>
    <remarks>
      Left() is the same as Substr(<paramref name="cString" />, 1, <paramref name="wCount" />).
      Left(), Right(), and Substr() are often used with both the At() and RAt() functions to locate the first and/or the last position of a substring before extracting it.
    </remarks>
    <example>
      This example extracts the first three characters from the left of the target string:
      <code language="X#">? LEFT("ABCDEF", 3)&#0009;&#0009;&#0009;&#0009;&#0009;// ABC</code>
      This example extracts a substring from the beginning of a string up to the first occurrence of a comma:
      <code language="X#">
        LOCAL cName := "James, William" AS STRING
        ? LEFT(cName, AT(",", cName))&#0009;&#0009;// James
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.Stuff'>Stuff</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </left>
  <len>
    <summary>
      Return the length of a string or an array.
    </summary>

    <param name="uValue">
      The string or array to measure.  In a string, each byte counts as 1, including an embedded null character (Chr(0)).<br/>
      A NULL_STRING counts as 0.  In an array, each element counts as 1.
    </param>
    <returns>
      The length of <paramref name="uValue" />.
    </returns>
    <remarks>
      <note type="tip">
        ALen(), PszLen() and SLen() are the strongly typed versions of Len().
      </note>
    </remarks>
    <example>
      These examples demonstrate Len() with various arguments:
      <code language="X#">
        ? LEN("string of characters")&#0009;&#0009;// 20
        ? LEN(NULL_STRING)&#0009;&#0009;&#0009;&#0009;// 0
        ? LEN(CHR(0))&#0009;&#0009;&#0009;&#0009;&#0009;// 1
        LOCAL aTest[10]
        ? LEN(aTest)&#0009;&#0009;&#0009;&#0009;&#0009;// 10
        ? LEN(ArrayNew(5))&#0009;&#0009;&#0009;&#0009;// 5
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AAdd'>AAdd</seealso>
    <seealso cref='O:XSharp.RT.Functions.ALen'>ALen</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASize'>ASize</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszLen'>PszLen</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.SLen'>SLen</seealso>
  </len>
  <lennum>
    <summary>
      Return the number of characters in a number, including digits, decimal point, and sign.
    </summary>

    <param name="nNum">The number you want the length of.</param>
    <returns>
    </returns>
    <remarks>
      LenNum() returns the number of bytes a number will occupy when converted to a string.
    </remarks>
    <example>
      This example uses LenNum() on various numbers:
      <code language="X#">
        ? LenNum(1234)&#0009;&#0009;&#0009;&#0009;&#0009;// 4
        ? LenNum(1234.56) &#0009;&#0009;&#0009;&#0009;// 7
        ? LenNum(1234.5678) &#0009;&#0009;&#0009;&#0009;// 9
        ? LenNum(-1234.5678) &#0009;&#0009;&#0009;&#0009;// 10
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.RT.Functions.NTrim'>NTrim</seealso>
  </lennum>
  <loadresstring>
    <summary>
      Look up an identifier in a string table and returns its corresponding string.
    </summary>

    <param name="cDefault">
      The default string to return if <paramref name="nStringID" /> cannot be found in the designated string table.  Omitting this value is the same as specifying NULL_STRING.
    </param>
    <param name="nStringID">
      The unique integer identifier that you want to look up.<br/>
      This value is defined when you declare the string table via RESOURCE...STRINGTABLE statement.
    </param>
    <param name="xModule">
      The module containing the string table in which to perform the lookup.<br/>
      This argument can be specified either as a string, in which case it will be the name of a .DLL or .EXE file, or a WORD that identifies the module via its handle.<br/>
      If not specified, LoadResString() assumes the string table resides in the module that is currently executing.<br/>

      &#0009;Important!<br/>
      The module that you specify here is not automatically loaded by the LoadResString() function.<br/>
      Therefore, prior to calling LoadResString(), you must either directly reference the module (for example, by calling one of its functions), or load the module manually using the Windows API function LoadLibrary().
    </param>
    <returns>
    </returns>
    <remarks>
      The LoadResString() function allows you to easily read information from a string table in your X# application.  String tables are defined via the RESOURCE statement using the STRINGTABLE keyword and are compiled, like all resource entities, by the Windows resource compiler.
      In a X# application, you can declare as many string table resource entities as you like; however, when the application is built, all of these are combined into a single string table, allowing only one table in each executable file or DLL.<br/>
      This means that within an application and across its library search path, string identifiers in string table resource declarations must be unique.  Note, however, that another module (such as a DLL) referenced by an application can also have a string table, which is why LoadResString() allows you to specify which module to reference.  Identifiers need only be unique within a module (that is, an .EXE or .DLL file).
    </remarks>
    <example>
      This example illustrates a technique for looking up an object's HyperLabel:Caption property using a string table.<br/>
      Using this technique facilitates internationalization of an application by isolating the natural language portion of the application that needs to be translated into a string table:
      <code language="X#">
        oDCMyControl:HyperLabel := HyperLabel{#MyControl, ;
        &#0009;LoadResString("&amp;File", MyFileString, MyLanguage),,}
        DEFINE MyFileString := 100
        GLOBAL MyLanguage AS STRING
        METHOD Start() CLASS App
        &#0009;...
        &#0009;IF ...      // it's French
        &#0009;&#0009;MyLanguage := "MYFRENCH.DLL"
        &#0009;ELSEIF ... // it's German
        &#0009;&#0009;MyLanguage := "MYGERMAN.DLL"
        &#0009;ENDIF
      </code>
      &#0009;
      <code language="X#">&#0009;RETURN NULL_STRING</code>
      The code for the MYFRENCH DLL string table would be as follows:
      <code language="X#">
        DEFINE MyFileString := 100
        RESOURCE French STRINGTABLE
        BEGIN
        &#0009;MyFileString, "&amp;Fichier"
        &#0009;...
        END
      </code>
      The code for the MYGERMAN DLL string table would be as follows:
      <code language="X#">
        DEFINE MyFileString := 100
        RESOURCE German STRINGTABLE
        BEGIN
        &#0009;MyFileString, "&amp;Datei"
        &#0009;...
        END
      </code>
    </example>
    <seealsocmd>RESOURCE</seealsocmd>
  </loadresstring>
  <lobyte>
    <summary>
      Return the low-order (rightmost) byte in a number.
    </summary>

    <param name="wValue">The number whose low-order byte you want to get.</param>
    <returns>
    </returns>
    <remarks>
      Related data can be stored in the high-order and low-order words of a variable.<br/>
      Therefore, instead of creating and returning a 2-element array, it may be more efficient to return a word whose 2 bytes contain separate information.
    </remarks>
    <example>
      The Windows API function GetVersion() returns the DOS version in the high-order WORD and the Windows version in the low-order WORD.  Moreover, the DOS major number is in the high-order byte of its WORD, the DOS minor number is in the low-order bytes of its WORD, the Windows major number is in the low-order byte of its WORD, and the Windows minor number is in the high-order byte of its WORD:
      <code language="X#">
        LOCAL dwVersion AS DWORD
        LOCAL wDOS, wWindows AS DWORD
        LOCAL bDOSMinor, bDOSMajor AS BYTE
        LOCAL bWindowsMajor, bWindowsMinor AS BYTE
        dwVersions := GetVersion()
        wDOS :=  HiWord(dwVersions)
        bDOSMajor := HiByte(wDOS)
        bDOSMinor := LoByte(wDOS)
        wWindows := LoWord(dwVersions)
        bWindowsMinor := HiByte(wWindows)
        bWindowsMajor := LoByte(wWindows)
        ? "The DOS major and minor numbers are",;
        &#0009; bDOSMajor, bDOSMinor
        // The DOS major and minor numbers are 5          0
        ? "The Windows major and minor numbers are",;
        &#0009; bWindowsMajor, bWindowsMinor
        // The Windows major and minor numbers are 3      10
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.HiByte'>HiByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.HiWord'>HiWord</seealso>
    <seealso cref='O:XSharp.Core.Functions.LoWord'>LoWord</seealso>
  </lobyte>
  <log>
    <summary>
      Calculate the natural logarithm of a numeric value.
    </summary>

    <param name="nValue">A number greater than 0 to convert to its natural logarithm.</param>
    <returns>
      The natural logarithm of <paramref name="nValue" />.<br/>
      If <paramref name="nValue" /> is less than or equal to 0, Log() generates a numeric overflow.
    </returns>
    <remarks>
      The Log() function returns x in the following equation:
      <code language="X#">e^x = y</code>
      where e is the base of the natural logarithm (approximately 2.7183) and y is the numeric expression used as the Log() argument (that is, Log(y) = x).<br/>

      Due to mathematical rounding, the values returned by Log() and Exp() may not agree exactly (that is, Exp(Log(n)) may not always equal n).<br/>

      Log() is the inverse of Exp().
    </remarks>
    <example>
      These examples demonstrate various results of Log():
      <code language="X#">
        ? Log(10)&#0009;&#0009;&#0009;&#0009;&#0009;// 2.30
        ? Log(10 * 2)&#0009;&#0009;&#0009;&#0009;// 3.00
        ? Exp(Log(1))&#0009;&#0009;&#0009;&#0009;// 1.00
        ? Log(2.71)&#0009;&#0009;&#0009;&#0009;&#0009;// 1.00
      </code>
      This example is a function that returns the base 10 logarithO:
      <code language="X#">
        FUNCTION MyLog10(nNumber)
        &#0009;IF nNumber &gt; 0
        &#0009;&#0009;RETURN Log(nNumber)/Log(10)
        &#0009;ELSE
        &#0009;&#0009;RETURN 0
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Exp'>Exp</seealso>
    <seealso cref='O:XSharp.RT.Functions.Log10'>Log10</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pow'>Pow</seealso>
  </log>
  <log10>
    <summary>
      Calculate the common logarithm of a numeric value.
    </summary>

    <param name="nValue">A number greater than 0 to convert to its common logarithm.</param>
    <returns>
      The common logarithm of <paramref name="nValue" />.<br/>
      If <paramref name="nValue" /> is less than or equal to 0, Log10() generates a run-time error.
    </returns>
    <remarks>
      Log10() is the inverse of the power (to the base 10) operator (** or ^).<br/>

      The common logarithm has a base of 10.<br/>
      The Log10() function returns x in the following equation:<br/>

      <code language="X#">10^x = y</code>
      where y is the numeric expression used as the Log10() argument (that is, Log10(y) = x).  <br/>

      Due to mathematical rounding, the values returned by Log10() and the power operator (** or ^) may not agree exactly (that is, 10^(Log10(n)) may not always equal n).
    </remarks>
    <example>
      These examples demonstrate various results of Log10():
      <code language="X#">
        ? Log10(10)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 1.00
        ? Log10(10 ^ 2)&#0009;&#0009;&#0009;&#0009;&#0009;// 2.00
        ? 10 ^(Log10(1))&#0009;&#0009;&#0009;&#0009;&#0009;// 1.00
        ? 10 ^(Log10(10))&#0009;&#0009;&#0009;&#0009;&#0009;// 10.00
        ? Log10(1000)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 3.00
        ? Log10(1100.9)&#0009;&#0009;&#0009;&#0009;&#0009;// 3.04
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Exp'>Exp</seealso>
    <seealso cref='O:XSharp.RT.Functions.LOG'>Log</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pow'>Pow</seealso>
  </log10>
  <logic2bin>
    <summary>
      Convert a logical value to a string containing an 8-bit logical value.
    </summary>

    <param name="lValue">The logical value to convert.</param>
    <returns>
    </returns>
    <remarks>
      Logic2Bin() is a conversion function that converts a logical data type into a 1-byte string.  Typical applications include saving data in their native format, data decryption, and transmitting logical data in their binary form.<br/>
      Its inverse is Bin2Logic().
    </remarks>
    <example>
      This example creates a new binary file, then writes a logical value in a binary forO:
      <code language="X#">
        LOCAL ptrHandle AS PTR
        ptrHandle := FCreate("MyFile", FC_NORMAL)
        FWrite3(ptrHandle, Logic2Bin(TRUE), 1)
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTOC'>LToC</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </logic2bin>
  <longjmp>
    <summary>
      Restore the stack environment and return control to the point immediately following the corresponding SetJmp() call.
    </summary>

    <param name="strucMark">A structure in which the environment was stored by a prior call to SetJmp().</param>
    <param name="siValue">
      The value that appears to be returned by an earlier call to SetJmp().<br/>
      It should not be a 0.<br/>
      If it is a 0, LongJmp() substitutes 1.
    </param>
    <returns>
    </returns>
    <remarks>
      LongJmp() restores the stack environment saved earlier by a call to SetJmp() and then jumps to the return address for SetJmp().  Execution resumes at the point immediately following SetJmp(), so it seems as though <paramref name="siValue" /> was just returned from SetJmp().
      SetJmp() and LongJmp() provide you with a mechanism to go to a particular line of code.<br/>
      They are typically used to simulate a "return to master" command or to branch out to error recovery code.
      SetJmp() must be called prior to LongJmp().<br/>
      Then, LongJmp() must be called before the routine in which you called SetJmp() returns.
    </remarks>
    <example>
      This example shows how LongJmp() and SetJmp() work together to save and restore the stack environment:
      <code language="X#">
        STATIC GLOBAL strucMark IS _JMP_BUF
        FUNCTION Start()
        &#0009;LOCAL siJMPRetVal AS SHORTINT
        &#0009;siJMPRetVal := SetJmp(@strucMark)
        &#0009;IF siJMPRetVal <paramref name="" />0
        &#0009;&#0009;? "LongJmp() was here with", siJMPRetVal
        &#0009;&#0009;RETURN FALSE
        &#0009;ENDIF
        &#0009;IF .NOT. File("voerror.log")
        &#0009;&#0009;LongJmp(@strucMark, 1)
        &#0009;ENDIF
        &#0009;SubFunc()
        &#0009;RETURN TRUE
        FUNCTION SubFunc()
        &#0009;LOCAL cLog AS STRING
        &#0009;cLog := MemoRead("voerror.log")
        &#0009;IF SLen(cLog) = MAX_ALLOC
        &#0009;&#0009;LongJmp(@strucMark, 2)
        &#0009;ENDIF
        &#0009;RETURN 0
      </code>
    </example>
    <seealsocmd>SetJmp</seealsocmd>
  </longjmp>
  <lower>
    <summary>
      Convert the uppercase and mixed case characters in a string to lowercase.
    </summary>

    <param name="cString">The string to convert to lowercase.</param>
    <returns>
      <paramref name="cString" /> with all alphabetic characters converted to lowercase.<br/>
      All other characters remain the same as in the original string.
    </returns>
    <remarks>
      Lower() is related to Upper(), which converts lowercase and mixed case strings to uppercase.  Lower() is also related to IsLower() and IsUpper(), which determine whether a string begins with a lower or uppercase letter.
      Lower() is generally used to format strings for display purposes.<br/>
      It can, however, be used to normalize strings for case-independent comparison or indexing purposes.
      This function is nation-dependent.
    </remarks>
    <example>
      These examples demonstrate various results of Lower():
      <code language="X#">
        ? Lower("1234 CHARS = ")&#0009;&#0009;// 1234 chars =
        LOCAL cString AS STRING
        cString := "DATA"
        ? Lower(cString)&#0009;&#0009;&#0009;&#0009;// data
        ? cString&#0009;&#0009;&#0009;&#0009;&#0009;// DATA
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.LowerA'>LowerA</seealso>
    <seealso cref='O:XSharp.Core.Functions.Upper'>Upper</seealso>
  </lower>
  <lowera>
    <summary>
      Convert the uppercase and mixed case characters in a string to lowercase, changing the contents of the argument as well as the return value.
    </summary>

    <param name="cString">The string to convert to lowercase.</param>
    <returns>
      <paramref name="cString" /> with all alphabetic characters converted to lowercase.<br/>
      All other characters remain the same as in the original string.
    </returns>
    <remarks>
      LowerA() is the same as Lower(), except that LowerA() converts both the characters in the original string and the characters in the return value to lowercase.  See Lower() for more information.
      <note type="tip">
        You may change more than one variable at the same time (see example below).
      </note>
    </remarks>
    <example>
      This example shows how LowerA() converts both the original string and the return value to lowercase.  Compare the results to the results in the Lower() example:
      <code language="X#">
        LOCAL cString AS STRING
        cString := "DATA"
        ? LowerA(cString)&#0009;&#0009;// data
        ? cString&#0009;&#0009;&#0009;&#0009;&#0009;// DATA
      </code>
      This example shows how you may change more than one variable at the same time:
      <code language="X#">
        a := "I Change"
        b := a
        LowerA(b)
        ? b &#0009;&#0009;&#0009;&#0009;&#0009;// "i change"
        ? a &#0009;&#0009;&#0009;&#0009;&#0009;// "i change"
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.Lower'>Lower</seealso>
    <seealso cref='O:XSharp.Core.Functions.Upper'>Upper</seealso>
  </lowera>
  <loword>
    <summary>
      Return the low-order (rightmost) word in a number.
    </summary>

    <param name="dwValue">The number whose low-order word you want to get.</param>
    <returns>
    </returns>
    <remarks>
      Related data can be stored in the high-order and low-order words of a variable.<br/>
      Therefore, instead of creating and returning a 2-element array, it may be more efficient to return a double word whose 2 words contain separate information.<br/>
      Also, many Windows API functions receive data in a LONGINT argument.<br/>
      Usually the high-order and low-order words of this argument contain different information about a window and its messages.  LoWord() can be used to extract the low-order word of this argument.
    </remarks>
    <example>
      This example uses LoWord() and HiWord() to determine the coordinates of a pixel.<br/>
      It assumes that liParam was passed to a Windows callback function:
      <code language="X#">CRTSetPixel(LoWord(liParam), HiWord(liParam), 0L)</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.HiByte'>HiByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.HiWord'>HiWord</seealso>
    <seealso cref='O:XSharp.Core.Functions.LoByte'>LoByte</seealso>
  </loword>
  <ltoc>
    <summary>
      Convert a logical value to a string.
    </summary>

    <param name="lValue">The logical value to convert.</param>
    <returns>
    </returns>
    <remarks>
      LToC() is useful in forming combined indexes.
    </remarks>
    <example>
      This example uses LToC() to write the return value of a logical function to a text file:
      <code language="X#">FWriteText(ptrHandle, LToC(Deleted()), 1)</code>
      This example uses LToC() to form a combined string expression:
      <code language="X#">? LToC(_FIELD-&gt;lRegister) + _FIELD-&gt;cName</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsString'>AsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Logic2Bin'>Logic2Bin</seealso>
  </ltoc>
  <ltrim>
    <summary>
      Remove leading spaces from a string.
    </summary>

    <param name="cString">The string to trim.</param>
    <returns>
      <paramref name="cString" /> with the leading spaces removed.<br/>
      If <paramref name="cString" /> is a NULL_STRING or all spaces, LTrim() returns a NULL_STRING.
    </returns>
    <remarks>
      LTrim() is used to format strings that have leading spaces, for example, numbers that have been converted to strings using Str().
      LTrim() is related to RTrim(), which removes trailing spaces, and AllTrim(), which removes both leading and trailing spaces.<br/>
      The inverse of AllTrim(), LTrim(), and RTrim() are the PadC(), PadR(), and PadL() functions, which center, right-justify, and left-justify strings by padding them with fill characters.
    </remarks>
    <example>
      These examples illustrate LTrim() used with several other functions:
      <code language="X#">
        nNumber = 18
        ? Str(nNumber)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 18
        ? SLen(Str(nNumber))&#0009;&#0009;&#0009;&#0009;&#0009;// 10
        ? LTrim(Str(nNumber))&#0009;&#0009;&#0009;&#0009;&#0009;// 18
        ? NTrim(nNumber)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 18
        ? SLen(LTrim(Str(nNumber)))&#0009;&#0009;&#0009;&#0009;// 2
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AllTrim'>AllTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadC'>PadC</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadL'>PadL</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadR'>PadR</seealso>
    <seealso cref='O:XSharp.RT.Functions.NTrim'>NTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Trim'>Trim</seealso>
  </ltrim>
  <lupdate>
    <summary>
      Return the date a database file was last modified and closed.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      The date of last change.<br/>
      If there is no database file in use, LUpdate() returns a NULL_DATE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      This example demonstrates that the modification date of a database file is not changed until the database file is closed:
      <code language="X#">
        QOut(TODAY())&#0009;&#0009;&#0009;&#0009;// Result: 09/01/90
        USE sales NEW
        QOut(LUpdate())&#0009;&#0009;&#0009;// Result: 08/31/90
        APPEND BLANK
        QOut(LUpdate())&#0009;&#0009;&#0009;// Result: 08/31/90
        DBCloseAll()
        USE sales NEW
        QOut(LUpdate())&#0009;&#0009;&#0009;// Result: 09/01/90
      </code>
      This example uses an aliased expression to return the last modification date of a database file in an unselected work area:
      <code language="X#">
        USE sales NEW
        USE customer NEW
        QOut(LUpdate(), Sales-&gt;LUpdate())
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldName'>FieldName</seealso>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
    <seealso cref='O:XSharp.RT.Functions.RecSize'>RecSize</seealso>
  </lupdate>
  <makedword>
    <summary>
      Create a DWORD from two words
    </summary>

    <param name="wLow">The number you want to have in the Low word of the Dword</param>
    <param name="wHigh">The number you want to have in the High word of the Dword</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      <code language="X#">
        ? MakeDword(0x0001, 0x0001) // 65537
        ? MakeDword(0xFFFF, 0xFFFF) // 4294967295
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MakeLong'>MakeLong</seealso>
    <seealsocmd>MakeShort</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.MakeWord'>MakeWord</seealso>
  </makedword>
  <makelong>
    <summary>
      Create a long from two words
    </summary>

    <param name="wLow">The number you want to have in the Low word of the Long</param>
    <param name="wHigh">The number you want to have in the High word of the Long</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      <code language="X#">
        ? MakeLong(0x0001, 0x0001) // 65537
        ? MakeLong(0xFFFF, 0xFFFF) // -1
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MakeDWord'>MakeDword</seealso>
    <seealsocmd>MakeShort</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.MakeWord'>MakeWord</seealso>
  </makelong>
  <makeshort>
    <summary>
      Create a Short from two bytes
    </summary>

    <param name="bLow">The number you want to have in the Low byte of the Short</param>
    <param name="bHigh">The number you want to have in the High byte of the Short</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      <code language="X#">
        ?  MakeShort(0x01, 0x01) // 256
        ?  MakeShort(0xFF, 0xFF) // -1
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MakeDWord'>MakeDword</seealso>
    <seealso cref='O:XSharp.Core.Functions.MakeLong'>MakeLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.MakeWord'>MakeWord</seealso>
  </makeshort>
  <makeword>
    <summary>
      Create a Short from two bytes
    </summary>

    <param name="bLow">The number you want to have in the Low byte of the Word</param>
    <param name="bHigh">The number you want to have in the High byte of the Word</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      <code language="X#">
        ?  MakeWord(0x01, 0x01) // 256
        ?  MakeWord(0xFF, 0xFF) // 65535
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MakeDWord'>MakeDword</seealso>
    <seealso cref='O:XSharp.Core.Functions.MakeLong'>MakeLong</seealso>
    <seealsocmd>MakeShort</seealsocmd>
  </makeword>
  <massign>
    <summary>
      Perform an assignment to a variable whose name is stored in a specified string.
    </summary>

    <param name="cExp">
      The string containing the variable name you want to assign <paramref name="uValue" /> to.
    </param>
    <param name="uValue">The value to assign.</param>
    <returns>
      The assigned value.
    </returns>
    <remarks>
      MAssign() is the functional equivalent of using the macro operator (&amp;) to perform an assignment.
    </remarks>
    <example>
      The following example uses the MAssign() function to perform assignments:
      <code language="X#">
        MEMVAR iValue
        LOCAL cVar AS STRING
        cVar := "iValue"
        MAssign(cVar, 5)&#0009;&#0009;// Same a &amp;cVar := 5
        ? iValue&#0009;&#0009;&#0009;&#0009;&#0009;// Result: 5
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Evaluate'>Evaluate</seealso>
    <seealso cref='O:XSharp.RT.Functions.MCompile'>MCompile</seealso>
    <seealso cref='O:XSharp.RT.Functions.MExec'>MExec</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrEvaluate'>StrEvaluate</seealso>
  </massign>
  <max>
    <summary>
      Return the larger of 2 values.
    </summary>

    <param name="uValue1">The first value to compare.</param>
    <param name="uValue2">
      The second value to compare.<br/>
      This must be of the same type as <paramref name="uValue1" /> except that numerics of different types are allowed.
    </param>
    <returns>
      The larger of the 2 arguments.<br/>
      The value returned is the same type as the larger argument.
    </returns>
    <remarks>
      The inverse of Max() is Min(), which returns the smaller of 2 expressions.
    </remarks>
    <example>
      In these examples Max() returns the larger of 2 numbers:
      <code language="X#">
        ? MAX(99, 100)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 100
        ? MAX(100, 99)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 100
      </code>
      In these examples Max() compares date values:
      <code language="X#">
        ? TODAY()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 05/27/93
        ? MAX(TODAY(), TODAY() + 1)&#0009;&#0009;&#0009;// 05/28/93
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Between'>Between</seealso>
    <seealso cref='O:XSharp.RT.Functions.Min'>Min</seealso>
    <seealso cref="O:XSharp.Core.Functions.Max" />
  </max>


  <maxatom>
    <summary>
      Determine the number of symbols in the atom table.
    </summary>
    <returns>
      MaxAtom() returns the highest symbol value, which tells you the total number of atoms used in the entire system.<br/>
      Each time a symbol is added to the atom table, the number of available spaces is decreased by 1, and the value of MaxAtom() increases by 1.
      Note that the return value depends on the specific circumstances in your application.<br/>
      For example, if you are executing your application dynamically from within the IDE, the return value will be different from the value you get when you run the executable version of the application.
    </returns>
    <remarks>
      MaxAtom() returns the same value as Memory(MaxAtom).
    </remarks>
    <example>
      This example uses MaxAtom() to print the highest system value (note that actual results will vary):
      <code language="X#">
        ? MaxAtom()&#0009;&#0009;&#0009;&#0009;// 5346
        ? SysAddAtom("First")&#0009;&#0009;// First
        ? MaxAtom()&#0009;&#0009;&#0009;&#0009;&#0009;// 5347
        ? SysAddAtom("Second")&#0009;&#0009;// Second
        ? MaxAtom()&#0009;&#0009;&#0009;&#0009;&#0009;// 5348
        ? Memory(MaxAtom)&#0009;&#0009;&#0009;// 5348
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.Memory'>Memory</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysAddAtom'>SysAddAtom</seealso>
  </maxatom>
  <mballtrim>
    <summary>
      Remove leading and trailing spaces — including double-byte spaces — from a string.
    </summary>

    <param name="cMBString">The string to trim.</param>
    <returns>
      A trimmed string, with leading and trailing spaces removed.
    </returns>
    <remarks>
      This function is identical in functionality to AllTrim() except that it handles strings containing double-byte characters.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AllTrim'>AllTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLTrim'>MBLTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRTrim'>MBRTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBTrim'>MBTrim</seealso>
  </mballtrim>
  <mbat>
    <summary>
      Return the position of the first occurrence of a substring within a string — both the substring and the string can contain double-byte characters.
    </summary>

    <param name="cMBSearch">The substring to search for.</param>
    <param name="cMBTarget">The string in which to search.  (To start at a specific offset, use MBAt3().)</param>
    <returns>
      The position of the first occurrence of <paramref name="cMBSearch" /> within <paramref name="cMBTarget" />.<br/>
      If <paramref name="cMBSearch" /> is not found, MBAt() returns zero.
    </returns>
    <remarks>
      This function is like At() except that it handles strings containing double-byte characters.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt2'>MBAt2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt3'>MBAt3</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtC'>MBAtC</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtC2'>MBAtC2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtLine'>MBAtLine</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtLine2'>MBAtLine2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLEFT'>MBLeft</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRight'>MBRight</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
  </mbat>
  <mbat2>
    <summary>
      Return the position of the first occurrence of a substring within a string — both the substring and the string can contain double-byte characters.
    </summary>

    <param name="cMBSearch">The substring for which to search.</param>
    <param name="cMBTarget">The string in which to search.  (To start at a specific offset, use MBAt3().)</param>
    <returns>
      The position of the first occurrence of <paramref name="cMBSearch" /> within <paramref name="cMBTarget" />.<br/>
      If <paramref name="cMBSearch" /> is not found, MBAt2() returns zero.
    </returns>
    <remarks>
      This function is like MBAt() except that it returns a WORD.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At2'>At2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt3'>MBAt3</seealso>
  </mbat2>
  <mbat3>
    <summary>
      Return the position of the first occurrence of a substring within a string, starting at a specific position — both the substring and the string can contain double-byte characters.
    </summary>

    <param name="cMBSearch">The substring to search for.</param>
    <param name="cMBTarget">The string in which to search.</param>
    <param name="wOffset">
      The position in the string at which to start searching.<br/>
      A value of zero corresponds to the first byte.
    </param>
    <returns>
      The position of the first occurrence of <paramref name="cMBSearch" /> within <paramref name="cMBTarget" />.<br/>
      If <paramref name="cMBSearch" /> is not found, MBAt3() returns zero.
    </returns>
    <remarks>
      This function is the same as MBAt(), except that you can specify an offset that tells where to start searching.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At3'>At3</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt2'>MBAt2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtC'>MBAtC</seealso>
  </mbat3>
  <mbatc>
    <summary>
      Return the position of the first occurrence of a sub string within a string, without regard for case — both the substring and the string can contain double-byte characters.
    </summary>

    <param name="cMBSearch">The substring to search for.</param>
    <param name="cMBTarget">The string in which to search.</param>
    <returns>
      The position of the first occurrence of <paramref name="cMBSearch" /> within <paramref name="cMBTarget" />.<br/>
      If <paramref name="cMBSearch" /> is not found, MBAtC() returns zero.
    </returns>
    <remarks>
      This function is like AtC() except that it handles strings containing double-byte characters.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AtC'>AtC</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtC2'>MBAtC2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
  </mbatc>
  <mbatc2>
    <summary>
      Return the position of the first occurrence of a substring within a string, without regard for case — both the substring and the string can contain double-byte characters.
    </summary>

    <param name="cMBSearch">The substring for which to search.</param>
    <param name="cMBTarget">The string in which to search.</param>
    <returns>
      The position of the first occurrence of <paramref name="cMBSearch" /> within <paramref name="cMBTarget" />.<br/>
      If <paramref name="cMBSearch" /> is not found, MBAtC2() returns zero.
    </returns>
    <remarks>
      This function is like MBAtC() except that it returns a WORD.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AtC2'>AtC2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtC'>MBAtC</seealso>
  </mbatc2>
  <mbatline>
    <summary>
      Return the line number of the first occurrence of a substring within a multiple line string — both the substring and the string can contain double-byte characters.
    </summary>

    <param name="cMBSearch">The substring to search for.</param>
    <param name="cMBTarget">The string in which to search.</param>
    <returns>
      The position of the first occurrence of <paramref name="cMBSearch" /> within <paramref name="cMBTarget" />.<br/>
      If <paramref name="cMBSearch" /> is not found, MBAtLine() returns zero.
    </returns>
    <remarks>
      This function is like AtLine() except that it handles strings containing double-byte characters.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ATLine'>AtLine</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtC'>MBAtC</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtLine2'>MBAtLine2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
  </mbatline>
  <mbatline2>
    <summary>
      Return the line number of the first occurrence of a substring within a multiple line string — both the substring and the string can contain double-byte characters.
    </summary>

    <param name="cMBSearch">The substring for which to search.</param>
    <param name="cMBTarget">The string in which to search.</param>
    <returns>
      The position of the first occurrence of <paramref name="cMBSearch" /> within <paramref name="cMBTarget" />.<br/>
      If <paramref name="cMBSearch" /> is not found, MBAtLine2() returns zero.
    </returns>
    <remarks>
      This function is like MBAtLine() except that it returns a WORD.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ATLine2'>AtLine2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtLine'>MBAtLine</seealso>
  </mbatline2>
  <mbleft>
    <summary>
      Return a substring beginning with the first character of a string containing double-byte characters.
    </summary>

    <param name="cMBString">The string from which to extract characters.</param>
    <param name="wCount">The number of characters to extract.</param>
    <returns>
      The leftmost <paramref name="wCount" /> characters of <paramref name="cMBString" /> — each double-byte character counts as one character.<br/>
      If <paramref name="wCount" /> is zero, MBLeft() returns a NULL_STRING.<br/>
      If <paramref name="wCount" /> is larger than the length of the string, MBLeft() returns the entire string.
    </returns>
    <remarks>
      This function is like Left() except that it handles strings containing double-byte characters.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLTrim'>MBLTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRight'>MBRight</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRTrim'>MBRTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBStuff'>MBStuff</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
  </mbleft>
  <mblen>
    <summary>
      Return the length of a string containing double-byte characters or an array.
    </summary>

    <param name="uMBValue">
      The string or array to measure.  In a string, each single-byte character counts as one, including an embedded null character (Chr(0)).  Double-byte characters also count as one.<br/>
      A NULL_STRING counts as zero.  In an array, each element counts as one.
    </param>
    <returns>
      The length of <paramref name="uMBValue" /> in which each double-byte character counts as one character.
    </returns>
    <remarks>
      This function is like Len() except that it handles strings containing double-byte characters.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLTrim'>MBLTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRTrim'>MBRTrim</seealso>
  </mblen>
  <mbltrim>
    <summary>
      Remove leading spaces — including double-byte spaces — from a string.
    </summary>

    <param name="cMBString">The string to trim.</param>
    <returns>
      <paramref name="cMBString" /> with the leading spaces removed.<br/>
      If <paramref name="cMBString" /> is a NULL_STRING or all spaces, MBLTrim() returns a NULL_STRING.
    </returns>
    <remarks>
      This function is like LTrim() except that it handles strings containing double-byte characters.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAllTrim'>MBAllTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRTrim'>MBRTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBTrim'>MBTrim</seealso>
  </mbltrim>
  <mbrat>
    <summary>
      Return the position of the last occurrence of a substring within a string — both the substring and the string can contain double-byte characters.
    </summary>

    <param name="cMBSearch">The substring for which to search.</param>
    <param name="cMBTarget">The string in which to search.  (To start at a specific offset, use MBRAt3().)</param>
    <returns>
      The position of <paramref name="cMBSearch" /> within <paramref name="cMBTarget" />.<br/>
      If <paramref name="cMBSearch" /> is not found, MBRAt() returns zero.
    </returns>
    <remarks>
      This function is like RAt() except that it handles strings containing double-byte characters.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLEFT'>MBLeft</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat2'>MBRAt2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat3'>MBRAt3</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRight'>MBRight</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
  </mbrat>
  <mbrat2>
    <summary>
      Return the position of the last occurrence of a substring within a string — both the substring and the string can contain double-byte characters.
    </summary>

    <param name="cMBSearch">The substring for which to search.</param>
    <param name="cMBTarget">The string in which to search.  (To start at a specific offset, use MBRAt3().)</param>
    <returns>
      The position of <paramref name="cMBSearch" /> within <paramref name="cMBTarget" />.<br/>
      If <paramref name="cMBSearch" /> is not found, MBRAt2() returns zero.
    </returns>
    <remarks>
      This function is like MBRAt() except that it returns a DWORD.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat3'>MBRAt3</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt2'>RAt2</seealso>
  </mbrat2>
  <mbrat3>
    <summary>
      Return the position of the last occurrence of a substring within a string, starting at a specific position — both the substring and the string can contain double-byte characters.
    </summary>

    <param name="cMBSearch">The substring for which to search.</param>
    <param name="cMBTarget">The string in which to search.</param>
    <param name="wOffset">
      The position in the string at which to start searching.<br/>
      A value of zero specifies the first byte.
    </param>
    <returns>
      The position of <paramref name="cMBSearch" /> within <paramref name="cMBTarget" />.<br/>
      If <paramref name="cMBSearch" /> is not found, MBRAt3() returns zero.
    </returns>
    <remarks>
      This function is like MBRAt(), except that you can specify an offset that tells where to start searching.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat2'>MBRAt2</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt3'>RAt3</seealso>
  </mbrat3>
  <mbright>
    <summary>
      Return a substring beginning with the last character of a string containing double-byte characters.
    </summary>

    <param name="cMBString">The string from which to extract characters.</param>
    <param name="wCount">The number of characters to extract.</param>
    <returns>
      The rightmost <paramref name="wCount" /> characters of <paramref name="cMBString" /> — each double-byte character counts as one character.<br/>
      If <paramref name="wCount" /> is zero, MBRight() returns a NULL_STRING.<br/>
      If <paramref name="wCount" /> is larger than the length of the string, MBRight() returns <paramref name="cMBString" />.
    </returns>
    <remarks>
      This function is like Right() except that it handles strings containing double-byte characters.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBLEFT'>MBLeft</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLTrim'>MBLTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRTrim'>MBRTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBStuff'>MBStuff</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
  </mbright>
  <mbrtrim>
    <summary>
      Remove trailing spaces — including double-byte spaces — from a string.
    </summary>

    <param name="cMBString">The string to trim.</param>
    <returns>
      <paramref name="cMBString" /> with the trailing spaces removed.<br/>
      If <paramref name="cMBString" /> is a NULL_STRING or all spaces, MBRTrim() returns a NULL_STRING.
    </returns>
    <remarks>
      This function is like RTrim() except that it handles strings containing double-byte characters.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBAllTrim'>MBAllTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLTrim'>MBLTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBTrim'>MBTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
  </mbrtrim>
  <mbslen>
    <summary>
      Return the length of a strongly typed string containing double-byte characters.
    </summary>

    <param name="cMBString">The string to count.</param>
    <returns>
      The length of <paramref name="cMBString" /> in which each double-byte character counts as one character.<br/>
      If the string is a NULL_STRING, MBSLen() returns zero.
    </returns>
    <remarks>
      This function is like SLen() except that it handles strings containing double-byte characters.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBAllTrim'>MBAllTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLen'>MBLen</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLTrim'>MBLTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRTrim'>MBRTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBTrim'>MBTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.SLen'>SLen</seealso>
  </mbslen>
  <mbstuff>
    <summary>
      Insert a string into another string, optionally deleting a specified number of characters from the original string — both strings can contain double-byte characters.
    </summary>

    <param name="cMBTarget">The string into which characters are inserted and deleted.</param>
    <param name="wStart">
      The position in <paramref name="cMBTarget" /> where the insertion/deletion occurs.
    </param>
    <param name="wDelete">The number of characters to delete — each double-byte character counts as one character.</param>
    <param name="cMBInsert">The string to insert.</param>
    <returns>
      <paramref name="cMBTarget" /> with the specified characters deleted and <paramref name="cMBInsert" /> inserted.
    </returns>
    <remarks>
      This function is like Stuff() except that it handles strings containing double-byte characters.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLEFT'>MBLeft</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRight'>MBRight</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Stuff'>Stuff</seealso>
  </mbstuff>
  <mbsubstr>
    <summary>
      Extract a substring from a string — both the substring and the string can contain double-byte characters.
    </summary>

    <param name="cMBTarget">The string from which to extract a substring.</param>
    <param name="nStart">
      The starting position in <paramref name="cMBTarget" />.<br/>
      If <paramref name="nStart" /> is positive, it is relative to the leftmost character in <paramref name="cMBTarget" />.<br/>
      If <paramref name="nStart" /> is negative, it is relative to the rightmost character in <paramref name="cMBTarget" />.
    </param>
    <param name="nCount">
      The number of characters to extract — double-byte characters count as one character.<br/>
      If omitted, the substring begins at <paramref name="nStart" /> and continues to the end of the string.<br/>
      If <paramref name="nCount" /> is greater than the number of characters from <paramref name="nStart" /> to the end of <paramref name="cMBTarget" />, the extra is ignored.
    </param>
    <returns>
      The substring.<br/>
      If the substring is not present, or if you specify <paramref name="nStart" /> as zero, MBSubstr() returns a NULL_STRING.
    </returns>
    <remarks>
      This function is like Substr() except that it handles strings containing double-byte characters.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLEFT'>MBLeft</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRight'>MBRight</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr2'>MBSubstr2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr3'>MBSubstr3</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </mbsubstr>
  <mbsubstr2>
    <summary>
      Extract a substring from a string, using strong typing and only two arguments — both the substring and the string can contain double-byte characters.
    </summary>

    <param name="cMBTarget">The string from which to extract a substring.</param>
    <param name="wStart">
      The starting position relative to the leftmost character in <paramref name="cMBTarget" />.
    </param>
    <returns>
      The substring.<br/>
      If the substring is not present, or if you specify <paramref name="wStart" /> as zero, MBSubstr2() returns a NULL_STRING.
    </returns>
    <remarks>
      MBSubstr2() is a typed version of MBSubstr().<br/>
      The third argument of MBSubstr() which counts the number of characters is not allowed.  Instead, this function starts at the specified location and extracts to the end of the string.<br/>
      Also, because <paramref name="wStart" /> cannot be negative, MBSubstr2() cannot extract a substring relative to the rightmost character of <paramref name="cMBTarget" /> as can MBSubstr().
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLEFT'>MBLeft</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRight'>MBRight</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr3'>MBSubstr3</seealso>
    <seealso cref='O:XSharp.Core.Functions.SubStr2'>Substr2</seealso>
  </mbsubstr2>
  <mbsubstr3>
    <summary>
      Extract a substring from a string, using strong typing and three required arguments — both the substring and the string can contain double-byte characters.
    </summary>

    <param name="cMBTarget">The string from which to extract a substring.</param>
    <param name="wStart">
      The starting position relative to the leftmost character in <paramref name="cMBTarget" />.
    </param>
    <param name="wCount">
      The number of characters to extract — double-byte characters count as one character.<br/>
      If <paramref name="wCount" /> is greater than the number of characters from <paramref name="wStart" /> to the end of <paramref name="cMBTarget" />, the extra is ignored.
    </param>
    <returns>
      The substring.<br/>
      If the substring is not present, or if you specify <paramref name="wStart" /> as zero, MBSubstr3() returns a NULL_STRING.
    </returns>
    <remarks>
      MBSubstr3() is a typed version of MBSubstr() in which all three arguments are required.  Because <paramref name="wStart" /> cannot be negative, MBSubstr3() cannot extract a substring relative to the rightmost character of <paramref name="cMBTarget" /> as can MBSubstr().
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLEFT'>MBLeft</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRight'>MBRight</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr2'>MBSubstr2</seealso>
    <seealso cref='O:XSharp.Core.Functions.SubStr3'>Substr3</seealso>
  </mbsubstr3>
  <mbtrim>
    <summary>
      Remove trailing spaces — including double-byte spaces — from a string.
    </summary>

    <param name="cMBString">The string to trim.</param>
    <returns>
      <paramref name="cMBString" /> with the trailing spaces removed.<br/>
      If <paramref name="cMBString" /> is a NULL_STRING or all spaces, MBTrim() returns a NULL_STRING.
    </returns>
    <remarks>
      This function is like Trim() except that it handles strings containing double-byte characters.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBAllTrim'>MBAllTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLTrim'>MBLTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRTrim'>MBRTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Trim'>Trim</seealso>
  </mbtrim>
  <mcompile>
    <summary>
      Macro compile a string.
    </summary>

    <param name="cString">The string to compile.</param>
    <returns>
      The string in a macro-compiled form.
    </returns>
    <remarks>
      MCompile() allows you to use the macro compiler to compile a string and store the compiled results
      for later execution. Instead of invoking the macro compiler each time an expression is evaluated,
      you could speed up your application by compiling an expression only once and executing the compiled
      form as often as desired.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/mcompilemexec/*" />
    </remarks>
    <example>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/mcompileexamples/*" />
    </example>
    <seealso cref='O:XSharp.RT.Functions.Evaluate'>Evaluate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ExecScript'>ExecScript</seealso>
    <seealso cref='O:XSharp.RT.Functions.MAssign'>MAssign</seealso>
    <seealso cref='O:XSharp.RT.Functions.MExec'>MExec</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrEvaluate'>StrEvaluate</seealso>
    <seealso cref='T:XSharp._Codeblock'>_Codeblock type</seealso>
  </mcompile>
  <mem2string>
    <summary>
      Extract a substring of a certain size from the left of a buffer.
    </summary>

    <param name="ptrSource">Pointer to the buffer from which to extract the substring.</param>
    <param name="dwCount">
      The number of bytes, from the left, to extract from <paramref name="ptrSource" />.
    </param>
    <returns>
      A substring of the specified number of bytes.
    </returns>
    <remarks>
      <note type="tip">
        Contrary to normal PSZs, strings are not static and may be collected by the garbage collector.<br/>
        Therefore, if you supply a string as an argument to a function, like Mem2String, which directly or indirectly allocates dynamic memory, you may run into trouble.<br/>
        For example, in Mem2String(Time(), 5), Time() may cause problems.  But Mem2String("hi there", 5) will not cause problems since literal strings are not collected.
      </note>
    </remarks>
    <example>
      This example uses Mem2String() to get the three leftmost characters of a PSZ:
      <code language="X#">
        LOCAL pszSource AS PSZ
        pszSource := "ABCDEF"
        ? Mem2String(pszSource, 3)&#0009;&#0009;&#0009;// ABC
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Psz2String'>Psz2String</seealso>
  </mem2string>
  <memalloc>
    <summary>
      Allocate a static memory buffer of a specified size.
    </summary>

    <param name="wBytes">The number of bytes to allocate.</param>
    <returns>
      A pointer to the allocated space if there is sufficient memory available; otherwise, it returns a NULL_PTR.  You should always check the return value for a successful allocation.
    </returns>
    <remarks>
      MemAlloc() allocates a memory buffer of at least <paramref name="wBytes" />.<br/>
      The allocated memory is defined to be static so it is not moved by the garbage collector.  Since memory is allocated in increments of 32 bytes, some extra space may be allocated.<br/>
      For example, a request for even 1 byte will allocate 32 bytes.  Space allocated by MemAlloc() is freed by MemFree().
      <note type="tip">
        This function allows the direct manipulation of a memory location and should be used with extreme care.
      </note>
    </remarks>
    <example>
      This example uses MemAlloc() to see whether a specified block is available:
      <code language="X#">
        FUNCTION IsAvailable(wRequest AS DWORD) AS LOGIC
        &#0009;LOCAL ptrBuff AS PTR
        &#0009;LOCAL lAvailable AS LOGIC
        &#0009;ptrBuff := MemAlloc(wRequest)
        &#0009;IF ptrBuff = NULL_PTR
        &#0009;&#0009;? "Memory allocation has failed"
        &#0009;&#0009;lAvailable := FALSE
        &#0009;ELSE
        &#0009;&#0009;lAvailable := TRUE
        &#0009;&#0009;MemFree(ptrBuff)
        &#0009;ENDIF
        &#0009;RETURN lAvailable
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemCAlloc'>MemCAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemFree'>MemFree</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemGrpAlloc'>MemGrpAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemGrpClose'>MemGrpClose</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemGrpOpen'>MemGrpOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemTotal'>MemTotal</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemWalk'>MemWalk</seealso>
    <seealso cref='O:XSharp.RT.Functions.StringAlloc'>StringAlloc</seealso>
  </memalloc>
  <mematspecial>
    <summary>
      Get the location of the first special console character in a buffer.
    </summary>

    <param name="ptrBuffer">A pointer to a buffer.</param>
    <param name="dwCount">
      The number of bytes in <paramref name="ptrBuffer" /> to check.
    </param>
    <returns>
      The location of the first special console character within the specified portion of <paramref name="ptrBuffer" />.<br/>
      If a special console character does not exist, MemAtSpecial() returns 0.
    </returns>
    <remarks>
      Special console characters are characters with ASCII values less than or equal to 13, which can require special handling when displayed on the screen.  Moreover, a terminal driver can assign special meaning to them, such as ringing the bell when a Chr(7) is specified.
    </remarks>
    <example>
      This example uses MemAtSpecial() iteratively to detect all special console characters in a string:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL s := "AB" + _Chr(10) + "CD" + _Chr(7) + ;
        &#0009;&#0009;&#0009;"EF" + _Chr(13) + "GH" AS STRING
        &#0009;LOCAL wAt AS DWORD
        &#0009;DO WHILE SLen(s) &gt; 0
        &#0009;&#0009;wAt := MemAtSpecial(Ptr(_CAST, s), SLen(s))
        &#0009;&#0009;IF wAt &gt; 0
        &#0009;&#0009;&#0009;? "Special char with ASCII code of:",;
        &#0009;&#0009;&#0009;&#0009;Asc(Substr3(s, wAt, 1)), "was detected"
        &#0009;&#0009;&#0009;// Query the rest of the string
        &#0009;&#0009;&#0009;// (from wAt+1 and on)
        &#0009;&#0009;&#0009;s := Substr(s, wAt+1)
        &#0009;&#0009;ELSE
        &#0009;&#0009;&#0009;s := ""
        &#0009;&#0009;ENDIF
        &#0009;ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemChr'>MemChr</seealso>
  </mematspecial>
  <membyte>
    <summary>
      Get a pointer to a byte in a memory buffer.
    </summary>

    <param name="ptrBuffer">A pointer to the memory buffer to examine.</param>
    <param name="bChar">The byte value to match.</param>
    <param name="dwCount">
      The number of bytes in <paramref name="ptrBuffer" /> to examine.
    </param>
    <returns>
      A pointer to the first occurrence of <paramref name="bChar" /> within the first <paramref name="dwCount" /> bytes of <paramref name="ptrBuffer" />.<br/>
      If <paramref name="bChar" /> is not matched, MemChr() returns a NULL_PTR.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses MemByte() on a PSZ:
      <code language="X#">
        FUNCTION FindChar()
        &#0009;LOCAL pszC1 := "ABCDEF" AS PSZ
        &#0009;? MemByte(pszC1, ASC("A"), 6)&#0009;&#0009;&#0009;// 3F37:2788
        &#0009;? MemByte(pszC1, ASC("B"), 6)&#0009;&#0009;&#0009;// 3F37:2789
        &#0009;? MemByte(pszC1, ASC("B"), 1)&#0009;&#0009;&#0009;// 0000:0000
        &#0009;// NULL_PTR: ASC("B") is not in the
        &#0009;// first "1" characters of the PSZ
      </code>
      This example uses MemByte() on an allocated block:
      <code language="X#">
        FUNCTION FindChar2()
        &#0009;LOCAL ptrBuff := MemAlloc(10) AS PTR
        &#0009;IF ptrBuff != NULL_PTR
        &#0009;&#0009;// Write 68 to first 10
        &#0009;&#0009;MemSet(ptrBuff, 68, 10)
        &#0009;&#0009;// Overwrite first 5 with 67
        &#0009;&#0009;MemSet(ptrBuff, 67, 5)
        &#0009;&#0009;? MemByte(ptrBuff, 68, 10)&#0009;&#0009;&#0009;// 3CA7:07DD
        &#0009;&#0009;? MemByte(ptrBuff, 67, 10)&#0009;&#0009;&#0009;// 3CA7:07D8
        &#0009;ENDIF
        &#0009;MemFree(ptrBuff)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemChr'>MemChr</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemComp'>MemComp</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemDWord'>MemDWord</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemInt'>MemInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemLong'>MemLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemShort'>MemShort</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemWord'>MemWord</seealso>
  </membyte>
  <memcalloc>
    <summary>
      Allocate static memory buffers of a specified size.
    </summary>

    <param name="wItems">The number of items to allocate memory for.</param>
    <param name="wBytes">The number of bytes to allocate for each item.</param>
    <returns>
      A pointer to the allocated space if there is sufficient memory available; otherwise, a NULL_PTR.  You should always check the return value from MemCAlloc() for a successful allocation.
    </returns>
    <remarks>
      MemCAlloc() is useful in allocating space for several items at one time.<br/>
      The allocated memory is defined to be static so that it is not moved by the garbage collector.  Space allocated by MemCAlloc() is freed by MemFree().
      <note type="tip">
        This function allows the direct manipulation of a memory location and should be used with extreme care.
      </note>
    </remarks>
    <example>
      This example uses MemCAlloc() to allocate space for ten long integers:
      <code language="X#">
        LOCAL ptrLongs AS PTR
        ptrLongs := MemCAlloc(10, 4)
      </code>
      Instead of hard-coding 4 for the size of a long integer, we could have issued:
      <code language="X#">ptrLongs := MemCAlloc(10, _SizeOf(LONG))</code>
      This next example uses MemCAlloc() to allocate space for five instances of a defined structure:
      <code language="X#">
        STRUCTURE StatInfo
        &#0009;MEMBER wAverageHit AS DWORD
        &#0009;MEMBER wMaxHit AS DWORD
        &#0009;MEMBER wMinHit AS DWORD
        FUNCTION MemCAlloc2() AS VOID
        &#0009;LOCAL ptrStruct AS PTR
        &#0009;ptrStruct := MemCAlloc(5, _SizeOf(StatInfo))
        &#0009;IF ptrStruct = NULL_PTR
        &#0009;&#0009;? "Allocation failed"
        &#0009;ELSE
        &#0009;&#0009;MemFree(ptrStruct)
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemAlloc'>MemAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemFree'>MemFree</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemGrpAlloc'>MemGrpAlloc</seealso>
  </memcalloc>
  <memcheckptr>
    <summary>
      Check the validity of a pointer to a memory buffer.
    </summary>

    <param name="ptrValue">The pointer to check.</param>
    <param name="wBytes">The number of bytes to check.</param>
    <returns>
      TRUE if it is a valid dynamically allocated memory pointer; otherwise, FALSE.
    </returns>
    <remarks>
      MemCheckPtr() can safeguard you against invalid wild pointers or null pointers whose use can bring adverse results.
    </remarks>
    <example>
      This example uses MemCheckPtr():
      <code language="X#">
        ptrV := MemAlloc(100)
        ? MemCheckPtr(ptrV, 100)&#0009;&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemAlloc'>MemAlloc</seealso>
  </memcheckptr>
  <memchr>
    <summary>
      Get a pointer to a matching character value in a memory buffer.
    </summary>

    <param name="ptrBuffer">A pointer to the memory buffer to examine.</param>
    <param name="dwChar">Word representation of the character to match.</param>
    <param name="dwCount">
      The number of characters in <paramref name="ptrBuffer" /> to examine.
    </param>
    <returns>
      A pointer to the first occurrence of <paramref name="dwChar" /> within the first <paramref name="dwCount" /> characters of <paramref name="ptrBuffer" />.<br/>
      If <paramref name="dwChar" /> is not matched, MemChr() returns a NULL_PTR.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses MemChr() on a PSZ:
      <code language="X#">
        FUNCTION FindChar() AS VOID
        &#0009;LOCAL pszC1 := "ABCDEF" AS PSZ
        &#0009;? MemChr(pszC1, ASC("A"), 6)&#0009;&#0009;&#0009;// A pointer
        &#0009;? MemChr(pszC1, ASC("B"), 6)&#0009;&#0009;&#0009;// A pointer
        &#0009;? MemChr(pszC1, ASC("B"), 1)
        &#0009;// NULL_PTR: ASC("B") is not in the
        &#0009;// first "1" characters of the PSZ
      </code>
      This next example uses MemChr() on an allocated block:
      <code language="X#">
        FUNCTION FindChar2() AS VOID
        &#0009;LOCAL ptrBuff := MemAlloc(10) AS PTR
        &#0009;IF ptrBuff != NULL_PTR
        &#0009;&#0009;// Write 68 to first 10
        &#0009;&#0009;MemSet(ptrBuff, 68, 10)
        &#0009;&#0009;// Overwrite first 5 with 67
        &#0009;&#0009;MemSet(ptrBuff, 67, 5)
        &#0009;&#0009;? MemChr(ptrBuff, 68, 10)&#0009;&#0009;&#0009;//3CEF:07DD
        &#0009;&#0009;? MemChr(ptrBuff, 67, 10)&#0009;&#0009;&#0009;//3CEF:07D8
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemByte'>MemByte</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemDWord'>MemDWord</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemInt'>MemInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemLong'>MemLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemShort'>MemShort</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemWord'>MemWord</seealso>
  </memchr>
  <memclear>
    <summary>
      Fill a memory buffer with null characters.
    </summary>

    <param name="ptrDest">A pointer to the memory buffer to fill.</param>
    <param name="dwCount">The number of bytes to fill.</param>
    <returns>
      A pointer to the filled memory buffer.
    </returns>
    <remarks>
      MemClear() sets the first <paramref name="dwCount" /> bytes of the memory buffer pointed to by <paramref name="ptrValue" /> to the ASCII CHR(0) character.
      <note type="tip">
        This function allows the direct manipulation of a memory location and should be used with extreme care.
      </note>
    </remarks>
    <example>
      This example clears out the contents of an allocated block:
      <code language="X#">
        LOCAL ptrBuff AS PTR
        ptrBuff := MemAlloc(10)
        MemClear(ptrBuff, 10)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemCopyString'>MemCopyString</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemSet'>MemSet</seealso>
  </memclear>
  <memcomp>
    <summary>
      Compare bytes in two memory buffers.
    </summary>

    <param name="ptrFirst">A pointer to the first memory buffer.</param>
    <param name="ptrSecond">A pointer to the second memory buffer.</param>
    <param name="dwCount">The number of bytes to compare.</param>
    <returns>
      -1, 0, or 1 if the first <paramref name="dwCount" /> bytes of <paramref name="ptrFirst" /> are less than, equal to, or greater than the first <paramref name="dwCount" /> bytes of <paramref name="ptrSecond" />, respectively.
    </returns>
    <remarks>
      <code language="X#">
        MemComp() compares the ANSI values of the first <paramref name="dwCount" /> bytes in each memory buffer.  Note that some characters (such as ä can have a greater ANSI value but a lower OEM value than other characters (such as ).<br/>
        The system only uses the ANSI set.
      </code>
    </remarks>
    <example>
      This examples use MemComp():
      <code language="X#">
        FUNCTION Compare()
        &#0009;LOCAL pszC1 := "abc" AS PSZ
        &#0009;LOCAL pszC2 := "abcd" AS PSZ
        &#0009;LOCAL pszChar1 := "ä" AS PSZ
        &#0009;LOCAL pszChar2 := "ß" AS PSZ
        &#0009;? MemComp(pszC1, pszC2, 4)&#0009;&#0009;&#0009;&#0009;// -1
        &#0009;? MemComp(pszC2, pszC1, 4)&#0009;&#0009;&#0009;&#0009;//  1
        &#0009;// The ANSI value of "ä" is greater than "ß"
        &#0009;// although its OEM value is less.
        &#0009;? MemComp(pszChar1, pszChar2)&#0009;&#0009;&#0009;//  1
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemByte'>MemByte</seealso>
  </memcomp>
  <memcopy>
    <summary>
      Copy one memory buffer to another.
    </summary>

    <param name="ptrDest">A pointer to the destination memory buffer.</param>
    <param name="ptrSource">A pointer to the source string to copy.</param>
    <param name="dwCount">The number of bytes to copy.</param>
    <returns>
      A pointer to the destination memory buffer.
    </returns>
    <remarks>
      MemCopy() copies the specified number of bytes from the source memory buffer to the destination memory buffer.<br/>
      If portions of memory occupied by the source string overlap with portions in the destination, the overlapping region is overwritten.<br/>
      Use MemMove() to copy overlapping regions before they are overwritten.
      <note type="tip">
        This function allows the direct manipulation of a memory location and should be used with extreme care.
      </note>
    </remarks>
    <example>
      This example uses MemCopy():
      <code language="X#">
        LOCAL pszDest := "Hi there" AS PSZ
        LOCAL pszSrc := "***" AS PSZ
        MemCopy(pszDest, pszSrc, 3)
        ? pszDest&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// ***there
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemCopyString'>MemCopyString</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemMove'>MemMove</seealso>
  </memcopy>
  <memcopystring>
    <summary>
      Copy one memory buffer to another and fill any remaining spaces with blanks.
    </summary>

    <param name="ptrDest">A pointer to the destination memory buffer.</param>
    <param name="cSource">The source string to copy.</param>
    <param name="dwCount">The number of bytes to copy.</param>
    <returns>
    </returns>
    <remarks>
      MemCopyString() copies the specified number of bytes from the source memory buffer to the destination memory buffer.<br/>
      If portions of memory occupied by the source string overlap with portions in the destination, the overlapping region is overwritten.<br/>
      If the number of bytes in the source memory buffer is less than <paramref name="dwCount" />, the rest of the destination memory buffer is filled with blanks.<br/>
      Use MemMove() to copy overlapping regions before they are overwritten.
      <note type="tip">
        This function allows the direct manipulation of a memory location and should be used with extreme care.
      </note>
    </remarks>
    <example>
      This example uses MemCopyString():
      <code language="X#">
        LOCAL pszDest := "Hi there" AS PSZ
        LOCAL pszSrc := "***" AS PSZ
        MemCopyString(pszDest, pszSrc, 5)
        ? pszDest&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// "***  ere"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemCopy'>MemCopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemMove'>MemMove</seealso>
  </memcopystring>
  <memdword>
    <summary>
      Get a pointer to a matching double word in a memory buffer.
    </summary>

    <param name="ptrBuffer">A pointer to the memory buffer to examine.</param>
    <param name="dwValue">The double word value to match.</param>
    <param name="dwCount">
      The number of double words in <paramref name="ptrBuffer" /> to examine.
    </param>
    <returns>
      A pointer to the first occurrence of <paramref name="dwValue" /> within the first <paramref name="dwCount" /> characters of <paramref name="ptrBuffer" />.<br/>
      If <paramref name="dwValue" /> is not matched, MemDWord() returns a NULL_PTR.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses MemDWord() on a PSZ:
      <code language="X#">
        FUNCTION FindDWord() AS VOID
        &#0009;LOCAL pszC := "ABCDEFGHIJ" AS PSZ
        &#0009;? MemDWord(pszC, Bin2DW("EFGH"), 2)&#0009;// A  pointer
        &#0009;? MemDWord(pszC, Bin2DW("EFGH"), 1)
        &#0009;// Pattern not found in the first DWord of pszC
        &#0009;//  0000:0000
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemByte'>MemByte</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemChr'>MemChr</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemInt'>MemInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemLong'>MemLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemShort'>MemShort</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemWord'>MemWord</seealso>
  </memdword>
  <memfree>
    <summary>
      Deallocate a specified memory buffer.
    </summary>

    <param name="ptrBuffer">
      A pointer to a previously allocated memory buffer.<br/>
      If an invalid pointer is specified, a message box informs you of the failed attempt.
    </param>
    <returns>
      0 if successful; otherwise, 65,535.
    </returns>
    <remarks>
      MemFree() is a memory function used to free up memory allocated by MemAlloc().<br/>
      The number of bytes freed is the number of bytes that were previously allocated by MemAlloc().
      <note type="tip">
        This function allows the direct manipulation of a memory location and should be used with extreme care.
      </note>
    </remarks>
    <example>
      This example uses MemFree() to deallocate a newly allocated block:
      <code language="X#">
        LOCAL ptrBuff AS PTR
        ptrBuff := MemAlloc(128)
        IF ptrBuff = NULL_PTR
        &#0009;? "Allocation failed"
        ELSE
        &#0009;MemFree(ptrBuff)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemAlloc'>MemAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.StringAlloc'>StringAlloc</seealso>
  </memfree>
  <memgrpalloc>
    <summary>
      Allocate a new memory buffer in a group.
    </summary>

    <param name="wGroup">
      The group to which the newly allocated memory buffer will belong.<br/>
      This group should have already been opened by MemGrpOpen().
    </param>
    <param name="wBytes">The number of bytes to allocate.</param>
    <returns>
      A pointer to the newly allocated space if there is sufficient memory available; otherwise, a NULL_PTR is returned.  You should always check the return value for a successful allocation.
    </returns>
    <remarks>
      MemGrpAlloc() allocates a memory buffer of at least <paramref name="wBytes" />.  Since memory is allocated in increments of 32 bytes, some extra space may be allocated.<br/>
      For example, a request for even 1 byte will allocate 32 bytes.  Space allocated by MemGrpAlloc() is freed by MemGrpClose().
      <note type="tip">
        This function allows the direct manipulation of a memory location and should be used with extreme care.
      </note>
    </remarks>
    <example>
      This example uses MemGrpAlloc():
      <code language="X#">
        Function Start()
        &#0009;LOCAL ptrCurrent AS PTR
        &#0009;LOCAL wGroup AS DWORD
        &#0009;LOCAL lRet AS LOGIC
        &#0009;wGroup := MemGrpOpen()&#0009;&#0009;// Need to have a
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// group ready first
        &#0009;IF wGroup != 0
        &#0009;&#0009;ptrCurrent := MemGrpAlloc(wGroup, 100)
        &#0009;&#0009;MemGrpClose(wGroup)
        &#0009;&#0009;lRet := FALSE
        &#0009;ELSE
        &#0009;&#0009;lRet := TRUE
        &#0009;ENDIF
        &#0009;RETURN lRet
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemGrpClose'>MemGrpClose</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemGrpOpen'>MemGrpOpen</seealso>
  </memgrpalloc>
  <memgrpclose>
    <summary>
      Close a memory group.
    </summary>

    <param name="wGroup">
      The group you want to close.<br/>
      If an invalid group is specified, a message box informs you of the failed attempt to close an invalid group.
    </param>
    <returns>
      0 if successful; otherwise, 65,535.
    </returns>
    <remarks>
      After a call to MemGrpClose(), any memory held by the group is subject to garbage collection, and <paramref name="wGroup" /> ceases to exist as a valid group handle.
      <note type="tip">
        This function allows the direct manipulation of a memory location and should be used with extreme care.
      </note>
    </remarks>
    <example>
      This example uses MemGrpClose() to close two different groups.
      <code language="X#">
        w1 := MemGrpOpen()&#0009;&#0009;&#0009;&#0009;// 1
        IF w1 != 0
        &#0009;? MemGrpClose(w1)&#0009;&#0009;// TRUE
        ENDIF
        IF w2 != 0
        &#0009;w2 := MemGrpOpen()&#0009;&#0009;// 1 (Same handle is reused)
        ENDIF
        MemGrpClose(w2)&#0009;&#0009;&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemGrpAlloc'>MemGrpAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemGrpOpen'>MemGrpOpen</seealso>
  </memgrpclose>
  <memgrpopen>
    <summary>
      Open up a new memory group.
    </summary>
    <returns>
      If successful, the handle of the new group; otherwise, 0.  You should always check for a valid group handle.
    </returns>
    <remarks>
      MemGrpOpen() opens up a new memory group.  In conjunction with MemGrpAlloc(), MemGrpOpen() allows you to group or organize dynamically allocated memory buffers.
      <note type="tip">
        This function allows the direct manipulation of a memory location and should be used with extreme care.
      </note>
    </remarks>
    <example>
      This example uses MemGrpOpen() and checks for a valid group number:
      <code language="X#">
        wGrp := MemGrpOpen()
        IF wGrp = 0
        &#0009;? "Unsuccessful - invalid handle"
        ELSE
        &#0009;? "New valid handle", wGrp
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemGrpAlloc'>MemGrpAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemGrpClose'>MemGrpClose</seealso>
  </memgrpopen>
  <memint>
    <summary>
      Get a pointer to a matching integer in a memory buffer.
    </summary>

    <param name="ptrBuffer">A pointer to the memory buffer to examine.</param>
    <param name="iValue">An integer to match.</param>
    <param name="dwCount">
      The number of integers in <paramref name="ptrBuffer" /> to examine.
    </param>
    <returns>
      A pointer to the first occurrence of <paramref name="iValue" /> within the first <paramref name="dwCount" /> integers of <paramref name="ptrBuffer" />.<br/>
      If <paramref name="iValue" /> is not matched, MemInt() returns a NULL_PTR.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses MemInt() on a PSZ:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL ptrI := "ABCDEFGHIJ" AS PSZ
        &#0009;? MemInt(ptrI, Bin2I("EFGH"), 2)&#0009;// A pointer
        &#0009;? MemInt(ptrI, Bin2I("EFGH"), 1)
        // Not found in the first integer of ptrI 0000:0000
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemByte'>MemByte</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemChr'>MemChr</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemDWord'>MemDWord</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemLong'>MemLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemShort'>MemShort</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemWord'>MemWord</seealso>
  </memint>
  <memlines>
    <summary>
      Count the number of lines in a string or memo field.
    </summary>

    <param name="cString">The string in which to count.</param>
    <returns>
      The number of lines in <paramref name="cString" />, depending on the <paramref name="nLineLength" />, the <paramref name="nTabSize" />, and whether word wrapping is on or off.
    </returns>
    <remarks>
      MemLines() is used with MemoLine() to print strings and memo fields based on the number of characters per line.  In the basic operation, use MemLines() to return the number of lines in the string or memo field.<br/>
      Then, using MemoLine() to extract each line, loop through the memo field until there are no lines left.
    </remarks>
    <example>
      This example displays the contents of each Notes memo field in the SALES.DBF file, 1 line at a time:
      <code language="X#">
        USE sales NEW
        nLineLength = 65
        DO WHILE !EOF()
        &#0009;nLines = MemLines(Sales-&gt;Notes)
        &#0009;FOR nCurrLine = 1 UPTO nLines
        &#0009;&#0009;? MemoLine(Sales-&gt;Notes, nLineLength,;
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;nCurrLine)
        &#0009;NEXT
        &#0009;SKIP
        &#0009;?
        ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MemoLine'>MemoLine</seealso>
  </memlines>
  <memlong>
    <summary>
      Get a pointer to a matching long integer in a memory buffer.
    </summary>

    <param name="ptrBuffer">A pointer to the memory buffer to examine.</param>
    <param name="liValue">The long integer value to match.</param>
    <param name="dwCount">
      The number of long integers in <paramref name="ptrBuffer" /> to examine.
    </param>
    <returns>
      A pointer to the first occurrence of <paramref name="liValue" /> within the first <paramref name="dwCount" /> long integers of <paramref name="ptrBuffer" />.<br/>
      If <paramref name="liValue" /> is not matched, MemLong() returns a NULL_PTR.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses MemLong() on a PSZ:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL ptrLI := "ABCDEFGHIJ" AS PSZ
        &#0009;? MemLong(ptrLI, Bin2L("EFGH", 2))&#0009;&#0009;// A pointer
        &#0009;? MemLong(ptrLI, Bin2L("EFGH", 1))
        &#0009;// Not found in the first long integer of ptrLI
        &#0009;// 0000:0000
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemByte'>MemByte</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemChr'>MemChr</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemDWord'>MemDWord</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemInt'>MemInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemShort'>MemShort</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemWord'>MemWord</seealso>
  </memlong>
  <memmove>
    <summary>
      Move one memory buffer to another.
    </summary>

    <param name="ptrDest">A pointer to the destination memory buffer.</param>
    <param name="ptrSource">A pointer to the source memory buffer.</param>
    <param name="dwCount">The number of bytes to copy.</param>
    <returns>
      A pointer to the destination memory buffer.
    </returns>
    <remarks>
      MemMove() copies the specified number of bytes from the source memory buffer to the destination memory buffer.<br/>
      If portions of the source buffer overlap with portions of the destination buffer, the overlapping region is copied and kept for the duration of the operation before it is overwritten.
      <note type="tip">
        This function allows the direct manipulation of a memory location and should be used with extreme care.
      </note>
    </remarks>
    <example>
      This example uses MemMove():
      <code language="X#">
        LOCAL pszDest := "Hi there" AS PSZ
        LOCAL pszSrc := "***" AS PSZ
        MemMove(pszDest, pszSrc, 3)
        ? pszDest&#0009;&#0009;&#0009;&#0009;&#0009;// ***there
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemCopy'>MemCopy</seealso>
  </memmove>
  <memoline>
    <summary>
      Extract a line of text from a string.
    </summary>

    <param name="cString">The string from which to extract a line of text.</param>
    <param name="nLineLength">
      The number of characters per line.<br/>
      This can be a value between 4 and 254.<br/>
      The default is 79.
    </param>
    <param name="nLineNumber">
      The line number to extract.<br/>
      The default is 1.
    </param>
    <param name="nTabSize">
      The number of characters to insert when the user presses Tab.<br/>
      If <paramref name="nTabSize" /> is not specified, 4 spaces are inserted.<br/>
      If <paramref name="nTabSize" /> is greater than or equal to <paramref name="nLineLength" />, the tab size is automatically converted to <paramref name="nLineLength" /> minus 1.
    </param>
    <param name="lWrap">
      TRUE toggles word wrap on; FALSE toggles it off.<br/>
      The default is TRUE.
    </param>
    <returns>
      The line of text specified by <paramref name="nLineNumber" /> in <paramref name="cString" />.<br/>
      If the line has fewer characters than the indicated length, the return value is padded with blanks.<br/>
      If the line number is greater than the total number of lines in <paramref name="cString" />, MemoLine() returns a NULL_STRING.
      If <paramref name="lWrap" /> is TRUE and the indicated line length breaks the line in the middle of a word, that word is not included as part of the return value but shows up at the beginning of the next line extracted with MemoLine().
      If <paramref name="lWrap" /> is FALSE, MemoLine() returns only the number of characters specified by the line length.<br/>
      The next line extracted by MemoLine() begins with the character following the next hard carriage return, and all intervening characters are not processed.
    </returns>
    <remarks>
      MemoLine() is a memo function used with MLCount() to extract lines of text from strings and memo fields, based on the number of characters per line.<br/>
      It is the most basic facility provided by X# to display memo fields and long strings.
      The basic method of operation is to determine the number of lines in the string using MLCount() and specifying the same number of characters per line, tab size, and wrapping behavior as you intend to use with MemoLine().<br/>
      Using this value as the upper boundary of a FOR...NEXT, each line of the string can be extracted with MemoLine() and processed with any combination of output commands and functions required.
    </remarks>
    <example>
      This example demonstrates the general method for displaying memo fields and long strings using the combination of MLCount() and MemoLine():
      <code language="X#">
        LOCAL nLineLength := 40, nTabSize := 3, lWrap := TRUE
        LOCAL nLines, nCurrentLine
        USE customer INDEX custname NEW
        nLines := MLCount(CustNotes, nLineLength, nTabSize, lWrap)
        SET PRINTER ON
        FOR nCurrentLine := 1 UPTO nLines
        &#0009;? MemoLine(CustNotes, nLineLength, nCurrentLine, nTabSize, lWrap)
        NEXT
        SET PRINTER OFF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MemLines'>MemLines</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemoTran'>MemoTran</seealso>
    <seealso cref='O:XSharp.RT.Functions.MLCount'>MLCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.MLine'>MLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.MLine3'>MLine3</seealso>
    <seealso cref='O:XSharp.RT.Functions.MLPos'>MLPos</seealso>
  </memoline>
  <memoread>
    <summary>
      Return the contents of a text file as a string.
    </summary>

    <param name="cFileName">The name of the text file to read from disk, including an optional drive, directory, and extension.  SetDefault() and SetPath() settings are ignored; the Windows default is used unless you specify a drive and directory as part of the file name.  No extension is assumed.</param>
    <returns>
      The contents of the file.<br/>
      The maximum file size that can be read is MAX_ALLOC bytes — the maximum size of a string.
      If <paramref name="cFileName" /> does not exist, MemoRead() returns a NULL_STRING.<br/>
      If it exists, this function attempts to open the file in shared mode and, if successful, it proceeds.<br/>
      If access is denied because, for example, another process has exclusive use of the file, MemoRead() returns a NULL_STRING and NetErr() is set to TRUE.
    </returns>
    <remarks>
      MemoRead() reads a disk file into memory, where it can be manipulated as a string or assigned to a memo field.  MemoRead() is used with MemoEdit() and MemoWrit() to edit an imported disk file; then write it back to disk.
      This function does an automatic OEM to ANSI conversion when SetAnsi() is FALSE.
    </remarks>
    <example>
      This example uses MemoRead() to assign the contents of a text file to the Notes memo field and to a character variable:
      <code language="X#">
        REPLACE Notes WITH MemoRead("temp.txt")
        cString = MemoRead("temp.txt")
      </code>
      This example defines a function that edits a disk file:
      <code language="X#">
        FUNCTION Editor(cFile)
        &#0009;LOCAL cString AS STRING
        &#0009;If(cString := MemoRead(cFile)) = NULL_STRING
        &#0009;&#0009;? "Error reading " + cFile
        &#0009;&#0009;RETURN FALSE
        &#0009;ELSE
        &#0009;&#0009;MemoWrit(cFile, MemoEdit(cString))
        &#0009;&#0009;RETURN TRUE
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.RT.Functions.FReadLine'>FReadLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.MemoWrit'>MemoWrit</seealso>
  </memoread>
  <memory>
    <summary>
      Report the status of memory.
    </summary>

    <param name="iFunc">One of the following constants, indicating the type of memory information about which you want to report (note that each constant begins with the prefix MEMORY_ as illustrated in the example below):</param>
    <param name="Constant">Action/Returns&#0009;</param>
    <param name="MEMORY_ACTIVATION">Size of activation stack table in bytes (maximum is 64)&#0009;</param>
    <param name="MEMORY_CLASSCOUNT">ClassCount()&#0009;</param>
    <param name="MEMORY_COLLECT">CollectForced()&#0009;</param>
    <param name="MEMORY_COLLECTCOUNT">CollectCount()&#0009;</param>
    <param name="MEMORY_DYNINFOFREE">DynInfoFree()&#0009;</param>
    <param name="MEMORY_DYNINFOMAX">DynInfoMax()&#0009;</param>
    <param name="MEMORY_DYNINFOSIZE">DynInfoSize()&#0009;</param>
    <param name="MEMORY_DYNINFOUSED">DynInfoUsed()&#0009;</param>
    <param name="MEMORY_FUNCTIONCOUNT">FCount()&#0009;</param>
    <param name="MEMORY_MAXATOM">MaxAtom()&#0009;</param>
    <param name="MEMORY_MEMTOTAL">MemTotal()&#0009;</param>
    <param name="MEMORY_PRIVAT">Size of private var table in bytes (maximum is 64)&#0009;</param>
    <param name="MEMORY_PUBLIC">Size of public var table in bytes (maximum is 64)&#0009;</param>
    <param name="MEMORY_REGCOLLNOTIFYEND_COUNT">Number of _RegCollNotifyEnd() active&#0009;</param>
    <param name="MEMORY_REGCOLLNOTIFYSTART_COUNT">Number of _RegCollNotifyStart() active&#0009;</param>
    <param name="MEMORY_REGISTERAXIT">Number of RegisterAxit() active&#0009;</param>
    <param name="MEMORY_REGISTEREXIT_COUNT">Number of _RegisterExit() active&#0009;</param>
    <param name="MEMORY_REGISTERKID">Number of RegisterKid() active&#0009;</param>
    <param name="MEMORY_SEQUENCE">Size of SEQUENCE table in bytes (maximum is 64) (see LABEL...())&#0009;</param>
    <param name="MEMORY_SP">Stack pointer of application&#0009;</param>
    <param name="MEMORY_STACK_FREE">Free stack space in bytes&#0009;</param>
    <param name="MEMORY_STACK_SIZE">Size of stack segment of application&#0009;</param>
    <param name="MEMORY_STACKKID">Number of stack KID active&#0009;</param>
    <param name="MEMORY_SYSTEM_FREE">Calls the Windows API GlobalMemoryStatus() function, returning MemoryStatus.dwTotalPhys&#0009;</param>
    <param name="MEMORY_SYSTEM_MAX">Calls the Windows API GlobalMemoryStatus() function, returning MemoryStatus.dwAvailPhys&#0009;</param>
    <param name="MEMORY_WINDOWS_SYSTEMRESOURCES">Calls the Windows API GlobalMemoryStatus() function, returning MemoryStatus.dwMemoryLoad&#0009;</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses Memory() to query various memory states:
      <code language="X#">
        ? Memory(MEMORY_SYSTEM_FREE)
        ? Memory(MEMORY_SYSTEM_MAX)
        ? Memory(MEMORY_DYNINFOFREE)
        ? Memory(MEMORY_DYNINFOMAX)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ClassCount'>ClassCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.CollectCount'>CollectCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.CollectForced'>CollectForced</seealso>
    <seealso cref='O:XSharp.VO.Functions.DynCheckError'>DynCheckError</seealso>
    <seealso cref='O:XSharp.VO.Functions.DynInfoFree'>DynInfoFree</seealso>
    <seealso cref='O:XSharp.VO.Functions.DynInfoSize'>DynInfoSize</seealso>
    <seealso cref='O:XSharp.VO.Functions.DynInfoUsed'>DynInfoUsed</seealso>
    <seealso cref='O:XSharp.RT.Functions.FCount'>FCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.MaxAtom'>MaxAtom</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemTotal'>MemTotal</seealso>
  </memory>
  <memotran>
    <summary>
      Replace carriage-return/linefeeds with a character that can be displayed.
    </summary>

    <param name="cTarget">The string that contains the carriage-return/linefeed.</param>
    <param name="cReplaceHardCR">
      The character to replace a hard carriage-return/linefeed pair with.<br/>
      The default is a semicolon (;).
    </param>
    <param name="cReplaceSoftCR">
      The character to replace a soft carriage-return/linefeed pair with.<br/>
      The default is a space.
    </param>
    <returns>
      A copy of <paramref name="cString" /> with the specified carriage-return/linefeed pairs replaced.
    </returns>
    <remarks>
      Carriage-return/linefeed characters are end-of-line formatting indicators placed in the string by MemoEdit():
      &#0009;Soft carriage returns (Chr(141)) are inserted when a line longer than the width of the MemoEdit() window wraps.
      &#0009;Hard carriage returns (Chr(13)) are inserted when the user explicitly presses Enter.
      MemoTran() is particularly useful when displaying a memo field in a report form that does not wrap when a soft carriage return is encountered.  MemoTran() resolves this by converting soft carriage returns to spaces.
    </remarks>
    <example>
      This example strips all end-of-line characters from a memo field:
      <code language="X#">REPLACE _FIELD-&gt;Notes WITH MemoTran(_FIELD-&gt;Notes)</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.HardCR'>HardCR</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrTran'>StrTran</seealso>
  </memotran>
  <memowrit>
    <summary>
      Write a string to a disk file.
    </summary>

    <param name="cFileName">
      The name of the target disk file, including an optional drive, directory, and extension.  SetDefault() and SetPath() settings are ignored; the Windows default is used unless you specify a drive and directory as part of the file name.  No extension is assumed.<br/>

      &#0009;If <paramref name="cFileName" /> does not exist, it is created.<br/>
      If it exists, this function attempts to open the file in exclusive mode and, if successful, the file is overwritten without warning or error.<br/>
      If access is denied because, for example, another process is using the file, MemoWrit() returns FALSE and NetErr() is set to TRUE.
    </param>
    <param name="cString">
      The string to write to <paramref name="cFileName" />.
    </param>
    <returns>
      TRUE if the writing operation is successful; otherwise, FALSE.
    </returns>
    <remarks>
      MemoWrit() is generally used with MemoRead() to load text files into memory, where they can be edited, displayed, and written back to disk.  You can also use MemoWrit() as a quick way of exporting a memo field to a text file.
      <note type="tip">
        Some characters, such as "ß," have different ANSI and OEM codes.  When writing such characters from Windows to a file, you may need to issue the Ansi2Oem() function.  Conversely, when reading the file back to Windows, you may need to issue an Oem2Ansi() function.<br/>
        To circumvent such problems, MemoWrit() automatically does an ANSI to OEM conversion when SetAnsi() is FALSE.
      </note>
    </remarks>
    <example>
      This example uses MemoWrit() to save the contents of a field to a text file:
      <code language="X#">
        USE Sales
        IF MemoWrit("votmp.txt", Sales-&gt;Notes)
        &#0009;? "Saved"
        ELSE
        &#0009;? "Error while writing cliptmp.txt"
        &#0009;BREAK
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.MemoRead'>MemoRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
  </memowrit>
  <memset>
    <summary>
      Fill a memory buffer with a specified character.
    </summary>

    <param name="ptrBuffer">A pointer to the memory buffer to fill.</param>
    <param name="bValue">The code for the character, as a number from 0 to 255.</param>
    <param name="wCount">The number of bytes to fill.</param>
    <returns>
      A pointer to the filled memory buffer.
    </returns>
    <remarks>
      MemSet() sets the first <paramref name="wCount" /> characters of the memory buffer pointed to by <paramref name="ptrBuffer" /> to a specified character.
      <note type="tip">
        This function allows the direct manipulation of a memory location and should be used with extreme care.
      </note>
    </remarks>
    <example>
      This example uses MemSet() to fill up all characters of an allocated buffer with "A":
      <code language="X#">
        FUNCTION MemReplicate() AS VOID
        &#0009;LOCAL ptrC AS PTR
        &#0009;ptrC := MemAlloc(10)
        &#0009;ptrC := MemSet(ptrC, Asc("A"),10)
        &#0009;? ptrC&#0009;&#0009;&#0009;&#0009;&#0009;// AAAAAAAAAA
        &#0009;MemFree(ptrC)
      </code>
      This example uses MemSet() to change all characters of a PSZ to "Z":
      <code language="X#">
        FUNCTION PszQ()
        &#0009;LOCAL pszS := "ABC" AS PSZ
        &#0009;// Asc("Z") = 90
        &#0009;MemSet(pszS, 90,3)
        &#0009;? pszS&#0009;&#0009;&#0009;&#0009;&#0009;// ZZZ
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemClear'>MemClear</seealso>
  </memset>
  <memshort>
    <summary>
      Get a pointer to a matching short integer in a memory buffer.
    </summary>

    <param name="ptrBuffer">A pointer to the memory buffer to examine.</param>
    <param name="siValue">The short integer value to match.</param>
    <param name="dwCount">
      The number of short integers in <paramref name="ptrBuffer" /> to examine.
    </param>
    <returns>
      A pointer to the first occurrence of <paramref name="siValue" /> within the first <paramref name="dwCount" /> short integers of  <paramref name="ptrBuffer" />.<br/>
      If <paramref name="siValue" /> is not matched, MemShort() returns a NULL_PTR.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses MemShort() on a PSZ:
      <code language="X#">
        FUNCTION StartShort()
        &#0009;LOCAL ptrSI := "ABCDEFGHIJ" AS PSZ
        &#0009;// Note: short integer translation of "AB"
        &#0009;// is 16961
        &#0009;? MemShort(ptrSI, 16961,2) &#0009;&#0009;// A pointer
        &#0009;? MemShort(ptrSI, 16961,1) &#0009;&#0009;// A pointer
        &#0009;// Same pointer as above
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemByte'>MemByte</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemChr'>MemChr</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemDWord'>MemDWord</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemInt'>MemInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemLong'>MemLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemWord'>MemWord</seealso>
  </memshort>
  <memtotal>
    <summary>
      Report the total number of bytes used by other memory manager functions.
    </summary>
    <returns>
      The total memory consumed by memory manager functions.<br/>
      This value is rounded or accurate within 4 KB increments.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses MemTotal() before and after allocating a memory buffer through a MemAllocSeg() function:
      <code language="X#">
        ? MemTotal()
        w := MemAllocSeg(100)
        ? MemTotal()&#0009;&#0009;&#0009;// Larger value than first call
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemAlloc'>MemAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemCAlloc'>MemCAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemGrpAlloc'>MemGrpAlloc</seealso>
  </memtotal>
  <memvarblock>
    <summary>
      Return a set-get code block for a given memory variable.
    </summary>

    <param name="cMemvarName">The name of the variable referred to by the set-get block.</param>
    <returns>
      A runtime code block (implemented as an object) that, when evaluated, sets (assigns) or gets (retrieves) the value of <paramref name="cMemvarName" />.<br/>
      If <paramref name="cMemvarName" /> does not exist, MemVarBlock() returns a NULL_OBJECT.
    </returns>
    <remarks>
      The code block created by MemVarBlock() has two operations, depending on whether an argument is passed to the code block when it is evaluated:
      &#0009;If the code block is evaluated with an argument, it assigns the value of the argument to <paramref name="cMemvarName" />.
      &#0009;If the code block is evaluated without an argument, it retrieves the value of <paramref name="cMemvarName" />.
      <note type="tip">
        MemVarBlock() creates set-get blocks only for variables whose names are known at runtime.  MemVarBlock(), therefore, cannot be used to create set-get blocks for local or static variables.<br/>
        The same restriction applies to creating blocks using the macro operator (&amp;).
      </note>
    </remarks>
    <example>
      This example compares MemVarBlock() to a code block created using the macro operator (&amp;).  Note that using MemVarBlock() allows you to avoid the speed and size overhead of the macro operator:
      <code language="X#">
        PRIVATE var := "This is a string"
        // Set-Get block defined using macro operator
        cbSetGet := &amp;("{|setVal|;
        &#0009;&#0009;If(setVal = NIL, var, var := setVal)}")
        // Set-Get block defined using MemVarBlock().
        // It is the functional equivalent of cbSetGet above
        cbSetGet := MemVarBlock("var")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldBlock'>FieldBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldWBlock'>FieldWBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarBlockSym'>MemVarBlockSym</seealso>
  </memvarblock>
  <memvarblocksym>
    <summary>
      Obtain a set-get code block for a given memory variable.
    </summary>

    <param name="symMemvarName">A symbol representing the variable name whose set-get block you want to obtain.</param>
    <returns>
      A runtime code block (implemented as an object) that, when evaluated, sets (assigns) or gets (retrieves) the value of <paramref name="cMemvarName" />.<br/>
      If <paramref name="cMemvarName" /> does not exist, MemVarBlockSym() returns a NULL_OBJECT.
    </returns>
    <remarks>
      The code block created by MemVarBlockSym() has two operations depending on whether an argument is passed to the code block when it is evaluated.<br/>
      If the code block is evaluated with an argument, it assigns the value of the argument to <paramref name="cMemvarName" />.<br/>
      If the code block is evaluated without an argument, it retrieves the value of <paramref name="cMemvarName" />.
      <note type="tip">
        MemVarBlockSym() creates set-get blocks only for variables whose names are known at runtime.  MemVarBlockSym(), therefore, cannot be used to create set-get blocks for local or static variables.<br/>
        The same restriction applies to creating blocks using the macro operator (&amp;).
      </note>
    </remarks>
    <example>
      This example compares MemVarBlockSym() to a code block created using the macro operator (&amp;).  Note that using MemVarBlockSym() allows you to avoid the speed and size overhead of the macro operator:
      <code language="X#">
        PRIVATE var := "This is a string"
        // Set-Get block defined using macro operator
        cbSetGet := &amp;({"|setVal|;
        &#0009;&#0009;If(setVal = NIL, var, var := setVal)}")
        // Set-Get block defined using MemVarBlockSym()
        // is the functional equivalent of cbSetGet above
        cbSetGet := MemVarBlockSym(#var)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldBlock'>FieldBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldWBlock'>FieldWBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarBlock'>MemVarBlock</seealso>
  </memvarblocksym>
  <memvarget>
    <summary>
      Return the contents of a memory variable.
    </summary>

    <param name="cVarName">The name of the memory variable.</param>
    <returns>
    </returns>
    <remarks>
      MemVarGet() is used instead of a macro when the name of the variable is in a string.
    </remarks>
    <example>
      This example uses MemVarGet() to retrieve the contents of a memory variable:
      <code language="X#">
        cPrivate := "hi"
        cHasName := "cPrivate"
        // Instead of ? &amp;cHasName, use this:
        ? MemVarGet(cHasName)&#0009;&#0009;&#0009;// hi
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarGet'>IVarGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarPut'>MemVarPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.VarGet'>VarGet</seealso>
  </memvarget>
  <memvarput>
    <summary>
      Assign a value to a memory variable of a given name.
    </summary>

    <param name="cVarName">The name of the variable you want to create.</param>
    <param name="uValue">The value to assign to the variable.</param>
    <returns>
      The value assigned to <paramref name="uValue" />.
    </returns>
    <remarks>
      If a memory variable called <paramref name="cVarName" /> does not exits, a memory variable called <paramref name="cVarName" /> is created.<br/>
      Therefore, MemVarPut(), like VarPut() can be used to create undeclared memory variables.<br/>
      It should be used instead of a macro.
      <note type="tip">
        This function allows the direct manipulation of a memory location and should be used with extreme care.
      </note>
    </remarks>
    <example>
      This example uses MemVarPut() to create a memory variable:
      <code language="X#">
        LOCAL cHasName AS STRING
        cHasName := "cPrivate"
        // Instead of &amp;cHasName := "new", use this:
        MemVarPut(cHasName, "new")
        ? cPrivate&#0009;&#0009;&#0009;&#0009;&#0009;// new
      </code>
      This example shows that the newly created variable is a MEMVAR:
      <code language="X#">
        MemVarPut("cVar", "hi")
        ? _MEMVAR-&gt;cVar&#0009;&#0009;&#0009;// hi
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarPut'>IVarPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarGet'>MemVarGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.VarPut'>VarPut</seealso>
  </memvarput>
  <memwalk>
    <summary>
      Walk through the memory system, checking for validity.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses MemWalk() after allocating and deallocating memory with other memory manager functions:
      <code language="X#">
        p := MemAlloc(100)
        MemFree(p)
        ? MemWalk()
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemAlloc'>MemAlloc</seealso>
  </memwalk>
  <memword>
    <summary>
      Get a pointer to a matching word in a memory buffer.
    </summary>

    <param name="ptrBuffer">A pointer to the memory buffer to examine.</param>
    <param name="dwValue">The word value to match.</param>
    <param name="dwCount">
      The number of words in <paramref name="ptrBuffer" /> to examine.
    </param>
    <returns>
      A pointer to the first occurrence of <paramref name="dwValue" /> within the first <paramref name="dwCount" /> words of <paramref name="ptrBuffer" />.<br/>
      If <paramref name="dwValue" /> is not matched, MemWord() returns a NULL_PTR.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses MemWord() on a PSZ:
      <code language="X#">
        Function Start()
        &#0009;LOCAL ptrW := "ABCDEFGHIJ" AS PSZ
        &#0009;? MemWord(ptrW, Bin2W("CD"), 3)&#0009;// A pointer
        &#0009;? MemWord(ptrW, Bin2W("CD"), 1)
        &#0009;// Not found in the first word of ptrW
        &#0009;//   0000:0000
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemAtSpecial'>MemAtSpecial</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemByte'>MemByte</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemChr'>MemChr</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemClear'>MemClear</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemComp'>MemComp</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemDWord'>MemDWord</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemInt'>MemInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemLong'>MemLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemShort'>MemShort</seealso>
  </memword>
  <methodlist>
    <summary>
      Create a class list in the form of an array for the specified object.
    </summary>

    <param name="oClass">The object whose methods you want to list.</param>
    <returns>
      An array of symbols containing the name of all methods defined for <paramref name="symObject" />.
    </returns>
    <remarks>
      This function creates a list of all methods defined for the specified object.<br/>
      The resulting method list array does not include ACCESS or ASSIGN methods.
    </remarks>
    <example>
      This example uses MethodList() to store a method list for an object of the Person class, then displays the resulting array.  Note how the ACCESS method is ignored.
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL oPerson AS Person
        &#0009;oPerson := Person{"Susan", 5, "Cue")
        &#0009;AEval(MethodList(oPerson),{|x| QOut(x)})
        &#0009;// Result is:
        &#0009;// INIT
        &#0009;// SHOWGRADE
        CLASS Person
        &#0009;EXPORT name
        &#0009;INSTANCE grade
        &#0009;PROTECT password
        CONSTRUCTOR(tname, tgrade, tpassword)
        &#0009;name := tname
        &#0009;grade := tgrade
        &#0009;password := tpassword
        METHOD ShowGrade()
        &#0009;? grade
        ACCESS Grade()
        &#0009;RETURN grade
        END CLASS
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IvarList'>IVarList</seealso>
    <seealso cref='O:XSharp.RT.Functions.MethodListClass'>MethodListClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.Object2Array'>Object2Array</seealso>
  </methodlist>
  <methodlistclass>
    <summary>
      Create a class list in the form of an array for the specified class.
    </summary>

    <param name="symClass">The class whose methods you want to list.</param>
    <returns>
      An array of symbols containing the name of all methods declared for <paramref name="symClass" />.
    </returns>
    <remarks>
      This function creates a list of all methods defined for the specified class.<br/>
      The resulting method list array does not include ACCESS or ASSIGN methods.
    </remarks>
    <example>
      This example uses MethodListClass() to store a method list for the Person class, then displays the resulting array.  Note how the ACCESS method is ignored.
      <code language="X#">
        FUNCTION Start()
        &#0009;AEval(MethodListClass(#Person),{|x| QOut(x)})
        &#0009;// Result is:
        &#0009;// INIT
        &#0009;// SHOWGRADE
        CLASS Person
        &#0009;EXPORT name
        &#0009;INSTANCE grade
        &#0009;PROTECT password
        CONSTRUCTOR(tname, tgrade, tpassword)
        &#0009;name := tname
        &#0009;grade := tgrade
        &#0009;password := tpassword
        METHOD ShowGrade()
        &#0009;? grade
        ACCESS Grade()
        &#0009;RETURN grade
        END CLASS

      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IvarListClass'>IVarListClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.MethodList'>MethodList</seealso>
    <seealso cref='O:XSharp.RT.Functions.Object2Array'>Object2Array</seealso>
  </methodlistclass>
  <mexec>
    <summary>
      Evaluate a macro-compiled string.
    </summary>

    <param name="oBlock">The macro-compiled string.</param>
    <returns>
      The value of the compiled expression.
    </returns>
    <remarks>
      MExec() evaluates an expression that was previously macro-compiled.
      Instead of  invoking the macro compiler each time an expression is evaluated,
      you could speed up your application by compiling an expression only once and
      executing the compiled result as often as desired.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/mcompilemexec/*" />

    </remarks>
    <example>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/mcompileexamples/*" />
    </example>
    <seealso cref='O:XSharp.RT.Functions.Evaluate'>Evaluate</seealso>
    <seealso cref='O:XSharp.RT.Functions.MAssign'>MAssign</seealso>
    <seealso cref='O:XSharp.RT.Functions.MCompile'>MCompile</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.ExecScript'>ExecScript</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrEvaluate'>StrEvaluate</seealso>
    <seealso cref='T:XSharp._Codeblock'>_Codeblock type</seealso>
  </mexec>

  <min>
    <summary>
      Return the smaller of 2 values.
    </summary>

    <param name="dValue1">The first value to compare.</param>
    <param name="dValue2">The second value to compare.</param>
    <param name="uValue1">The first value to compare.</param>
    <param name="uValue2">
      The second value to compare.<br/>
      This must be of the same type as <paramref name="uValue1" /> except that numerics of different types are allowed.
    </param>
    <returns>
      The smaller of the 2 arguments.<br/>
      The value returned is the same type as the smaller argument.
    </returns>
    <remarks>
      The inverse of Min() is Max(), which returns the larger of 2 expressions.
    </remarks>
    <example>
      In these examples Min() returns the smaller of 2 numbers:
      <code language="X#">
        ? MIN(99, 100)&#0009;&#0009;&#0009;&#0009;&#0009;// 99
        ? MIN(100, 99)&#0009;&#0009;&#0009;&#0009;&#0009;// 99
      </code>
      In these examples Min() compares date values:
      <code language="X#">
        ? TODAY()&#0009;&#0009;&#0009;&#0009;&#0009;// 05/27/93
        ? MIN(TODAY(), TODAY() + 30)&#0009;&#0009;// 05/27/93
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Between'>Between</seealso>
    <seealso cref='O:XSharp.RT.Functions.Max'>Max</seealso>
    <seealso cref="O:XSharp.Core.Functions.Min" />
  </min>
  <mlcount>
    <summary>
      Count the number of lines in a string.
    </summary>

    <param name="cString">The string to count.</param>
    <param name="nLineLength">
      The number of characters per line, ranging from 4 to 254.<br/>
      The default line length is 79.
    </param>
    <param name="nTabSize">
      The number of characters to insert when the user presses the tab key.<br/>
      The default value is 4.<br/>
      If <paramref name="nTabSize" /> is greater than or equal to <paramref name="nLineLength" />, the tab size is automatically converted to <paramref name="nLineLength" /> minus 1.
    </param>
    <param name="lWrap">
      Controls whether words wrap to the next line:  TRUE if they wrap; FALSE if they do not.<br/>
      The default is TRUE.
    </param>
    <returns>
      The number of lines in <paramref name="cString" />, depending on the <paramref name="nLineLength" />, the <paramref name="nTabSize" />, and whether word wrapping is on or off.
    </returns>
    <remarks>
      MLCount() is a memo function used with MemoLine() to print strings and memo fields based on the number of characters per line.  In the basic operation, use MLCount() to return the number of lines in the string.<br/>
      Then, using MemoLine() to extract each line, loop through the string until there are no lines left.
      If <paramref name="lWrap" /> is TRUE and an end of line position breaks a word, it is word-wrapped to the next line and the next line begins with that word.<br/>
      If <paramref name="lWrap" /> is FALSE, MLCount() counts the number of characters specified by <paramref name="nLineLength" /> as the current line.<br/>
      The next line begins with the character following the next hard or soft carriage return.  Intervening characters are ignored.
    </remarks>
    <example>
      This example displays the contents of each Notes memo field in the SALES database file, 1 line at a time:
      <code language="X#">
        USE sales NEW
        nLineLength = 65
        DO WHILE !EOF()
        &#0009;nLines = MLCount(Sales-&gt;Notes, nLineLength)
        &#0009;FOR nCurrLine = 1 UPTO nLines
        &#0009;&#0009;? MemoLine(Sales-&gt;Notes, nLineLength, nCurrLine)
        &#0009;NEXT
        &#0009;SKIP
        &#0009;?
        ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MemLines'>MemLines</seealso>
    <seealso cref='O:XSharp.Core.Functions.MemoLine'>MemoLine</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemoTran'>MemoTran</seealso>
    <seealso cref='O:XSharp.Core.Functions.MLCount1'>MLCount1</seealso>
    <seealso cref='O:XSharp.RT.Functions.MLPos'>MLPos</seealso>
  </mlcount>
  <mlcount1>
    <summary>
      Count the number of lines in a string.
    </summary>

    <param name="cString">The string to count.</param>
    <returns>
      The number of lines in <paramref name="cString" />.
    </returns>
    <remarks>
      MLCount1() is similar to MLCount() except that MLCount1() has only one argument and that argument is strongly typed.  See MLCount() for more information.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MLCount'>MLCount</seealso>
  </mlcount1>
  <mlctopos>
    <summary>
      Return the position of a character in a formatted string.
    </summary>

    <param name="cText">A string.</param>
    <param name="nWidth">
      The length of each line after <paramref name="cText" /> is formatted.
    </param>
    <param name="nLine">The line number in the formatted text, starting from the top at 1.</param>
    <param name="nCol">The column number in the formatted text, starting from the left at 0.</param>
    <param name="nTabSize">
      The number of characters to insert when the user presses Tab.<br/>
      If <paramref name="nTabSize" /> is not specified, 4 spaces are inserted.
    </param>
    <param name="lWrap">
      The word-wrap flag.<br/>
      The default is TRUE.
    </param>
    <returns>
      The byte position of the character within <paramref name="cText" />, counting from 1.
    </returns>
    <remarks>
      MLCToPos() determines the character position that corresponds to a particular line and column within formatted text.  Note that the line number is 1-relative, and the column number is 0-relative.<br/>
      This is compatible with MemoEdit().<br/>
      The return value is 1-relative, making it suitable for use in Substr() or other string functions.
      MLCToPos() is used with MPosToLC() to create search routines or other text processing for MemoEdit().
    </remarks>
    <example>
      This example gives the current position of the character that will appear in line 3, column 0 when <paramref name="cText" /> is formatted with a line length of 5 characters:
      <code language="X#">
        cText := "Note the side on which the bread" + "is buttered."
        ? MLCToPos(cText, 5, 3, 0)&#0009;&#0009;// Result: 10
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MLPos'>MLPos</seealso>
    <seealso cref='O:XSharp.RT.Functions.MPosToLc'>MPosToLC</seealso>
  </mlctopos>
  <mline>
    <summary>
      Extract a line of text from a string, specifying an optional offset argument.
    </summary>

    <param name="cString">The string that contains the line of text.</param>
    <param name="nLine">The line number to extract.</param>
    <param name="nOffset">
      The position from which to extract characters.<br/>
      An offset of 0 corresponds to the first byte in <paramref name="cString" />.<br/>
      This is the default.<br/>
      Alternatively, <paramref name="nOffset" /> may be passed by reference (preceded by an @) in which case, after the function call, it will contain the size of the returned line.
    </param>
    <returns>
      The specified line.<br/>
      If the specified line does not exist, the return value is a NULL_STRING.<br/>
      A new line begins when a hard-carriage return is encountered.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses MLine(), to extract the first line that is past offset 10 (the 11th character).
      <code language="X#">? MLine(Customer-&gt;Memos, 1, 10)</code>
      This example applies MLine() to a string that has two lines:
      <code language="X#">
        ? MLine(Space(30)+Chr(13)+Space(40), 1)
        // Returns the first line (Space(30))
      </code>
      This example passes <paramref name="nOffset" /> by reference:
      <code language="X#">
        nOffset := 0
        ? MLine(Space(30)+Chr(13)+Space(40), 1, @nOffset)
        &#0009;// Space(30)
        ? nOffset&#0009;&#0009;&#0009;&#0009;// 30
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MemoLine'>MemoLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.MLine3'>MLine3</seealso>
  </mline>
  <mline3>
    <summary>
      Extract a line of text from a string, specifying a required offset argument.
    </summary>

    <param name="cString">The string that contains the line of text.</param>
    <param name="dwLine">The line number to extract.</param>
    <param name="ptrN">
      <paramref name="ptrN" /> must be a DWORD variable that is passed by reference.<br/>
      At the end of the function call, <paramref name="ptrN" /> will contain the offset of the last character of the returned line (cLineString).
    </param>
    <returns>
      The specified line.<br/>
      If the specified line does not exist, the return value is NULL_STRING and <paramref name="ptrN" /> contains a 0.
    </returns>
    <remarks>
      MLine3() is similar to MLine(), except that all three arguments are required and it stores the offset of the last returned character with respect to the beginning of <paramref name="cString" />.  See MLine() for more information.
    </remarks>
    <example>
      This example displays the content and the size of all lines in a character or memo field:
      <code language="X#">
        LOCAL dwOffset AS DWORD
        LOCAL dwLines AS DWORD
        LOCAL i AS DWORD
        dwLines := MemLines(_FIELD-&gt;Mail)
        FOR i := 1 UPTO dwLines
        &#0009;// Extract lines sequentially
        &#0009;? MLine3(_FIELD-&gt;Mail, i, @dwOffset)
        &#0009;? dwOffset&#0009;&#0009;&#0009;// Length of line
        NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MemoLine'>MemoLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.MLine'>MLine</seealso>
  </mline3>
  <mlpos>
    <summary>
      Determine the position of a line in a string.
    </summary>

    <param name="cText">A string.</param>
    <param name="nWidth">
      The length of each line after <paramref name="cText" /> is formatted.
    </param>
    <param name="nLine">The line number in the formatted text, starting from the top at 1.</param>
    <param name="nTabSize">
      The number of characters to insert when the user presses Tab.<br/>
      If <paramref name="nTabSize" /> is not specified, 4 spaces are inserted.
    </param>
    <param name="lWrap">
      The word-wrap flag.<br/>
      The default is TRUE.
    </param>
    <returns>
      The character position of <paramref name="wLine" /> in <paramref name="cString" />.<br/>
      If <paramref name="wLine" /> is greater than the number of lines in <paramref name="cString" />, MLPos() returns the length of <paramref name="cString" />.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses MLPos() to find the position of a specific line, given a line length of 40:
      <code language="X#">
        LOCAL cString AS STRING
        LOCAL wLine AS DWORD
        LOCAL wPosition AS DWORD
        cString = MemoRead("temp.txt")
        nLineLength = 40
        wLine = 5
        wPosition = MLPos(cString, nLineLength, wLine)
        ? Substr(cString, wPosition, 12)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MemoLine'>MemoLine</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemoTran'>MemoTran</seealso>
    <seealso cref='O:XSharp.RT.Functions.MLCount'>MLCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.MLPos2'>MLPos2</seealso>
  </mlpos>
  <mlpos2>
    <summary>
      Determine the position of a line in a string.
    </summary>

    <param name="cString">A string.</param>
    <param name="dwLine">The line number.</param>
    <returns>
      The character position of <paramref name="dwLine" /> in <paramref name="cString" />.<br/>
      If <paramref name="dwLine" /> is greater than the number of lines in <paramref name="cString" />, MLPos2() returns the length of <paramref name="cString" />.
    </returns>
    <remarks>
      MLPos2() is similar to MLPos() except that MLPos2() has only two arguments and those arguments are strongly typed.  See MLPos() for more information.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MLPos'>MLPos</seealso>
  </mlpos2>
  <mod>
    <summary>
      Return the remainder of one number divided by another number.
    </summary>

    <param name="nDividend">The dividend of the division operation.</param>
    <param name="nDivisor">The divisor of the division operation.</param>
    <returns>
      A number representing the remainder of <paramref name="nDividend" /> divided by <paramref name="nDivisor" />.
    </returns>
    <remarks>
      Mod() is not implemented using the X# modulus operator (%).  Note that there are differences between the Mod() function and the modulus operator, which are described in the following table:
      Dividend&#0009;Divisor&#0009;Modulus Operator&#0009;Mod() function&#0009;
      3&#0009; 0&#0009;Error&#0009; 3&#0009;
      3&#0009;-2&#0009; 1&#0009;-1&#0009;
      -3&#0009; 2&#0009;-1&#0009; 1&#0009;
      -3&#0009; 0&#0009;Error&#0009;-3&#0009;
      -1&#0009; 3&#0009;-1&#0009; 2&#0009;
      -2&#0009; 3&#0009;-2&#0009; 1&#0009;
      2&#0009;-3&#0009; 2&#0009;-1&#0009;
      1&#0009;-3&#0009; 1&#0009;-2&#0009;
      <note type="tip">
        In dBASE III PLUS, a 0 divisor returns the dividend for every value of the dividend.  In versions of CA-Clipper prior to Summer '87, a 0 divisor returned 0 for all dividends.  In X#, by contrast, the modulus of any dividend using a 0 divisor causes a runtime error.
      </note>
    </remarks>
    <example>
    </example>
  </mod>
  <month>
    <summary>
      Extract the number of the month from a date.
    </summary>

    <param name="dDate">The date.</param>
    <returns>
      A number from 0 to 12.  Specifying a NULL_DATE returns 0.
    </returns>
    <remarks>
      Month() is a date conversion function that is useful when you require a numeric month value during calculations for such things as periodic reports.
      Month() is a member of a group of functions that return components of a date value as numbers.<br/>
      The group includes Day() and Year() to return the day and year values as numerics.  CMonth() is a related function that allows you to return the name of the month from a date value.
    </remarks>
    <example>
      These examples return the month of the system date:
      <code language="X#">
        ? Today()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 09/01/90
        ? Month(Today())&#0009;&#0009;&#0009;&#0009;// 9
        // Advance by 1 month:
        ? Month(Today()) + 1&#0009;&#0009;&#0009;// 10
      </code>
      This example uses month along with Day() and Year():
      <code language="X#">
        ?"We are", Year(Today()), "years, ",;
        &#0009;&#0009;Month(Today()), "months, and", Day(Today()),;
        &#0009;&#0009;&#0009;"days into our history!"
      </code>
      This example shows the result when a  NULL_DATE is passed:
      <code language="X#">? Month(NULL_DATE)&#0009;&#0009;&#0009;&#0009;// 0</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CMonth'>CMonth</seealso>
    <seealso cref='O:XSharp.RT.Functions.Day'>Day</seealso>
    <seealso cref='O:XSharp.RT.Functions.DoW'>DoW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Year'>Year</seealso>
  </month>
  <mparamcount>
    <summary>
      Return the number of arguments that a method is expecting.
    </summary>

    <param name="symClass">The symbol of the class containing the method to examine.</param>
    <param name="symMethod">The method name, specified without parentheses.</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses MParamCount() to get the number of arguments that the Area method in class Rectangle is expecting.  Furthermore, the example sets up a Geometry class with an IdentifyObject() method that uses MParamCount() to collect information about different objects:
      <code language="X#">
        CLASS Rectangle
        METHOD Area(x, y) CLASS Rectangle
        RETURN x*y
        CLASS Geometry
        METHOD IdentifyObject(symObject, symMethod);
        &#0009;CLASS Geometry
        RETURN MParamCount(symObject, symMethod)
        Function Start()
        &#0009;LOCAL oShapes AS OBJECT
        &#0009;? MParamCount(#Rectangle, #Area)&#0009;&#0009;// 2
        &#0009;oShapes := Geometry{}
        &#0009;? "It is a "+NTrim(oShapes:IdentifyObject;
        &#0009;&#0009;(#Rectangle, #Area))+ " dimensional object"
        &#0009;// It is a 2 dimensional object
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CParamCount'>CParamCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.FParamCount'>FParamCount</seealso>
  </mparamcount>
  <mpostolc>
    <summary>
      Return the line and column position of a character in a formatted string.
    </summary>

    <param name="cText">A string.</param>
    <param name="nWidth">
      The length of each line after <paramref name="cText" /> is formatted.
    </param>
    <param name="nPos">The byte position within the formatted text, counting from 1.</param>
    <param name="nTabSize">
      The number of characters to insert when the user presses Tab.<br/>
      If <paramref name="nTabSize" /> is not specified, 4 spaces are inserted.
    </param>
    <param name="lWrap">
      The word-wrap flag.<br/>
      The default is TRUE.
    </param>
    <returns>
      An array containing the line and column numbers for the character at the specified position.
    </returns>
    <remarks>
      MPosToLC() identifies the formatted line and column that correspond to a particular character position within <paramref name="cText" />.  Note that the line number returned is 1-relative, and the column number is 0-relative.<br/>
      This is compatible with MemoEdit().  <paramref name="nPos" /> is 1-relative, which is compatible with At(), RAt(), and other string functions.
      MPosToLC() is used with MLCToPos() to create search routines or other text processing for MemoEdit().
    </remarks>
    <example>
      This example determines the line and column corresponding to the tenth character of the text string shown, assuming a formatting width of five columns.<br/>
      A formatting width of five would cause each of the first 3 words to be placed on a line by itself.<br/>
      The tenth character of the text is the "s" in "side."<br/>
      The word "side" would be at the leftmost column of the third line of the formatted text, so the return value is {3, 0}:
      <code language="X#">
        cText := "Note the side on which the bread" + "is buttered."
        aLC := MPosToLC(cText, 5, 10)&#0009;// Result: {3, 0}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MLcToPos'>MLCToPos</seealso>
    <seealso cref='O:XSharp.RT.Functions.MLPos'>MLPos</seealso>
  </mpostolc>
  <neterr>
    <summary>
      Detect a concurrency conflict.
    </summary>

    <param name="lNewError">Sets the value returned by NetErr() to either TRUE or FALSE.  Setting NetErr() allows the runtime error handler to control the way certain concurrency control errors are handled.</param>
    <returns>
      TRUE if a concurrency conflict occurs or if programmatically set to TRUE via the <paramref name="lNewError" /> argument; otherwise, FALSE.<br/>
      The initial value is FALSE.
    </returns>
    <remarks>
      NetErr() is a global flag set by certain operations that is used to test for concurrency control conflicts in the following situations:
      Operation Attempted
      &#0009;NetErr() is TRUE&#0009;
      Append a blank record with APPEND BLANK or DBAppend()
      &#0009;If another process has a file lock in place or a record lock of LastRec() + 1 (with, for example, a simultaneous append blank operation)&#0009;
      File open in either shared or exclusive mode (with, for example, USE or DBUseArea())
      &#0009;If another process has exclusive use of the file&#0009;
      File open in exclusive mode (with, for example, USE...EXCLUSIVE or DBUseArea() with <paramref name="lShared" /> set to FALSE)
      &#0009;If another process has the file open, in either shared or exclusive mode&#0009;
      Internally, these situations result in a runtime error, invoking the installed error handler.
      &#0009;The source code for the default error handler, defined in the ERRORSYS.PRG file located in your X# \SAMPLES directory, does not display an error message in these cases, allowing your application to continue.
      NetErr() is generally applied in a program by testing one of these operations.
      &#0009;If the function returns FALSE, you can perform the next operation.<br/>
      Otherwise, you must handle the error either by retrying the operation or by terminating it with a BREAK or RETURN.

    </remarks>
    <example>
      This example demonstrates typical usage of NetErr().<br/>
      If the USE succeeds, the index files are opened and processing continues.<br/>
      If the USE fails, a message is displayed, and control returns to the nearest BEGIN SEQUENCE construct:
      <code language="X#">
        USE customer SHARED NEW
        IF !NetErr()
        &#0009;SET INDEX TO custnum, custorders, custzip
        ELSE
        &#0009;? "File is in use by another"
        ENDIF
      </code>
    </example>
    <seealsocmd>APPEND BLANK</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.Flock'>FLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.RLock'>RLock</seealso>
    <seealsocmd>USE</seealsocmd>
  </neterr>
  <netname>
    <summary>
      Identify the current workstation.
    </summary>
    <returns>
      The workstation ID as a string up to 15 characters in length.<br/>
      If the workstation ID was never set or the application is not operating under Microsoft LAN Manager, it returns a NULL_STRING.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example demonstrates the NetName() result when a workstation is started as a network node with a station identifier of "STATION 1":
      <code language="X#">? NetName()&#0009;&#0009;// Result: STATION 1</code>
      This example demonstrates the NetName() result when a workstation is started as a stand-alone unit:
      <code language="X#">? NetName()&#0009;&#0009;// Result: NULL_STRING</code>
    </example>
  </netname>
  <newindexlock>
    <summary>
      Return and optionally change the setting that determines whether to use the new locking offset of -1 (0xFFFFFFFF) for .NTX files.
    </summary>

    <param name="lNewSetting">
      TRUE uses the new locking offset.  FALSE uses a locking offset of 1 billion bytes.<br/>

      &#0009;The initial default is FALSE.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, NewIndexLock() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      By default, this function sets the index locking offset for the current work area.<br/>
      It can be made to operate on an unselected work area by specifying it within an aliased expression.  Thus, you can set a separate flag for each work area.  You cannot, however, use index files with different locking offsets in the same work area.
      This setting affects only newly created index files.<br/>
      It has no effect on existing files, in which locking offset is determined by information stored in the file's header record.
      Note:<br/>
      This function may not be implemented for RDDs other than DBFNTX.
      Index files created with NewIndexLock(FALSE) in effect have a built-in limitation which limits the size of the database files to 1 GB.<br/>
      If you do not require compatibility with Xbase applications, you can use NewIndexLock(TRUE) to implement a less restrictive locking offset that does not limit the file size in any way.
      Important!<br/>
      If your application must share data with an Xbase product, either simultaneously or at different times, do not set NewIndexLock(TRUE) unless this can also be done in the other applications as well.  Doing so will make your .NTX files incompatible with these products.
    </remarks>
    <example>
      This example illustrates the status of NewIndexLock() after several calls to the function:
      <code language="X#">
        ? NewIndexLock()&#0009;&#0009;// FALSE (initial setting)
        ? NewIndexLock(TRUE)&#0009;// FALSE (previous setting)
        ? NewIndexLock()&#0009;&#0009;// TRUE  (current setting)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
  </newindexlock>
  <newlocks>
    <summary>
      Return the setting that determines whether to use the new locking offset of -1 (0xFFFFFFFF) for .NTX files.
      Note:  NewLocks() is a compatibility function and therefore not recommended.<br/>
      It is superseded by the NewIndexLock() function, which allows you to change and retrieve the setting.  Refer to NewIndexLock() for more information.
    </summary>
    <returns>
      A logical value indicating the current status of NewIndexLock().
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
  </newlocks>
  <nomethod>
    <summary>
      Identify an invalid method call.
    </summary>
    <returns>
      A NULL_SYMBOL is returned if such a method does not exist.
    </returns>
    <remarks>
      You can declare a method called NoMethod() for any class which is executed any time a method is invoked that is not defined for that class.<br/>
      This way you can trap a bad method call before it generates a runtime error.<br/>
      The NoMethod() function can be called from the NoMethod() method to determine the name of the missing method.
    </remarks>
    <example>
      This example shows the use of NoMethod():
      <code language="X#">
        METHOD NoMethod() CLASS MyDataWindow
        &#0009;// This will be called anytime a method that
        &#0009;// is called does not exist for MyDataWindow.
        &#0009;// This FUNCTION CALL displays the name
        &#0009;// of the missing method in the status bar.
        SELF:StatusMessage(Symbol2String(NoMethod()) ;
        &#0009;+ "method not defined", MESSAGEERROR)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IsMethodUsual'>IsMethodUsual</seealso>
  </nomethod>
  <ntocdow>
    <summary>
      Convert the number that identifies a day into the name of the day.
    </summary>

    <param name="dwDayNum">A number from 1 to 7.</param>
    <returns>
      The name of the day that corresponds to <paramref name="dwDayNum" />, where Sunday is 1, Monday is 2, and so on.
    </returns>
    <remarks>
      This function is nation-dependent.
    </remarks>
    <example>
      This example shows how NToCDoW() works in English:
      <code language="X#">
        ? NToCDoW(1)&#0009;&#0009;&#0009;// "Sunday"
        ? NToCDoW(4)&#0009;&#0009;&#0009;&#0009;// "Wednesday"
        ? NToCDoW(7)&#0009;&#0009;&#0009;&#0009;// "Saturday"
        ? NToCDoW(8)&#0009;&#0009;&#0009;&#0009;// NULL_STRING
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CDoW'>CDoW</seealso>
    <seealso cref='O:XSharp.RT.Functions.DoW'>DoW</seealso>
    <seealso cref='O:XSharp.Core.Functions.NToCMonth'>NToCMonth</seealso>
  </ntocdow>
  <ntocmonth>
    <summary>
      Convert the number that identifies a month into the name of the month.
    </summary>

    <param name="dwMonthNum">A number from 1 to 12.</param>
    <returns>
      The name of the month that corresponds to <paramref name="dwMonthNum" />, where January is 1, February is 2, and so on through December, which is 12.
    </returns>
    <remarks>
      This function is nation-dependent.
    </remarks>
    <example>
      This example shows how NToCMonth() works in English:
      <code language="X#">
        ? NToCMonth(1)&#0009;&#0009;&#0009;&#0009;// "January"
        ? NToCMonth(2)&#0009;&#0009;&#0009;&#0009;// "February"
        ? NToCMonth(12)&#0009;&#0009;&#0009;// "December"
        ? NToCMonth(14)&#0009;&#0009;&#0009;// NULL_STRING
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CMonth'>CMonth</seealso>
    <seealso cref='O:XSharp.RT.Functions.Month'>Month</seealso>
    <seealso cref='O:XSharp.Core.Functions.NToCDoW'>NToCDoW</seealso>
  </ntocmonth>
  <ntrim>
    <summary>
      Convert a numeric expression to a left-trimmed string.
    </summary>

    <param name="nNum">The expression to convert to a string.</param>
    <returns>
    </returns>
    <remarks>
      NTrim() returns the same value as LTrim(Str(<paramref name="nNum" />)).  Thus, any conversion rules that apply to the Str() function also apply to the NTrim() function.
    </remarks>
    <example>
      This example compares the output of NTrim() to that of Str():
      <code language="X#">
        ? NTrim(234)&#0009;&#0009;&#0009;// "234"
        ? LTrim(Str(234))&#0009;&#0009;// "234"
        ? Str(234)&#0009;&#0009;&#0009;&#0009;// "       234"
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
  </ntrim>
  <nversion>
    <summary>
      Identify a character set by its nation driver.
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses NVersion() to identify a nation driver:
      <code language="X#">
        ? NVersion()&#0009;&#0009;&#0009;//<br/>
        US ASCII
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
    <seealso cref='O:XSharp.RT.Functions.Version'>Version</seealso>
  </nversion>
  <object2array>
    <summary>
      Convert the values of an object's instance variables to an array.
    </summary>

    <param name="oObject">The object containing the instance variable to convert.</param>
    <returns>
      An array containing the contents of all instance variables of <paramref name="oObject" />.
    </returns>
    <remarks>
      This conversion can offer you additional flexibility in manipulating data and can allow you to utilize powerful array functions, such as AEval() and AScan().<br/>
      The scope throughout the function call is SELF.
    </remarks>
    <example>
      This example uses Object2Array() to store INSTANCE and EXPORT instance variables into an array.<br/>
      It then prints the stored instance variables.  (Note that the password is not stored in the array because it is a protected instance variable.)
      <code language="X#">
        CLASS Person
        &#0009;EXPORT name
        &#0009;INSTANCE grade
        &#0009;PROTECT password
        CONSTRUCTOR(tname, tgrade, tpassword)
        &#0009;name := tname
        &#0009;grade := tgrade
        &#0009;password := tpassword
        END CLASS
        FUNCTION Start()
        &#0009;LOCAL x AS OBJECT
        &#0009;LOCAL a AS ARRAY
        &#0009;LOCAL i AS SHORT
        &#0009;x := Person{"Randal", "A", "123"}
        &#0009;a := Object2Array(x)
        &#0009;// Print them
        &#0009;FOR i := 1 UPTO ALen(a)
        &#0009;&#0009;QOut(a[i])
        &#0009;NEXT
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Randal
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// A
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarGet'>IVarGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.IvarList'>IVarList</seealso>
    <seealso cref='O:XSharp.RT.Functions.IvarListClass'>IVarListClass</seealso>
  </object2array>
  <occurs>
    <summary>
      Return the number of times a substring occurs in a string.
    </summary>

    <param name="cSearch">The substring for which to search.</param>
    <param name="cTarget">The string in which to search.  (To specify an offset, use Occurs3()).</param>
    <returns>
      The number of times that <paramref name="cSearch" /> appears in <paramref name="cTarget" />.
    </returns>
    <remarks>
      Occurs() is case-sensitive and nation-dependent.
    </remarks>
    <example>
      This example shows typical use of Occurs():
      <code language="X#">
        LOCAL cSearch AS STRING
        LOCAL cTarget AS STRING
        cSearch := "any"
        cTarget := "Anything goes anyway anytime."
        ? Occurs(cSearch, cTarget)&#0009;&#0009;// 2
        ? Occurs("any","ANY any")&#0009;&#0009;&#0009;// 1
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.At3'>At3</seealso>
    <seealso cref='O:XSharp.Core.Functions.Instr'>InStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Occurs2'>Occurs2</seealso>
    <seealso cref='O:XSharp.Core.Functions.Occurs3'>Occurs3</seealso>
  </occurs>
  <occurs2>
    <summary>
      Return the number of times a substring occurs in a string.
    </summary>

    <param name="cSearch">The substring for which to search.</param>
    <param name="cTarget">The string in which to search.  (To specify an offset, use Occurs3()).</param>
    <returns>
      The number of times that <paramref name="cSearch" /> appears in <paramref name="cTarget" />.
    </returns>
    <remarks>
      Occurs2() is the same as Occurs().
    </remarks>
    <example>
      This example shows typical use of Occurs():
      <code language="X#">
        LOCAL cSearch AS STRING
        LOCAL cTarget AS STRING
        cSearch := "any"
        cTarget := "Anything goes anyway anytime."
        ? Occurs2(cSearch, cTarget)&#0009;&#0009;// 2
        ? Occurs2("any","ANY any")&#0009;&#0009;// 1
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Occurs'>Occurs</seealso>
    <seealso cref='O:XSharp.Core.Functions.Occurs3'>Occurs3</seealso>
  </occurs2>
  <occurs3>
    <summary>
      Return the number of times a substring occurs in a string, starting at a specified position.
    </summary>

    <param name="cSearch">The substring to search for.</param>
    <param name="cTarget">The string in which to search.</param>
    <param name="dwOffset">
      The position in the string at which to start searching.<br/>
      A value of zero (0) specifies the first byte.
    </param>
    <returns>
      The number of times that <paramref name="cSearch" /> appears in <paramref name="cTarget" />.
    </returns>
    <remarks>
      Occurs3() is the same as Occurs(), except that you can specify an offset that tells where to start searching.  See Occurs() for more information.
    </remarks>
    <example>
      This example show typical use of Occurs3():
      <code language="X#">
        LOCAL cSearch AS STRING
        LOCAL cTarget AS STRING
        cSearch := "any"
        cTarget := "Anything goes anyway anytime."
        ? Occurs3(cSearch,cTarget,18)&#0009;&#0009;// 1
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.At3'>At3</seealso>
    <seealso cref='O:XSharp.Core.Functions.Occurs'>Occurs</seealso>
    <seealso cref='O:XSharp.Core.Functions.Occurs2'>Occurs2</seealso>
  </occurs3>
  <oem2ansi>
    <summary>
      Convert a string of OEM characters to ANSI characters.
    </summary>

    <param name="cOemString">A source string of OEM characters.</param>
    <returns>
      A converted string of ANSI characters.
    </returns>
    <remarks>
      Oem2Ansi() converts the individual characters in the source string to matching characters from the ANSI character set.<br/>
      This may need to be done because certain symbols, such as ß, have different code values in the ANSI and OEM character sets.<br/>
      Therefore, when using Windows to read or display DOS string data or file names, it is often necessary to translate characters from OEM to ANSI.
      Note that most X# for Clipper applications automatically perform an OEM to ANSI conversion when SetAnsi() is FALSE.  Some, however, such as FRead(), that assume they are working with binary data, do not do such a conversion.
    </remarks>
    <example>
      This example uses Oem2Ansi() to convert OEM characters to ANSI characters in order to read a DOS file into Windows:
      <code language="X#">
        SetAnsi(TRUE)
        // no conversion between ANSI and OEM
        Oem2Ansi(FReadLine(ptrFileHandle))
        // do the conversion yourself if needed
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2AnsiA'>Oem2AnsiA</seealso>
    <seealso cref='O:XSharp.RT.Functions.Oem2AnsiBuff'>Oem2AnsiBuff</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </oem2ansi>
  <oem2ansia>
    <summary>
      Convert a string of OEM characters to ANSI characters, changing the contents of the argument as well as the return value.
    </summary>

    <param name="cOemString">A source string of OEM characters.</param>
    <returns>
      A converted string of ANSI characters.
    </returns>
    <remarks>
      Oem2AnsiA() is the same as Oem2Ansi(), except that Oem2AnsiA() also replaces the contents of the original string with OEM characters.
    </remarks>
    <example>
      This example uses Oem2AnsiA() to change the contents of a variable by translating each character from OEM to ANSI:
      <code language="X#">
        LOCAL cString AS STRING
        cString := "ßá"
        Oem2AnsiA(cString)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2OemA'>Ansi2OemA</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
    <seealso cref='O:XSharp.RT.Functions.Oem2AnsiBuff'>Oem2AnsiBuff</seealso>
  </oem2ansia>
  <oem2ansibuff>
    <summary>
      Convert a specified number of OEM characters in a source buffer to a buffer of corresponding, if any, ANSI characters.
    </summary>

    <param name="pszTarget">A pointer to the buffer that will contain the converted string.</param>
    <param name="pszSource">A pointer to the buffer that contains the string to convert.</param>
    <param name="dwCount">The number of characters to convert.</param>
    <returns>
      A pointer to the buffer that contains the converted string.
    </returns>
    <remarks>
      Oem2AnsiBuff() is the same as Oem2Ansi, except that the resulting pointer is stored in the buffer pointed to by <paramref name="pszTarget" />.<br/>
      Also, the <paramref name="dwCount" /> argument lets you specify the number of characters to be converted.
      <note type="tip">
        You are responsible for allocating space for the buffer pointed to by <paramref name="pszTarget" />.<br/>
        Using an unallocated buffer pointer can have adverse results.
      </note>
    </remarks>
    <example>
      This example does a conversion from OEM to ANSI.  Note that the source string is also used as the target string:
      <code language="X#">
        LOCAL cStr := "ßá"
        Oem2AnsiBuff(Ptr(_CAST, cStr),;
        &#0009;&#0009;&#0009;Ptr(_CAST, cStr), sLen(cStr))
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Ansi2OemBuff'>Ansi2OemBuff</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2AnsiA'>Oem2AnsiA</seealso>
  </oem2ansibuff>
  <oledatetimeasdate>
    <summary>
      Change the return values of OLE date values to VO date values.
    </summary>

    <param name="lSet">The new setting. FALSE allows the return values to be instances of the OleDateTime class, TRUE forces all OLE  DateTime values to be VO dates . The default is FALSE</param>
    <returns>
    </returns>
    <remarks>
      An OLE date is actually a DateTime combination, often known as a timestamp in SQL databases. This combination of DateTime can not be stored in a DBF Date field and is not recognised by the Date FieldSpec as being a valid date.
      When an OLE date field is returned it is an instance of the OleDateTime class and the values can be extracted from this. The alternative is to use the OleDateTimeAsDate(TRUE) function which will convert all of the returned dates into the standard VO format.
    </remarks>
    <example>
    </example>
    <seealsocmd>OleDateTime Class</seealsocmd>
  </oledatetimeasdate>
  <ooptree>
    <summary>
      Return a multidimensional array of all object-oriented programming symbols that constitute the class.
    </summary>

    <param name="oObject">The object whose class symbols you want to retrieve.</param>
    <returns>
      Each class occupies an array consisting of the class name, a subarray of instance variables, and a subarray of methods.
    </returns>
    <remarks>
      OOPTree() retrieves the names of ancestors (super classes), instance data, and methods in the class definition tree.
    </remarks>
    <example>
      This example uses OOPTree():
      <code language="X#">
        CLASS Thing_1
        &#0009;EXPORT x1
        CONSTRUCTOR() CLASS Thing_1
        &#0009;x1 := 1
        METHOD Meth_1() CLASS Thing_1
        METHOD Meth_1x() CLASS Thing_1
        CLASS Thing_2 INHERIT Thing_1
        &#0009;EXPORT x2
        METHOD Meth_2 CLASS Thing_2
        METHOD Meth_2x CLASS Thing_2
        CLASS Thing_3 INHERIT Thing_2
        &#0009;EXPORT x3
        METHOD Meth_3 CLASS Thing_3
        METHOD Meth_3x CLASS Thing_3
        Function Start()
        &#0009;LOCAL o AS OBJECT, aTree AS ARRAY
        &#0009;o := Thing_3{}
        &#0009;aTree := OOPTree(o)
      </code>
      The array, aTree, contains the following information:
      <code language="X#">
        /***************************
        Thing-1
        &#0009;&#0009;&#0009;x1
        &#0009;&#0009;&#0009;Meth_1x
        &#0009;&#0009;&#0009;Meth_1
        &#0009;&#0009;&#0009;Init
        Thing-2
        &#0009;&#0009;&#0009;x2
        &#0009;&#0009;&#0009;x1
        &#0009;&#0009;&#0009;Meth_2x
        &#0009;&#0009;&#0009;Meth_2
        &#0009;&#0009;&#0009;Meth_1x
        &#0009;&#0009;&#0009;Meth_1
        &#0009;&#0009;&#0009;Init
        Thing-3
        &#0009;&#0009;&#0009;x2
        &#0009;&#0009;&#0009;x1
        &#0009;&#0009;&#0009;x3
        &#0009;&#0009;&#0009;Meth_3x
        &#0009;&#0009;&#0009;Meth_3
        &#0009;&#0009;&#0009;Meth_2x
        &#0009;&#0009;&#0009;Meth_2
        &#0009;&#0009;&#0009;Meth_1x
        &#0009;&#0009;&#0009;Meth_1
        &#0009;&#0009;&#0009;Init
        ***************************/
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ClassCount'>ClassCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassList'>ClassList</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassName'>ClassName</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTree'>ClassTree</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTreeClass'>ClassTreeClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.OOPTreeClass'>OOPTreeClass</seealso>
  </ooptree>
  <ooptreeclass>
    <summary>
      Return a multidimensional array of all object-oriented programming symbols that constitute the class of an object.
    </summary>

    <param name="symClass">The class name whose class symbols you want to retrieve.</param>
    <returns>
      Each class occupies an array consisting of the class name, a subarray of instance variables, and a subarray of methods.
    </returns>
    <remarks>
      OOPTreeClass() retrieves the names of ancestors (super classes), instance data, and methods in the class definition tree.
    </remarks>
    <example>
      This example uses OOPTreeClass():
      <code language="X#">
        CLASS Thing_1
        &#0009;EXPORT x1
        CONSTRUCTOR() CLASS Thing_1
        &#0009;x1 := 1
        METHOD Meth_1() CLASS Thing_1
        METHOD Meth_1x() CLASS Thing_1
        CLASS Thing_2 INHERIT Thing_1
        &#0009;EXPORT x2
        METHOD Meth_2 CLASS Thing_2
        METHOD Meth_2x CLASS Thing_2
        CLASS Thing_3 INHERIT Thing_2
        &#0009;EXPORT x3
        METHOD Meth_3 CLASS Thing_3
        METHOD Meth_3x CLASS Thing_3
        Function Start()
        &#0009;LOCAL aTree AS ARRAY
        &#0009;aTree := OOPTreeClass(#Thing_3)
      </code>
      The array, aTree, contains the following information:
      <code language="X#">
        /***************************
        Thing-1
        &#0009;&#0009;&#0009;x1
        &#0009;&#0009;&#0009;Meth_1x
        &#0009;&#0009;&#0009;Meth_1
        &#0009;&#0009;&#0009;Init
        Thing-2
        &#0009;&#0009;&#0009;x2
        &#0009;&#0009;&#0009;x1
        &#0009;&#0009;&#0009;Meth_2x
        &#0009;&#0009;&#0009;Meth_2
        &#0009;&#0009;&#0009;Meth_1x
        &#0009;&#0009;&#0009;Meth_1
        &#0009;&#0009;&#0009;Init
        Thing-3
        &#0009;&#0009;&#0009;x2
        &#0009;&#0009;&#0009;x1
        &#0009;&#0009;&#0009;x3
        &#0009;&#0009;&#0009;Meth_3x
        &#0009;&#0009;&#0009;Meth_3
        &#0009;&#0009;&#0009;Meth_2x
        &#0009;&#0009;&#0009;Meth_2
        &#0009;&#0009;&#0009;Meth_1x
        &#0009;&#0009;&#0009;Meth_1
        &#0009;&#0009;&#0009;Init
        ***************************/
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ClassCount'>ClassCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassList'>ClassList</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassName'>ClassName</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTree'>ClassTree</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTreeClass'>ClassTreeClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.OOPTree'>OOPTree</seealso>
  </ooptreeclass>
  <ordbagext>
    <summary>
      Return the default index file extension for a work area as defined by its RDD.
    </summary>
    <returns>
      A string indicating the default index file extension for a work area as defined by its RDD.
    </returns>
    <remarks>
      <note type="tip">
        You can also obtain the default index file extension using DBOrderInfo(DBOI_INDEXEXT).
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </ordbagext>
  <ordbagname>
    <summary>
      Return the index file name of a specific order.
    </summary>

    <param name="uOrder">
      The name of the order whose index file name you want to obtain or a number representing its position in the order list.<br/>
      Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.  Invalid values are ignored.
    </param>
    <returns>
      The name of the index file containing the order.
    </returns>
    <remarks>
      <note type="tip">
        You can also obtain the index file name using DBOrderInfo(DBOI_INDEXNAME, <paramref name="cOrder" />).
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </ordbagname>
  <ordcondset>
    <summary>
      Set the condition and scope for an order.
    </summary>

    <param name="cForCondition">
      A string that specifies the for condition for the order.<br/>
      This string is returned by DBOrderInfo(DBOI_CONDITION, [<paramref name="cIndexFile" />], <paramref name="cOrder" />).
      If you do not need this information, you can specify a NULL_STRING.
    </param>
    <param name="cbForCondition">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/cbfor/*" /><br/>
      >
      This condition (not <paramref name="cForCondition" />) is the one that is actually used to create the order.
      Unlike the while condition and other scoping information, the for condition is stored as part of the index file and is used when updating or rebuilding the order with DBReindex().
      Any limitations on the for condition are determined by the RDD
    </param>

    <param name="lAll">
      A value of TRUE specifies a scope of all records.<br/>
      Use FALSE if you want to indicate other record scoping conditions (that is, <paramref name="nNext" />, <paramref name="nRecord" />, or <paramref name="lRest" />).<br/>
      The default is FALSE.
    </param>
    <param name="cbWhileCondition">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/cbwhile/*" />
    </param>
    <param name="cbEval">
      A code block that is evaluated at intervals specified by <paramref name="nInterval" />.<br/>
      This is useful in producing a status bar or odometer that monitors the ordering progress.<br/>
      The return value of <paramref name="cbEval" /> must be a logical value.<br/>
      If <paramref name="cbEval" /> returns FALSE, indexing halts.<br/>
      The default is NIL.
    </param>
    <param name="nInterval">
      A numeric expression that determines the number of times <paramref name="cbEval" /> is evaluated.<br/>
      This argument offers a performance enhancement by evaluating the condition at intervals instead of for every record processed.<br/>
      To step through every record, you can specify a value of 0.<br/>
      The default is 0.
    </param>
    <param name="nStart">
      The starting record number.<br/>
      To start at the beginning of the file, specify a value of 0.<br/>
      The default is 0.<br/>

      &#0009;You define the scope using one of these three, mutually exclusive arguments (use 0 or FALSE for the others).<br/>
      The default is all records.  Record scoping information is used only to create the order.<br/>
      It is not stored in the index file and not used for index updates and reindexing purposes.
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <param name="lDescend">
      Specifies whether the keyed pairs be sorted in decreasing or increasing order of value.  TRUE results in descending order.  FALSE results in ascending order.<br/>
      The default is FALSE.
    </param>
    <param name="lAdditive">
      Specifies whether open orders should remain open while the new order is being created.  TRUE specifies that they should remain open.  FALSE specifies that all open orders should be closed.<br/>
      The default is FALSE.
    </param>
    <param name="lCurrent">
      Specifies whether only records in the controlling order — and within the current range as specified by OrdSetScope() — will be included in this order.  TRUE specifies that the controlling order and range should be used to limit the scope of the newly created order.  FALSE specifies that all records in the database file are included in the order.<br/>
      The default is FALSE.
    </param>
    <param name="lCustom">
      Specifies whether the new order will be a custom built order (for RDDs that this feature).  TRUE specifies that a custom built order will be created.<br/>
      A custom built order is initially empty, giving you complete control over order maintenance.<br/>
      The system does not automatically add and delete keys from a custom built order.  Instead, you explicitly add and delete keys using OrdKeyAdd() and OrdKeyDel().  FALSE specifies a standard, system-maintained order.<br/>
      The default is FALSE.
    </param>
    <param name="lNoOptimize">
      Specifies whether the FOR condition will be optimized (for RDDs that support this feature).  TRUE optimizes the FOR condition, and FALSE does not.<br/>
      The default is FALSE.
    </param>
    <returns>
    </returns>
    <remarks>
      This function is identical to DBSetOrderCondition(), which you can refer to for more information.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrderCondition'>DBSetOrderCondition</seealso>
  </ordcondset>
  <ordcreate>
    <summary>
      Create or replace an order in an index file.
    </summary>
    <returns>
    </returns>
    <remarks>
      Except for the order of the arguments, this function is identical to DBCreateOrder(), which you can refer to for more information.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
  </ordcreate>
  <orddescend>
    <summary>
      Return and optionally change the descending flag of an order.
    </summary>

    <param name="uOrder">
      The name of the order or a number representing its position in the order list.<br/>
      Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.<br/>
      If omitted or NIL, the controlling order is assumed.<br/>

      &#0009;Specifying an invalid value will raise a runtime error.
    </param>
    <param name="cIndexFile">
      The name of an index file, including an optional drive and directory (no extension should be specified).<br/>
      Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.<br/>

      &#0009;If <paramref name="cIndexFile" /> is not open by the current process, a runtime error is raised.
    </param>
    <param name="lNewDescend">TRUE dynamically turns on the descending flag for the order, resulting in descending order.  FALSE dynamically turns the flag off, resulting in ascending order.</param>
    <returns>
      If <paramref name="lNewDescend" /> is not specified, OrdDescend() returns the current setting.<br/>
      If <paramref name="lNewDescend" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      OrdDescend() changes the ascending/descending flag at runtime only — it does not change the descending flag stored in the actual index file.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      The following example illustrates OrdDescend(), every order can be both ascending and descending.
      <code language="X#">
        USE customer VIA "DBFCDX"
        INDEX ON LastName TAG Last
        INDEX ON FirstName TAG First DESCENDING
        SET ORDER TO TAG Last
        // last was originally created in ascending order
        // Swap it to descending
        OrdDescend(,, TRUE)
        // Last will now be processed in descending order
        SET ORDER TO TAG First
        // First was originally created in descending order
        // Swap it to ascending
        OrdDescend(,, FALSE)
        // First will now be processed in ascending order
      </code>
    </example>
    <seealsocmd>INDEX</seealsocmd>
  </orddescend>
  <orddestroy>
    <summary>
      Remove an order from an open index file.
    </summary>

    <param name="uOrder">
      The name of the order or a number representing its position in the order list.<br/>
      Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.  Invalid values are ignored.
    </param>
    <param name="cIndexFile">
      The name of an index file, including an optional drive and directory (no extension should be specified).<br/>
      Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.<br/>

      &#0009;If <paramref name="cIndexFile" /> is not open by the current process, a runtime error is raised.<br/>
      The default is NULL_STRING.
    </param>
    <returns>
    </returns>
    <remarks>
      This function is identical to DBDeleteOrder(), which you can refer to for more information.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDeleteOrder'>DBDeleteOrder</seealso>
  </orddestroy>
  <ordfor>
    <summary>
      Return the for condition of an order.
    </summary>

    <param name="uOrder">
      The name of the order whose for condition you want to obtain or a number representing its position in the order list.<br/>
      Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.  Invalid values are ignored.
    </param>
    <param name="cIndexFile">
      The name of an index file, including an optional drive and directory (no extension should be specified).<br/>
      Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.<br/>

      &#0009;If <paramref name="cIndexFile" /> is not open by the current process, a runtime error is raised.
    </param>
    <returns>
      A string representing the for condition of the specified order.<br/>
      If the order was not created with a for condition, the return value will be a NULL_STRING.<br/>
      If the RDD does not support the for condition, it can either return a NULL_STRING or cause an error, depending on the RDD.
    </returns>
    <remarks>
      <note type="tip">
        You can also obtain the for condition using of an order DBOrderInfo(DBOI_CONDITION, [<paramref name="cIndexFile" />], <paramref name="cOrder" />).
      </note>
    </remarks>
    <example>
    </example>
  </ordfor>
  <ordisunique>
    <summary>
      Return the status of the unique flag for a given order.
    </summary>

    <param name="uOrder">
      The name of the order or a number representing its position in the order list.<br/>
      Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.<br/>
      If omitted or NIL, the controlling order is assumed.<br/>

      &#0009;Specifying an invalid order will raise a runtime error.
    </param>
    <param name="cIndexFile">
      The name of an index file, including an optional drive and directory (no extension should be specified).<br/>
      Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.<br/>

      &#0009;If <paramref name="cIndexFile" /> is not open by the current process, a runtime error is raised.
    </param>
    <returns>
      The status of the indicated order's unique flag as a logical value.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example shows the return value of OrdIsUnique() using various orders:
      <code language="X#">
        USE customer VIA "DBFCDX"
        INDEX ON LastName TAG Last UNIQUE
        INDEX ON FirstName TAG First
        INDEX ON AGE TO j:\test\tmp\age UNIQUE
        SET ORDER TO last
        ? OrdIsUnique()&#0009;&#0009;&#0009;// Result: TRUE, for last
        ? OrdIsUnique("First")&#0009;&#0009;// Result: FALSE
        ? OrdIsUnique("Age")&#0009;&#0009;// Result: TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.OrdDescend'>OrdDescend</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdFor'>OrdFor</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdKey'>OrdKey</seealso>
  </ordisunique>
  <ordkey>
    <summary>
      Return the key expression of an order.
    </summary>

    <param name="uOrder">
      The name of the order whose key expression you want to obtain or a number representing its position in the order list.<br/>
      Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.  Invalid values are ignored.
    </param>
    <param name="cIndexFile">
      The name of an index file, including an optional drive and directory (no extension should be specified).<br/>
      Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.<br/>

      &#0009;If <paramref name="cIndexFile" /> is not open by the current process, a runtime error is raised.
    </param>
    <returns>
      A string representing the key expression of the specified order.
    </returns>
    <remarks>
      <note type="tip">
        You can also obtain the key expression of an order using DBOrderInfo(DBOI_EXPRESSION, [<paramref name="cIndexFile" />], <paramref name="cOrder" />).
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </ordkey>
  <ordkeyadd>
    <summary>
      Add a key to a custom built order.
    </summary>

    <param name="uOrder">
      The name of the order or a number representing its position in the order list.<br/>
      Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.<br/>
      If omitted or NIL, the controlling order is assumed.<br/>

      &#0009;Specifying an invalid order, such as one that is not custom built, will raise a runtime error.
    </param>
    <param name="cIndexFile">
      The name of an index file, including an optional drive and directory (no extension should be specified).<br/>
      Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.<br/>

      &#0009;If <paramref name="cIndexFile" /> is not open by the current process, a runtime error is raised.
    </param>
    <param name="uKeyValue">
      A specific key value that you want to add for the current record.<br/>
      The data type must match that of the order.<br/>
      If not specified, the order's key expression is evaluated for the current record and added to the order.
    </param>
    <returns>
      TRUE if successful; otherwise FALSE.
      <br/>



      From the standard RDDs only the DBFCDX RDD supports Custom Indexes. This RDD does NOT support the use of the <paramref name="uKeyValue" /> parameter. It always uses the Key Expression to calculate the Key Values to insert.
    </returns>
    <remarks>
      A custom built order is one that is not automatically maintained by the DBFCDX driver.  You can determine if an order is custom built using DBOrderInfo(DBOI_CUSTOM, ...).  When you create such an order, it is initially empty.  You must manually add and delete keys using OrdKeyAdd() and OrdKeyDel().
      OrdKeyAdd() evaluates the key expression (or <paramref name="uKeyValue" />, if specified), then adds the key for the current record to the order.<br/>
      If the order has a for condition, the key will be added only if that condition is met, and then, only if it falls within the current scoping range.
      Note:  RDDs may allow you to add several keys for the same record with consecutive calls to OrdKeyAdd().
      OrdKeyAdd() will fail if:
      &#0009;The record pointer is positioned on an invalid record (i.e., at EOF())
      &#0009;The specified order is not custom built
      &#0009;The specified order does not exist
      &#0009;No order was specified and there is no controlling order
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example creates a custom index and adds every fiftieth record to it:
      <code language="X#">
        USE customer VIA "DBFCDX"
        // Create custom built order that is initially empty
        INDEX ON LastName TO Last CUSTOM
        // Add every 50th record
        FOR n := 1 UPTO RecCount() STEP 50&#0009;
        &#0009;GOTO n
        &#0009;OrdKeyAdd()
        NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.OrdFor'>OrdFor</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyDel'>OrdKeyDel</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdScope'>OrdScope</seealso>
  </ordkeyadd>
  <ordkeycount>
    <summary>
      Return the number of keys in an order.
    </summary>

    <param name="uOrder">
      The name of the order or a number representing its position in the order list.<br/>
      Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.<br/>
      If omitted or NIL, the controlling order is assumed.<br/>

      &#0009;Specifying an invalid order will raise a runtime error.
    </param>
    <param name="cIndexFile">
      The name of an index file, including an optional drive and directory (no extension should be specified).<br/>
      Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.<br/>

      &#0009;If <paramref name="cIndexFile" /> is not open by the current process, a runtime error is raised.
    </param>
    <returns>
    </returns>
    <remarks>
      OrdKeyCount() counts the keys in the specified order and returns the result as a numeric value.<br/>
      If the order is not conditional and no scope has been set for it, OrdKeyCount() is identical to RecCount(), returning the number of records in the database file.  However, for a conditional order, there may be fewer keys than there are records, since some records may not meet the order's for condition or may not fall inside the scope specified by OrdScope() — in counting the keys, OrdKeyCount() respects the currently defined scope and for condition.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      <br/>



      If there is no order in operation, the return value will be 0 and not the value of RecCount().
    </remarks>
    <example>
      This example demonstrates using OrdKeyCount() with various orders.
      <code language="X#">
        USE customer
        // Assume 1000 total records,
        // 500 less than thirty years old, and
        // 895 making less than 50,000
        ? RecCount()&#0009;&#0009;&#0009;&#0009;&#0009;// Result: 1000
        ? OrdKeyCount()&#0009;&#0009;&#0009;// Result: 0
        INDEX ON Age TO Age
        INDEX ON First TO First FOR Age &lt; 30
        INDEX ON Last TO Last FOR Salary &lt; 50000
        // Age is the controlling order
        SET INDEX TO Age, First, Last
        ? RecCount()&#0009;&#0009;&#0009;&#0009;&#0009;// Result: 1000
        ? OrdKeyCount()&#0009;&#0009;&#0009;// Result: 1000
        ? OrdKeyCount("First")&#0009;&#0009;// Result: 500
        ? OrdKeyCount(3)&#0009;&#0009;&#0009;// Result: 895
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyGoto'>OrdKeyGoTo</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyNo'>OrdKeyNo</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdScope'>OrdScope</seealso>
  </ordkeycount>
  <ordkeydel>
    <summary>
      Delete a key from a custom built order.
    </summary>

    <param name="uOrder">
      The name of the order or a number representing its position in the order list.<br/>
      Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.<br/>
      If omitted or NIL, the controlling order is assumed.<br/>

      &#0009;Specifying an invalid order, such as one that is not custom built, will raise a runtime error.
    </param>
    <param name="cIndexFile">
      The name of an index file, including an optional drive and directory (no extension should be specified).<br/>
      Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.<br/>

      &#0009;If <paramref name="cIndexFile" /> is not open by the current process, a runtime error is raised.
    </param>
    <returns>
      TRUE if successful; otherwise FALSE.
    </returns>
    <remarks>
      A custom built order is one that is not automatically maintained by the DBFCDX driver.  You can determine if an order is custom built using DBOrderInfo(DBOI_CUSTOM, ...).  When you create such an order, it is initially empty.  You must manually add and delete keys using OrdKeyAdd() and OrdKeyDel().
      OrdKeyDel() will fail if:
      &#0009;The record pointer is positioned on an invalid record (for example, EOF() returns TRUE or the record pointer is positioned on a record that falls outside the orders' scope or for condition)
      &#0009;The specified order is not custom built
      &#0009;The specified order does not exist
      &#0009;No order was specified and there is no controlling order
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example creates a custom index, adds every fiftieth record to it, and deletes every hundredth record:
      <code language="X#">
        USE customer VIA "DBFCDX"
        // Create custom built order that is initially empty
        INDEX ON LastName TO Last CUSTOM
        // Add every 50th record
        FOR n := 1 UPTO RecCount() STEP 50&#0009;
        &#0009;GOTO n
        &#0009;OrdKeyAdd()
        NEXT
        // Remove every 100th record
        FOR n := 1 UPTO RecCount() STEP 100
        &#0009;GOTO n
        &#0009;OrdKeyDel()
        NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.OrdFor'>OrdFor</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyAdd'>OrdKeyAdd</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdScope'>OrdScope</seealso>
  </ordkeydel>
  <ordkeygoto>
    <summary>
      Move to a record specified by its logical record number in the controlling order.
    </summary>

    <param name="nKeyNo">
      The logical record number.<br/>
      If the value specified does not satisfy the scope or for condition for the order, the record pointer is positioned at the end-of-file.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      OrdKeyGoTo() is the complement to OrdKeyNo().  OrdKeyNo() returns the logical record number (i.e., its position in the controlling order) of the current record, and OrdKeyGoTo() moves the record pointer to the specified logical record.
      Tip:<br/>
      This function can be useful when displaying scroll bars.<br/>
      If the user clicks on a certain position on the scroll bar, you can move to the corresponding record by calling OrdKeyGoTo().
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example shows the difference between physical and logical record number:
      <code language="X#">
        USE customer
        SET INDEX TO first&#0009;&#0009;&#0009;// Make records in first name
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// order
        OrdKeyGoTo(100)&#0009;&#0009;&#0009;&#0009;// Go to the 100th logical record
        ? RECNO()&#0009;&#0009;&#0009;&#0009;&#0009;// Returns the physical record
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// number
        ? OrdKeyNo()&#0009;&#0009;&#0009;&#0009;// Returns 100, the logical
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// record no
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbGoto'>DBGoTo</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyCount'>OrdKeyCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyNo'>OrdKeyNo</seealso>
  </ordkeygoto>
  <ordkeyno>
    <summary>
      Get the logical record number of the current record.
    </summary>

    <param name="uOrder">
      The name of the order or a number representing its position in the order list.<br/>
      Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.<br/>
      If omitted or NIL, the controlling order is assumed.<br/>

      &#0009;Specifying an invalid order will raise a runtime error.
    </param>
    <param name="cIndexFile">
      The name of an index file, including an optional drive and directory (no extension should be specified).<br/>
      Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.<br/>

      &#0009;If <paramref name="cIndexFile" /> is not open by the current process, a runtime error is raised.
    </param>
    <returns>
      The relative position of the current record in the specified order, as a numeric value.  OrdKeyNo() respects the scope and for condition of the order by returning zero if the record pointer is positioned on an invalid record or if EOF() is TRUE.
    </returns>
    <remarks>
      OrdKeyNo() returns the logical record number of a key in an order.<br/>
      This in contrast to the physical record number (returned using the RecNo() function), which is the relative position of the record in the physical database file.
      Tip:<br/>
      This function can be useful for displaying scroll bars and messages such as "Record 9 of 123" when viewing records in a browser.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example shows the difference between physical and logical record number:
      <code language="X#">
        USE customer&#0009;&#0009;&#0009;// Assuming 1000 records
        SET INDEX TO first&#0009;&#0009;// Make records in first order
        ? OrdKeyNo()&#0009;&#0009;&#0009;// Result: 1
        DBSkip(10)
        ? OrdKeyNo()&#0009;&#0009;&#0009;// Result: 11
        ? RECNO()&#0009;&#0009;&#0009;&#0009;// Result: Unknown
        DBGoBottom()
        ? OrdKeyNo()&#0009;&#0009;&#0009;// Result: 1000
        ? RECNO()&#0009;&#0009;&#0009;&#0009;// Result: Unknown
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyCount'>OrdKeyCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyGoto'>OrdKeyGoTo</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdScope'>OrdScope</seealso>
    <seealso cref='O:XSharp.RT.Functions.RecNo'>RecNo</seealso>
  </ordkeyno>
  <ordkeyval>
    <summary>
      Get the key value of the current record from the controlling order.
    </summary>
    <returns>
      The current record's key value.<br/>
      The data type of the return value is the same as the that of the key expression used to create the order.<br/>
      Use ValType() or UsualType() to determine the data type.
      OrdKeyVal() returns NIL if:
      &#0009;The is no controlling order
      &#0009;The record pointer is at the end-of-file (EOF() returns TRUE)
      &#0009;There is no key defined for this record (for example, you have positioned the record pointer to a record that does not meet the order's for condition or that lies outside of its specified scope)
    </returns>
    <remarks>
      The key value is retrieved from the controlling order, not the database file.<br/>
      This makes the retrieval faster because no time is spent reading in the actual record.
      Tip:  OrdKeyVal() is fast, but if you are going to use the value more than once, it is faster to store the result in a local variable.<br/>
      Then use the local variable rather than calling OrdKeyVal() repeatedly for the same record.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example displays the values for all keys in an order without ever reading the individual records into memory:
      <code language="X#">
        FUNCTION DisplayKeys()
        &#0009;LOCAL cKey, cFirst, cLast
      </code>
      &#0009;
      <code language="X#">
        &#0009;USE customer
        &#0009;// Assuming both LastName and FirstName are
        &#0009;// 20 characters
        &#0009;INDEX ON LastName + FirstName TO lastfir
      </code>
      &#0009;
      <code language="X#">
        &#0009;DO WHILE !Customer-&gt;EOF()
        &#0009;&#0009;cKey := Customer-&gt;OrdKeyVal()&#0009;&#0009;// Get key
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// value
        &#0009;&#0009;cLast := LEFT(cKey, 20)&#0009;&#0009;&#0009;// Get last
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// name
        &#0009;&#0009;cFirst := RIGHT(cKey, 20)&#0009;&#0009;// Get first
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// name
        &#0009;&#0009;? cLast, cFirst
        &#0009;&#0009;Customer-&gt;DBSkip()
        &#0009;ENDDO
      </code>
      &#0009;
      <code language="X#">&#0009;CLOSE</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.OrdScope'>OrdScope</seealso>
  </ordkeyval>
  <ordlistadd>
    <summary>
      Open an index file and add specified orders to the order list in a work area.
    </summary>

    <param name="cIndexFile">
      The name of the index file to open, including an optional drive, directory, and extension for each.  See SetDefault() and SetPath() for file searching and creation rules.<br/>
      The default extension is determined by the RDD and can be obtained using DBOrderInfo(DBOI_INDEXEXT).  <br/>

      &#0009;If <paramref name="cIndexFile" /> does not exist, a runtime error is raised.<br/>
      If it exists and is not already open by the current process, this function attempts to open the file in the same mode as the corresponding database file.<br/>
      If access is denied because, for example, another process is using the file and this one is asking for exclusive use, NetErr() is set to TRUE.<br/>
      Otherwise, the file open is successful.<br/>

      &#0009;Concurrency conflicts with index files are rare since they should be used with only one database file.<br/>
      If a concurrency problem arises, it will normally be when you attempt to open the database file.
    </param>
    <param name="cOrder">
      The name of a specific order to add.<br/>
      If not specified, all orders in the index file are added to the order list.  Invalid values are ignored.<br/>

      &#0009;Important!<br/>
      Using this argument can be dangerous, because the orders in <paramref name="cIndexFile" /> that are not added to the order list will not be kept up to date with changes made to the database file.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      Except for its ability to select orders from the index file, it is functionally equivalent to DBSetIndex(), which you can refer to for more information.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
  </ordlistadd>
  <ordlistclear>
    <summary>
      Remove orders from the order list in a work area and close associated index files.
    </summary>
    <returns>
    </returns>
    <remarks>
      Except for the order of the arguments, this function is identical to DBClearIndex(), which you can refer to for more information.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearIndex'>DBClearIndex</seealso>
  </ordlistclear>
  <ordlistrebuild>
    <summary>
      Rebuild all orders in the order list of a work area.
    </summary>
    <returns>
    </returns>
    <remarks>
      This function is identical to DBReindex(), which you can refer to for more information.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbReindex'>DBReindex</seealso>
  </ordlistrebuild>
  <ordname>
    <summary>
      Return the name of an order in the order list of a work area.
    </summary>

    <param name="uOrder">
      The name of the order whose name you want to obtain or a number representing its position in the order list.<br/>
      Using the position is the preferred method since it is the name you want to obtain.  Invalid values are ignored.
    </param>
    <param name="cIndexFile">
      The name of an index file, including an optional drive and directory (no extension should be specified).<br/>
      Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.<br/>

      &#0009;If <paramref name="cIndexFile" /> is not open by the current process, a runtime error is raised.
    </param>
    <returns>
      The name of the specified order.
    </returns>
    <remarks>
      <note type="tip">
        You can also obtain the name of an order using DBOrderInfo(DBOI_NAME, [<paramref name="cIndexFile" />], <paramref name="cOrder" />).
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </ordname>
  <ordnumber>
    <summary>
      Return the position of an order in the order list of a work area.
    </summary>

    <param name="uOrder">
      The name of the order whose position you want to obtain or a number representing its position in the order list.<br/>
      Using the order name is the preferred method since it is the position you want to obtain.  Invalid values are ignored.
    </param>
    <param name="cIndexFile">
      The name of an index file, including an optional drive and directory (no extension should be specified).<br/>
      Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.<br/>

      &#0009;If <paramref name="cIndexFile" /> is not open by the current process, a runtime error is raised.
    </param>
    <returns>
      A numeric value that is equal to the position of the specified order in the order list.
    </returns>
    <remarks>
      <note type="tip">
        You can also obtain the position of an order using DBOrderInfo(DBOI_NUMBER, [<paramref name="cIndexFile" />], <paramref name="cOrder" />).
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </ordnumber>
  <ordscope>
    <summary>
      Set or clear the boundaries for scoping key values in the controlling order.
    </summary>

    <param name="kScope">A number specifying the top (TOPSCOPE) or bottom (BOTTOMSCOPE) boundary.</param>
    <param name="uNewValue">
      The top or bottom range of key values that will be included in the controlling order's current scope.  <paramref name="uNewValue" /> can be an expression that matches the data type of the key expression in the controlling order or a code block that returns the correct data type.<br/>

      &#0009;Omitting <paramref name="uNewValue" /> or specifying it as NIL has the special effect of resetting the specified scope to its original default.<br/>
      The default top range is the first logical record in the controlling order, and the default bottom range is the last logical record.
    </param>
    <returns>
      If <paramref name="uNewValue" /> is not specified, OrdScope() returns and clears the current setting.<br/>
      If <paramref name="uNewValue" /> is specified, the function sets it and the previous setting is returned.
    </returns>
    <remarks>
      The range of values specified using OrdScope() is inclusive.  In other words, the keys included in the scope will be greater than or equal the top boundary and less than or equal to the bottom boundary.
      Note:<br/>
      To return current settings without changing them, call the DBOrderInfo() function, using the DBOI_SCOPETOP and DBOI_SCOPEBOTTOM constants.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This example illustrates using OrdScope() to set various scoping limitations on an order:
      <code language="X#">
        USE friends
        SET INDEX TO age
        // Make 25 the lowest age in range
        OrdScope(TOPSCOPE, 25)
        // Make 30 the highest age in range
        OrdScope(BOTTOMSCOPE, 30)
        LIST Age&#0009;&#0009;&#0009;&#0009;// Shows records with 25
        &#0009;&#0009;&#0009;&#0009;&#0009;// &lt;= Age &lt;= 30
        // Change highest age to 35
        OrdScope(BOTTOMSCOPE, 35)
        LIST Age&#0009;&#0009;&#0009;&#0009;// Shows records with 25
        &#0009;&#0009;&#0009;&#0009;&#0009;// &lt;= Age &lt;= 35
        // Reset top boundary
        OrdScope(TOPSCOPE, NIL)
        LIST Age&#0009;&#0009;&#0009;&#0009;// Shows records with Age &lt;= 35
        // Reset bottom boundary
        OrdScope(BOTTOMSCOPE, NIL)
        LIST Age&#0009;&#0009;&#0009;&#0009;// Shows all records
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealsocmd>SET SCOPE</seealsocmd>
    <seealsocmd>SET SCOPEBOTTOM</seealsocmd>
    <seealsocmd>SET SCOPETOP</seealsocmd>
  </ordscope>
  <ordsetfocus>
    <summary>
      Set the controlling order for a work area.
    </summary>
    <returns>
    </returns>
    <remarks>
      This function is similar to DBSetOrder(), which you can refer to for more information.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrder'>DBSetOrder</seealso>
  </ordsetfocus>
  <ordsetrelation>
    <summary>
      Relate a specified work area to the current work area.
    </summary>

    <param name="uArea">The number of the child work area or the alias of the child work area.</param>
    <param name="cbKey">A code block that expresses the relational expression in executable form.</param>
    <param name="cKey">
      An optional string value that expresses the relational expression in textual form.<br/>
      If <paramref name="cKey" /> is supplied, it must be equivalent to <paramref name="cbKey" />.<br/>
      If <paramref name="cKey" /> is omitted, DBRelation() returns a NULL_STRING for the relation.
    </param>
    <returns>
    </returns>
    <remarks>
      OrdSetRelation() relates the work area specified by <paramref name="nArea" /> or <paramref name="cAlias" /> (the child work area) to the current work area (the parent work area).<br/>
      Any existing relations remain active.
      Relating work areas synchronizes the child work area with the parent work area.<br/>
      This is achieved by automatically repositioning the child work area whenever the parent work area moves to a new record.<br/>
      If there is a controlling order in the child work area, moving the parent work area causes an automatic seek operation in the child work area; the seek key is based on the expression specified by <paramref name="cbKey" /> and/or <paramref name="cKey" />.<br/>
      If the child work area has no controlling order, moving the parent work area causes an automatic "go to" in the child work area; the record number for the "go to" is based on the expression specified by <paramref name="cbKey" /> and/or <paramref name="cKey" />.
      OrdSetRelation() is identical to DBSetRelation() (and the SET RELATION...SCOPED command), but it also sets up a scope on the order in the child work area.<br/>
      This means that whenever you select the child work area, only the records related to the current parent record will be visible.<br/>
      This allows straightforward handling of one-to-many relationships and is particularly useful when displaying the related data in a sub-data window.  Refer to DBSetRelation() for additional information.
    </remarks>
    <example>
      This example displays each invoice with its related line items:
      <code language="X#">
        USE lineitem NEW VIA "DBFCDX"
        SET ORDER TO TAG InvNo
        USE invoice NEW VIA "DBFCDX"
        // Set a selective relation from Invoice into LineItem
        OrdSetRelation("LineItem", {|| Invoice-&gt;InvNo}, "Invoice-&gt;InvNo")
        GO TOP
        DO WHILE !EOF()
        &#0009;? InvNo, InvDate&#0009;&#0009;// Display invoice fields
        &#0009;SELECT LineItem
        &#0009;// Only records for current invoice # are visible
        &#0009;LIST "   ", PartNo, Qty, Price
        &#0009;SELECT Invoice&#0009;&#0009;&#0009;// On to next invoice
        &#0009;SKIP
        ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearRelation'>DBClearRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRelation'>DBRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRSelect'>DBRSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetRelation'>DBSetRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.Found'>Found</seealso>
    <seealsocmd>SET RELATION</seealsocmd>
  </ordsetrelation>
  <ordskipunique>
    <summary>
      Move the record pointer to the next or previous unique key in the controlling order.
    </summary>

    <param name="nDirection">Specifies whether the function will skip to the next or previous key.  Omitting this value or specifying it as 1 skips to the next unique key.  Specifying a negative value skips to the previous key.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      OrdSkipUnique() allows you to make a non-unique order look like a unique order.<br/>
      Each time you use OrdSkipUnique(), you are moved to the next (or previous) unique key, exactly as if you were skipping through a unique order.<br/>
      This function eliminates the problems associated with maintaining a unique order, while providing you with fast access to unique keys.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      This examples uses OrdSkipUnique() to build an array of unique last names beginning with the letter "J:"
      <code language="X#">
        FUNCTION LastUnique()
        &#0009;LOCAL aLast[0]
        &#0009;SET INDEX TO last&#0009;&#0009;&#0009;// Use the last name order
        &#0009;? OrdIsUnique()&#0009;&#0009;&#0009;// Result: FALSE
        &#0009;SET SCOPE TO "J"&#0009;&#0009;&#0009;// Only look at the J's
        &#0009;GO TOP
        &#0009;DO WHILE !EOF()&#0009;&#0009;&#0009;// Add all the unique J
        &#0009;&#0009;AADD(aLast, Last)&#0009;&#0009;// last names to aLast
        &#0009;&#0009;OrdSkipUnique()
        &#0009;ENDDO
        &#0009;SET SCOPE TO&#0009;&#0009;&#0009;// Clear the scope
        &#0009;RETURN aLast&#0009;&#0009;&#0009;// Return array of
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// unique J names
      </code>
    </example>
    <seealsocmd>INDEX</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.OrdIsUnique'>OrdIsUnique</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetUnique'>SetUnique</seealso>
  </ordskipunique>
  <os>
    <summary>
      Return the operating system name.
    </summary>

    <param name="lExtended">This can contain anything.</param>
    <returns>
      OS() returns the name of the disk operating system under which the current workstation is operating, followed by the version number.
    </returns>
    <remarks>
      Without the parameter the functions returns
      &#0009;"Windows 2000...."
      for W2K, WXP and Windows Server 2003 so as to maintain backward compatability.
      With the parameter, the content and type is unimportant, it returns the correct OS name, such as
      &#0009;"Windows XP...."
      or
      &#0009;"Windows 2003 Server...."
      if a more acurate answer is required.
    </remarks>
    <example>
      This example uses OS() to report the operating system the current workstation is running under:
      <code language="X#">? OS()&#0009;&#0009;// DOS 6.00, Windows 3.10</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetEnv'>GetEnv</seealso>
    <seealso cref='O:XSharp.RT.Functions.Version'>Version</seealso>
  </os>
  <pad>
    <summary>
      Pad character, numeric, and date values with fill characters on the right.
    </summary>

    <param name="uValue">A character, numeric, or date value to pad with a fill character.</param>
    <param name="nLength">The length of the string to return.</param>
    <param name="cFillChar">
      The character with which to pad <paramref name="uValue" />.<br/>
      The default is a space character.
    </param>
    <returns>
      A string containing <paramref name="uValue" /> and padded with <paramref name="cFillChar" /> to a total length of <paramref name="nLength" />.<br/>
      If the length of <paramref name="uValue" /> exceeds <paramref name="nLength" />, Pad() truncates cPaddedString to <paramref name="nLength" />.
    </returns>
    <remarks>
      Pad() displays variable-length strings within a fixed-length area.<br/>
      It can be used, for example, to ensure alignment with consecutive ?? commands.<br/>
      Another use is to display text to a fixed-width screen area, ensuring that previous text is completely overwritten.
      Pad() is the inverse of Trim(), which trims trailing space from strings.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.PadC'>PadC</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadL'>PadL</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadR'>PadR</seealso>
    <seealso cref='O:XSharp.Core.Functions.Trim'>Trim</seealso>
  </pad>
  <padc>
    <summary>
      Pad character, numeric, and date values with fill characters on both the right and left.
    </summary>

    <param name="uValue">A character, numeric, or date value to pad with a fill character.</param>
    <param name="nLength">The length of the string to return.</param>
    <param name="cFillChar">
      The character with which to pad <paramref name="uValue" />.<br/>
      The default is a space character.
    </param>
    <returns>
      A string containing <paramref name="uValue" /> and padded with <paramref name="cFillChar" /> to a total length of <paramref name="nLength" />.<br/>
      If the length of <paramref name="uValue" /> exceeds <paramref name="nLength" />, Pad() truncates cPaddedString to <paramref name="nLength" />.
    </returns>
    <remarks>
      PadC is the same as Pad() except that PadC() centers <paramref name="uValue" /> within <paramref name="nLength" /> and adds fill characters on both the left and right sides.<br/>
      For more information, see Pad().
      PadC() is the inverse of AllTrim(), which trims both leading and trailing space from strings.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AllTrim'>AllTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
  </padc>
  <padl>
    <summary>
      Pad character, numeric, and date values with fill characters on the left.
    </summary>

    <param name="uValue">A character, numeric, or date value to pad with a fill character.</param>
    <param name="nLength">The length of the string to return.</param>
    <param name="cFillChar">
      The character with which to pad <paramref name="uValue" />.<br/>
      The default is a space character.
    </param>
    <returns>
      A string containing <paramref name="uValue" /> and padded with <paramref name="cFillChar" /> to a total length of <paramref name="nLength" />.<br/>
      If the length of <paramref name="uValue" /> exceeds <paramref name="nLength" />, Pad() truncates cPaddedString to <paramref name="nLength" />.
    </returns>
    <remarks>
      PadL is the same as Pad() except that PadL() adds fill characters on the left.<br/>
      For more information, see Pad().
      PadL() is the inverse of LTrim(), which trims leading space from strings.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
  </padl>
  <padr>
    <summary>
      Pad character, numeric, and date values with fill characters on the right.
    </summary>

    <param name="uValue">A character, numeric, or date value to pad with a fill character.</param>
    <param name="nLength">The length of the string to return.</param>
    <param name="cFillChar">
      The character with which to pad <paramref name="uValue" />h.<br/>
      The default is a space character.
    </param>
    <returns>
      A string containing <paramref name="uValue" /> and padded with <paramref name="cFillChar" /> to a total length of <paramref name="nLength" />.<br/>
      If the length of <paramref name="uValue" /> exceeds <paramref name="nLength" />, PadR() truncates cPaddedString to <paramref name="nLength" />.
    </returns>
    <remarks>
      PadR() is the same as Pad().<br/>
      For more information, see Pad().
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
  </padr>
  <palettergb>
    <summary>
      Get a particular color from a user-defined palette.
    </summary>

    <param name="bR">The amount of red in the color, as a number from 0 to 255.</param>
    <param name="bG">The amount of green in the color, as a number from 0 to 255.</param>
    <param name="bB">The amount of blue in the color, as a number from 0 to 255.</param>
    <returns>
      The number of the color described, relative to the numbers of the other colors in the palette.<br/>
      If the color described does not have a number in the palette, the next closest number is returned.
    </returns>
    <remarks>
      PaletteRGB() can be used only with devices that support palettes that can be created by Windows programmers.  See the Windows API PaletteRGB() function for more information on palettes.
    </remarks>
    <example>
      This example uses PaletteRGB() to create a brush with a red color.  CreateSolidBrush() and SelectObject() are defined in the Win32 API library:
      <code language="X#">
        hBr :=  CreateSolidBrush(PaletteRGB(255, 0, 0))
        SelectObject(hdc, hBr)
        // Select the created brush into the current DC
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.RGB'>RGB</seealso>
  </palettergb>
  <pause>
    <summary>
      Display a system modal dialog box to pause the current application.
    </summary>
    <returns>
      A handle for the dialog box.
    </returns>
    <remarks>
      Pause() opens a system modal dialog box, displaying the current module, entity, and line number and a "Waiting..." message.<br/>
      The dialog box has two buttons: Ignore and Abort.  Pressing Ignore will continue application execution, and pressing Abort will abort the application.
    </remarks>
    <example>
    </example>
    <seealsocmd>ASSERT</seealsocmd>
  </pause>
  <pcount>
    <summary>
      Return the position of the last argument in the list of arguments passed when a procedure or function is invoked.
    </summary>
    <returns>
      The position of the last argument passed.<br/>
      If no arguments are passed, PCount() returns 0.
    </returns>
    <remarks>
      PCount() is useful for determining whether arguments were left off the end of a list of arguments.<br/>
      Arguments that were left off the middle of a list of arguments cannot be detected by this function.<br/>
      There are, however, other ways to detect theO:
      &#0009;Skipped arguments are uninitialized and, therefore, return NIL when accessed.<br/>
      Therefore, you can determine if a argument did not receive a value by testing it for NIL.<br/>
      To check arguments for NIL, use the IsNil() function.
      &#0009;You can set the default value of skipped arguments with the Default() function.
      &#0009;You can enforce correct data types by using EnforceType() or EnforceNumeric().

    </remarks>
    <example>
      This example is a function that opens a database file and uses PCount() to determine whether the calling procedure passed the name of the database file to open.<br/>
      If the name was not passed, OpenFile() asks for the name:
      <code language="X#">
        FUNCTION OpenFile(cFile)
        &#0009;IF PCount() = 0
        &#0009;&#0009;ACCEPT "File to use: " TO cFile
        &#0009;ENDIF
        &#0009;USE (cFile)
        &#0009;RETURN (NetErr())
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceNumeric'>EnforceNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
  </pcount>
  <pow>
    <summary>
      Raise the first argument to the numeric power specified by the second argument.
    </summary>

    <param name="nBase">The base number.</param>
    <param name="nExponent">The power to which to raise the base number.</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses Pow() to raise 2 to the 3rd power:
      <code language="X#">? Pow(2,3)&#0009;&#0009;&#0009;// 8.00</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Exp'>Exp</seealso>
  </pow>
  <procfile>
    <summary>
      Return the name of the activated module.
    </summary>

    <param name="wActivation">
      Specifies which activation to query.<br/>
      A value of 0 refers to the current activation, a value of 1 refers to the previous activation, and so on.<br/>
      The default value is 0.
    </param>
    <returns>
      For the current activation, ProcFile() returns the name of the current module.<br/>
      For a previous activation, ProcFile() returns the name of the module that invoked the current module.
    </returns>
    <remarks>
      ProcFile() queries the X# activation stack to determine the name of the currently executing module.
      ProcFile() is used with ProcLine() and ProcName() to report debugging information.
      Not every function call sets up the activation stack.<br/>
      A function invokes the activation stack if in it you have used  PRIVATE or PUBLIC variables or issued a SET PROCNAME ON command.
    </remarks>
    <example>
      This example presents a function that you can call during the debugging phase of program development to display the names of the current and previously activated modules:
      <code language="X#">
        // In Module1:
        FUNCTION Start()
        &#0009;MyFunction()
        // In Module2:
        FUNCTION MyFunction() AS VOID
        &#0009;? ProcFile()&#0009;&#0009;&#0009;// Module2 (current)
        &#0009;? ProcFile(1)&#0009;&#0009;&#0009;// Module1 (previous)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ProcLine'>ProcLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.ProcName'>ProcName</seealso>
  </procfile>
  <procline>
    <summary>
      Return the source line number of the last line executed in an activated entity.
    </summary>

    <param name="dwActivation">
      Specifies which activation to query.  0 refers to the current activation, 1 refers to the previous activation, and so on.<br/>
      The default value is 0.
    </param>
    <returns>
      For the current activation, ProcLine() returns the number of the current line.<br/>
      For a previous activation, ProcLine() returns the number of the line that invoked the procedure, function, or method in which ProcLine() is invoked.
      Since X# is not file-based, the line number is relative to the beginning of the activated entity and not relative to the beginning of the source file containing the entity.<br/>
      A line can include a comment, a blank line, a user defined command, or a continued line.<br/>
      A multistatement line is counted as a single line.
    </returns>
    <remarks>
      ProcLine() queries the X# activation stack to determine the last line executed in a currently executing procedure, function, or method.
      ProcLine() is used with ProcFile() and ProcName() to report debugging information.  ProcLine() and ProcName() are controlled by two options on the Application menu:
      1.&#0009;Application Compiler Options displays a list of CA-Clipper compatibility options, one of which is PROCNAME/PROCLINE:
      &#0009;If PROCNAME/PROCLINE is selected, these functions will compile and run accurately.
      &#0009;If PROCNAME/PROCLINE is not selected, these functions will compile and run but may not produce accurate results.
      2.&#0009;Application Properties displays a Debug option.<br/>
      If this option is selected, these functions will produce accurate results even if PROCNAME/PROCLINE is not selected.
      The SET PROCLINE command overrides these compiler options and application settings on an entity level.  See the SET PROCLINE entry for more information.
    </remarks>
    <example>
      This example presents a function that you can call during the debugging phase of program development to display part of the activation stack with line numbers:
      <code language="X#">
        FUNCTION Start()
        &#0009;? "Running"
        &#0009;MyFunction()
        FUNCTION MyFunction() AS VOID
        &#0009;? ProcLine()&#0009;&#0009;// 2 (line in current function)
        &#0009;? ProcLine(1)&#0009;&#0009;// 3 (line in previous function)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ProcFile'>ProcFile</seealso>
    <seealso cref='O:XSharp.Core.Functions.ProcName'>ProcName</seealso>
    <seealsocmd>SET PROCLINE</seealsocmd>
    <seealsocmd>SET PROCNAME</seealsocmd>
  </procline>
  <procname>
    <summary>
      Return the name of an activated entity.
    </summary>

    <param name="wActivation">
      Specifies which activation to query.<br/>
      A value of 0 refers to the current activation, a value of 1 refers to the previous activation, and so on.<br/>
      The default value is 0.
    </param>
    <returns>
      For the current activation, ProcName() returns the name of the current procedure, function, or method.<br/>
      For a previous activation, ProcName() returns the name of the procedure, function, or method that invoked the current entity.
    </returns>
    <remarks>
      ProcName() queries the X# activation stack to determine the name of a currently executing procedure, function, or method.
      ProcName() is used with ProcFile() and ProcLine() to report debugging information.  ProcLine() and ProcName() are controlled by two options on the Application menu:
      1.&#0009;Application Compiler Options displays a list of CA-Clipper compatibility options, one of which is PROCNAME/PROCLINE:
      &#0009;If PROCNAME/PROCLINE is selected, these functions will compile and run accurately.
      &#0009;If PROCNAME/PROCLINE is not selected, these functions will compile and run but may not produce accurate results.
      2.&#0009;Application Properties displays a Debug option.<br/>
      If this option is selected, these functions will produce accurate results even if PROCNAME/PROCLINE is not selected.
      The SET PROCNAME command overrides these compiler options and application settings on an entity level.  See the SET PROCNAME entry for more information.
    </remarks>
    <example>
      This example presents a function that you can call during the debugging phase of program development to display the activation stack with line numbers:
      <code language="X#">
        FUNCTION ListStack() AS VOID
        &#0009;LOCAL wActivation := 1 AS DWORD
      </code>
      &#0009;
      <code language="X#">
        &#0009;DO WHILE "" != ProcName(wActivation)
        &#0009;&#0009;? "Called froO:", ProcName(wActivation),;
        &#0009;&#0009;&#0009;"(" + NTrim(ProcLine(wActivation))+ + ")"
        &#0009;&#0009;++wActivation
        &#0009;ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ProcFile'>ProcFile</seealso>
    <seealso cref='O:XSharp.Core.Functions.ProcLine'>ProcLine</seealso>
    <seealsocmd>SET PROCLINE</seealsocmd>
    <seealsocmd>SET PROCNAME</seealsocmd>
  </procname>
  <proper>
    <summary>
      Change the first character of each word to uppercase
    </summary>

    <param name="cText">A string of text.</param>
    <returns>
      <paramref name="cText" /> with uppercase letters at the beginning of each word.
    </returns>
    <remarks>
      Proper() is nation-dependent.
    </remarks>
    <example>
      This example uses Proper() to capitalize a person's name:
      <code language="X#">
        LOCAL cName AS STRING
        cName := "terry a. brown"
        ? Proper(cName)&#0009;&#0009;&#0009;// Terry A. Brown
        ? cName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// terry a. brown
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ProperA'>ProperA</seealso>
  </proper>
  <propera>
    <summary>
      Capitalize a proper name correctly, changing the contents of the argument as well as the return value.
    </summary>

    <param name="cName">A proper name.</param>
    <returns>
      <paramref name="cName" /> with uppercase letters at the beginning of each word.
    </returns>
    <remarks>
      ProperA() is the same as Proper(), except that ProperA() changes the original string as well.
      <note type="tip">
        You may change more than one variable at the same time (see example below).
      </note>
    </remarks>
    <example>
      This example uses ProperA() to capitalize a person's name.  Compare the results to the results in the Proper example():
      <code language="X#">
        LOCAL cName AS STRING
        cName : = "terry a. brown"
        ? ProperA(cName)&#0009;&#0009;&#0009;// Terry A. Brown
        ? cName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Terry A. Brown
      </code>
      This example shows how more than one variable may be changed at the same time:
      <code language="X#">
        a:= "i change"
        b:= a
        ProperA(b)
        ? b &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// "I Change"
        ? a &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// "I Change"
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Proper'>Proper</seealso>
  </propera>
  <psz2string>
    <summary>
      Convert a null-terminated string to a strongly typed string.
    </summary>

    <param name="pszString">A null-terminated string.</param>
    <returns>
    </returns>
    <remarks>
      Psz2String() can be used to do any necessary conversions before calling functions that expect a strongly typed string in their argument list.
    </remarks>
    <example>
      This example uses Psz2String() to convert a null-terminated string to a strongly typed string:
      <code language="X#">
        LOCAL cMyBuffer AS STRING
        LOCAL pszString AS PSZ
        pszString := String2Psz("zero terminated")
        cMyBuffer := Psz2String(pszString)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Mem2String'>Mem2String</seealso>
    <seealso cref='O:XSharp.RT.Functions.Psz2Usual'>Psz2Usual</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszAlloc'>PszAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszLen'>PszLen</seealso>
  </psz2string>
  <psz2usual>
    <summary>
      Convert a PSZ to a USUAL with a PSZ tag.
    </summary>

    <param name="pszString">The PSZ to convert.</param>
    <returns>
      <paramref name="pszString" /> converted to a USUAL which maintains its PSZ tag.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses Psz2Usual() to convert a PSZ to a USUAL with a PSZ tag:
      <code language="X#">
        LOCAL uMyBuffer AS USUAL
        LOCAL pszString AS PSZ
        pszString := String2Psz("zero terminated")
        uMyBuffer := Psz2Usual(pszString)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Mem2String'>Mem2String</seealso>
    <seealso cref='O:XSharp.RT.Functions.Psz2String'>Psz2String</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszAlloc'>PszAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszLen'>PszLen</seealso>
  </psz2usual>
  <pszalloc>
    <summary>
      Copy a buffer pointed to by a PSZ to a newly allocated block of memory and return a new pointer to that memory.
    </summary>

    <param name="pszString">A null-terminated string.</param>
    <returns>
    </returns>
    <remarks>
      The newly allocated string is a static object, which implies that the garbage collector does not move the string.
    </remarks>
    <example>
      This example displays the storage addresses of two variables:
      <code language="X#">
        LOCAL pszString AS PSZ
        LOCAL pszOrigString AS PSZ
        pszOrigString := "Cavo tree"
        pszString := PszAlloc(pszOrigString)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemAlloc'>MemAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemFree'>MemFree</seealso>
    <seealso cref='O:XSharp.RT.Functions.Psz2String'>Psz2String</seealso>
    <seealso cref='O:XSharp.RT.Functions.Psz2Usual'>Psz2Usual</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszLen'>PszLen</seealso>
    <seealso cref='O:XSharp.RT.Functions.StringAlloc'>StringAlloc</seealso>
  </pszalloc>
  <pszlen>
    <summary>
      Return the length of a PSZ.
    </summary>

    <param name="pszString">A null-terminated string.</param>
    <returns>
      The length of <paramref name="pszString" />.<br/>
      The null-terminating character is not counted.
    </returns>
    <remarks>
      PszLen() is a typed version of Len().
    </remarks>
    <example>
      This example uses PszLen() to determine the length of a null-terminated string:
      <code language="X#">
        LOCAL pszString AS PSZ
        pszString := PszAlloc("CAVO2x tree")
        ? PszLen(pszString)&#0009;&#0009;&#0009;&#0009;&#0009;// 11
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.RT.Functions.Psz2String'>Psz2String</seealso>
    <seealso cref='O:XSharp.RT.Functions.Psz2Usual'>Psz2Usual</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszAlloc'>PszAlloc</seealso>
    <seealso cref='O:XSharp.Core.Functions.SLen'>SLen</seealso>
  </pszlen>
  <ptrlen>
    <summary>
      Determine the number of bytes that can be read at a given pointer.
    </summary>

    <param name="ptrRead">The pointer to examine.</param>
    <returns>
      The number of bytes that can be read, starting from the location pointed to by <paramref name="ptrRead" />.<br/>
      If <paramref name="ptrRead" /> is an invalid pointer, a value of 0 is returned.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example illustrates PtrLen():
      <code language="X#">
        LOCAL ptrFunc AS PTR
        ptrFunc := @ MyFunc()
        ? PtrLen(ptrFunc)
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.PtrLenWrite'>PtrLenWrite</seealso>
  </ptrlen>
  <ptrlenwrite>
    <summary>
      Determine the number of bytes that can be written at a given pointer.
    </summary>

    <param name="ptrWrite">The pointer to examine.</param>
    <returns>
      The number of bytes that can be written, starting from the location pointed to by <paramref name="ptrRead" />.<br/>
      If <paramref name="ptrRead" /> is an invalid pointer or a write-protected pointer, a value of 0 is returned.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses PtrLen() as an argument to HexDump():
      <code language="X#">HexDump(ptrBuff, PtrLen(ptrBuff) </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.PtrLen'>PtrLen</seealso>
  </ptrlenwrite>
  <qout>
    <summary>
      Display the results of one or more expressions in the terminal window to the console.
    </summary>

    <param name="uValueList">
      A comma-separated list of expressions of any data type to display to the console.<br/>
      If QOut() is specified without arguments, a carriage return/linefeed pair is displayed.
    </param>
    <returns>
    </returns>
    <remarks>
      QOut() is a console function.<br/>
      It is the functional primitive that creates the ? command.  Like the ? command, it displays the results of one or more expressions to the console.  QOut() outputs carriage return and linefeed characters before displaying the results of <paramref name="uValueList" />.
      When QOut() displays to the console, Row() and Col() are updated.<br/>
      If SetPrinter() is TRUE, PRow() and PCol() are updated instead.<br/>
      If <paramref name="uValueList" /> is specified, QOut() displays a space between the results of each expression.
      You can use QOut() for console display within an expression.<br/>
      This is particularly useful for blocks, iteration functions such as AEval() and DBEval(), and in a list of statements in the output pattern of a command definition.
    </remarks>
    <example>
      This example displays the values of 3 expressions that are separated by commas:
      <code language="X#">
        QOut("Hello", 20, TODAY())
        // Hello     20        12/17/98
      </code>
      This example uses QOut() with AEval() to list the contents of a literal array to the console:
      <code language="X#">
        LOCAL aElements := {1, 2, 3, 4, 5}
        AEval(aElements, {|element| QOut(element)})
      </code>
    </example>
    <seealsocmd>?</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.QQOut'>QQOut</seealso>

  </qout>
  <qqout>
    <summary>
      Display the results of one or more expressions in the terminal window to the console.
    </summary>

    <param name="uValueList">
      A comma-separated list of expressions of any data type to display to the console.<br/>
      If QQOut() is specified without arguments, nothing displays.
    </param>
    <returns>
    </returns>
    <remarks>
      QQOut() is the same as QOut() except that it creates the ?? command and displays the results of <paramref name="uValueList" /> at the current Row() and Col() position.<br/>
      For more information, see QOut().
    </remarks>
    <example>
      This example displays the values of 3 expressions that are separated by commas:
      <code language="X#">
        QQOut("Hello", 20, TODAY())
        // Hello     20        12/17/2006
      </code>
      This example uses QQOut() with AEval() to list the contents of a literal array to the console:
      <code language="X#">
        LOCAL aElements := {1, 2, 3, 4, 5}
        AEval(aElements, {|element| QQOut(element)})
      </code>
    </example>
    <seealsocmd>??</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.QOut'>QOut</seealso>
  </qqout>
  <queryrtregint>
    <summary>
      Retrieve a numeric value from the Registry.
    </summary>

    <param name="cSubkey">The subkey under which you want to search for a numeric value.</param>
    <param name="cKey">The key under which you want to search for a numeric value.</param>
    <returns>
      <paramref name="dwValue" /> if the entry <paramref name="cKey" /> = <paramref name="dwValue" /> exists; otherwise, zero.
    </returns>
    <remarks>
      QueryRTRegInt() searches within the Registry under the following key:
      HKEY_CURRENT_USER
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      Or:
      HKEY_LOCAL_MACHINE
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      QueryRTRegInt() tries to read from the HKEY_CURRENT_USER first. When the key is not found under HKEY_CURRENT_USER then it tries to read from HKEY_LOCAL_MACHINE
    </remarks>
    <example>
      This example uses QueryRTRegInt() to obtain the value associated with the LOCK_RETRIES Registry entry under the subkey SSA.<br/>
      The resulting value is used in a DO WHILE loop, determining how many times the RLock() operation is attempted:
      <code language="X#">
        nRetries := QueryRTRegInt("SSA", "LOCK_RETRIES")
        DO WHILE nRetries &gt; 0
        &#0009;IF RLock()
        &#0009;&#0009;EXIT
        &#0009;ENDIF
        &#0009;nRetries--
        ENDDO
        IF nRetries = 0
        &#0009;// Error message
        ENDIF
        ...
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegString'>QueryRTRegString</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegInt'>SetRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegString'>SetRTRegString</seealso>
  </queryrtregint>
  <queryrtregstring>
    <summary>
      Retrieve a string value from the Registry.
    </summary>

    <param name="cSubkey">The subkey under which you want to search for a string value.</param>
    <param name="cKey">The key under which you want to search for a string value.</param>
    <returns>
      <paramref name="cValue" /> if the entry <paramref name="cKey" /> = <paramref name="cValue" /> exists; otherwise, zero.
    </returns>
    <remarks>
      QueryRTRegString() searches within the Registry under following key:
      HKEY_CURRENT_USER
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      Or:
      HKEY_LOCAL_MACHINE
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      QueryRTRegInt() tries to read from the HKEY_CURRENT_USER first. When the key is not found under HKEY_CURRENT_USER then it tries to read from HKEY_LOCAL_MACHINE
    </remarks>
    <example>
      This example uses QueryRTRegString() to obtain the value associated with the APP_DIR Registry entry under the subkey SSA.<br/>
      The resulting directory name is appended to a database file name before the file is opened:
      <code language="X#">
        cDbf:=QueryRTRegString("SSA","APP_DIR") + "test.dbf"
        USE (cDbf)
        ...
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegInt'>QueryRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegInt'>SetRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegString'>SetRTRegString</seealso>
  </queryrtregstring>
  <rand>
    <summary>
      Return a random number between 0 and 1.
    </summary>

    <param name="nSeed">
      An optional start value.<br/>
      This is the point at which the random number generator is initialized.  Subsequent random numbers are then influenced by <paramref name="nSeed" />.<br/>

      &#0009;If you first call Rand() without <paramref name="nSeed" />, it starts as though 100001 were specified.<br/>
      If you call the function with <paramref name="nSeed" /> as 100001, it allows you to restart the generator.<br/>
      Then, if you call the function several times without <paramref name="nSeed" />, it returns the "standard sequence" of numbers.<br/>

      &#0009;If <paramref name="nSeed" /> is less than or equal to 0, the system time is brought into the process.
    </param>
    <returns>
    </returns>
    <remarks>
      Rand() allows you to generate pseudo-random numbers.  Multiple calls to Rand() always return the same random number sequence, provided that they have the same start value (<paramref name="nSeed" />) on the first call and that any subsequent calls do not specify <paramref name="nSeed" />.
    </remarks>
    <example>
      This example uses Rand() to generate the same sequence whenever it runs:
      <code language="X#">
        // Initialize to default starting seed
        ? Rand(100001.0)
        ? Rand()&#0009;&#0009;&#0009;// Known sequence (no parameter passed)
        ? Rand()&#0009;&#0009;&#0009;// Known sequence (no parameter passed)
      </code>
      This example generates the same start value as the previous example but subsequent calls accept a seed value which is also influenced by the system time:
      <code language="X#">
        ? Rand(100001.0)
        ? Rand(0.0)&#0009;&#0009;// Depends on exact time of day
        ? Rand(0.0)&#0009;&#0009;// Time-dependent
      </code>
      This example generates a sequence of random numbers and then reinitializes to the same seed to reproduce the same numbers:
      <code language="X#">
        ? Rand(100.0)&#0009;// Non-default seed value
        ? Rand()&#0009;&#0009;&#0009;// Known sequence
        ? Rand()
        ? Rand(100.0)&#0009;// Regenerate same sequence again
        ? Rand()
        ? Rand()
      </code>
      This example multiplies the result by 100 to increase the range of returned values:
      <code language="X#">? Rand()*100</code>
    </example>
  </rand>
  <rat>
    <summary>
      Return the position of the last occurrence of a substring within a string.
    </summary>

    <param name="cSearch">The substring for which to search.</param>
    <param name="cTarget">The string in which to search.  (To specify an offset, use RAt3()).</param>
    <returns>
      The position of <paramref name="cSearch" /> within <paramref name="cTarget" />.<br/>
      If <paramref name="cSearch" /> is not found, RAt() returns 0.
    </returns>
    <remarks>
      RAt() is like At(), which returns the position of the first occurrence of a substring within another string.<br/>
      If you only need to know whether a substring exists within another string, use the InStr() function or the $ operator.
      Both the RAt() and At() functions are used with Substr(), Left(), and Right() to extract substrings.
    </remarks>
    <example>
      This example uses RAt() to create a function, FilePath(), that extracts the path from a file specification.<br/>
      If the path is unspecified, FilePath() returns a NULL_STRING:
      <code language="X#">
        ? FilePath("c:\dbf\sales.dbf")&#0009;&#0009;// c:\dbf\
        FUNCTION FilePath(cFile AS STRING)
        &#0009;LOCAL nPos AS DWORD
        &#0009;LOCAL cFilePath AS STRING
        &#0009;IF (nPos := RAt("\", cFile)) != 0
        &#0009;&#0009;cFilePath := Substr(cFile, 1, nPos)
        &#0009;ELSE
        &#0009;&#0009;cFilePath := NULL_STRING
        &#0009;ENDIF
        &#0009;RETURN cFilePath
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.Instr'>InStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt2'>RAt2</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt3'>RAt3</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAtLine'>RAtLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.RATLine2'>RAtLine2</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </rat>
  <rat2>
    <summary>
      Return the position of the last occurrence of a substring within a string.
    </summary>

    <param name="cSearch">The substring for which to search.</param>
    <param name="cTarget">The string in which to search.  (To specify an offset, use RAt3()).</param>
    <returns>
      The position of <paramref name="cSearch" /> within <paramref name="cTarget" />.<br/>
      If <paramref name="cSearch" /> is not found, RAt2() returns 0.
    </returns>
    <remarks>
      RAt2() is the same as RAt() except that RAt2() returns WORD.  See RAt() for more information.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt3'>RAt3</seealso>
  </rat2>
  <rat3>
    <summary>
      Return the position of the last occurrence of a substring within a string.
    </summary>

    <param name="cSearch">The substring for which to search.</param>
    <param name="cTarget">The string in which to search.</param>
    <param name="dwOffSet">
      The position in the string at which to start searching.<br/>
      A value of zero (0) specifies the first byte.
    </param>
    <returns>
      The position of <paramref name="cSearch" /> within <paramref name="cTarget" />.<br/>
      If <paramref name="cSearch" /> is not found, RAt3() returns 0.
    </returns>
    <remarks>
      RAt3() is the same as RAt(), except that you can specify an offset that tells where to start searching.  See RAt() for more information.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt2'>RAt2</seealso>
  </rat3>
  <ratline>
    <summary>
      Return the line number of the last occurrence of a substring within a multiline string.
    </summary>

    <param name="cSearch">The substring for which to search.</param>
    <param name="cTarget">The string in which to search.</param>
    <returns>
      The position of the last occurrence of <paramref name="cSearch" /> within <paramref name="cTarget" />.<br/>
      If <paramref name="cSearch" /> is not found, RAtLine() returns 0.
    </returns>
    <remarks>
      RAtLine() returns the position of the last occurrence of a substring by searching the target string from the right.
    </remarks>
    <example>
      This example uses RAtLine() to indicate that the last occurrence of  "line" is on the third line:
      <code language="X#">
        LOCAL cBigString AS STRING
        cBigString := "This is the first line" + ;
        &#0009;&#0009;_Chr(K_RETURN) + "This is the second line" + ;
        &#0009;&#0009;_Chr(K_RETURN) + "This is the third line"
        ? RAtLine("line", cBigString)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 3
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt2'>RAt2</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt3'>RAt3</seealso>
    <seealso cref='O:XSharp.Core.Functions.RATLine2'>RAtLine2</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrTran'>StrTran</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </ratline>
  <ratline2>
    <summary>
      Return the line number of the last occurrence of a substring within a multiline string.
    </summary>

    <param name="cSearch">The substring for which to search.</param>
    <param name="cTarget">The string in which to search.</param>
    <returns>
      The position of the last occurrence of <paramref name="cSearch" /> within <paramref name="cTarget" />.<br/>
      If <paramref name="cSearch" /> is not found, RAtLine2() returns 0.
    </returns>
    <remarks>
      RAtLine2() is the same as RAtLine() except that RAtLine() returns WORD.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.RAtLine'>RAtLine</seealso>
  </ratline2>
  <rddcount>
    <summary>
      Get the number of currently loaded RDDs.
    </summary>

    <param name="kRDDType">
      The types of RDDs to count.<br/>
      The types are<br/>

      &#0009;Constant&#0009;Description<br/>

      &#0009;RDT_FULL&#0009;Fully implemented RDDs<br/>

      &#0009;RDT_TRANSFER&#0009;Transfer RDDs<br/>

      &#0009;RDT_HIDDEN&#0009;Specific RDDs<br/>

      &#0009;If <paramref name="kRDDType" /> is not specified, RDT_FULL + RDT_TRANSFER is assumed.
    </param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      The following example opens up two files via the DBFNTX driver and another file via the DBFMDX drivers.<br/>
      It then counts and lists all the RDDs in use:
      <code language="X#">
        PROCEDURE Start()
        &#0009;LOCAL aRDD &#0009;AS ARRAY
        &#0009;LOCAL wRDDs&#0009;AS SHORTINT
        &#0009;LOCAL i &#0009;&#0009;AS SHORTINT
        &#0009;USE customer NEW
        &#0009;USE address NEW
        &#0009;USE memos VIA DBFMDX NEW
        &#0009;wRDDs:= ;&#0009;RDDCount(RDT_FULL+RDT_TRANSFER+RDT_HIDDEN)
        &#0009;aRDD := ;&#0009;RDDList(RDT_FULL+RDT_TRANSFER+RDT_HIDDEN)
        &#0009;FOR i := 1 UPTO wRDDs
        &#0009;&#0009;QOut(aRDD[i])
        &#0009;NEXT
        &#0009;RETURN
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.RddList'>RDDList</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddName'>RDDName</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddList'>VODBRDDLIST</seealso>
  </rddcount>
  <rddinfo>
    <summary>
      Return and optionally change settings controlled directly by the RDD.
    </summary>

    <param name="kInfoType">
      Specifies the setting.<br/>
      <include file="RTComments.xml" path="Comments/RddInfoParam/*"  />
    </param>
    <param name="uNewSetting">
      If specified, this parameter is used to change the value of a setting.<br/>
      The data type (and whether <paramref name="uNewSetting" /> can be specified), depends on the <paramref name="kInfoType" /> constant and is documented in the Constants section below.<br/>
    </param>
    <remarks>
      <include file="RTComments.xml" path="Comments/RddInfoRemarks/*"  />
    </remarks>
    <returns>
      If <paramref name="uNewSetting" /> is not specified, RDDInfo() returns the current setting.<br/>
      If <paramref name="uNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRecordInfo'>DBRecordInfo</seealso>
  </rddinfo>
  <rddlist>
    <summary>
      Get a list of RDDs in use.
    </summary>

    <param name="kRDDType">
      The types of RDDs to include in the list.<br/>
      The types are:<br/>

      &#0009;Constant&#0009;Description<br/>

      &#0009;RDT_FULL&#0009;Fully implemented RDDs<br/>

      &#0009;RDT_TRANSFER&#0009;Transfer RDDs<br/>

      &#0009;RDT_HIDDEN&#0009;Specific RDDs<br/>

      &#0009;If <paramref name="kRDDType" /> is not specified, RDT_FULL + RDT_TRANSFER is assumed.
    </param>
    <returns>
      An array with the names of currently loaded RDDs.
    </returns>
    <remarks>
    </remarks>
    <example>
      The following example opens up two files via the default of DBFNTX and another file via the DBFMDX drivers.<br/>
      It then counts and lists all the RDDs in use:
      <code language="X#">
        PROCEDURE Start()
        &#0009;LOCAL aRDD &#0009;AS ARRAY
        &#0009;LOCAL wRDDs&#0009;AS SHORTINT
        &#0009;LOCAL i &#0009;&#0009;AS SHORTINT
        &#0009;USE customer NEW
        &#0009;USE address NEW
        &#0009;USE memos VIA DBFMDX NEW
        &#0009;wRDDs:= ;&#0009;RDDCount(RDT_FULL+RDT_TRANSFER+RDT_HIDDEN)
        &#0009;aRDD := ;&#0009;RDDList(RDT_FULL+RDT_TRANSFER+RDT_HIDDEN)
        &#0009;FOR i := 1 UPTO wRDDs
        &#0009;&#0009;QOut(aRDD[i])
        &#0009;NEXT
        &#0009;RETURN
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.RddCount'>RDDCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddName'>RDDName</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddList'>VODBRDDLIST</seealso>
  </rddlist>
  <rddname>
    <summary>
      Return an RDD name.
    </summary>
    <returns>
    </returns>
    <remarks>
      By default, this function returns the name of the RDD in the currently selected work area.<br/>
      It can be made to operate on an unselected work area by specifying it within an aliased expression.
      The default RDD can be set by RDDSetDefault().
    </remarks>
    <example>
      The following example checks the default RDD to report the default extension for the index files:
      <code language="X#">
        IF RDDName() == "DBFMDX"
        &#0009;QOut(".MDX extension")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDriver'>DBDriver</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddList'>RDDList</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddName'>VODBRDDName</seealso>
  </rddname>
  <rddsetdefault>
    <summary>
      Return and optionally change the default RDD for the application.
    </summary>

    <param name="cNewSetting">
      The name of the RDD that will be used to activate and manage applications when no RDD is explicitly specified.<br/>
      If this RDD is not available to the application, the call has no effect.<br/>
      To return the current default RDD, specify NULL_STRING.
    </param>
    <returns>
      If <paramref name="cNewSetting" /> is specified as a NULL_STRING, RDDSetDefault() returns the current default RDD.<br/>
      If <paramref name="cNewSetting" /> is specified, the previous default RDD is returned.
    </returns>
    <remarks>
      Unless established with a call to RDDSetDefault() (or some other function that explicitly sets the default), the name of the default RDD is undetermined.
      This function replaces the DBSetDriver() function.<br/>
      To return the default RDD without changing it, use DBDriver().
    </remarks>
    <example>
      The following example checks the default RDD, then sets a different one if necessary:
      <code language="X#">
        IF RDDSetDefault("") == "DBFMDX"
        &#0009;RDDSetDefault("DBFNTX")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDriver'>DBDriver</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddList'>RDDList</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddSetDefault'>VODBRDDSetDefault</seealso>
  </rddsetdefault>
  <real42bin>
    <summary>
      Convert a Real4 value to a string containing a 32-bit floating point number.
    </summary>

    <param name="r4Value">The value to convert.</param>
    <returns>
    </returns>
    <remarks>
      Real42Bin() is a conversion function that converts a Real4 data type into a 4-byte string.  Typical applications include reading foreign file types in their native format and then saving, reading, decrypting, and transmitting data in their compressed binary form instead of in strings.<br/>
      Its inverse is Bin2Real4().
    </remarks>
    <example>
      Instead of saving numeric data as strings, this example writes them in a binary format in order to save disk space and possible transmission times:
      <code language="X#">
        FUNCTION Compressed() AS LOGIC
        &#0009;LOCAL nh
        &#0009;LOCAL lSuccess := FALSE AS LOGIC
        &#0009;nh := FOpen2("data.bin", FO_READWRITE)
        &#0009;// Assumes that file debug.bin already exists
        &#0009;IF nh != F_ERROR
        &#0009;&#0009;FWrite3(nh, Real42Bin(123456.789), 4)
        &#0009;&#0009;FWrite3(nh, Real42Bin(12 ^ 6), 4)
        &#0009;&#0009;FWrite3(nh, Real42Bin(4566.969), 4)
        &#0009;&#0009;FClose(nh)
        &#0009;&#0009;lSuccess := TRUE
        &#0009;ELSE
        &#0009;&#0009;? DOSErrString(siError)
        &#0009;ENDIF
        &#0009;RETURN lSuccess
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </real42bin>
  <real82bin>
    <summary>
      Convert a Real8 value to a string containing an 8-byte floating point number.
    </summary>

    <param name="r8Value">The value to convert.</param>
    <returns>
    </returns>
    <remarks>
      Real82Bin() is a conversion function that converts a Real8 data type into an 8-byte string.  Typical applications include reading foreign file types in their native format and then saving, reading, decrypting, and transmitting data in their compressed binary form instead of in strings.<br/>
      Its inverse is Bin2Real8().
    </remarks>
    <example>
      Instead of saving numeric data as strings, this example writes them in a binary format in order to save disk space and possible transmission times:
      <code language="X#">
        FUNCTION Compressed() AS LOGIC
        &#0009;LOCAL nh
        &#0009;LOCAL lSuccess := FALSE AS LOGIC
        &#0009;nh := FOpen2("data.bin", FO_READWRITE)
        &#0009;// Assumes that file debug.bin already exists
        &#0009;IF nh != F_ERROR
        &#0009;&#0009;FWrite3(nh, Real82Bin(123456.789), 8)
        &#0009;&#0009;FWrite3(nh, Real82Bin(12 ^ 6), 8)
        &#0009;&#0009;FWrite3(nh, Real82Bin(4566.969), 8)
        &#0009;&#0009;FClose(nh)
        &#0009;&#0009;lSuccess := TRUE
        &#0009;ELSE
        &#0009;&#0009;? DOSErrString(siError)
        &#0009;ENDIF
        &#0009;RETURN lSuccess
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real8'>Bin2Real8</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </real82bin>
  <reccount>
    <summary>
      Determine the number of records in a database file.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
  </reccount>
  <recno>
    <summary>
      Return the current record number.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      The current record number.<br/>
      If the work area contains a database file with 0 records, RecNo() returns 1, BOF() and EOF() both return TRUE, and LastRec() returns 0.
      If the record pointer is moved past the last record, RecNo() returns LastRec() + 1 and EOF() returns TRUE.<br/>
      If an attempt is made to move before the first record, RecNo() returns the record number of the first logical record in the database file and BOF() returns TRUE.<br/>
      If no database file is open, RecNo() will return a 0.
    </returns>
    <remarks>
      X# database files are physically ordered by record number.<br/>
      Each work area in turn maintains a pointer to the current record in its open database file.  That record number is reported by RecNo().<br/>
      This allows direct access to a record without sequentially scanning the database file to reach the specified record position.
      Typically, RecNo() generalizes routines that process records by record number.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      This example queries RecNo() after deliberately moving the record pointer:
      <code language="X#">
        USE customer NEW
        GO 3
        QOut(RECNO())&#0009;&#0009;&#0009;&#0009;// Result: 3
        GO TOP
        QOut(RECNO())&#0009;&#0009;&#0009;&#0009;// Result: 1
        nRecord := 3
        GO nRecord
        QOut(RECNO())&#0009;&#0009;&#0009;&#0009;// Result: 3
        DBGoBottom()
        SKIP
        QOut(RECNO(), LastRec())&#0009;&#0009;// Result: 11 10
      </code>
      This example uses aliased expressions to query the value of RecNo() in unselected work areas:
      <code language="X#">
        USE sales NEW
        USE customer NEW
        QOut(Sales-&gt;RECNO())
        QOut(Customer-&gt;RECNO())
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bof'>BOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
  </recno>
  <recsize>
    <summary>
      Determine the record length of a database file.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      The record length, in bytes.  RecSize() returns 0 if no database file is open.
    </returns>
    <remarks>
      RecSize() determines the length of a record by summing the lengths of each field, then adding one for the Deleted() status flag.  When this value is multiplied by LastRec(), the product is the amount of space occupied by all of the file's records.
      RecSize() is useful in programs that perform automatic file backup.  When used in conjunction with DiskSpace(), the RecSize() function can assist in ensuring that sufficient free space exists on the disk before a file is stored.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      The following function, DBFSize(), uses RecSize() to calculate the size of the current database file:
      <code language="X#">
        FUNCTION DBFSize
        &#0009;RETURN ((RecSize() * LastRec()) + Header() + 1)
      </code>
      This example illustrates the use of RecSize() to determine the record length of database files open in unselected work areas:
      <code language="X#">
        USE customer NEW
        USE sales NEW
        QOut(RecSize(), Customer-&gt;RecSize())
        QOut(DBFSize(), Customer-&gt;DBFSize())
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRecordInfo'>DBRecordInfo</seealso>
    <seealso cref='O:XSharp.Core.Functions.DiskSpace'>DiskSpace</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldName'>FieldName</seealso>
    <seealso cref='O:XSharp.RT.Functions.Header'>Header</seealso>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
  </recsize>
  <reference>
    <summary>
      Alphabetical Listing
      By Category
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </reference>
  <registeraxit>
    <summary>
      Register an object so that it receives an Axit message before being destroyed by the garbage collector.
    </summary>

    <param name="oObject">The object that you want to register.</param>
    <returns>
    </returns>
    <remarks>
      RegisterAxit() causes the garbage collector to send an Axit message to the specified object before the object is destroyed.<br/>
      This way, you can code a method for the object's class named Axit() that will be automatically invoked as part of the standard garbage collection on the object.  RegisterAxit() is typically issued from the Init() method, as illustrated in the example below.
      The Axit() method is typically used for cleanup code.<br/>
      For example, you might close all open files, restore old environmental setting, free up memory, and so on.
      Tip:<br/>
      Use Memory(MEMORY_REGISTERAXIT) to get the number of objects registered for Axit.
    </remarks>
    <example>
      This example illustrates a class declaration that allocates memory in an Init() method and deallocates it in an Axit() method:
      <code language="X#">
        CLASS SysOne&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// define SysOne class
        &#0009;INSTANCE ptrX AS PTR
        CONSTRUCTOR() CLASS SysOne
        &#0009;ptrX := MemAlloc(1000)
        &#0009;RegisterAxit(SELF)
        &#0009;RETURN SELF
        METHOD Axit() CLASS SysOne
        &#0009;MemFree(ptrX)
        FUNCTION UseClass()
        &#0009;LOCAL oLowLevel AS SysOne
        &#0009;oLowLevel := SysOne{}&#0009;&#0009;&#0009;// call SysOne:Init()
        &#0009;. . .
        &#0009;// Because the object has been registered,
        &#0009;// the garbage collector calls SysOne:Axit()
        &#0009;// just before object is destroyed.
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.RegisterExit'>_RegisterExit</seealso>
    <seealso cref='O:XSharp.RT.Functions.InCollect'>InCollect</seealso>
    <seealso cref='O:XSharp.VO.Functions.RegisterKid'>RegisterKid</seealso>
    <seealso cref='O:XSharp.RT.Functions.UnRegisterAxit'>UnregisterAxit</seealso>
  </registeraxit>
  <registerkid>
    <summary>
      Register a dynamic object for update after a garbage collection.
    </summary>

    <param name="ptrKid">A pointer to a dynamic object you want to register.</param>
    <param name="dwCount">
      The number of consecutive objects to register.<br/>
      The objects may be USUALs or typed dynamic objects (strings, floats, class objects, or arrays.)
    </param>
    <param name="lItem">Determines whether registered objects are polymorphic: TRUE specifies USUAL and FALSE specifies typed.</param>
    <returns>
    </returns>
    <remarks>
      RegisterKid() ensures that dynamic objects are preserved after a garbage collection.  Dynamic objects are subject to garbage collection and their pointers become invalid after a collection.  However, if the pointer is registered, it is automatically updated and remains valid after a collection.
      Use Memory(MEMORY_REGISTERKID) to get the number of active registered objects.
      <note type="tip">
        Warning!  Invalid arguments cause general protection faults within the garbage collector.
        You must always ensure that an UnregisterKid() is performed for the pointer before it goes out of scope; therefore, for example, you would always use the following logic for a BEGIN SEQUENCE construct:
        <code language="X#">
          BEGIN SEQUENCE
          &#0009;...
          &#0009;RegisterKid(...)
          END SEQUENCE
          UnregisterKid(...)
        </code>
      </note>
    </remarks>
    <example>
      This example uses RegisterKid() to preserve data that might otherwise have been wiped out by the garbage collector:
      <code language="X#">
        STRUCTURE strucMyStrings
        &#0009;MEMBER DIM aStr[10] AS PTR
        Function Start()
        &#0009;LOCAL wI AS DWORD
        &#0009;LOCAL strucMyArray AS strucMyStrings
        &#0009;strucMyArray :=;
        &#0009;&#0009; MemCAlloc(_SizeOf(strucMyStrings), 1)
        &#0009;RegisterKid(strucMyArray, 10, FALSE)
        &#0009;FOR wI := 1 UPTO 10
        &#0009;&#0009;strucMyArray.aStr[wI] := Ptr(_CAST, Str(wI))
        &#0009;NEXT
        &#0009;CollectForced()&#0009;&#0009;// Force a garbage collection
        &#0009;UnregisterKid(strucMyArray)
        &#0009;// Collection is complete. Unregister objects.
        &#0009;// Objects have survived after a collection.
        &#0009;FOR wI := 1 UPTO 10
        &#0009;&#0009;MessageBox(0, strucMyArray.aStr[wI], Psz(wI), 0)
        &#0009;NEXT
        &#0009;MemFree(strucMyArray)
        &#0009;// Don't forget to free the allocated memory when you're done
      </code>
      The following is an example with BEGIN SEQUENCE:
      <code language="X#">
        STRUCT StrucMyStrings
        &#0009;MEMBER DIM aStr[10] AS PTR
        FUNCTION Start()
        LOCAL I AS DWORD
        LOCAL strucMyArray AS StrucMyStrings
        BEGIN SEQUENCE
        strucMyArray := MemCAlloc(_SizeOf(StrucMyStrings),1)
        &#0009;RegisterKid(strucMyArray, 10, FALSE)
        &#0009;FOR I := 1 UPTO 10
        &#0009;&#0009;strucMyArray.aStr[I] :=STR(I)
        &#0009;NEXT
        &#0009;Collect()&#0009;&#0009;// stress test...
        END SEQUENCE
        UnregisterKid(strucMyArray)
        FOR I := 1 UPTO 10 &#0009;// did we survive?
        &#0009;MessageBox(0, strucMyArray.aStr[I], Psz(I), 0)
        NEXT
        MemFree(strucMyArray)
        // Don't forget to free the allocated memory when you're done
      </code>
    </example>
    <seealsocmd>_DynCheck</seealsocmd>
    <seealso cref='O:XSharp.VO.Functions.DynCheckError'>DynCheckError</seealso>
    <seealso cref='O:XSharp.VO.Functions.Memory'>Memory</seealso>
    <seealso cref='O:XSharp.RT.Functions.RegisterAxit'>RegisterAxit</seealso>
    <seealso cref='O:XSharp.VO.Functions.UnRegisterKid'>UnregisterKid</seealso>
  </registerkid>
  <registeroleautomation>
    <summary>
      Register a X# object as an active automation server object.
    </summary>

    <param name="oObject">The object implementing the automation server.</param>
    <param name="cProgID">
      The program ID of the automation server.<br/>
      The program ID is a string which uniquely identifies the automation server.  Defaults to NULL_STRING.
    </param>
    <param name="iResID">
      The resource ID of the automation server's type library.<br/>
      The default is 1.
    </param>
    <param name="lASP">
      A flag specifying whether the automation server is to be used as an ASP component.<br/>
      The default is FALSE.
    </param>
    <returns>
      A handle (pointer) identifying the automation server uniquely.
    </returns>
    <remarks>
      RegisterOLEAutomationObject() registers any X# object as the current automation server.<br/>
      This means that all methods, accesses, and assigns of the server are exposed via OLE automation.
      Note:<br/>
      If you use the AutoServer base class or the Automated property in the GUI classes, you do not have to call this function explicitly.
      See Creating OLE Servers in the "How To" section of the online help for further details.
    </remarks>
    <example>
    </example>
    <seealsocmd>CLASS AutoServer</seealsocmd>
    <seealsocmd>UnRegisterOLEAutomationObject</seealsocmd>
    <seealsocmd>Window:Automated</seealsocmd>
  </registeroleautomation>
  <replicate>
    <summary>
      Repeat a string a specified number of times.
    </summary>

    <param name="cString">The string to repeat.</param>
    <param name="dwCount">
      The number of times to repeat <paramref name="cString" />, up to a maximum of MAX_ALLOC. Specifying a value of zero returns a NULL_STRING.
    </param>
    <returns>
    </returns>
    <remarks>
      Replicate() repeatedly displays, prints, or stuffs the keyboard with one or more characters.  Replicate() is like the Space() function, which returns a specified number of space characters.
    </remarks>
    <example>
      These examples demonstrate Replicate() repeating strings:
      <code language="X#">
        ? Replicate("*", 5)&#0009;&#0009;&#0009;&#0009;&#0009;// *****
        ? Replicate("Hi ", 2)&#0009;&#0009;&#0009;&#0009;// Hi Hi
        ? Replicate(_Chr(42), 5)&#0009;&#0009;&#0009;&#0009;// *****
      </code>
      This example uses Replicate() to stuff the keyboard with several Down arrow keys:
      <code language="X#">Keyboard(Replicate(_Chr(K_DN), 5))</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Space'>Space</seealso>
  </replicate>
  <rgb>
    <summary>
      Get a particular Windows color.
    </summary>

    <param name="bRed">The amount of red in the color, as a number from 0 to 255.</param>
    <param name="bGreen">The amount of green in the color, as a number from 0 to 255.</param>
    <param name="bBlue">The amount of blue in the color, as a number from 0 to 255.</param>
    <returns>
      The number that Windows uses to identify the color described.
    </returns>
    <remarks>
      If all three arguments are specified as 0, the color is black.<br/>
      If all three arguments are specified as 255, the color is white.
    </remarks>
    <example>
      The following example identifies a color that is mostly red and green, with a little bit of blue:
      <code language="X#">RGB(225,225,50)</code>
      This example lists the RGB value of commonly used colors:
      <code language="X#">
        ? "Red", RGB(255, 0, 0)
        ? "Green", RGB(0, 255, 0)
        ? "Blue", RGB(0, 0, 255)
        ? "Yellow", RGB(255, 255, 0)
        ? "Magenta", RGB(255, 0, 255)
        ? "Cyan", RGB(0, 255, 255)
        ? "Black", RGB(0, 0, 0)
        ? "Gray", RGB(128, 128, 128)
        ? "Brown", RGB(128, 128, 0)
        ? "Purple", RGB(128, 0, 128)
        ? "Aqua", RGB(0, 128, 128)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.PaletteRGB'>PaletteRGB</seealso>
  </rgb>
  <right>
    <summary>
      Return a substring beginning with the rightmost character.
    </summary>

    <param name="cString">The string from which to extract characters.</param>
    <param name="dwCount">The number of characters to extract.</param>
    <returns>
      The rightmost <paramref name="dwCount" /> characters of <paramref name="cString" />.<br/>
      If <paramref name="dwCount" /> is 0, Right() returns a NULL_STRING.<br/>
      A negative value is not allowed since a WORD cannot be negative.<br/>
      If <paramref name="dwCount" />  larger than the length of the string, Right() returns <paramref name="cString" />.
    </returns>
    <remarks>
      Right() is the same as Substr(<paramref name="cString" />, -<paramref name="wCount" />).<br/>
      For example, Right("ABC", 1) is the same as Substr("ABC", -1).  Right() is related to Left(), which extracts a substring beginning with the leftmost character in <paramref name="cString" />.
      The Right(), Left(), and Substr() functions are often used with both the At() and RAt() functions to locate either the first and/or the last position of a substring before extracting it.
    </remarks>
    <example>
      This example shows the relationship between Right() and Substr():
      <code language="X#">
        ? Right("ABCDEF", 3)&#0009;&#0009;&#0009;&#0009;// DEF
        ? Substr("ABCDEF", 3)&#0009;&#0009;&#0009;&#0009;// CDEF
        ? Substr("ABCDEF", -3)&#0009;&#0009;&#0009;&#0009;// DEF
      </code>
      This example extracts a substring from the end of another string, up to the last occurrence of a comma:
      <code language="X#">
        LOCAL cName AS STRING
        cName := "James, William"
        ? Right(cName, SLen(cName) - RAt(",", cName) -1)&#0009;// William
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.Stuff'>Stuff</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </right>
  <rlock>
    <summary>
      Lock the current record.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <param name="cRecordNumberList">
      Specifies that RLOCK( ) attempts to lock multiple records.
      The character expression cRecordNumberList specifies one or more record numbers, separated by commas, that RLOCK( ) attempts to lock.
      For example, to attempt record locks on the first four records in a table, cRecordNumberList should contain 1, 2, 3, 4.
    </param>
    <returns>
      TRUE if the record lock(s) is (are) obtained; otherwise, FALSE.<br/>
      If you try to lock more than one record and one of them fails then
      locks that were successful are released again.<br/>
      An attempt to lock a record in an empty database returns TRUE.
    </returns>
    <remarks>
      If a database file is opened in shared mode, you must obtain a record lock before attempting any operation that writes to the database file.
      For each invocation of RLock(), there is one attempt to lock the target record, and the result is returned as a logical value.<br/>
      An attempt to obtain a record lock fails if another process currently has a file lock or record lock on the target record.
      If RLock() is successful, the record is locked and other processes are prevented from updating the record until the lock is released.
      RLock() provides a shared lock, allowing other users read-only access to the locked record while allowing only the current process to
      modify it.
      A record lock remains in effect until you explicitly unlock it (with DBUnLock(), for example), close the database file, or
      attempt another file or record lock (with RLock() or DBRLock() without an argument).
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      This feature is useful since RLock() does not automatically attempt a record lock for related files.

    </remarks>
    <example>
      This example deletes a record in a shared database file using RLock():
      <code language="X#">
        USE customer INDEX custname SHARED NEW
        SEEK "Smith"
        IF Customer-&gt;Found()
        &#0009;IF Customer-&gt;RLock()
        &#0009;&#0009;Customer-&gt;DBDelete()
        &#0009;&#0009;QOut("Smith deleted")
        &#0009;ELSE
        &#0009;&#0009;QOut("Record in use by another")
        &#0009;ENDIF
        ELSE
        &#0009;QOut("Smith not in Customer file")
        ENDIF
        CLOSE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLock'>DBUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUseArea'>DBUseArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.Flock'>FLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetExclusive'>SetExclusive</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRlock'>VODBRLock</seealso>
  </rlock>
  <round>
    <summary>
      Round a number to a specified number of digits.
    </summary>

    <param name="nNumber">The number to round.</param>
    <param name="siDecimals">
      The number of decimal places to retain.  Specifying a 0 or negative value for <paramref name="siDecimals" />  rounds to whole numbers.<br/>
      A negative <paramref name="siDecimals" /> also indicates the number of digits to the left of the decimal point to round (see the example).
    </param>
    <returns>
    </returns>
    <remarks>
      Digits below 5 are rounded down.  Digits from 5 to 9 are rounded up.
      The display of the return value does not obey the decimals setting unless SetFixed() is TRUE.<br/>
      If SetFixed() is FALSE, the display of the return value contains  <paramref name="siDecimals" /> decimal digits if  <paramref name="siDecimals" /> is greater than 0, and zero decimal digits if  <paramref name="siDecimals" /> is less than or equal to 0.
    </remarks>
    <example>
      These examples round values with decimal digits:
      <code language="X#">
        SetDecimal(2)
        SetFixed(TRUE)
        ? Round(10.4, 0)&#0009;&#0009;&#0009;&#0009;&#0009;// 10
        ? Round(10.5, 0)&#0009;&#0009;&#0009;&#0009;&#0009;// 11
        ? Round(10.51, 0)&#0009;&#0009;&#0009;&#0009;&#0009;// 11
        ? Round(10.49999999999999, 2)&#0009;&#0009;&#0009;// 10.50
      </code>
      These examples use a negative <paramref name="siDecimals" /> argument to round numeric values to whole numbers:
      <code language="X#">
        ? Round(101.99, -1)&#0009;&#0009;&#0009;&#0009;&#0009;// 100
        ? Round(109.99, -1)&#0009;&#0009;&#0009;&#0009;&#0009;// 110
        ? Round(109.99, -2)&#0009;&#0009;&#0009;&#0009;&#0009;// 100
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Integer'>Integer</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetFixed'>SetFixed</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Val'>Val</seealso>
  </round>
  <row>
    <summary>
      Return the screen row position of the cursor in the terminal window.
    </summary>
    <returns>
      The cursor row position.<br/>
      The range of the return value is 0 to MaxRow().
    </returns>
    <remarks>
      Row() is a screen function that returns the current row or line position of the screen cursor.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Col'>Col</seealso>
  </row>
  <rtrim>
    <summary>
      Remove trailing spaces from a string.
    </summary>

    <param name="cString">The string to trim.</param>
    <returns>
      <paramref name="cString" /> with the trailing spaces removed.<br/>
      If <paramref name="cString" /> is a NULL_STRING or all spaces, RTrim() returns a NULL_STRING.
    </returns>
    <remarks>
      RTrim() is the same as Trim().  See Trim() for details.
    </remarks>
    <example>
      This is a function in which RTrim() formats city, state, and zip code fields for labels or form letters:
      <code language="X#">
        FUNCTION CityState(cCity, cState, cZip)
        &#0009;RETURN RTrim(cCity) + ", " ;
        &#0009;&#0009;&#0009;+ RTrim(cState) + "  " + cZip
      </code>
      To complete the example the function, CityState(), displays a record from CUSTOMER.DBF:
      <code language="X#">
        USE customer INDEX custname NEW
        SEEK "Kate"
        ? CityState(City, State, ZipCode)&#0009;// Athens, GA 10066
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AllTrim'>AllTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Trim'>Trim</seealso>
  </rtrim>
  <sbtodb>
    <summary>
      Convert single-byte kana characters in a string to their double-byte equivalents.
    </summary>

    <param name="cMBTarget">The string to convert.</param>
    <returns>
      <paramref name="cMBTarget" /> with the specified characters changed.
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.DBToSB'>DBToSB</seealso>
  </sbtodb>
  <sclone>
    <summary>
      Create new character variable with the same characters as the original string.
    </summary>

    <param name="cString">The string to clone.</param>
    <returns>
      The same string, but with a different address from the original string.<br/>
      The new string is dynamically allocated.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses SClone() to show how cloning a string works:
      <code language="X#">
        LOCAL cString1 AS STRING
        LOCAL cString2 AS STRING
        cString1 := "Hello"
        cString2 := SClone(cString1)
        ? cString1 == cString2&#0009;&#0009;// TRUE
        cString1 := "World"
        ? cString1 == cString2&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.StringAlloc'>StringAlloc</seealso>
  </sclone>
  <seconds>
    <summary>
      Return the number of seconds that have elapsed since midnight.
    </summary>
    <returns>
      The number of seconds that have elapsed since midnight in the form seconds.hundredths.  Numbers range from 0 to 86,399.
    </returns>
    <remarks>
      Seconds() provides a simple method of calculating elapsed time during program execution, based on the system clock.<br/>
      It is related to the Time() function, which returns the system time in the form hh:mO:ss.<br/>
      The smallest resolution depends on the hardware timer tick.
    </remarks>
    <example>
      This example contrasts the value of Time() with Seconds():
      <code language="X#">
        ? Time()&#0009;&#0009;&#0009;&#0009;&#0009;// 10:00:00
        ? Seconds()&#0009;&#0009;&#0009;&#0009;&#0009;// 36000.00
      </code>
      This example uses Seconds() to track elapsed time in seconds:
      <code language="X#">
        LOCAL nStart, nElapsed AS FLOAT
        nStart := Seconds()
        .
        . <paramref name="Statements" />
        .
        nElapsed := Seconds() - nStart
        ? "Elapsed: " + NTrim(nElapsed) + " seconds"
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ElapTime'>ElapTime</seealso>
    <seealso cref='O:XSharp.RT.Functions.GetTickCountLow'>GetTickCountLow</seealso>
    <seealso cref='O:XSharp.Core.Functions.Secs'>Secs</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
  </seconds>
  <secs>
    <summary>
      Return a time as the number of seconds that have elapsed since midnight.
    </summary>

    <param name="cTime">The time to convert to seconds, in the form hh:mO:ss.</param>
    <returns>
      The number of seconds from midnight to the time specified.<br/>
      The return value cannot be greater than 86,400, the number of seconds in a day.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example displays the number of seconds that have passed since midnight:
      <code language="X#">? Secs(Time())</code>
      This example specifies a time greater than 24 hours:
      <code language="X#">? Secs("25:05:09")&#0009;&#0009;&#0009;// 90309</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.TString'>TString</seealso>
  </secs>
  <select>
    <summary>
      Determine the number of a work area.
    </summary>

    <param name="uWorkArea">
      A value that identifies the work area.<br/>
      This can be the number of the work area or its alias, specified either as a symbol or a string.<br/>
      If <paramref name="uWorkArea" /> is not specified, the current work area number is returned.<br/>
      Therefore, Select() is the same as DBGetSelect().
    </param>
    <returns>
      A number from 0 to 4096.  0 is returned if <paramref name="uWorkArea" /> does not identify a valid work area or does not correspond to a valid alias.
    </returns>
    <remarks>
      The Select() function and SELECT command specified with an extended expression argument look somewhat alike.
    </remarks>
    <example>
      This example shows how Select() takes different arguments:
      <code language="X#">
        USE sales NEW
        USE customer NEW
        QOut(Select())&#0009;&#0009;&#0009;&#0009;// Result: 2
        QOut(Select(#sales))&#0009;&#0009;// Result: 1
        QOut(Select("customer"))&#0009;&#0009;// Result: 2
        QOut(Select("sales"))&#0009;&#0009;// Result: 1
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias'>Alias</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGetSelect'>DBGetSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetSelect'>DBSetSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>SELECT</seealso>
    <seealso cref='O:XSharp.RT.Functions.Used'>Used</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbGetSelect'>VoDbGetSelect</seealso>
  </select>
  <send>
    <summary>
      Invoke a method.
    </summary>

    <param name="oObject">The object whose method is invoked.</param>
    <param name="symMethod">The method name, specified without parentheses.</param>
    <param name="MethodArgList">
      A comma-separated list of arguments to pass to <paramref name="symMethod" />.
    </param>
    <returns>
      The return value of the method.
    </returns>
    <remarks>
      Send() allows you to send a method through a function call.
    </remarks>
    <example>
      This example uses Send() to invoke a method named Horn() that expects two arguments:
      <code language="X#">
        CLASS Automobile
        &#0009;EXPORT model
        CONSTRUCTOR(tmodel) CLASS Automobile
        &#0009;model := tmodel
        METHOD Horn(nSound, cSay) CLASS Automobile
        &#0009;Tone(nSound, 2)
        &#0009;QOut(cSay)
        FUNCTION Start()
        &#0009;LOCAL x AS OBJECT
        &#0009;x := Automobile{"Car"}
        &#0009;// x:Horn(100, "Hello!")
        &#0009;Send(x, #Horn, 100, "Hello!")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ASend'>ASend</seealso>
    <seealso cref='O:XSharp.RT.Functions.NoMethod'>NoMethod</seealso>
  </send>
  <setamext>
    <summary>
      Set the morning extension for time strings in 12-hour format.
    </summary>

    <param name="cAMExt">
      The extension to be used for time strings that occur in the morning hours.<br/>
      This string can be up to eight characters in length — additional characters are ignored.<br/>
      The initial default depends on SetInternational(), which you can refer to for more information.
    </param>
    <returns>
    </returns>
    <remarks>
      Time strings formatted using the 12-hour time format have an extension to specify if the time is in the morning or the evening.  SetAMExt() allows you to programmatically set the extension identifying morning time strings (that is, those between 12:00:00 midnight and just before 12:00:00 noon).<br/>
      A typical extension for morning time strings is "AM", which is how the function derives its name.
      The initial default for the morning extension is affected by SetInternational(), which you can refer to for more information.<br/>
      Use GetAMExt() to retrieve the current value of this setting.
    </remarks>
    <example>
      This example turns on the 12-hour time format and displays a time string using two different extensions:
      <code language="X#">
        SetAMPM(TRUE)
        SetAMExt(" am")
        ? TString(3800)&#0009;// 01:03:20 am
        SetAMExt(" morning")
        ? TString(3800)&#0009;// 01:03:20 morning
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetAMExt'>GetAMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAmPm'>SetAMPM</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPMExt'>SetPMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
    <seealso cref='O:XSharp.RT.Functions.TString'>TString</seealso>
  </setamext>
  <setampm>
    <summary>
      Return and optionally change the setting that determines whether time strings are in 12-hour or 24-hour format.
    </summary>

    <param name="lNewSetting">
      TRUE indicates 12-hour format.  FALSE indicates 24-hour format.<br/>
      The initial default depends on SetInternational(), which you can refer to for more information.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, SetAMPM() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example shows the difference between the 12-hour and 24-hour display formats:
      <code language="X#">
        SetPMExt(" pm")
        SetAMPM(FALSE)
        ? TIME()&#0009;&#0009;// Result: 13:10:15 pm
        SetAMPM(TRUE)
        ? TIME()&#0009;&#0009;// Result: 01:10:15 pm
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetAMExt'>SetAMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPMExt'>SetPMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
  </setampm>
  <setansi>
    <summary>
      Return and optionally change the setting that determines whether database files are created using ANSI or OEM format and whether certain text file operations convert between the two character sets.
    </summary>

    <param name="lNewSetting">
      TRUE specifies the ANSI format; FALSE specifies the OEM format.<br/>
      If the Ansi entry in the X# section of WIN.INI is not present, an entry of Ansi=1 will be written, setting the initial default to TRUE; if this entry is set to 0, the initial default is FALSE.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, SetAnsi() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetAnsi() is a dual purpose function.
      <br/>



      First and foremost, it determines the format used to create new database files — ANSI, which uses the Windows character set, or OEM, which uses the ASCII character set.  Thus, functions such as DBCreate() and DBCopyStruct() are affected by this setting.<br/>
      The information that determines the ANSI/OEM format of a database file is stored in the header record of the file.
      Important!<br/>
      If your application must share data with a DOS-based product, either simultaneously or at different times, you must use the OEM format when creating .DBF files.
      If SetAnsi() is TRUE, your X# application will perform an automatic conversion between OEM and ANSI for existing database files that are in OEM format, thereby preserving the format of the data and allowing it to be used by other applications that do not support the ANSI format.
      Is SetAnsi() is FALSE, however, no automatic conversion is performed when reading to or writing from any database file.  In this case, the data will appear at runtime just as it was read from disk.<br/>
      For OEM databases, therefore, the programmer is fully responsible for ANSI/OEM conversion of displayed data or data modified by any edit control or terminal function.  You can use the Ansi2Oem() and Oem2Ansi() functions to convert data between the two formats.
      <br/>



      The second purpose of SetAnsi() is to control how functions that read and write text files deal with the two different character sets.  When SetAnsi() is FALSE, functions that read from text files (FReadText() and MemoRead()) and write to text files (FWriteText() and MemoWrit()) automatically convert between ANSI to OEM.  When SetAnsi() is TRUE, these functions perform no conversion.
      Independent of SetAnsi(), however, all data that is read or written using the FRead(), FWrite(), and related functions is not converted to and from the OEM character set.
    </remarks>
    <example>
      This example stores the SetAnsi() setting in the beginning of an application and restores it to its original setting at the end:
      <code language="X#">
        METHOD Start() CLASS App
        &#0009;LOCAL lAnsiSetting AS LOGIC
        &#0009;lAnsiSetting := SetAnsi(FALSE)
        &#0009;...
        &#0009;SetAnsi(lAnsiSetting)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCopy'>DBCopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCopyStruct'>DBCopyStruct</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCopyXStruct'>DBCopyXStruct</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreate'>DBCreate</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadText'>FReadText</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWriteText'>FWriteText</seealso>
    <seealso cref='O:XSharp.Core.Functions.MemoRead'>MemoRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.MemoWrit'>MemoWrit</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
  </setansi>
  <setapplocaleid>
    <summary>
      Sets the locale that the runtime uses for comparing strings when running in Windows collation mode (SetCollation(#Windows)).
    </summary>

    <param name="uiNewLocale">Must be a valid LocaleId and can be constructed using the MAKELCID() and MAKELANGID() functions.</param>
    <returns>
      The previously installed Locale.
    </returns>
    <remarks>
      This function sets the locale that the runtime uses for comparing strings when running in Windows collation mode (SetCollation(#Windows)), which is the default mode for X#. The string comparison is responsible for the sorting of DBF files, for comparing strings (including Asorting arrays of strings) and for the sort order within indexes. The default behaviour of the runtime is to read the locale id from the current user by calling the GetUserDefaultLCID() function. To avoid problem when different users using the same app have different Locales selected on their machines you can now control the Locale used by your app from within the code.
    </remarks>
    <example>
      // To use the standard German Language in Phone Book sorting mode:
      <br/>



      <br/>



      // To use the Swiss German Language in Default sorting mode
      <br/>



      &#0009;
      // To use the Norwegian Bokmal language, default sorting mode
      <br/>



      &#0009;
      // To use language independent sorting
      <br/>



      &#0009;
    </example>
    <seealso cref='O:XSharp.VO.Functions.GetAppLocaleID'>GetAppLocaleId</seealso>
  </setapplocaleid>
  <setbeep>
    <summary>
      Return and optionally change the setting that determines whether a beep is sounded by the error system when an error occurs.
    </summary>

    <param name="lNewSetting">
      TRUE turns beeping on; FALSE turns it off.<br/>
      If the Beep entry in the Windows section of WIN.INI is not present or is set to yes, the initial default is TRUE; if this entry is set to no, the initial default is FALSE.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, SetBeep() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example shuts off the error beep if it is on:
      <code language="X#">
        IF SetBeep()
        &#0009;MessageBeep(MB_OK)
        &#0009;SetBeep(FALSE)
        &#0009;? "No more beeping on errors from now on!"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Tone'>Tone</seealso>
  </setbeep>
  <setcentury>
    <summary>
      Return and optionally change the setting that determines whether to include or omit century digits in the date format.
    </summary>

    <param name="lNewSetting">
      TRUE includes century digits, meaning the date format contains four digits for the year and can include a century other than 19xx.  FALSE omits century digits, meaning the date format contains only two digits for the year.<br/>
      This means that century digits of dates are not displayed and cannot be input.<br/>
      The initial default is TRUE.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, SetCentury() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetCentury() modifies the current date format as set by SetDateFormat().  Note that only the display and input format of dates is affected; date calculations maintain the century information regardless of the date format.
    </remarks>
    <example>
      This example shows the results of a simple SetCentury function:
      <code language="X#">
        SetCentury(FALSE)
        ? TODAY()&#0009;&#0009;&#0009;&#0009;&#0009;// 06/15/93
        SetCentury(TRUE)
        ? TODAY()&#0009;&#0009;&#0009;&#0009;&#0009;// 06/15/1993
      </code>
    </example>
  </setcentury>
  <setcollation>
    <summary>
      Return and optionally change the setting that determines the internal collation routine used for string comparisons.
    </summary>

    <param name="symNewSetting">
      The collation mode to use.<br/>
      The available modes are #Windows (the default) and #Clipper.
    </param>
    <returns>
      If <paramref name="symNewSetting" /> is not specified, SetCollation() returns the current setting.<br/>
      If <paramref name="symNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetCollation() sets the internal collation routine that is used for all string comparisons, except the ones done using the == operator.  Note that this includes sort and index operations, as well as programmatic string comparisons using the various operators.
      Note:  Changing SetInternational() automatically changes SetCollation() so that the two settings are the same.
      This setting allows X# to operate in different collation modes.<br/>
      The #Clipper mode is provided for compatibility with CA-Clipper applications and uses a collation routine defined in the nation module (VO28NAT.DLL).<br/>
      The #Windows mode uses string comparison services provided by Windows that automatically handle foreign character sets.
      Therefore, if an application uses the #Clipper collation mode, it will behave the same on all machines.  Thus, to achieve a different collation sequence based on a language other than English, you would need a version of VO28NAT.DLL specialized to the desired language.  On the other hand, if the application uses the #Windows collation mode, it will behave differently from machine to machine, depending on the language defined in the International settings of the Control Panel.  In this case, all languages supported by Windows are also supported by your application, including right-to-left languages, such as Hebrew and Arabic, and double-byte languages, such as Chinese, Japanese, and Korean.
      Note:  String functions, such as Substr() and SLen(), that operate at the byte level will not function correctly with double-byte characters.
      The collation sequence for the regular Latin character set is different for #Clipper and #Windows.<br/>
      For #Clipper:
      A &lt; B &lt; C &lt; ... &lt; Z &lt; a &lt; b &lt; c &lt; ... &lt; z
      For #Windows:
      A &lt; a &lt; B &lt; b &lt; C &lt; c &lt; ... &lt; Z &lt; z
      Warning!  SetCollation() determines how index files and the orders within them are created and maintained.<br/>
      Attempting to use different collation modes in the same order will corrupt the order.
    </remarks>
    <example>
      This example, based on the Start() method for the Standard Application, checks the current Windows language configuration, allowing the application to run only when set to use the French language collation:
      <code language="X#">
        METHOD Start() CLASS App
        &#0009;LOCAL oWindow AS Window
        &#0009;LOCAL nLen, nBufSize := 10 AS SHORTINT
        &#0009;LOCAL pszLang := Psz(Space(nBufSize)) AS PSZ
        &#0009;// Initialize StandardShellWindow
        &#0009;Enable3DControls()
        &#0009;oWindow := StandardShellWindow{SELF}
        &#0009;oWindow:Show()
        &#0009;// Retrieve language collation setting from WIN.INI
        &#0009;nLen := GetProfileString("intl", "sLanguage",&#0009;;
        &#0009;&#0009;"", pszLang, nBufSize)
      </code>
      &#0009;
      <code language="X#">
        &#0009;// Run application only if system configured to use
        &#0009;// French Windows collation
        &#0009;IF (Left(String(_CAST, pszLang), nLen) != "fra")
        &#0009;&#0009;// Incorrect language so give error and quit.
        &#0009;&#0009;TextBox{oWindow, "System Configuration",&#0009;;
        &#0009;&#0009;&#0009;"You must have the Language set to " +&#0009;;
        &#0009;&#0009;&#0009;"'French' in the International " +&#0009;&#0009;;
        &#0009;&#0009;&#0009;"section of your Control Panel to " +&#0009;;
        &#0009;&#0009;&#0009;"run this application."}:Show()
        &#0009;ELSE
        &#0009;&#0009;// Run application
        &#0009;&#0009;SELF:Exec()
        &#0009;ENDIF
      </code>
    </example>
    <seealsocmd>SET COLLATION</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
  </setcollation>
  <setcolor>
    <summary>
      Return and optionally change the setting that determines the current color settings for the terminal window.
    </summary>

    <param name="cNewSetting">
      The colors to be used in subsequent screen painting.<br/>

      <br/>



      &#0009;The color must be specified as a foreground and background color pair, separated by the slash (/) character:<br/>

      &#0009;Foreground defines the color of characters displayed on the screen.<br/>

      &#0009;Background defines the color displayed behind the character.  Spaces and nondisplay characters display as background.<br/>

      &#0009;When specifying the foreground color for a particular region, you can also specify high intensity with either a plus sign (+) or an asterisk (*).  <br/>

      &#0009;Colors can be specified using letters according to the following table.For example, you might specify W+/N.
    </param>
    <param name="Letter">Color</param>
    <param name="B">Blue</param>
    <param name="B+">Bright Blue</param>
    <param name="BG">Cyan</param>
    <param name="BG+">Bright Cyan</param>
    <param name="G">Green</param>
    <param name="G+">Bright Green</param>
    <param name="GR">Brown</param>
    <param name="GR+">Yellow</param>
    <param name="N">Black</param>
    <param name="N+">Gray</param>
    <param name="R">Red</param>
    <param name="R+">Bright Red</param>
    <param name="RB">Magenta</param>
    <param name="RB+">Bright Magenta</param>
    <param name="W">White</param>
    <param name="W+">Bright White</param>
    <returns>
      If <paramref name="cNewSetting" /> is not specified, SetColor() returns the current color setting.<br/>
      If <paramref name="cNewSetting" /> is specified, the previous color setting is returned.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example assigns the current color setting to the variable, <paramref name="cColor" />:
      <code language="X#">
        LOCAL cColor AS STRING
        cColor := SetColor()
      </code>
      This example uses SetColor() to set a new color setting and save the current one:
      <code language="X#">
        cNewColor := "RB+/N"
        cOldColor := SetColor(cNewColor)
      </code>
    </example>
  </setcolor>
  <setcpu>
    <summary>
      Return and optionally change the setting that determines the type of central processor you have.
    </summary>

    <param name="nNewSetting">
      A value, like 386 or 486, for the new setting.<br/>
      The initial default is the numeric identifier of your central processor.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, SetCPU() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetCPU is a compatibility function. It does not really do anything in X#.
    </remarks>
    <seealso cref='O:XSharp.Core.Functions.SetMath'>SetMath</seealso>
  </setcpu>
  <setdatecountry>
    <summary>
      Return and optionally change the setting that determines the X# date format by selecting from a list of constants with corresponding date formats.
    </summary>

    <param name="dwNewSetting">One of the following constants which initializes the corresponding date format (the number of characters in the year value is control by SetCentury()):</param>
    <list type="table">
      <listheader>
        <term>Constant</term>
        <description>Date Format</description>
      </listheader>
      <item>
        <term>
          AMERICAN
        </term>
        <description>mm/dd/yy or mm/dd/yyyy</description>
      </item>
      <item>
        <term>ANSI</term>
        <description>yy.mm.dd or yyyy.mm.dd</description>
      </item>
      <item>
        <term>BRITISH</term>
        <description>dd/mm/yy or dd/mm/yyyy</description>
      </item>
      <item>
        <term>FRENCH</term>
        <description>dd/mm/yy or dd/mm/yyyy</description>
      </item>
      <item>
        <term>GERMAN</term>
        <description>dd.mm.yy or dd.mm.yyyy</description>
      </item>
      <item>
        <term>ITALIAN</term>
        <description>dd-mm-yy or dd-mm-yyyy</description>
      </item>
      <item>
        <term>JAPANESE</term>
        <description>yy/mm/dd or yyyy/mm/dd</description>
      </item>
      <item>
        <term>USA</term>
        <description>mm-dd-yy or mm-dd-yyyy</description>
      </item>
    </list>
    <returns>
      If <paramref name="dwNewSetting" /> is not specified, SetDateCountry() returns one of the numeric values described above indicating the current date and country setting.<br/>
      If <paramref name="dwNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses SetDateCountry() to display today's date in all 16 formats:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL I AS INT
        &#0009;SetDateCountry(2)
        &#0009;SetCentury(FALSE)
        &#0009;? DTOC(TODAY())
        &#0009;? DTOC(92.12.31)
        &#0009;? DTOC(1992.12.31)
        &#0009;FOR I := 1 UPTO 8
        &#0009;&#0009;SetDateCountry(I)
        &#0009;&#0009;? I, DTOC(TODAY()), "!" + DTOC(0) + "!"
        &#0009;NEXT
        &#0009;?
        &#0009;SetCentury(TRUE)
        &#0009;FOR I := 1 UPTO 8
        &#0009;&#0009;SetDateCountry(I)
        &#0009;&#0009;? I, DTOC(TODAY()), "!" + DTOC(0) + "!"
        &#0009;NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CToD'>CToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToC'>DToC</seealso>
    <seealsocmd>SET DATE</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetDateFormat'>SetDateFormat</seealso>

  </setdatecountry>
  <setdateformat>
    <summary>
      Change the setting that determines the X# date format.
    </summary>

    <param name="cNewSetting">
      The new date format to be set, in a string of 37 characters or less.<br/>
      The date format can be specified in a number of ways, but must contain one or more occurrences of the letters D, M, and Y (respectively).<br/>
      For example:
    </param>
    <returns>
      TRUE if the argument is the same as the current setting; otherwise, FALSE.
    </returns>
    <remarks>
      SetDateFormat() analyzes the new format specified by <paramref name="cNewSetting" /> and determines both the proper placement and number of digits for the day, month, and year based on the D, M, and Y letters it finds.
      SetDateFormat() is a global setting that affects the behavior of dates throughout a program, allowing you to control date formatting in a way that facilitates porting applications to foreign countries.
    </remarks>
    <example>
      This example uses SetDateFormat() to set a date format:
      <code language="X#">
        FUNCTION T()
        &#0009;LOCAL x AS STRING
        &#0009;? GetDateFormat()
        &#0009;x:="DD-ABC-YYYY-123-MM"
        &#0009;? x
        &#0009;SetDateFormat(x)
        &#0009;? GetDateFormat()
        &#0009;? TODAY()
        &#0009;? 00.00.00
        &#0009;? CTOD("31.1992.12")
        &#0009;? CTOD(NULL_STRING)
        &#0009;SetCentury(FALSE)
        &#0009;? GetDateFormat()
      </code>
      This example illustrates how SetDateFormat() can ignore or include the century digits:
      <code language="X#">
        SetDateFormat("Year: YY, month: MM, day: DD")
        ? SetCentury()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        SetDateFormat("DD. day of month MM in the Year YYYY")
        ? SetCentury()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CToD'>CToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToC'>DToC</seealso>
    <seealsocmd>SET DATE FORMAT</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetDateCountry'>SetDateCountry</seealso>
  </setdateformat>
  <setdecimal>
    <summary>
      Return and optionally change the setting that determines the number of decimal places used to display numbers.
    </summary>

    <param name="nNewSetting">
      The number of decimal places to display.<br/>
      The initial default is 2.<br/>
      A negative value specifies that all significant digits are returned
    </param>
    <returns>
      If <paramref name="nNewSetting" /> is not specified, SetDecimal() returns the current setting.<br/>
      If <paramref name="nNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetDecimal() determines the number of decimal places displayed in the results of numeric functions and calculations.<br/>
      Its operation depends directly on the SetFixed() setting:
      &#0009;If SetFixed() is FALSE, SetDecimal() establishes the minimum number of decimal digits displayed by Exp(), Log(), SqRt(), and division operations.<br/>
      If SetFixed() is FALSE, SetDecimal() is still in effect.
      &#0009;If SetFixed() is TRUE, all numeric values are displayed with exactly the number of decimal places specified by SetDecimal().
      Note that neither SetDecimal() nor SetFixed() affects the actual numeric precision of calculations — only the display format is affected.
      All variables containing a FLOAT type have internal picture information relating to digits and decimals (see FloatFormat()).<br/>
      For database fields of type FLOAT, such picture information resides in the database header structure and is obtainable by FieldVal().
      With the Val() function and with literal floats (that is, hard-coded in source code and thus known at compile time), the number of decimals is derived from the hard-coded decimal portion and the number of digits is taken from SetDigit().
      If new floats are generated in expressions or by functions, the number of digits is always taken from SetDigit() and the number of decimals is determined as follows:
      Operators&#0009;Number of decimals&#0009;
      + or -&#0009;Maximum of two operands&#0009;
      *&#0009;Sum of two operands&#0009;
      /&#0009;Current setting of SetDecimal()&#0009;
      For functions, the number of decimals is determined by the current setting of SetDecimal() or a zero for special cases such as the Integer() function.
    </remarks>
    <example>
      These examples show various results of the SetDecimal() function:
      <code language="X#">
        SetDecimal(2)
        ? 2.0/4.0               // 0.50
        ? 1.0/3.0               // 0.33
        SetDecimal(4)
        ? 2.0/4.0               // 0.5000
        ? 1.0/3.0               // 0.3333
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FloatFormat'>FloatFormat</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDecimalSep'>SetDecimalSep</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetFixed'>SetFixed</seealso>
    <seealso cref='O:XSharp.RT.Functions.Transform'>Transform</seealso>
  </setdecimal>
  <setdecimalsep>
    <summary>
      Return and optionally change the setting that determines the decimal separation character to be used in numeric-to-string conversion functions.
    </summary>

    <param name="nNewSetting">
      An ASCII code representing the new decimal separator.<br/>
      The initial default is 46, which is the ASCII code for the "." character.<br/>
      Possible values are ASC(".") and ASC(",").
    </param>
    <returns>
      If <paramref name="nNewSetting" /> is not specified, SetDecimalSep() returns the current setting.<br/>
      If <paramref name="nNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example changes the decimal separator from a period (.) to a comma (,):
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL rPi := 3.14 AS REAL4
        &#0009;SetDecimalSep(Asc(","))
        &#0009;QOut(rPi)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetTimeSep'>SetTimeSep</seealso>
  </setdecimalsep>
  <setdefault>
    <summary>
      Change the setting that determines the X# default drive and directory.
    </summary>

    <param name="cPathSpec">
      The default disk drive and directory.<br/>
      If you specify both a drive and directory, a colon must be included after the drive letter.  (Use GetDefault() to get the current setting.)
    </param>
    <returns>
    </returns>
    <remarks>
      By default, when a X# program starts, the default drive and directory are the current X# drive and directory.  Within the program, you can change this with SetDefault() — it sets the drive and directory where the application program creates and searches for files specified without a path name.
      Note:  Certain commands and functions that open files do not respect the SetDefault() setting.<br/>
      These cases are noted explicitly in the documentation for those commands and functions.
      SetDefault() does not change the X# drive and directory, but instead causes the application to use a different default.<br/>
      To set additional search paths for file access, use SetPath().
    </remarks>
    <example>
      This example uses SetDefault() to set and query the current default drive and directory:
      <code language="X#">
        FUNCTION Start()
        ? GetCurPath()&#0009;&#0009;&#0009;// Print current path
        SetPath("c:\")&#0009;&#0009;&#0009;// Set new path
        ? GetCurPath()&#0009;&#0009;&#0009;// Print current path
        ? GetDefault()&#0009;&#0009;&#0009;// Print current default
        SetDefault("c:\")&#0009;&#0009;// Set new default
        ? GetDefault()&#0009;&#0009;&#0009;// Print current default
        WAIT
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetDefault'>GetDefault</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPath'>SetPath</seealso>
  </setdefault>
  <setdefaultdir>
    <summary>
      Change the setting that determines the location of the error log file.
    </summary>

    <param name="cPathSpec">
      The disk drive and directory where you want the application to create and search for the error log file.<br/>
      If you specify both a drive and directory, a colon must be included after the drive letter.<br/>
      The initial default for SetDefaultDir() is the current directory.
    </param>
    <returns>
    </returns>
    <remarks>
      By default — that is, if you do not place a DefaultDir entry in the X# section of WIN.INI and do not call SetDefaultDir() — the location of the error log file is determined as follows:
      &#0009;The SetDefault() location, if one has been set
      &#0009;Otherwise, the current Windows directory
      If you set the DefaultDir entry to a value other than its initial default (DefaultDir=), this setting determines the location of the error log file for this, and all other X# applications.
      If you call SetDefaultDir(), it overrides the DefaultDir entry for the current application, using the specified location.
    </remarks>
    <example>
      This example uses SetDefaultDir() to change the set and query the current default drive and directory:
      <code language="X#">
        Function Start()
        &#0009;SetDefaultDir("c:\errfiles")
        &#0009;...
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetDefaultDir'>GetDefaultDir</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDefault'>SetDefault</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetErrorLog'>SetErrorLog</seealso>
  </setdefaultdir>
  <setdeleted>
    <summary>
      Return and optionally change the setting that determines whether to ignore or include records that are marked for deletion.
    </summary>

    <param name="lNewSetting">
      TRUE ignores deleted records; FALSE processes deleted records.<br/>
      The initial default is FALSE.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, SetDeleted() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetDeleted() toggles automatic filtering of records marked for deletion in all work areas.  When TRUE is specified, most commands ignore deleted records.<br/>
      If, however, you refer to a record by record number (GOTO or any command that supports the RECORD scope), the record is not ignored, even if it is marked for deletion.<br/>
      Additionally, TRUE has no effect on INDEX or reindexing.
      Note:  RECALL ALL honors SetDeleted() and does not recall any records.
      <note type="tip">
        Filtering deleted records in a single work area:<br/>
        To confine the filtering of deleted records to a particular work area, select the work area, then set the filter to !Deleted().
      </note>
    </remarks>
    <example>
      This example illustrates the effect of using SetDeleted():
      <code language="X#">
        USE sales NEW
        ? LastRec()&#0009;&#0009;&#0009;&#0009;// 84
        DELETE RECORD 4
        COUNT TO nCount
        ? nCount&#0009;&#0009;&#0009;&#0009;&#0009;// 84
        SetDeleted(TRUE)
        COUNT TO nCount
        ? nCount&#0009;&#0009;&#0009;&#0009;&#0009;// 83
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetFilter'>DBSetFilter</seealso>
    <seealsocmd>DELETE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.Deleted'>Deleted</seealso>
    <seealsocmd>RECALL</seealsocmd>
  </setdeleted>
  <setdigit>
    <summary>
      Return and optionally change the setting that determines the number of digits that will be shown to the left of the decimal point when a number is displayed.
    </summary>

    <param name="nNewSetting">
      The number of digits to show.<br/>
      The initial default is 10.<br/>
      A negative value indicates that only the significant whole digits to the left of the decimal point (the mantissa) are returned.<br/>
      Any right padding is also suppressed.
    </param>
    <returns>
      If <paramref name="nNewSetting" /> is not specified, SetDigit() returns the current setting.<br/>
      If <paramref name="nNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetDigit() and SetDigitFixed() can be used together to control the way digits are displayed:
      &#0009;When SetDigitFixed() is TRUE, display of numeric output is fixed according to the SetDigit() value.
      &#0009;When SetDigitFixed() is FALSE, numeric output displays according to the default rules for numeric display.
      To provide finer control of numeric display, you can use the PICTURE clause of @...SAY, @...GET, and the Transform() function.
      A -1 for <paramref name="nNewSetting" />  implies that only significant whole digits to the left of the decimal are to be displayed (any leading zeros will be suppressed.)
      <note type="tip">
        SetDigit() affects only the display format of numbers, not the actual numeric precision of calculations.
      </note>
    </remarks>
    <example>
      This example shows typical uses of SetDigit():
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL nSaveDigit AS SHORTINT
        &#0009;? 1234&#0009;&#0009;&#0009;&#0009;// 1234
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Initial setting is 10 digits
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Number is displayed right justified
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Save current setting, then reset to 5 digits
        &#0009;nSaveDigit := SetDigit(5)
        &#0009;? 1234&#0009;&#0009;&#0009;&#0009;//  234
        &#0009;? 1234.567&#0009;&#0009;&#0009;&#0009;//  1234.567
        &#0009;? 123456&#0009;&#0009;&#0009;&#0009;// *****
        &#0009;SetDigit(nSaveDigit)&#0009;&#0009;// Restore the old setting
        &#0009;? 1234&#0009;&#0009;&#0009;&#0009;//  1234
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDigitFixed'>SetDigitFixed</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetFixed'>SetFixed</seealso>
  </setdigit>
  <setdigitfixed>
    <summary>
      Return and optionally change the setting that fixes the number of digits used to display numeric output.
    </summary>

    <param name="lNewSetting">
      TRUE fixes the number of digits displayed.  FALSE leaves the number of digits displayed unfixed.<br/>
      The initial default is FALSE.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, SetDigitFixed() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetDigit() and SetDigitFixed() can be used together to control the way digits are displayed:
      &#0009;When SetDigitFixed() is TRUE, display of numeric output is fixed according to the SetDigit() value.
      &#0009;When SetDigitFixed() is FALSE, numeric output displays according to the default rules for numeric display.
      <note type="tip">
        SetDigitFixed() affects only the display format of numbers, not the actual numeric precision of calculations.
      </note>
    </remarks>
    <example>
      This example uses SetDigitFixed() to start fixing the number of digits displayed at the beginning of a routine and stop fixing them at the end of the routine:
      <code language="X#">
        LOCAL lSDFSetting AS LOGIC
        lSDFSetting := SetDigitFixed(TRUE)
        MyFunc()
        SetDigitFixed(lSDFSetting)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDigit'>SetDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetFixed'>SetFixed</seealso>
  </setdigitfixed>
  <setenv>
    <summary>
      Update or replace the contents of a DOS environment variable.
    </summary>

    <param name="cVar">The environment variable to be modified.</param>
    <param name="cValue">The new value to assign to the environment variable.</param>
    <param name="lAppend">Logical value indicating whether the new value should be appended to the old value (TRUE) or if it should replace the old value (FALSE).</param>
    <returns>
      TRUE if successful; otherwise FALSE.
    </returns>
    <remarks>
      SetEnv() lets you either append or replace a DOS environment variable from within an application.  Typically this is configuration information-- including path names--that describes the location of files (database, index, label, or reports).
      Note:  Instead of using environment variables for configuring your application, you may want to consider using registry settings.
    </remarks>
    <example>
      These examples modify the DOS PATH:
      <code language="X#">
        ? SetEnv("PATH","D:\CAVO2x\BIN", .F.)  //Overwrites PATH
        ? GetEnv("PATH")
        ? SetEnv("PATH", "C:\MyApp", .T.)  //Appends to the end of PATH
        ? GetEnv("PATH")
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetEnv'>GetEnv</seealso>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegInt'>QueryRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegString'>QueryRTRegString</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegInt'>SetRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegString'>SetRTRegString</seealso>
  </setenv>
  <setepoch>
    <summary>
      Return and optionally change the setting that determines how dates without century digits are interpreted.
    </summary>

    <param name="nNewSetting">
      Specifies the base year of a 100-year period in which all dates containing only two year digits are assumed to fall.<br/>
      The initial default is 1900, causing dates with no century digits to be interpreted as falling within the twentieth century.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, SetEpoch() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetEpoch() is an environment function that determines the interpretation of date strings containing only two year digits.  When such a string is converted to a date value, its year digits are compared with the year digits of <paramref name="nNewSetting" />.<br/>
      If the year digits in the date are greater than or equal to the year digits of <paramref name="nNewSetting" />, the date is assumed to fall within the same century as <paramref name="nNewSetting" />.<br/>
      Otherwise, the date is assumed to fall in the following century.
    </remarks>
    <example>
      This example shows the effects of SetEpoch():
      <code language="X#">
        SetDateFormat("mm/dd/yyyy")
        ? CTOD("05/27/1904")&#0009;&#0009;// 05/27/1904
        ? CTOD("05/27/67")&#0009;&#0009;// 05/27/1967
        ? CTOD("05/27/04")&#0009;&#0009;// 05/27/1904
        SetEpoch(1960)
        ? CTOD("05/27/1904")&#0009;&#0009;// 05/27/1904
        ? CTOD("05/27/67")&#0009;&#0009;// 05/27/1967
        ? CTOD("05/27/04")&#0009;&#0009;// 05/27/2004
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CToD'>CToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToC'>DToC</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToS'>DToS</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetCentury'>SetCentury</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDateCountry'>SetDateCountry</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDateFormat'>SetDateFormat</seealso>
    <seealso cref='O:XSharp.RT.Functions.Today'>Today</seealso>
    <seealso cref="F:XSharp.Set.Epoch" />
    <seealso cref="F:XSharp.Set.EpochYear" />
    <seealso cref="F:XSharp.Set.EpochCent" />
    <seealso cref="P:XSharp.RuntimeState.EpochCent" />
    <seealso cref="P:XSharp.RuntimeState.EpochYear" />
    <seealso cref="P:XSharp.RuntimeState.Epoch" />
  </setepoch>
  <seterrorlog>
    <summary>
      Return and optionally change the setting that determines whether error information is written to the error log file by the default runtime error handler.
    </summary>

    <param name="lNewSetting">
      TRUE causes error information to be written to a text file, known as a X# error log file.  FALSE suppresses the recording of errors in the error log file.<br/>

      &#0009;If the ErrorLog entry in the X# section of WIN.INI is not present, an entry of ErrorLog=1 will be written, setting the initial default to TRUE; if this entry is set to 0, the initial default is FALSE.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, SetErrorLog() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetErrorLog() gives you a way to keep track of errors that occur in an application at runtime.<br/>
      If it is set to TRUE and your application generates one or more errors when executed, the default error handler writes error information to an error log file named VOERROR.LOG.
      If the ErrorLogAppend entry in the X# section of WIN.INI is not present, an entry of ErrorLogAppend=0 will be written, causing the error log file to be created anew for each application run.<br/>
      If this entry is set to 1, the error information is appended to the existing error log file.<br/>
      This feature is useful if there are multiple applications running simultaneously on the same computer.  In either case, the error log file is created if it does not exist.
      The location of the error log file is controlled by SetDefaultDir(), which you can refer to for more information.
      Although writing error information to a file is normally useful, in some situations (such as when you are limited by network create rights, the maximum number of open files, shortage of disk space, or insufficient directory entries) you must use SetErrorLog() to prevent the system from writing to an error file.
    </remarks>
    <example>
      This example sets SetErrorLog() to FALSE and saves the previous setting:
      <code language="X#">
        lSaveErrorLog := SetErrorLog(FALSE)
        MyFunc()
        SetErrorLog(lSaveErrorLog)
      </code>
    </example>
    <seealsocmd>SetDefaultDir</seealsocmd>
  </seterrorlog>
  <setexact>
    <summary>
      Toggles an exact match for character string comparisons.
    </summary>

    <param name="lNewSetting">
      TRUE causes strings to be compared for length and value; FALSE causes strings to be compared by length and position only. The initial default is FALSE.<br/>

      &#0009;This function is equivalent to the == operator for string evaluation and is preferred for most string evaluations.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, SetExact() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetExact() returns and optionally sets the default string comparison methodology.
      SetExact() is a compatibility function and not recommended.
    </remarks>
    <example>
    </example>
    <seealsocmd>SET EXACT</seealsocmd>
  </setexact>
  <setexclusive>
    <summary>
      Return and optionally change the setting that determines whether to open database files in exclusive or shared mode.
    </summary>

    <param name="lNewSetting">
      TRUE causes database files to be opened in exclusive (nonshared) mode; FALSE causes database files to be opened in shared mode.<br/>
      The initial default is TRUE.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, SetExclusive() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetExclusive() determines whether a USE command specified without the EXCLUSIVE or SHARED clause automatically opens database, memo, and index files as EXCLUSIVE.  When database files are opened as EXCLUSIVE, other users cannot use them until they are closed.  In this mode, file and record locks are unnecessary.
      When TRUE is specified, all database and associated files open in a nonshared (exclusive) mode unless the USE command is specified with the SHARED clause.<br/>
      Use this only for operations that absolutely require exclusive use of a database file, such as PACK, REINDEX, and ZAP.
      When FALSE is specified, all files are open in shared mode unless the USE command is specified with the EXCLUSIVE clause.
      Do not use SetExclusive() to control access by other users to records and files.  You can control access programmatically using RLock() and FLock().
      SetExclusive() is a compatibility function and not recommended.<br/>
      It is superseded by the EXCLUSIVE and SHARED clauses of the USE command.

      <note type="tip">
        Error handling:<br/>
        Attempting to use a database file already opened as exclusive by another user generates a runtime error and sets NetErr() to TRUE.<br/>
        After control returns to the point of error, you can test NetErr() to determine whether the USE command failed.
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Flock'>FLock</seealso>
    <seealso cref='O:XSharp.Core.Functions.NetErr'>NetErr</seealso>
    <seealso cref='O:XSharp.RT.Functions.RLock'>RLock</seealso>
    <seealsocmd>USE</seealsocmd>
  </setexclusive>
  <setfdatetime>
    <summary>
      Reset the date and time stamps of a File.
    </summary>

    <param name="cFile">The name of the file (optionally including drive and directory information) to modify.</param>
    <param name="dDate">
      The new date to use for the date stamp.<br/>
      If not specified, the default is Today().
    </param>
    <param name="cTime">
      The new time string to use for the time stamp.<br/>
      If not specified, the default is Time().
    </param>
    <returns>
      TRUE if successful; otherwise FALSE.
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </setfdatetime>
  <setfieldstore>
    <summary>
      Return and optionally change the setting that determines whether assignments are made to fields or to memory variables.
    </summary>

    <param name="lNewSetting">
      TRUE turns field assignment on; FALSE turns it off.<br/>
      The initial default is FALSE.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, SetFieldStore() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      If there are PRIVATE or PUBLIC variables that have the same name as a database field in the current work area, assignments are made to the memory variables (PRIVATE, PUBLIC) unless SetFieldStore() is set to TRUE.
    </remarks>
    <example>
      This example shows the effect of SetFieldStore() on a private variable:
      <code language="X#">
        PRIVATE LName
        LName := "MyMemVar"
        USE Test
        ? Test-&gt;LName&#0009;&#0009;&#0009;&#0009;&#0009;// OldField
        // This refers to the PRIVATE variable called LName:
        ? LName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// MyMemVar
        // Default setting is FALSE
        ? SetFieldStore()&#0009;&#0009;&#0009;&#0009;// FALSE
        // Since SetFieldStore() is FALSE, this will
        // assign a value to the PRIVATE memory variable called LName
        LName := "NewVal"
        ? Test-&gt;LName&#0009;&#0009;&#0009;&#0009;&#0009;// OldField
        ? LName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// NewVal
        ? SetFieldStore(TRUE)
        &#0009;// FALSE (returns previous setting)
        // Since SetFieldStore() is TRUE, this will
        // assign a value to the database field called LName
        LName := "NewestVal"
        ? Test-&gt;LName&#0009;&#0009;&#0009;&#0009;&#0009;// NewestVal
        // This still refers to the PRIVATE variable called LName:
        ? LName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// NewVal
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias'>Alias</seealso>
    <seealsocmd>REPLACE</seealsocmd>
  </setfieldstore>
  <setfixed>
    <summary>
      Return and optionally change the setting that fixes the number of decimal digits used to display numbers.
    </summary>

    <param name="lNewSetting">TRUE displays numeric output using the current SetDecimal() setting.  FALSE ignores SetDecimal(), allowing the operation or function to determine the number of decimal places to display, according to the default rules for numeric display.</param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, SetDecimal() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      <note type="tip">
        SetFixed() affects only the display format of numbers, not the actual numeric precision of calculations.
      </note>
    </remarks>
    <example>
      This example uses SetFixed() to start fixing the number of decimal digits displayed at the beginning of a routine and stop fixing it at the end of the routine:
      <code language="X#">
        LOCAL lSFSetting AS LOGIC
        lSFSetting := SetFixed(TRUE)
        MyFunc()
        SetFixed(lSFSetting)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FloatFormat'>FloatFormat</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDigitFixed'>SetDigitFixed</seealso>
  </setfixed>
  <setfloatdelta>
    <summary>
      Return and optionally change the setting that determines the point at which 2 floating point numbers would be considered equal even though they are different.
    </summary>

    <param name="nNewSetting">The acceptable difference between 2 numbers.</param>
    <returns>
      If <paramref name="nNewSetting" /> is not specified, SetFloatDelta() returns the current setting.<br/>
      If <paramref name="nNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetFloatDelta() determines the maximum amount by which 2 floating point numbers could be different and yet still be considered equal.  Two numbers might be considerably different, but the difference will be ignored if the setting for SetFloatDelta() is larger than the difference between the 2 numbers.
    </remarks>
    <example>
      This example uses SetFloatDelta() to change the result of numeric comparisons:
      <code language="X#">
        ? 1.231 =  1.23&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        ? 1.33 = 1.23&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        SetFloatDelta(0.01)&#0009;&#0009;&#0009;&#0009;// Delta at 0.01
        ? 1.231 = 1.23&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE since 1.231-1.23 &lt; 0.01
        ? 1.33 = 1.23&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE since 1.33-1.23 &gt; 0.01
        ? 1.4 &lt; 1.40123456&#0009;&#0009;&#0009;&#0009;// FALSE
        ? 1.4 &lt; 1.42&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Between'>Between</seealso>
  </setfloatdelta>
  <setrefresh>
    <summary>
      Retrieve and optionally set the time for which the RDD system caches data.
    </summary>

    <param name="nNewSetting">The acceptable difference between 2 numbers.</param>
    <returns>
      If <paramref name="nNewSetting" /> is not specified, SetRefresh() returns the current setting.<br/>
      If <paramref name="nNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetRefresh() determines the time in seconds that the RDD system keeps data in memory before checking for changes by other users.
    </remarks>
    <seealso cref='O:XSharp.Core.Functions.SetRefresh'>SetRefresh</seealso>
  </setrefresh>
  <setinternational>
    <summary>
      Return and optionally change the setting that determines the international mode for the application.
    </summary>

    <param name="symNewSetting">
      The international mode to use.<br/>
      The available modes are #Windows (the default) and #Clipper.
    </param>
    <returns>
      If <paramref name="symNewSetting" /> is not specified, SetInternational() returns the current setting.<br/>
      If <paramref name="symNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetInternational() allows X# to operate in different international modes.<br/>
      The #Clipper mode is provided for compatibility with CA-Clipper applications and uses an internationalization routine defined in the nation module (VO28NAT.DLL).<br/>
      The #Windows mode uses international services provided by Windows.
      Therefore, if an application uses the #Clipper international mode, it will behave the same on all machines.  Thus, to achieve a different internationalization routine, you would need a specialized version of VO28NAT.DLL.  On the other hand, if the application uses the #Windows international mode, it will behave differently from machine to machine, depending on information defined in the International settings of the Control Panel.
      Changing SetInternational() automatically changes SetCollation() so that the two settings are the same.  SetInternational() also determines the initial defaults for the functions listed in the table below and resets them each time you call the function.<br/>
      For SetInternational(#Windows), the settings are taken from the corresponding International settings in the Control Panel:
      Function&#0009;SetInternational(#Clipper) Default
      GetAMExt()/SetAMExt()&#0009;NULL_STRING
      GetPMExt()/SetPMExt()&#0009;NULL_STRING
      SetAMPM()&#0009;24-hour format
      SetDateFormat()&#0009;mm/dd/yy&#0009;
      SetDecimal()&#0009;2&#0009;
      SetDecimalSep()&#0009;Period (.)&#0009;
      SetTimeSep()&#0009;Colon (:)&#0009;
      SetThousandSep()&#0009;Comma (,)&#0009;
      <note type="tip">
        Leading zeros in time strings:<br/>
        The leading zeros International setting in the Control Panel is ignored.  Leading zeros are always displayed for time strings.
        Decimal and thousand separators in picture clauses:<br/>
        The comma as the thousands separator and the period used as the decimal separator in picture clauses is unaffected by this setting.<br/>
        Therefore, your source code will not change based on the status of SetInternational().  Note that picture clauses are defined with the @...SAY...GET command, the Transform() function, or the FieldSpec:Picture property.
        @E picture function:<br/>
        The @E picture function is ignored if SetInternational(#Windows) is in effect.
      </note>
    </remarks>
    <example>
      This example sets the international mode to #Clipper in the application's startup routine in order to maintain backward compatibility with CA-Clipper applications.  Note that SetCollation() is also changed to #Clipper as a result:
      <code language="X#">
        METHOD Start() CLASS App
        &#0009;...
        &#0009;SetInternational(#Clipper)
        &#0009;...
      </code>
    </example>
    <seealsocmd>SET INTERNATIONAL</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetCollation'>SetCollation</seealso>
  </setinternational>
  <setjmp>
    <summary>
      Save the stack environment.
    </summary>

    <param name="strucMark">A structure in which the environment will be stored.</param>
    <returns>
      Zero (0), when called to save the stack environment.  When SetJmp() is invoked as a result of a LongJmp() call, it returns the second argument of LongJmp().
    </returns>
    <remarks>
      SetJmp() causes the current stack environment (which includes stack-based variables and the return address for SetJmp()) to be saved in <paramref name="strucMark" />.  <paramref name="strucMark" /> is defined as follows:
      <code language="X#">
        STRUCTURE _JMP_BUF
        &#0009;MEMBER pJumpAddr<br/>
        AS PTR
        &#0009;MEMBER nEBP       AS DWORD
        &#0009;MEMBER nESP       AS DWORD
        &#0009;MEMBER pKIDStack<br/>
        AS PTR
        &#0009;MEMBER nDASOff  <br/>
        AS DWORD
        &#0009;MEMBER nCallStack AS DWORD
      </code>
      A subsequent call to LongJmp() restores the stack environment and resumes execution as though SetJmp() had returned the second argument of LongJmp().
      SetJmp() and LongJmp() provide you with a mechanism to go to a particular line of code.<br/>
      They are typically used to simulate a "return to master" command or to branch out to error recovery code.
    </remarks>
    <example>
      This example shows how LongJmp() and SetJmp() work together to save and restore the stack environment:
      <code language="X#">
        STATIC GLOBAL strucMark IS _JMP_BUF
        FUNCTION Start()
        &#0009;LOCAL siJMPRetVal AS SHORTINT
        &#0009;siJMPRetVal :=SetJmp(@strucMark)
        &#0009;? siJMPRetVal
        &#0009;IF siJMPRetVal <paramref name="" />0
        &#0009;&#0009;? "LongJmp() got me here", siJMPRetVal
        &#0009;&#0009;RETURN FALSE
        &#0009;ENDIF
        &#0009;LongJmp(@strucMark, 1)|
        &#0009;? "You will never see this on the screen."
        &#0009;RETURN TRUE
      </code>
      Here is another example where a LongJmp() is issued if a an error is detected:
      <code language="X#">
        STATIC GLOBAL strucMark IS _JMP_BUF
        FUNCTION Start()
        &#0009;LOCAL siJMPRetVal AS SHORTINT
        &#0009;siJMPRetVal := SetJmp(@strucMark)
        &#0009;IF siJMPRetVal <paramref name="" />0
        &#0009;&#0009;? "LongJmp() was here with", siJMPRetVal
        &#0009;&#0009;RETURN FALSE
        &#0009;ENDIF
        &#0009;IF .NOT. FILE("voerror.log")
        &#0009;&#0009;LongJmp(@strucMark, 1)
        &#0009;ENDIF
        &#0009;SUBFUNC()
        &#0009;RETURN TRUE
        FUNCTION Subfunc
        &#0009;LOCAL cLog AS STRING
        &#0009;cLog := MEMOREAD("voerror.log")
        &#0009;IF SLen(cLog) =MAX_ALLOC
        &#0009;&#0009;LongJmp(@strucMark, 2)
        &#0009;ENDIF
        &#0009;RETURN 0
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.LongJmp'>LongJmp</seealso>
  </setjmp>
  <setmath>
    <summary>
      Return and optionally change the setting that determines the internal operational characteristics of the underlying floating-point system.
    </summary>
    <returns>
      If <paramref name="nNewSetting" /> is not specified, SetMath() returns the current setting.<br/>
      If <paramref name="nNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
	SetMath is a compatibility function. It does not really do anything in X#.
    </remarks>
    <seealso cref='O:XSharp.Core.Functions.SetCpu'>SetCPU</seealso>
  </setmath>
  <setnatdll>
    <summary>
      Activate a new DLL for nation-dependent operations and messages.
    </summary>

    <param name="cNewDLL">The name of the new DLL to use.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      The default library for nation-dependent operations is VO28NAT.DLL.  SetNatDLL() disables the default DLL and loads the specified DLL <paramref name="cNewDLL" /> which is active until the next call to SetNatDLL().
    </remarks>
    <example>
      This example sets DLL CAVONT20.GER for nation-dependent operations:
      <code language="X#">
        ? GetNatDLL()&#0009;&#0009;&#0009;&#0009;// VO28NAT.DLL
        ? SetNatDLL("GERMAN.DLL")&#0009;&#0009;// .T.
        ? GetNatDLL()&#0009;&#0009;&#0009;&#0009;// GERMAN.DLL
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetNatDLL'>GetNatDLL</seealso>
  </setnatdll>
  <setpath>
    <summary>
      Change the setting that determines the X# search path for opening files.
    </summary>

    <param name="cPathList">
      The paths X# uses when searching for a file not found in the default directory.<br/>
      A path is a pointer to a directory.<br/>
      It consists of an optional drive letter and colon, followed by a list of directories from the root to the desired directory separated by backslash (\) characters.<br/>
      A path list is the sequence of paths to search, each separated by a comma or semicolon.<br/>

      &#0009;If omitted, the path list is released so that X# searches only the default directory.  (Use GetCurPath() to get the current setting.)
    </param>
    <returns>
    </returns>
    <remarks>
      SetPath() allows commands and functions that open database and associated files to find and open existing files in another drive and/or directory.<br/>
      It does this by specifying a path list to search if a referenced file cannot be found in the default directory.
      When you attempt to access a file without specifying its path, X# first searches the default drive and directory.<br/>
      The default drive and directory are established by Windows when your application is loaded, or, during execution, by the SetDefault() function.<br/>
      If the file is not found, X# then searches each path in the specified path list until the first occurrence of the file is found.
      To create new files in another drive or directory, use SetDefault() or explicitly declare the path when specifying the new file name.
      Note:  Certain commands and functions that open files do not respect the SetPath() setting.<br/>
      These cases are noted explicitly in the documentation for those commands and functions.
    </remarks>
    <example>
      This example sets two paths for opening files:
      <code language="X#">SetPath("a:\inventory;b:\vendors")</code>
      This example configures a path setting at runtime by passing a DOS environment variable to a program, retrieving its value with GetEnv(), then setting the path with this value.<br/>
      For example, in DOS:
      <code language="X#">SET VO_PATH = c:\apps\data;c:\apps\progs</code>
      Later in the configuration section of your application prograO:
      <code language="X#">SetPath(GetEnv("VO_PATH"))</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetCurPath'>GetCurPath</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDefault'>SetDefault</seealso>
  </setpath>
  <setpmext>
    <summary>
      Set the evening extension for time strings in 12-hour format.
    </summary>

    <param name="cPMExt">
      The extension to be used for time strings that occur in the evening hours.<br/>
      This string can be up to eight characters in length — additional characters are ignored.
    </param>
    <returns>
    </returns>
    <remarks>
      Time strings formatted using the 12-hour time format have an extension to specify if the time is in the morning or the evening.  SetPMExt() allows you to programmatically set the extension identifying evening time strings (that is, those between 12:00:00 noon and just before 12:00:00 midnight).<br/>
      A typical extension for evening time strings is "PM", which is how the function derives its name.
      The initial default for the evening extension is affected by SetInternational(), which you can refer to for more information.<br/>
      Use GetPMExt() to retrieve the current value of this setting.
      Note:<br/>
      If SetInternational(#Windows) is in effect, the evening extension is also displayed as part of the 24-hour time format.<br/>
      This is a Windows standard that is not specific to X#.
    </remarks>
    <example>
      This example turns on the 12-hour time format and displays a time string using two different extensions:
      <code language="X#">
        SetAMPM(TRUE)
        SetPMExt(" pm")
        ? TString(47000)&#0009;&#0009;// 01:03:20 pm
        SetAMExt(" evening")
        ? TString(47000)&#0009;&#0009;// 01:03:20 evening
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetPMExt'>GetPMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAMExt'>SetAMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAmPm'>SetAMPM</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
    <seealso cref='O:XSharp.RT.Functions.TString'>TString</seealso>
  </setpmext>
  <setpos>
    <summary>
      Move the cursor to a new position on the terminal window.
    </summary>

    <param name="iRow">The new row position of the cursor</param>
    <param name="iCol">The new column position of the cursor</param>
    <returns>
    </returns>
    <remarks>
      SetPos() moves the cursor to the specified location, and updates Row() and Col() with the new cursor position.
    </remarks>
    <example>
      This example shows the relationship between the DevPos() function and the @...SAY command:
      <code language="X#">
        SetPos(10, 10)
        ? Qout("Hello there")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Row'>Row</seealso>
    <seealso cref='O:XSharp.RT.Functions.Col'>Col</seealso>
  </setpos>
  <setrtregint>
    <summary>
      Save a numeric value to the Registry.
    </summary>

    <param name="cSubkey">The subkey under which you want to add the number.</param>
    <param name="cKey">The key under which you want to add the number.</param>
    <param name="dwKeyValue">The key value you want to add to the Registry.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      SetRTRegInt() can be used to save runtime settings into the Registry.<br/>
      The value will be saved as <paramref name="cKey" /> = <paramref name="dwKeyValue" /> under the following key:
      HKEY_CURRENT_USER
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      and optionally under
      HKEY_LOCAL_MACHINE
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      If <paramref name="cSubkey" /> is empty (NULL_STRING), the Registry entry will be saved without a subkey under:
      HKEY_LOCAL_MACHINE
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      SetRtRegInt()  only writes to HKEY_LOCAL_MACHINE if the key already exists (and ignores write errors). It always writes to HKEY_CURRENT_USER as well. The return value reflects the result of the write operation to HKEY_CURRENT_USER
    </remarks>
    <example>
      This example adds the entry LOCK_RETRIES = 10 to the Registry under the subkey SSA:
      <code language="X#">
        SetRTRegInt("SSA", "LOCK_RETRIES", 10")
        ...
        nRetries := QueryRTRegInt("SSA", "LOCK_RETRIES")
        DO WHILE nRetries &gt; 0
        &#0009;IF RLock()
        &#0009;&#0009;EXIT
        &#0009;ENDIF
        &#0009;nRetries--
        ENDDO
        IF nRetries = 0
        &#0009;// Error message
        ENDIF
        ...
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegInt'>QueryRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegString'>QueryRTRegString</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegString'>SetRTRegString</seealso>
  </setrtregint>
  <deletertregkey>
    <summary>
      Delete a subtree from the VO registry branches
    </summary>

    <param name="cSubkey">The subkey that you want to delete.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      DeleteRtRegKey() can be used to clear settings into the Registry.<br/>
      it will clear the following subkeys:
      HKEY_CURRENT_USER
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      and optionally under
      HKEY_LOCAL_MACHINE
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      If <paramref name="cSubkey" /> is empty (NULL_STRING), the Registry entry will be saved without a subkey under:
      HKEY_LOCAL_MACHINE
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
    </remarks>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegInt'>QueryRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegString'>QueryRTRegString</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegString'>SetRTRegString</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegInt'>SetRTRegInt</seealso>
  </deletertregkey>
  <setrtregstring>
    <summary>
      Save a string value to the Registry.
    </summary>

    <param name="cSubkey">The subkey under which you want to add the string.</param>
    <param name="cKey">The key under which you want to add the string.</param>
    <param name="cValue">The key value you want to add to the Registry.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      SetRTRegString() can be used to save runtime settings into the Registry.<br/>
      The value will be saved as <paramref name="cKey" /> = <paramref name="dwKeyValue" /> under the following key:
      HKEY_CURRENT_USER
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      and optionally under
      HKEY_LOCAL_MACHINE
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      If <paramref name="cSubkey" /> is empty (NULL_STRING), the Registry entry will be saved without a subkey under:
      HKEY_LOCAL_MACHINE
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      SetRTRegString()  only writes to HKEY_LOCAL_MACHINE if the key already exists (and ignores write errors). It always writes to HKEY_CURRENT_USER as well. The return value reflects the result of the write operation to HKEY_CURRENT_USER
    </remarks>
    <example>
      This example adds the entry APP_DIR = \SSA\ to the Registry under the subkey SSA:
      <code language="X#">
        SetRTRegString("SSA", "APP_DIR", "\SSA\")
        ...
        cDbf:=QueryRTRegString("SSA","APP_DIR") + "test.dbf"
        USE (cDbf)
        ...
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegInt'>QueryRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegString'>QueryRTRegString</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegInt'>SetRTRegInt</seealso>
  </setrtregstring>
  <setscience>
    <summary>
      Return and optionally change the setting that displays numbers in scientific notation.
    </summary>

    <param name="lNewSetting">
      TRUE turns scientific notation on; specifying FALSE turns it off.<br/>
      The initial default is FALSE.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, SetScience() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetScience() is an environment function that allows you to display numbers in scientific notation.<br/>
      Any number can be shown in scientific notation where a number is represented by a mantissa (its whole digits) multiplied by 10 raised to the power of an exponent.
    </remarks>
    <example>
      This example uses SetScience() to show numbers in scientific notation:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL lSNSetting AS LOGIC
        &#0009;lSNSetting := SetScience(TRUE)
        &#0009;? 1234567890
        &#0009;? 12345.678
        &#0009;SetScience(lSNSetting)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FloatFormat'>FloatFormat</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetFixed'>SetFixed</seealso>
  </setscience>
  <setsoftseek>
    <summary>
      Return and optionally change the setting that determines whether a seek operation will find a close match when no exact match is found.
    </summary>

    <param name="lNewSetting">
      TRUE moves the record pointer to the next record with a higher key after a failed order search; FALSE moves the record point to the end of the file after a failed order search.<br/>

      &#0009;The initial default is FALSE.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, SetSoftSeek() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetSoftSeek() enables relative seeking, a method of searching an order and returning a record even if there is no match for a specified key.
      When TRUE is specified and a match for a seek operation (for example, the SEEK command or DBSeek() function) is not found, the record pointer is set to the next logical record with a higher key value than the seek argument.  Records not visible (because of DBSetFilter(), SetDeleted(), or a conditional controlling order) are skipped when searching for the next higher key value.<br/>
      If there is no record with a higher key value, the record pointer is positioned at LastRec() + 1, EOF() returns TRUE, and Found() returns FALSE.  Found() returns TRUE only if the record is actually found.<br/>
      It never returns TRUE for a relative find.
      When FALSE is specified and a seek operation is unsuccessful, the record pointer is positioned at LastRec() + 1, EOF() returns TRUE, and Found() returns FALSE.
    </remarks>
    <example>
      This example starts relative seeking at the beginning of a routine and stops it at the end of the routine:
      <code language="X#">
        LOCAL lSSSetting AS LOGIC
        lSSSetting := SetSoftSeek(TRUE)
        SEEK UPPER("CarlM")
        ? Found()&#0009;&#0009;&#0009;// FALSE
        ? EOF()&#0009;&#0009;&#0009;// FALSE
        ? cName&#0009;&#0009;&#0009;// CarlT
        SetSoftSeek(lSSSetting)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrder'>DBSetOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetRelation'>DBSetRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.Found'>Found</seealso>
    <seealsocmd>SEEK</seealsocmd>
  </setsoftseek>
  <setthousandsep>
    <summary>
      Return and optionally change the setting that determines the thousands separation character to be used in numeric-to-string conversion functions.
    </summary>

    <param name="nNewSetting">
      An ASCII code representing the new thousands separator.<br/>
      The initial default depends on SetInternational(), which you can refer to for more information.
    </param>
    <returns>
      If <paramref name="nNewSetting" /> is not specified, SetThousandSep() returns the current setting.<br/>
      If <paramref name="nNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      Normally, numeric values are displayed without thousands separators, unless you explicitly specify the number using pictured output.  Pictured output is achieved using a picture clause, which can be defined with the @...SAY...GET command, the Transform() function, or the FieldSpec:Picture property.
      Note:<br/>
      The comma character used in your source code to represent the thousands separator in picture clauses is unaffected by this setting, just as the period used to represent the decimal separator is unaffected by SetDecimalSep().
      Therefore, your source code will not change based on these settings, as illustrated in the example below.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetDecimalSep'>SetDecimalSep</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
  </setthousandsep>
  <settimesep>
    <summary>
      Change the setting that determines the separation character to be used in time strings.
    </summary>

    <param name="dwNewSetting">
      The ASCII code for a character to be used as the time string separator (for example, periods or dashes).<br/>
      The initial default is a colon (:), which is ASCII code 58.  (Use GetTimeSep() to get the current setting.)
    </param>
    <returns>
      The previous setting.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example changes the way times are displayed from 24:00:00 to 24.00.00:
      <code language="X#">
        FUNCTION Start()
        &#0009;SetTimeSep(Asc("."))
        &#0009;QOut(Time())&#0009;&#0009;&#0009;// 24.00.00
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Asc'>Asc</seealso>
    <seealso cref='O:XSharp.Core.Functions.Chr'>Chr</seealso>
    <seealso cref='O:XSharp.Core.Functions.GetTimeSep'>GetTimeSep</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDecimalSep'>SetDecimalSep</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
  </settimesep>
  <setunique>
    <summary>
      Return and optionally change the setting that determines whether to include unique record keys in an order.
    </summary>

    <param name="lNewSetting">
      TRUE creates orders with unique records only; FALSE creates orders with all records, even if their keys are the same.<br/>
      The initial default is FALSE.
    </param>
    <returns>
      If <paramref name="lNewSetting" /> is not specified, SetUnique() returns the current setting.<br/>
      If <paramref name="lNewSetting" /> is specified, the previous setting is returned.
    </returns>
    <remarks>
      SetUnique() is a database function that controls whether orders are created with uniqueness as an attribute.  When TRUE is specified, new orders are created including only unique keys.<br/>
      This is the same as creating an order with the INDEX...UNIQUE command.
      The manner in which nonunique keys are handled in a unique order is determined by the RDD.<br/>
      The standard behavior in most DBF-based RDDs is to include a record reference to a particular key value only once.  Thus, if, during the creation or update of a unique order, two or more records are encountered with the same key value, only the first record is included in the order.  When the unique order is updated, reindexed, or packed, only unique records are maintained, without regard to the current SetUnique() value.
      Changing key values in a unique order has important implications.  First, if a unique key is changed to the value of a key already in the order, the changed record is lost from the order.  Second, if there is more than one instance of a key value in a database file, changing the visible key value does not bring forward another record with the same key until the order is rebuilt.
      When FALSE is specified, orders are created with all records.  Subsequent updates to the database files add all key values to the order independent of the current UNIQUE setting.
      Note that keys from deleted records are also included in the index, and may hide keys from non-deleted records.
    </remarks>
    <example>
      This example sets one routine to create orders with only records that have unique keys:
      <code language="X#">
        LOCAL lUniqueSetting AS LOGIC
        lUniqueSetting := SetUnique(TRUE)
        MyFunc()
        SetUnique(lUniqueSetting)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealsocmd>INDEX</seealsocmd>
    <seealsocmd>PACK</seealsocmd>
    <seealsocmd>REINDEX</seealsocmd>
  </setunique>
  <setwipedynspace>
    <summary>
      Set the value of WipeDynSpace.
    </summary>

    <param name="lWipe">
      The logical value for setting WipeDynSpace on and off.<br/>

      &#0009;TRUE turns it on, FALSE turns it off.<br/>

      &#0009;Note that changing this setting will be enforced the next time the garbage collecter activates.
    </param>
    <returns>
      The existing value of WipeDynSpace.
    </returns>
    <remarks>
      Allows the changing of the garbage collectors WipeDynSpace setting.
      The change made using this function will be enforced the next time the garbage collector is activated.
      Note: that this function was introduced in version 2.7 of X#. In previous versions this functionality was achieved using registry settings on each machine.
    </remarks>
    <example>
    </example>
  </setwipedynspace>
  <seval>
    <summary>
      Execute a code block for each of the individual characters in a string.
    </summary>

    <param name="cString">The string to scan.</param>
    <param name="cbBlock">The code block to execute for each character encountered.</param>
    <param name="nStart">
      The starting character.<br/>
      A negative value starts from the end.<br/>
      The default value is 1 if <paramref name="nCount" /> is positive and<br/>
      The length of <paramref name="cString" /> if <paramref name="nCount" /> is negative.
    </param>
    <param name="nCount">
      The number of characters to process from <paramref name="nStart" />.<br/>
      A negative value steps downward.<br/>
      The default is all characters to the end of the string.
    </param>
    <returns>
      A string of characters that have been processed by the code block.
    </returns>
    <remarks>
      SEval() is a character function that evaluates a code block once for each character in a string, passing the ASCII value and the character index as arguments.<br/>
      The return value of the code block is ignored.<br/>
      All characters in <paramref name="cString" /> are processed unless either the <paramref name="nStart" /> or the <paramref name="nCount" /> argument is specified.
    </remarks>
    <example>
      This example uses SEval() to extract the street number from a string containing the complete street address:
      <code language="X#">
        LOCAL cStreetNumber AS STRING
        LOCAL cAddress AS STRING
        cStreetNumber := NULL_STRING
        cAddress := "1209 West Golden Lane"
        SEval(cAddress, ;
        &#0009;&#0009;{|c| cStreetNumber += ;
        &#0009;&#0009;If(IsDigit(Chr(c)), Chr(c), NULL_STRING)})
        ? cStreetNumber&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 1209
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbEval'>DBEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.QOut'>QOut</seealso>
    <seealso cref='O:XSharp.RT.Functions.SEvalA'>SEvalA</seealso>
  </seval>
  <sevala>
    <summary>
      Execute a code block for each of the individual characters in a string, changing the contents of the argument as well as the return value.
    </summary>

    <param name="cString">The string to scan.</param>
    <param name="cbBlock">The code block to execute for each character encountered.</param>
    <param name="iStart">
      The starting character.<br/>
      A negative value starts from the end.<br/>
      The default value is 1 if <paramref name="nCount" /> is positive and<br/>
      The length of <paramref name="cString" /> if <paramref name="nCount" /> is negative.
    </param>
    <param name="iCount">
      The number of characters to process from <paramref name="iStart" />.<br/>
      A negative value steps downward.<br/>
      The default is all characters to the end of the string.
    </param>
    <returns>
      A string of characters that have been processed by the code block.
    </returns>
    <remarks>
      SEvalA() is identical to SEval() in that they both evaluate a code block once for each character of a string,
      passing the ASCII value and the character index as arguments.<br/>
      The only difference is that, while SEval()
      ignores the return value of the code block, SEvalA() assigns the return value to the original string.
      See SEval() for details.
    </remarks>
    <example>
      This example uses SEvalA() to change part of a string to uppercase:
      <code language="X#">
        LOCAL cString
        cString := "He was doa."
        ? SEvalA(cString,;
        &#0009;{|cChar| Asc(Upper(Chr(cCha-r)))}, 8, 3)
        // "He was DOA."
        ? cString&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// "He was DOA."
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEvalA'>AEvalA</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbEval'>DBEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.QOut'>QOut</seealso>
    <seealso cref='O:XSharp.RT.Functions.SEval'>SEval</seealso>
  </sevala>
  <shellautocomplete>
    <summary>
      Allow the user to select from the autosuggest list by pressing the TAB key
    </summary>

    <param name="hWnd">H</param>
    <param name="dwFlags"></param>
    <param name="SHACF_AUTOAPPEND_FORCE_OFF">Ignore the registry default and force the autoappend feature off. This flag must be used in combination with one or more of the SHACF_FILESYS* or SHACF_URL* flags.</param>
    <param name="SHACF_AUTOAPPEND_FORCE_ON">Ignore the registry value and force the autoappend feature on. The completed string will be displayed in the edit box with the added characters highlighted. This flag must be used in combination with one or more of the SHACF_FILESYS* or SHACF_URL* flags.</param>
    <param name="SHACF_AUTOSUGGEST_FORCE_OFF">Ignore the registry default and force the autosuggest feature off. This flag must be used in combination with one or more of the SHACF_FILESYS* or SHACF_URL* flags.</param>
    <param name="SHACF_AUTOSUGGEST_FORCE_ON">Ignore the registry value and force the autosuggest feature on. A selection of possible completed strings will be displayed as a drop-down list, below the edit box. This flag must be used in combination with one or more of the SHACF_FILESYS* or SHACF_URL* flags.</param>
    <param name="SHACF_DEFAULT">The default setting, equivalent to SHACF_FILESYSTEM | SHACF_URLALL. SHACF_DEFAULT cannot be combined with any other flags.</param>
    <param name="SHACF_FILESYSTEM">Include the file system.</param>
    <param name="SHACF_URLALL">Include the URLs in the users History and Recently Used lists. Equivalent to</param>
    <param name="SHACF_URLHISTORY">Include the URLs in the user's History list.</param>
    <param name="SHACF_URLMRU">Include the URLs in the user's Recently Used list.</param>
    <param name="SHACF_USETAB">Allow the user to select from the autosuggest list by pressing the TAB key. If this flag is not set, pressing the TAB key will shift focus to the next control and close the autosuggest list. If SHACF_USETAB is set, pressing the TAB key will select the first item in the list. Pressing TAB again will select the next item in the list, and so on. When the user reaches the end of the list, the next TAB key press will cycle the focus back to the edit control. This flag must be used in combination with one or more of the SHACF_FILESYS* or SHACF_URL* flags. </param>
    <returns>
    </returns>
    <remarks>
      <note type="tip">
        This will require version 5.0 or later of the shlwapi.dll
        The supported operating systems are Windows 2000, Windows NT 4.0 with Internet Explorer 5, Windows 98, Windows 95 with Internet Explorer 5
        This will require the inclusion of the OLE library or a call to CoInitialize(NULL) for AutoComplete. CoInitialize will make a call to CoUninit later.
      </note>
    </remarks>
    <example>
    </example>
    <seealsocmd>[****]</seealsocmd>
  </shellautocomplete>
  <showbitmap>
    <summary>
      Display a bitmap in a window or control.
    </summary>

    <param name="hWnd">Handle of the window or control in which you want to display the bitmap.</param>
    <param name="cFileName">The bitmap file to display.</param>
    <param name="cTitle">Caption for the window or control.</param>
    <returns>
      TRUE if successful, otherwise FALSE.
    </returns>
    <remarks>
      This function allows you to display a bitmap in a window or a control.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.StretchBitmap'>StretchBitmap</seealso>
  </showbitmap>
  <sin>
    <summary>
      Calculate the sine of a number.
    </summary>

    <param name="nNum">An angle in radians.</param>
    <returns>
      The sine of the specified angle.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses Sin() to calculate the sine of 2.7:
      <code language="X#">? Sin(2.7)&#0009;&#0009;&#0009;&#0009;// 0.43</code>
      This example finds the sine of a 60 degree angle.<br/>
      The first step is to convert 60 degrees to radians. This is done by dividing the angle by 180/PI:
      <code language="X#">? Sin(60/(180/PI))&#0009;&#0009;&#0009;// 0.87</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Cos'>Cos</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cot'>Cot</seealso>
    <seealso cref='O:XSharp.RT.Functions.Tan'>Tan</seealso>
  </sin>
  <slen>
    <summary>
      Return the length of a strongly typed string.
    </summary>

    <param name="cString">The string to count.</param>
    <returns>
      The length of a string.<br/>
      If the string is a NULL_STRING, SLen() returns 0.
    </returns>
    <remarks>
      SLen() is a typed version of Len().  See Len() for a complete description.
    </remarks>
    <example>
      This example shows how to use strong typing to determine the length of a string:
      <code language="X#">
        LOCAL cName AS STRING
        cName := "William Shakespeare"
        ? SLen(cName)&#0009;&#0009;&#0009;&#0009;&#0009;// 19
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AllTrim'>AllTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.ALen'>ALen</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszLen'>PszLen</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.Trim'>Trim</seealso>
  </slen>
  <soundex>
    <summary>
      Convert a string to Soundex form.
    </summary>

    <param name="cString">The string to convert.</param>
    <returns>
      A 4-digit string starting with an alphabetic character and ending with three digits.
    </returns>
    <remarks>
      Soundex() is a character function that indexes and searches for sound-alike or phonetic matches.<br/>
      It is used in applications where the precise spelling of character keys is not known or where there is a high probability of misspelled names.  Misspelling is common in real-time transaction systems where the data entry operator is receiving information over the telephone.  Soundex() works by bringing sound-alikes together under the same key value.  Note, however, the soundex method is not absolute.  Keys that are quite different can result in the same soundex value.
    </remarks>
    <example>
      This example builds an order using Soundex() to create the key values.<br/>
      It then searches for a value found in the Salesman field:
      <code language="X#">
        USE sales
        INDEX ON Soundex(Salesman) TO salesman
        SEEK Soundex("Smith")
        ? Found(), salesman&#0009;&#0009;&#0009;&#0009;// TRUE Smith
      </code>
      Here, a search is made for the same key as above but with a different spelling:
      <code language="X#">
        SEEK Soundex("Smythe")
        ? Found(), salesman&#0009;&#0009;&#0009;&#0009;// TRUE Smith
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealsocmd>INDEX</seealsocmd>
    <seealsocmd>LOCATE</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetSoftSeek'>SetSoftSeek</seealso>
  </soundex>
  <space>
    <summary>
      Create a string of spaces.
    </summary>

    <param name="dwSize">
      The number of spaces to return, up to a maximum of MAX_ALLOC byes.<br/>
      If <paramref name="dwSize" /> is 0, Space() returns a NULL_STRING.
    </param>
    <returns>
      A string of spaces.
    </returns>
    <remarks>
      Space() is similar to Buffer() but uses an initialization character of " ".<br/>
      If an initialization character is not needed, Buffer() is more efficient.  Space() is also the same as Replicate(" ", <paramref name="dwCount" />).
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
    <seealso cref='O:XSharp.Core.Functions.Replicate'>Replicate</seealso>
  </space>
  <splitpath>
    <summary>
      Break a path name into its components.
    </summary>

    <param name="pszPathName">The path name to break.</param>
    <param name="pszDrive">
      The drive letter followed by a colon.  <paramref name="pszDrive" /> must contain 2 bytes, plus 1 byte for the terminating _Chr(0) character.
    </param>
    <param name="pszDir">
      The directories, including the trailing slash.<br/>
      Forward slashes and backslashes both may be present in <paramref name="pszFile" />.<br/>
      Forward slashes (/) are converted to backslashes (\).  <paramref name="pszDir" /> must contain 255 bytes, plus 1 byte for the terminating _Chr(0) character.
    </param>
    <param name="pszFile">
      The file name, without the extension.  <paramref name="pszFile" />  must contain 255 bytes, plus 1 byte for the terminating _Chr(0) character.
    </param>
    <param name="pszExt">
      The extension, including the leading period.  <paramref name="pszExt" /> must contain 7 bytes, plus 1 byte for the terminating _Chr(0) character.
    </param>
    <returns>
    </returns>
    <remarks>
      SplitPath() breaks a path name into its components and stores the result in the supplied arguments.<br/>
      The supplied arguments must have enough space to hold the maximum possible size of the broken components.<br/>
      If any of the components is missing in the path name, the corresponding argument is truncated to a 0 length.
    </remarks>
    <example>
      This example breaks a full path name into its four components:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL cDrive, cDir, cFile, cExt AS STRING
        &#0009;MySplitPath("c:\develop\myprg\hello.prg", ;
        &#0009;&#0009;@cDrive, @cDir, @cFile, @cExt)
        &#0009;? cDrive&#0009;&#0009;&#0009;// C:
        &#0009;? cDir&#0009;&#0009;&#0009;// \DEVELOP\MYPRG
        &#0009;? cFile&#0009;&#0009;&#0009;// HELLO
        &#0009;? cExt &#0009;&#0009;&#0009;// .PRG
        FUNCTION MySplitPath(cPath AS STRING,&#0009;;
        &#0009;cDrive REF STRING,&#0009;&#0009;&#0009;;
        &#0009;cDir REF STRING,&#0009;&#0009;&#0009;;
        &#0009;cFile REF STRING,&#0009;&#0009;&#0009;;
        &#0009;cExt REF STRING)
        &#0009;LOCAL pszPath, pszDrive, pszDir AS PSZ
        &#0009;LOCAL pszFile, pszExt AS PSZ
        &#0009;LOCAL cb
        &#0009;pszPath := MemAlloc(cb := SLen(cPath) + 1)
        &#0009;MemCopy(pszPath, PTR(_CAST, cPath), cb)
        &#0009;pszDrive := MemAlloc(2+1)
        &#0009;pszDir   := MemAlloc(255+1)
        &#0009;pszFile  := MemAlloc(255+1)
        &#0009;pszExt   := MemAlloc(7+1)
        &#0009;SplitPath(cPath, pszDrive, pszDir,&#0009;;
        &#0009;&#0009;pszFile, pszExt)
        &#0009;cDrive := Psz2String(pszDrive)
        &#0009;cDir   := Psz2String(pszDir)
        &#0009;cFile  := Psz2String(pszFile)
        &#0009;cExt   := Psz2String(pszExt)
        &#0009;MemFree(pszDrive)
        &#0009;MemFree(pszDir)
        &#0009;MemFree(pszFile)
        &#0009;MemFree(pszExt)
        &#0009;RETURN
      </code>
      This example shows that the supplied argument is truncated to 0 length if its corresponding component is missing in the path name:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL cDrive, cDir, cFile, cExt AS STRING
        &#0009;MySplitPath("c:\develop\myprg\hello", ;
        &#0009;&#0009;@cDrive, @cDir, @cFile, @cExt)
        &#0009;? cDrive&#0009;&#0009;&#0009;// C:
        &#0009;? cDir&#0009;&#0009;&#0009;// \DEVELOP\MYPRG
        &#0009;? cFile&#0009;&#0009;&#0009;// HELLO
        &#0009;? SLen(cExt) &#0009;&#0009;// 0
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FPathName'>FPathName</seealso>
  </splitpath>
  <sqrt>
    <summary>
      Return the square root of a positive number.
    </summary>

    <param name="nNumber">
      A positive number to take the square root of.<br/>
      A negative <paramref name="nNumber" /> returns 0.
    </param>
    <returns>
      The number of decimal places displayed is determined solely by SetDecimal() regardless of SetFixed().
    </returns>
    <remarks>
      SqRt() can be used anywhere in a numeric calculation to compute a square root (for example, in an expression that calculates standard deviation).
    </remarks>
    <example>
      These examples show various results of SqRt():
      <code language="X#">
        SetDecimal(5)
        ? SQRT(2)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 1.41421
        ? SQRT(4)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 2.00000
        ? SQRT(4) ^ 2&#0009;&#0009;&#0009;&#0009;// 4.00000
        ? SQRT(2) ^ 2&#0009;&#0009;&#0009;&#0009;// 2.00000
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetFixed'>SetFixed</seealso>
  </sqrt>
  <stod>
    <summary>
      Convert an ANSI date string to date format.
    </summary>

    <param name="cDate">
      A date in the ANSI format yyyymmdd.<br/>
      The century digits must be specified.<br/>
      If <paramref name="cDate" /> contains more than the eight characters required for the date, the extra characters are ignored.
    </param>
    <returns>
      A date in the current SetDateFormat() or SET DATE format. If <paramref name="cDate" /> is not a valid ANSI date, a NULL_DATE is returned.
    </returns>
    <remarks>
      SToD() is a date function that converts an ANSI date created by the DToS() function back into the standard date format.
    </remarks>
    <example>
      This example displays the ANSI date in default date format:
      <code language="X#">
        ? SToD("19981028")         &#0009;// 10/28/98
        ? SToD("981028")         &#0009;// NULL_DATE
        ? SToD("19981028extra")      // 10/28/98
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CToD'>CToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.CToDAnsi'>CToDAnsi</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToS'>DToS</seealso>
  </stod>
  <str>
    <summary>
      Convert a numeric expression to a string.
    </summary>

    <param name="nNumber">The numeric expression to convert to a string.</param>
    <param name="nLength">
      The length of the string to return, including decimal digits, decimal point, and sign.<br/>

      &#0009;A value of -1 specifies that any right padding is suppressed.  However, decimal places are still returned as specified in <paramref name="nDecimals" />.<br/>

      &#0009;If <paramref name="nLength" /> is not specified,  SetDigit() and SetDigitFixed() determine the number of digits that are returned.
    </param>
    <param name="nDecimals">
      The number of decimal places in the return value.<br/>
      A  value  of -1 specifies that only the significant digits to the right of the decimal point are returned (see example below).<br/>
      The number of whole digits in the return value, however, are still determined by the <paramref name="nLength" /> argument.<br/>

      &#0009;If <paramref name="nDecimals" /> is not specified, SetDecimal() and SetFixed()  determine the number of decimals that are returned.<br/>

      &#0009;The representation of the decimal point is determined by the current setting of SetDecimalSep().
    </param>
    <returns>
      A string, with these exceptions:
      &#0009; If <paramref name="nNumber" /> is an expression that yields a numeric overflow, a runtime error is generated that could be handled by the currently installed error handler.  Either "+INF" or "-INF", which represent the biggest possible float number, is returned by the error handler.
      &#0009;If <paramref name="nLength" /> is less than the number of whole number digits in <paramref name="nNumber" />, the result will be in scientific notation.<br/>
      If the result of scientific notation does not fit, a series of asterisk is returned.
      Rounding is determined as follows:
      &#0009;If <paramref name="nLength" /> is less than the number of decimal digits required for the decimal portion of the returned string, the return value is rounded to the available number of decimal places.
      &#0009;If <paramref name="nLength" /> is specified, but <paramref name="nDecimals" /> is omitted (no decimal places), the return value is rounded to an integer.
      If <paramref name="nLength" /> and <paramref name="nDecimals" /> are not specified, they are taken out of the internal float format inside the FLOAT, or out of SetDigit() if the internal digit number is 0.<br/>
      If SetFixed() or SetDigitFixed() is TRUE, these values are overridden by the values of SetDecimal() or SetDigit().
      If SetScience() is TRUE, the return will be in scientific notation. Moreover, If SetDigit() specifies a number that is less than the number of whole number digits in <paramref name="nNumber" /> and SetDigitFixed() is set to TRUE, the result is in scientific notation.  But if scientific notation does not fit, the result is a series of asterisks.
    </returns>
    <remarks>
      Str() is commonly used to concatenate numbers to strings.  Thus, it is useful for creating codes for items, such as part numbers, from numbers and for creating order keys that combine numeric and character data.
      Str() is like Transform(), which formats numbers as strings using a mask instead of length and decimal specifications.
      The inverse of Str() is Val() which converts numbers formatted as strings to numeric values.
    </remarks>
    <example>
      These examples demonstrate the range of values returned by Str(), depending on the arguments specified:
      <code language="X#">
        nNumber := 123.45
        ? Str(nNumber)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;//      123.45
        ? Str(nNumber, 4)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 123.
        ? Str(nNumber, 2)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// **
        ? Str(nNumber * 10, 7, 2)&#0009;&#0009;&#0009;&#0009;&#0009;// 1234.50
        ? Str(nNumber * 10, 12, 4)&#0009;&#0009;&#0009;&#0009;//    1234.5000
        ? Str(nNumber, 10, 1)&#0009;&#0009;&#0009;&#0009;&#0009;//      123.5
        ? Str(123.45, -1)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 123.45
        ? Str(123.45, -1, 2)&#0009;&#0009;&#0009;&#0009;&#0009;// 123.45
        ? Str(0.45000, 12, -1)&#0009;&#0009;&#0009;&#0009;&#0009;//      0.45000
      </code>
      Often two numbers display the same results, but internally they have two different values stored in them. Thus an equality test will fail (return FALSE) unless you round each side.  Here is an example:
      <code language="X#">
        ? nNum
        // displays identical to MyFunction() below
        ? MyFunction()
        // displays identical to nNum above
        // but internally they are not equal
        ? nNum = MyFunction()&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        // after rounding they are equal
        ? Round(nNum, 0) == Round(MyFunction(), 0)&#0009;// TRUE
        // a Val(Str()) is also rounding
        ? Val(Str(nNum)) = Val(Str(MyFunction()))&#0009;&#0009;// TRUE
      </code>
      Setting SetFloatDelta() to a higher value than before has the same effect:
      <code language="X#">
        SetFloatDelta(0.1)
        ? nNum == MyFunction()&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
      </code>
      This functions returns a string of all asterisks when the Decimals parameter is &gt; 0 and the Decimals parameter is  &gt; Length-2.
      Also a string of all asterisks is returned when the number does NOT fit into the allocated space.
      Example:
      <code language="X#">
        &#0009;? Str(9,6,6)&#0009;=&gt; "******"
        &#0009;? Str(9,6,5)&#0009;=&gt; "******"
        &#0009;? Str(9,6,4)&#0009;=&gt; "9.0000"
        &#0009;? Str(9,6,3)&#0009;=&gt; " 9.000"
        &#0009;? Str(10,6,6)&#0009;=&gt; "******"
        &#0009;? Str(10,6,5)&#0009;=&gt; "******"
        &#0009;? Str(10,6,4)&#0009;=&gt; "******"
        &#0009;? Str(10,6,3)&#0009;=&gt; "10.000"
      </code>
      This example uses Str() to create an order with a compound key of order numbers and customer names:
      <code language="X#">
        USE customer NEW
        INDEX ON Str(NumOrders, 9) + Custname TO custord
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.NTrim'>NTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.Round'>Round</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDecimalSep'>SetDecimalSep</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDigit'>SetDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDigitFixed'>SetDigitFixed</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetScience'>SetScience</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str1'>Str1</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str2'>Str2</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str3'>Str3</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrFloat'>StrFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrInt'>StrInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrLong'>StrLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.Transform'>Transform</seealso>
    <seealso cref='O:XSharp.RT.Functions.Val'>Val</seealso>
  </str>
  <str1>
    <summary>
      Convert a numeric expression to a string.
    </summary>

    <param name="fNumber">The numeric expression to convert.</param>
    <returns>
    </returns>
    <remarks>
      Str1() is a typed version of the Str() numeric function.  See Str() for a detailed description.
    </remarks>
    <example>
      This example shows how to use Str1() to convert a number to a string:
      <code language="X#">
        LOCAL fNumber AS FLOAT
        fNumber := 123.45
        ? Str1(fNumber)&#0009;&#0009; //      123.45
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str2'>Str2</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str3'>Str3</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrFloat'>StrFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrInt'>StrInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrLong'>StrLong</seealso>
  </str1>
  <str2>
    <summary>
      Convert a numeric expression to a string of a specified length.
    </summary>

    <param name="fNumber">The numeric expression to convert.</param>
    <param name="dwLength">
      The length of the string to return, including decimal digits, decimal point, and sign.<br/>
      If <paramref name="siLength" /> is not long enough to hold the entire number, the result will be in scientific notation.
    </param>
    <returns>
    </returns>
    <remarks>
      Str2() is a typed version of the Str() numeric function where both arguments are mandatory.  See Str() for a detailed description.
    </remarks>
    <example>
      These examples show how to use Str2() to change a number to a string:
      <code language="X#">
        LOCAL fNumber AS FLOAT
        fNumber := 123.45
        ? Str2(fNumber, 4)&#0009;&#0009;// 123.
        ? Str2(fNumber, 2)&#0009;&#0009;// **
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str1'>Str1</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str3'>Str3</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrFloat'>StrFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrInt'>StrInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrLong'>StrLong</seealso>
  </str2>
  <str3>
    <summary>
      Convert a numeric expression to a string of specific length and decimal places.
    </summary>

    <param name="fNumber">The numeric expression to convert.</param>
    <param name="dwLength">
      The length of the string to return, including decimal digits, decimal point, and sign.<br/>
      If <paramref name="dwLength" /> is not long enough to hold the entire number, the result will be in scientific notation.
    </param>
    <param name="dwDecimals">The number of decimal places to return.</param>
    <returns>
    </returns>
    <remarks>
      Str3() is a typed version of the Str() numeric function where all three arguments are mandatory.  See Str() for a detailed description.
    </remarks>
    <example>
      These examples show how to use Str3() to change a number to a string:
      <code language="X#">
        LOCAL fNumber AS FLOAT
        fNumber := 123.45
        ? Str3(fNumber, 10, 1)&#0009;&#0009;&#0009;//      123.5
        ? Str3(fNumber * 10, 7, 2)&#0009;&#0009;// 1234.50
        ? Str3(fNumber * 10, 12, 4)&#0009;&#0009;//    1234.5000
      </code>
      This functions returns a string of all asterisks when the Decimals parameter is &gt; 0 and the Decimals parameter is  &gt; Length-2.
      Also a string of all asterisks is returned when the number does NOT fit into the allocated space.
      Example:
      <code language="X#">
        &#0009;? Str(9,6,6)&#0009;=&gt; "******"
        &#0009;? Str(9,6,5)&#0009;=&gt; "******"
        &#0009;? Str(9,6,4)&#0009;=&gt; "9.0000"
        &#0009;? Str(9,6,3)&#0009;=&gt; " 9.000"
        &#0009;? Str(10,6,6)&#0009;=&gt; "******"
        &#0009;? Str(10,6,5)&#0009;=&gt; "******"
        &#0009;? Str(10,6,4)&#0009;=&gt; "******"
        &#0009;? Str(10,6,3)&#0009;=&gt; "10.000"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str1'>Str1</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str2'>Str2</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrFloat'>StrFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrInt'>StrInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrLong'>StrLong</seealso>
  </str3>
  <stretchbitmap>
    <summary>
      Display a bitmap stretched or shrunk to fit a window or control.
    </summary>

    <param name="hWnd">Handle of the window or control in which you want to display the bitmap.</param>
    <param name="cFileName">The bitmap file to display.</param>
    <param name="cTitle">Caption for the window or control.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      This function allows you to stretch or shrink a bitmap to fit the current window or control size, and then displays that bitmap.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.ShowBitmap'>ShowBitmap</seealso>
  </stretchbitmap>
  <strevaluate>
    <summary>
      Allows text substitution in strings entered at runtime.
    </summary>

    <param name="cString">A string containing one or more macro variables to expand.</param>
    <returns>
      The new string, after all macro substitutions have taken place.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example demonstrates StrEvaluate() on a string entered at runtime that contains a macro variable:
      <code language="X#">
        MEMVAR cOne
        LOCAL cTwo AS STRING
        cOne := "world"
        ACCEPT "Enter a macro string " TO cTwo
        // If you type "Hello &amp;cOne" (without quotes)
        ? cTwo&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Result: "Hello &amp;cOne"
        ? StrEvaluate(cTwo)&#0009;&#0009;&#0009;// Result: "Hello world"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Evaluate'>Evaluate</seealso>
    <seealso cref='O:XSharp.RT.Functions.MAssign'>MAssign</seealso>
    <seealso cref='O:XSharp.RT.Functions.MCompile'>MCompile</seealso>
    <seealso cref='O:XSharp.RT.Functions.MExec'>MExec</seealso>
  </strevaluate>
  <strfloat>
    <summary>
      Convert a float expression to a PSZ.
    </summary>

    <param name="flSource">The numeric expression to convert.</param>
    <param name="dwLength">
      The length of the string to return, including decimal digits, decimal point, and sign.<br/>
      If <paramref name="dwLength" /> is not long enough to hold the entire number,<br/>
      The result will be in scientific notation.
    </param>
    <param name="dwDecimals">The number of decimal places to return.</param>
    <returns>
    </returns>
    <remarks>
      StrFloat() is a typed version of the Str() numeric function, except that SetDecimalSep() is ignored.  See Str() for a detailed description.
    </remarks>
    <example>
      These examples demonstrate the range of values returned by StrFloat(), depending on the arguments specified:
      <code language="X#">
        LOCAL fNumber AS FLOAT
        fNumber := 123.45
        ? StrFloat(fNumber * 10, 7, 2)&#0009;&#0009;&#0009;// 1234.50
        ? StrFloat(fNumber * 10, 12, 4)&#0009;&#0009;// 1234.5000
        ? StrFloat(fNumber, 10, 1)&#0009;&#0009;&#0009;// 1234.5
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str1'>Str1</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str2'>Str2</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str3'>Str3</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrInt'>StrInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrLong'>StrLong</seealso>
  </strfloat>
  <string2atom>
    <summary>
      Convert a string to a symbol.
    </summary>

    <param name="cString">The string to convert.</param>
    <returns>
      A symbol which is added to the atom table if it is not already there.
    </returns>
    <remarks>
      String2Atom() and its counterpart Symbol2String() allow you to manipulate symbols to a more desirable or convenient form.
    </remarks>
    <example>
      This example uses String2Atom() to assign the contents of a string to a symbol:
      <code language="X#">
        LOCAL cMyName<br/>
        AS STRING
        LOCAL symMyName AS SYMBOL
        cMyName := "Josie"
        symMyName : = String2Atom(cMyName)
        ? symMyName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Josie
      </code>
      This example shows the differences between String2Atom() and String2Symbol(), which yields the symbol in uppercase:
      <code language="X#">
        ? String2Atom("Hello") = String2Symbol("Hello")
        &#0009;// FALSE
        ? String2Atom("HELLO") = String2Symbol("Hello")
        &#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsSymbol'>AsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.String2Symbol'>String2Symbol</seealso>
  </string2atom>
  <string2psz>
    <summary>
      Convert a strongly typed string to a null-terminated string.
    </summary>

    <param name="cString">The string to convert.</param>
    <returns>
      A non-zero PSZ if successful; otherwise, NULL_PSZ.
    </returns>
    <remarks>
      String2Psz() is useful for many Windows or DLL functions that require a PSZ in their argument list.<br/>
      It checks whether <paramref name="cString" /> is a NULL_STRING.<br/>
      If this is the case, String2Psz() returns a static pointer to a byte containing 0x00.
      Otherwise, it allocates a buffer within static memory, copies the string content to it, and returns the pointer to this buffer.<br/>
      The pointer becomes a hidden local variable.<br/>
      If the appropriate function or method, which called String2Psz(), goes out of scope, the allocated buffer will be freed up automatically.  Furthermore, the pointer is no longer valid.
      Warning!  Do not use String2Psz() to initialize global variables!
    </remarks>
    <example>
      The following example uses the Win32 API function GetDriveType().<br/>
      It shows three different ways to create the required PSZ argument:
      <code language="X#">
        LOCAL cDrive AS STRING
        LOCAL nType&#0009;<br/>
        AS INT
        cDrive := Upper(CurDrive()) + ":"
        //&#0009;Version 1: Slow, copy of cDrive created
        nType := GetDriveType( String2Psz(cDrive) )
        //&#0009;Version 2: Better, no copy of cDrive created
        nType := GetDriveType( Cast2Psz(cDrive) )
        //&#0009;Version 3: Best performance, no function call at all
        //             But: No check for NULL_STRING
        nType := GetDriveType( PSZ(_CAST, cDrive) )
        DO CASE
        CASE nType = DRIVE_REMOTE
        &#0009;? cDrive + " is a network drive"
        CASE nType = DRIVE_CDROM
        &#0009;? cDrive + " is a CD-ROM"
        CASE nType = DRIVE_REMOVABLE
        &#0009;? cDrive + " is a floppy or zip drive"
        CASE nType = DRIVE_FIXED
        &#0009;? cDrive + " is a fixed drive"
        CASE nType = DRIVE_RAMDISK
        &#0009;? cDrive + " is a RAM disk"
        ENDCASE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Cast2Psz'>Cast2Psz</seealso>
    <seealso cref='O:XSharp.RT.Functions.Psz2String'>Psz2String</seealso>
  </string2psz>
  <string2symbol>
    <summary>
      Convert a string to an uppercase symbol.
    </summary>

    <param name="cString">The string to convert.</param>
    <returns>
      The symbol in uppercase.<br/>
      This symbol is added to the atom table if it is not already there.
    </returns>
    <remarks>
      String2Symbol() changes the argument to uppercase before converting it.<br/>
      It is the same as using a literal symbol.
    </remarks>
    <example>
      This example uses String2Symbol() to assign the contents of a string to a symbol:
      <code language="X#">
        LOCAL cMyName<br/>
        AS STRING
        LOCAL symMyName AS SYMBOL
        cMyName := "Josie"
        symMyName : = String2Symbol(cMyName)
        ? symMyName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// JOSIE
      </code>
      This example shows the similarities between String2Symbol() and the # sign which identifies a symbol:
      <code language="X#">
        ? String2Symbol("Hello") = #Hello&#0009;&#0009;// TRUE
        ? String2Symbol("HELLO") = #Hello&#0009;&#0009;// TRUE
      </code>
      This example shows the differences between String2Symbol() and String2Atom(), which does not change the case:
      <code language="X#">
        ? String2Atom("Hello") = String2Symbol("Hello")
        &#0009;// FALSE
        ? String2Atom("HELLO") = String2Symbol("Hello")
        &#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsSymbol'>AsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.String2Atom'>String2Atom</seealso>
  </string2symbol>
  <stringalloc>
    <summary>
      Copy a string to a newly allocated block of memory and return a PSZ to the memory.
    </summary>

    <param name="cString">The string to copy.</param>
    <returns>
      A pointer to the newly allocated string.
    </returns>
    <remarks>
      StringAlloc() makes a copy of a string.<br/>
      The new copy is a PSZ and points to a different address from the original string.<br/>
      The newly allocated string is a static object which will not be moved by the garbage collector.  Note that storage allocated by StringAlloc() must be removed by MemFree().
    </remarks>
    <example>
      This example displays the storage addresses of two variables:
      <code language="X#">
        LOCAL pszString AS PSZ
        LOCAL cString AS STRING
        cString := "CAVO2x tree"
        pszString := StringAlloc(cString)
        ? @cString
        ? @pszString&#0009;&#0009;// Has different storage address than cString
        MemFree(pszString)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemAlloc'>MemAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemFree'>MemFree</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszAlloc'>PszAlloc</seealso>
  </stringalloc>
  <strint>
    <summary>
      Convert an integer expression to a PSZ.
    </summary>

    <param name="liNumber">The integer expression to convert.</param>
    <param name="dwLength">
      The length of the string to return, including decimal digits, decimal point, and sign.<br/>
      If <paramref name="dwLength" /> is not long enough to hold the entire number, the result will be in scientific notation.
    </param>
    <param name="dwDecimals">The number of decimal places to return.</param>
    <returns>
    </returns>
    <remarks>
      StrInt() is a typed version of the Str() numeric function, except that SetDecimalSep() is ignored.  See Str() for a detailed description.
    </remarks>
    <example>
      These examples demonstrate the range of values returned by StrInt(), depending on the arguments specified:
      <code language="X#">
        LOCAL iNumber AS INT
        iNumber := 123
        ? StrInt(iNumber,10, 0)&#0009;&#0009;&#0009;// 123
        ? StrInt(iNumber, 4, 0)&#0009;&#0009;&#0009;// 123
        ? StrInt(iNumber, 2, 0)&#0009;&#0009;&#0009;// **
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str1'>Str1</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str2'>Str2</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str3'>Str3</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrFloat'>StrFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrLong'>StrLong</seealso>
  </strint>
  <strlong>
    <summary>
      Convert a long integer expression to a PSZ.
    </summary>

    <param name="liNumber">The long integer expression to convert.</param>
    <param name="dwLength">
      The length of the string to return, including decimal digits, decimal point, and sign.<br/>
      If <paramref name="dwLength" /> is not long enough to hold the entire number,<br/>
      The result will be in scientific notation.
    </param>
    <param name="dwDecimals">The number of decimal places to return.</param>
    <returns>
    </returns>
    <remarks>
      StrLong() is a typed version of the Str() numeric function, except that SetDecimalSep() is ignored.  See Str() for a detailed description.
    </remarks>
    <example>
      These examples demonstrate the range of values returned by StrLong(), depending on the arguments specified:
      <code language="X#">
        LOCAL liNumber AS LONGINT
        liNumber := 12345L
        ? StrLong(liNumber, 5, 0)&#0009;&#0009;&#0009;// "12345"
        ? StrLong(liNumber, 4, 0)&#0009;&#0009;&#0009;//  "****"
        ? StrLong(liNumber, 2, 10)&#0009;&#0009;// "**"
        ? StrLong(liNumber * 10, 7, 2)&#0009;&#0009;// "****.**"
        ? StrLong(liNumber * 10, 12, 4)&#0009;// " 123450.0000"
        ? StrLong(liNumber, 10, 1)&#0009;&#0009;// " 12345.0"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str1'>Str1</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str2'>Str2</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str3'>Str3</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrFloat'>StrFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrInt'>StrInt</seealso>
  </strlong>
  <strtran>
    <summary>
      Search and replace characters within a string.
    </summary>

    <param name="uTarget">The string in which to search.</param>
    <param name="uSearch">
      The substring for which to search.<br/>
      All occurrences of <paramref name="uSearch" /> are replaced unless <paramref name="uStart" /> or <paramref name="uCount" /> is specified.  Note that StrTran() replaces substrings and, therefore, does not account for whole words.
    </param>
    <param name="uReplace">
      The substring with which to replace <paramref name="cSearch" />.<br/>
      If this argument is not specified, <paramref name="cSearch" /> is replaced with a NULL_STRING.
    </param>
    <param name="uStart">
      The first occurrence to replace.<br/>
      If this argument is omitted or 0, the default is 1.
    </param>
    <param name="uCount">
      The number of occurrences to replace.<br/>
      If this argument is not specified, the default is all.
    </param>
    <returns>
      A new string with the specified occurrences of <paramref name="uSearch" /> replaced by <paramref name="uReplace" />.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses StrTran() to convert a postmodern analog to a famous quotation:
      <code language="X#">
        cString := "To compute or not to compute?"
        ? StrTran(cString, "compute", "be")
        // To be or not to be?
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.HardCR'>HardCR</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemoTran'>MemoTran</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Stuff'>Stuff</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </strtran>
  <strzero>
    <summary>
      Convert a numeric expression to a string and pad it with leading zeroes instead of blanks.
    </summary>

    <param name="nNumber">The numeric expression to convert to a string.</param>
    <param name="nLength">The length of the string to return, including zeroes, decimal digits, decimal point, and sign.</param>
    <param name="nDecimals">The number of decimal places in the return value.</param>
    <returns>
      A string.
    </returns>
    <remarks>
      StrZero() is useful in displaying numbers, creating codes such as part numbers from numeric values, and creating order keys that combine numeric and character data.  StrZero() is similar to the Str() function except that the padding character is a zero ("0") instead of a blank.<br/>
      For more information, see the Str() function.
    </remarks>
    <example>
      This example uses StrZero() to convert a 3-digit number to a 5-character string:
      <code language="X#">? StrZero(987, 5, 0)&#0009;&#0009;// "00987"</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.NTrim'>NTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Val'>Val</seealso>
  </strzero>
  <stuff>
    <summary>
      Delete and insert characters in a string.
    </summary>

    <param name="cTarget">The string into which characters are inserted and deleted.</param>
    <param name="dwStart">
      The position in <paramref name="cTarget" /> where the insertion/deletion occurs.
    </param>
    <param name="dwDelete">The number of characters to delete.</param>
    <param name="cInsert">The string to insert.</param>
    <returns>
      <paramref name="cTarget" /> with the specified characters deleted and <paramref name="cInsert" /> inserted.
    </returns>
    <remarks>
      Stuff() first deletes characters from <paramref name="cTarget" />, then inserts characters into the resulting string to form the return string.  Stuff() can perform the following six operations:
      &#0009;Insert:<br/>
      If <paramref name="dwDelete" /> is 0, no characters are removed from <paramref name="cTarget" />.  <paramref name="cInsert" /> is then inserted at <paramref name="dwStart" />, and the entire string is returned.<br/>
      For example, Stuff("My dog has fleas.", 12, 0, "no ") returns "My dog has no fleas."
      &#0009;Replace:<br/>
      If <paramref name="cInsert" /> is the same length as <paramref name="dwDelete" />, <paramref name="cInsert" /> replaces characters beginning at <paramref name="dwStart" />.<br/>
      The same number of characters are deleted as are inserted, and the resulting string is the same length as the original.<br/>
      For example, Stuff("My dog has fleas.", 12, 5, "bones") returns "My dog has bones."
      &#0009;Delete:<br/>
      If <paramref name="cInsert" /> is a NULL_STRING, the number of characters specified by <paramref name="dwDelete" /> are removed from <paramref name="cTarget" />, and the string is returned without any added characters.<br/>
      For example, Stuff("My dog has fleas.", 1, 3, NULL_STRING) returns "dog has fleas."
      &#0009;Replace and insert:<br/>
      If <paramref name="cInsert" /> is longer than <paramref name="dwDelete" />, all characters from <paramref name="dwStart" /> up to <paramref name="dwDelete" /> are replaced and the rest of <paramref name="cInsert" /> is inserted.  Since more characters are inserted than are deleted, the resulting string is always longer than the original.<br/>
      For example, Stuff("My dog has fleas.", 8, 3, "does not have") returns "My dog does not have fleas."
      &#0009;Replace and delete:<br/>
      If the length of <paramref name="cInsert" /> is less than <paramref name="dwDelete" />, more characters are deleted than inserted.<br/>
      The resulting string, therefore, is shorter than the original.<br/>
      For example, Stuff("My dog has fleas.", 8, 3, "is") returns "My dog is fleas."
      &#0009;Replace and delete rest:<br/>
      If <paramref name="dwDelete" /> is greater than or equal to the number of characters remaining in <paramref name="cTarget" /> beginning with <paramref name="dwStart" />, all remaining characters are deleted before <paramref name="cInsert" /> is inserted.<br/>
      For example, Stuff("My dog has fleas.", 8, 10, "is.") returns "My dog is."
    </remarks>
    <example>
      These examples demonstrate the six basic operations of Stuff():
      <code language="X#">
        // Insert
        ? Stuff("ABCDEF", 2, 0, "xyz")&#0009;&#0009;&#0009;// AxyzBCDEF
        // Replace
        ? Stuff("ABCDEF", 2, 3, "xyz")&#0009;&#0009;&#0009;// AxyzEF
        // Delete
        ? Stuff("ABCDEF", 2, 2, NULL_STRING)&#0009;// ADEF
        // Replace and insert
        ? Stuff("ABCDEF", 2, 1, "xyz")&#0009;&#0009;&#0009;// AxyzCDEF
        // Replace and delete
        ? Stuff("ABCDEF", 2, 4, "xyz")&#0009;&#0009;&#0009;// AxyzF
        // Replace and delete rest
        ? Stuff("ABCDEF", 2, 10, "xyz")&#0009;&#0009;// Axyz
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrTran'>StrTran</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </stuff>
  <substr>
    <summary>
      Extract a substring from a string.
    </summary>

    <param name="cTarget">The string from which to extract a substring.</param>
    <param name="nStart">
      The starting position in <paramref name="cTarget" />.<br/>
      If <paramref name="wStart" /> is positive, it is relative to the leftmost character in <paramref name="cTarget" />.<br/>
      If <paramref name="nStart" /> is negative, it is relative to the rightmost character in <paramref name="cTarget" />.<br/>
      If <paramref name="nStart" /> is zero, a NULL_STRING is returned.
    </param>
    <param name="nCount">
      The number of characters to extract.<br/>
      If omitted, the substring begins at <paramref name="nStart" /> and continues to the end of the string.<br/>
      If <paramref name="nCount" /> is greater than the number of characters from <paramref name="nStart" /> to the end of <paramref name="cTarget" />, the extra is ignored.
    </param>
    <returns>
      The substring.<br/>
      If the substring is not present, a NULL_STRING is returned.
    </returns>
    <remarks>
      Substr() is related to the Left() and Right() functions, which extract substrings beginning with leftmost and rightmost characters in <paramref name="cTarget" />, respectively.
      The Substr(), Right(), and Left() functions are often used with both the At() and RAt() functions to locate either the first and/or the last position of a substring before extracting it.<br/>
      They are also used to display or print only a portion of a string.
    </remarks>
    <example>
      These examples extract the first and last name from a variable:
      <code language="X#">
        cName := "Biff Styvesent"
        ? Substr(cName, 1, 4)&#0009;&#0009;&#0009;&#0009;// Biff
        ? Substr(cName, 6)&#0009;&#0009;&#0009;&#0009;&#0009;// Styvesent
        ? Substr(cName, SLen(cName) + 2)
        // Null string
        ? Substr(cName, -9)&#0009;&#0009;&#0009;&#0009;&#0009;// Styvesent
        ? Substr(cName, -9, 3)&#0009;&#0009;&#0009;&#0009;// Sty
      </code>
      This example uses Substr() with At() and RAt() to create a function to extract a file name from a file specification:
      <code language="X#">
        ? FileBase("c:\prg\myfile.obj")&#0009;&#0009;// myfile.obj
        FUNCTION FileBase(cFile)
        &#0009;LOCAL nPos AS DWORD
        &#0009;IF (nPos := RAt("\", cFile)) != 0
        &#0009;&#0009;cFile := Substr(cFile, nPos + 1)
        &#0009;ELSEIF (nPos := At(":", cFile)) != 0
        &#0009;&#0009;cFile := Substr(cFile, nPos + 1)
        &#0009;ENDIF
        &#0009;RETURN cFile
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.CharPos'>CharPos</seealso>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.Core.Functions.SubStr2'>Substr2</seealso>
    <seealso cref='O:XSharp.Core.Functions.SubStr3'>Substr3</seealso>
  </substr>
  <substr2>
    <summary>
      Extract a substring from a string, using strong typing and only two arguments.
    </summary>

    <param name="cTarget">The string from which to extract a substring.</param>
    <param name="dwStart">
      The starting position in <paramref name="cTarget" />.  Since this argument is a WORD, it cannot be negative.
    </param>
    <returns>
      The substring.<br/>
      If the substring is not found, a NULL_STRING is returned.
    </returns>
    <remarks>
      Substr2() is a typed version of Substr().  See Substr() for details.
    </remarks>
    <example>
      These examples extract part of a name:
      <code language="X#">
        LOCAL cName AS STRING
        cName := "Biff Styvesent"
        ? Substr2(cName, 6)&#0009;&#0009;&#0009;&#0009;&#0009;// Styvesent
        ? Substr2(cName, SLen(cName) + 2)&#0009;&#0009;// null string
      </code>
      This example uses Substr2() with At() and RAt() to create a function to extract a file name from a file specification:
      <code language="X#">
        ? FileBase("c:\prg\myfile.obj")&#0009;&#0009;// myfile.obj
        FUNCTION FileBase(cFile)
        &#0009;LOCAL nPos AS DWORD
        &#0009;IF (nPos := RAt("\", cFile)) != 0
        &#0009;&#0009;cFile := Substr2(cFile, nPos + 1)
        &#0009;ELSEIF (nPos := At(":", cFile)) != 0
        &#0009;&#0009;cFile := Substr2(cFile, nPos + 1)
        &#0009;ENDIF
        &#0009;RETURN cFile
      </code>
      &#0009;
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
    <seealso cref='O:XSharp.Core.Functions.SubStr3'>Substr3</seealso>
  </substr2>
  <substr3>
    <summary>
      Extract a substring from a string, using strong typing and three required arguments.
    </summary>

    <param name="cTarget">The string from which to extract a substring.</param>
    <param name="dwStart">
      The starting position in <paramref name="cTarget" />.  Since this argument is a WORD, it cannot be negative.
    </param>
    <param name="dwLen">
      The number of characters to extract.<br/>
      If omitted, the substring begins at <paramref name="dwStart" /> and continues to the end of the string.<br/>
      If <paramref name="dwLen" /> is greater than the number of characters from <paramref name="dwStart" /> to the end of <paramref name="cTarget" />, the extra is ignored.
    </param>
    <returns>
      The substring.<br/>
      If the substring is not found, it returns a NULL_STRING.
    </returns>
    <remarks>
      Substr3() is a typed version of Substr() and requires three arguments.  See Substr() for details.
    </remarks>
    <example>
      These examples extract the first and last name from a variable:
      <code language="X#">
        LOCAL cName AS STRING
        cName := "Biff Styvesent"
        ? Substr3(cName, 1, 4)&#0009;&#0009;&#0009;&#0009;// Biff
        ? Substr3(cName, 6, 9)&#0009;&#0009;&#0009;&#0009;// Styvesent
        ? Substr3(cName, 6, 3)&#0009;&#0009;&#0009;&#0009;// Sty
        ? Substr3(cName, SLen(cName) + 2, 5)&#0009;// null string
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
    <seealso cref='O:XSharp.Core.Functions.SubStr2'>Substr2</seealso>
  </substr3>
  <swapbyte>
    <summary>
      Exchange the right and left halves of a byte.
    </summary>

    <param name="bSwap">The byte whose nibbles you want to swap.</param>
    <returns>
      The byte value with swapped nibbles.
    </returns>
    <remarks>
      SwapByte() swaps the right nibble of a byte with the left nibble of a byte and returns the result.  (A nibble is 4 bits, which is half of a byte.)
    </remarks>
    <example>
      This example uses SwapByte() on the character "A".<br/>
      The ASCII value of "A" is 65. Thus, its binary representation is 0100 0001.  Swapping it gives 0001 0100.<br/>
      Therefore, an ASCII value of 20 is returned.
      <code language="X#">? SwapByte(Asc("A"))</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SwapDWord'>SwapDWord</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapInt'>SwapInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapLong'>SwapLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapShort'>SwapShort</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapWord'>SwapWord</seealso>
  </swapbyte>
  <swapdword>
    <summary>
      Exchange the right and left halves of a double word.
    </summary>

    <param name="dwSwap">The double word value whose words you want to swap.</param>
    <returns>
      The swapped double word.
    </returns>
    <remarks>
      SwapDWord() swaps the right half of a double word with the left half of a double word and returns the result.<br/>
      The sign may not be preserved during the swap.
    </remarks>
    <example>
      This example uses SwapDWord():
      <code language="X#">
        bHex := 0x23CACE
        ? SwapDWord(bHex)&#0009;&#0009;// returns 3402498083
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SwapByte'>SwapByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapInt'>SwapInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapLong'>SwapLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapShort'>SwapShort</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapWord'>SwapWord</seealso>
  </swapdword>
  <swapint>
    <summary>
      Exchange the right and left halves of an integer.
    </summary>

    <param name="liSwap">The integer whose bytes you want to swap.</param>
    <returns>
      The swapped integer.
    </returns>
    <remarks>
      SwapInt() swaps the right half of an integer with the left half of an integer and returns the result.<br/>
      The sign may not be
      preserved during the swap.
    </remarks>
    <example>
      This example uses SwapInt():
      <code language="X#">? SwapInt(30001)&#0009;&#0009;// 1966145536</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SwapByte'>SwapByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapDWord'>SwapDWord</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapLong'>SwapLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapShort'>SwapShort</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapWord'>SwapWord</seealso>
  </swapint>
  <swaplong>
    <summary>
      Exchange the right and left halves of a long integer.
    </summary>

    <param name="liSwap">The long integer whose words you want to swap.</param>
    <returns>
      The swapped long integer.
    </returns>
    <remarks>
      SwapLong() swaps the right half of a long integer with the left half of a long integer and returns the result.<br/>
      The sign may not be preserved after the swap.
    </remarks>
    <example>
      This example uses SwapLong():
      <code language="X#">? SwapLong(256000000)&#0009;&#0009;// 1073745730</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SwapByte'>SwapByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapDWord'>SwapDWord</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapInt'>SwapInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapShort'>SwapShort</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapWord'>SwapWord</seealso>
  </swaplong>
  <swapshort>
    <summary>
      Exchange the right and left halves of a short integer.
    </summary>

    <param name="siSwap">The short integer whose bytes you want to swap.</param>
    <returns>
      The swapped short integer.
    </returns>
    <remarks>
      SwapShort() swaps the right half of a short integer with the left half of a short integer and returns the result.<br/>
      The sign may not be preserved after the swap.
    </remarks>
    <example>
      This example uses SwapShort():
      <code language="X#">? SwapShort(-10000)&#0009;&#0009;&#0009;&#0009;// -3880</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SwapByte'>SwapByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapDWord'>SwapDWord</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapInt'>SwapInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapLong'>SwapLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapWord'>SwapWord</seealso>
  </swapshort>
  <swapword>
    <summary>
      Exchange the right and left halves of a word.
    </summary>

    <param name="wSwap">The word whose bytes you want to swap.</param>
    <returns>
      The swapped word.
    </returns>
    <remarks>
      SwapWord() swaps the right half of a word with the left half of a word and returns the result.
    </remarks>
    <example>
      This example uses SwapWord():
      <code language="X#">
        aHex := 0xAB00
        ? SwapWord(aHex)&#0009;&#0009;&#0009;// returns 171
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SwapByte'>SwapByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapDWord'>SwapDWord</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapInt'>SwapInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapLong'>SwapLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapShort'>SwapShort</seealso>
  </swapword>
  <symbol2string>
    <summary>
      Convert a symbol to a string.
    </summary>

    <param name="symVar">The symbol to convert.</param>
    <returns>
      A string.
    </returns>
    <remarks>
      The operations available for symbols are limited due to their storage mechanism — you can only compare them and manipulate their functions.<br/>
      Using Symbol2String() to convert symbols to strings gives them access to all of the string operations.
    </remarks>
    <example>
      This example uses Symbol2String() to convert a symbol to a string so it can be used in string comparisons.  Since the symbol is a literal symbol, the scanner converts it to uppercase:
      <code language="X#">
        LOCAL cMyName AS STRING
        LOCAL symMemoName AS SYMBOL
        cMyName := Symbol2String(#symMemoName)
        ? cMyName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Result: SYMMEMONAME
        IF "MEMO" $ cMyName
        &#0009;? "Symbol name contains the string MEMO"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.String2Symbol'>String2Symbol</seealso>
  </symbol2string>
  <sysaddatom>
    <summary>
      Convert a null-terminated string to a symbol and add it to the atom table.
    </summary>

    <param name="pszString">A pointer to the null-terminated string to convert.</param>
    <returns>
      A symbol which is added to the atom table if it is not already there.
    </returns>
    <remarks>
      <note type="tip">
        Although literal symbols are converted to uppercase letters, symbols created using SysAddAtom() are not;  SysAddAtom() preserves the casing of letters as specified in the function argument.  SysAddAtomUpperA(), on the other hand, converts its argument to uppercase and creates the resulting symbol in uppercase, the same way a literal symbol does.
      </note>
    </remarks>
    <example>
      This example uses SysAddAtom() to convert names to symbols and illustrates how the return value from MaxAtom() increases by one as each string is converted, thus adding to the number of symbols currently in use:  (The last conversion does not add to the number of symbols because "Charly" was added to the symbol table earlier).
      <code language="X#">
        SysAddAtom("Vera")&#0009;&#0009;&#0009;// Convert Vera
        ? MaxAtom()&#0009;&#0009;&#0009;&#0009;&#0009;// 7531
        SysAddAtom("Charly")&#0009;&#0009;// Convert Charly
        ? MaxAtom()&#0009;&#0009;&#0009;&#0009;&#0009;// 7532
        SysAddAtom("Odile")&#0009;&#0009;&#0009;// Convert Odile
        ? MaxAtom()&#0009;&#0009;&#0009;&#0009;&#0009;// 7533
        SysAddAtom("Charly")&#0009;&#0009;// Convert Charly
        ? MaxAtom()&#0009;&#0009;&#0009;&#0009;&#0009;// Still 7533
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.String2Symbol'>String2Symbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysAddAtomUpperA'>SysAddAtomUpperA</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysFindAtom'>SysFindAtom</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysGetAtomName'>SysGetAtomName</seealso>
  </sysaddatom>
  <sysaddatomuppera>
    <summary>
      Convert a null-terminated string to an uppercase symbol and add it to the atom table.
    </summary>

    <param name="pszString">The null-terminated string to convert.</param>
    <returns>
      An uppercase symbol which is added to the atom table if it is not already there.
    </returns>
    <remarks>
      SysAddAtomUpperA() converts its argument to uppercase and creates the resulting symbol in uppercase, the same way a literal symbol does.  SysAddAtom(), on the other hand, preserves the casing of letters as specified in the function argument.
    </remarks>
    <example>
      This example uses SysAddAtomUpperA:
      <code language="X#">
        LOCAL pszC := "Hello" AS PSZ
        ? SysAddAtomUpperA(pszC)&#0009;&#0009;&#0009;// HELLO
        ? pszC &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// "HELLO"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.String2Symbol'>String2Symbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysAddAtom'>SysAddAtom</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysFindAtom'>SysFindAtom</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysGetAtomName'>SysGetAtomName</seealso>
  </sysaddatomuppera>
  <sysfindatom>
    <summary>
      Determine whether a symbol is in the atom table.
    </summary>

    <param name="pszString">The string that corresponds to the symbol you are checking on.</param>
    <returns>
      If found, the symbol value corresponding to the string is returned.<br/>
      If not found, a symbol value corresponding to a non-existing symbol, WORD(_CAST,65535), is returned.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses SysFindAtom() and type casting to determine whether the string "Charly" exists:
      <code language="X#">
        IF Word(_CAST, SysFindAtom("Charly")) ;
        &#0009;&#0009;&#0009;&#0009;= Word(_CAST, 65535)
        &#0009;? "Charly was not found"
        ELSE
        &#0009;? "Charly was found"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.SysAddAtom'>SysAddAtom</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysAddAtomUpperA'>SysAddAtomUpperA</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysGetAtomName'>SysGetAtomName</seealso>
  </sysfindatom>
  <sysgetatomname>
    <summary>
      Convert a symbol to a null-terminated string.
    </summary>

    <param name="symVar">The symbol to convert.</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses SysGetAtomName() to convert a symbol to a string:
      <code language="X#">
        symC := SysAddAtom("Chuck")
        ? SysGetAtomName(symC)   &#0009;&#0009;&#0009;// "Chuck"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Symbol2String'>Symbol2String</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysAddAtom'>SysAddAtom</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysAddAtomUpperA'>SysAddAtomUpperA</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysFindAtom'>SysFindAtom</seealso>
  </sysgetatomname>
  <tan>
    <summary>
      Calculate the tangent of a number.
    </summary>

    <param name="nNum">An angle in radians.</param>
    <returns>
      The tangent of the specified angle.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example uses Tan() to calculate the tangent of 1.38 radians:
      <code language="X#">? Tan(1.38)&#0009;&#0009;&#0009;&#0009;// 5.18</code>
      This example shows that the tangent is equal to the sine over the cosine:
      <code language="X#">? Sin(1.38)/Cos(1.38)&#0009;&#0009;// 5.18</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ATan'>ATan</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cos'>Cos</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cot'>Cot</seealso>
    <seealso cref='O:XSharp.RT.Functions.Sin'>Sin</seealso>
  </tan>
  <time>
    <summary>
      Return the system time in a format determined by various international settings.
    </summary>
    <returns>
      The format of the return value is dependent on several functions, including SetAMPM(), SetAMExt(), SetPMExt(), and SetInternational(), which you can refer to for more information.
    </returns>
    <remarks>
      Time() returns the system time.  Time() is related to Seconds(), which returns the integer value representing the number of seconds since midnight.
    </remarks>
    <example>
      These examples show the results of Time() under various circumstances:
      <code language="X#">
        SetInternational(#Windows)
        // Assuming 12-hour time with "AM" and "PM"extensions
        // and colon separator set in Control Panel
        ? Time()&#0009;&#0009;&#0009;&#0009;&#0009;// 02:37:17 PM
        SetInternational(#Clipper)
        ? Time()&#0009;&#0009;&#0009;&#0009;&#0009;// 14:37:19
        SetAMPM(TRUE)&#0009;&#0009;&#0009;// 12-hour format
        SetPMExt(" pm")
        ? Time()&#0009;&#0009;&#0009;&#0009;&#0009;// 02:37:21 pm
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ElapTime'>ElapTime</seealso>
    <seealso cref='O:XSharp.Core.Functions.Seconds'>Seconds</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAMExt'>SetAMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAmPm'>SetAMPM</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPMExt'>SetPMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetTimeSep'>SetTimeSep</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
    <seealso cref='O:XSharp.RT.Functions.Today'>Today</seealso>
  </time>
  <time24>
    <summary>
      Return the system time in 24-hour format.
    </summary>
    <returns>
      The system time in the form hh:mO:ss, where hh is hours in 24-hour format, mm is minutes, and ss is seconds.
    </returns>
    <remarks>
      Time24() does not depend on any other setting to determine its output format.  Instead, it returns the system time.  Time() is related to Seconds(), which returns the integer value representing the number of seconds since midnight.
    </remarks>
    <example>
      These examples show the results of Time24() used with Substr() to extract the hour, minutes, and seconds:
      <code language="X#">
        ? Time24()&#0009;&#0009;&#0009;&#0009;// 10:37:17
        ? Substr3(Time24(), 1, 2)&#0009;&#0009;// 10
        ? Substr3(Time24(), 4, 2)&#0009;&#0009;// 37
        ? Substr3(Time24(), 7, 2)&#0009;&#0009;// 17
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
  </time24>
  <today>
    <summary>
      Return the system date as a date value.
    </summary>
    <returns>
    </returns>
    <remarks>
      This function provides a means of initializing memory variables to the current date, comparing other date
      values to the current date, and performing date arithmetic relative to the current date.
      The display format for dates is controlled by SetDateFormat() and the SET DATE command.<br/>
      The default format is mm/dd/yy.
    </remarks>
    <example>
      These examples show Today() used in various ways:
      <code language="X#">
        ? Today()&#0009;&#0009;&#0009;&#0009;&#0009;// 09/09/98
        ? Today() + 30&#0009;&#0009;&#0009;&#0009;// 10/09/98
        ? Today() - 30&#0009;&#0009;&#0009;&#0009;// 08/10/98
        dDate := Today()
        ? CMonth(dDate)&#0009;&#0009;&#0009;// September
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CToD'>CToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToC'>DToC</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToS'>DToS</seealso>
    <seealsocmd>SET DATE</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetDateCountry'>SetDateCountry</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDateFormat'>SetDateFormat</seealso>
  </today>
  <tohira>
    <summary>
      Convert single-byte and double-byte katakana characters in a string to their double-byte hiragana equivalents.
    </summary>

    <param name="cMBTarget">The string to convert.</param>
    <returns>
      <paramref name="cMBTarget" /> with the specified characters changed.
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.ToJNum'>ToJNum</seealso>
    <seealso cref='O:XSharp.VO.Functions.ToKata'>ToKata</seealso>
  </tohira>
  <tojnum>
    <summary>
      Convert the single-byte and double-byte numbers in a string to double-byte kanji numbers.
    </summary>

    <param name="cMBTarget">The string of numbers to convert.</param>
    <returns>
      <paramref name="cMBTarget" /> with the specified numbers changed.
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.ToHira'>ToHira</seealso>
    <seealso cref='O:XSharp.VO.Functions.ToKata'>ToKata</seealso>
  </tojnum>
  <tokata>
    <summary>
      Convert single-byte katakana and double-byte hiragana characters in a string to their double-byte katakana equivalents.
    </summary>

    <param name="cMBTarget">The string to convert.</param>
    <returns>
      <paramref name="cMBTarget" /> with the specified characters changed.
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.ToHira'>ToHira</seealso>
    <seealso cref='O:XSharp.VO.Functions.ToJNum'>ToJNum</seealso>
  </tokata>
  <tone>
    <summary>
      Sound a speaker tone for a specified frequency and duration.
      Note:<br/>
      Tone() is a compatibility function and is no longer recommended.<br/>
      It is superseded by the Windows API MessageBeep(), SndPlaySound(), and the MCI family of functions.  MessageBeep() is defined in the System Library, whereas the other functions are defined in the Win32 API library.  In order to use these functions, you must include the Win32 API library in your application's search path.
    </summary>

    <param name="wFrequency">The frequency of the tone to sound.</param>
    <param name="wDuration">
      The duration of the tone measured in increments of 1/18 of a second.<br/>
      For example, an <paramref name="wDuration" /> value of 18 represents one second.<br/>

      &#0009;For both arguments, noninteger values are truncated — not rounded — to their integer portion.
    </param>
    <returns>
    </returns>
    <remarks>
      Tone() is a sound function that indicates various program states to the user.<br/>
      These can be error states, boundary conditions, or the end of a time-consuming process.<br/>
      For example, an error state would sound an error tone before alerting the user with a message or interactive dialog box.<br/>
      A boundary condition might indicate that the user is attempting to cursor past the top or bottom of a column in a TBrowse object.<br/>
      A batch process also might indicate its completion with a sound to alert the user, in case the user has turned away from the screen.
      Tone() works by sounding the speaker at the specified frequency for the specified duration.<br/>
      The duration is measured in increments of 1/18 of a second.<br/>
      The frequency is measured in hertz (cycles per second).  Frequencies of less than 20 are inaudible.<br/>
      The table below shows the frequencies of standard musical notes.
      Note:<br/>
      Tone() works only on IBM PC and 100% compatible computers.
      Pitch&#0009;Frequency&#0009;Pitch&#0009;Frequency&#0009;
      C&#0009;130.80&#0009;mid C&#0009;261.70&#0009;
      C#&#0009;138.60&#0009;C#&#0009;277.20&#0009;
      D&#0009;146.80&#0009;D&#0009;293.70&#0009;
      D#&#0009;155.60&#0009;D#&#0009;311.10&#0009;
      E&#0009;164.80&#0009;E&#0009;329.60&#0009;
      F&#0009;174.60&#0009;F&#0009;349.20&#0009;
      F#&#0009;185.00&#0009;F#&#0009;370.00&#0009;
      G&#0009;196.00&#0009;G&#0009;392.00&#0009;
      G#&#0009;207.70&#0009;G#&#0009;415.30&#0009;
      A&#0009;220.00&#0009;A&#0009;440.00&#0009;
      A#&#0009;233.10&#0009;A#&#0009;466.20&#0009;
      B&#0009;246.90&#0009;B&#0009;493.90&#0009;
      &#0009;&#0009;C&#0009;523.30&#0009;
    </remarks>
    <example>
      This example is a beep function that indicates that a batch operation has completed:
      <code language="X#">
        FUNCTION DoneBeep()
        &#0009;Tone(300, 1)
        &#0009;Tone(100, 1)
        &#0009;Tone(300, 1)
        &#0009;Tone(100, 1)
      </code>
      This example is a tone sequence that indicates invalid keystrokes or boundary conditions:
      <code language="X#">
        FUNCTION ErrorBeep()
        &#0009;Tone(100, 3)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Chr'>Chr</seealso>
  </tone>
  <toword>
    <summary>
      Convert a number to a word.
    </summary>

    <param name="nNumber">The number to convert to a word, specified in the range of plus or minus 32,767, inclusive.</param>
    <returns>
    </returns>
    <remarks>
      ToWord() can be used in situations where a word is preferred or required, such as when passing arguments to a DLL function.
      <note type="tip">
        ToWord() is the same as the Word() function in CA-Clipper, but WORD is a reserved word in X#.<br/>
        Under X#, Word() is a conversion operator.  With numbers that are not greater than a WORD type number, it yields the same results as ToWord() and maintains compatibility with CA-Clipper.
      </note>
    </remarks>
    <example>
      This example uses ToWord() as an argument to a function which expects a short integer:
      <code language="X#">
        LOCAL n := 30000 AS USUAL
        CProc(ToWord(n))
        FUNCTION CProc(siV AS SHORTINT)
        &#0009;? siV
      </code>
    </example>
  </toword>
  <transform>
    <summary>
      Convert any value into a formatted string.
    </summary>

    <param name="uValue">
      The value to format.<br/>
      This expression can be any valid X# data type except array, code block, object, and NIL.
    </param>
    <param name="cSayPicture">A string of picture and template characters that describes the format of the returned string.</param>
    <returns>
      A formatted string as defined by <paramref name="cSayPicture" />.
    </returns>
    <remarks>
      Transform() is a conversion function that formats character, date, logical, and numeric values according to a specified picture string that includes a combination of picture function and template strings.  Transform() formats data for output to the screen or the printer in the same manner as the PICTURE clause of the @...SAY command.<br/>
      To convert the transformed string back to its original value, use Unformat().
      Function string:<br/>
      A picture function string specifies formatting rules that apply to the Transform() return value as a whole, rather than to particular character positions within <paramref name="uValue" />.<br/>
      The function string consists of the @ character, followed by one or more additional characters, each of which has a particular meaning (see table below).<br/>
      If a function string is present, the @ character must be the leftmost character of the picture string, and the function string must not contain spaces.<br/>
      A function string can be specified alone or with a template string.<br/>
      If both are present, the function string must precede the template string, and the two must be separated by a single space.
      Function&#0009;Action&#0009;
      B&#0009;Displays numbers left-justified&#0009;
      C&#0009;Displays CR after positive numbers&#0009;
      D&#0009;Displays date in SET DATE format&#0009;
      E&#0009;Displays date in British format&#0009;
      R&#0009;Nontemplate characters are inserted&#0009;
      X&#0009;Displays DB after negative numbers&#0009;
      Z&#0009;Displays zeros as blanks&#0009;
      (&#0009;Encloses negative numbers in parentheses&#0009;
      !&#0009;Converts alphabetic characters to uppercase&#0009;
      Template string:<br/>
      A picture template string specifies formatting rules on a character by character basis.<br/>
      The template string consists of a series of characters, some of which have special meanings (see table below).<br/>
      Each position in the template string corresponds to a position in the value of the <paramref name="uValue" /> argument.  Because Transform() uses a template, it can insert formatting characters such commas, dollar signs, and parentheses.
      Characters in the template string that have no assigned meanings are copied literally into the return value.<br/>
      If the @R picture function is used, these characters are inserted between characters of the return value; otherwise, they overwrite the corresponding characters of the return value.<br/>
      A template string can be specified alone or with a function string.<br/>
      If both are present, the function string must precede the template string, and the two must be separated by a single space.
      Template&#0009;Action&#0009;
      A,N,X,9,#&#0009;Displays digits for any data type&#0009;
      L&#0009;Displays logicals as "T" or "F"&#0009;
      Y&#0009;Displays logicals as "Y" or "N"&#0009;
      !&#0009;Converts an alphabetic character to uppercase&#0009;
      $&#0009;Displays a dollar sign in place of a leading space in a numeric
      *&#0009;Displays an asterisk in place of a leading space in a numeric
      .&#0009;Specifies a decimal point position&#0009;
      ,&#0009;Specifies a comma position&#0009;
    </remarks>
    <example>
      This example formats a number into a currency format using a template:
      <code language="X#">? Transform(123456, "$999,999")&#0009;// Result: $123,456</code>
      This example formats a string using a function:
      <code language="X#">? Transform("to upper", "@!")&#0009;&#0009;// Result: TO UPPER</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Lower'>Lower</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.Core.Functions.Upper'>Upper</seealso>
    <seealso cref='O:XSharp.RT.Functions.Unformat'>Unformat</seealso>
  </transform>
  <trim>
    <summary>
      Remove trailing spaces from a string.
    </summary>

    <param name="cString">The string to trim.</param>
    <returns>
      <paramref name="cString" /> with the trailing spaces removed.<br/>
      If <paramref name="cString" /> is a NULL_STRING or all spaces, Trim() returns a NULL_STRING.
    </returns>
    <remarks>
      Trim() is used to format strings by deleting trailing spaces while concatenating strings.<br/>
      This is typically the case with database fields which are stored in fixed-width format.<br/>
      For example, you can use Trim() to concatenate first and last name fields to form a name string.
      Trim() is related to LTrim(), which removes leading spaces, and AllTrim(), which removes both leading and trailing spaces.<br/>
      The inverse of AllTrim(), LTrim(), and Trim() are the PadC(), PadR(), and PadL() functions, which center, right-justify, or left-justify strings by padding them with fill characters.
    </remarks>
    <example>
      This is a function in which Trim() formats city, state, and zip code fields for labels or form letters:
      <code language="X#">
        FUNCTION CityState(cCity, cState, cZip)
        &#0009;RETURN Trim(cCity) + ", " ;
        &#0009;&#0009;&#0009;&#0009;+ Trim(cState) + "  " + cZip
      </code>
      To complete the example the function, CityState(), displays a record from CUSTOMER.DBF:
      <code language="X#">
        USE customer INDEX custname NEW
        SEEK "Kate"
        ? CityState(City, State, ZipCode)
        // Athens, GA 10066
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AllTrim'>AllTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadC'>PadC</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadL'>PadL</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadR'>PadR</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </trim>
  <tstring>
    <summary>
      Convert a specified number of seconds to a time string.
    </summary>

    <param name="nSeconds">The number of seconds to convert.  </param>
    <returns>
      The format of the return value is dependent on several functions, including SetAMPM(), SetAMExt(), SetPMExt(), and SetInternational(), which you can refer to for more information.<br/>
      If <paramref name="nSeconds" /> is greater than 86,400 (the number of seconds in one day), the number of seconds past the whole number of days is returned (see the second example below).
    </returns>
    <remarks>
      TString() converts a specified number of seconds to a time string.  Days() is a related function that is particularly useful when <paramref name="nSeconds" /> is greater than 86,400, since it returns the number of full days in a given number of seconds.
    </remarks>
    <example>
      This example uses TString() on a number less than 86,400.<br/>
      The initial settings define a 12-hour time format with " AM" and " PM" as the morning and evening extensions:
      <code language="X#">
        SetAMPM(TRUE)
        SetAMExt(" AM")
        SetPMExt(" PM")
        ? TString(6400)&#0009;&#0009;// 01:46:40 AM
      </code>
      This example passes 303,600 to TString().  Since 303,600 seconds is equal to 3 days, 11 hours, and 20 minutes, TString() only returns the time past the whole 3 days.<br/>
      The initial settings define a 24-hour format with no morning or evening extension:
      <code language="X#">
        SetAMPM(FALSE)
        SetAMExt(NULL_STRING)
        SetPMExt(NULL_STRING)
        ? TString(303600)&#0009;&#0009;// 12:20:00
        ? Days(303600)&#0009;&#0009;&#0009;// 3
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Days'>Days</seealso>
    <seealso cref='O:XSharp.Core.Functions.Secs'>Secs</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAMExt'>SetAMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAmPm'>SetAMPM</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPMExt'>SetPMExt</seealso>
  </tstring>
  <type>
    <summary>
      Determine the data type of an expression represented as a string.
    </summary>

    <param name="cString">
      A string that contains an expression whose type is to be determined.<br/>
      It cannot contain undeclared variables or functions that are not intended for used with macros<br/>
      If <paramref name="cString" /> does not exist, "U" is returned.
    </param>
    <returns>
      One of the following characters:
      Returns&#0009;Meaning&#0009;
      A&#0009;Array&#0009;
      B&#0009;Block&#0009;
      C&#0009;String&#0009;
      D&#0009;Date&#0009;
      L&#0009;Logical&#0009;
      M&#0009;Memo&#0009;
      N&#0009;Numeric&#0009;
      O&#0009;Object&#0009;
      U&#0009;NIL, local, or static&#0009;
      UE&#0009;Error syntactical&#0009;
      UI&#0009;Error indeterminate&#0009;
    </returns>
    <remarks>
      Type() uses the macro operator (&amp;) to determine the argument's data type; therefore, you cannot use it to determine the data type of undeclared variables or functions that are not intended for used with macros.<br/>
      Use UsualType() for these expressions.
      <note type="tip">
        Array references:  References to private and public arrays return "A."  References to array elements return the type of the element.
        If():<br/>
        To return the appropriate data type for an If() expression, Type() evaluates the condition then returns the type of the evaluated path.<br/>
        If either the If() condition or the evaluated path are invalid, Type() returns "UE."
        Testing parameters:  Type() can only test the validity of parameters received using the PARAMETERS statement.  Testing a parameter declared as part of a FUNCTION or PROCEDURE declaration always returns "U." because local parameters do not have a symbol in the symbol table.<br/>
        To determine whether an argument was skipped or left off the end of the argument list, compare it to NIL or use IsNil().
      </note>
    </remarks>
    <example>
      These examples demonstrate various results from invocations of Type():
      <code language="X#">
        ? Type('Substr("Hi There", 4, 5)')&#0009;&#0009;// C
        ? Type("UdF()")&#0009;&#0009;&#0009;&#0009;&#0009;// UI
        ? Type('If(TRUE, "true", 12)')&#0009;&#0009;&#0009;// C
        PROCEDURE NilParameters()
        &#0009;PARAMETERS cParam1, nParam2, uParam3
        &#0009;IF cParam1 = NIL
        &#0009;&#0009;? "First parameter was not passed"
        &#0009;&#0009;cParam1 := "Default value"
        &#0009;ENDIF
        &#0009;IF Type("nParam2") = "U"
        &#0009;&#0009;? "Second parameter was not passed"
        &#0009;ENDIF
        &#0009;IF IsNil(uParam3)
        &#0009;&#0009;? "Third parameter was not passed"
        &#0009;ENDIF
        .
        . <paramref name="Statements" />
        .
      </code>
      This example shows the difference between Type(), ValType(), UsualType(), and UsualVal().  Note that Type() macro-expands the contents of the string before evaluating it, whereas UsualType() does not:
      <code language="X#">
        num := 10&#0009;&#0009;&#0009;&#0009;&#0009;// Undeclared variable
        ? Type("num + num")&#0009;&#0009;&#0009;// N
        ? ValType(num + num)&#0009;&#0009;// N
        ? UsualType("num + num")&#0009;&#0009;// 7 (stands for STRING)
        ? UsualVal(num + num)&#0009;&#0009;// 20
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </type>
  <unformat>
    <summary>
      Convert a transformed string back to its original value.
    </summary>

    <param name="cFormatString">The string to convert.</param>
    <param name="cSayPicture">The picture string used when the original value was converted.</param>
    <param name="cType">
      The data type of the original value.<br/>
      This can be any valid X# data type except array, code block, object, and NIL.
    </param>
    <returns>
      The original value.
    </returns>
    <remarks>
      Unformat() is the inverse of Transform().<br/>
      It uses the picture string to convert back to its original value a value that was converted into a formatted string with the Transform() function.<br/>
      It is useful for converting data that was entered from a single-line edit which included picture characters.
      <note type="tip">
        If the Transform() function overwrote characters in the original value, the overwritten characters are lost and the characters that overwrote them appear in their place.<br/>
        Also, any characters or numbers that were truncated are not restored.
      </note>
    </remarks>
    <example>
      This example converts a number in currency format back to its original numeric format:
      <code language="X#">
        ? Unformat("$123,456.78", "@R $999,999.99", "N")
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Result: numeric 123456.78
      </code>
      This example converts a formatted string back to its unformatted state:
      <code language="X#">
        ? Unformat("(516)555-1212", "@R (AAA)AAA-AAAA", "C")
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Result: string 5165551212
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Transform'>Transform</seealso>
    <seealso cref='O:XSharp.RT.Functions.Val'>Val</seealso>
  </unformat>
  <unregisteraxit>
    <summary>
      Terminate the registration of an object that has been registered with RegisterAxit().
    </summary>

    <param name="oObject">The object that you want to stop registering.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      When the garbage collector calls the Axit() method, it automatically terminates registration of the object after the Axit() method is complete, so UnregisterAxit() is only necessary if you directly or explicitly call the Axit() method in your application.  Before calling UnregisterAxit() make sure that InCollect() is FALSE.
    </remarks>
    <example>
      This example calls UnregisterAxit() after checking for InCollect():
      <code language="X#">
        IF !InCollect()
        &#0009;UnregisterAxit()
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.InCollect'>InCollect</seealso>
    <seealso cref='O:XSharp.RT.Functions.RegisterAxit'>RegisterAxit</seealso>
  </unregisteraxit>
  <unregisterkid>
    <summary>
      Remove the registration of an object that was registered to the garbage collector.
    </summary>

    <param name="ptrObject">A pointer to the object you want to unregister.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      UnregisterKid() unregisters an object that was previously registered for update after garbage collection via the RegisterKid() function.<br/>
      The pointer to the dynamic object once again becomes subject to the garbage collector and could become invalid after a garbage collection.
    </remarks>
    <example>
      This example uses UnregisterKid():
      <code language="X#">
        STRUCTURE StrucMyStrings
        &#0009;MEMBER DIM aStr[10] AS PTR
        Function Start()
        &#0009;LOCAL wI AS DWORD
        &#0009;LOCAL strucMyArray AS StrucMyStrings
        &#0009;strucMyArray ;
        &#0009;&#0009;:= MemCAlloc(_SizeOf(StrucMyStrings), 1)
        &#0009;RegisterKid(strucMyArray, 10, FALSE)
        &#0009;FOR wI := 1 UPTO 10
        &#0009;&#0009;strucMyArray.aStr[wI] := Ptr(_CAST, STR(wI))
        &#0009;NEXT
        &#0009;CollectForced()&#0009;&#0009;&#0009;// Force a garbage collection
        &#0009;UnregisterKid(strucMyArray)
        &#0009;// Collection is complete: unregister objects
        &#0009;// Objects have survived after a collection:
        &#0009;FOR wI := 1 UPTO 10
        &#0009;&#0009;MessageBox(0, strucMyArray.aStr[wI], ;
        &#0009;&#0009;&#0009;&#0009;Psz(wI), 0)
        &#0009;NEXT
        &#0009;MemFree(strucMyArray)
        &#0009;// Don't forget to free the allocated memory when you're done
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.RegisterAxit'>RegisterAxit</seealso>
    <seealso cref='O:XSharp.VO.Functions.RegisterKid'>RegisterKid</seealso>
  </unregisterkid>
  <unregisteroleautomati>
    <summary>
      Remove the registration of a X# object that was registered previously as an active automation server object.
    </summary>

    <param name="oObject">The object registered as an automation server.</param>
    <returns>
      TRUE, if the operation was successful; otherwise, FALSE.
    </returns>
    <remarks>
      UnRegisterOLEAutomationObject() unregisters a X# object that was previously registered by a call to RegisterOLEAutomationObject().
      Note:<br/>
      If you use the AutoServer base class or the Automated property in the GUI classes, you do not have to call this function explicitly.
      See Creating OLE Servers in Visual Obects in the "How To" section of the online help for further details.
    </remarks>
    <example>
    </example>
    <seealsocmd>CLASS AutoServer</seealsocmd>
    <seealsocmd>RegisterOLEAutomationObject</seealsocmd>
    <seealsocmd>Window:Automated</seealsocmd>
  </unregisteroleautomati>
  <upper>
    <summary>
      Convert the lowercase and mixed case characters in a string to uppercase.
    </summary>

    <param name="cString">The string to convert to uppercase.</param>
    <returns>
      <paramref name="cString" /> with all alphabetical characters converted to uppercase.<br/>
      All other characters remain the same as in the original string.
    </returns>
    <remarks>
      Upper() is related to Lower(), which converts uppercase and mixed case strings to lowercase.<br/>
      Upper() is also related to IsUpper() and IsLower(), which determine whether a string begins with an uppercase or lowercase letter.
      Upper() is generally used to format strings for display purposes.<br/>
      It can, however, be used to normalize strings for case-independent comparison or indexing purposes.
      Upper() and UpperA() are nation-dependent.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.Lower'>Lower</seealso>
    <seealso cref='O:XSharp.Core.Functions.UpperA'>UpperA</seealso>
  </upper>
  <uppera>
    <summary>
      Convert the lowercase and mixed case characters in a string to uppercase, changing the contents of the argument as well as the return value.
    </summary>

    <param name="cString">The string to convert to uppercase.</param>
    <returns>
      <paramref name="cString" /> with all alphabetical characters converted to uppercase.<br/>
      All other characters remain the same as in the original string.
    </returns>
    <remarks>
      UpperA() is similar to Upper() except that it changes the contents of the argument as well as the return value.  See Upper() for details.
      <note type="tip">
        You may change more than one variable at the same time (see example below).
      </note>
    </remarks>
    <example>
      These examples illustrate the effects of UpperA().  Compare them to the results of the Upper() example:
      <code language="X#">
        LOCAL cName AS STRING
        cName := "noLi1"
        ? UpperA(cName)&#0009;&#0009;&#0009;&#0009;// NOLI1
        ? cName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// NOLI1
      </code>
      This example shows how you may change more than one variable at the same time:
      <code language="X#">
        a:= "i Change"
        b:= a
        UpperA(b)
        ? b // "I Change"
        ? a // "I Change"
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.Lower'>Lower</seealso>
    <seealso cref='O:XSharp.Core.Functions.Upper'>Upper</seealso>
  </uppera>
  <used>
    <summary>
      Determine whether a database file is open.
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      TRUE if there is a database file in use; otherwise, FALSE.
    </returns>
    <remarks>
      Used() determines whether there is a database file in use in a work area.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      This example determines whether a database file is in use in the current work area:
      <code language="X#">
        USE customer NEW
        QOut(Used())&#0009;&#0009;&#0009;// Result: TRUE
        CLOSE
        QOut(Used())&#0009;&#0009;&#0009;// Result: FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias'>Alias</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
    <seealsocmd>USE</seealsocmd>
  </used>
  <usualtype>
    <summary>
      Determine the data type of an expression.
    </summary>

    <param name="uValue">The expression whose data type you want to return.</param>
    <returns>
      The data type of <paramref name="uValue" />.<br/>
      The return values have the following meanings:
      Returns&#0009;Meaning&#0009;
      ARRAY&#0009;Array&#0009;
      CODEBLOCK&#0009;Code block&#0009;
      DATE&#0009;Date&#0009;
      FLOAT&#0009;Float, Real4, Real8&#0009;
      LOGIC&#0009;Logical value&#0009;
      LONGINT&#0009;Byte, Word, DWord, ShortInt, Int, LongInt&#0009;
      OBJECT&#0009;Object or runtime code block (see example below)&#0009;
      VOID&#0009;NIL&#0009;
      PTR&#0009;Pointer&#0009;
      STRING&#0009;String, PSZ&#0009;
      SYMBOL&#0009;Symbol&#0009;
      If <paramref name="uValue" /> is passed by reference, 128 is automatically added to the return value (see the last example).
    </returns>
    <remarks>
      UsualType() does not macro expand strings.<br/>
      UsualType() is faster and provides more detailed information than the old ValType() function.
    </remarks>
    <example>
      This example displays different results, depending on the type of the variable:
      <code language="X#">
        xType := USUALTYPE(xVar)
        DO CASE
        CASE xType =STRING
        &#0009;? "String"
        CASE xType =LONGINT
        &#0009;? "LongInt"
        CASE xType =DATE
        &#0009;? "Date"
        OTHERWISE&#0009;
        &#0009;? "One of the many others"
        ENDCASE
      </code>
      These examples show the numeric return values for several data types:
      <code language="X#">
        ? UsualType(1) = LONGINT&#0009;&#0009;&#0009;// TRUE
        ? UsualType("D. Lyon") = STRING&#0009;// TRUE
        ? UsualType(NIL)&#0009;= 0&#0009;&#0009;&#0009;// TRUE
        ? UsualType({"An Array"}) = ARRAY&#0009;// TRUE
        ? UsualType(block) = CODEBLOCK&#0009;&#0009;// TRUE
      </code>
      This example shows the difference between Type(), ValType(), UsualType(), and UsualVal().  Note that Type() macro-expands the contents of the string before evaluating it, whereas UsualType() does not:
      <code language="X#">
        num := 10&#0009;&#0009;&#0009;&#0009;&#0009;// Undeclared variable
        ? Type("num + num")&#0009;&#0009;&#0009;// N
        ? ValType(num + num)&#0009;&#0009;// N
        ? UsualType("num + num")&#0009;&#0009;// 7 (stands for STRING)
        ? UsualVal(num + num)&#0009;&#0009;// 20
      </code>
      This example shows the differences between the UsualType() of a compile-time code block and a runtime code block:
      <code language="X#">
        // Hard-coded code block is visible at compile
        // time:
        LOCAL cb := {||"Compile time"}
        LOCAL ob
        // The code block is within quotes so the compiler
        // is not aware of it at compile time:
        ob := Evaluate("{||'Run time'}")
        ? UsualType(cb)&#0009;&#0009;&#0009;// CODEBLOCK
        ? UsualType(ob)&#0009;&#0009;&#0009;// OBJECT
      </code>
      This example shows how 128 is added to the return value when a value is passed by reference:
      <code language="X#">
        FUNCTION PassRef()
        &#0009;LOCAL v AS STRING
        &#0009;v := NULL_STRING
        &#0009;AtFront(@v)
        FUNCTION AtFront(pv)
        &#0009;// @STRING
        &#0009;? UsualType(@pv)&#0009;&#0009;// 7 + 128 = 135
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsCodeBlock'>IsCodeBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethodUsual'>IsMethodUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.Type'>Type</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualVal'>UsualVal</seealso>
    <seealso cref='O:XSharp.RT.Functions.ValType'>ValType</seealso>
  </usualtype>
  <usualval>
    <summary>

      <br/>



      Access contents of an address, whether it is passed by reference or not.
    </summary>

    <param name="uValue">
      An expression of any type.<br/>
      This can be referenced or preceded with the @ sign.
    </param>
    <returns>
      The actual content of <paramref name="uValue" />, whether it was referenced or not.
    </returns>
    <remarks>
      UsualVal() can be used to retrieve the contents of an argument that is passed by reference or preceded by the @ sign.
    </remarks>
    <example>
      This example shows how UsualVal() retrieves the content of an argument that is passed by reference:
      <code language="X#">? UsualVal(@Var) = Var&#0009;&#0009;// TRUE</code>
      This example shows how UsualVal() retrieves the content of an argument that is not passed by reference:
      <code language="X#">? UsualVal(Var) = Var&#0009;&#0009;// TRUE</code>
      This example shows the difference between Type(), ValType(), UsualType(), and UsualVal().  Note that Type() macro-expands the contents of the string before evaluating it, whereas ValType() does not:
      <code language="X#">
        num := 10&#0009;&#0009;&#0009;&#0009;&#0009;// Undeclared variable
        ? Type("num + num")&#0009;&#0009;&#0009;// N
        ? ValType(num + num)&#0009;&#0009;// N
        ? UsualType("num + num")&#0009;&#0009;// 7(stands for STRING)
        // Argument was not referenced below
        ? UsualVal(num + num)&#0009;&#0009;// 20
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Type'>Type</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
    <seealso cref='O:XSharp.RT.Functions.ValType'>ValType</seealso>
  </usualval>
  <val>
    <summary>
      Convert a string containing a numeric value to a numeric data type.
    </summary>

    <param name="cNumber">
      The string to convert.  <paramref name="cNumber" /> can be in any of the compiler-supported base formats, such as binary, decimal, hex, or scientific.  When in scientific format, a decimal point is necessary to identify the base "E".  So Val("1E+1") equals 1 but Val("1.0E+1") equals 10.0.  Moreover, "+INF" and "-INF" (both must be in uppercase) represent +infinity and -infinity.
    </param>
    <returns>
      <paramref name="cNumber" /> as a numeric value.
    </returns>
    <remarks>
      If <paramref name="cNumber" /> is a valid numeric expression, Val() processes it all.  However, if <paramref name="cNumber" />  is not entirely a valid numeric expression but does contain decimal numerics, Val() evaluates it until it reaches a second decimal point, the first non-numeric character, or the end of the expression.
      Leading spaces are always ignored.
      All variables containing a FLOAT type have internal picture information (like a template) relating to digits and decimals (see FloatFormat()).<br/>
      For data base fields of type FLOAT, such picture information resides in the database header structure and is obtainable by FieldVal().
      With the Val() function and with literal floats (that is, hard-coded in source code and thus known at compile-time), the number of decimals is derived from the hard-coded decimal portion and the number of digits is taken from the SetDigit() or SET DIGIT setting.
      Str() and Transform() are closely related to Val() since each converts numeric values to strings.
    </remarks>
    <example>
      This example compares the results when SetFixed() is TRUE and when it is FALSE:
      <code language="X#">
        FUNCTION Start()
        &#0009;SetDecimal(3)
        &#0009;SetFixed(FALSE)
        &#0009;? Val("12.1234")&#0009;&#0009;// 12.1234
        &#0009;SetFixed(TRUE)
        &#0009;? Val("12.1234")&#0009;&#0009;// 12.123
        &#0009;RETURN TRUE
      </code>
      These examples illustrates Val() with SetFixed() set to TRUE and SetDecimal() set to 2:
      <code language="X#">
        SetDecimal(2)
        SetFixed(TRUE)
        ? Val("12.1234")&#0009;&#0009;&#0009;// 12.12
        ? Val("12.1256")&#0009;&#0009;&#0009;// 12.13
        ? Val("12A12")&#0009;&#0009;&#0009;&#0009;// 12.00
        ? Val("A1212")&#0009;&#0009;&#0009;&#0009;// 0.00
        ? Val(Space(1))&#0009;&#0009;&#0009;// 0.00
        ? Val(" 12.12")&#0009;&#0009;&#0009;// 12.12
        ? Val("12 .12")&#0009;&#0009;&#0009;// 12.00
      </code>
      This example applies Val() on a hexadecimal string:
      <code language="X#">? Val("0xFF")&#0009;&#0009;&#0009;&#0009;// 255</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FloatFormat'>FloatFormat</seealso>
    <seealso cref='O:XSharp.RT.Functions.Round'>Round</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetFixed'>SetFixed</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Transform'>Transform</seealso>
  </val>
  <valtype>
    <summary>
      Determine the data type of an expression.
      Note:  ValType() is a compatibility function and is no longer recommended.<br/>
      UsualType() and IsNumeric() work faster and provide more information.
    </summary>

    <param name="uValue">
      The expression whose data type you want to return.<br/>
      If the argument does not exist, an "undefined error" occurs.
    </param>
    <returns>
      One of the following characters, which represent the data type of <paramref name="uValue" />:
      Characters&#0009;Meaning&#0009;
      A&#0009;Array&#0009;
      B&#0009;Code block&#0009;
      C&#0009;String, PSZ&#0009;
      D&#0009;Date&#0009;
      L&#0009;Logic&#0009;
      N&#0009;LongInt, ShortInt, Byte, Word, Dword, Real4, Real8, Float, Numeric&#0009;
      O&#0009;Object&#0009;
      U&#0009;NIL&#0009;
      #&#0009;Symbol&#0009;
      -&#0009;PTR&#0009;
      If <paramref name="uValue" /> is passed by reference, the return value will be preceded by an @ sign (see the second example).
    </returns>
    <remarks>
      ValType() is similar to Type(), but differs by actually evaluating the specified argument and determining the type of the return value.<br/>
      For this reason, you can determine the type of local and static variables and functions.  Type(), by contrast, uses the macro operator (&amp;) to evaluate the type of its argument.
    </remarks>
    <example>
      This example shows the difference between Type(), ValType(), UsualType(), and UsualVal().  Note that Type() macro-expands the contents of the string before evaluating it, whereas ValType() does not:
      <code language="X#">
        num := 10&#0009;&#0009;&#0009;&#0009;&#0009;// Undeclared variable
        ? Type("num + num")&#0009;&#0009;&#0009;// N
        ? ValType(num + num)&#0009;&#0009;// N
        ? UsualType("num + num")&#0009;&#0009;// 7 (stands for STRING)
        ? UsualVal(num + num)&#0009;&#0009;// 20
      </code>
      This example shows how @ is added to the return value when a value is passed by reference:
      <code language="X#">
        FUNCTION PassRef()
        &#0009;LOCAL v AS STRING
        &#0009;AtFront(@v)
        FUNCTION AtFront(pv)
        &#0009;? ValType(@pv)&#0009;&#0009;&#0009;// @C
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Type'>Type</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualVal'>UsualVal</seealso>
  </valtype>
  <varget>
    <summary>
      Return the contents of a field or a memory variable.
    </summary>

    <param name="cVarName">The name of the field or memory variable.</param>
    <returns>
    </returns>
    <remarks>
      VarGet() is used instead of a macro when the name of the field or memory variable is in a string.
    </remarks>
    <example>
      This example uses VarGet() to retrieve the contents of a field:
      <code language="X#">
        LOCAL cFieldName := "Address"
        USE Customer
        // Instead of ? &amp;cFieldName, use this:
        ? VarGet(cFieldName)&#0009;// 101 5th Street
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarGet'>IVarGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarGet'>MemVarGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.VarPut'>VarPut</seealso>
  </varget>
  <varput>
    <summary>
      Assign a value to a field or a memory variable of a given name.
    </summary>

    <param name="cVarName">The name of the variable you want to create.</param>
    <param name="uValue">The value to assign to the variable.</param>
    <returns>
      The value assigned to (uValue).
    </returns>
    <remarks>
      If a field or memory variable called <paramref name="cVarName" /> does not exist, a memory variable called <paramref name="cVarName" /> is created.<br/>
      Therefore, VarPut(), like MemVarPut(), can be used to create undeclared memory variables.<br/>
      It should be used instead of a macro.
    </remarks>
    <example>
      This example uses VarPut() to store a value into a database field:
      <code language="X#">
        LOCAL cFieldName
        cFieldName := "Address"
        VarPut(cFieldName, "Hollywood, Room 222")
      </code>
      This example uses VarPut() to create a memory variable:
      <code language="X#">
        LOCAL cHasName
        cHasName := "cPrivate"
        // Instead of &amp;cHasName := "new", use this:
        VarPut(cHasName, "new")
        ? cPrivate&#0009;&#0009;&#0009;&#0009;&#0009;// new
      </code>
      This example shows that the newly created variable is a MEMVAR:
      <code language="X#">
        VarPut("cVar", "hi")
        ? _MEMVAR-&gt;cVar&#0009;&#0009;&#0009;// hi
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarPut'>IVarPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarPut'>MemVarPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.VarGet'>VarGet</seealso>
  </varput>
  <verifythemestate>
    <summary>
      Verifies the current theme state and sets the ThemeEnabled flag
    </summary>
    <returns>
      The function returns the current value of the ThemeEnabled flag like the function IsThemeEnabled()
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </verifythemestate>
  <version>
    <summary>
      Returns the version of X# you are using.
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </version>
  <vodbalias>
    <summary>
      Return the alias of a specified work area as a string.
    </summary>

    <param name="wWorkArea">Any work area number.</param>
    <returns>
      If there is no database file in use, VODBAlias() returns a NULL_STRING.
    </returns>
    <remarks>
      VODBAlias() is like Alias() but is strongly typed.  See Alias() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias'>Alias</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbAliasSym'>VODBAliasSym</seealso>
  </vodbalias>
  <vodbaliassym>
    <summary>
      Return the alias of a specified work area as a symbol.
    </summary>

    <param name="wWorkArea">Any work area number.</param>
    <returns>
      The alias of the specified work area as a symbol.<br/>
      If there is no database file in use for the specified work area, VODBAlias() returns a  NULL_SYMBOL.
    </returns>
    <remarks>
    </remarks>
    <example>
      This example opens a file, issues the VODBGetSelect() function to determine the current work area number, and then gets the symbol associated with the work area:
      <code language="X#">
        USE file1 NEW ALIAS test1
        nAlias := VODBGetSelect()
        sAlias := VODBAliasSym(nAlias)
        ? sAlias&#0009;&#0009;// Returns: test1
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias0Sym'>Alias0Sym</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbAlias'>VODBAlias</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbGetSelect'>VODBGetSelect</seealso>
  </vodbaliassym>
  <vodbappend>
    <summary>
      Add a new record.
    </summary>

    <param name="lReleaseLocks">TRUE clears all pending record locks, then appends the next record.  FALSE maintains all pending record locks, adding new records to the end of the lock list.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBAppend() is like DBAppend() but is strongly typed.<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBAppend() for more information and examples.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbAppend'>DBAppend</seealso>
  </vodbappend>
  <vodbbof>
    <summary>
      Determine when beginning-of-file is encountered.
    </summary>
    <returns>
      TRUE after an attempt to skip backward beyond the first logical record in a database file or if the current database file contains no records; otherwise, FALSE.<br/>
      If there is no database file open in the current work area, VODBBOF() returns TRUE.
    </returns>
    <remarks>
      VODBBOF() is the same as BOF().  See BOF() for more information and examples.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bof'>BOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbEof'>VODBEOF</seealso>
  </vodbbof>
  <vodbclearfilter>
    <summary>
      Clear a logical filter condition.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBClearFilter() is the same as DBClearFilter().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBClearFilter() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearFilter'>DBClearFilter</seealso>
  </vodbclearfilter>
  <vodbclearlocate>
    <summary>
      Clear a locate condition by deleting the locate code block.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBClearLocate() clears the locate condition by deleting the locate code block.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      A locate condition can be set by DBLocate(), VODBLocate(), VODBSetLocate(), or the LOCATE command.
      Note that this function does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.
    </remarks>
    <example>
      This example sets and retrieves a locate code block, evaluates it against the current record, and finally cleans up:
      <code language="X#">
        DBUseArea(TRUE, "DBFNTX", "address",;
        &#0009;&#0009;&#0009;&#0009;"Address", TRUE)
        VODBSetLocate({|| Name == "Odile"})
        // Process filtered records
        VODBClearLocate()
        // Process unfiltered records
        DBCloseArea()
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.VoDbSetLocate'>VODBSetLocate</seealso>
  </vodbclearlocate>
  <vodbclearrelation>
    <summary>
      Clear any active relations.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBClearRelation() is the same as DBClearRelation().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBClearRelation() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearRelation'>DBClearRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbSetRelation'>VODBSetRelation</seealso>
  </vodbclearrelation>
  <vodbclearscope>
    <summary>Clear the active locate condition.</summary>
    <returns>TRUE if successful; otherwise, FALSE.</returns>
    <remarks>
      This function has nothing to do with DBClearScope().
      That function clears the topscope and bottom scope from the current index.`
      <include file="CoreComments.xml" path="Comments/LastError/*" />
      <note type="tip">VoDbClearScope() and CoreDb.ClearScope() are aliases</note>
    </remarks>
  </vodbclearscope>
  <vodbcloseall>
    <summary>
      Close all files in all work areas.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBCloseAll() is the same as DBCloseAll().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBCloseAll() for more information.
    </remarks>
    <example>
      The following example closes all work areas:
      <code language="X#">
        LOCAL rddList       AS _RDDLIST
        ...
        aRdds := {"CAVODBF", "DBFNTX"}
        n       := ALen(aRdds)
        rddList := MemAlloc( (_SizeOf(DWORD)) + (n * _SizeOf(SYMBOL)) )
        rddList.uiRddCount := n
        FOR i := 1 TO n
        &#0009;rddList.atomRddName[i] := SysAddAtomUpperA(aRdds[i])
        NEXT
        VODBUseArea(TRUE, rddList, "sales", "sales", TRUE, FALSE)
        VODBOrdListAdd("Last", NIL)
        VODBUseArea(TRUE, rddList, "customer", "", TRUE, FALSE)
        MemFree(rddList)
        cLast := customer-&gt;last
        IF (Sales-&gt;(VODBSeek(cLast)))
        &#0009;IF Sales-&gt;(Deleted())
        &#0009;&#0009;IF RLock()
        &#0009;&#0009;&#0009;Sales-&gt;(VODBRecall())
        &#0009;&#0009;&#0009;? "Record deleted: ", sales;
        &#0009;&#0009;&#0009;&#0009;(Deleted())
        &#0009;&#0009;ENDIF
        &#0009;ENDIF
        ELSE
        &#0009;? "Not found"
        ENDIF
        VODBCloseAll()&#0009;&#0009;// Close all work areas
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCloseAll'>DBCloseAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbCloseArea'>VODBCloseArea</seealso>
  </vodbcloseall>
  <vodbclosearea>
    <summary>
      Close all files in a work area.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBCloseArea() is the same as DBCloseArea().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBCloseArea() for more information.
    </remarks>
    <example>
      The following example closes a file via an alias reference:
      <code language="X#">
        LOCAL rddList       AS _RDDLIST
        ...
        aRdds := {"CAVODBF", "DBFNTX"}
        n       := ALen(aRdds)
        rddList := MemAlloc( (_SizeOf(DWORD)) + (n * _SizeOf(SYMBOL)) )
        rddList.uiRddCount := n
        FOR i := 1 TO n
        &#0009;rddList.atomRddName[i] := SysAddAtomUpperA(aRdds[i])
        NEXT
        cLast := "Winston"
        VODBUseArea(TRUE, rddList, "sales", "sales", TRUE, FALSE)
        VODBOrdListAdd("Last", NIL)
        MemFree(rddList)
        IF (VODBSeek(cLast))
        &#0009;IF Deleted() .AND. RLock()
        &#0009;&#0009;VODBRecall()
        &#0009;&#0009;? "Record deleted: ", Deleted()
        &#0009;ENDIF
        ELSE
        &#0009;? "Not found"
        ENDIF
        VODBCloseArea()
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCloseArea'>DBCloseArea</seealso>
  </vodbclosearea>
  <vodbcommit>
    <summary>
      Flush pending updates in one work area.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBCommit() is the same as DBCommit().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBCommit() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCommit'>DBCommit</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCommitAll'>DBCommitAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbCommitAll'>VODBCommitAll</seealso>
  </vodbcommit>
  <vodbcommitall>
    <summary>
      Flush pending updates in all work areas.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBCommitAll() is the same as DBCommitAll().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBCommitAll() for more information.
    </remarks>
    <example>
      The following example writes all pending updates to disk:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL rddList       AS _RDDLIST
        &#0009;aRdds := {"CAVODBF", "DBFNTX"}
        &#0009;n       := ALen(aRdds)
        &#0009;rddList := MemAlloc( (_SizeOf(DWORD)) + (n * _SizeOf(SYMBOL)) )
        &#0009;rddList.uiRddCount := n
        &#0009;FOR i := 1 TO n
        &#0009;&#0009;rddList.atomRddName[i] := SysAddAtomUpperA(aRdds[i])
        &#0009;NEXT
        &#0009;cLast := "Winston"
        &#0009;VODBUseArea(TRUE, rddList, "sales", "sales", TRUE, FALSE)
        &#0009;VODBOrdListAdd("SaleFNam", NIL)
        &#0009;VODBOrdListAdd("SaleLNam", NIL)
        &#0009;VODBUseArea(TRUE, rddList, "colls", "colls", TRUE, FALSE)
        &#0009;VODBOrdListAdd("CollFNam", NIL)
        &#0009;VODBOrdListAdd("CollLNam", NIL)
        &#0009;MemFree(rddList)
        &#0009;DBSelectArea("sales")
        &#0009;// Select "sales" workarea
        &#0009;IF (Sales-&gt;(VODBSeek(cLast)))
        &#0009;&#0009;IF Sales-&gt;(Deleted()) .AND. sales(RLock())
        &#0009;&#0009;&#0009;Sales-&gt;(VODBRecall())
        &#0009;&#0009;&#0009;? "Deleted record has been recalled."
        &#0009;&#0009;ENDIF
        &#0009;ELSE
        &#0009;&#0009;? "Not found"
        &#0009;ENDIF
        &#0009;// Processing done, write updates to disk and
        &#0009;// close files
        &#0009;VODBCommitAll()
        &#0009;VODBCloseAll()
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCommit'>DBCommit</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCommitAll'>DBCommitAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbCommit'>VODBCommit</seealso>
  </vodbcommitall>
  <vodbcontinue>
    <summary>
      Resume a pending locate condition.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBContinue() is the same as DBContinue().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBContinue() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealsocmd>CONTINUE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbContinue'>DBContinue</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbLocate'>VODBLocate</seealso>
  </vodbcontinue>
  <vodbdelete>
    <summary>
      Mark the current record for deletion.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBDelete() is the same as DBDelete().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBDelete() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDelete'>DBDelete</seealso>
    <seealso cref='O:XSharp.RT.Functions.Deleted'>Deleted</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbDeleted'>VODBDeleted</seealso>
  </vodbdelete>
  <vodbdeleted>
    <summary>
      Return the deleted status of the current record.
    </summary>
    <returns>
      TRUE if the current record is marked for deletion; otherwise, FALSE.<br/>
      If there is no database file in use in the current work area, VODBDeleted() returns FALSE.
    </returns>
    <remarks>
      VODBDeleted() is the same as Deleted().  See Deleted() for more information and examples.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDelete'>DBDelete</seealso>
    <seealso cref='O:XSharp.RT.Functions.Deleted'>Deleted</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbDelete'>VODBDelete</seealso>
  </vodbdeleted>
  <vodbeof>
    <summary>
      Determine when end-of-file is encountered.
    </summary>
    <returns>
      TRUE when an attempt is made to move the record pointer beyond the last logical record in a database file or if the current database file contains no records; otherwise, FALSE.<br/>
      If there is no database file open in the current work area, VODBEOF() returns TRUE.
    </returns>
    <remarks>
      VODBEOF() is the same as EOF().  See EOF() for more information and examples.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbBof'>VODBBOF</seealso>
  </vodbeof>
  <vodbeval>
    <summary>
      Evaluate a code block for each record that matches a specified scope and/or condition.
    </summary>

    <param name="cbExecute">The code block to execute for each record that matches the scope and conditions.</param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      VODBEval() is like DBEval() but is strongly typed.<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBEval() for more information.
    </remarks>
    <example>
      This example uses VODBEval() to implement Count(), a function that counts the number of records in a work area matching a specified scope.<br/>
      The scope is passed as an array to Count().<br/>
      A set of constants defines the elements of the scope array:
      <code language="X#">
        // Scope attribute constants
        DEFINE FOR_COND&#0009;&#0009;:=&#0009;1&#0009;AS SHORTINT
        DEFINE WHILE_COND&#0009;&#0009;:=&#0009;2&#0009;AS SHORTINT
        DEFINE NEXT_SCOPE&#0009;&#0009;:=&#0009;3&#0009;AS SHORTINT
        DEFINE REC_SCOPE&#0009;&#0009;:=&#0009;4&#0009;AS SHORTINT
        DEFINE REST_SCOPE&#0009;&#0009;:=&#0009;5&#0009;AS SHORTINT
        DEFINE SCOPE_ELEMENTS&#0009;:=&#0009;5&#0009;AS SHORTINT
        FUNCTION Start()
        &#0009;// Create a scope and count records using it
        &#0009;LOCAL mySet[SCOPE_ELEMENTS]
        &#0009;LOCAL myCount AS LONGINT
        &#0009;USE customer NEW
        &#0009;mySet[FOR_COND] := {||customer = "Smith"}
        &#0009;mySet[WHILE_COND] := {||zip &gt; "90000"}
        &#0009;mySet[REST_SCOPE] := FALSE
        &#0009;// Every record (ALL)
        &#0009;myCount := Count(mySet)
        &#0009;RETURN TRUE
        FUNCTION Count(aScope) AS LONGINT
        &#0009;LOCAL nCount := 0 AS LONGINT
        &#0009;VODBEval({|| nCount++},;
        &#0009;&#0009;aScope[FOR_COND],;
        &#0009;&#0009;aScope[WHILE_COND],;
        &#0009;&#0009;aScope[NEXT_SCOPE],;
        &#0009;&#0009;aScope[REC_SCOPE],;
        &#0009;&#0009;aScope[REST_SCOPE])
        &#0009;RETURN nCount
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbEval'>DBEval</seealso>
  </vodbeval>
  <vodbfieldget>
    <summary>
      Retrieve the value of a specified database field.
    </summary>

    <param name="wFieldPos">The position of the field in the record structure for the current work area.</param>
    <param name="ptrRetVal">
      A pointer to a polymorphic value.<br/>
      This value will receive the requested information if the function is successful and will be unchanged otherwise.<br/>
      If you just want to retrieve information, this value must be NIL before calling the function.<br/>

      &#0009;Although other RDDs may expand on this concept, the supplied RDDs limit using a non-NIL value to a single circumstance in which you can change the information rather than just retrieve it.  With the DBS_ALIAS <paramref name="kInfoType" />, you can specify a non-NIL value, allowing you to specify a string that you can subsequently use to access the indicated field.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBFieldGet() is like FieldGet() but is strongly typed.  See FieldGet() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetSym'>FieldGetSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetAlias'>FieldGetAlias</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetArea'>FieldGetArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldPut'>VODBFieldPut</seealso>
  </vodbfieldget>
  <vodbfieldinfo>
    <summary>
      Retrieve field definition information about a field.
    </summary>

    <param name="kInfoType">Determines what type of information is retrieved.</param>
    <param name="wFieldPos">The position number of the field that you want information on.</param>
    <param name="ptrRetVal">
      A pointer to a polymorphic value.<br/>
      This value will receive the requested information if the function is successful and will be unchanged otherwise.<br/>
      If you just want to retrieve information, this value must be NIL before calling the function.<br/>

      &#0009;Although other RDDs may expand on this concept, the supplied RDDs limit using a non-NIL value to a single circumstance in which you can change the information rather than just retrieve it.  With the DBS_ALIAS <paramref name="kInfoType" />, you can specify a non-NIL value, allowing you to specify a string that you can subsequently use to access the indicated field.
    </param>
    <param name="uNewValue">A new value to assign to the field attribute.  </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBFieldInfo() is the same as DBFieldInfo(), except for the purpose of its third argument and the fact that it returns a logical.<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBFieldInfo() for more information.
    </remarks>
    <example>
      The following examples use VODBFieldInfo() to retrieve field information:
      <code language="X#">
        FUNCTION ShowFieldInfo(wField AS WORD) AS VOID
        &#0009;LOCAL uResult AS USUAL
        &#0009;uResult := NIL
        &#0009;IF VODBFieldInfo(DBS_NAME, wField, @uResult)
        &#0009;&#0009;? "FieldName(): ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;IF VODBFieldInfo(DBS_TYPE, wField, @uResult)
        &#0009;&#0009;? "Field type: ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;IF VODBFieldInfo(DBS_LEN, wField, @uResult)
        &#0009;&#0009;? "Field length: ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;IF VODBFieldInfo(DBS_DEC, wField, @uResult)
        &#0009;&#0009;? "Decimals: ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;RETURN
        STATIC FUNCTION DoError() AS USUAL
        &#0009;LOCAL uRetCode AS USUAL
        &#0009;LOCAL oError AS USUAL
        &#0009;oError := ErrorBuild(@strucErrInfo)
        &#0009;oError:FuncSym := #VODBFieldInfo
        &#0009;RETURN EVAL(ErrorBlock(), oError)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbInfo'>VODBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbOrderInfo'>VODBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRecordInfo'>VODBRecordInfo</seealso>
  </vodbfieldinfo>
  <vodbfieldput>
    <summary>
      Set the value of a specified database field.
    </summary>

    <param name="wFieldPos">The position of the field in the current database file.</param>
    <param name="uNewValue">
      The value to assign to the field.<br/>
      The data type of this expression must match the data type of the designated field variable.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBFieldPut() is like FieldPut() but is strongly typed.  See FieldPut() for more information.
    </remarks>
    <example>
      This example compares VODBFieldPut() to assign a value to the first field of a database:
      <code language="X#">
        nField := 1
        // Using VODBFieldPut()
        VODBFieldPut(nField, "MyData")&#0009;// Set field value
        // Or:
        ? FIELDNAME(1)&#0009;// City (name of the first field)
        City := "MyData"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetSym'>FieldGetSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPut'>FieldPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutSym'>FieldPutSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutAlias'>FieldPutAlias</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutArea'>FieldPutArea</seealso>
  </vodbfieldput>
  <vodbfilter>
    <summary>
      Return a filter.
    </summary>
    <returns>
      The filter condition defined in the current work area.<br/>
      If no filter has been set, VODBFilter() returns a NULL_STRING.
    </returns>
    <remarks>
      VODBFilter() is the same as DBFilter().  See DBFilter() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFilter'>DBFilter</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbClearFilter'>VODBClearFilter</seealso>
  </vodbfilter>
  <vodbflock>
    <summary>
      Lock an opened and shared database file.
    </summary>
    <returns>
      TRUE if the lock succeeded; otherwise, FALSE.
    </returns>
    <remarks>
      VODBFLock() is the same as FLock().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See FLock() for more information and examples.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Flock'>FLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRlock'>VODBRLock</seealso>
  </vodbflock>
  <vodbfound>
    <summary>
      Determine if the previous search operation succeeded.
    </summary>
    <returns>
      TRUE if the last search command was successful; otherwise, FALSE.  VODBFound() will also return FALSE if there is no database open in the current work area.
    </returns>
    <remarks>
      VODBFound() is the same as Found().  See Found() for more information and examples.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Found'>Found</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbSeek'>VODBSeek</seealso>
  </vodbfound>
  <vodbgetselect>
    <summary>
      Return the work area number.
    </summary>
    <returns>
      A number from 1 to 4096.
    </returns>
    <remarks>
      VODBGetSelect() is the same as DBGetSelect().  See DBGetSelect() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbGetSelect'>DBGetSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbSelect'>VODBSelect</seealso>
  </vodbgetselect>
  <vodbgetselect1>
    <summary>
      Return the work area number for a certain alias
    </summary>
    <param name="sArea">The name of the alias to look for. This is NOT case sensitive.</param>
    <returns>
      A number from 0 to 4096. When the alias is not used (in the current thread) then the return value is 0. Otherwise it is the area number of the area that has this alias.
    </returns>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbGetSelect'>DBGetSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbSelect'>VODBSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.Alias'>Alias</seealso>
  </vodbgetselect1>
  <vodbgobottom>
    <summary>
      Move to the last logical record.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBGoBottom() is the same as DBGoBottom().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBGoBottom() for more information.
    </remarks>
    <example>
      The following example uses VODBGoBottom() to position the record pointer on the last logical record:
      <code language="X#">
        cLast := "Winston"
        DBUseArea(TRUE, "DBFNTX", "sales", "sales", TRUE)
        VODBOrdListAdd("lastname", NIL, NIL)
        Sales-&gt;(VODBGoBottom())
        IF (Sales-&gt;Last == "Winston")
        &#0009;IF Sales-&gt;(RLock())
        &#0009;&#0009;Sales-&gt;(VODBDelete())
        &#0009;&#0009;? "Record deleted: ", sales;
        &#0009;&#0009;&#0009;(VODBDeleted())
        &#0009;ELSE
        &#0009;&#0009;? "Unable to lock record..."
        &#0009;ENDIF
        END
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbGoBottom'>DBGoBottom</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoTop'>DBGoTop</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbGoTop'>VODBGoTop</seealso>
  </vodbgobottom>
  <vodbgoto>
    <summary>
      Move to a record specified by record number.
    </summary>

    <param name="uRecID">
      The record ID to go to.<br/>
      If <paramref name="uRecID" /> does not exist, the work area is positioned to LastRec() + 1, and both VODBEOF() and VODBBOF() return TRUE.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBGoTo() is like DBGoTo() but is strongly typed.<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBGoTo() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbGoto'>DBGoTo</seealso>
  </vodbgoto>
  <vodbgotop>
    <summary>
      Move to the first logical record.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBGoTop() is the same as DBGoTop().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBGoTop() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbGoBottom'>DBGoBottom</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoTop'>DBGoTop</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbGoBottom'>VODBGoBottom</seealso>
  </vodbgotop>
  <vodbinfo>
    <summary>
      Retrieve information about a work area.
    </summary>

    <param name="kInfoType">Determines what type of information is retrieved.</param>
    <param name="ptrRetVal">
      A pointer to a polymorphic value.<br/>
      This value will receive the requested information if the function is successful and will be unchanged otherwise.<br/>
      If you just want to retrieve information, this value must be NIL before calling the function.<br/>

      &#0009;Using a non-NIL value is not currently supported by any of the supplied RDDs .<br/>
      This feature is reserved for RDDs that allow you to change the information rather than just retrieve it.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBInfo() is similar to DBInfo().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBInfo() for more information.
    </remarks>
    <example>
      The following examples return work area information:
      <code language="X#">
        FUNCTION ShowInfo() AS VOID
        &#0009;LOCAL uResult AS USUAL
        &#0009;uResult := NIL
        &#0009;IF VODBInfo(DBI_GETHEADERSIZE, @uResult)
        &#0009;&#0009;? "HEADER(): ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;IF VODBInfo(DBI_LASTUPDATE, @uResult)
        &#0009;&#0009;? "LUpdate(): ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;IF VODBInfo(DBI_GETRECSIZE, @uResult)
        &#0009;&#0009;? "RecSize(): ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;IF VODBInfo(DBI_FULLPATH, @uResult)
        &#0009;&#0009;? "PATHNAME: ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;RETURN
        STATIC FUNCTION DoError() AS USUAL
        &#0009;LOCAL uRetCode<br/>
        AS USUAL
        &#0009;LOCAL oError  <br/>
        AS USUAL
        &#0009;oError := ErrorBuild(@strucErrInfo)
        &#0009;oError:FuncSym := #VODBInfo
        &#0009;RETURN EVAL(ErrorBlock(), oError)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddInfo'>RDDInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldInfo'>VODBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbOrderInfo'>VODBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRecordInfo'>VODBRecordInfo</seealso>
  </vodbinfo>
  <vodblastrec>
    <summary>
      Return the number of the last record in a database file.
    </summary>
    <returns>
      The number of physical records in a database file.  Filtering or deleted settings have no effect on the return value.  VODBLastRec() returns 0 if there is no database file in use.
    </returns>
    <remarks>
      VODBLastRec() is the same as LastRec().  See LastRec() for more information and examples.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
  </vodblastrec>
  <vodblocate>
    <summary>
      Search for the first record that matches a specified condition and scope.
    </summary>

    <param name="cbForCondition">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/cbfor/*" />
    </param>
    <param name="cbWhileCondition">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/cbwhile/*" />
    </param>
    <param name="liNext">
      The number of records to process, starting with the current record.<br/>
      To omit this argument, specify -1.
    </param>
    <param name="uRecord">
      The number of the record to process.<br/>
      To omit this argument, specify -1.
    </param>
    <param name="lRest">TRUE processes only records from the current record to end-of-file.  FALSE processes all records.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBLocate() is like DBLocate() but is strongly typed.<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBLocate() for more information.
    </remarks>
    <example>
      The following example locates the first sale in the past 30 days in the city of LA:
      <code language="X#">
        USE sales
        VODBLocate({||City == "LA"}, {||SaleDay &gt; ;
        &#0009;TODAY()-30},-1,NIL,FALSE)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ASort'>ASort</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbLocate'>DBLocate</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSort'>DBSort</seealso>
  </vodblocate>
  <vodbordbagext>
    <summary>
      Return the default index file extension for a work area as defined by the its RDD.
    </summary>
    <returns>
    </returns>
    <remarks>
      VODBOrdBagExt() is the same as calling DBOrderInfo(DBOI_DEFBAGEXT).
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </vodbordbagext>
  <vodbordcondset>
    <summary>
      Set the condition and scope for an order.
    </summary>

    <param name="ptrCondInfo">A pointer to a data structure (_DBORDERCONDINFO) defining the condition and scope information.</param>
    <returns>
    </returns>
    <remarks>
      VODBOrdCondSet() is the same as DBSetOrderCondition() except that it is strongly typed and the condition information is specified using a data structure rather than individual function arguments.
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrderCondition'>DBSetOrderCondition</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbOrdCreate'>VODBOrdCreate</seealso>
  </vodbordcondset>
  <vodbordcreate>
    <summary>
      Create or replace an order in an index file.
    </summary>

    <param name="ptrCondInfo">
      A pointer to a data structure (_DBORDERCONDINFO) defining the condition and scope information.<br/>

      &#0009;Note:  See DBCreateOrder() for descriptions of the remaining arguments.
    </param>
    <returns>
    </returns>
    <remarks>
      VODBOrdCreate() is the same as DBCreateOrder() except that it is strongly typed, the order of the <paramref name="cIndexFile" /> and <paramref name="cOrder" /> arguments is reversed, and it allows you to specify condition information using a data structure.
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
  </vodbordcreate>
  <vodborddestroy>
    <summary>
      Remove an order from an open index file.
    </summary>
    <returns>
    </returns>
    <remarks>
      VODBOrdDestroy() is the same as DBDeleteOrder() except that it is strongly typed and the order of the arguments is reversed.<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDeleteOrder'>DBDeleteOrder</seealso>
  </vodborddestroy>
  <vodborderinfo>
    <summary>
      Return information about index files and the orders in them.
    </summary>
    <param name="kInfoType">Determines what type of information is retrieved. This should be one of the DBOI_ constants listed in the remarks section</param>
    <param name="cIndexFile">
      The name of an open index file (only the eight-letter file name is needed).<br/>
      Use this argument with <paramref name="cOrder" /> to remove ambiguity when there are two or more orders with the same name in different index files.<br/>
      To omit the argument, specify NULL_STRING.
    </param>
    <param name="uOrder">
      &#0009;The name of the order about which you want to obtain information or a number representing its position in the order list.<br/>
      To omit the <paramref name="cOrder" /> | <paramref name="nPosition" /> argument, specify NIL.
    </param>
    <param name="ptrRetVal">
      A pointer to a polymorphic value.<br/>
      This value will receive the requested information if the function is successful and will be unchanged otherwise.<br/>
      If you just want to retrieve information, this value must be NIL before calling the function.<br/>

      &#0009;Using a non-NIL value is not currently supported by any of the supplied RDDs .<br/>
      This feature is reserved for RDDs that allow you to change the information rather than just retrieve it.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBOrderInfo() is similar to DBOrderInfo().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBOrderInfo() for more information.
      <include file="RTComments.xml" path="Comments/DBOI_Constants/*"  />

    </remarks>
    <example>
      The following examples return order access information:
      <code language="X#">
        FUNCTION ShowOrderInfo() AS VOID
        &#0009;LOCAL uResult AS USUAL
        &#0009;uResult := NIL
        &#0009;IF VODBOrderInfo(DBOI_EXPRESSION,"",0,@uResult)
        &#0009;&#0009;? "IndexKey(): ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;// Record number for specified position:
        &#0009;uResult := 100
        &#0009;IF VODBOrderInfo(DBOI_RECNO,"",0,@uResult)
        &#0009;&#0009;? "Record number of position 100: ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;IF VODBOrderInfo(DBOI_FULLPATH,"",0,@uResult)
        &#0009;&#0009;? "FULLPATH of index file: ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;RETURN
        STATIC FUNCTION DoError() AS USUAL
        &#0009;LOCAL uRetCode<br/>
        AS USUAL
        &#0009;LOCAL oError  <br/>
        AS USUAL
        &#0009;oError := ErrorBuild(@strucErrInfo)
        &#0009;oError:FuncSym := #VODBOrderInfo
        &#0009;RETURN EVAL(ErrorBlock(), oError)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldInfo'>VODBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbInfo'>VODBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRecordInfo'>VODBRecordInfo</seealso>
  </vodborderinfo>
  <vodbordlistadd>
    <summary>
      Open an index file and add specified orders to the order list in a work area.
    </summary>
    <returns>
    </returns>
    <remarks>
      VODBOrdListAdd() is the same as DBSetIndex() except that it is strongly typed.<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbOrdCreate'>VODBOrdCreate</seealso>
  </vodbordlistadd>
  <vodbordlistclear>
    <summary>
      Remove orders from the order list in a work area and close associated index files.
    </summary>
    <returns>
    </returns>
    <remarks>
      VODBOrdListClear() is the same as DBClearIndex() except that it is strongly typed and the order of the arguments is reversed.<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearIndex'>DBClearIndex</seealso>
  </vodbordlistclear>
  <vodbordlistrebuild>
    <summary>
      Rebuild all orders in the order list of a work area.
    </summary>
    <returns>
    </returns>
    <remarks>
      VODBOrdListRebuild() is the same as DBReindex() except that it is strongly typed.<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbReindex'>DbReindex</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbOrdCreate'>VoDbOrdCreate</seealso>
  </vodbordlistrebuild>
  <vodbordsetfocus>
    <summary>
      Set the controlling order for a work area.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBOrdSetFocus() is similar to DBSetOrder() except that it is strongly typed and the order of the arguments is reversed.<br/>
      Also, the third argument <paramref name="pszPreviousOrder" /> points to the old controlling order.  See DBSetOrder() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrder'>DBSetOrder</seealso>
  </vodbordsetfocus>
  <vodbpack>
    <summary>
      Remove all records that have been marked for deletion from a database file.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBPack() is the same as DBPack().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBPack() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbPack'>DBPack</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbDelete'>VODBDelete</seealso>
  </vodbpack>
  <vodbrddlist>
    <summary>
      Get a list of RDDs in use.
    </summary>

    <param name="strucRDDList">
      A structure of type _RDDLIST.  _RDDLIST is defined as follows:<br/>

      &#0009;MEMBER uiRDDCount AS DWORD<br/>

      &#0009;MEMBER DIM atomRDDName[1] AS SYMBOL<br/>

      &#0009;You must allocate enough memory for <paramref name="strucRDDList" />.<br/>
      Use MemAlloc() and MemFree() to allocate and deallocate the memory.<br/>
      The memory must be large enough to hold the uiRDDCount member and a DIM array of symbols having RDDCount() elements.  Normally, the return of RDDCount() is assigned to uiRDDCount.  Since the uiRDDCount member is a WORD, its size is given by _SizeOf(WORD).  Moreover, the size of a DIM array of symbols having uiRDDCount (RDDCount()) elements is equal to uiRDDCount * _SizeOf(SYMBOL).
    </param>
    <param name="kRDDType">
      The types of RDDs to include in the list.<br/>
      The types are:
    </param>
    <param name="Constant">Description&#0009;</param>
    <param name="RDT_FULL">Fully implemented RDDs&#0009;</param>
    <param name="RDT_TRANSFER">Transfer RDDs&#0009;</param>
    <param name="RDT_HIDDEN">Specific RDDs&#0009;</param>
    <returns>
      TRUE, if successful; otherwise, FALSE.<br/>
      A FALSE return value indicates an error, but this function does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.
    </returns>
    <remarks>
    </remarks>
    <example>
      The following example lists all the RDDs in use:
      <code language="X#">
        FUNCTION QOutRDD() AS VOID PASCAL
        &#0009;LOCAL rddList AS _RDDLIST
        &#0009;LOCAL si AS SHORTINT
        &#0009;LOCAL wCount AS WORD
        &#0009;wCount := ;&#0009;RDDCount(RDT_FULL+RDT_TRANSFER+RDT_HIDDEN)
        &#0009;IF wCount &gt; 0
        &#0009;// Allocate memory for one WORD (that is,
        &#0009;// RDDlist.uiRDDCount) and
        &#0009;// a DIM array of symbols having wCount elements
        &#0009;&#0009;RDDList := MemAlloc((_SizeOf(WORD)) +;
        &#0009;&#0009;&#0009;&#0009;(wCount * _SizeOf(SYMBOL)))
        &#0009;&#0009;RDDList.uiRDDCount := wCount
        &#0009;&#0009;IF VODBRDDList(rddList, ;
        &#0009;&#0009;&#0009;&#0009;RDT_FULL+RDT_TRANSFER+RDT_HIDDEN)
        &#0009;&#0009;&#0009;FOR si := 1 UPTO RDDList.uiRDDCount
        &#0009;&#0009;&#0009;&#0009;? RDDList.atomRDDName[si]
        &#0009;&#0009;&#0009;NEXT
        &#0009;&#0009;ENDIF
        &#0009;&#0009;MemFree(rddList)
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.RddList'>RDDList</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddName'>VODBRDDName</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddSetDefault'>VODBRDDSetDefault</seealso>
  </vodbrddlist>
  <vodbrddname>
    <summary>
      Return an RDD name.
    </summary>
    <returns>
    </returns>
    <remarks>
      VODBRDDName() is the same as RDDName().  See RDDName() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDriver'>DBDriver</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddName'>RDDName</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddList'>VODBRDDList</seealso>
  </vodbrddname>
  <vodbrddsetdefault>
    <summary>
      Return and optionally change the default RDD for the application.
    </summary>

    <param name="cNewSetting">
      The name of the RDD that will be used to activate and manage applications when no RDD is explicitly specified.<br/>
      If this RDD is not available to the application, the call has no effect.
    </param>
    <returns>
      If <paramref name="cNewSetting" /> is not specified, VODBRDDSetDefault() returns the current default RDD.<br/>
      If <paramref name="cNewSetting" /> is specified, the previous default RDD is returned.
    </returns>
    <remarks>
      VODBRDDSetDefault() is like RDDSetDefault() but is strongly typed.  See RDDSetDefault() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetDriver'>DBSetDriver</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddList'>VODBRDDList</seealso>
  </vodbrddsetdefault>
  <vodbrecall>
    <summary>
      Restore the current record if it is marked for deletion.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBRecall() is the same as DBRecall().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBRecall() for more information.
    </remarks>
    <example>
      The following example recalls a record if it is deleted and attempts to lock the record if successful:
      <code language="X#">
        LOCAL rddList       AS _RDDLIST
        ...
        aRdds := {"CAVODBF", "DBFNTX"}
        n       := ALen(aRdds)
        rddList := MemAlloc( (_SizeOf(DWORD)) + (n * _SizeOf(SYMBOL)) )
        rddList.uiRddCount := n
        FOR i := 1 TO n
        &#0009;rddList.atomRddName[i] := SysAddAtomUpperA(aRdds[i])
        NEXT
        cLast := "Winston"
        VODBUseArea(TRUE, rddList, "sales", "sales", TRUE, FALSE)
        VODBOrdListAdd("LastName", NIL, NIL)
        MemFree(rddList)
        IF (Sales-&gt;(VODBSeek(cLast)))
        &#0009;IF Sales-&gt;(VODBDeleted())
        &#0009;&#0009;IF Sales-&gt;(RLock())
        &#0009;&#0009;&#0009;Sales-&gt;(VODBRecall())
        &#0009;&#0009;&#0009;? "Record recalled"
        &#0009;&#0009;ELSE
        &#0009;&#0009;&#0009;? "Unable to lock record..."
        &#0009;&#0009;ENDIF
        &#0009;ENDIF
        ELSE
        &#0009;? "Not found"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRecall'>DBRecall</seealso>
  </vodbrecall>
  <vodbrecno>
    <summary>
      Return the current record number.
    </summary>
    <returns>
      The current record number.<br/>
      If the work area contains a database file with 0 records, VODBRecNo() returns 1, BOF() and EOF() both return TRUE, and LastRec() returns 0.
      If the record pointer is moved past the last record, VODBRecNo() returns LastRec() + 1 and EOF() returns TRUE.<br/>
      If an attempt is made to move before the first record, VODBRecNo() returns the record number of the first logical record in the database file and BOF() returns TRUE.<br/>
      If no database file is open, VODBRecNo() will return a 0.
    </returns>
    <remarks>
      VODBRecNo() is the same as RecNo().  See RecNo() for more information and examples.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.RecNo'>RecNo</seealso>
    <seealso cref='O:XSharp.RT.Functions.RecSize'>RecSize</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRecordInfo'>VODBRecordInfo</seealso>
  </vodbrecno>
  <vodbrecordinfo>
    <summary>
      Retrieve information about a record.
    </summary>

    <param name="kInfoType">Determines what type of information is retrieved..</param>
    <param name="nRecID">
      The ID of the record to retrieve information on.<br/>
      A value of 0L means the current record.
    </param>
    <param name="ptrRetVal">
      A pointer to a polymorphic value.<br/>
      This value will receive the requested information if the function is successful and will be unchanged otherwise.<br/>
      If you just want to retrieve information, this value must be NIL before calling the function.<br/>

      &#0009;Using a non-NIL value is not currently supported by any of the supplied RDDs .<br/>
      This feature is reserved for RDDs that allow you to change the information rather than just retrieve it.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBRecordInfo() is similar to DBRecordInfo().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBRecordInfo() for more information.
    </remarks>
    <example>
      The following examples retrieve record information:
      <code language="X#">
        FUNCTION ShowRecordInfo() AS VOID
        &#0009;LOCAL uResult AS USUAL
        &#0009;uResult := NIL
        &#0009;IF VODBRecordInfo(DBRI_LEN,0,@uResult)
        &#0009;&#0009;? "RecSize(): ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;IF VODBRecordInfo(DBRI_LOCKED,200,@uResult)
        &#0009;&#0009;? "Locking flag of record 200: ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;RETURN
        STATIC FUNCTION DoError() AS USUAL
        &#0009;LOCAL uRetCode<br/>
        AS USUAL
        &#0009;LOCAL oError  <br/>
        AS USUAL
        &#0009;oError := ErrorBuild(@strucErrInfo)
        &#0009;oError:FuncSym := #VODBRecordInfo
        &#0009;RETURN EVAL(ErrorBlock(), oError)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRecordInfo'>DBRecordInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldInfo'>VODBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbInfo'>VODBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbOrderInfo'>VODBOrderInfo</seealso>
  </vodbrecordinfo>
  <vodbrelation>
    <summary>
      Return the linking expression of a specified relation.
    </summary>

    <param name="wRelation">
      The position of the desired relation in the list of current work area relations.<br/>
      The relations are numbered according to the order in which they were defined with SET RELATION.
    </param>
    <param name="pszRelation">
      The position of the desired relation in the list of current work area relations.<br/>
      The relations are numbered according to the order in which they were defined with SET RELATION.
    </param>
    <returns>
      The linking expression defined to <paramref name="wRelation" />.<br/>
      If there is no relation set for <paramref name="wRelation" />, VODBRelation() returns a NULL_STRING.
      <br/>



      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBSetRelation() is similar to DBRelation().  See DBRelation() for more information and examples.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRelation'>DBRelation</seealso>
  </vodbrelation>
  <vodbrlock>
    <summary>
      Lock the current record.
    </summary>

    <param name="uRecID">
      The ID of the record to be locked.<br/>
      To omit, specify NIL. This will lock the current record and release all previously locked records.
    </param>
    <returns>
      TRUE if the record lock is obtained; otherwise, FALSE.<br/>
      An attempt to lock a record in an empty database returns TRUE.
    </returns>
    <remarks>
      VODBRLock() is like DBRLock() but is strongly typed.<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBRLock() for more information and examples.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.RLock'>RLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbAppend'>VODBAppend</seealso>
  </vodbrlock>
  <vodbrselect>
    <summary>
      Return the work area number of a relation.
    </summary>

    <param name="wRelation">
      The position of the desired relation in the list of current work area relations.<br/>
      The relations are numbered according to the order in which they were defined by the relation setting.
    </param>
    <returns>
      The work area number of the specified relation.<br/>
      If there is no relation set for <paramref name="wRelation" />, VODBRSelect() returns 0.
    </returns>
    <remarks>
      VODBRSelect() is like DBRSelect() but is strongly typed.  See DBRSelect() for more information and examples.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRSelect'>DBRSelect</seealso>
  </vodbrselect>
  <vodbseek>
    <summary>
      Move to the record having the specified key value.
    </summary>

    <param name="uKey">A value of any type that specifies the key value associated with the desired record.</param>
    <param name="lSoftSeek">Determines how the work area is positioned if the specified key value is not found:  TRUE performs a soft seek; FALSE does not.</param>
    <returns>
      VODBSeek() always returns TRUE.
    </returns>
    <remarks>
      VODBSeek() is like DBSeek() but is strongly typed.  See DBSeek() for more information.
    </remarks>
    <example>
      In this example, VODBSeek() moves the pointer to the record in the database, EMPLOYEE, in which the value in the field cName matches the entered value of cName:
      <code language="X#">
        ACCEPT "Employee name: " TO cName
        IF (Employee-&gt;(VODBSeek(cName), FALSE))
        &#0009;Employee-&gt;(ViewRecord())
        ELSE
        &#0009;? "Not found"
        END
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
  </vodbseek>
  <vodbselect>
    <summary>
      Select a new work area and retrieve the current work area.
    </summary>

    <param name="wNew">The work area number for the new work area.</param>
    <param name="wOld">A variable that is passed by reference and will contain the number of the current work area.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBSelect() is like DBSelect() but is strongly typed.<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBSelect() for more information.
    </remarks>
    <example>
      This example shows how to save and restore the old environment:
      <code language="X#">
        LOCAL wOld AS DWORD
        VODBSelect(10, @wOld)
        &#0009;// Process the work area
        VODBSelect(wOld, @wOld)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSelect'>DBSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
  </vodbselect>
  <vodbsetfilter>
    <summary>
      Set a filter condition.
    </summary>

    <param name="cbCondition">A code block that expresses the filter condition in executable form.</param>
    <param name="cCondition">
      A character value that expresses the filter condition in textual form.<br/>
      It must be equivalent to <paramref name="cbCondition" />.<br/>
      To omit, specify a NULL_STRING.  <paramref name="cCondition" /> is the value returned by the DBFilter() function.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.<br/>
      If <paramref name="cCondition" /> is omitted, the DBSetFilter() function will return an empty string for the work area.
    </returns>
    <remarks>
      VODBSetFilter() is like DBSetFilter() but is strongly typed.<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBSetFilter() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetFilter'>DBSetFilter</seealso>
  </vodbsetfilter>
  <vodbsetfound>
    <summary>
      Set the found flag.
    </summary>

    <param name="lFound">The new setting for the found flag.</param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBSetFound() is like DBSetFound() but is strongly typed.<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBSetFound() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetFound'>DBSetFound</seealso>
  </vodbsetfound>
  <vodbsetlocate>
    <summary>
      Specify the code block for a locate condition.
    </summary>

    <param name="cbForCondition">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/cbfor/*" /><br/>

      If no scope is specified, <paramref name="cbForCondition" /> changes the default scope to all records.<br/>
      The code block should contain a logical expression.<br/>
      It corresponds to the first argument of DBLocate() or VODBLocate().<br/>
      It is valid until it is overwritten by the next VODBSetLocate().
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBSetLocate() allows you to change the locate condition.  Once you issue a LOCATE command, DBLocate(), or VODBLocate(), you could continue searching but with a different condition.
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      Note that this function does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.
    </remarks>
    <example>
      The following example shows how to search on two different and independent criteria:
      <code language="X#">
        FUNCTION Locators() AS LOGIC
        &#0009;LOCAL cbForCondition, cbWhileCondition, nNext, ;
        &#0009;&#0009;&#0009;uRecId, lRest
        &#0009;USE test
        &#0009;cbForCondition := {||Proper(ALLTRIM(Name)) == ;
        &#0009;&#0009;&#0009;"Charly"}
        &#0009;cbWhileCondition := {||TRUE}&#0009;// Process to EOF
        &#0009;nNext := -1&#0009;&#0009;&#0009;// Scope ALL
        &#0009;uRecId := NIL&#0009;&#0009;&#0009;// Leave it at NIL
        &#0009;lRest := FALSE&#0009;&#0009;// Search from top of file
        &#0009;// Search for Charly
        &#0009;DBLocate(cbForCondition, cbWhileCondition, ;
        &#0009;&#0009;nNext, uRecId, lRest)
        &#0009;? Found(), RECNO(), Name
        &#0009;// Specify a second name; Search for Odile
        &#0009;VODBSetLocate({||Proper(ALLTRIM(Name))=="Odile"})
        &#0009;CONTINUE
        &#0009;? Found(), RECNO(), Name
        &#0009;DBCloseArea()
        &#0009;RETURN Found()
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbLocate'>DBLocate</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbLocate'>VODBLocate</seealso>
  </vodbsetlocate>
  <vodbsetrelation>
    <summary>
      Relate a specified work area to the current work area.
    </summary>

    <param name="cAlias">The alias of the child work area.</param>
    <param name="cbRel">A code block that expresses the relational expression in executable form.</param>
    <param name="cRel">
      The relational expression in textual form.<br/>
      It must be equivalent to <paramref name="cbRel" />.<br/>
      To omit, specify a NULL_STRING.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBSetRelation() is like DBSetRelation() but is strongly typed.  <br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBSetRelation() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetRelation'>DBSetRelation</seealso>
  </vodbsetrelation>
  <vodbsetselect>
    <summary>
      Select a new work area.
    </summary>

    <param name="siNewArea">The number of the new work area.</param>
    <returns>
      The newly selected work area.
    </returns>
    <remarks>
      VODBSetSelect() is like DBSetSelect() but is strongly typed.  See DBSetSelect() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetSelect'>DBSetSelect</seealso>
  </vodbsetselect>
  <vodbskip>
    <summary>
      Move the record pointer relative to the current record.
    </summary>

    <param name="liRecords">
      The number of logical records to move, relative to the current record.<br/>
      A positive value means to skip forward, and a negative value means to skip backward.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBSkip() is like DBSkip() but is strongly typed.<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBSkip() for more information and an example.
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSkip'>DBSkip</seealso>
  </vodbskip>
  <vodbsymselect>
    <summary>
      Select a new work area by specifying its alias as a symbol and return the number of the current work area.
    </summary>

    <param name="symAlias">The alias of the work area you want to select.</param>
    <returns>
      The number of the current work area.
    </returns>
    <remarks>
      VODBSymSelect() is like DBSymSelect() but is strongly typed.  See DBSymSelect() for more information.
    </remarks>
    <example>
      This example uses VODBSymSelect() to change work areas:
      <code language="X#">
        FUNCTION ChangeArea() AS VOID
        &#0009;USE test
        &#0009;USE address NEW
        &#0009;? Alias()&#0009;&#0009;&#0009;// Address
        &#0009;VODBSymSelect(#Test)
        &#0009;? Alias()&#0009;&#0009;&#0009;// Test
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSymSelect'>DBSymSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbSelect'>VODBSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbUseArea'>VODBUseArea</seealso>
  </vodbsymselect>
  <vodbunlock>
    <summary>
      Release all locks for a work area.
    </summary>

    <param name="uRecID">
      The ID of the record to be unlocked.<br/>
      To omit, specify NIL.<br/>
      This unlocks all locked records or the whole file.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBUnLock() is the same as DBUnLock().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBUnLock() for more information.
    </remarks>
    <example>
      The following example illustrates a basic use of the VODBUnLock() function:
      <code language="X#">
        cLast := "Winston"
        USE sales SHARED NEW VIA "DBFNTX"
        VODBOrdListAdd("Lastname", NIL, NIL)
        IF (Sales-&gt;(VODBSeek(cLast)))
        &#0009;IF Sales-&gt;(VODBRLock(NIL))
        &#0009;&#0009;Sales-&gt;(VODBDelete())
        &#0009;&#0009;? "Record deleted: ", sales;
        &#0009;&#0009;&#0009;(VODBDeleted())
        &#0009;&#0009;Sales-&gt;(VODBUnLock(NIL))
        &#0009;ELSE
        &#0009;&#0009;? "Unable to lock record..."
        &#0009;ENDIF
        ELSE
        &#0009;? "Not found"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbUnLock'>DBUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLockAll'>DbUnLockAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbUnLockAll'>VODbUnLockAll</seealso>
  </vodbunlock>
  <vodbunlockall>
    <summary>
      Release all locks for all work areas.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODbUnLockAll() is the same as DbUnLockAll().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DbUnLockAll() for more information.
    </remarks>
    <example>
      The following example marks a record for deletion if an VODBRLock() attempt is successful, then clears all locks in all work areas:
      <code language="X#">
        cLast := "Winston"
        USE sales SHARED NEW VIA "DBFNTX"
        VODBOrdListAdd("Salefnam", NIL)
        VODBOrdListAdd("Salelnam", NIL)
        USE colls SHARED NEW VIA "DBFNTX"
        VODBOrdListAdd("Collfnam", NIL)
        VODBOrdListAdd("Colllnam", NIL)
        DBSelectArea("sales")&#0009;&#0009;// Select "sales" work area
        IF (colls-&gt;(VODBSeek(cLast)))
        &#0009;IF colls-&gt;(VODBDeleted())
        &#0009;&#0009;? "Record deleted: ", colls-&gt;;
        &#0009;&#0009;&#0009;(VODBDeleted())
        &#0009;&#0009;IF colls-&gt;(VODBRLock(NIL))
        &#0009;&#0009;&#0009;colls-&gt;(VODBRecall())
        &#0009;&#0009;&#0009;? "Record recalled..."
        &#0009;&#0009;ENDIF
        &#0009;ENDIF
        ELSE
        &#0009;? "Not found"
        &#0009;VODbUnLockAll()&#0009;&#0009;// Remove all locks in
        ENDIF&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// all work areas
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbUnLock'>DBUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLockAll'>DbUnLockAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbUnLock'>VODBUnLock</seealso>
  </vodbunlockall>
  <vodbusearea>
    <summary>
      Open a database file.
    </summary>

    <param name="lNewArea">Specifies whether the file is to be opened in a new work area.  TRUE selects the lowest numbered unoccupied work area as the current work area before the use operation.  FALSE uses the current work area (if the work area is occupied, it is closed first).</param>
    <param name="ptrRDDList">
      A pointer to a structure (_RDDLIST) that contains a list of RDD names from which the work area gets its functionality.<br/>
      If multiple RDDs (specified with this argument) implement the same function, the function associated with the last RDD in the list takes precedence.<br/>
      This allows you to use RDDs with special capabilities, like encryption or decryption, in different work areas with different database drivers.
    </param>
    <param name="cDataFile">
      The name of the database file to open, including an optional drive, directory, and extension.<br/>
      If the database file has a corresponding memo file, it is also opened.<br/>
      The default extension for database and memo files is determined by the RDD.  See SetDefault() and SetPath() for file searching and creation rules.
    </param>
    <param name="cAlias">
      An identifier name to associate with the work area when <paramref name="cDataFile" /> is opened.  Duplicate alias names are not allowed within a single application.
    </param>
    <param name="lShared">
      TRUE Attempts to open <paramref name="cDataFile" /> for shared use.  FALSE attempts to open <paramref name="xcDataFile" /> for exclusive (non-shared) use, denying all other processes access until the database file is closed.
    </param>
    <param name="lReadOnly">
      TRUE attempts to open <paramref name="cDataFile" /> with a read-only attribute, prohibiting updates to the work area.  FALSE attempts to open <paramref name="cDataFile" /> with a read-write attribute, allowing updates.
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBUseArea() is a strongly typed function used to implement DBUseArea().<br/>
      This function does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBUseArea() for more information.
    </remarks>
    <example>
      This example is a typical use of the VODBUseArea() function:
      <code language="X#">
        FUNCTION NtxUse(cDBF AS STRING) AS LOGIC PASCAL
        &#0009;LOCAL n,i           AS DWORD
        &#0009;LOCAL rddList       AS _RDDLIST
        &#0009;LOCAL aRdds         AS ARRAY
        &#0009;LOCAL lRet        <br/>
        AS LOGIC
        &#0009;aRdds := {"CAVODBF", "DBFNTX"}
        &#0009;n       := ALen(aRdds)
        &#0009;rddList := MemAlloc( (_SizeOf(DWORD)) + (n * _SizeOf(SYMBOL)) )
        &#0009;rddList.uiRddCount := n
        &#0009;FOR i := 1 TO n
        &#0009;&#0009;rddList.atomRddName[i] := SysAddAtomUpperA(aRdds[i])
        &#0009;NEXT
        &#0009;lRet := VODBUseArea(TRUE, rddList, cDBF, "", TRUE, FALSE)
        &#0009;MemFree(rddList)
        &#0009;RETURN lRet
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbUseArea'>DBUseArea</seealso>
    <seealso cref='O:XSharp.Core.Functions.NetErr'>NetErr</seealso>
  </vodbusearea>
  <vodbzap>
    <summary>
      Remove all records from open files.
    </summary>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
    <remarks>
      VODBZap() is the same as DBZap().<br/>
      This function, however, does not call the error handler and will not, therefore, produce a runtime error message or create an error object if it fails.  Thus, it may be important to check the return value to determine if the function succeeded.<br/>
      The global structure, StrucErrInfo, will contain needed information regarding any error that occurs.  See DBZap() for more information.
    </remarks>
    <example>
      This example demonstrates a typical zap operation:
      <code language="X#">
        USE sales EXCLUSIVE NEW
        IF !NetErr()
        &#0009;SET INDEX TO sales, branch, salesman
        &#0009;IF VODBZap()
        &#0009;&#0009;? "Zapped OK"
        &#0009;ELSE
        &#0009;&#0009;? "Error detected during zap"
        &#0009;ENDIF
        &#0009;CLOSE sales
        ELSE
        &#0009;? "Error detected when opening the file"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbZap'>DBZap</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbDelete'>VODBDelete</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbPack'>VODBPack</seealso>
  </vodbzap>
  <vosendmessage>
    <summary>
      Send the specified message to the specified window.
    </summary>

    <param name="hWnd">Handle of the window to which the message is being sent.</param>
    <param name="nMsg">Windows API message constant representing the message to send to the window.</param>
    <param name="wParam">First message-specific information.</param>
    <param name="lParam">Second message-specific information.</param>
    <returns>
      LONGINT return value, dependent upon the message sent.
    </returns>
    <remarks>
      This is a garbage collector-safe version of the Windows API SendMessage() function.<br/>
      If a Windows message involves a PSZ as one of the message parameters and you pass a regular string to SendMessage(), there is a potential problem with the X# garbage collection.  By using VOSendMessage() for messages involving dynamic X# data types, this problem can be avoided.
      Note:  Refer to the Windows API for further information on the SendMessage() function, messages, parameters and return values.
    </remarks>
    <example>
    </example>
  </vosendmessage>
  <w2bin>
    <summary>
      Convert a word to a string containing a 16-bit unsigned integer.
    </summary>

    <param name="wValue">The value to convert.  Decimal values are truncated.</param>
    <returns>
    </returns>
    <remarks>
      W2Bin() is a conversion function that converts a word into a 2-byte string.  Typical applications include reading foreign file types in their native format and then saving, reading, decrypting, and transmitting numeric data in their compressed binary form instead of in strings.<br/>
      Its inverse is Bin2W().
    </remarks>
    <example>
      This example uses W2Bin() to store the current procedure line to a debugging file:
      <code language="X#">
        FUNCTION ErrorLines() AS LOGIC
        &#0009;LOCAL nh
        &#0009;LOCAL lSuccess := FALSE AS LOGIC
        &#0009;nh := FOpen2("data.bin", FO_READWRITE)
        &#0009;// Assumes that file debug.bin already exists
        &#0009;IF nh != F_ERROR
        &#0009;&#0009;FWrite(nh, W2Bin(ProcLine()))
        &#0009;&#0009;FWrite(nh, W2Bin(ProcLine(1)))
        &#0009;&#0009;FClose(nh)
        &#0009;&#0009;lSuccess := TRUE
        &#0009;ELSE
        &#0009;&#0009;? "An error occurred when opening debug.bin"
        &#0009;&#0009;FError()
        &#0009;ENDIF
        &#0009;RETURN lSuccess
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
  </w2bin>
  <workdir>
    <summary>
      Return the currently selected working directory.
    </summary>
    <returns>
    </returns>
    <remarks>
      The working directory is where the associated .EXE file resides and was executed from.<br/>
      The .EXE file is either CAVO2x.EXE or your linked application's .EXE, as appropriate.
      <br/>



      This example uses the WorkDir() function to get the current directory before setting a new one:
      <code language="X#">
        LOCAL cWorkDir AS STRING
        cWorkDir := WorkDir()
        SetDefault(cWorkDir + "samples\debug")
      </code>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.CurDir'>CurDir</seealso>
    <seealso cref='O:XSharp.Core.Functions.CurDrive'>CurDrive</seealso>
    <seealso cref='O:XSharp.RT.Functions.DirChange'>DirChange</seealso>
    <seealso cref='O:XSharp.Core.Functions.DiskName'>DiskName</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDefault'>SetDefault</seealso>
  </workdir>
  <year>
    <summary>
      Extract the number of the year from a date.
    </summary>

    <param name="dDate">The date.</param>
    <returns>
      The year of <paramref name="dDate" />, including the century digits, as a 4-digit number.<br/>
      The value returned is not affected by SetDateFormat(), SetCentury(), SET DATE, or SET CENTURY.  Specifying a NULL_DATE returns 0.
    </returns>
    <remarks>
      Year() is a date conversion function that converts a date value to a numeric year value.<br/>
      If the century digits are not specified, the century is determined by the rules of SET EPOCH or SetEpoch().
      Year() is a member of a group of functions that return components of a date value as numbers.<br/>
      The group includes Day() and Month(), which return the day and month values as numbers.
    </remarks>
    <example>
      These examples illustrate Year() using the system date:
      <code language="X#">
        ? TODAY()&#0009;&#0009;&#0009;&#0009;&#0009;// 09/20/90
        ? YEAR(TODAY())&#0009;&#0009;&#0009;// 1990
        ? YEAR(TODAY()) + 11&#0009;&#0009;// 2001
        ? YEAR(05.15.64)&#0009;&#0009;&#0009;// 1964
        SetEpoch(2000)
        ? YEAR(CTOD("05.15.64"))&#0009;// 2064
      </code>
      This example creates a function using Year() to format a date value in the form month, day, year:
      <code language="X#">
        ? Mdy(TODAY())&#0009;&#0009;&#0009;&#0009;// September 20, 1990
        FUNCTION Mdy(dDate)
        &#0009;RETURN CMONTH(dDate) + " " + ;
        &#0009;&#0009;&#0009;NTrim(DAY(dDate)) ;
        &#0009;&#0009;&#0009;+ "," + STR(YEAR(dDate))
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Day'>Day</seealso>
    <seealso cref='O:XSharp.RT.Functions.Month'>Month</seealso>
    <seealsocmd>SET CENTURY</seealsocmd>
    <seealsocmd>SET DATE</seealsocmd>
    <seealsocmd>SET EPOCH</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetCentury'>SetCentury</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDateCountry'>SetDateCountry</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDateFormat'>SetDateFormat</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetEpoch'>SetEpoch</seealso>
  </year>
  <_accept>
    <summary>
      Take input from the keyboard and assign it to a memory variable.
    </summary>

    <param name="uValuePrompt">An optional prompt displayed before the input area.</param>
    <param name="TO idVar">
      The variable that will hold input from the keyboard.<br/>
      If there is no variable named <paramref name="idVar" /> that is visible to the current routine, a private variable is created.
    </param>
    <returns>
    </returns>
    <remarks>
      When _Accept is executed, it first performs a carriage return/linefeed, displays the prompt in the terminal window, and begins taking characters from the keyboard at the position immediately following the prompt.
      Up to 255 characters can be entered.  When input reaches the edge of the window, as defined by MaxCol(), the cursor moves to the next line.
      _Accept supports only two editing keys:  Backspace and Enter (Esc is not supported).  Backspace deletes the last character typed.  Enter confirms entry and is the only key that can terminate an _Accept.<br/>
      If Enter is the only key pressed, _Accept assigns a NULL_STRING to <paramref name="cVar" />.
    </remarks>
    <example>
      This example uses ACCEPT to get keyboard input from the user:
      <code language="X#">
        LOCAL cVar AS STRING
        cVar := _Accept("Enter a value:  " )
        IF cVar = NULL_STRING
        ? "User pressed Enter"
        ELSE
        ? "User input:", cVar
        ENDIF
      </code>
      <br/>



      Terminal Lite
    </example>
  </_accept>
  <_debout32>
    <summary>
      Write information to the Debug Terminal Program
    </summary>

    <param name="pszText">PSZ text that gets written to the Debug Terminal Program</param>
    <returns>
    </returns>
    <remarks>
      _DebOut32() helps when debugging X# applications. It uses the same mechanism as the Operating Systems OutPutDebugString() functions.
      To see the output you need to run a special program that intercepts this output. You can download such a program from
      http://www.sysinternals.com
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DebOut'>DebOut</seealso>
    <seealso cref='O:XSharp.Core.Functions.DebOut32'>DebOut32</seealso>
  </_debout32>
  <_dyncheck>
    <summary>
      Check integrity of dynamic memory.
    </summary>
    <returns>
      TRUE means that dynamic memory is not corrupted.  FALSE means that dynamic memory is corrupted.
    </returns>
    <remarks>
      This function is useful if you are manipulating dynamic memory directly with functions such as RegisterKid().<br/>
      It can help you determine where in your application dynamic memory corruption occurred. Care must be taken using this function. Some dynamic memory errors can cause immediate termination of the application due to the nature of the detected error.
    </remarks>
    <example>
      The following example displays a message based on the return value of _DynCheck():
      <code language="X#">
        IF _DynCheck()
        &#0009;? "Dynamic memory ok."
        ELSE
        &#0009;? "Dynamic memory corrupted."
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.DynCheckError'>DynCheckError</seealso>
    <seealso cref='O:XSharp.VO.Functions.Memory'>Memory</seealso>
    <seealso cref='O:XSharp.VO.Functions.RegisterKid'>RegisterKid</seealso>
  </_dyncheck>
  <_getcmdline>
    <summary>
      Return a pointer to the command line used to invoke the application.
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions._GetInst'>_GetInst</seealso>
    <seealso cref='O:XSharp.Core.Functions._GetPrevInst'>_GetPrevInst</seealso>
  </_getcmdline>
  <_getcmdshow>
    <summary>
      Return a constant specifying how the application window is shown.
    </summary>
    <returns>
      One of the following constants indicating the status of the window:
      Constant&#0009;Meaning&#0009;
      SW_HIDE&#0009;The window is hidden and another window activated&#0009;
      SW_MINIMIZE&#0009;The window is minimized and the top-level window in the system's list is activated&#0009;
      SW_RESTORE&#0009;Window is activated and displayed — if minimized or maximized, Windows restores it to its original size and position (same as SW_SHOWNORMAL).&#0009;
      SW_SHOW&#0009;Window is activated and displayed in its current size and position&#0009;
      SW_SHOWMAXIMIZED&#0009;Window is activated and displayed as maximized&#0009;
      SW_SHOWMINIMIZED&#0009;Window is activated and displayed as an icon&#0009;
      SW_SHOWMINNOACTIVE&#0009;Window is displayed as an icon, leaving the currently active window active&#0009;
      SW_SHOWNA&#0009;Window is displayed in its current state, leaving the currently active window active&#0009;
      SW_SHOWNOACTIVATE&#0009;Window is displayed in its most recent size and position, leaving the currently active window active&#0009;
      SW_SHOWNORMAL&#0009;Window is activated and displayed — if minimized or maximized, Windows restores it to its original size and position (same as SW_RESTORE).&#0009;
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions._GetCmdLine'>_GetCmdLine</seealso>
    <seealso cref='O:XSharp.Core.Functions._GetInst'>_GetInst</seealso>
    <seealso cref='O:XSharp.Core.Functions._GetPrevInst'>_GetPrevInst</seealso>
  </_getcmdshow>
  <_getfirstparam>
    <summary>
      Access the first parameter in a variable parameter list.
    </summary>

    <param name="pptrStart">The anonymous pointer variable local to the calling function which will serve as an address to the list of variable parameters.</param>
    <param name="ptrFirst">The address of a fixed parameter variable in the parameter list of the calling function.</param>
    <param name="dwTypeFirst">Specifies the type of the above fixed parameter.</param>
    <param name="dwType">Specifies the type of the actual parameter to be accessed.</param>
    <returns>
      The value (USUAL) of the type specified for <paramref name="dwType" />.
    </returns>
    <remarks>
      This special function is used in conjunction with _GetNextParam() for accessing the variable parameters within functions defined to access a variable parameter list.
    </remarks>
    <example>
      The following example illustrates the implementation of a function accepting a variable number of parameters:
      <code language="X#">
        FUNCTION CFunc(dummy:=1 AS INT, dwNumber AS INT, ... );
        &#0009;AS VOID STRICT
        LOCAL   xParam &#0009;AS USUAL
        LOCAL   i&#0009;&#0009;AS DWORD
        LOCAL   pParam&#0009;AS PTR
        LOCAL   cString &#0009;AS STRING
        xParam := _GetFirstParam(@pParam, @dwNumber, INT,;
        STRING)
        ? dwNumber
        ? xParam
        FOR i := 2 UPTO dwNumber&#0009;
        &#0009;xParam := _GetNextParam(@pParam, STRING)
        &#0009;? xParam
        NEXT
        RETURN&#0009;
        FUNCTION Start
        &#0009;CFunc(,1, "How")
        &#0009;CFunc(,2, "How ", "are ")
        &#0009;CFunc(,3, "How ", "are ", "you ")
      </code>
    </example>
    <seealsocmd>_GetNextParam</seealsocmd>
  </_getfirstparam>
  <_getinst>
    <summary>
      Return the instance handle of an application or DLL.
    </summary>
    <returns>
    </returns>
    <remarks>
      The instance handle is assigned by Windows to the application or DLL and is needed for low-level Windows system programming.
    </remarks>
    <example>
      The following example loads a string from the string table.<br/>
      This example requires the Win32 API library to be included in the application's search path:
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL x := BUFFER(64) AS STRING
        &#0009;LOCAL cb AS WORD
        &#0009;cb := LoadString(_GetInst(), 100, x, 64)
        &#0009;x := LEFT(x, cb)
        &#0009;? x         // Hello World
      </code>
      &#0009;
      <code language="X#">
        RESOURCE StringTable
        &#0009;{
        &#0009;&#0009;100, "Hello World"
        &#0009;}
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions._GetCmdLine'>_GetCmdLine</seealso>
    <seealso cref='O:XSharp.Core.Functions._GetCmdShow'>_GetCmdShow</seealso>
    <seealso cref='O:XSharp.Core.Functions._GetPrevInst'>_GetPrevInst</seealso>
  </_getinst>
  <_getnextparam>
    <summary>
      Access the remaining parameters in a variable parameter list.
    </summary>

    <param name="pptrStart">Anonymous pointer obtained by a previous call to _GetFirstParam() or _GetNextParam().</param>
    <param name="dwType">Specifies the type of the actual parameter to be accessed.</param>
    <returns>
      The value (USUAL) of the type specified for <paramref name="dwType" />.
    </returns>
    <remarks>
      This special function is used in conjunction with _GetFirstParam() for accessing the variable parameters within functions defined to access a variable parameter list.
    </remarks>
    <example>
      See the _GetFirstParam() example.
    </example>
    <seealsocmd>_GetFirstParam</seealsocmd>
  </_getnextparam>
  <_getprevinst>
    <summary>
      NOTE: This is not supported in 32 bit applications.
      The function is kept for backward compatibility, but always returns a NULL_PTR.
      <br/>



      Return the previous instance handle of an application or DLL.
    </summary>
    <returns>
    </returns>
    <remarks>
      <note type="tip">
        For a Windows 3.2 application or DLL, the previous instance handle is always NULL.
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions._GetCmdLine'>_GetCmdLine</seealso>
    <seealso cref='O:XSharp.Core.Functions._GetCmdShow'>_GetCmdShow</seealso>
    <seealso cref='O:XSharp.Core.Functions._GetInst'>_GetInst</seealso>
  </_getprevinst>
  <_registerexit>
    <summary>
      Register an exit routine to be called when the current application ends.
    </summary>

    <param name="ptrRoutine">A pointer to the function or procedure to register as an exit routine.</param>
    <returns>
      TRUE if successful; otherwise FALSE.
    </returns>
    <remarks>
      The registered routine will be called when the application ends, regardless of whether the termination was normal or the result of an error.
      A maximum number of 64 routines can be registered as exit routines, but the order of execution cannot be controlled by the application.<br/>
      The exit routines may be executed in any order, regardless of the order in which you register them.
      Note:<br/>
      The PROCEDURE statement can be used to declare initialization routines.
    </remarks>
    <example>
      The following example displays a message box before the current application is terminated:
      <code language="X#">
        FUNCTION Start()
        &#0009;...
        &#0009;_RegisterExit(@MyExitFunc())
        &#0009;...
        FUNCTION MyExitFunc()
        &#0009;MessageBox(0, "App over", "Exit", MB_OK)
      </code>
    </example>
    <seealsocmd>PROCEDURE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.RegisterAxit'>RegisterAxit</seealso>
  </_registerexit>
  <_voloadlibrary>
    <summary>
      To safely use a .Dll that was created in X#.
    </summary>

    <param name="idVariable">The name of a variable expressed as a literal identifier.</param>
    <returns>
      A
    </returns>
    <remarks>
      When a .Dll is created in X#, it will almost always call on the runtime library. It is possible that the .Dll you are trying to load will be calling the old version of the runtime (CAVORT20.DLL) into memory and this needs to be avoided.
      Using _VOLoadLibrary( ) to load the .Dll will allow the system to check to see that the old runtime (CAVORT20.DLL) is not being brought into memory and will generate an error if it is.
      If the old runtime is detected the runtime will first call the error handler and then terminate the application because having two runtimes in memory would cause all sorts of problems.
    </remarks>
    <example>
    </example>
  </_voloadlibrary>
  <_wait>
    <summary>
      Display a prompt after sending a carriage return/linefeed to the terminal window, then wait for a key to be pressed.
      Note:  WAIT is a compatibility command and is no longer recommended.
    </summary>

    <param name="uValuePrompt">
      An optional prompt displayed before the input area.<br/>
      If omitted, "Press any key to continue..." is displayed.  Specify NULL_STRING if you do not want to display a prompt.
    </param>
    <param name="Value">
      The variable that will hold input from the keyboard.<br/>
      If there is no variable named <paramref name="idVar" /> that is visible to the current routine, a private variable is created.  <paramref name="idVar" /> is assigned the keystroke as a string.<br/>
      If an Alt or Ctrl key combination is pressed, WAIT assigns Chr(0) to <paramref name="idVar" />.  <br/>

      &#0009;Non-alphanumeric values entered by pressing an Alt+key combination assign the specified character.<br/>
      If the character can be displayed, it is echoed to the screen.
    </param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealsocmd>ACCEPT</seealsocmd>
  </_wait>
  <uAreaValue>
    <span>
      Specifies the work area name or number for a table from which the value must be retrieved.
    </span>
  </uAreaValue>
  <uAreaOperation>
    <span>
      Specifies the work area name or number for a table on which the operation must be performed.
    </span>
  </uAreaOperation>
  <currentWorkareaParam>
    <span>
      <br/>By default, this function operates on the currently selected work area.
      <br/>It can be made to operate on an unselected work area by specifying
      it within an aliased expression or by calling the overload that accepts a workarea
      parameter (a workarea number or alias ).<br/>
    </span>
  </currentWorkareaParam>
  <currentWorkarea>
    <span>
      By default, this function operates on the currently selected work area.<br/>
      It can be made to operate on an unselected work area by specifying
      it within an aliased expression
    </span>
  </currentWorkarea>
  <cbwhile>
    <span>
      A code block that defines another condition that each record must meet in order
      to be processed.
      As soon as a record is encountered that causes the condition to fail, the operation
      terminates.<br/>

      If no scope is specified, <paramref name="cbWhileCondition" /> changes the default scope to <paramref name="lRest" />.<br/>

      You define the scope using one of these three, mutually exclusive arguments.<br/>
      The default is all records.
    </span>
  </cbwhile>
  <cbfor>
    <span>
      A code block that defines a condition that each record within the scope must meet in order to be processed.
    </span>
  </cbfor>
  <recordscope>
    <span>
      <note type="tip">
        The <paramref name="nNext" />, <paramref name="nRecord" />, and <paramref name="lRest" /> arguments are mutually exclusive. You should not pass all three of them.
        And if you pass the <paramref name="cbWhile" /> argument then this also controls the scope behavior.
      </note>
    </span>
  </recordscope>
  <vodbsetscope>
    <summary>Set the locate condition.</summary>
    <param name="scope">Scope information for the current workarea</param>
    <returns>TRUE if successful; otherwise, FALSE.</returns>
    <remarks>Please note that this scope information is NOT the order scope, but a class that stores information about LOCATE operations and other workarea operations.</remarks>
    <seealso cref="T:XSharp.RDD.Support.DbScopeInfo"/>
  </vodbsetscope>
  <vodbgetscope>
    <summary>Gets the current locate condition.</summary>
    <returns>Scope information for the current workarea.</returns>
    <remarks>Please note that this scope information is NOT the order scope, but a class that stores information about LOCATE operations and other workarea operations.</remarks>
    <seealso cref="T:XSharp.RDD.Support.DbScopeInfo"/>
  </vodbgetscope>
  <sysobject>
    <summary>
      Install a system-wide object. Please not that this works a bit different from Visual Objects.
    </summary>
    <param name="oSys">
      The object to be installed. <paramref name="oSys"/> can be a NULL_OBJECT, in which case the system object is cleared.
    </param>
    <returns>
      <paramref name="oSys"/> or, if <paramref name="oSys"/> is not specified, the currently installed object.
    </returns>
    <remarks>
      Unlike in VO the SysObject is not used to receive all messages being sent to other data types because in .Net all types by default already accept messages.
    </remarks>
  </sysobject>
  <_run>
    <summary>Execute a Windows or DOS application, a batch file, or a DOS command.</summary>
    <remarks>
      This function uses the WinExec() function from the windows api. The security issues as mentioned there are also valid for this function.
      <see href='!:https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec'>WinExec()</see>
    </remarks>
    <param name="cProgram">
      The command line (file name plus optional parameters) for the application to be executed.
      If the name of the executable file in the lpCmdLine parameter does not contain a directory path,
      the system searches for the executable file in this sequence:<br/>
      1) The directory from which the application loaded.<br/>
      2) The current directory.<br/>
      3) The Windows system directory. The GetSystemDirectory function retrieves the path of this directory.<br/>
      4) The Windows directory. The GetWindowsDirectory function retrieves the path of this directory.<br/>
      5) The directories listed in the PATH environment variable.<br/>
    </param>
    <returns>
      If the function succeeds, the return value is greater than 31. f the function fails, the return value is one of the following error values.
      <list>
        <listheader>
          <term>Return code/value</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>
            0
          </term>
          <description>
            The system is out of memory or resources.
          </description>
        </item>
        <item>
          <term>
            ERROR_BAD_FORMAT (1)
          </term>
          <description>The .exe file is invalid.</description>
        </item>
        <item>
          <term>ERROR_FILE_NOT_FOUND (2)</term>
          <description>
            The specified file was not found.
          </description>
        </item>
        <item>
          <term>ERROR_PATH_NOT_FOUND (3)</term>
          <description>The specified path was not found</description>
        </item>
      </list>
    </returns>

  </_run>
  <oclone>
    <summary>Duplicate an object`.</summary>
    <param name="o">The variable to duplicate. </param>
    <returns>A reference to a new object with the same values as the original object.</returns>
  </oclone>
  <mcompilemexec>
    <span>
      <note type="tip">
        In Visual Objects the return value of MCompile() is a specially formatted string with PCode tokens.
        We have changed that in <b>X#</b>, and the return value of MCompile() is now a codeblock of the _Codeblock type. <br/>
        If the string that was compiled in Visual Objects was in the form of "{||.....}" then you hed
        to call MExec() to convert the string into a _Codeblock object. To evaluate the codeblock you
        would then have to pass the result of MExec() into the EVal() function.<br/>
        If the string that was compiled in Visual Objects was not in the form of "{||.....}",
        like in the examples of this topic then calling MExec() on return value of MCompile()
        would immediately evaluate the expression and return the result.<br/>
        Since in <b>X#</b>the return the return value of MCompile() is a codeblock of the _Codeblock type,
        you can you can also use the Eval() function to evaluate the codeblock. <br/>
        In X# Calling MExec() on the codeblock returned from MCompile() will either directly evaluate the
        codeblock (when the original string was not in the codeblock format) or will simply return the same
        codeblock when the original string was in the codeblock format.
      </note>
    </span>
  </mcompilemexec>
  <mcompileexamples>
    <span>
      This examples show typical uses of MCompile() and MExec():
      <code language="X#">
        LOCAL cComp AS CodeBlock        // Note that this had to be string in Visual Objects
        cComp := MCompile("2+3")
        ? MExec(cComp)                  // 5
        nResult := MExec(cComp)         // Assigning
        ? MExec(cComp) = 5              // Comparing
        MEMVAR Two // Declare and initialize a Private variable
        Two := 2
        cComp := MCompile("Two+3")      // Macro refers to the private variable
        ? MExec(cComp)                  // 5
        // The followin works in X# only, since the result of cComp is now a CodeBlock
        ? Eval(cComp)
      </code>

    </span>
  </mcompileexamples>
  <datetime>
    <summary>
      Returns the current date and time as a DateTime value, or creates a year 2000-compliant DateTime value.
    </summary>
    <param name="nYear">
      Specifies the year in the DateTime value. <paramref name="nYear" /> can be a value from 100 to 9999.
    </param>
    <param name="nMonth">
      Specifies the month in the DateTime value. <paramref name="nMonth" /> can be a value from 1 to 12.
    </param>
    <param name="nDay">
      Specifies the day in the DateTime value. <paramref name="nDay" /> can be a value from 1 to 31.
    </param>
    <param name="nHours">
      Specifies the hours in the DateTime value. <paramref name="nHours" /> can be a value from from 0 (midnight) to 23 (11 P.M). Defaults to 0 if omitted.
    </param>
    <param name="nMinutes">
      Specifies the minutes in the DateTime value. <paramref name="nMinutes" /> can be a value from 0 to 59. Defaults to 0 if omitted.
    </param>
    <param name="nSeconds">
      Specifies the seconds in the DateTime value. <paramref name="nSeconds" /> can be a value from 0 to 59. Defaults to 0 if omitted.
    </param>

  </datetime>

</Runtimefunctions>
