<?xml version="1.0" encoding="utf-8"?>
<Runtimefunctions>
  <aadd>
    <summary>
      向数组末尾添加新元素。
    </summary>
    <param name="aTarget">要添加新元素的目标数组。</param>
    <param name="uNewElement">
      分配给新元素的值。<br/>
      如果 <paramref name="uNewElement" /> 是另一个数组，目标数组中的新元素将包含对 <paramref name="uNewElement" /> 指定的数组的引用，而不是数组本身。
    </param>
    <param name="nElement">
      数组中要分配新值的元素位置。如果未指定 <paramref name="nElement">nElement</paramref>，则将值分配给最后一个元素。
    </param>
    <returns>
      <paramref name="uNewElement" /> 的值。
    </returns>
    <remarks>
      AAdd() 将目标数组的实际长度增加一。<br/>
      新创建的数组元素被赋予 <paramref name="uNewElement" /> 指定的值。<br/>
      AAdd() 用于动态增加数组的大小。<br/>
      它对于构建动态列表或队列很有用。<br/>
      一个很好的例子是用于保存 Get 对象的 GetList 数组。<br/>
      AAdd() 类似于 ASize()，但一次只添加一个元素；ASize() 可以将数组更改为指定大小。<br/>
      然而，AAdd() 的优点是可以为新元素分配值，而 ASize() 不能。<br/>
      AAdd() 看似与 AIns() 相似，但它们是不同的：AIns() 在数组内移动元素，但不改变数组的长度。<br/>
    </remarks>
    <example>
      这些示例展示了多次调用 AAdd() 时会发生什么：
      <code language="X#">
        LOCAL aArray AS ARRAY
        aArray := {}&#0009;&#0009;&#0009;&#0009;&#0009;// aArray 是一个空数组
        AAdd(aArray, 5)&#0009;&#0009;&#0009;// aArray 是 {5}
        AAdd(aArray, 10)&#0009;&#0009;&#0009;// aArray 是 {5, 10}
        AAdd(aArray, {12, 10})&#0009;&#0009;// aArray 是 {5, 10, {12, 10}}
        AAdd(aArray, 1, 2 )&#0009;&#0009;// aArray 是 {5, 2, 10, {12, 10}}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AIns'>AIns</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASize'>ASize</seealso>
  </aadd>

  <abs>
    <summary>
      返回数值表达式的绝对值，无论其符号如何。
    </summary>
    <param name="nValue">要评估的数值表达式。</param>
    <returns>
      一个正数或0。
    </returns>
    <remarks>
      如果 <paramref name="nValue" /> 大于或等于0，绝对值与 <paramref name="nValue" /> 相同。<br/>
      如果 <paramref name="nValue" /> 小于0，则为 <paramref name="nValue" /> 的负值。<br/>
      Abs() 允许您获取两个数字大小之间的差异，<br/>
      其中大小是指距离原点或零的距离。
    </remarks>
    <example>
      以下示例展示了 Abs() 的典型结果：
      <code language="X#">
        nNum1 := 100
        nNum2 := 150
        ? nNum1 - nNum2&#0009;&#0009;&#0009;&#0009;// -50
        ? ABS(nNum1 - nNum2)&#0009;&#0009;&#0009;//  50
        ? ABS(nNum2 - nNum1)&#0009;&#0009;&#0009;//  50
        ? ABS(-12)&#0009;&#0009;&#0009;&#0009;&#0009;//  12
        ? ABS(0)&#0009;&#0009;&#0009;&#0009;&#0009;//  0
        nSouth := -5
        nNorth := 4
        ? ABS(nSouth) - ABS(nNorth)&#0009;&#0009;// 1
        ? ABS(nSouth) &gt; ABS(nNorth)&#0009;&#0009;// TRUE
        ? nSouth &gt; nNorth&#0009;&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AbsFloat'>AbsFloat</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsInt'>AbsInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsLong'>AbsLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal4'>AbsReal4</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal8'>AbsReal8</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsShort'>AbsShort</seealso>
  </abs>

  <absfloat>
    <summary>
      返回强类型数值表达式的绝对值，无论其符号如何。
    </summary>
    <param name="fValue">要评估的浮点数。</param>
    <returns>
      一个正数或0。
    </returns>
    <remarks>
      AbsFloat() 与 Abs() 相同，只是它是强类型的。<br/>
      更多信息，请参见 Abs()。
    </remarks>
    <example>
      这些示例展示了 AbsFloat() 的典型结果：
      <code language="X#">
        LOCAL fNum1 := 99.99 AS FLOAT
        LOCAL fNum2 := 149.99 AS FLOAT
        ? fNum1 - fNum2&#0009;&#0009;&#0009;&#0009;// -50.00
        ? AbsFloat(fNum1 - fNum2)&#0009;&#0009;//  50.00
        ? AbsFloat(fNum2 - fNum1)&#0009;&#0009;//  50.00
        ? AbsFloat(-12)&#0009;&#0009;&#0009;&#0009;//  12
        ? AbsFloat(0)&#0009;&#0009;&#0009;&#0009;//  0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Abs'>Abs</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsInt'>AbsInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsLong'>AbsLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal4'>AbsReal4</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal8'>AbsReal8</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsShort'>AbsShort</seealso>
  </absfloat>

  <absint>
    <summary>
      返回强类型数值表达式的绝对值，无论其符号如何。
    </summary>
    <param name="liValue">要评估的32位整数。</param>
    <returns>
      一个正数或0。
    </returns>
    <remarks>
      AbsInt() 与 Abs() 相同，只是它是强类型的。<br/>
      更多信息，请参见 Abs()。
    </remarks>
    <example>
      这些示例展示了 AbsInt() 的典型结果：
      <code language="X#">
        LOCAL iNum1 := 100 AS INT
        LOCAL iNum2 := 150 AS INT
        ? iNum1 - iNum2&#0009;&#0009;&#0009;&#0009;// -50
        ? AbsInt(iNum1 - iNum2)&#0009;&#0009;//  50
        ? AbsInt(iNum2 - iNum1)&#0009;&#0009;//  50
        ? AbsInt(-12)&#0009;&#0009;&#0009;&#0009;//  12
        ? AbsInt(0)&#0009;&#0009;&#0009;&#0009;//  0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Abs'>Abs</seealso>
    <seealso cref='O:XSharp.RT.Functions.AbsFloat'>AbsFloat</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsLong'>AbsLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal4'>AbsReal4</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal8'>AbsReal8</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsShort'>AbsShort</seealso>
  </absint>

  <abslong>
    <summary>
      返回强类型数值表达式的绝对值，无论其符号如何。
    </summary>
    <param name="liValue">要评估的32位整数。</param>
    <returns>
      一个正数或0。
    </returns>
    <remarks>
      AbsLong() 与 Abs() 相同，只是它是强类型的。<br/>
      更多信息，请参见 Abs()。
    </remarks>
    <example>
      这些示例展示了 AbsLong() 的典型结果：
      <code language="X#">
        LOCAL liNum1 := 100 AS LONGINT
        LOCAL liNum2 := 150 AS LONGINT
        ? liNum1 - liNum2&#0009;&#0009;&#0009;&#0009;// -50
        ? AbsLong(liNum1 - liNum2)&#0009;&#0009;&#0009;//  50
        ? AbsLong(liNum2 - liNum1)&#0009;&#0009;&#0009;//  50
        ? AbsLong(-12)&#0009;&#0009;&#0009;&#0009;&#0009;//  12
        ? AbsLong(0)&#0009;&#0009;&#0009;&#0009;&#0009;//  0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Abs'>Abs</seealso>
    <seealso cref='O:XSharp.RT.Functions.AbsFloat'>AbsFloat</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsInt'>AbsInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal4'>AbsReal4</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal8'>AbsReal8</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsShort'>AbsShort</seealso>
  </abslong>

  <absreal4>
    <summary>
      返回强类型数值表达式的绝对值，无论其符号如何。
    </summary>
    <param name="r4Value">要评估的32位浮点数。</param>
    <returns>
      一个正数或0。
    </returns>
    <remarks>
      AbsReal4() 与 Abs() 相同，只是它是强类型的。<br/>
      更多信息，请参见 Abs()。
    </remarks>
    <example>
      这些示例展示了 AbsReal4() 的典型结果：
      <code language="X#">
        LOCAL r4Num1 := 99.99 AS REAL4
        LOCAL r4Num2 := 149.99 AS REAL4
        ? r4Num1 - r4Num2&#0009;&#0009;&#0009;&#0009;// -50.00
        ? AbsReal4(r4Num1 - r4Num2)&#0009;&#0009;&#0009;//  50.00
        ? AbsReal4(r4Num2 - r4Num1)&#0009;&#0009;&#0009;//  50.00
        ? AbsReal4(-12)&#0009;&#0009;&#0009;&#0009;&#0009;//  12
        ? AbsReal4(0)&#0009;&#0009;&#0009;&#0009;&#0009;//  0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Abs'>Abs</seealso>
    <seealso cref='O:XSharp.RT.Functions.AbsFloat'>AbsFloat</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsInt'>AbsInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsLong'>AbsLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal8'>AbsReal8</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsShort'>AbsShort</seealso>
  </absreal4>

  <absreal8>
    <summary>
      返回强类型数值表达式的绝对值，无论其符号如何。
    </summary>
    <param name="r8Value">要评估的64位浮点数。</param>
    <returns>
      一个正数或0。
    </returns>
    <remarks>
      AbsReal8() 与 Abs() 相同，只是它是强类型的。<br/>
      更多信息，请参见 Abs()。
    </remarks>
    <example>
      这些示例展示了 AbsReal8() 的典型结果：
      <code language="X#">
        LOCAL r8Num1 := 99.99 AS REAL8
        LOCAL r8Num2 := 149.99 AS REAL8
        ? r8Num1 - r8Num2&#0009;&#0009;&#0009;&#0009;// -50.00
        ? AbsReal8(r8Num1 - r8Num2)&#0009;&#0009;&#0009;//  50.00
        ? AbsReal8(r8Num2 - r8Num1)&#0009;&#0009;&#0009;//  50
        ? AbsReal8(-12)&#0009;&#0009;&#0009;&#0009;&#0009;//  12
        ? AbsReal8(0)&#0009;&#0009;&#0009;&#0009;&#0009;//  0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Abs'>Abs</seealso>
    <seealso cref='O:XSharp.RT.Functions.AbsFloat'>AbsFloat</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsInt'>AbsInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsLong'>AbsLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal4'>AbsReal4</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsShort'>AbsShort</seealso>
  </absreal8>

  <absshort>
    <summary>
      返回强类型数值表达式的绝对值，无论其符号如何。
    </summary>
    <param name="siValue">要评估的16位整数。</param>
    <returns>
      一个正数或0。
    </returns>
    <remarks>
      AbsShort() 与 Abs() 相同，只是它是强类型的。<br/>
      更多信息，请参见 Abs()。
    </remarks>
    <example>
      这些示例展示了 AbsShort() 的典型结果：
      <code language="X#">
        LOCAL siNum1 := 100 AS SHORTINT
        LOCAL siNum2 := 150 AS SHORTINT
        ? siNum1 - siNum2&#0009;&#0009;&#0009;&#0009;// -50
        ? AbsShort(siNum1 - siNum2)&#0009;&#0009;&#0009;//  50
        ? AbsShort(siNum2 - siNum1)&#0009;&#0009;&#0009;//  50
        ? AbsShort(-12)&#0009;&#0009;&#0009;&#0009;&#0009;//  12
        ? AbsShort(0)&#0009;&#0009;&#0009;&#0009;&#0009;//  0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Abs'>Abs</seealso>
    <seealso cref='O:XSharp.RT.Functions.AbsFloat'>AbsFloat</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsInt'>AbsInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsLong'>AbsLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal4'>AbsReal4</seealso>
    <seealso cref='O:XSharp.Core.Functions.AbsReal8'>AbsReal8</seealso>
  </absshort>

  <aclone>
    <summary>
      复制一个多维数组。
    </summary>
    <param name="aSource">要复制的数组。</param>
    <returns>
      <paramref name="aSource" /> 的副本。
    </returns>
    <remarks>
      AClone() 创建 <paramref name="aSource" /> 的完整副本。<br/>
      如果 <paramref name="aSource" /> 包含子数组，AClone() 会创建匹配的子数组，并用 <paramref name="aSource" /> 子数组中的值的副本填充它们。<br/>
      要通过引用复制子数组而不是创建新的子数组，请使用 ACloneShallow()。
    </remarks>
    <example>
      这个例子创建一个数组，然后使用 AClone() 复制它。<br/>
      然后修改第一个数组，但复制的副本不受影响：
      <code language="X#">
        LOCAL aOne, aTwo AS ARRAY
        aOne := {1, 2, 3}&#0009;&#0009;&#0009;// aOne 是 {1, 2, 3}
        aTwo := AClone(aOne)&#0009;&#0009;&#0009;// aTwo 是 {1, 2, 3}
        aOne[1] := 99&#0009;&#0009;&#0009;&#0009;// aOne 是 {99, 2, 3}
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 但 aTwo 仍然是 {1,2,3}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ACloneShallow'>ACloneShallow</seealso>
    <seealso cref='O:XSharp.RT.Functions.ACopy'>ACopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.ADel'>ADel</seealso>
    <seealso cref='O:XSharp.RT.Functions.AIns'>AIns</seealso>
    <seealso cref='O:XSharp.RT.Functions.AReplicate'>AReplicate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASize'>ASize</seealso>
  </aclone>

  <acloneshallow>
    <summary>
      浅复制一个数组，不包括其子数组。
    </summary>
    <param name="aSource">要复制的数组。</param>
    <returns>
      <paramref name="aSource" /> 的浅复制副本，不包括其子数组。
    </returns>
    <remarks>
      ACloneShallow() 创建 <paramref name="aSource" /> 的副本。<br/>
      与 AClone() 不同，ACloneShallow() 不检查 <paramref name="aSource" /> 是否包含子数组，如果存在也不会复制它们。<br/>
      ACloneShallow() 的工作方式也与 AClone() 不同，AClone() 通过递归遍历源数组来进行复制。<br/>
      ACloneShallow() 首先从源数组直接获取信息构建目标数组结构，然后将第一维的值复制到目标数组。<br/>
      如果源数组的某个元素是子数组，目标数组将包含对该子数组的引用。
    </remarks>
    <example>
      这个例子创建一个数组并使用 ACloneShallow() 复制它。<br/>
      此外，通过改变源子数组中的一个元素自动影响目标子数组，<br/>
      说明子数组是通过引用复制的：
      <code language="X#">
        LOCAL aSource, aTarget, aSourceSubArray AS ARRAY
        aSourceSubArray := {3,4,5}
        aSource := {1, 2, aSourceSubArray}
        aTarget := ACloneShallow(aSource)
        // aTarget 是 {1, 2, {3,4,5}}
        // 现在改变源子数组
        aSourceSubArray[3] := 100
        // 这个改变也反映在 aTarget 中
        // aTarget 现在是 {1, 2, {3,4,100}}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AClone'>AClone</seealso>
  </acloneshallow>

  <acopy>
    <summary>
      将元素从一个数组复制到另一个数组。
    </summary>
    <param name="aSource">要从中复制元素的数组。</param>
    <param name="aTarget">要将元素复制到的数组。</param>
    <param name="nStart">
      <paramref name="aSource" /> 中的起始元素位置。<br/>
      负值从末尾开始。<br/>
      如果 <paramref name="nCount" /> 为正，默认值为 1；如果 <paramref name="nCount" /> 为负，默认值为数组长度。
    </param>
    <param name="nCount">
      从 <paramref name="nStart" /> 开始，要从 <paramref name="aSource" /> 复制的元素数量。<br/>
      负值从末尾开始。<br/>
      如果未指定 <paramref name="nCount" />，则从起始元素开始复制 <paramref name="aSource" /> 中的所有元素。
    </param>
    <param name="nTargetPos">
      <paramref name="aTarget" /> 中接收来自 <paramref name="aSource" /> 元素的起始元素位置。<br/>
      默认值为 1。
    </param>
    <returns>
      对 <paramref name="aTarget" /> 的引用。
    </returns>
    <remarks>
      ACopy() 将元素从 <paramref name="aSource" /> 复制到 <paramref name="aTarget" />。<br/>
      <paramref name="aTarget" /> 必须已经存在，并且大小足以容纳被复制的元素。<br/>
      如果 <paramref name="aSource" /> 有更多元素，某些元素将不会被复制。
      ACopy() 复制所有数据类型的值。<br/>
      如果 <paramref name="aSource" /> 的一个元素是子数组，<paramref name="aTarget" /> 中相应的元素将只包含对该子数组的引用。<br/>
      因此，ACopy() 不会创建多维数组的完整副本。<br/>
      要做到这一点，请使用 AClone() 函数。
    </remarks>
    <example>
      这个例子创建两个数组，每个数组都填充一个值。<br/>
      然后将源数组的前两个元素复制到目标数组中：
      <code language="X#">
        LOCAL nCount := 2, nStart := 1, aOne, aTwo
        aOne := {1, 1, 1}
        aTwo := {2, 2, 2}
        ACopy(aOne, aTwo, nStart, nCount)
        // aTwo 现在是 {1, 1, 2}
      </code>
      这个例子将一个数组以相反的顺序复制到另一个数组中：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL a1, a2 AS ARRAY
        &#0009;a1 := {1, 2, 3, 4, 5}
        &#0009;a2: = ArrayCreate(ALen(a1))
        &#0009;&#0009;// 从末尾开始并向后步进
        &#0009;ACopy(a1, a2, -1, - 0xFFFF, 1)&#0009;// 反转数组
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AClone'>AClone</seealso>
    <seealso cref='O:XSharp.RT.Functions.ADel'>ADel</seealso>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AFill'>AFill</seealso>
    <seealso cref='O:XSharp.RT.Functions.AIns'>AIns</seealso>
    <seealso cref='O:XSharp.RT.Functions.AReplicate'>AReplicate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASort'>ASort</seealso>
  </acopy>

  <acot>
    <summary>
      计算一个数的反余切。
    </summary>
    <param name="nNum">任意数值。</param>
    <returns>
      一个介于 -PI/2 和 PI/2 之间的数，表示以弧度为单位的角度，其余切等于 <paramref name="nNum" />。
    </returns>
    <remarks>
    </remarks>
    <example>
      这个例子使用 ACot() 来找到余切为 20 的角度：
      <code language="X#">? ACot(20)&#0009;&#0009;&#0009;// 0.05 弧度</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ATan'>ATan</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cos'>Cos</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cot'>Cot</seealso>
    <seealso cref='O:XSharp.RT.Functions.Sin'>Sin</seealso>
    <seealso cref='O:XSharp.RT.Functions.Tan'>Tan</seealso>
  </acot>

  <adel>
    <summary>
      删除数组元素。
    </summary>
    <param name="aTarget">要删除元素的数组。</param>
    <param name="dwPosition">要删除元素的位置。</param>
    <returns>
      对 <paramref name="aTarget" /> 的引用。
    </returns>
    <remarks>
      当从数组中删除一个元素时，其内容将丢失，并且从该位置到数组末尾的所有元素都会向上移动一个位置。<br/>
      数组的最后一个元素变为 NIL。
    </remarks>
    <example>
      这个例子创建一个包含三个元素的数组，然后删除第二个元素。<br/>
      第三个元素向上移动一个位置，新的第三个元素被赋值为 NIL：
      <code language="X#">
        LOCAL aArray
        aArray := {1, 2, 3}&#0009;&#0009;// aArray 现在是 {1, 2, 3}
        ADel(aArray, 2)&#0009;&#0009;&#0009;// aArray 现在是 {1, 3, NIL}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ACopy'>ACopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.ADel'>ADel</seealso>
    <seealso cref='O:XSharp.RT.Functions.AFill'>AFill</seealso>
    <seealso cref='O:XSharp.RT.Functions.AIns'>AIns</seealso>
  </adel>

  <adir>
    <summary>
      用目录信息填充一系列数组。
      注意：<br/>
      ADir() 是一个兼容性函数，因此不推荐使用。<br/>
      它被 Directory() 函数取代，后者将所有文件信息返回在一个多维数组中。
    </summary>
    <param name="cFileSpec">
      目录搜索的文件规范。<br/>
      除了文件名外，此规范可能包括可选的驱动器、目录和扩展名。<br/>
      文件名和扩展名可以包含标准通配符（* 和 ?）。<br/>
      如果未指定驱动器和目录，此函数将使用 SetDefault() 设置。
    </param>
    <param name="acFileNames">
      用匹配 <paramref name="cFileSpec" /> 的文件名填充的数组。<br/>
      每个元素将包含文件名和扩展名作为字符串，全部为大写字母。
    </param>
    <param name="anSizes">
      用 <paramref name="acFileNames" /> 中相应文件的大小填充的数组。
    </param>
    <param name="adDates">
      用 <paramref name="acFileNames" /> 中相应文件的日期填充的数组。
    </param>
    <param name="acTimes">
      用 <paramref name="acFileNames" /> 中相应文件的时间填充的数组，格式为 hh:mm:ss。
    </param>
    <param name="acAttributes">
      用 <paramref name="acFileNames" /> 中相应文件的属性填充的数组。<br/>
      如果指定了 <paramref name="acAttributes" />，则包括隐藏、系统和目录文件以及普通文件。<br/>
      如果未指定 <paramref name="acAttributes" />，则只包括普通文件。
    </param>
    <returns>
      匹配 <paramref name="cFileSpec" /> 中描述的目录模式的文件数量。
    </returns>
    <remarks>
      ADir() 执行两个基本操作。<br/>
      首先，它返回匹配文件规范的文件数量。<br/>
      其次，它用文件名、大小、日期、时间和属性填充一系列数组。<br/>
      注意，所有数组参数必须在调用此函数之前存在，并且必须有足够大的大小来容纳函数结果。
      <note type="tip">
        如果指定了 <paramref name="acAttributes" />，并且 <paramref name="cFileSpec" /> 包含匹配目录名的模式（如 "*.*" 或 "*."），则目录会包含在 <paramref name="acFileNames" /> 中。<br/>
        它们用属性值 "D" 表示。<br/>
        如果在子目录中执行 ADir()，<paramref name="acFileNames" /> 的前两个条目是 "." 和 ".."，即父目录和当前目录别名。<br/>
        报告目录的最后更新日期和时间，但目录的大小始终为 0。
      </note>
    </remarks>
    <example>
      这个例子创建一个数组来保存当前默认目录中所有 .TXT 文件的名称，然后使用 AEval() 将它们列出到控制台：
      <code language="X#">
        LOCAL aFiles AS ARRAY
        aFiles := ArrayCreate(ADir("*.txt"))
        ADir("*.txt", aFiles)
        AEval(aFiles, {|element| QOut(element)})
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScan'>AScan</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASort'>ASort</seealso>
    <seealso cref='O:XSharp.RT.Functions.Directory'>Directory</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDefault'>SetDefault</seealso>
  </adir>

  <adjustfname>
    <summary>
      从指定为字符串的文件名中删除空格。
    </summary>
    <param name="cFileName">您要调整的文件名。</param>
    <returns>
      删除所有空格后的 <paramref name="cFileName" />。
    </returns>
    <remarks>
    </remarks>
    <example>
      这个例子展示了 AdjustFName() 如何从文件名中删除空格而不影响原始文件名：
      <code language="X#">
        cFile := "  BadFileName    .DBF"
        ? AdjustFName(cFile)    // "BadFileName.DBF"
        ? cFile                 // "  BadFileName    .DBF"
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AdjustFNameA'>AdjustFNameA</seealso>
  </adjustfname>

  <adjustfnamea>
    <summary>
      从指定为字符串的文件名中删除空格，同时更改原始文件名的内容和返回的文件名。
    </summary>
    <param name="cFileName">您要调整的文件名。</param>
    <returns>
      删除所有空格后的 <paramref name="cFileName" />。
    </returns>
    <remarks>
      AdjustFNameA() 与 AdjustFName() 相同，但 AdjustFNameA() 不仅从返回值中删除空格，还会从原始文件名中删除空格。
    </remarks>
    <example>
      这个例子展示了 AdjustFNameA() 如何返回一个删除了空格的新文件名，并同时调整原始文件名：
      <code language="X#">
        cFile := "  BadFileName    .DBF"
        ? AdjustFNameA(cFile)   // "BadFileName.DBF"
        ? cFile                 // "BadFileName.DBF"
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AdjustFName'>AdjustFName</seealso>
  </adjustfnamea>

  <aeval>
    <summary>
      对数组中的每个元素执行代码块。
    </summary>
    <param name="aArray">要遍历的数组。</param>
    <param name="cbBlock">要执行的代码块。</param>
    <param name="nStart">
      起始元素。<br/>
      负值从末尾开始。<br/>
      如果 <paramref name="nCount" /> 为正，默认值为1；如果 <paramref name="nCount" /> 为负，默认值为数组的长度。
    </param>
    <param name="nCount">
      从 <paramref name="nStart" /> 开始处理的元素数。<br/>
      负值从末尾开始。<br/>
      默认为数组末尾的所有元素。
    </param>
    <returns>
      对 <paramref name="aArray" /> 的引用。<br/>
      代码块的返回值被忽略 — 要将返回值分配给数组中的每个元素，请使用 AEvalA() 函数。
    </returns>
    <remarks>
      AEval() 将元素值和元素索引作为参数传递。
      AEval() 不对它正在传递的数组元素的内容做任何假设。<br/>
      假定提供的代码块知道每个元素中将包含什么类型的数据。
      AEval() 类似于 DBEval()，后者为数据库文件的每条记录执行代码。<br/>
      像 DBEval() 一样，AEval() 可以用作构建简单和复杂数组结构的迭代命令的原语。
      <note type="tip">
        在 Visual Objects 2 中引入了两个不同的函数：AEval() 和 AEvalOld()。这些函数之间的区别在于 AEval() 只用一个参数（数组中的元素）调用代码块，而 AEvalOld() 还传入第二个参数（数组索引）。在 X# 中，这种区别不再存在。因此，在 X# 中 AEval() 和 AEvalOld() 做的是同样的事情。
      </note>
    </remarks>
    <example>
      这个例子显示一个一维数组的内容：
      <code language="X#">
        LOCAL aArray[6]
        AFill(aArray, "Hi All!") // 填充所有元素
        AEval(aArray, {|Element| QOut(Element)})
      </code>
      这个例子使用 AEval() 显示由 Directory() 函数返回的文件名和文件大小数组：
      <code language="X#">
        LOCAL aFiles := Directory("*.dbf")
        LOCAL nTotal := 0
        AEval(aFiles, {|aDBFFile | QOut(PadR(aDBFFile[F_NAME], 10), ;
        &#0009;&#0009;aDBFFile[F_SIZE], nTotal += aDBFFile[F_SIZE]})
        ? "Total bytes:", nTotal
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEvalA'>AEvalA</seealso>
    <seealso cref='O:XSharp.RT.Functions.AEvalOld'>AEvalOld</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanBinExact'>AScanBinExact</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanExact'>AScanExact</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbEval'>DBEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.QOut'>QOut</seealso>
    <seealso cref='O:XSharp.RT.Functions.SEval'>SEval</seealso>
  </aeval>

  <aevala>
    <summary>
      对数组中的每个元素执行代码块，并将返回值赋给数组中的每个元素。
    </summary>
    <param name="aArray">要遍历的数组。</param>
    <param name="cbBlock">要执行的代码块。</param>
    <param name="nStart">
      起始元素。<br/>
      负值从末尾开始。<br/>
      如果 <paramref name="nCount" /> 为正，默认值为1；如果 <paramref name="nCount" /> 为负，默认值为数组的长度。
    </param>
    <param name="nCount">
      从 <paramref name="nStart" /> 开始处理的元素数。<br/>
      负值从末尾开始。<br/>
      默认为到数组末尾的所有元素。
    </param>
    <returns>
      对 <paramref name="aArray" /> 的引用。
    </returns>
    <remarks>
      AEvalA() 与 AEval() 类似，它们都为数组的每个元素评估一次代码块，
      将元素值作为参数传递。<br/>
      不同之处在于，AEval() 忽略代码块的返回值，
      而 AEvalA() 将返回值赋给数组元素。<br/>
      详情请参见 AEval()。
    </remarks>
    <example>
      此示例使用 AEvalA() 创建一个小写文件名的数组：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL aFiles := Directory("*.dbf")
        &#0009;LOCAL nTotal AS SHORTINT
        &#0009;AEvalA(aFiles,{|aDBFFile| LOWER(PadR(aDBFFile[F_NAME], 10))})
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbEval'>DBEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.QOut'>QOut</seealso>
    <seealso cref='O:XSharp.RT.Functions.SEval'>SEval</seealso>
  </aevala>

  <aevalold>
    <summary>
      对数组中的每个元素执行代码块。
    </summary>
    <param name="aArray">要遍历的数组。</param>
    <param name="cbBlock">要执行的代码块。</param>
    <param name="nStart">
      起始元素<br/>
      负值从末尾开始。<br/>
      如果 <paramref name="nCount" /> 为正，默认值为1；如果 <paramref name="nCount" /> 为负，默认值为数组的长度。
    </param>
    <param name="nCount">
      从 <paramref name="nStart" /> 开始处理的元素数。<br/>
      负值从末尾开始。<br/>
      默认为到数组末尾的所有元素。
    </param>
    <returns>
      对 <paramref name="aArray" /> 的引用。<br/>
      代码块的返回值被忽略。<br/>
      要将代码块的返回值赋给数组中的每个元素，请使用 AEvalA() 函数。
    </returns>
    <remarks>
      AEvalOld() 将元素值和元素索引作为参数传递。<br/>
      AEvalOld() 不对它正在传递的数组元素的内容做任何假设。<br/>
      假定提供的代码块知道每个元素中将包含什么类型的数据。
      AEvalOld() 类似于 DBEval()，后者为数据库文件的每条记录执行代码。<br/>
      像 DBEval() 一样，AEvalOld() 可以用作构建简单和复杂数组结构的迭代命令的原语。
      <note type="tip">
        在 Visual Objects 2 中引入了两个不同的函数：AEval() 和 AEvalOld()。这些函数之间的区别在于 AEval() 只用一个参数（数组中的元素）调用代码块，而 AEvalOld() 还传入第二个参数（数组索引）。在 X# 中，这种区别不再存在。因此，在 X# 中 AEval() 和 AEvalOld() 做的是同样的事情。
      </note>
    </remarks>
    <example>
      此示例使用 AEvalOld() 显示由 Directory() 函数返回的文件名和文件大小数组：
      <code language="X#">
        LOCAL aFiles := Directory("*.dbf")
        LOCAL nTotal := 0
        AEvalOld(aFiles, {| aDBFFile | QOut(PadR(aDBFFile[F_NAME], 10), ;
        &#0009;&#0009;aDBFFile[F_SIZE]), aDBFFile[F_SIZE]), nTotal += aDBFFile[F_SIZE]})
        ? "总字节数:", nTotal
      </code>
      下一个示例根据条件更改数组元素的内容。<br/>
      如果条件为假，则仅显示数组元素。<br/>
      注意代码块参数的使用：
      <code language="X#">
        LOCAL aArray[6]
        AFill      (aArray, "old")
        AEvalOld   (aArray, {|cValue, nIndex| IF(cValue == "old",;
        ArrayPut (aArray, nIndex,"new"),QOut(cValue))})
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AEvalA'>AEvalA</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbEval'>DBEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.QOut'>QOut</seealso>
    <seealso cref='O:XSharp.RT.Functions.SEval'>SEval</seealso>
  </aevalold>

  <afields>
    <summary>
      用当前数据库文件的结构填充数组。
      注意：<br/>
      AFields() 是一个兼容性函数，因此不推荐使用。<br/>
      它已被 DBStruct() 取代，后者不需要在调用前存在任何数组，并返回一个包含当前数据库文件结构的多维数组。
    </summary>
    <param name="acFieldNames">要用字段名填充的数组。</param>
    <param name="acTypes">
      要用 <paramref name="acFieldNames" /> 中字段类型填充的数组。
    </param>
    <param name="anWidths">
      要用 <paramref name="acFieldNames" /> 中字段宽度填充的数组。
    </param>
    <param name="anDecimals">
      要用 <paramref name="acFieldNames" /> 中字段定义的小数位数填充的数组。<br/>
      如果字段类型不是数值型，系统将 0 赋给 <paramref name="anDecimals" />。
    </param>
    <returns>
      字段数量或最短数组参数的长度，以较小者为准。<br/>
      如果未指定参数，或当前工作区没有使用中的文件，AFields() 返回 0。
    </returns>
    <remarks>
      AFields() 用当前打开的数据库文件的结构填充一系列数组（结构属性数组），每个数组中每个字段对应一个元素。<br/>
      AFields() 的工作方式类似于 ADir()，用信息填充一系列现有数组。
      要使用 AFields()，你必须首先创建用于保存数据库结构信息的数组，每个数组的元素数量与字段数量相同（即 FCount()）。一旦结构属性数组存在，你就可以调用 AFields() 来用每个字段的信息填充它们。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      这个例子使用带别名表达式的 AFields() 来填充数组，其中包含在未选定工作区中打开的 SALES.DBF 的结构：
      <code language="X#">
        PROCEDURE Start()
        &#0009;LOCAL acFieldNames, aTypes, aWidths, ;
        &#0009;&#0009;&#0009;aDecimals AS ARRAY
        &#0009;USE sales NEW
        &#0009;USE customer NEW
        &#0009;acFieldNames := Sales-&gt;(ArrayNew(FCount()))
        &#0009;acTypes      := Sales-&gt;(ArrayNew(FCount()))
        &#0009;anWidths     := Sales-&gt;(ArrayNew(FCount()))
        &#0009;anDecimals   := Sales-&gt;(ArrayNew(FCount()))
        &#0009;Sales-&gt;(AFields(acFieldNames, acTypes, anWidths, anDecimals))
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ADir'>ADir</seealso>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScan'>AScan</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreate'>DBCreate</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbStruct'>DBStruct</seealso>
    <seealso cref='O:XSharp.RT.Functions.FCount'>FCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldName'>FieldName</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.RT.Functions.Type'>Type</seealso>
  </afields>

  <afill>
    <summary>
      用指定值填充数组元素。
    </summary>
    <param name="aTarget">要填充的数组。</param>
    <param name="uValue">要放入每个数组元素的值。</param>
    <param name="nStart">
      起始元素。<br/>
      负值从末尾开始。<br/>
      如果 <paramref name="nCount" /> 为正，默认值为 1；如果 <paramref name="nCount" /> 为负，默认值为数组长度。
    </param>
    <param name="nCount">
      从 <paramref name="nStart" /> 开始处理的元素数。<br/>
      负值从末尾开始。<br/>
      默认为直到数组末尾的所有元素。
    </param>
    <returns>
      <paramref name="aTarget" /> 的引用。
    </returns>
    <remarks>
      AFill() 通过将 <paramref name="uValue" /> 赋给指定范围内的每个数组元素，用任何数据类型的单一值填充指定数组。
      对多维数组使用 AFill 可能会覆盖用于数组其他维度的子数组。
    </remarks>
    <example>
      此示例创建一个3元素数组。<br/>
      然后用逻辑值 FALSE 填充数组。最后，将位置 2 和 3 的元素赋予新值 TRUE：
      <code language="X#">
        LOCAL aLogic[3]&#0009;&#0009;&#0009;// aLogic 为 {NIL, NIL, NIL}
        AFill(aLogic, FALSE)&#0009;&#0009;// aLogic 为 {FALSE, FALSE, FALSE}
        AFill(aLogic, TRUE, 2, 2)&#0009;&#0009;// aLogic 为 {FALSE, TRUE, TRUE}
      </code>
      此示例填充多维数组的各个行：
      <code language="X#">
        LOCAL a2[3][3]&#0009;//一个2维数组
        AFill(a2[1], "One")
        AFill(a2[2], "Two")
        AFill(a2[3], "Three")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AAdd'>AAdd</seealso>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AReplicate'>AReplicate</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbStruct'>DBStruct</seealso>
    <seealso cref='O:XSharp.RT.Functions.Directory'>Directory</seealso>
  </afill>

  <ains>
    <summary>
      在数组中插入一个元素并将其赋值为 NIL。
    </summary>
    <param name="aTarget">要插入元素的数组。</param>
    <param name="dwPosition">要插入元素的位置。</param>
    <returns>
      对 <paramref name="aTarget" /> 的引用。
    </returns>
    <remarks>
      AIns() 在指定数组中插入一个新元素。<br/>
      新插入的元素为 NIL，直到为其赋予新值。<br/>
      插入后，数组中的最后一个元素被丢弃，新元素之后的所有元素向下移动一个位置。
      &#0009;在多维数组中使用 AIns() 时必须小心。<br/>
      在多维数组中使用 AIns() 会丢弃指定目标数组中的最后一个元素，如果它是一个数组元素，将导致一个或多个维度丢失。<br/>
      要在数组中插入新维度，请先使用 AAdd() 或 ASize() 在数组末尾添加新元素，然后再使用 AIns()。
    </remarks>
    <example>
      此示例演示了在数组上使用 AIns() 的效果：
      <code language="X#">
        LOCAL aArray AS ARRAY
        aArray := {1, 2, 3}&#0009;&#0009;&#0009;// aArray 现在是 {1, 2, 3}
        AIns(aArray, 2)&#0009;&#0009;&#0009;// aArray 现在是 {1, NIL, 2}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AAdd'>AAdd</seealso>
    <seealso cref='O:XSharp.RT.Functions.ACopy'>ACopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.ADel'>ADel</seealso>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval </seealso>
    <seealso cref='O:XSharp.RT.Functions.AFill'>AFill</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASize'>ASize</seealso>
  </ains>

  <alen>
    <summary>
      返回数组中元素的数量。
    </summary>
    <param name="aTarget">要计数的数组。</param>
    <returns>
      数组中的元素数量。<br/>
      如果数组为空，ALen() 返回 0。
    </returns>
    <remarks>
      如果数组是多维的，子数组算作一个元素。<br/>
      这意味着多维数组的 ALen() 仅返回第一维的长度。<br/>
      要确定其他维度中的元素数量，请对子数组使用 ALen()，如下面的示例所示。（注意，X# 中的多维数组不需要具有统一的维度。）
    </remarks>
    <example>
      此示例创建一个字面量二维数组，然后返回数组和包含在数组第一个元素中的子数组的元素数量：
      <code language="X#">
        LOCAL aArray := {{1, 2}, {1, 2}, {1, 2}}
        ? ALen(aArray)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 3
        ? ALen(aArray[1])&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 2
      </code>
      此示例使用 ALen() 遍历多维数组：
      <code language="X#">
        LOCAL aArray := {{1, 2}, {1, 2}, {1, 2}}
        LOCAL nRow, nColumn AS SHORTINT
        LOCAL nRowCount, nColumnCount AS SHORTINT
        nRowCount = ALen(aArray)
        FOR nRow := 1 UPTO nRowCount
        &#0009;nColumnCount = ALen(aArray[nRow])
        &#0009;FOR nColumn := 1 UPTO nColumnCount
        &#0009;&#0009;? nRow, nColumn, aArray[nRow][nColumn]
        &#0009;NEXT
        NEXT
      </code>
      在此示例中，函数返回一个描述多维数组维度的数值数组。<br/>
      该函数假设数组具有统一的维度：
      <code language="X#">
        FUNCTION Dimensions(aArray)
        &#0009;LOCAL aDims := {}
        &#0009;DO WHILE IsArray(aArray)
        &#0009;&#0009;AADD(aDims, ALen(aArray))
        &#0009;&#0009;aArray := aArray[1]
        &#0009;ENDDO
        &#0009;RETURN (aDims)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AAdd'>AAdd</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASize'>ASize</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
  </alen>

  <alias>
    <summary>
      返回指定工作区的别名作为字符串。
    </summary>
    <param name="uWorkArea">
      任何工作区名称或编号。<br/>
      如果未指定，则返回当前工作区的别名。
    </param>
    <returns>
      如果没有正在使用的数据库文件，Alias() 返回一个 NULL_STRING。
    </returns>
    <remarks>
      Alias() 是 Select() 的反向操作。Alias() 根据工作区编号返回别名，而 Select() 根据别名返回工作区编号。
    </remarks>
    <example>
      此示例返回先前选择的工作区的名称：
      <code language="X#">
        USE file1 NEW ALIAS Test1
        nOldArea := Select()
        USE file2 NEW ALIAS Test2
        QOut(Alias(nOldArea))&#0009;&#0009;&#0009;// 返回: Test1
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias0'>Alias0</seealso>
    <seealso cref='O:XSharp.RT.Functions.Alias0Sym'>Alias0Sym</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSelect'>DBSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbAlias'>VODBAlias</seealso>
  </alias>

  <alias0>
    <summary>
      返回当前工作区的别名作为字符串。
    </summary>
    <returns>
      如果没有正在使用的数据库文件，Alias0() 返回一个 NULL_STRING。
    </returns>
    <remarks>
      Alias0() 与 Alias() 相同，只是 Alias0() 不接受任何参数。（这由函数名中的"0"表示。）<br/>
      因此，当不需要参数时，应使用 Alias0() 而不是 Alias() 以提高程序效率。
      <br/>
      此示例返回当前工作区的名称：
      <code language="X#">
        USE file1 NEW ALIAS Test1
        QOut(Alias0())&#0009;&#0009;// 返回: Test1
      </code>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias'>Alias</seealso>
    <seealso cref='O:XSharp.RT.Functions.Alias0Sym'>Alias0Sym</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSelect'>DBSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbAlias'>VODBAlias</seealso>
  </alias0>

  <alias0sym>
    <summary>
      返回当前工作区的别名作为符号。
    </summary>
    <returns>
      如果当前工作区没有正在使用的数据库文件，Alias0Sym() 返回一个 NULL_SYMBOL。
    </returns>
    <remarks>
      Alias0Sym() 与 Alias0() 相同，只是它返回别名作为符号。
      <br/>
      此示例返回当前工作区的名称：
      <code language="X#">
        USE mydbf
        QOut(Alias0Sym())&#0009;&#0009;&#0009;// 返回: "MYDBF"
        QOut(Alias0Sym() = #MYDBF)&#0009;&#0009;// 返回: TRUE
      </code>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias'>Alias</seealso>
    <seealso cref='O:XSharp.RT.Functions.Alias0'>Alias0</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbAliasSym'>VODBAliasSym</seealso>
  </alias0sym>

  <alltrim>
    <summary>
      从字符串中删除前导和尾随空格。
    </summary>
    <param name="cString">要修剪的字符串。</param>
    <returns>
      修剪后的字符串，已删除前导和尾随空格。
    </returns>
    <remarks>
      AllTrim() 与 LTrim() 和 RTrim() 相关，它们分别删除前导和尾随空格。<br/>
      AllTrim()、LTrim() 和 RTrim() 的反向操作是 PadC()、PadL() 和 PadR() 函数，它们通过用填充字符填充字符串来使其居中、左对齐和右对齐。
    </remarks>
    <example>
      此示例创建一个带有前导和尾随空格的字符串，然后使用 AllTrim() 修剪它们：
      <code language="X#">
        LOCAL cString AS STRING
        cString := SPACE(10) + "string" + SPACE(10)
        ? SLen(cString)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 26
        ? SLen(ALLTRIM(cString))&#0009;&#0009;&#0009;&#0009;&#0009;// 6
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadC'>PadC</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadL'>PadL</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadR'>PadR</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.Trim'>Trim</seealso>
  </alltrim>

  <altd>
    <summary>
      在应用程序中以编程方式定义断点。
    </summary>
    <remarks>
      AltD() 仅在应用程序由调试器执行时才起作用。
    </remarks>
    <example>
      此示例展示如何使用 AltD() 在函数中定义断点：
      <code language="X#">
        FUNCTION Bad()
        &#0009;...
        &#0009;AltD()&#0009;&#0009;&#0009;// 编程断点
        &#0009;...
        &#0009;RETURN Value
      </code>
    </example>
  </altd>

  <ampm>
    <summary>
      将24小时制军用时间转换为12小时制时间。
    </summary>
    <param name="c24HrTime">有效的军用时间格式为 hh:mO:ss，其中 hh 是24小时制的小时，mm 是分钟，ss 是秒。</param>
    <returns>
      一个11字符长的字符串，以12小时制格式表示，带有"am"或"pm"。<br/>
      如果 <paramref name="cTime" /> 不代表有效的军用时间，则返回 NULL_STRING。
    </returns>
    <remarks>
    </remarks>
    <example>
      这些示例使用 AmPm()：
      <code language="X#">
        ? AmPm("10:45:23")&#0009;&#0009;&#0009;&#0009;// 10:45:23 am
        ? AmPm("22:45:23")&#0009;&#0009;&#0009;&#0009;// 10:45:23 pm
        ? AmPm("10:45:23Hello")&#0009;&#0009;&#0009;// NULL_STRING
        ? AmPm("1045")&#0009;&#0009;&#0009;&#0009;&#0009;// NULL_STRING
        ? AmPm("10:45")&#0009;&#0009;&#0009;&#0009;&#0009;// NULL_STRING
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
  </ampm>

  <ansi2oem>
    <summary>
      将ANSI字符串转换为OEM字符串。
    </summary>
    <param name="cAnsiString">ANSI字符源字符串。</param>
    <returns>
      转换后的OEM字符串。
    </returns>
    <remarks>
      Ansi2Oem() 将源字符串中的各个字符转换为OEM字符集中的匹配字符。<br/>
      这可能是必要的，因为某些符号（如ä）在ANSI和OEM字符集中有不同的代码值。DOS应用程序在创建包含ä的文件名时使用OEM代码值，并在目录项中放置132。但Windows应用程序使用ANSI代码值，ä对应228，因此无法找到该文件。<br/>
      为解决这个问题，您可以使用Ansi2Oem()将ANSI文件名转换为OEM字符集。
      此外，如果Windows应用程序写入文件的字符是ANSI字符集，当DOS应用程序读取文件时可能会出现相同的字符转换问题。
    </remarks>
    <example>
      这个例子将字符串"aá.TXT"写入DOS文件。注意，á在ANSI字符集中的代码值为225，而在OEM字符集中，代码值225对应ß字符。<br/>
      FWrite()函数假定为原始二进制数据，因此不会自动将ANSI转换为OEM。（如果需要，您可以自己进行转换或使用其他函数，如FWriteText()。）
      <code language="X#">FWrite(ptrFileHandle, Ansi2Oem("aá.txt"))</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2OemA'>Ansi2OemA</seealso>
    <seealso cref='O:XSharp.RT.Functions.Ansi2OemBuff'>Ansi2OemBuff</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
  </ansi2oem>

  <ansi2oema>
    <summary>
      将ANSI字符串转换为OEM字符串，同时修改原始字符串的内容和返回的字符串。
    </summary>
    <param name="cAnsiString">ANSI字符源字符串。</param>
    <returns>
      转换后的OEM字符串。
    </returns>
    <remarks>
      Ansi2OemA() 与 Ansi2Oem() 功能相同，但 Ansi2OemA() 还会用OEM字符替换原始字符串的内容。
    </remarks>
    <example>
      这个例子将包含字符 ßä 的字符串从ANSI转换为OEM。
      <code language="X#">
        LOCAL cString AS STRING
        cString := "ßä"
        Ansi2OEMA(cString)&#0009;&#0009;// 将 ßä 转换为OEM
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.RT.Functions.Ansi2OemBuff'>Ansi2OemBuff</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2AnsiA'>Oem2AnsiA</seealso>
  </ansi2oema>

  <ansi2oembuff>
    <summary>
      将源缓冲区中指定数量的 ANSI 字符转换为相应的 OEM 字符缓冲区。
    </summary>
    <param name="pszTarget">指向将包含转换后字符串的缓冲区的指针。</param>
    <param name="pszSource">指向包含要转换字符串的缓冲区的指针。</param>
    <param name="dwCount">要转换的字符数。</param>
    <returns>
      指向包含转换后字符串的缓冲区的指针。
    </returns>
    <remarks>
      Ansi2OemBuff() 类似于 Ansi2Oem()，但结果字符串存储在 <paramref name="pszTarget" /> 指向的缓冲区中。<br/>
      此外，<paramref name="dwCount" /> 参数允许您指定要转换的字符数。
      <note type="tip">
        您负责为 <paramref name="pszTarget" /> 指向的缓冲区分配空间。<br/>
        使用未分配的缓冲区指针可能会产生不良后果。
      </note>
    </remarks>
    <example>
      此示例使用 Ansi2OemBuff() 将 ANSI 字符串 "ßä" 的内容转换为 OEM 字符集。注意，源字符串也用作目标字符串：
      <code language="X#">
        LOCAL cStr := "ßä"
        Ansi2OemBuff(PSZ(_CAST, cStr), PSZ(_CAST, cStr), SLen(cStr))
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.Core.Functions.Ansi2OemA'>Ansi2OemA</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2AnsiA'>Oem2AnsiA</seealso>
  </ansi2oembuff>

  <areplicate>
    <summary>
      创建一个数组并用默认值填充其元素。
    </summary>
    <param name="xFill">用于填充数组的值。</param>
    <param name="nElements">数组的大小。</param>
    <returns>
      一个长度为 <paramref name="nElements" /> 的数组，每个元素包含 <paramref name="xFill" />。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例创建一个包含 10 个元素的数组并用零填充：
      <code language="X#">aNewArray := AReplicate(0, 10)</code>
      此示例创建一个包含 5 个元素的数组并用 "Empty" 字符串填充：
      <code language="X#">aEmptyArray := AReplicate("Empty", 5)</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AClone'>AClone</seealso>
    <seealso cref='O:XSharp.RT.Functions.ACopy'>ACopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.AFill'>AFill</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayBuild'>ArrayBuild</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayCreate'>ArrayCreate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayInit'>ArrayInit</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayNew'>ArrayNew</seealso>
  </areplicate>

  <arraybuild>
    <summary>
      创建一个空数组。
    </summary>
    <returns>
      一个空数组。
    </returns>
    <remarks>
      ArrayBuild() 创建一个空数组。<br/>
      它是空数组赋值的函数形式，等同于：
      <code language="X#">aMyArray := {}</code>
      需要注意的是，在通用的 {} 中您可以列出其他值，而 ArrayBuild() 不接受任何参数。
      要创建指定长度的未初始化数组，请参见 ArrayCreate() 和 ArrayNew()。<br/>
      要创建已初始化的数组，请参见 ArrayInit()。
    </remarks>
    <example>
      此示例使用 ArrayBuild() 函数创建一个空数组，然后展示通过赋值字面量数组实现相同效果的方法：
      <code language="X#">
        aArray := ArrayBuild()
        aArray := {}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AReplicate'>AReplicate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayCreate'>ArrayCreate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayInit'>ArrayInit</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayNew'>ArrayNew</seealso>
  </arraybuild>

  <arraycreate>
    <summary>
      创建一个未初始化的一维数组。
    </summary>
    <param name="dwElements">数组中的元素数量。</param>
    <returns>
      一个未初始化的一维数组。
    </returns>
    <remarks>
      ArrayCreate() 返回一个只有一个维度的未初始化数组。<br/>
      要创建未初始化的多维数组，请参见 ArrayNew()。
    </remarks>
    <example>
      此示例使用 ArrayCreate() 创建一个包含五个元素的一维数组，然后展示通过赋值 NIL 值的字面量数组实现相同效果的方法：
      <code language="X#">
        LOCAL aArray AS ARRAY
        aArray := ArrayCreate(5)
        aArray := {NIL, NIL, NIL, NIL, NIL}
      </code>
      此示例创建一个数字数组并为元素赋值：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL aArray AS ARRAY
        &#0009;aArray := ArrayCreate(3)
        &#0009;ArrayPut(aArray, 1, 1)
        &#0009;ArrayPut(aArray, 2, 10)
        &#0009;ArrayPut(aArray, 3, 100)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AReplicate'>AReplicate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayBuild'>ArrayBuild</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayInit'>ArrayInit</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayNew'>ArrayNew</seealso>
  </arraycreate>

  <arraydeprotect>
    <summary>
      从整个数组中移除写保护。
    </summary>
    <param name="aTarget">要解除保护的数组。</param>
    <returns>
      如果数组成功解除保护则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      ArrayDeprotect() 移除由 ArrayProtect() 函数对数组施加的保护，允许更改其值。
    </remarks>
    <example>
      此示例将值存储到数组元素中，保护这些元素，然后移除保护以便可以更改它们：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL aWriteProtect AS ARRAY
        &#0009;aWriteProtect := ArrayCreate(2)
        &#0009;ArrayPut(aWriteProtect, 1, "Origin")
        &#0009;ArrayPut(aWriteProtect, 2, "Origin")
        &#0009;ArrayProtect(aWriteProtect)
        &#0009;// 在调用函数中允许写入
        &#0009;ArrayPut(aWriteProtect, 1, "Main Function")
        &#0009;// 在被调用函数中不允许写入
        &#0009;TryChange(aWriteProtect)
        &#0009;ArrayDeprotect(aWriteProtect)
        &#0009;// 允许写入（无保护）
        &#0009;TryChange(aWriteProtect)
        FUNCTION TryChange(aPassed)
        &#0009;ArrayPut(aPassed, 1, "Sub Function")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ArrayProtect'>ArrayProtect</seealso>
  </arraydeprotect>

  <arrayget>
    <summary>
      读取数组元素。
    </summary>
    <param name="aTarget">要读取的数组。</param>
    <param name="dwElement">要读取的元素编号。</param>
    <returns>
      该元素所包含的值。
    </returns>
    <remarks>
      ArrayGet() 读取并返回数组元素的值。
    </remarks>
    <example>
      此示例创建一个数组并打印其值：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL aStates[3]
        &#0009;LOCAL i AS SHORTINT
        &#0009;ArrayPut(aStates, 1, "蒙大拿")
        &#0009;ArrayPut(aStates, 2, "怀俄明")
        &#0009;ArrayPut(aStates, 3, "爱达荷")
        &#0009;FOR i := 1 UPTO ALen(aStates)
        &#0009;&#0009;QOut(ArrayGet(aStates, i))
        &#0009;NEXT
        &#0009;// 以下我们用两种不同的方式打印相同的数组：
        &#0009;// FOR...NEXT 的函数等效形式
        &#0009;AEval(aStates, {|Element| QOut(Element)})
        &#0009;// 使用 [] 获取数组元素
        &#0009;FOR i := 1 UPTO ALen(aStates)
        &#0009;&#0009;QOut(aStates[i])
        &#0009;NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ArrayPut'>ArrayPut</seealso>
  </arrayget>

  <arrayinit>
    <summary>
      创建一个已初始化的数组。
    </summary>
    <param name="wElements">元素数量。</param>
    <param name="aValues">用于初始化数组的数据</param>
    <returns>
      一个已初始化的数组，具有指定数量的元素，每个元素中包含引用的值。
    </returns>
    <remarks>
      ArrayInit() 构建一个具有指定元素数量的数组，并使用指针内容初始化这些元素。<br/>
      在 <paramref name="" /> 引用的位置必须至少有 <paramref name="wElements" /> 个 USUAL 类型的数据。<br/>
      要创建未初始化的数组，请参见 ArrayNew()。
    </remarks>
    <example>
      此示例创建并初始化一个包含2个元素的数组。<br/>
      一个现有的 DIM 数组作为初始化数据的指针：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL aOffsets AS ARRAY
        &#0009;LOCAL DIM aDimPoint[2] AS USUAL
        &#0009;aDimPoint[1] := "你好"
        &#0009;aDimPoint[2] := "世界！"
        &#0009;aOffsets := ArrayInit(2, @aDimPoint)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AReplicate'>AReplicate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayBuild'>ArrayBuild</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayCreate'>ArrayCreate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayNew'>ArrayNew</seealso>
  </arrayinit>

  <arraynew>
    <summary>
      创建具有指定元素数量和维度的未初始化数组。
    </summary>
    <param name="wElementList">
      表示每个维度中元素数量的逗号分隔列表。<br/>
      如果指定了多个元素数量，则会创建一个多维数组，维度数等于 <paramref name="wElementList" /> 中参数的数量。
    </param>
    <returns>
      具有指定维度的数组。
    </returns>
    <remarks>
      在 X# 中，有几种创建数组的方法：
      &#0009;使用声明语句（如 LOCAL 或 STATIC）声明数组。
      &#0009;使用 PRIVATE 或 PUBLIC 语句创建数组。
      &#0009;将字面量数组赋值给现有变量。
      &#0009;使用 ArrayNew() 函数。<br/>
      ArrayNew() 的优势在于它可以在表达式或代码块中创建数组。
      您还可以使用 ArrayBuild() 函数创建空数组，使用 ArrayCreate() 函数创建一维数组，或使用 ArrayInit() 创建已初始化的数组。
    </remarks>
    <example>
      此示例使用 ArrayNew() 函数创建一个包含五个元素的一维数组，然后展示了通过赋值 NIL 值的字面量数组实现相同操作的等效方式：
      <code language="X#">
        LOCAL aArray AS ARRAY
        aArray := ArrayNew(5)
        aArray := {NIL, NIL, NIL, NIL, NIL}
      </code>
      此示例展示了三种创建相同多维数组的不同语句：
      <code language="X#">
        aArray := ArrayNew(3, 2)
        aArray := {{NIL, NIL}, {NIL, NIL}, {NIL, NIL}}
        aArray := {ArrayCreate(2), ArrayCreate(2), ArrayCreate(2)}
      </code>
      此示例创建一个多维数组：
      <code language="X#">aArray := ArrayNew(3, 2, 5)</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AAdd'>AAdd</seealso>
    <seealso cref='O:XSharp.RT.Functions.AClone'>AClone</seealso>
    <seealso cref='O:XSharp.RT.Functions.ACopy'>ACopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.ADel'>ADel</seealso>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AFill'>AFill</seealso>
    <seealso cref='O:XSharp.RT.Functions.AIns'>AIns</seealso>
    <seealso cref='O:XSharp.RT.Functions.AReplicate'>AReplicate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayBuild'>ArrayBuild</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayCreate'>ArrayCreate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayInit'>ArrayInit</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScan'>AScan</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASize'>ASize</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASort'>ASort</seealso>
    <seealsocmd>LOCAL</seealsocmd>
    <seealsocmd>PRIVATE</seealsocmd>
    <seealsocmd>PUBLIC</seealsocmd>
    <seealsocmd>STATIC</seealsocmd>
  </arraynew>

  <arrayprotect>
    <summary>
      保护数组，使其在声明函数之外无法被修改。
    </summary>
    <param name="aTarget">要保护的数组。</param>
    <returns>
      如果数组成功被保护则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      ArrayProtect() 在为数组元素赋值后保护它们不被更改。<br/>
      声明该数组的函数仍然可以写入数组。
    </remarks>
    <example>
      此示例将值存储到数组元素中，保护这些元素，然后移除保护以便子函数可以更改它们：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL aWriteProtect AS ARRAY
        &#0009;aWriteProtect := ArrayCreate(2)
        &#0009;ArrayPut(aWriteProtect, 1, "原始")
        &#0009;ArrayPut(aWriteProtect, 2, "原始")
        &#0009;ArrayProtect(aWriteProtect)
        &#0009;// 在调用函数中允许写入
        &#0009;ArrayPut(aWriteProtect, 1, "主函数")
        &#0009;// 在被调用函数中不允许写入
        &#0009;TryChange(aWriteProtect)
        &#0009;ArrayDeprotect(aWriteProtect)
        &#0009;// 允许写入（无保护）
        &#0009;TryChange(aWriteProtect)
        FUNCTION TryChange(aPassed)
        &#0009;ArrayPut(aPassed, 1, "子函数")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ArrayDeProtect'>ArrayDeprotect</seealso>
  </arrayprotect>

  <arrayput>
    <summary>
      向数组元素写入值。
    </summary>
    <param name="aTarget">要写入的数组。</param>
    <param name="dwElement">要接收值的数组元素编号。</param>
    <param name="uValue">要写入数组元素的值。</param>
    <returns>
      被赋予的值。
    </returns>
    <remarks>
      ArrayPut() 向指定的数组元素写入值。<br/>
      如果该元素已有值，则会被覆盖。
    </remarks>
    <example>
      此示例向数组元素写入值：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL aStates[2]
        &#0009;ArrayPut(aStates, 1, "蒙大拿")
        &#0009;ArrayPut(aStates, 2, "怀俄明")
        &#0009;// 以下我们使用 [] 实现相同的结果
        &#0009;aStates[1] := "蒙大拿"
        &#0009;aStates[2] := "怀俄明"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ArrayGet'>ArrayGet</seealso>
  </arrayput>

  <arraystore>
    <summary>
      将数组存储到缓冲区。
    </summary>
    <param name="aSource">要存储到缓冲区的数组。</param>
    <param name="Buff">指向缓冲区的指针。</param>
    <param name="dwLen">缓冲区的长度。</param>
    <returns>
      存储到缓冲区的字节数。
    </returns>
    <remarks>
      将数组的内容存储到由 <paramref name="Buff" /> 指向的缓冲区中。在写入之前，您应确保缓冲区已分配且足够大。
    </remarks>
    <example>
      此示例将数组的元素值写入缓冲区。<br/>
      一个 DIM 数组作为目标指针：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL DIM aDestination[4] AS USUAL
        &#0009;LOCAL aList[4]
        &#0009;ArrayPut(aList, 1, 1)
        &#0009;ArrayPut(aList, 2, 3)
        &#0009;ArrayPut(aList, 3, 5)
        &#0009;ArrayPut(aList, 4, 7)
        &#0009;ArrayStore(aList, @aDestination, 4*6)
        &#0009;? aDestination[1]&#0009;&#0009;// Result: 1
        &#0009;? aDestination[2]&#0009;&#0009;// Result: 3
        &#0009;? aDestination[3]&#0009;&#0009;// Result: 5
        &#0009;? aDestination[4]&#0009;&#0009;// Result: 7
      </code>
    </example>
  </arraystore>

  <arrayswap>
    <summary>
      替换数组元素的值并返回原值。
    </summary>
    <param name="aTarget">要替换元素值的数组。</param>
    <param name="dwElement">要替换的元素编号。</param>
    <param name="uNewValue">新值。</param>
    <returns>
      被 <paramref name="uNewValue" /> 替换的原值。
    </returns>
    <remarks>
      ArraySwap() 用新值替换指定的数组元素。
    </remarks>
    <example>
      此示例交换数组的第二个和第三个元素：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL aList[4]
        &#0009;ArrayPut(aList, 1, "First")
        &#0009;ArrayPut(aList, 2, "Second")
        &#0009;ArrayPut(aList, 3, "Third")
        &#0009;ArrayPut(aList, 4, "Fourth")
        &#0009;aList[3] := ArraySwap(aList, 2, aList[3])
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ArrayPut'>ArrayPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.ArrayGet'>ArrayGet</seealso>
  </arrayswap>

  <asc>
    <summary>
      将字符转换为其 ASCII 值。
    </summary>
    <param name="cString">要转换为数字的字符。</param>
    <returns>
      一个从 0 到 255 的数字，表示 <paramref name="cString" /> 的 ASCII 码。
    </returns>
    <remarks>
      Asc() 是一个字符转换函数，它返回字符串中最左侧字符的 ASCII 值。<br/>
      Asc() 主要用于需要对字符的 ASCII 值进行数值计算的表达式。Chr() 和 Asc() 是互逆函数。
    </remarks>
    <example>
      以下示例展示了 Asc() 的各种结果：
      <code language="X#">
        ? Asc("A")&#0009;&#0009;&#0009;&#0009;// 65
        ? Asc("Apple")&#0009;&#0009;&#0009;&#0009;// 65
        ? Asc("a")&#0009;&#0009;&#0009;&#0009;&#0009;// 97
        ? Asc("Z") - Asc("A")&#0009;&#0009;// 25
        ? Asc(NULL_STRING)&#0009;&#0009;&#0009;// 0
        ? Asc(Chr(0))&#0009;&#0009;&#0009;&#0009;// 0
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Chr'>Chr</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Val'>Val</seealso>
  </asc>

  <ascan>
    <summary>
      扫描数组直到找到一个值或代码块返回 TRUE。
    </summary>
    <param name="aTarget">要扫描的数组。</param>
    <param name="uSearch">
      要扫描的值。<br/>
      除非此参数是代码块，否则它必须与 <paramref name="aTarget" /> 中元素的数据类型匹配。
    </param>
    <param name="nStart">
      起始元素。<br/>
      负值从末尾开始。<br/>
      如果 <paramref name="nCount" /> 为正，默认值为1；如果 <paramref name="nCount" /> 为负，默认值为数组的长度。
    </param>
    <param name="nCount">
      从 <paramref name="nStart" /> 开始处理的元素数。<br/>
      负值从末尾开始。<br/>
      默认为数组末尾的所有元素。
    </param>
    <returns>
      如果 <paramref name="uSearch" /> 是代码块，AScan() 返回代码块返回 TRUE 的第一个元素的位置。<br/>
      否则，AScan() 返回第一个匹配元素的位置。<br/>
      如果未找到匹配项，AScan() 返回 0。
    </returns>
    <remarks>
      如果 <paramref name="uSearch" /> 不是代码块，其值会与第一个目标元素比较。<br/>
      如果不匹配，AScan() 继续处理数组中的下一个元素。<br/>
      此过程持续进行，直到找到匹配项或扫描范围内的元素耗尽。<br/>

      如果 <paramref name="uSearch" /> 是代码块，AScan() 扫描 <paramref name="aTarget" />，对每个访问的元素执行代码块。<br/>
      每遇到一个元素，AScan() 将元素的值作为参数传递给代码块，然后对代码块执行 Eval()。<br/>
      当代码块返回 TRUE 或扫描范围内的元素耗尽时，扫描操作停止。
      注意：值的比较使用 = 运算符。<br/>
      对于精确匹配（即使用 == 运算符），请使用 AScanExact()。
    </remarks>
    <example>
      此示例演示了扫描一个3元素数组，同时使用字符串和代码块作为搜索条件。<br/>
      代码块条件展示了如何执行不区分大小写的搜索：
      <code language="X#">
        aArray := {"Tom", "Mary", "Sue"}
        ? AScan(aArray, "Mary")&#0009;&#0009;&#0009;&#0009;// 2
        ? AScan(aArray, "mary")&#0009;&#0009;&#0009;&#0009;// 0
        ? AScan(aArray, ;
        &#0009;&#0009;{|x| Upper(x) = "MARY"})&#0009;// 2
      </code>
      此示例演示了在找到匹配项后扫描搜索参数的多个实例：
      <code language="X#">
        LOCAL aArray := {"Tom", "Mary", "Sue", "Mary"}
        LOCAL nStart := 1
        LOCAL iAtEnd, iPos AS INT
        // 获取数组最后一个元素的位置
        iAtEnd := 4
        DO WHILE (iPos := AScan(aArray, "Mary", nStart)) &gt; 0
        &#0009;? iPos, aArray[iPos]
        &#0009;// 获取新的起始位置并测试边界条件
        &#0009;IF (nStart += iPos) &gt; iAtEnd
        &#0009;&#0009;EXIT
        &#0009;ENDIF
        ENDDO
      </code>
      此示例使用代码块扫描二维数组。注意，代码块中的参数 aVal 是一个数组：
      <code language="X#">
        LOCAL aArr := {}
        AAdd(aArr,{"one", "two"})
        AAdd(aArr,{"three", "four"})
        AAdd(aArr,{"five", "six"})
        ? AScan(aArr, {|aVal| aVal[2] = "four"})&#0009;&#0009;// 2
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanBin'>AScanBin</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanBinExact'>AScanBinExact</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanExact'>AScanExact</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
  </ascan>

  <ascanbin>
    <summary>
      扫描已排序的数组，直到找到一个值或代码块返回0。
    </summary>
    <param name="aTarget">要扫描的已排序数组。</param>
    <param name="uSearch">
      要扫描的值。<br/>
      除非此参数是代码块，否则它必须与<paramref name="aTarget" />中元素的数据类型匹配。<br/>
      如果<paramref name="uSearch" />是代码块，它应返回一个数值，表示比较的结果：正值表示<paramref name="uSearch" />大于当前数组元素，0表示相等，负值表示<paramref name="uSearch" />小于当前数组元素。
    </param>
    <returns>
      如果<paramref name="uSearch" />是代码块，AScanBin()在代码块返回零值时返回元素的位置。<br/>
      否则，AScanBin()返回匹配元素的位置。<br/>
      如果存在多个相同的元素，由于AScanBin()使用二分查找算法，返回的匹配项不一定是编号最小的元素。<br/>
      如果未找到匹配项，AScanBin()返回0。
    </returns>
    <remarks>
      AScanBin()扫描数组以查找指定值。
      如果<paramref name="uSearch" />是代码块，AScanBin()使用二分查找算法扫描<paramref name="aTarget" />，并对每个访问的元素执行代码块。<br/>
      每遇到一个元素，AScanBin()将元素的值作为参数传递给代码块，然后对代码块执行Eval()。<br/>
      当代码块返回零值或扫描范围内的元素耗尽时，扫描操作停止。
      注意：值的比较使用=运算符。<br/>
      对于精确匹配（即使用==运算符），请使用AScanBinExact()。
    </remarks>
    <example>
      此示例演示了使用字符串和代码块作为搜索条件扫描3元素数组。<br/>
      代码块条件展示了如何执行不区分大小写的搜索：
      <code language="X#">
        aArray := {"Tom", "Mary", "Sue"}
        ASort(aArray)
        ? AScanBin(aArray, "Mary")&#0009;&#0009;&#0009;&#0009;// 1
        ? AScanBin(aArray, "mary")&#0009;&#0009;&#0009;&#0009;// 0
        ? AScanBin(aArray, ;
        &#0009;&#0009;{|x| MyCompare(x, "MARY")})&#0009;&#0009;// 1
        FUNCTION MyCompare(cElement, cSearch) AS SHORTINT
        &#0009;LOCAL siRet := 0 AS SHORTINT
        &#0009;cElement := Upper(cElement)
        &#0009;IF cSearch &gt; cElement
        &#0009;&#0009;siRet := 1
        &#0009;ELSEIF cSearch &lt; cElement
        &#0009;&#0009;siRet := -1
        &#0009;&#0009;// ELSE默认为初始值0
        &#0009;ENDIF
        &#0009;RETURN siRet
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScan'>AScan</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanBinExact'>AScanBinExact</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanExact'>AScanExact</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
  </ascanbin>

  <ascanbinexact>
    <summary>
      扫描已排序的数组，直到找到一个精确匹配或代码块返回0。
    </summary>
    <param name="aTarget">要扫描的已排序数组。</param>
    <param name="uSearch">
      要扫描的值。<br/>
      除非此参数是代码块，否则它必须与<paramref name="aTarget" />中元素的数据类型匹配。<br/>
      如果<paramref name="uSearch" />是代码块，它应返回一个数值，表示比较的结果：正值表示<paramref name="uSearch" />大于当前数组元素，0表示相等，负值表示<paramref name="uSearch" />小于当前数组元素。
    </param>
    <returns>
      如果<paramref name="uSearch" />是代码块，AScanBinExact()在代码块返回零值时返回元素的位置。<br/>
      否则，AScanBinExact()返回精确匹配元素的位置。<br/>
      如果存在多个相同的元素，由于AScanBinExact()使用二分查找算法，返回的精确匹配项不一定是编号最小的元素。<br/>
      如果未找到精确匹配项，AScanBinExact()返回0。
    </returns>
    <remarks>
      AScanBinExact()与AScanBin()相同，只是使用==进行匹配而不是=。
    </remarks>
    <example>
      此示例展示了AScanBinExact()和AScanBin()之间的区别：
      <code language="X#">
        aArray := {"Larger", "Largest"}&#0009;// 已排序
        ? "Larger" = "Large"&#0009;&#0009;&#0009;// TRUE
        ? "Larger" == "Large"&#0009;&#0009;&#0009;// FALSE
        ? AScanBin(aArray, "Large")&#0009;&#0009;// 1
        ? AScanBinExact(aArray, "Large")&#0009;// 0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScan'>AScan</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanBin'>AScanBin</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
  </ascanbinexact>

  <ascanexact>
    <summary>
      扫描数组直到找到精确匹配或代码块返回TRUE。
    </summary>
    <param name="aTarget">要扫描的数组。</param>
    <param name="uSearch">
      要扫描的值。<br/>
      除非此参数是代码块，否则它必须与<paramref name="aTarget" />中元素的数据类型匹配。
    </param>
    <param name="nStart">
      起始元素。<br/>
      负值从末尾开始。<br/>
      如果<paramref name="nCount" />为正，默认值为1；如果<paramref name="nCount" />为负，默认值为数组长度。
    </param>
    <param name="nCount">
      从<paramref name="nStart" />开始处理的元素数量。<br/>
      负值从末尾开始。<br/>
      默认为到数组末尾的所有元素。
    </param>
    <returns>
      如果<paramref name="uSearch" />是代码块，AScanExact()在代码块返回TRUE时返回元素的位置。<br/>
      否则，AScanExact()返回第一个精确匹配元素的位置。<br/>
      如果未找到精确匹配，AScanExact()返回0。
    </returns>
    <remarks>
      AScanExact()与AScan()相同，只是使用==进行匹配而不是=。
    </remarks>
    <example>
      此示例展示了AScanExact()和AScan()之间的区别：
      <code language="X#">
        aArray := {"Larger", "Large"}
        ? "Larger" = "Large"&#0009;&#0009;&#0009;// TRUE
        ? "Larger" == "Large"&#0009;&#0009;&#0009;// FALSE
        ? AScan(aArray, "Large")&#0009;&#0009;&#0009;// 1
        ? AScanExact(aArray, "Large")&#0009;&#0009;// 2
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScan'>AScan</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanBin'>AScanBin</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
  </ascanexact>

  <asend>
    <summary>
      对数组中的每个对象元素调用一个方法。
    </summary>
    <param name="aTarget">要处理的数组。</param>
    <param name="symMethod">方法名称，指定时不带括号。</param>
    <param name="MethodArgList">
      传递给<paramref name="symMethod" />的参数列表，以逗号分隔。
    </param>
    <returns>
      对<paramref name="aTarget" />的引用。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例向对象数组发送一个简单消息进行评估。<br/>
      每个元素对象依次评估该消息：
      <code language="X#">
        CLASS Greet
        METHOD Salut(cRest) CLASS Greet
        &#0009;? "Hello", cRest
        &#0009;RETURN
        END CLASS
        FUNCTION Start()
        &#0009;LOCAL oAlpha, oBeta, oGamma, oDelta, oEpsilon ;
        &#0009;&#0009;AS OBJECT
        &#0009;LOCAL aBunch AS ARRAY
        &#0009;oAlpha   := Greet{}
        &#0009;oBeta    := Greet{}
        &#0009;oGamma   := Greet{}
        &#0009;oDelta   := Greet{}
        &#0009;oEpsilon := Greet{}
        &#0009;aBunch := {oAlpha, oBeta, oGamma, oDelta, oEpsilon}
        &#0009;ASend(aBunch, #Salut, "world")
        &#0009;// 等效输出
        &#0009;AEval(aBunch, {|aTemp| aTemp:Salut("world")})
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.Send'>Send</seealso>
  </asend>

  <ashexstring>
    <summary>
      将值转换为十六进制字符串。
    </summary>
    <param name="uValue">任何类型的值。</param>
    <returns>
      表示输入值的十六进制字符串。
    </returns>
    <remarks>
      AsHexString() 函数可以处理各种数据类型，并返回其十六进制表示。
    </remarks>
    <example>
      此示例使用 AsHexString() 显示不同表达式的十六进制转储：
      <code language="X#">
        LOCAL cAlpha AS STRING
        LOCAL siSum AS SHORTINT
        cAlpha := "ABCDEF"
        siSum := 100
        ? AsHexString(cAlpha)&#0009;&#0009;// 41 42 43 44 45 46
        ? AsHexString(siSum)&#0009;&#0009;// 00000064
        ? AsHexString("abcdef")&#0009;&#0009;// 61 62 63 64 65 66
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsSymbol'>AsSymbol</seealso>
  </ashexstring>

  <asize>
    <summary>
      增大或缩小数组。
    </summary>
    <param name="aTarget">要增大或缩小的数组。</param>
    <param name="dwLength">数组的新大小。</param>
    <returns>
      对 <paramref name="aTarget" /> 的引用。
    </returns>
    <remarks>
      ASize() 改变 <paramref name="aTarget" /> 的实际长度。<br/>
      数组会被缩短或延长以匹配指定的长度。<br/>
      如果数组被缩短，数组末尾的元素将丢失。<br/>
      如果数组被延长，新元素会被添加到数组末尾并赋值为 NIL。
      ASize() 类似于 AAdd()，后者向数组末尾添加单个新元素，并可同时选择性地赋予新值。注意，ASize() 与 AIns() 和 ADel() 不同，后两者实际上不改变数组的长度。
    </remarks>
    <example>
      这些示例演示了添加新元素和删除现有元素：
      <code language="X#">
        LOCAL aArray AS ARRAY
        aArray := {1}&#0009;&#0009;&#0009;// aArray 是 {1}
        ASize(aArray, 3)&#0009;&#0009;// aArray 是 {1, NIL, NIL}
        ASize(aArray, 1)&#0009;&#0009;// aArray 是 {1}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AAdd'>AAdd</seealso>
    <seealso cref='O:XSharp.RT.Functions.ADel'>ADel</seealso>
    <seealso cref='O:XSharp.RT.Functions.AFill'>AFill</seealso>
    <seealso cref='O:XSharp.RT.Functions.AIns'>AIns</seealso>
  </asize>

  <asort>
    <summary>
      对数组进行排序。
    </summary>
    <param name="aTarget">要排序的数组。</param>
    <param name="nStart">
      起始元素。<br/>
      默认值为1。
    </param>
    <param name="nCount">
      从 <paramref name="nStart" /> 开始处理的元素数量。<br/>
      默认为处理到数组末尾的所有元素。
    </param>
    <param name="cbOrder">
      用于确定排序顺序的代码块。<br/>
      此参数用于将排序顺序更改为降序或字典顺序。<br/>
      每次评估时，目标数组中的两个元素都会作为参数传递。<br/>
      如果元素按排序顺序排列，代码块返回 TRUE。请参见下面的示例。<br/>

      &#0009;默认排序顺序为升序：<br/>

      &#0009;&#0009;低值元素排在数组开头（第一个元素）。<br/>

      &#0009;&#0009;高值元素排在数组末尾（最后一个元素）
    </param>
    <returns>
      对 <paramref name="aTarget" /> 的引用。
    </returns>
    <remarks>
      ASort() 对数组的全部或部分进行排序。<br/>
      数组可以包含混合类型的 USUAL。<br/>
      可以排序的数据类型包括字符、日期、逻辑和数值。
      字符串按 ASCII 顺序排序；逻辑值排序时 FALSE 为低值；日期值按时间顺序排序；数值按大小排序。
      &#0009;ASort() 不会直接对多维数组进行排序。<br/>
      要对多维数组进行排序，您必须提供一个能正确处理子数组的代码块。
    </remarks>
    <example>
      此示例创建一个包含五个未排序元素的数组，先按升序排序，然后使用代码块按降序排序：
      <code language="X#">
        aArray := {3, 5, 1, 2, 4}
        ASort(aArray)&#0009;&#0009;&#0009;&#0009;&#0009;// {1, 2, 3, 4, 5}
        ASort(aArray,,, {|x, y| x &gt;= y})&#0009;// {5, 4, 3, 2, 1}
      </code>
      此示例对混合类型数组进行排序。
      <code language="X#">
        LOCAL  a := {"Z", "A", "one", 2, 1, "Three"}
        ASort(a)
      </code>
      此示例按升序对字符串数组进行排序，不区分大小写。<br/>
      它通过使用在比较前将元素转换为大写的代码块来实现这一点：
      <code language="X#">
        aArray := {"Fred", "Kate", "ALVIN", "friend"}
        ASort(aArray,,, {|x, y| Upper(x) &lt;= Upper(y)})&#0009;// {ALVIN, FRED, FRIEND, KATE}
      </code>
      此示例使用每个子数组的第二个元素对多维数组进行排序：
      <code language="X#">
        aKids := {{"Mary", 14}, {"Joe", 23}, {"Art", 16}}
        aSortKids := ASort(aKids,,, {|x, y| x[2] &lt;= y[2]})&#0009;// {{"Mary", 14}, {"Art", 16}, {"Joe", 23}}
      </code>
      注意：<br/>
      如果确定不会有重复值，可以在代码块中使用 &lt; 和 &gt; 运算符；否则，
      更适合使用 &lt;= 和 &gt;=，因为它们可以正确处理重复值。
    </example>
    <seealso cref='O:XSharp.RT.Functions.AScan'>AScan</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
  </asort>

  <aspadr>
    <summary>
      Convert a value to a right-padded string.
    </summary>
    <param name="uValue">The value to be converted.</param>
    <param name="wLen">The length of the padded string.</param>
    <returns>
      A right-padded string of length <paramref name="wLen" /> containing the converted value.
    </returns>
    <remarks>
      AsPadR(<paramref name="uValue" />, <paramref name="wLen" />) is like specifying PadR(AsString(<paramref name="uValue" />), <paramref name="wLen" />, " ").
    </remarks>
    <example>
      This example uses AsPadR() to compare a number with the contents of a character field:
      <code language="X#">? _FIELD-&gt;cRegion == AsPadR(2048, 10)</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsString'>AsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadR'>PadR</seealso>
  </aspadr>

  <asstring>
    <summary>
      将值转换为字符串。
    </summary>
    <param name="uValue">要转换的值。</param>
    <returns>
      包含转换后值的字符串。<br/>
      转换后的字符串是动态分配的。
    </returns>
    <remarks>
    </remarks>
    <example>
      这些示例展示了如何使用AsString()：
      <code language="X#">
        LOCAL cNum AS STRING
        LOCAL cDate AS STRING
        cNum := AsString(123456)
        &#0009;// 转换一个空日期
        cDate := AsString(0.0.0)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsPadr'>AsPadR</seealso>
    <seealso cref='O:XSharp.RT.Functions.AsSymbol'>AsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTOC'>LToC</seealso>
  </asstring>

  <assymbol>
    <summary>
      将字符串或PSZ转换为符号。
    </summary>
    <param name="uValue">
      要转换的值。<br/>
      <paramref name="uValue" />的可能数据类型为STRING、PSZ或SYMBOL。
    </param>
    <returns>
      转换后的符号值。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例将字符串转换为符号。<br/>
      这样做的一个原因是提高性能，因为符号比较比字符串比较更快。
      <code language="X#">
        symFind := AsSymbol("ALongPassword!")
        &#0009;// 执行更快的搜索
        AScan(aSymList, symFind)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsHexString'>AsHexString</seealso>
    <seealso cref='O:XSharp.RT.Functions.AsString'>AsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.String2Atom'>String2Atom</seealso>
    <seealso cref='O:XSharp.RT.Functions.String2Symbol'>String2Symbol</seealso>
  </assymbol>

  <at>
    <summary>
      返回子字符串在字符串中首次出现的位置。
    </summary>
    <param name="cSearch">要搜索的子字符串。</param>
    <param name="cTarget">要在其中搜索的字符串。（要从特定偏移量开始，请使用At3()。）</param>
    <returns>
      <paramref name="cSearch" />在<paramref name="cTarget" />中首次出现的位置。<br/>
      如果未找到<paramref name="cSearch" />，At()返回0。
    </returns>
    <remarks>
      如果您只需要知道一个子字符串是否存在于另一个字符串中，请使用InStr()函数或$运算符。<br/>
      要查找子字符串在字符串中最后一次出现的位置，请使用RAt()。
      At()和RAt()函数都与Substr()、Left()和Right()一起使用来提取子字符串。
    </remarks>
    <example>
      这些示例展示了At()的典型用法：
      <code language="X#">
        ? At("a", "abcde")&#0009;&#0009;&#0009;// 1
        ? At("bcd", "abcde")&#0009;&#0009;// 2
        ? At("a", "bcde")&#0009;&#0009;&#0009;// 0
      </code>
      此示例使用强类型根据目标字符串中逗号的位置拆分字符串：
      <code language="X#">
        LOCAL cTarget AS STRING
        cTarget := "Langtree, Lilly"
        ? Substr(cTarget, 1, At(",", cTarget) - 1)&#0009;// Langtree
        ? Substr(cTarget, At(",", cTarget) + 2)&#0009;&#0009;// Lilly
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At2'>At2</seealso>
    <seealso cref='O:XSharp.Core.Functions.At3'>At3</seealso>
    <seealso cref='O:XSharp.Core.Functions.AtC'>AtC</seealso>
    <seealso cref='O:XSharp.Core.Functions.AtC2'>AtC2</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATCLine'>AtCLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATCLine2'>AtCLine2</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATLine'>AtLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATLine2'>AtLine2</seealso>
    <seealso cref='O:XSharp.Core.Functions.Instr'>InStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.Core.Functions.Occurs'>Occurs</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </at>

  <at2>
    <summary>
      返回子字符串在字符串中首次出现的位置。
    </summary>
    <param name="cSearch">要搜索的子字符串。</param>
    <param name="cTarget">要在其中搜索的字符串。（要从特定偏移量开始，请使用At3()。）</param>
    <returns>
      <paramref name="cSearch" />在<paramref name="cTarget" />中首次出现的位置。<br/>
      如果未找到<paramref name="cSearch" />，At2()返回0。
    </returns>
    <remarks>
      At2()与At()类似，但返回一个WORD。有关更多信息，请参见At()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.At3'>At3</seealso>
  </at2>

  <at3>
    <summary>
      从指定位置开始，返回子字符串在字符串中首次出现的位置。
    </summary>
    <param name="cSearch">要搜索的子字符串。</param>
    <param name="cTarget">要在其中搜索的字符串。</param>
    <param name="dwOffset">
      开始搜索的字符串位置。<br/>
      值为零对应第一个字节。
    </param>
    <returns>
      <paramref name="cSearch" />在<paramref name="cTarget" />中首次出现的位置。<br/>
      如果未找到<paramref name="cSearch" />，At3()返回0。
    </returns>
    <remarks>
      At3()与At()相同，只是您可以指定一个偏移量来告诉从哪里开始搜索。
    </remarks>
    <example>
      以下示例展示了At3()的典型用法：
      <code language="X#">
        ? At3("a", "abcdeabc", 2)&#0009;&#0009;// 6
        ? At3("a", "bcde", 1)&#0009;&#0009;// 0
      </code>
      此示例显示字符串在源中每次出现的位置：
      <code language="X#">
        LOCAL dwOffset<br/>
        AS DWORD
        LOCAL dwFound := 1 AS DWORD
        LOCAL cSource AS STRING
        LOCAL cSearch AS STRING
        cSource := "Now know-how is valued"
        cSearch := "ow"
        DO WHILE dwFound != 0
        &#0009;? dwFound := At3(cSearch, cSource, wOffset)
        &#0009;dwOffset := dwFound + SLen(cSearch)
        END
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.At2'>At2</seealso>
    <seealso cref='O:XSharp.Core.Functions.AtC'>AtC</seealso>
    <seealso cref='O:XSharp.Core.Functions.Occurs'>Occurs</seealso>
  </at3>

  <atail>
    <summary>
      返回数组的最后一个元素。
    </summary>
    <param name="aTarget">目标数组。</param>
    <returns>
      数组最后一个元素的内容。
    </returns>
    <remarks>
      ATail() 返回数组的最后一个元素。<br/>
      在需要获取数组最后一个元素时，它可以作为 <paramref name="aArray" />[ALen(<paramref name="aArray" />)] 的简写形式使用。
    </remarks>
    <example>
      以下示例创建一个字面量数组并返回数组的最后一个元素：
      <code language="X#">
        aArray := {"a", "b", "c", "d"}
        ? ATail(aArray)&#0009;&#0009;&#0009;// d
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ALen'>ALen</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
  </atail>

  <acos>
    <summary>
      返回指定数值表达式的反余弦值。
    </summary>
    <param name="nExpression">
      指定一个数值表达式，ACOS()返回其反余弦值。nExpression的值范围可以从-1到+1。ACOS()返回的值范围从0到pi（3.141592）。ACOS()返回的小数位数由SET DECIMALS决定。
      使用RTOD()将弧度转换为角度。
    </param>
    <returns>
      数值
    </returns>
    <remarks>
      反余弦值以弧度返回。
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? RTOD(ACOS(0))  // 显示 90.00
        STORE -1 to gnArcAngle
        ? RTOD(ACOS(gnArcAngle))  // 显示 180.00
        ? RTOD(ACOS(SQRT(2)/2))  // 显示 45.00
      </code>
    </example>
  </acos>

  <asin>
    <summary>
      返回数值表达式的反正弦值（以弧度为单位）。
    </summary>
    <param name="nExpression">
      指定ASIN()返回其反正弦值的数值表达式。nExpression的值范围可以从-1到+1，ASIN()返回的值范围从-pi/2到+pi/2（-1.57079到1.57079）。结果显示的小数位数可以通过SET DECIMALS指定。
    </param>
    <returns>
      数值
    </returns>
    <remarks>
      使用RTOD()将弧度转换为角度。
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? RTOD(ASIN(0))  // 返回 0.00
        STORE 1 to gnArcAngle
        ? RTOD(ASIN(gnArcAngle))  // 返回 90.00
        ? RTOD(ASIN(SQRT(2)/2))  // 返回 45.00
      </code>
    </example>
  </asin>

  <atan2>
    <summary>
      返回正切值为两个指定数值商的角度。
    </summary>
    <param name="nX">任意数值。</param>
    <param name="nY">任意数值。</param>
    <returns>
      返回正切值为两个指定数值商的角度。
    </returns>
  </atan2>

  <pi>
    <summary>
      返回数值常数 pi（π）。
    </summary>
    <returns>
      PI()返回值
      数值类型
    </returns>
    <remarks>
      数值常数 pi（3.141592）是圆的周长与其直径的比值。
      <b>PI()</b> 返回值显示的小数位数由 SET DECIMALS 决定。
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? PI() // 显示 3.14
        STORE 2.30 TO gnRadius
        STORE PI() * gnRadius^2 TO gnArea
        ? gnArea  // 显示 16.6190
      </code>
    </example>
  </pi>

  <rtod>
    <summary>
      将弧度转换为相应的角度。
      在使用 X# 三角函数 COS()、SIN() 和 TAN() 时，可以使用 RTOD()。
    </summary>
    <param name="nExpression">
      指定表示弧度值的数值表达式。
    </param>
    <returns>
      数值数据类型。RTOD() 返回从弧度数转换而来的度数。
    </returns>
    <remarks>
      要将度数转换为弧度，请使用 DTOR() 函数。
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? RTOD(ACOS(0))  // 显示 90.00
        STORE -1 to gnArcAngle
        ? RTOD(ACOS(gnArcAngle))  // 显示 180.00
        ? RTOD(ACOS(SQRT(2)/2)) // 显示 45.00
      </code>
    </example>
  </rtod>

  <dtor>
    <summary>
      将度数转换为弧度。
    </summary>
    <param name="nExpression">
      指定要转换为弧度的数值表达式。以度:分:秒格式表示的角度应先转换为其十进制等值。
    </param>
    <returns>
      数值
    </returns>
    <remarks>
      DTOR() 将以度数表示的数值表达式转换为等效的弧度值。DTOR() 在使用 X# 三角函数时很有用，如 ACOS()、ASIN()、COS()、SIN()、TAN()。
      使用 RTOD() 可将弧度转换为度数。
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? DTOR(0)  // 显示 0.00
        ? DTOR(45) // 显示 0.79
        ? DTOR(90) // 显示 1.57
        ? DTOR(180)  // 显示 3.14
        ? COS(DTOR(90))  // 显示 0.00
      </code>
    </example>
  </dtor>

  <atan>
    <summary>
      计算一个数的反正切值。
    </summary>
    <param name="nNum">任意数值。</param>
    <returns>
      一个介于 -PI/2 和 PI/2 之间的数，表示弧度角，其正切值等于 <paramref name="nNum" />。
    </returns>
    <remarks>
      <note type="tip">
        结果仅跨越半个圆（从 -PI/2 到 PI/2）。<br/>
        这意味着对于不在 -PI/2 和 PI/2 之间的值，Tan() 和 ATan() 不是互逆函数。换句话说，ATan(Tan(<paramref name="n" />)) 并不总是返回 <paramref name="n" />。请参见下面的示例。
      </note>
    </remarks>
    <example>
      这个例子显示，对于值 -1+PI，ATan() 不是 Tan() 的逆函数，但对于值 -1，ATan() 是 Tan() 的逆函数。<br/>
      这是因为 -1+PI 的正切等于 Tan(-1+PI) 或 -1.56。<br/>
      -1 的正切也等于 Tan(-1) 或 -1.56。<br/>
      -1.56 的 ATan() 是 ATan(-1.56) 或 -1。因此 ATan(Tan(-1)) 等于 -1。但 ATan(Tan(-1+PI)) 等于 -1，这不等于 -1+PI。
      <code language="X#">
        ? ATan(Tan(-1+PI)) <paramref name="" /> -1+PI&#0009;&#0009;// TRUE
        ? ATan(Tan(-1)) = -1&#0009;&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ACot'>ACot</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cos'>Cos</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cot'>Cot</seealso>
    <seealso cref='O:XSharp.RT.Functions.Sin'>Sin</seealso>
    <seealso cref='O:XSharp.RT.Functions.Tan'>Tan</seealso>
  </atan>

  <atc>
    <summary>
      返回一个子串在字符串中第一次出现的位置，不区分大小写。
    </summary>
    <param name="cSearch">要搜索的子串。</param>
    <param name="cTarget">要在其中搜索的字符串。</param>
    <returns>
      <paramref name="cSearch" /> 在 <paramref name="cTarget" /> 中第一次出现的位置。<br/>
      如果未找到 <paramref name="cSearch" />，AtC() 返回 0。
    </returns>
    <remarks>
      如果您只需要知道一个子串是否存在于另一个字符串中，请使用 InStr() 函数或 $ 运算符。<br/>
      要查找子串在字符串中最后一次出现的位置，请使用 RAt()。
    </remarks>
    <example>
      这些示例展示了 AtC() 的典型用法：
      <code language="X#">
        ? AtC("bcd", "ABCDE")&#0009;&#0009;// 2
        ? AtC("a", "bcde")&#0009;&#0009;&#0009;// 0
        ? AtC("a", "AbCdE")&#0009;&#0009;&#0009;// 1
      </code>
      这个示例使用强类型来更高效地完成相同的操作：
      <code language="X#">
        LOCAL cSearch AS STRING
        LOCAL cTarget AS STRING
        cSearch := "a"
        cTarget := "AbCdE"
        ? AtC(cSearch, cTarget)&#0009;&#0009;// 1
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.AtC2'>AtC2</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATCLine'>AtCLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.Instr'>InStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Occurs'>Occurs</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
  </atc>

  <atc2>
    <summary>
      返回一个子串在字符串中第一次出现的位置，不区分大小写。
    </summary>
    <param name="cSearch">要搜索的子串。</param>
    <param name="cTarget">要在其中搜索的字符串。</param>
    <returns>
      <paramref name="cSearch" /> 在 <paramref name="cTarget" /> 中第一次出现的位置。<br/>
      如果未找到 <paramref name="cSearch" />，AtC2() 返回 0。
    </returns>
    <remarks>
      AtC2() 与 AtC() 类似，但它返回一个 WORD 类型的值。更多信息请参见 AtC()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AtC'>AtC</seealso>
  </atc2>

  <atcline>
    <summary>
      返回一个子串在多行字符串中第一次出现的行号，不区分大小写。
    </summary>
    <param name="cSearch">要搜索的子串。</param>
    <param name="cTarget">要在其中搜索的字符串。</param>
    <returns>
      <paramref name="cSearch" /> 在 <paramref name="cTarget" /> 中第一次出现的位置。<br/>
      如果未找到 <paramref name="cSearch" />，AtCLine() 返回 0。
    </returns>
    <remarks>
      如果您只需要知道一个子串是否存在于另一个字符串中，请使用 InStr() 函数或 $ 运算符。
    </remarks>
    <example>
      这些示例展示了 AtCLine() 的典型用法：
      <code language="X#">
        LOCAL cBigString AS STRING
        cBigString := "这是第一行" + ;
        &#0009;CRLF + "这是第二行" + ;
        &#0009;CRLF + "这是第三行"
        ? AtCLine("第三", cBigString)&#0009;&#0009;&#0009;// 3
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATCLine2'>AtCLine2</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATLine'>AtLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.Instr'>InStr</seealso>
  </atcline>

  <atcline2>
    <summary>
      返回一个子串在多行字符串中第一次出现的行号，不区分大小写。
    </summary>
    <param name="cSearch">要搜索的子串。</param>
    <param name="cTarget">要在其中搜索的字符串。</param>
    <returns>
      <paramref name="cSearch" /> 在 <paramref name="cTarget" /> 中第一次出现的位置。<br/>
      如果未找到 <paramref name="cSearch" />，AtCLine2() 返回 0。
    </returns>
    <remarks>
      AtCLine2() 与 AtCLine() 类似，但它返回一个 WORD 类型的值。更多信息请参见 AtCLine()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ATCLine'>AtCLine</seealso>
  </atcline2>

  <atline>
    <summary>
      返回一个子串在多行字符串中第一次出现的行号。
    </summary>
    <param name="cSearch">要搜索的子串。</param>
    <param name="cTarget">要在其中搜索的字符串。</param>
    <returns>
      <paramref name="cSearch" /> 在 <paramref name="cTarget" /> 中第一次出现的位置。<br/>
      如果未找到 <paramref name="cSearch" />，AtLine() 返回 0。
    </returns>
    <remarks>
      如果您只需要知道一个子串是否存在于另一个字符串中，请使用 InStr() 函数或 $ 运算符。
    </remarks>
    <example>
      这些示例展示了 AtLine() 的典型用法：
      <code language="X#">
        LOCAL cBigString AS STRING
        cBigString := "这是第一行" + ;
        &#0009;CRLF + "这是第二行" + ;
        &#0009;CRLF + "这是第三行"
        ? AtLine("第三", cBigString)&#0009;&#0009;&#0009;// 3
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At Function</seealso>
    <seealso cref='O:XSharp.Core.Functions.AtC'>AtC Function</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATCLine'>AtCLine Function</seealso>
    <seealso cref='O:XSharp.Core.Functions.ATLine2'>AtLine2 Function</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrTran'>StrTran Function</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr Function</seealso>
  </atline>

  <atline2>
    <summary>
      返回一个子串在多行字符串中第一次出现的行号。
    </summary>
    <param name="cSearch">要搜索的子串。</param>
    <param name="cTarget">要在其中搜索的字符串。</param>
    <returns>
      <paramref name="cSearch" /> 在 <paramref name="cTarget" /> 中第一次出现的行号。<br/>
      如果未找到 <paramref name="cSearch" />，AtLine2() 返回 0。
    </returns>
    <remarks>
      AtLine2() 与 AtLine() 类似，但它返回一个 WORD 类型的值。更多信息请参见 AtLine()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ATLine'>AtLine</seealso>
  </atline2>

  <atranslate>
    <summary>
      使用二维数组作为查找表，将一个值翻译为另一个值。<br/>
      数组的形状与 DBServer:GetLookupTable 返回的形状相匹配。
    </summary>
    <param name="aLookupTable">
      一个 n x 2 的矩形数组。<br/>
      查找表有两个元素，每个元素都是一个一维数组，两个数组长度相同。（这是 DBServer:GetLookupTable 返回的数组类型。）第一个线性数组用于查找值，第二个用于获取翻译后的值。
    </param>
    <param name="uValue">
      要翻译的值。<br/>
      该值应与 <paramref name="aLookupTable" /> 数组第一列中的值类型匹配。
    </param>
    <param name="lSoftSeek">
      指示是否应使用软查找。<br/>
      如果为 TRUE，则使用大于 <paramref name="uValue" /> 的第一个值来产生返回值；如果为 FALSE，则只有精确匹配才会产生返回值。<br/>
      此参数是可选的；如果省略，则假定为 FALSE。（此默认值不依赖于 SetSoftSeek()。）
    </param>
    <returns>
      从数组第二列查找到的值，数据类型与数组包含的类型相同。<br/>
      如果未找到匹配项（软查找关闭时），或者 <paramref name="uValue" /> 大于查找表中的所有元素（软查找打开时），则返回 NIL。
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </atranslate>

  <between>
    <summary>
      确定一个值是否在另外两个值之间。
    </summary>
    <param name="uValue">
      一个要与 <paramref name="uMin" /> 和 <paramref name="uMax" /> 比较的任何类型的值。
    </param>
    <param name="uMin">
      要与 <paramref name="uValue" /> 比较的最小值.<br/>
      该值必须与 <paramref name="uValue" /> 的类型相同，但数字类型可以不同.
    </param>
    <param name="uMax">
      要与 <paramref name="uValue" /> 比较的最大值.
      该值必须与 <paramref name="uValue" /> 的类型相同，但数字类型可以不同.
    </param>
    <returns>
      如果该值大于或等于最小值并且小于或等于最大值，则为 TRUE，否则为 FALSE。
    </returns>
    <remarks>
      Between() 可以用来对多态数据类型进行高级搜索.<br/>
      例如，它可以确定
      &#0009;一个字符是否在两个其他字符之间，或者在 ANSI 字符集或 ASCII 图表中
      &#0009;一个日期是否在两个其他日期之间
      &#0009;一个数字是否在两个其他数字之间
      <note type="tip">
        字符串比较:  字符串比较取决于国家.  请注意，一个字符可以在 ANSI 字符集中在两个其他字符之间，但在 OEM 字符集中不在.  因此，在传递字符串时，您可能经常需要指定是否使用 ANSI 或 OEM 字符集.
        浮点数比较:  SetFloatDelta() 会影响 Between() 的结果.
      </note>
    </remarks>
    <example>
      这些示例显示了使用 Between() 搜索字母表中的字母 "cd" 时会发生什么:
      <code language="X#">
        ? Between("cd", "ab", "ef")&#0009;// TRUE
        ? Between("cd", "gh", "kl")&#0009;// FALSE
      </code>
      该示例确定今天的日期是否在 1993年12月12日到 1994年12月12日之间:
      <code language="X#">
        // 返回值取决于今天的日期
        ? Between(Today(), 93.12.12, 94.12.12)
      </code>
      该示例使用数字进行比较:
      <code language="X#">? Between(2, 1, 3)&#0009;&#0009;// TRUE</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.RT.Functions.Max'>Max</seealso>
    <seealso cref='O:XSharp.Core.Functions.Max'>Max</seealso>
    <seealso cref='O:XSharp.RT.Functions.Min'>Min</seealso>
    <seealso cref='O:XSharp.Core.Functions.Min'>Min</seealso>
    <seealso cref='O:XSharp.RT.Functions.SetFloatDelta'>SetFloatDelta</seealso>
  </between>

  <bin2date>
    <summary>
      将一个字符串中的 32 位二进制日期转换为日期数据类型。
    </summary>
    <param name="cString">一个 32 位二进制日期，表示为字符串 —— 最小有效字节优先。  该函数仅使用该字符串的前 4 个字节，所有其他的都将被忽略.</param>
    <returns>
      一个日期值，它对应于 <paramref name="cString" /> 指定的日期.<br/>
      如果 <paramref name="cString" /> 不是一个有效的二进制日期，Bin2Date() 将返回一个 NULL_DATE。
    </returns>
    <remarks>
      Bin2Date() 是一个转换函数，用于将字符串的前 4 个字节转换为日期。  该函数通常用于从外部文件格式中读取日期，然后将其保存、读取、解密和传输到压缩二进制形式，而不是将其作为字符串.<br/>
      Date2Bin() 是 Bin2Date() 的逆函数.
    </remarks>
    <example>
      该示例展示了 Bin2Date() 的使用：
      <code language="X#">? Bin2Date("!$%" + Chr(0))&#0009;// 03/09/52</code>
      该示例显示了 Bin2Date() 和 Date2Bin() 之间的逆关系：
      <code language="X#">? Bin2Date(Date2Bin(Today()))&#0009;// 今天的日期</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2date>

  <bin2dw>
    <summary>
      将一个字符串中的 32 位无符号整数转换为双字。
    </summary>
    <param name="cUnsignedInt">一个 32 位无符号整数，表示为字符串 —— 最小有效字节优先。  该函数仅使用该字符串的前 4 个字节，所有其他的都将被忽略.</param>
    <returns>
    </returns>
    <remarks>
      Bin2DW() 是一个转换函数，用于将字符串的前 4 个字节转换为双字。  该函数通常用于从外部文件格式中读取数字，然后将其保存、读取、解密和传输到压缩二进制形式，而不是将其作为字符串.<br/>
      DW2Bin() 是 Bin2DW() 的逆函数.
    </remarks>
    <example>
      该示例将 4 个 ASCII 字符传递给 Bin2DW()，并返回一个 10 位数字:
      <code language="X#">? Bin2DW("abcd")&#0009;&#0009;// 1684234849</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2dw>

  <bin2f>
    <summary>
      将一个字符串中的 80 位浮点数转换为 float 值。
    </summary>
    <param name="cFloat">一个 80 位浮点数，表示为字符串 —— 最小有效字节优先.</param>
    <returns>
    </returns>
    <remarks>
      Bin2F() 是一个转换函数，用于将二进制字符串转换为浮点数。  该函数通常用于从外部文件格式中读取数字，然后将其保存、读取、解密和传输到压缩二进制形式，而不是将其作为字符串.<br/>
      F2Bin() 是 Bin2F() 的逆函数.
    </remarks>
    <example>
      该示例将一个已转换的浮点数解密回其原始形式：
      <code language="X#">
        FUNCTION Start()
        LOCAL cEncrypt AS STRING
        LOCAL fDecrypt AS FLOAT
        cEncrypt := F2Bin(12365789.96587)&#0009;// 加密
        fDecrypt := Bin2F(cEncrypt)&#0009;&#0009;// 解密
        ? fDecrypt&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 12365789.96587
        RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2f>

  <bin2i>
    <summary>
      将包含 16 位 signed 整数的字符串转换为短整数。
    </summary>
    <param name="cSignedInt">以字符串形式表示的 16 位 signed 整数 —— 最小有效字节优先。  该函数仅使用字符串的前 2 个字节，所有其他字节将被忽略。</param>
    <returns>
    </returns>
    <remarks>
      Bin2I() 是一个转换函数，用于将字符串的前 2 个字节转换为短整数。  该函数通常用于从外部文件格式中读取数字，然后将其保存、读取、解密和传输到压缩二进制形式，而不是将其作为字符串.<br/>
      对于介于 0 和 255 之间的数字，可以使用 Chr() 或 _Chr().
      Bin2I() 的逆函数是 I2Bin().
    </remarks>
    <example>
      该示例使用文件函数打开一个数据库文件，并读取最后更新的日期（字节 1-3）。<br/>
      结果是 LUpdate() 的同一个结果:
      <code language="X#">
        ptrHandle := FOpen2("sales.dbf", FO_READ)&#0009;// 指向文件的字节 1
        FSeek(ptrHandle, 1, FS_SET)&#0009;&#0009;&#0009;// 读取最后更新的日期
        siYear  := Bin2I(FReadStr(ptrHandle, 1) + _Chr(0))
        siMonth := Bin2I(FReadStr(ptrHandle, 1) + _Chr(0))
        siDay   := Bin2I(FReadStr(ptrHandle, 1) + _Chr(0))
        ? NTrim(siMonth), NTrim(siDay), NTrim(siYear)
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2i>

  <bin2l>
    <summary>
      将包含 32 位 signed 整数的字符串转换为长整数。
    </summary>
    <param name="cSignedInt">以字符串形式表示的 32 位 signed 整数 —— 最小有效字节优先。  该函数仅使用字符串的前 4 个字节，所有其他字节将被忽略。</param>
    <returns>
    </returns>
    <remarks>
      Bin2L() 是一个转换函数，用于将字符串的前 4 个字节转换为长整数。  该函数通常用于从外部文件格式中读取数字，然后将其保存、读取、解密和传输到压缩二进制形式，而不是将其作为字符串.<br/>
      L2Bin() 是 Bin2L() 的逆函数.
    </remarks>
    <example>
      该示例使用文件函数打开一个数据库文件，并读取记录数（字节 4-7）。<br/>
      结果是 LastRec() 的同一个结果:
      <code language="X#">
        ptrHandle := FOpen2("sales.dbf", FO_READ)&#0009;// Sales.dbf 包含 84 条记录
        FSeek(ptrHandle, 4, FS_SET)&#0009;&#0009;&#0009;// 指向字节 4
        cRecords := Space(4)
        FRead(ptrHandle, @cRecords, 4)&#0009;&#0009;&#0009;// 读取记录数
        ? LTrim(Str(Bin2L(cRecords)))&#0009;&#0009;&#0009;// 84
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2l>

  <bin2logic>
    <summary>
      将包含 8 位逻辑值的字符串转换为逻辑值。
    </summary>
    <param name="pszLogical">以字符串形式表示的 8 位逻辑值。</param>
    <returns>
    </returns>
    <remarks>
      Bin2Logic() 是一个转换函数，用于将字符串的第一个字节转换为逻辑值。  该函数通常用于从外部文件格式中读取逻辑值，然后将其保存、读取、解密和传输到压缩二进制形式，而不是将其作为字符串.<br/>
      Logic2Bin() 是 Bin2Logic() 的逆函数.
    </remarks>
    <example>
      该示例使用文件函数打开一个文件，读取第一个字节作为二进制逻辑，然后将其转换为逻辑值:
      <code language="X#">
        ptrHandle := FOpen("sales.txt", FO_READ)
        cByte := Space(1)
        FRead(ptrHandle, @cByte, 1)
        ? Bin2Logic(cByte)))&#0009;&#0009;&#0009;//  TRUE 或 FALSE
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Logic2Bin'>Logic2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTOC'>LToC</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2logic>

  <bin2real4>
    <summary>
      将包含 32 位浮点数的字符串转换为 Real4 值。
    </summary>
    <param name="cFloat">以字符串形式表示的 32 位浮点数 —— 最小有效字节优先。 仅使用字符串的前 4 个字节，所有其他字节将被忽略。</param>
    <returns>
    </returns>
    <remarks>
      Bin2Real4() 是一个转换函数，用于将字符串的前 4 个字节转换为 32 位浮点数。  该函数通常用于从外部文件格式中读取数字，然后将其保存、读取、解密和传输到压缩二进制形式，而不是将其作为字符串。<br/>
      Real42Bin() 是 Bin2Real4() 的逆函数.
    </remarks>
    <example>
      该示例证明 Real42Bin() 是 Bin2Real4() 的逆函数:
      <code language="X#">
        cString := Real42Bin(1245633.25)
        ? cString&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 4-byte string
        ? Bin2Real4(cString)&#0009;&#0009;&#0009;// 1245633.25
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2real4>

  <bin2real8>
    <summary>
      将包含 64 位浮点数的字符串转换为 Real8 值。
    </summary>
    <param name="cFloat">以字符串形式表示的 64 位浮点数 —— 最小有效字节优先。 仅使用字符串的前 8 个字节，所有其他字节将被忽略。</param>
    <returns>
    </returns>
    <remarks>
      Bin2Real8() 是一个转换函数，用于将字符串的前 8 个字节转换为 64 位浮点数。  该函数通常用于从外部文件格式中读取数字，然后将其保存、读取、解密和传输到压缩二进制形式，而不是将其作为字符串."<br/>
      Real82Bin() 是 Bin2Real8() 的逆函数.
    </remarks>
    <example>
      该示例证明 Real82Bin() 是 Bin2Real8() 的逆函数:
      <code language="X#">
        cString := Real82Bin(1245633.25)
        ? cString&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 8-byte string
        ? Bin2Real8(cString)&#0009;&#0009;&#0009;// 1245633.25
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real82Bin'>Real82Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2real8>

  <bin2w>
    <summary>
      将包含无符号 16 位整数的字符串转换为 Word。
    </summary>
    <param name="cUnsignedInt">以字符串形式表示的无符号 16 位整数 —— 最小有效字节优先。  仅使用字符串的前 2 个字节，所有其他字节将被忽略。</param>
    <returns>
    </returns>
    <remarks>
      Bin2W() 是一个转换函数，用于将字符串的前 2 个字节转换为 Word。  该函数通常用于从外部文件格式中读取数字，然后将其保存、读取、解密和传输到压缩二进制形式，而不是将其作为字符串."<br/>
      W2Bin() 是 Bin2W() 的逆函数.
    </remarks>
    <example>
      该示例使用文件函数打开一个数据库文件，然后读取记录的字节数 (第 10-11 个字节)。
      结果与 RecSize() 相同:
      <code language="X#">
        ptrHandle := FOpen2("sales.dbf", FO_READ)
        // 请注意，sales.dbf 中记录的长度为 124
        // 将指针设置到字节 10，第一个记录大小字节
        FSeek(ptrHandle, 10, FS_SET)
        cRecSize := Space(2)&#0009;&#0009;&#0009;// 读取记录大小
        FRead(ptrHandle, @cRecSize, 2)
        ? NTrim(Bin2W(cRecSize)))&#0009;&#0009;&#0009;// 124
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </bin2w>

  <blobdirectexport>
    <summary>
      将 binary large object (BLOB) 指针的内容导出到文件中。注意：<br/>
      BLOB 文件 (.DBV 或 .FPT) 用于存储备忘录字段信息，作为替代标准 .DBT 文件机制的方法，支持一些 RDDs。<br/>
      它是一个更为强大和高效的机制，用于存储和检索大量数据，而不是使用 .DBT 文件。  X# 提供了 DBFCDX 驱动程序，它默认使用 BLOB 文件存储机制，并且提供了 DBFBLOB 驱动程序，您可以将其作为继承的驱动程序用于其他 RDDs。
    </summary>
    <param name="nPointer">
      一个指向 BLOB 数据的指针。<br/>
      可以使用 BLOBDirectPut()、BLOBDirectExport() 或 DBFieldInfo(DBS_BLOB_POINTER, <paramref name="nFieldPos" />) 获取该指针。
    </param>
    <param name="cTargetFile">
      目标文件的名称，包括可选的驱动器、目录和扩展名。 请参阅 SetDefault() 和 SetPath()，以了解文件搜索和创建规则。  如果省略扩展名，将不会添加默认扩展名。<br/>
      &#0009;如果 <paramref name="cTargetFile" /> 不存在，将创建该文件。<br/>
      如果它存在，则该函数将尝试以独占模式打开该文件，并在成功时将数据写入该文件，而不发出警告或错误。<br/>
      如果访问被拒绝，因为例如另一个进程正在使用该文件，NetErr() 将被设置为 TRUE。
    </param>
    <param name="kMode">
      一个常量，定义复制模式，如下表所示：<br/>
      <list>
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>BLOB_EXPORT_APPEND</term>
          <description>将数据追加到文件</description>
        </item>
        <item>
          <term>BLOB_EXPORT_OVERWRITE</term>
          <description>覆盖文件 —— 这是默认值</description>
        </item>
      </list>
    </param>
    <returns>
      如果成功，则返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      该示例从 BLOB 文件的根区域中提取一个指针数组，然后使用其中一个指针将图片导出到文件中:
      <code language="X#">
        FUNCTION PutPix()
        &#0009;LOCAL cPixFile AS STRING
        &#0009;LOCAL nPointer
        &#0009;LOCAL aBLOBPtrs AS ARRAY
        &#0009;cPixFile := "picture.gif"
        &#0009;// 客户数据库，其中每个客户的图片
        &#0009;// 都存储在名为 Pix 的字段中
        &#0009;USE customer NEW VIA "DBFCDX"
        &#0009;// 将数组中的第二个元素
        &#0009;// 作为指针
        &#0009;aBLOBPtrs := BLOBRootGet()
        &#0009;nPointer := aBLOBPtrs[2]
        &#0009;// 将 nPointer 指向的图片导出到文件
        &#0009;IF !BLOBDirectExport(nPointer, cPixFile, ;
        &#0009;&#0009;BLOB_EXPORT_OVERWRITE)
        &#0009;&#0009;&#0009;Alert("Export of picture " + cPixFile + ";
        &#0009;&#0009;&#0009;&#0009;failed!")
        &#0009;ELSE
        &#0009;&#0009;// 在这里添加代码以显示图片
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBDirectImport'>BLOBDirectImport</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBExport'>BLOBExport</seealso>
  </blobdirectexport>

  <blobdirectget>
    <summary>
      从 BLOB 文件中检索数据，而不需要引用特定的字段。
    </summary>
    <param name="nPointer">
      BLOB 数据的指针。<br/>
      该指针可以使用 BLOBDirectPut()、BLOBDirectImport() 或 DBFieldInfo(DBS_BLOB_POINTER, <paramref name="nFieldPos" />) 获得。
    </param>
    <param name="nStart">
      <paramref name="nPointer" /> 中的起始位置。<br/>
      如果 <paramref name="nStart" /> 是正数，它是相对于 <paramref name="nPointer" /> 左边的第一个字符的偏移量。<br/>
      如果 <paramref name="nStart" /> 是负数，它是相对于 <paramref name="nPointer" /> 右边的第一个字符的偏移量。<br/>
      如果 <paramref name="nStart" /> 被省略，它将被假定为 1。
    </param>
    <param name="nCount">
      从 <paramref name="nStart" /> 位置开始检索的字节数。<br/>
      如果 <paramref name="nCount" /> 大于存储的数据量，多余的数据将被忽略。<br/>
      如果省略该参数，BLOBDirectGet() 将检索到数据的末尾。
    </param>
    <returns>
      检索到的 BLOB 文件中的数据。<br/>
      返回值的数据类型取决于实际存储的数据类型。<br/>
      使用 ValType() 或 UsualType() 来确定数据类型。
    </returns>
    <remarks>
      BLOBDirectGet() 可以检索 BLOB 文件中的数据，而不需要引用特定的字段。<br/>
      它特别适用于访问大于 64 KB 的数据，例如使用 BLOBImport() 函数创建的备忘录字段。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      该示例演示了将设置信息存储在 BLOB 文件中，然后selective检索存储的信息:
      <code language="X#">
        FUNCTION PutSettings(aColors AS ARRAY,;
        &#0009;aPaths AS ARRAY, aPassWords AS ARRAY) AS VOID
        &#0009;LOCAL aSettings AS ARRAY
        &#0009;USE setup NEW VIA DBFBLOB
        &#0009;aSettings := {}
        &#0009;AADD(aSettings, BLOBDirectPut(0, aColors))
        &#0009;AADD(aSettings, BLOBDirectPut(0, aPaths))
        &#0009;AADD(aSettings, BLOBDirectPut(0, aPassWords))
        &#0009;BLOBRootPut(aSettings)
        &#0009;CLOSE
        FUNCTION GetColors() AS ARRAY
        &#0009;LOCAL aSettings   AS ARRAY
        &#0009;LOCAL aColors     AS ARRAY
        &#0009;USE setup NEW VIA DBFBLOB
        &#0009;aSettings := BLOBRootGet()
        &#0009;aColors := BLOBDirectGet(aSettings[1])
        &#0009;CLOSE
        &#0009;RETURN aColors
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBDirectPut'>BLOBDirectPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBGet'>BLOBGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBImport'>BLOBImport</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
    <seealso cref='O:XSharp.RT.Functions.ValType'>ValType</seealso>
  </blobdirectget>

  <blobdirectimport>
    <summary>
      将文件导入 BLOB 文件中，并返回到数据的指针。
    </summary>
    <param name="nOldPointer">
      一个指向 BLOB 数据的指针，该数据将在导入后释放。<br/>
      该指针可以使用 BLOBDirectPut()、BLOBDirectImport() 或 DBFieldInfo(DBS_BLOB_POINTER, <paramref name="nFieldPos" />) 获得。将 0 传递给该参数将禁用数据的释放。<br/>

      &#0009;如果指定了该参数，BLOBDirectImport() 将释放与 <paramref name="nOldPointer" /> 相关联的空间，以便其他数据重用。<br/>
      因此，在将 <paramref name="nOldPointer" /> 传递给该函数作为参数后，不允许使用 <paramref name="nOldPointer" /> 与任何 BLOB 函数。<br/>
      使用该函数的返回值来引用新存储的数据。
    </param>
    <param name="cSourceFile">
      读取 BLOB 数据的文件名，包括可选的驱动器、目录和扩展名。请参见 SetDefault() 和 SetPath() 以获取文件搜索和创建规则。没有默认的扩展名被假定。<br/>

      &#0009;<br/>

      &#0009;该函数尝试以共享模式打开 <paramref name="cSourceFile" />。<br/>
      如果文件不存在，将引发运行时错误。<br/>
      如果文件成功打开，操作将继续执行。<br/>
      如果访问被拒绝，因为另一个进程独占了该文件，NetErr() 将被设置为 TRUE。
    </param>
    <returns>
      一个指向 BLOB 文件中存储的 BLOB 图像的数字指针。
    </returns>
    <remarks>
      BLOBDirectImport() 提供了一种将文件内容复制到 BLOB 文件中的机制。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      BLOBDirectImport() 与 BLOBDirectExport() 一起用于在外部文件和 BLOB 文件之间传输数据。您可以使用 BLOBDirectImport() 与各种文件类型，包括图形图像、文字处理文件和打印机字体等。<br/>
      这两个函数非常适合创建文档、图形、声音等数据库。
      &#0009;在使用 BLOBDirectImport() 导入文件后，nNewPointer，即返回值，是唯一可以访问 BLOB 文件中的数据的方式。<br/>
      请您，开发者，提供永久存储该引用的方法（请参见下面的示例）
      注意：DBFieldInfo(DBS_BLOB_TYPE, <paramref name="nFieldPos" />) 将对使用 BLOBDirectImport() 创建的备忘录字段返回 "C"（字符串）
    </remarks>
    <example>
      该示例将 .BMP 文件导入到 BLOB 文件中，以便在应用程序启动时显示该图像:<br/>
      <code language="X#">
        FUNCTION PutPix()
        &#0009;LOCAL cBMPFile AS STRING
        &#0009;LOCAL aSettings AS ARRAY
        &#0009;cBMPFile := "logo.bmp"
        &#0009;aSettings := {}
        &#0009;// 客户数据库，用于存储启动参数
        &#0009;USE customer NEW VIA "DBFCDX"
        &#0009;// 获取默认路径设置
        &#0009;AAdd(aSettings, StartPaths())
        &#0009;// 获取默认颜色设置
        &#0009;AAdd(aSettings, DefaultColors())
        &#0009;&#0009;// 获取公司 LOGO，以便在启动时显示
        &#0009;// 没有需要释放的数据，因为这
        &#0009;// 是第一次导入
        &#0009;nPointer := BLOBDirectImport(0, cBMPFile)
        &#0009;AAdd(aSettings, nPointer)
        &#0009;// 将设置存储在客户.fpt 文件的根区域中
        &#0009;BLOBRootPut(aSettings)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBDirectExport'>BLOBDirectExport</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBImport'>BLOBImport</seealso>
  </blobdirectimport>

  <blobdirectput>
    <summary>
      在不引用特定字段的情况下将数据放入 BLOB 文件中。
    </summary>
    <param name="nOldPointer">
      之前存储的 BLOB 数据的引用。<br/>
      该引用可以使用 BLOBDirectPut()、BLOBDirectImport() 或 DBFieldInfo(DBS_BLOB_POINTER, <paramref name="nFieldPos" />) 获得。<br/>
      如果不是 0，BLOBDirectPut() 将 <paramref name="nOldPointer" /> 引用的数据替换为 <paramref name="uBLOB" />;否则，<paramref name="uBLOB" /> 将被添加到 BLOB 文件的当前内容中。<br/>
      <br/>
      &#0009;<br/>
      &#0009;重要！<br/>
      如果指定了 <paramref name="nOldPointer" />，BLOBDirectPut() 将释放与 <paramref name="nOldPointer" /> 关联的空间，以便其他数据重新使用。<br/>
      因此，在将 <paramref name="nOldPointer" /> 传递给该函数后，不可以再使用 <paramref name="nOldPointer" /> 与任何 BLOB 函数。<br/>
      请使用函数的返回值来引用新存储的数据。
    </param>
    <param name="uBLOB">
      要存储在 BLOB 文件中的数据。<br/>
      <paramref name="uBLOB" /> 可以是任何 X# 通用数据类型，除了代码块和对象。
    </param>
    <returns>
      一个指向 <paramref name="uBLOB" /> 数据的数值指针。
    </returns>
    <remarks>
      BLOBDirectPut() 在不创建与特定备注字段的链接的情况下存储可变长度的 BLOB 数据。<br/>
      在使用 BLOBDirectPut() 将数据添加到 BLOB 文件后，您应该存储函数的返回值，因为这是在 BLOB 文件中访问数据的唯一方式。<br/>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      该示例在 BLOB 文件中存储设置信息，然后选择性地检索存储的信息:<br/>
      <code language="X#">
        FUNCTION PutSettings(aColors AS ARRAY,;
        &#0009;aPaths AS ARRAY, aPassWords AS ARRAY) AS VOID
        LOCAL aSettings AS ARRAY
        &#0009;USE setup NEW VIA DBFBLOB
        &#0009;aSettings := {}
        &#0009;AADD(aSettings, BLOBDirectPut(0, aColors))
        &#0009;AADD(aSettings, BLOBDirectPut(0, aPaths))
        &#0009;AADD(aSettings, BLOBDirectPut(0, aPassWords))
        &#0009;BLOBRootPut(aSettings)
        &#0009;CLOSE
        FUNCTION GetColors() AS ARRAY
        &#0009;LOCAL aSettings AS ARRAY
        &#0009;LOCAL aColors   AS ARRAY
        &#0009;USE setup NEW VIA DBFBLOB
        &#0009;aSettings := BLOBRootGet()
        &#0009;aColors := BLOBDirectGet(aSettings[1])
        &#0009;CLOSE
        &#0009;RETURN aColors
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBDirectGet'>BLOBDirectGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBExport'>BLOBExport</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBGet'>BLOBGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBImport'>BLOBImport</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootPut'>BLOBRootPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
  </blobdirectput>

  <blobexport>
    <summary>
      将 BLOB 的内容，根据其备注字段号，复制到文件中。
    </summary>
    <param name="nFieldPos">数据库文件结构中字段的位置。</param>
    <param name="cTargetFile">
      将 BLOB 数据写入的目标文件的名称，包括可选的驱动器、目录和扩展名。  见 SetDefault() 和 SetPath() 的文件搜索和创建规则。  不指定默认扩展名。<br/>

      &#0009;如果 <paramref name="cTargetFile" /> 不存在，将其创建。<br/>
      如果它存在，函数尝试在独占模式下打开该文件，如果成功，则将数据写入该文件中，而不警告或出错。<br/>
      如果因为另一个进程使用该文件而访问被拒绝，例如，NetErr() 将被设置为 TRUE。
    </param>
    <param name="kMode">
      一个常量，定义复制模式，如下表所示：<br/>
      <list>
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>BLOB_EXPORT_APPEND</term>
          <description>将数据追加到文件</description>
        </item>
        <item>
          <term>BLOB_EXPORT_OVERWRITE</term>
          <description>覆盖文件 —— 这是默认值</description>
        </item>
      </list>
    </param>
    <returns>
      如果成功，则返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      该示例将存储在字段中的图片导出到 .GIF 文件，以便在编程中显示该文件:
      <code language="X#">
        FUNCTION ShowPix()
        &#0009;LOCAL cPixFile := "picture.gif" AS STRING
        &#0009;LOCAL nPos
        &#0009;// 客户数据库，包括每个客户的图片
        &#0009;// 存储在名为 Pix 的字段中
        &#0009;USE customer NEW VIA "DBFCDX"
        &#0009;nPos := FIELDPOS("Pix")
        &#0009;// 导出 BLOB 文件的数据
        &#0009;// 对于当前 Pix 字段
        &#0009;IF !BLOBExport(nPos, cPixFile,;
        &#0009;&#0009;BLOB_EXPORT_OVERWRITE)
        &#0009;&#0009;&#0009;Alert("将图片 " + cPixFile + " 导出失败!")
        &#0009;ELSE
        &#0009;&#0009;// 在这里编写代码以显示图片
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBDirectExport'>BLOBDirectExport</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBImport'>BLOBImport</seealso>
  </blobexport>

  <blobget>
    <summary>
      通过备注字段号获取 BLOB 的内容
    </summary>
    <param name="nFieldPos">数据库文件结构中字段的位置。</param>
    <param name="nStart">
      BLOB 数据在备注字段中的起始位置。<br/>
      如果 <paramref name="nStart" /> 是正数，它相对于备注字段的最左边的字符。<br/>
      如果 <paramref name="nStart" /> 是负数，它相对于备注字段的最右边的字符。<br/>
      如果省略 <paramref name="nStart" />，它被假定为 1。
    </param>
    <param name="nCount">
      从 <paramref name="nStart" /> 位置开始，获取的数据字节数。<br/>
      如果 <paramref name="nCount" /> 大于实际存储的数据量，多余的数据将被忽略。<br/>
      如果省略 <paramref name="nCount" />，BLOBGet() 将获取到数据的结尾。
    </param>
    <returns>
      从备注字段中获取的 BLOB 数据。<br/>
      该数据的类型取决于实际存储的数据类型。<br/>
      使用 ValType() 或 UsualType() 来确定数据类型。<br/>
      如果所指示的字段不是备注字段，BLOBGet() 将返回 NIL。
    </returns>
    <remarks>
      BLOBGet() 与 FieldGet() 非常相似。  但是，因为字符串类型的变量不能大于 64 KB，FieldGet() 将在尝试从备注字段中获取大于该大小的数据时引发一个运行时错误。
      BLOBGet() 也将在尝试获取大于该大小的字段时引发一个错误，但是您可以通过使用小于 64 KB 的 <paramref name="nCount" /> 来获取该字段的任何子集。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      注意：小于 64 KB 的 BLOB 数据可以使用标准方式从备注字段中获取（例如，在表达式中使用字段名或使用 FieldGet() 函数）。
    </remarks>
    <example>
      该示例将 Word 处理文档中的信息导入到一个字段中，然后使用 BLOBGet() 来获取该字段的前 25 个字符:
      <code language="X#">
        FUNCTION GetFirst25()
        &#0009;LOCAL nPos
        &#0009;LOCAL cStr AS STRING
        &#0009;USE customer NEW INHERIT FROM {"DBFBLOB"}
        &#0009;// 字段，包含 Word 处理文档
        &#0009;nPos := FIELDPOS("WP_DOC")
        &#0009;&#0009;// 导入一个文件（可以大于 64 KB），然后
        &#0009;// 获取该字段的前 25 个字符以供用户查看
        &#0009;IF BLOBImport(nPos, "c:\application\temp.doc")
        &#0009;&#0009;cStr := BLOBGet(nPos, 1, 25)
        &#0009;ELSE
        &#0009;&#0009;cStr := "Error: could not import file!"
        &#0009;ENDIF
        CLOSE
        RETURN cStr
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBDirectGet'>BLOBDirectGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBDirectPut'>BLOBDirectPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBImport'>BLOBImport</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetSym'>FieldGetSym</seealso>
  </blobget>

  <blobimport>
    <summary>
      通过备注字段号将文件的内容读取到 BLOB 中
    </summary>
    <param name="nFieldPos">数据库文件结构中字段的位置。</param>
    <param name="cSourceFile">
      读取 BLOB 数据的文件名，包括可选的驱动器、目录和扩展名。请参见 SetDefault() 和 SetPath() 以获取文件搜索和创建规则。没有默认的扩展名被假定。<br/>

      &#0009;该函数尝试以共享模式打开 <paramref name="cSourceFile" />。<br/>
      如果文件不存在，将引发运行时错误。<br/>
      如果文件成功打开，操作将继续执行。<br/>
      如果访问被拒绝，因为另一个进程独占了该文件，NetErr() 将被设置为 TRUE。
    </param>
    <returns>
      如果成功，返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      BLOBImport() 提供了将文件的内容复制到备注字段中的 BLOB 数据的机制。<br/>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      BLOBImport() 可以与 BLOBExport() 结合使用，以在文件和备注字段之间传输 BLOB 数据。  您可以使用 BLOBImport() 来处理多种文件类型，包括图形图像、word processor 文件和打印机字体。<br/>
      这两个函数是创建包含文档、图形、声音等的数据库的理想选择。<br/>
      注意：DBFieldInfo(DBS_BLOB_TYPE, <paramref name="nFieldPos" />) 将返回 "C" (string) 对于使用 BLOBImport() 创建的任何备注字段。
    </remarks>
    <example>
      该示例将信息从一个 word 处理文档导入到一个字段中，然后使用 BLOBGet() 来提取该字段的前 25 个字符:
      <code language="X#">
        FUNCTION Populate()
        &#0009;USE customer NEW INHERIT FROM {"DBFBLOB"}
        &#0009;// Construct unique file name based on last
        &#0009;// name and id
        &#0009;DO WHILE .NOT. EOF()
        &#0009;&#0009;GetPix("Pix", SUBSTR(LastName, 1, 4) + CustID)
        &#0009;&#0009;Customer-&gt;DBSkip()
        &#0009;ENDDO
        FUNCTION GetPix(cPixField, cPixFile)
        &#0009;LOCAL nPos
        &#0009;nPos := FIELDPOS(cPixField)
        &#0009;// 导入图片文件到指定字段
        &#0009;IF !BLOBImport(nPos, cPixFile)
        &#0009;&#0009;Alert("Import of picture " + cPixFile + "; failed!")
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBExport'>BLOBExport</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
  </blobimport>

  <blobrootget>
    <summary>
      从 BLOB 文件的根目录中检索数据。
    </summary>
    <returns>
      BLOB 文件的根目录中的检索数据。<br/>
      返回值的数据类型取决于实际存储的数据类型。<br/>
      使用 ValType() 或 UsualType() 来确定数据类型。  如果根引用从未使用 BLOBRootPut() 写入到 BLOB 文件中，BLOBRootGet() 将返回 NIL。
    </returns>
    <remarks>
      BLOBRootGet() 允许从工作区中的 BLOB 文件的根目录中检索一个 BLOB。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      注意：因为根目录中的数据不引用特定的数据库记录，所以 DBRLock() 不会保护这个根存储引用。<br/>
      因此，如果数据库文件以共享模式打开，您应该在调用 BLOBRootGet() 之前使用 BLOBRootLock()。
    </remarks>
    <example>
      该示例使用 BLOBRootGet() 从 BLOB 文件中读取系统设置到一个数组中，然后演示了如何允许用户修改设置并将它们还原到 BLOB 文件中:
      <code language="X#">
        FUNCTION UpdateSettings()
        &#0009;LOCAL aSettings AS ARRAY
        &#0009;USE customer NEW SHARED VIA "DBFCDX"
        &#0009;IF BLOBRootLock()
        &#0009;&#0009;// 获取当前设置
        &#0009;&#0009;aSettings := BLOBRootGet()
        &#0009;&#0009;IF EMPTY(aSettings)
        &#0009;&#0009;&#0009;// 该函数将 aSettings
        &#0009;&#0009;&#0009;// 填充为默认数据
        &#0009;&#0009;&#0009;aSettings := GetDefaultSettings()
        &#0009;&#0009;ENDIF
        &#0009;&#0009;// 该函数将允许用户
        &#0009;&#0009;// 修改设置
        &#0009;&#0009;IF ModifySettings(aSettings)
        &#0009;&#0009;&#0009;// 最后将设置
        &#0009;&#0009;&#0009;// 保存到 BLOB 文件中
        &#0009;&#0009;&#0009;BLOBRootPut(aSettings)
        &#0009;&#0009;ENDIF
        &#0009;&#0009;BLOBRootUnLock()
        &#0009;ELSE
        &#0009;&#0009;aSettings := {}
        &#0009;&#0009;Alert("无法在 root;
        &#0009;&#0009;&#0009;区获得锁")
        &#0009;ENDIF
        &#0009;CLOSE
        &#0009;RETURN aSettings
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootLock'>BLOBRootLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootPut'>BLOBRootPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUseArea'>DBUseArea</seealso>
  </blobrootget>

  <blobrootlock>
    <summary>
      在 BLOB 文件的根目录中获取锁。
    </summary>
    <returns>
      如果成功，返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      使用 BLOBRootLock() 在共享模式下访问数据库文件时，以获取 BLOB 文件根目录中的锁，以便于从或写入到根目录。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      该示例演示了如何正确地锁定和解锁 BLOB 文件的根目录，以便于在共享模式下打开的数据库文件中使用。
      <code language="X#">
        FUNCTION GetSettings()
        &#0009;LOCAL aCustSettings AS ARRAY
        &#0009;// 以共享模式打开客户文件
        &#0009;USE customer NEW SHARED INHERIT FROM {"DBFBLOB"}
        &#0009;IF BLOBRootLock()
        &#0009;&#0009;aCustSettings := BLOBRootGet()
        &#0009;&#0009;BLOBRootUnLock()
        &#0009;ELSE
        &#0009;&#0009;Alert("无法获取客户文件的根锁")
        &#0009;ENDIF
        &#0009;CLOSE
        &#0009;RETURN aCustSettings
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootGet'>BLOBRootGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootPut'>BLOBRootPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootUnlock'>BLOBRootUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUseArea'>DBUseArea</seealso>
  </blobrootlock>

  <blobrootput>
    <summary>
      在 BLOB 文件的根区域存储数据。
    </summary>
    <param name="uBLOB">
      您想要放入 BLOB 文件根区域的数据。<paramref name="uBLOB" /> 可以是任何 X# 常用数据类型，除了代码块和对象。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      BLOBRootPut() 允许将一个 — 且仅一个 — 数据片段存储到 BLOB 文件的根区域（这一数据片段没有大小限制）。<br/>
      存储新数据后，BLOBRootPut() 会释放与之前存储在 BLOB 文件根区域的任何数据相关的空间。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      注意：因为根数据不引用数据库文件中的特定记录，DBRLock() 不会保护这个根存储引用。<br/>
      因此，如果数据库文件以共享模式打开，您应该在调用 BLOBRootPut() 之前使用 BLOBRootLock()。
    </remarks>
    <example>
      此示例使用 BLOBRootPut() 在修改后将系统设置存储到 BLOB 文件：
      <code language="X#">
        FUNCTION UpdateSettings()
        &#0009;LOCAL aSettings AS ARRAY
        &#0009;USE customer NEW SHARED VIA "DBFCDX"
        &#0009;IF BLOBRootLock()
        &#0009;&#0009;// 获取任何现有设置
        &#0009;&#0009;aSettings := BLOBRootGet()
        &#0009;&#0009;IF EMPTY(aSettings)
        &#0009;&#0009;&#0009;// 此函数将用默认数据填充 aSettings
        &#0009;&#0009;&#0009;aSettings := GetDefaultSettings()
        &#0009;&#0009;ENDIF
        &#0009;&#0009;// 此函数将允许用户修改设置
        &#0009;&#0009;IF ModifySettings(aSettings)
        &#0009;&#0009;&#0009;// 最后，存储设置
        &#0009;&#0009;&#0009;BLOBRootPut(aSettings)
        &#0009;&#0009;ENDIF
        &#0009;&#0009;BLOBRootUnLock()
        &#0009;ELSE
        &#0009;&#0009;aSettings := {}
        &#0009;&#0009;Alert("无法获取根区域的锁")
        &#0009;ENDIF
        &#0009;CLOSE
        &#0009;RETURN aSettings
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootGet'>BLOBRootGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootLock'>BLOBRootLock</seealso>
  </blobrootput>

  <blobrootunlock>
    <summary>
      释放 BLOB 文件根区域的锁定。
    </summary>
    <returns>
    </returns>
    <remarks>
      使用 BLOBRootUnLock() 来释放先前通过 BLOBRootLock() 获得的锁定。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      注意：<br/>
      只有 BLOBRootGet() 和 BLOBRootPut() 函数需要使用 BLOBRootLock() 或 BLOBRootUnLock()。
    </remarks>
    <example>
      此示例说明了如何正确地锁定和解锁以共享模式打开的数据库文件的 BLOB 文件根区域。
      <code language="X#">
        FUNCTION GetSettings()
        &#0009;LOCAL aCustSettings AS ARRAY
        &#0009;// 以共享模式打开客户文件
        &#0009;USE customer NEW SHARED INHERIT FROM {"DBFBLOB"}
        &#0009;IF BLOBRootLock()
        &#0009;&#0009;aCustSettings := BLOBRootGet()
        &#0009;&#0009;BLOBRootUnLock()
        &#0009;ELSE
        &#0009;&#0009;Alert("无法获取客户文件的根锁定")
        &#0009;ENDIF
        &#0009;CLOSE
        &#0009;RETURN aCustSettings
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBRootLock'>BLOBRootLock</seealso>
  </blobrootunlock>

  <bof>
    <summary>
      判断是否遇到文件开头。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      当尝试跳过数据库文件的第一个逻辑记录之前，或者数据库文件不包含记录时，返回 TRUE；否则返回 FALSE。<br/>
      如果工作区中没有打开的数据库文件，BOF() 返回 TRUE。
    </returns>
    <remarks>
      BOF() 是一个数据库函数，用于在使用 DBSkip() 函数向后移动记录指针时测试边界条件。<br/>
      一个例子是基于用户按键在数据库文件中向前或向后翻页的屏幕分页例程。当用户尝试向后翻页时，您可以使用 BOF() 在使用 DBSkip() 移动记录指针并重绘屏幕之前测试文件开头条件。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      只有 DBSkip()、VODBSkip() 和 SKIP 命令可以将 BOF() 设置为 TRUE。一旦 BOF() 设置为 TRUE，它将保持其值，直到再次尝试移动记录指针。
    </remarks>
    <example>
      此示例通过尝试将记录指针移动到第一条记录之前来演示 BOF()：
      <code language="X#">
        USE sales NEW
        QOut(RECNO(), BOF())&#0009;&#0009;// 结果: 1 FALSE
        DBSkip(-1)
        QOut(RECNO(), BOF())&#0009;&#0009;// 结果: 1 TRUE
      </code>
      此示例使用别名表达式查询未选择工作区中的 BOF() 值：
      <code language="X#">
        USE sales NEW
        USE customer NEW
        USE invoices NEW
        QOut(sales-&gt;BOF(), customer-&gt;BOF())
      </code>
      此示例使用 BOF() 函数的参数来评估未选择工作区中的 BOF() 值：
      <code language="X#">
        USE sales NEW
        USE customer NEW
        USE invoices NEW
        QOut(BOF("sales"), BOF("customer"))
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSkip'>DBSkip</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbBof'>VODBBOF</seealso>
    <seealso cref='P:VO.DbServer.BoF'>DBServer:BoF</seealso>
  </bof>

  <break>
    <summary>
      从 BEGIN SEQUENCE...END 结构中分支出去。
    </summary>

    <param name="uValue">
      传递给 RECOVER 子句的值。注意，<paramref name="uValue" /> 不是可选的；但是，如果没有中断值，可以指定 NIL。
    </param>
    <returns>
      传递给 RECOVER 子句的值。
    </returns>
    <remarks>
      _Break() 在功能上与 BREAK 语句相同。
    </remarks>
    <example>
      此示例安装了一个错误处理代码块，该代码块使用 _Break() 跳转到 RECOVER 之后的行：
      <code language="X#">
        FUNCTION Start()
        &#0009;// 声明 "Export Local" 以提高代码块效率
        &#0009;LOCAL cbSaveHandler
        &#0009;LOCAL oError
        &#0009;// 设置您自己的错误块。
        &#0009;// 如果发生错误，您的错误块将调用 BREAK，
        &#0009;// 使您跳转到 RECOVER 行。
        &#0009;cbSaveHandler := ErrorBlock({|x| _Break(x)})
        &#0009;BEGIN SEQUENCE
        &#0009;&#0009;USE myfile
        &#0009;&#0009;// 如果此处发生错误，将执行安装的代码块，
        &#0009;&#0009;// 其中的 _Break() 会使您跳转到 RECOVER 语句之后的行
        &#0009;RECOVER USING oError
        &#0009;&#0009;// 只有在发生调用安装的错误处理程序的错误时，
        &#0009;&#0009;// 您才会通过 _Break() 到达这里
        &#0009;&#0009;? "打开文件时出错"
        &#0009;&#0009;InKey(0)
        &#0009;&#0009;QUIT&#0009;&#0009;// 注意
        &#0009;END
        &#0009;// 恢复默认错误处理程序
        &#0009;ErrorBlock(cbSaveHandler)
      </code>
    </example>
    <seealsocmd>BEGIN SEQUENCE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.CanBreak'>CanBreak</seealso>
  </break>

  <buffer>
    <summary>
      返回指定大小的未初始化字符串。
    </summary>
    <param name="dwSize">要返回的字节数。</param>
    <returns>
      一个长度为 <paramref name="dwSize" /> 字节的字符串。<br/>
      如果 <paramref name="dwSize" /> 为 0，Buffer() 返回 NULL_STRING。
    </returns>
    <remarks>
      Buffer() 类似于 Space()，但内容是随机的。在不需要初始化字符的情况下，应使用它而不是 Space()。
    </remarks>
    <example>
      此示例使用 Buffer() 分配一个字符串，然后用 FRead3() 读取的数据填充它：
      <code language="X#">
        cBuff := Buffer(8)
        FRead3(ptrHandle, Ptr(_CAST, cBuff), 8)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
    <seealso cref='O:XSharp.Core.Functions.Replicate'>Replicate</seealso>
    <seealso cref='O:XSharp.Core.Functions.Space'>Space</seealso>
  </buffer>

  <canbreak>
    <summary>
      检查是否在 BEGIN SEQUENCE...END 结构内发生中断。
    </summary>
    <returns>
    </returns>
    <remarks>
      如果代码不在 BEGIN SEQUENCE...END 结构内，中断的行为类似于 QUIT 命令。请注意，中断可以由 BEGIN SEQUENCE...END 结构内执行的 _Break() 函数或 BREAK 语句调用。
    </remarks>
    <example>
      此示例展示了 CanBreak() 的两种可能结果：
      <code language="X#">
        BEGIN SEQUENCE
        ? CanBreak()&#0009;&#0009;&#0009;&#0009;// TRUE
        END SEQUENCE? CanBreak()&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealsocmd>BEGIN SEQUENCE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions._Break'>_Break</seealso>
    <seealsocmd>QUIT</seealsocmd>
  </canbreak>

  <cast2psz>
    <summary>
      检查强类型字符串是否为 NULL_STRING 并返回有效的（非零）PSZ。
    </summary>
    <param name="cString">要转换的字符串。</param>
    <returns>
      如果成功，返回非零 PSZ；否则返回 NULL_PSZ。
    </returns>
    <remarks>
      Cast2Psz() 对于许多需要在参数列表中使用 PSZ 的 Windows 或 DLL 函数很有用。<br/>
      它检查 <paramref name="cString" /> 是否为 NULL_STRING。<br/>
      如果是，String2Psz() 返回一个指向包含 0x00 的静态字节指针。<br/>
      否则，它将 <paramref name="cString" /> 参数作为 PSZ 返回。
      不要使用 Cast2Psz() 来初始化您自己的 PSZ 变量，因为它保持相同的动态字符串，其位置将在下一次调用"垃圾收集器"时改变。
    </remarks>
    <example>
      请参见 String2Psz() 示例。
    </example>
    <seealso cref='O:XSharp.RT.Functions.Psz2String'>Psz2String</seealso>
    <seealso cref='O:XSharp.RT.Functions.String2Psz'>String2Psz</seealso>
  </cast2psz>

  <cdow>
    <summary>
      从日期中提取星期几的名称。
    </summary>
    <param name="dDate">要提取星期几的日期。</param>
    <returns>
      星期几的名称，其中第一个字母大写，字符串的其余部分小写。<br/>
      对于无效或 NULL_DATE，CDoW() 返回 NULL_STRING。
    </returns>
    <remarks>
      CDoW() 是一个日期转换函数，用于格式化报告、标签、屏幕等的日期显示。<br/>
      此函数依赖于国家/地区设置。
    </remarks>
    <example>
      这些示例说明了 CDoW() 的用法：
      <code language="X#">
        ? Today()&#0009;&#0009;&#0009;&#0009;&#0009;// 06/05/93
        ? CDoW(Today())&#0009;&#0009;&#0009;// 星期二
        ? CDoW(Today() + 7)&#0009;&#0009;&#0009;// 星期二
        ? CDoW(CToD("06/12/93"))&#0009;&#0009;// 星期日
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CToD'>CToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.Day'>Day</seealso>
    <seealso cref='O:XSharp.RT.Functions.DoW'>DoW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Today'>Today</seealso>
  </cdow>

  <ceil>
    <summary>
      将数字向上舍入到下一个最高整数。
    </summary>
    <param name="nNumber">要舍入的数字。</param>
    <returns>
      大于或等于 <paramref name="nNumber" /> 的最接近数字的整数部分（无小数）。由于 <paramref name="nNumber" /> 和返回值都是 USUAL 数据类型，您不受整数大小的限制。
    </returns>
    <remarks>
      Ceil() 将带有小数部分的正数向上舍入到下一个最高整数，并返回负数的整数部分。
    </remarks>
    <example>
      这些示例说明了 Ceil() 对正值和负值的作用：
      <code language="X#">
        ? Ceil(1.6)&#0009;&#0009;&#0009;// 2
        ? Ceil(-1.6)&#0009;&#0009;&#0009;&#0009;// -1 (因为 -1 &gt; -2)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Floor'>Floor</seealso>
    <seealso cref='O:XSharp.RT.Functions.Frac'>Frac</seealso>
    <seealso cref='O:XSharp.RT.Functions.Integer'>Integer</seealso>
    <seealso cref='O:XSharp.RT.Functions.Round'>Round</seealso>
  </ceil>

  <chareven>
    <summary>
      返回字符串中的偶数位置字符。
    </summary>
    <param name="cString">要返回偶数位置字符的字符串。</param>
    <returns>
      字符串中的每隔一个字符，从第二个字符开始。
    </returns>
    <remarks>
    </remarks>
    <example>
      这些示例显示了字符串中的每个偶数位置字符：
      <code language="X#">
        ? CharEven("A1B2C3")&#0009;&#0009;&#0009;// 123
        ? CharEven("1234567890")&#0009;&#0009;&#0009;// 24680
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.CharMix'>CharMix</seealso>
    <seealso cref='O:XSharp.Core.Functions.CharOdd'>CharOdd</seealso>
  </chareven>

  <charmix>
    <summary>
      返回一个字符串，其奇数位置字符和偶数位置字符分别来自两个不同的字符串。
    </summary>
    <param name="cOdd">其字符将构成返回字符串中奇数位置字符的字符串。</param>
    <param name="cEven">其字符将构成返回字符串中偶数位置字符的字符串。</param>
    <returns>
      一个字符串，其中<paramref name="cOdd" />和<paramref name="cEven" />的字符交替出现。<br/>
      <paramref name="cOdd" />的长度决定了返回字符串的长度：假设<paramref name="cEven" />至少包含一个字符，返回字符串的长度是<paramref name="cOdd" />长度的两倍：
      &#0009;较长的<paramref name="cEven" />字符串会被截断至<paramref name="cOdd" />的长度。
      &#0009;较短的<paramref name="cEven" />会从头到尾处理，然后再从头开始，直到<paramref name="cOdd" />中没有更多字符。
      如果<paramref name="cEven" />包含少于一个字符，则返回NULL_STRING。
    </returns>
    <remarks>
      CharMix()提供了一种方便的方法来重新组合从CharOdd()和CharEven()提取的字符串。
    </remarks>
    <example>
      这个例子混合了两个字符串：
      <code language="X#">? CharMix("13579", "24680")&#0009;// 1234567890</code>
      这个例子在游戏中洗牌：
      <code language="X#">
        Function Start()
        &#0009;LOCAL cPoker AS STRING
        &#0009;cPoker := "AKJQ0123456789"
        &#0009;? Shuffle(cPoker, 10)&#0009;// Q37A048K159J26
        &#0009;RETURN TRUE
        FUNCTION Shuffle(cDeck AS STRING, ;
        &#0009;&#0009;siShuffles AS SHORTINT) AS STRING PASCAL
        &#0009;// 假设卡片数量为偶数。
        &#0009;// cDeck的长度可被2整除
        &#0009;LOCAL siCounter AS SHORTINT
        &#0009;LOCAL siCards AS SHORTINT
        &#0009;siCards := SLen(cDeck)
        &#0009;// 第一张和最后一张牌不洗牌；
        &#0009;// 所以添加/填充空白卡
        &#0009;siCards += 2
        &#0009;cDeck := PadC(cDeck, siCards)
        &#0009;FOR siCounter := 1 UPTO siShuffles
        &#0009;&#0009;// 将牌组切成两半并洗牌
        &#0009;&#0009;cDeck := CharMix(Substr3(cDeck, 1,;
        &#0009;&#0009;siCards/2), Substr2(cDeck, (siCards/2)+1))
        &#0009;NEXT
        &#0009;RETURN Substr3(cDeck, 2, siCards-2)
        &#0009;// 排除添加的空白卡
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.CharEven'>CharEven</seealso>
    <seealso cref='O:XSharp.Core.Functions.CharOdd'>CharOdd</seealso>
  </charmix>

  <charodd>
    <summary>
      返回字符串中的奇数位置字符。
    </summary>
    <param name="cString">要返回奇数位置字符的字符串。</param>
    <returns>
      字符串中的每隔一个字符，从第一个字符开始。
    </returns>
    <remarks>
    </remarks>
    <example>
      SaveScreenOld()函数的返回值保持与CA-Clipper SaveScreen()函数的兼容性，它将屏幕内容存储在一个缓冲区中，奇数字节包含实际的屏幕字符，偶数字节包含相应的屏幕属性。CharOdd()在从这样的缓冲区中提取屏幕内容时非常有用。
      这个例子保存第一行的屏幕内容，并在下一行以多种不同的颜色重新显示它：
      <code language="X#">
        Function Start()
        &#0009;LOCAL i AS SHORTINT
        &#0009;LOCAL cBuffer AS STRING
        &#0009;LOCAL cCharacters, cAttributes AS STRING
        &#0009;LOCAL cSong AS STRING
        &#0009;cSong := "展示你的真实色彩！"
        &#0009;?? cSong
        &#0009;cBuffer := SaveScreenOld(0, 0, 0, 79)
        &#0009;cCharacters := CharOdd(cBuffer)
        &#0009;cAttributes := CharEven(cBuffer)
        &#0009;// 更改属性
        &#0009;SEvalA(cAttributes, {|| Chr(i++)}, 1,;
        &#0009;&#0009;&#0009;&#0009;SLen(cSong))
        &#0009;// 用新属性重新显示
        &#0009;RestScreenOld(1, 0, 1, 79,;
        &#0009;&#0009;&#0009;&#0009;CharMix(cCharacters, cAttributes))
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.CharEven'>CharEven</seealso>
    <seealso cref='O:XSharp.Core.Functions.CharMix'>CharMix</seealso>
  </charodd>

  <charpos>
    <summary>
      根据字符在字符串中的位置返回该字符。
    </summary>
    <param name="cString">您想要从中提取字符的字符串。</param>
    <param name="wPosition">
      字符在 <paramref name="cString" /> 中的位置。
    </param>
    <returns>
      位于指定位置的字符。
    </returns>
    <remarks>
      CharPos(<paramref name="cString" />, <paramref name="wPosition" />) 从指定字符串中提取长度为一个字符的子字符串。功能上，它与 Substr(<paramref name="cString" />, <paramref name="wPosition" />, 1) 相同。
      <br/>
      以下示例从名字中提取单个字母并单独显示它们：
      <code language="X#">
        FUNCTION SayName()
        &#0009;LOCAL siCount AS SHORTINT
        &#0009;LOCAL cName := "张三李四"
        &#0009;FOR siCount := 1 UPTO Len(cName)
        &#0009;&#0009;?? CharPos(cName, siCount)
        &#0009;NEXT
      </code>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </charpos>

  <checkinstanceof>
    <summary>
      确定对象是否为特定类的实例。
    </summary>
    <param name="oObject">要检查的对象。</param>
    <param name="symClassName">
      <paramref name="oObject" /> 可能是其实例的类。
    </param>
    <returns>
      如果 <paramref name="oObject" /> 是 <paramref name="symClassName" /> 的实例，则返回 TRUE；否则，将生成一个错误。如果选择忽略错误，则返回 FALSE。
      如果 <paramref name="oObject" /> 是 NULL_OBJECT，则返回 FALSE，但不生成错误。
    </returns>
    <remarks>
      继承类的实例也是原始（超）类的实例。然而，超类的实例不是其任何继承类的实例。
      CheckInstanceOf() 类似于 IsInstanceOf()，但如果指定的对象不是指定类的实例，它还会生成一个错误消息。
    </remarks>
    <example>
      这些示例说明了 CheckInstanceOf() 在继承类上的使用：
      <code language="X#">
        CLASS Person
        &#0009;EXPORT name, sign
        CONSTRUCTOR(tName, tSign)
        &#0009;name := tName
        &#0009;sign := tSign
        END CLASS
        CLASS Male INHERIT Person
        &#0009;EXPORT prefers
        END CLASS
        FUNCTION CheckArgument()
        &#0009;LOCAL x, y AS OBJECT
        &#0009;x := Person{"小明", "总裁"}
        &#0009;y := Male{"小张", "副总"}
        &#0009;? CheckInstanceOf(x, #Person)&#0009;&#0009;// TRUE
        &#0009;? CheckInstanceOf(x, #Male)&#0009;&#0009;// FALSE
        &#0009;? CheckInstanceOf(y, #Person)&#0009;&#0009;// TRUE
        &#0009;? CheckInstanceOf(y, #Male)&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ClassName'>ClassName</seealso>
    <seealso cref='O:XSharp.RT.Functions.CreateInstance'>CreateInstance</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsInstanceOf'>IsInstanceOf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsInstanceOfUsual'>IsInstanceOfUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethodUsual'>IsMethodUsual</seealso>
  </checkinstanceof>

  <chr>
    <summary>
      将 ASCII 码转换为字符值。
    </summary>
    <param name="dwCode">从 0 到 255 的 ASCII 码。</param>
    <returns>
      对应于 <paramref name="dwCode" /> 的单个字符。
    </returns>
    <remarks>
      Chr() 是 Asc() 的反函数。Chr() 用于多种常见任务，包括：
      &#0009;向屏幕或打印机发送控制代码和图形字符
      &#0009;发出蜂鸣声
      &#0009;将 InKey() 返回值转换为字符
      &#0009;填充键盘缓冲区
      Chr(0) 的长度为 1，被视为任何其他字符；这允许您将其发送到任何设备或文件，包括数据库文件。
      <note type="tip">
        _Chr() 是一个运算符，功能与 Chr() 函数相同。<br/>
        作为运算符，它在编译时进行评估，可以在 DEFINE、GLOBAL 或 STATIC LOCAL 语句中用于指定初始值。由于它不会产生函数调用的开销，因此效率更高。以下是一个示例：
        <code language="X#">DEFINE CRLF := _Chr(ASC_CR) + _Chr(ASC_LF)</code>
      </note>
    </remarks>
    <example>
      这些示例说明了使用不同参数的 Chr()：
      <code language="X#">
        ? Chr(Asc("A") + 32)&#0009;&#0009;// a
        ? Chr(7)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 发出蜂鸣声
        ? Chr(72)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// H
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Asc'>Asc</seealso>
  </chr>

  <classcount>
    <summary>
      返回应用程序可用的类的数量。
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例演示了 ClassCount() 的用法：
      <code language="X#">
        FUNCTION Start()
        &#0009;? ClassCount(), "个类可用。"
        &#0009;// 5 个类可用。
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ClassList'>ClassList</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTree'>ClassTree</seealso>
  </classcount>

  <classlist>
    <summary>
      返回一个符号数组，对应于应用程序可用的类。
    </summary>
    <returns>
      包含所有类名称作为符号的数组。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例说明了 ClassList() 的用法：
      <code language="X#">
        CLASS MyClass
        END CLASS...
        FUNCTION PrintClass()
        &#0009;LOCAL aClass AS ARRAY
        &#0009;aClass := ClassList()
        &#0009;// 预定义的系统类首先列出。
        &#0009;FOR i := 1 UPTO ALen(aClass)
        &#0009;&#0009;QOut(aClass[i])
        &#0009;NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ClassCount'>ClassCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTree'>ClassTree</seealso>
  </classlist>

  <classname>
    <summary>
      获取对象的类名。
    </summary>
    <param name="oObject">要获取类名的对象。</param>
    <returns>
      <paramref name="oObject" /> 所属的类。<br/>
      如果 <paramref name="oObject" /> 不是类的实例，则返回 NULL_SYMBOL。
    </returns>
    <remarks>
    </remarks>
    <example>
      这些示例说明了 ClassName() 的用法：
      <code language="X#">
        CLASS Person
        &#0009;EXPORT cName, cSign
        CONSTRUCTOR(tName, tSign)
        &#0009;cName := tName
        &#0009;cSign := tSign
        END CLASS
        CLASS Female INHERIT Person
        &#0009;EXPORT prefers
        END CLASS
        FUNCTION CheckClass()
        &#0009;LOCAL oY AS OBJECT
        &#0009;oY := Female{"女士", "精彩"}
        &#0009;IF ClassName(oY)&#0009;= #Female&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;
        &#0009;&#0009;? "这位女士属于 Female 类。"
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CheckInstanceOf'>CheckInstanceOf</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassCount'>ClassCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTree'>ClassTree</seealso>
  </classname>

  <classtree>
    <summary>
      获取对象的类层次结构。
    </summary>
    <param name="oObject">要获取类层次结构的对象。</param>
    <returns>
      一个包含 <paramref name="oObject" /> 所派生的类名称的数组。<br/>
      数组的最后一个元素包含根类，后续的类都从该根类继承。
    </returns>
    <remarks>
      ClassTree() 显示对象的类是否从其他类继承，如果有的话，显示继承自哪些类。
    </remarks>
    <example>
      这些示例说明了 ClassTree() 在多重继承情况下的使用：
      <code language="X#">
        CLASS Person
        &#0009;EXPORT name, sign
        CONSTRUCTOR(tName, tSign)
        &#0009;name := tName
        &#0009;sign := tSign
        END CLASS
        CLASS Male INHERIT Person
        &#0009;EXPORT prefers
        END CLASS
        CLASS OldMale INHERIT Male
        &#0009;EXPORT age
        END CLASS
        FUNCTION InheritanceTree()
        &#0009;LOCAL y AS OBJECT
        &#0009;LOCAL a AS ARRAY
        &#0009;y := OldMale{"Charlie", "dude"}
        &#0009;a := ClassTree(y)
        &#0009;? ArrayGet(a, 1)&#0009;&#0009;&#0009;// OLDMALE
        &#0009;? ArrayGet(a, 2)&#0009;&#0009;&#0009;// MALE
        &#0009;? ArrayGet(a, 3)&#0009;&#0009;&#0009;// PERSON
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ClassCount'>ClassCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassList'>ClassList</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassName'>ClassName</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTreeClass'>ClassTreeClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.OOPTree'>OOPTree</seealso>
    <seealso cref='O:XSharp.RT.Functions.OOPTreeClass'>OOPTreeClass</seealso>
  </classtree>

  <classtreeclass>
    <summary>
      获取类的层次结构。
    </summary>
    <param name="symClass">表示要获取类层次结构的类名的符号。</param>
    <returns>
      一个包含 <paramref name="symClass" /> 所派生的类名称的数组。<br/>
      数组的最后一个元素包含根类，后续的类都从该根类继承。
    </returns>
    <remarks>
      ClassTreeClass() 显示指定类是否从其他类继承，如果有的话，显示继承自哪些类。
    </remarks>
    <example>
      这些示例说明了 ClassTreeClass() 在多重继承情况下的使用：
      <code language="X#">
        CLASS Person
        &#0009;EXPORT name, sign
        CONSTRUCTOR(tName, tSign)
        &#0009;name := tName
        &#0009;sign := tSign
        END CLASS

        CLASS Male INHERIT Person
        &#0009;EXPORT prefers
        END CLASS
        CLASS OldMale INHERIT Male
        &#0009;EXPORT age
        END CLASS
        FUNCTION InheritanceTree()
        &#0009;LOCAL a AS ARRAY
      </code>
      &#0009;
      <code language="X#">
        &#0009;a := ClassTreeClass(#OldMale)
        &#0009;? ArrayGet(a, 1)&#0009;&#0009;&#0009;// OLDMALE
        &#0009;? ArrayGet(a, 2)&#0009;&#0009;&#0009;// MALE
        &#0009;? ArrayGet(a, 3)&#0009;&#0009;&#0009;// PERSON
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ClassCount'>ClassCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassList'>ClassList</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassName'>ClassName</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTreeClass'>ClassTreeClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.OOPTree'>OOPTree</seealso>
    <seealso cref='O:XSharp.RT.Functions.OOPTreeClass'>OOPTreeClass</seealso>
  </classtreeclass>

  <cls>
    <summary>
      清除终端窗口并将光标定位到第0行第0列。
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      这些例子说明了 CLS() 的用法：
      <code language="X#">
        FUNCTION Start()
        QOut("清除屏幕。")
        WAIT
        CLS()
        RETURN
      </code>
    </example>
  </cls>

  <cmonth>
    <summary>
      从日期中提取月份名称。
    </summary>
    <param name="dDate">要从中提取月份的日期。</param>
    <returns>
      月份名称，其中第一个字母大写，其余字符小写。<br/>
      对于无效或 NULL_DATE，CMonth() 返回 NULL_STRING。
    </returns>
    <remarks>
      CMonth() 是一个日期转换函数，用于创建可在报告、标签、屏幕等中使用的格式化日期字符串。<br/>
      此函数与国家/地区相关。
    </remarks>
    <example>
      以下示例说明了 CMonth() 的用法：
      <code language="X#">
        ? CMonth(Today())&#0009;&#0009;&#0009;&#0009;&#0009;// 九月
        ? CMonth(Today() + 45)&#0009;&#0009;&#0009;&#0009;// 十月
        ? Substr3(CMonth(Today()), 1, 3) +;
        &#0009;Str(Day(Today()))&#0009;&#0009;&#0009;// 九月 1
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CDoW'>CDoW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Day'>Day</seealso>
    <seealso cref='O:XSharp.RT.Functions.Month'>Month</seealso>
    <seealso cref='O:XSharp.Core.Functions.NToCMonth'>NToCMonth</seealso>
    <seealso cref='O:XSharp.RT.Functions.Today'>Today</seealso>
    <seealso cref='O:XSharp.RT.Functions.Year'>Year</seealso>
  </cmonth>

  <col>
    <summary>
      返回终端窗口中光标的当前列位置。
    </summary>
    <returns>
      光标当前所在的列。<br/>
      此值的范围从0到MaxCol()。
    </returns>
    <remarks>
      每当终端窗口中的光标位置发生变化时，Col()返回的值都会改变；例如，控制台和全屏命令都可以改变光标位置。此外，每当执行CLEAR、CLEAR SCREEN或CLS()时，Col()会自动设置为0。
    </remarks>
    <example>
      此示例在指定的行和列显示文件名：
      <code language="X#">
        FUNCTION Start()
        LOCAL cErrorMessage AS STRING
        LOCAL cFileName AS STRING
        cErrorMessage := "未找到文件。"
        cFileName := "customer.dbf"
        SetPos(1, 10)
        QQout(cFileName)
        SetPos(Row(), Col() + 2)
        QQOut(cErrorMessage)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.cls'>CLS</seealso>
    <seealso cref='O:XSharp.RT.Functions.QOut'>QOut</seealso>
    <seealso cref='O:XSharp.RT.Functions.Row'>Row</seealso>
  </col>

  <collect>
    <summary>
      如果达到水位线，则调用垃圾收集器。
    </summary>
    <returns>
    </returns>
    <remarks>
      当达到水位线时，Collect() 会调用垃圾收集器。<br/>
      水位线是系统确定适合进行垃圾收集的点。
      字面量或硬编码的字符串是静态的，不能被收集。动态字符串可以被收集。<br/>
      例如，在 MyFunc("hello") 中，字面量字符串 "hello" 不可收集，而在 MyFunc(Time()) 中，Time() 返回的字符串是可收集的。
      字符串、浮点数、数组和对象都是动态的、可收集的对象，除非它们是字面量。
    </remarks>
    <example>
      这些例子说明了 Collect() 的用法：
      <code language="X#">
        ? CollectCount()&#0009;&#0009;// 4
        Collect()
        ? CollectCount()&#0009;&#0009;// 这可能是 5 或 4
        &#0009;&#0009;&#0009;&#0009;&#0009;// 取决于是否执行了垃圾收集
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CollectCount'>CollectCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.CollectForced'>CollectForced</seealso>
    <seealso cref='O:XSharp.VO.Functions.Memory'>Memory</seealso>
    <seealso cref='O:XSharp.RT.Functions.RegisterAxit'>RegisterAxit</seealso>
    <seealso cref='O:XSharp.VO.Functions.RegisterKid'>RegisterKid</seealso>
  </collect>

  <collectcount>
    <summary>
      计算系统执行的垃圾回收次数。
    </summary>
    <returns>
      垃圾回收的次数。
    </returns>
    <remarks>
      CollectCount() 确定应用程序中执行垃圾回收的次数。<br/>
      这告诉你系统资源中有多少被用于垃圾回收。<br/>
      如果垃圾回收器被过于频繁地调用，可能意味着内存不足，从而导致性能下降。
      CollectCount() 与 Memory(MEMORY_COLLECT) 的功能相同。
    </remarks>
    <example>
      这些示例显示每次调用 CollectForced() 后，CollectCount() 的返回值增加1：
      <code language="X#">
        ? CollectCount()&#0009;&#0009;&#0009;// 1
        CollectForced()
        ? CollectCount()&#0009;&#0009;&#0009;// 2
        CollectForced()
        ? CollectCount()&#0009;&#0009;&#0009;// 3
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Collect'>Collect</seealso>
    <seealso cref='O:XSharp.RT.Functions.CollectForced'>CollectForced</seealso>
    <seealso cref='O:XSharp.VO.Functions.Memory'>Memory</seealso>
  </collectcount>

  <collectforced>
    <summary>
      调用垃圾收集器。
    </summary>
    <returns>
    </returns>
    <remarks>
      CollectForced() 调用垃圾收集器，无论是否达到水位线。
      字面量或硬编码的字符串是静态的，不能被收集。动态字符串可以被收集。<br/>
      例如，在 MyFunc("hello") 中，字面量字符串 "hello" 不可收集，而在 MyFunc(Time()) 中，Time() 返回的字符串是可收集的。
      字符串、浮点数、数组和对象都是动态的、可收集的对象，除非它们是字面量。
    </remarks>
    <example>
      这些例子说明了 CollectForced() 的用法：
      <code language="X#">
        ? CollectCount()&#0009;&#0009;&#0009;&#0009;// 1
        CollectForced()
        ? CollectCount()&#0009;&#0009;&#0009;&#0009;// 2
        CollectForced()
        ? CollectCount()&#0009;&#0009;&#0009;&#0009;// 3
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Collect'>Collect</seealso>
    <seealso cref='O:XSharp.RT.Functions.CollectCount'>CollectCount</seealso>
  </collectforced>

  <concatatom>
    <summary>
      连接两个符号。
    </summary>
    <param name="s1">要连接的第一个符号。</param>
    <param name="s2">要连接的第二个符号。</param>
    <returns>
      连接后的符号。<br/>
      如果该符号不存在于原子表中，则会被添加进去。
    </returns>
    <remarks>
      ConcatAtom() 允许您连接两个符号，类似于使用"+"运算符连接字符串的方式。
      要执行更复杂的字符串操作，请将符号转换为字符串（使用Symbol2String()）。
    </remarks>
    <example>
      以下示例说明了ConcatAtom()的用法：
      <code language="X#">
        ? ConcatAtom(#HEL, #LO)&#0009;&#0009;&#0009;// #HELLO
        ? ConcatAtom(#GOOD,#BYE) = #GOODBYE&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ConcatAtom3'>ConcatAtom3</seealso>
  </concatatom>

  <concatatom3>
    <summary>
      连接三个符号。
    </summary>
    <param name="s1">要连接的第一个符号。</param>
    <param name="s2">要连接的第二个符号。</param>
    <param name="s3">要连接的第三个符号。</param>
    <returns>
      连接后的符号。<br/>
      如果该符号不存在于原子表中，则会被添加进去。
    </returns>
    <remarks>
      ConcatAtom3() 允许您连接3个符号，类似于使用"+"运算符连接字符串的方式。
      要执行更复杂的字符串操作，请将符号转换为字符串（使用Symbol2String()）。
    </remarks>
    <example>
      以下示例说明了ConcatAtom3()的用法：
      <code language="X#">
        ? ConcatAtom3(#UN,#BELIEV,#ABLE)&#0009;
        &#0009;// UNBELIEVABLE
        ? ConcatAtom3(#GOOD,#BYE,#GIRL) = #GOODBYEGIRL
        &#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ConcatAtom'>ConcatAtom</seealso>
  </concatatom3>

  <concatatom4>
    <summary>
      连接四个符号。
    </summary>
    <param name="s1">要连接的第一个符号。</param>
    <param name="s2">要连接的第二个符号。</param>
    <param name="s3">要连接的第三个符号。</param>
    <param name="s4">要连接的第四个符号。</param>
    <returns>
      连接后的符号。<br/>
      如果该符号不存在于原子表中，则会被添加进去。
    </returns>
    <remarks>
      ConcatAtom4() 允许您连接4个符号，类似于使用"+"运算符连接字符串的方式。
      要执行更复杂的字符串操作，请将符号转换为字符串（使用Symbol2String()）。
    </remarks>
    <seealso cref='O:XSharp.RT.Functions.ConcatAtom'>ConcatAtom</seealso>
  </concatatom4>

  <concatatom5>
    <summary>
      连接五个符号。
    </summary>
    <param name="s1">要连接的第一个符号。</param>
    <param name="s2">要连接的第二个符号。</param>
    <param name="s3">要连接的第三个符号。</param>
    <param name="s4">要连接的第四个符号。</param>
    <param name="s5">要连接的第五个符号。</param>
    <returns>
      连接后的符号。<br/>
      如果该符号不存在于原子表中，则会被添加进去。
    </returns>
    <remarks>
      ConcatAtom5() 允许您连接5个符号，类似于使用"+"运算符连接字符串的方式。
      要执行更复杂的字符串操作，请将符号转换为字符串（使用Symbol2String()）。
    </remarks>
    <seealso cref='O:XSharp.RT.Functions.ConcatAtom'>ConcatAtom</seealso>
  </concatatom5>

  <condate>
    <summary>
      将表示年、月和日的一组数字格式化为日期。
    </summary>
    <param name="dwYear">
      有效的年份。<br/>
      如果未指定世纪数字，则根据 SetEpoch() 的规则确定世纪。
    </param>
    <param name="dwMonth">表示有效月份的 1 到 12 之间的数字。</param>
    <param name="dwDay">
      表示 <paramref name="dwMonth" /> 中有效日期的数字。
    </param>
    <returns>
      对应于传入参数的日期。<br/>
      如果指定的任何参数不代表有效的年、月或日，则返回 NULL_DATE。
    </returns>
    <remarks>
      ConDate() 将给定的数字转换为日期。<br/>
      日期的显示由 SetCentury() 控制。
    </remarks>
    <example>
      以下示例说明了 ConDate() 的用法：
      <code language="X#">
        ? ConDate(93, 10, 25)&#0009;&#0009;// 10/25/93
        ? ConDate(2093, 10, 25)&#0009;&#0009;// 10/25/93
        ? SetCentury(TRUE)
        ? ConDate(2093, 10, 25)&#0009;&#0009;// 10/25/2093
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ConTime'>ConTime</seealso>
    <seealso cref='O:XSharp.Core.Functions.Days'>Days</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetCentury'>SetCentury</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetEpoch'>SetEpoch</seealso>
  </condate>

  <contime>
    <summary>
      将表示小时、分钟和秒的一组数字格式化为时间字符串。
    </summary>
    <param name="dwHour">小时数，最多23。</param>
    <param name="dwMinute">分钟数，最多59。</param>
    <param name="dwSeconds">秒数，最多59。</param>
    <returns>
      一个与传入参数对应的（军用）时间，格式为HH:MO:SS，不带AM/PM标记。
    </returns>
    <remarks>
    </remarks>
    <example>
      以下示例说明了ConTime()的用法：
      <code language="X#">
        ? ConTime(10, 59, 59)&#0009;&#0009;// 10:59:59
        ? ConTime(22, 59, 59)&#0009;&#0009;// 22:59:59
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AmPm'>AmPm</seealso>
    <seealso cref='O:XSharp.RT.Functions.ConDate'>ConDate</seealso>
    <seealso cref='O:XSharp.Core.Functions.ElapTime'>ElapTime</seealso>
    <seealso cref='O:XSharp.Core.Functions.Seconds'>Seconds</seealso>
    <seealso cref='O:XSharp.Core.Functions.Secs'>Secs</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetTimeSep'>SetTimeSep</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
    <seealso cref='O:XSharp.RT.Functions.TString'>TString</seealso>
  </contime>

  <cos>
    <summary>
      计算数字的余弦值。
    </summary>
    <param name="nNum">以弧度表示的角度。</param>
    <returns>
      指定角度的余弦值。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 Cos() 计算 0 和 PI 的余弦值：
      <code language="X#">
        ? Cos(0)&#0009;&#0009;&#0009;&#0009;//  1.00
        ? Cos(PI)&#0009;&#0009;&#0009;&#0009;&#0009;// -1.00
      </code>
      此示例计算 60 度角的余弦值。<br/>
      第一步是将 60 度转换为弧度。<br/>
      这是通过将角度除以 180/PI 来完成的：
      <code language="X#">? Cos(60/(180/PI))&#0009;&#0009;//  0.50</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Cot'>Cot</seealso>
    <seealso cref='O:XSharp.RT.Functions.Sin'>Sin</seealso>
    <seealso cref='O:XSharp.RT.Functions.Tan'>Tan</seealso>
  </cos>

  <cot>
    <summary>
      计算一个值的余切。
    </summary>
    <param name="nNum">以弧度表示的角度。</param>
    <returns>
      指定角度的余切值。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 Cot() 来展示余切等于余弦除以正弦：
      <code language="X#">
        ? Cot(1.5)&#0009;&#0009;&#0009;&#0009;// 0.07
        ? Cos(1.5)&#0009;&#0009;&#0009;&#0009;// 0.07
        ? Sin(1.5)&#0009;&#0009;&#0009;&#0009;// 1.00
        ? Cos(1.5) / Sin(1.5)&#0009;&#0009;// 0.07
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ACot'>ACot</seealso>
    <seealso cref='O:XSharp.RT.Functions.ATan'>ATan</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cos'>Cos</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cot'>Cot</seealso>
    <seealso cref='O:XSharp.RT.Functions.Sin'>Sin</seealso>
    <seealso cref='O:XSharp.RT.Functions.Tan'>Tan</seealso>
  </cot>

  <cparamcount>
    <summary>
      返回代码块期望的参数数量。
    </summary>
    <param name="oCodeBlock">要检查的代码块。</param>
    <returns>
      <paramref name="oCodeBlock" /> 期望的参数数量。
    </returns>
    <remarks>
      当打印代码块时（通过像 QOut() 这样的函数），参数数量会以十六进制表示法显示在代码块的 | | 对中。
    </remarks>
    <example>
      这个例子使用 CParamCount() 来确定要执行什么计算：
      <code language="X#">
        DEFINE N_LENGTH := 10
        DEFINE N_WIDTH  :=  5
        DEFINE N_HEIGHT :=  2
        Function Start()
        &#0009;LOCAL cbRectangle AS CODEBLOCK
        &#0009;cbRectangle := {|x, y| x * y}
        &#0009;? Size(cbRectangle)&#0009;&#0009;&#0009;// 50
        &#0009;RETURN TRUE
        FUNCTION Size(cbArea) AS LONGINT
        &#0009;LOCAL siDimensions AS SHORTINT
        &#0009;LOCAL liArea AS LONGINT
        &#0009;siDimensions := CParamCount(cbArea)
        &#0009;DO CASE
        &#0009;CASE siDimensions = 1&#0009;&#0009;// Length
        &#0009;&#0009;liArea := Eval(cbArea, N_LENGTH)
        &#0009;CASE siDimensions = 2&#0009;&#0009;// Area
        &#0009;&#0009;liArea := Eval(cbArea, N_LENGTH, N_WIDTH)
        &#0009;CASE siDimensions = 3&#0009;&#0009;// Volume
        &#0009;&#0009;liArea := Eval(cbArea, N_LENGTH, N_WIDTH,;
        &#0009;&#0009;&#0009;N_HEIGHT)
        &#0009;ENDCASE
        &#0009;RETURN liArea
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FParamCount'>FParamCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.MParamCount'>MParamCount</seealso>
  </cparamcount>

  <createinstance>
    <summary>
      创建一个对象。
    </summary>
    <param name="type">描述需要创建的对象的类型对象。</param>
    <param name="symClassName">要为其创建对象的类的名称。</param>
    <param name="InitArgList">
      传递给 <paramref name="symClassName" /> 的 Init() 方法的参数列表，以逗号分隔（参见下面的示例）。
    </param>
    <returns>
    </returns>
    <remarks>
      CreateInstance() 是以函数方式创建特定类的对象的方法。<br/>
      它本质上与通过 {} 调用创建对象相同，但在需要函数形式的情况下很有用。
    </remarks>
    <example>
      这个示例展示了如何使用 CreateInstance() 创建对象：
      <code language="X#">
        CLASS Person
        &#0009;EXPORT name, sign
        CONSTRUCTOR(tName, tSign)
        &#0009;name := tName
        &#0009;sign := tSign
        END CLASS

        FUNCTION Start()
        &#0009;LOCAL x AS OBJECT
        &#0009;// 将类名作为符号传递，并且
        &#0009;// 指定所有 Init() 方法参数。
        &#0009;x :=  CreateInstance(#PERSON, "Odile", "H")
        &#0009;? x:name&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Odile
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IsInstanceOf'>IsInstanceOf</seealso>
  </createinstance>

  <createvothread>
    <summary>
      创建一个新线程。
    </summary>
    <param name="pSecAttr">
      指向 _WINSECURITY_ATTRIBUTES 结构的指针，该结构决定返回的句柄是否可以被子进程继承。<br/>
      如果 lpThreadAttributes 为 NULL，则句柄不能被继承。<br/>
      更多信息，请参见 WIN32 函数 CreateThread()。
    </param>
    <param name="nStackSize">
      新线程的堆栈大小（以字节为单位）。<br/>
      如果此参数为 0，则堆栈大小默认为与进程的主线程相同的大小。
    </param>
    <param name="pFunc">
      新线程的入口点，通常是使用 PASCAL 调用约定声明的函数的地址。<br/>
      其原型为：ThreadFunc( pArguments AS PTR ) AS DWORD PASCAL。
    </param>
    <param name="pParam">
      作为参数传递给线程入口点 <paramref name="pFunc" /> 的指针或任何其他 32 位参数。
    </param>
    <param name="dwFlags">
      控制线程创建的附加标志。<br/>
      &#0009;注意：有关 WIN32 函数 CreateThread() 的详细信息，请查阅 Microsoft Win32 软件开发工具包文档。
    </param>
    <param name="pdwID">接收线程标识符的 DWORD 指针。</param>
    <returns>
      如果成功，返回新线程的句柄；否则，返回 NULL_PTR。
    </returns>
    <remarks>
      CreateVOThread() 是 Win32 函数 CreateThread() 的包装函数。在通知运行时由 X# 进程创建了新线程后，所有参数都会传递给该函数。
    </remarks>
    <example>
      以下示例展示了三个不同的线程：
      <code language="X#">
        STRUCT _THREADDATA
        &#0009;MEMBER nThread<br/>
        AS INT
        &#0009;// MEMBER xy  <br/>
        AS ...
        FUNC Start
        &#0009;LOCAL DIM adw[3]  <br/>
        AS PTR
        &#0009;LOCAL DIM pData[3]<br/>
        AS PTR
        &#0009;LOCAL pTData      <br/>
        AS _THREADDATA
        &#0009;LOCAL i             AS DWORD
        &#0009;LOCAL nID           AS DWORD
      </code>
      &#0009;
      <code language="X#">
        &#0009;FOR i := 1 TO 3
        &#0009;&#0009;pTData := MemAlloc(_SIZEOF(_THREADDATA))
        &#0009;&#0009;IF pTData != NULL_PTR
        &#0009; &#0009;&#0009;pTData.nThread := i
        &#0009; &#0009;&#0009;pData[i] := pTData
        &#0009;&#0009;ENDIF
        &#0009;&#0009;adw[i] := CreateVOThread( NULL_PTR, 0,;
        @__ThreadFunc(),;
        pTData, 0,;
        @nID )
        &#0009;NEXT
        &#0009;WaitForMultipleObjects( 3, @adw, TRUE, INFINITE )
        &#0009;FOR i := 1 TO 3
        &#0009;&#0009;IF pData[i] != NULL_PTR
        &#0009;&#0009; MemFree(pData[i])
        &#0009;&#0009;ENDIF
        &#0009;NEXT
        &#0009;WAIT "DONE"
        &#0009;RETURN NIL
        STATIC FUNC __ThreadFunc ( pTData AS _THREADDATA )<br/>
        AS DWORD PASCAL
        &#0009;LOCAL i   AS DWORD
        &#0009;LOCAL n   AS DWORD
        &#0009;n := pTData.nThread
        &#0009;FOR i := 1 TO 100
        &#0009;&#0009;_DebOut32("Thread " + NTrim(n) )
        &#0009;&#0009; Sleep(1)
        &#0009;NEXT
        &#0009;ExitVOThread(0)
      </code>
    </example>
  </createvothread>

  <crypt>
    <summary>
      加密或解密字符串。
    </summary>
    <param name="cSource">将被加密或解密的字符串。</param>
    <param name="cKey">要使用的加密/解密密钥。</param>
    <returns>
      加密/解密后的字符串。
    </returns>
    <remarks>
      此函数可用于加密或解密任何字符串。请注意，加密密钥对于之后解密字符串非常重要。没有正确的密钥（即用于加密字符串的相同密钥），数据将无法使用。
    </remarks>
    <example>
      此示例将加密一个字符串，然后解密该字符串：
      <code language="X#">
        LOCAL a, b, c AS STRING
        LOCAL cKey as STRING
        a := "敏捷的棕色狐狸跳过懒惰的狗。"
        cKey := "猫"
        b := Crypt(a, cKey)
        c := Crypt(b, cKey)
        ? a&#0009;&#0009;// 敏捷的棕色狐狸跳过懒惰的狗。
        ? b&#0009;&#0009;// ú¿C_6g[‡N%ì*„k ÙYñƒ---à-øÃFé†ÈbÓÈã_ø´Ù¢ù½Ÿ
        ? c&#0009;&#0009;// 敏捷的棕色狐狸跳过懒惰的狗。
      </code>
    </example>
  </crypt>

  <crypta>
    <summary>
      加密或解密字符串，同时改变原始字符串的内容并返回加密后的字符串。
    </summary>
    <param name="cSource">将被加密或解密的字符串。</param>
    <param name="cKey">要使用的加密/解密密钥。</param>
    <returns>
      加密/解密后的字符串。
    </returns>
    <remarks>
      此函数与Crypt()相同，但它还会更改原始字符串<paramref name="cSource" />。请注意，加密密钥对于之后解密字符串非常重要。没有正确的密钥（即用于加密字符串的相同密钥），数据将无法使用。
    </remarks>
    <example>
      此示例将加密一个字符串，然后解密该字符串：
      <code language="X#">
        LOCAL a AS STRING
        LOCAL cKey as STRING
        a := "敏捷的棕色狐狸跳过懒惰的狗。"
        cKey := "猫"
        ? a
        // 敏捷的棕色狐狸跳过懒惰的狗。
        ? CryptA(a, cKey)
        // ú¿C_6g[‡N%ì*„k ÙYñƒ---à-øÃFé†ÈbÓÈã_ø´Ù¢ù½Ÿ
        ? a
        // ú¿C_6g[‡N%ì*„k ÙYñƒ---à- øÃFé†ÈbÓÈã_ø´Ù¢ù½Ÿ
        CryptA(a, cKey)
        ? a
        // 敏捷的棕色狐狸跳过懒惰的狗。
      </code>
    </example>
  </crypta>

  <ctod>
    <summary>
      将日期字符串转换为日期格式。
    </summary>
    <param name="cDate">
      表示月、日和年的数字字符串，用任何非数字字符分隔。
      月、日和年的数字必须符合由 SetDateFormat() 或 SetDateCountry() 设置的格式。
      如果未指定世纪数字，则根据 SetEpoch() 的规则确定世纪。
    </param>
    <returns>
      与 <paramref name="cDate" /> 中指定数字对应的日期值。<br/>
      如果 <paramref name="cDate" /> 不是有效日期，CToD() 返回 NULL_DATE。
    </returns>
    <remarks>
      CToD() 是一个字符转换函数，将最初格式化为字符串的日期值转换为日期数据类型。<br/>

      要初始化 NULL_DATE，请将 <paramref name="cDate" /> 指定为 NULL_STRING。但请记住，您可以获得空日期（甚至非空日期），而无需产生函数调用开销，只需指定日期字面值，如 92.07.22。<br/>

      此外，当强类型变量声明为 DATE 类型时，它会自动初始化为空日期。
      CToD() 是 DToC() 的反函数，后者将日期值转换为字符串。<br/>

      DToS() 也将日期值转换为字符串，由于它采用 yyyymmdd 的形式，通常是与字符串组合索引日期的首选形式。
    </remarks>
    <example>
      此示例简单地将 CToD() 应用于字符串：
      <code language="X#">? CToD("05/15/64")&#0009;&#0009;&#0009;&#0009;&#0009;// 05/15/64</code>
      此示例比较 CToD() 的返回值与硬编码日期：
      <code language="X#">? CToD("05/15/64") = 64.05.15&#0009;&#0009;// .T.</code>
      此示例显示声明的强类型 DATE 变量被初始化为空日期：
      <code language="X#">
        LOCAL dInit AS DATE
        ? CToD(NULL_STRING) = dInit&#0009;&#0009;&#0009;// .T.
        ? CToD(NULL_STRING) = NULL_DATE&#0009;&#0009;// .T.
      </code>
      此示例演示了 CToD() 和 DToC() 之间的反向关系：
      <code language="X#">? CToD(DToC(Today())) = Today()&#0009;&#0009;// .T.</code>
    </example>
  </ctod>

  <ctodansi>
    <summary>
      将ANSI日期字符串转换为日期格式。
    </summary>
    <param name="cDate">
      一个ANSI格式的字符串，形式为yyyy.mm.dd，其中yy、mm和dd分别代表年、月和日。<br/>

      年、月和日可以用任何非数字字符分隔。<br/>

      <paramref name="cDate" />始终被解释为ANSI字符串，不依赖于SetDateFormat()或SetDateCountry()。<br/>

      如果未指定世纪数字，则根据SetEpoch()的规则确定世纪。
    </param>
    <returns>
      与<paramref name="cDate" />中指定数字对应的日期值。<br/>

      如果<paramref name="cDate" />不是有效的ANSI日期，CToDAnsi()返回NULL_DATE。
    </returns>
    <remarks>
      CToDAnsi()是一个字符转换函数，将ANSI日期字符串转换为日期数据类型。
    </remarks>
    <example>
      这个例子简单地将CToDAnsi()应用于一个字符串：
      <code language="X#">? CToDAnsi("84/10/23")&#0009;&#0009;&#0009;&#0009;// 10/23/84</code>
      这个例子展示了SetCentury()的效果：
      <code language="X#">
        SetCentury(TRUE)
        ? CToDAnsi("2084/10/23")&#0009;&#0009;&#0009;&#0009;// 10/23/2084
        ? CToDAnsi("90$05$14")&#0009;&#0009;&#0009;&#0009;// 05/14/1990
      </code>
      这个例子展示了CToDAnsi()不依赖于国家设置：
      <code language="X#">
        SetDateCountry(GERMAN)
        ? CToDAnsi("84/10/23")&#0009;&#0009;&#0009;&#0009;// 23.10.1984
      </code>
    </example>
  </ctodansi>

  <curdir>
    <summary>
      返回当前 Windows 目录。
    </summary>
    <param name="cDrive">
      要查询的磁盘驱动器的字母。<br/>
      SetDefault() 被忽略；除非您指定了驱动器，否则使用 Windows 默认值。
    </param>
    <returns>
      由 <paramref name="cDrive" /> 指定的驱动器的当前目录，不包含前导或尾随反斜杠 (\) 字符。
      <br/>
      如果发生错误，或指定驱动器的当前目录是根目录，CurDir() 返回 NULL_STRING。
      请注意，其他 Windows 任务可能会更改非默认驱动器的当前目录，从而影响使用 CurDir() 查询非默认驱动器时的返回值。
    </returns>
    <remarks>
    </remarks>
    <example>
      这些示例说明了各种 CurDir() 结果：
      <code language="X#">
        ? CurDir("e:")&#0009;&#0009;// NULL_STRING，根目录
        ? CurDir("c")&#0009;&#0009;&#0009;// vo\source
        ? CurDir("c:")&#0009;&#0009;&#0009;// vo\source
        ? CurDir()&#0009;&#0009;&#0009;// NULL_STRING，根目录
        ? CurDir("a")&#0009;&#0009;&#0009;// NULL_STRING，驱动器未就绪
      </code>
      此示例在当前 Windows 目录与指定目录不匹配时将其更改为新值：
      <code language="X#">
        IF CurDir("c:") != "vo\source"
        &#0009;DirChange("\vo\source")
        ENDIF
      </code>
    </example>
  </curdir>

  <curdrive>
    <summary>
      返回当前 Windows 驱动器。
    </summary>
    <returns>
      当前驱动器的字母，不包含尾随冒号。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例说明了 CurDrive() 和 DiskChange() 之间的关系，并显示 CurDrive() 不受 SetDefault() 影响：
      <code language="X#">
        FUNCTION DriveTest()
        &#0009;? CurDrive()&#0009;&#0009;&#0009;// C
        &#0009;SetDefault("A")
        &#0009;? CurDrive()&#0009;&#0009;&#0009;// C
        &#0009;DiskChange("A")
        &#0009;? CurDrive()&#0009;&#0009;&#0009;// A
        &#0009;DiskChange("C")
        &#0009;? CurDrive()&#0009;&#0009;&#0009;// C
      </code>
    </example>
  </curdrive>

  <date2bin>
    <summary>
      将日期转换为32位二进制日期字符串。
    </summary>
    <param name="dValue">要转换的日期值。</param>
    <returns>
    </returns>
    <remarks>
      Date2Bin() 是一个转换函数，将日期数据类型转换为4字节字符串。典型应用包括以原生格式读取外部文件类型，然后以压缩的二进制形式而非字符串形式保存、读取、解密和传输日期类型。<br/>
      其逆函数是 Bin2Date()。
    </remarks>
    <example>
      此示例使用 Date2Bin() 将今天的日期记录到调试文件中：
      <code language="X#">
        FUNCTION RecordDate() AS LOGIC
        &#0009;LOCAL nh
        &#0009;LOCAL lSuccess := FALSE AS LOGIC
        &#0009;nh := FOpen2("debug.doc", FO_READWRITE)
        &#0009;// 假设 debug.doc 文件已存在
        &#0009;IF nh != F_ERROR
        &#0009;&#0009;FWrite(nh, Date2Bin(Today()))
        &#0009;&#0009;FClose(nh)
        &#0009;&#0009;lSuccess := TRUE
        &#0009;ELSE
        &#0009;&#0009;? "打开 debug.doc 时发生错误"
        &#0009;&#0009;? FError()
        &#0009;ENDIF
        &#0009;RETURN lSuccess
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </date2bin>

  <day>
    <summary>
      从日期中提取月份中的日期数。
    </summary>
    <param name="dDate">日期。</param>
    <returns>
      月份中的日期，范围为 0 到 31 的数字。<br/>
      如果日期是 2 月 29 日且该年不是闰年，Day() 返回 0。<br/>
      对于无效或 NULL_DATE，Day() 返回 0。
    </returns>
    <remarks>
      Day() 是一个日期转换函数，当您在计算中需要数字形式的日期值时非常有用，例如用于周期性报告。
      Day() 是返回日期值组成部分为数字的一组函数中的成员。<br/>
      该组还包括 Month() 和 Year()，用于将月份和年份值返回为数字。<br/>
      CDoW() 是一个相关函数，允许您从日期值返回星期几的名称。
    </remarks>
    <example>
      这些示例展示了 Day() 函数的几种使用方式：
      <code language="X#">
        ? Today()&#0009;&#0009;&#0009;&#0009;&#0009;// 09/01/90
        ? Day(Today())&#0009;&#0009;&#0009;&#0009;// 1
        ? Day(Today()) + 1&#0009;&#0009;&#0009;// 2
        ? Day(0.0.0)&#0009;&#0009;&#0009;&#0009;&#0009;// 0
      </code>
      此示例结合使用 Day()、CMonth() 和 Year() 来格式化日期值：
      <code language="X#">
        ? CMonth(Today()) + Str(Day(Today())) + ;
        &#0009;"," + Str(Year(Today()))&#0009;&#0009;// June 15, 1990
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CDoW'>CDoW</seealso>
    <seealso cref='O:XSharp.RT.Functions.CMonth'>CMonth</seealso>
    <seealso cref='O:XSharp.RT.Functions.DoW'>DoW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Month'>Month</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Today'>Today</seealso>
    <seealso cref='O:XSharp.RT.Functions.Year'>Year</seealso>
  </day>

  <days>
    <summary>
      将指定的秒数转换为天数。
    </summary>
    <param name="nSeconds">要转换为天数的秒数。</param>
    <returns>
      四舍五入到最接近的天数。
    </returns>
    <remarks>
      Days() 函数将给定的秒数转换为整数天数。<br/>
      不足24小时的剩余部分可以通过 TString() 函数获得（参见下面的示例）。
    </remarks>
    <example>
      这个例子使用 Days() 和 TString() 函数来显示 300,000 秒等于 3 天 11 小时 20 分钟：
      <code language="X#">
        ? Days(300000)&#0009;&#0009;&#0009;&#0009;// 3
        ? TString(300000)&#0009;&#0009;&#0009;// 11:20:00
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.TString'>TString</seealso>
  </days>

  <dbapp>
    <summary>
      从数据库文件导入记录。
    </summary>
    <param name="cSourceFile">
      要添加记录的数据库文件名，包括可选的驱动器、目录和扩展名。<br/>
      有关文件搜索和创建规则，请参见 SetDefault() 和 SetPath()。<br/>
      数据库文件的默认扩展名由 RDD 确定。<br/>
      此函数尝试以共享模式打开 <paramref name="cSourceFile" />。<br/>
      如果文件不存在，则引发运行时错误。<br/>
      如果文件成功打开，操作继续进行。<br/>
      如果由于另一个进程独占使用该文件等原因而被拒绝访问，NetErr() 将被设置为 TRUE。
    </param>
    <param name="acFields">
      要从 <paramref name="cSourceFile" /> 追加的字段列表。<br/>
      默认为所有字段。<br/>
      只有两个文件中名称和类型相同的字段才会被追加。<br/>
      如果同名字段的数据类型不匹配，将引发运行时错误。
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <param name="cDriver">
      将为工作区提供服务的 RDD 的名称。<br/>
      如果未指定，则使用由 RDDSetDefault() 确定的默认 RDD。
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/acrdds/*"/>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      默认情况下，此函数向当前选定工作区中的数据库文件添加记录。<br/>
      通过在别名表达式中指定，可以使其在未选定的工作区上操作。
      DBApp() 不要求数据库文件被独占使用或通过 FLock() 锁定来执行其操作。<br/>
      在添加每条记录时，X# 自动仲裁新记录的争用。
      DBApp() 在功能上等同于不带 DELIMITED 或 SDF 子句的 APPEND FROM 命令。
    </remarks>
    <example>
      以下示例从 OLD.DBF 文件添加记录：
      <code language="X#">DBApp("old.dbf")</code>
    </example>
    <seealsocmd>APPEND FROM</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbAppDelim'>DBAppDelim</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbAppSdf'>DBAppSDF</seealso>
    <seealso cref='O:VO.DbServer.AppendDB'>DBServer:AppendDB 方法</seealso>
  </dbapp>

  <dbappdelim>
    <summary>
      从分隔文本文件导入记录。
    </summary>
    <param name="cSourceFile">
      要添加记录的分隔文本文件名，包括可选的驱动器、目录和扩展名。<br/>
      有关文件搜索和创建规则，请参见 SetDefault() 和 SetPath()。<br/>
      默认扩展名为 .TXT。<br/>
      此函数尝试以共享模式打开 <paramref name="cSourceFile" />。<br/>
      如果文件不存在，则引发运行时错误。<br/>
      如果文件成功打开，操作继续进行。<br/>
      如果由于另一个进程独占使用该文件等原因而被拒绝访问，NetErr() 将被设置为 TRUE。
    </param>
    <param name="cDelim">
      用于分隔 <paramref name="cSourceFile" /> 中字段的分隔符。<br/>
      默认分隔符是双引号。
    </param>
    <param name="acFields">
      要从 <paramref name="cSourceFile" /> 复制的字段列表。<br/>
      默认为所有字段。
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      DBAppDelim() 在功能上等同于 APPEND FROM DELIMITED 命令。
      它与 DBApp() 函数相同，只是它只能用于文本文件。<br/>
      更多信息请参见 APPEND FROM 和 DBApp()。
    </remarks>
    <example>
      以下示例从名为 SRCDELIM.TXT 的文本文件追加记录：
      <code language="X#">
        USE test NEW
        DBAppDelim("srcdelim.txt")
      </code>
    </example>
    <seealsocmd>APPEND FROM</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbApp'>DBApp</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbAppSdf'>DBAppSDF</seealso>
    <seealso cref='O:VO.DbServer.AppendDelimited'>DBServer:AppendDelimited</seealso>
  </dbappdelim>

  <dbappend>
    <summary>
      向数据库文件添加新记录。
    </summary>
    <param name="lReleaseLocks">
      一个逻辑数据类型，如果为 TRUE，则清除所有待处理的记录锁，然后追加下一条记录。<br/>
      如果为 FALSE，则保持所有待处理的记录锁，并将新记录添加到锁定列表的末尾。<br/>
      默认值为 TRUE。
    </param>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。<br/>
      如果成功添加，记录中的每个字段都将设置为其数据类型的空值，并且新记录成为当前记录。
    </returns>
    <remarks>
      默认情况下，此函数在当前选定的工作区中的数据库文件上操作。<br/>
      通过在别名表达式中指定，可以使其在未选定的工作区上操作。
      DBAppend(TRUE) 执行与 APPEND BLANK 命令相同的功能。<br/>
      有关更多信息，请参阅 APPEND BLANK。
      <note type="tip">
        逻辑记录：DBAppend() 不遵循逻辑可见性。<br/>
        也就是说，如果记录成功添加，它将成为当前记录，无论任何顺序或过滤条件如何。
        共享模式：<br/>
        对于共享数据库，DBAppend() 自动在新记录上放置记录锁。<br/>
        如果无法锁定记录，NetErr() 将设置为 TRUE，表示记录未添加，并继续执行。
      </note>
    </remarks>
    <example>
      以下示例追加一条空白记录，检查 NetErr() 条件，并更新数据：
      <code language="X#">
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", ;
        &#0009;&#0009;&#0009;&#0009;TRUE)
        ... <paramref name="Statements" />
        DBAppend()
        IF !NetErr()
        &#0009;Sales-&gt;FirstName := cFirst
        &#0009;Sales-&gt;LastName := cLast
        ELSE
        &#0009;QOut("追加操作失败")
        ENDIF
      </code>
      以下示例首先锁定一条记录，然后在不释放当前锁定列表中的记录锁的情况下向 SALES 数据库追加一条空白记录。<br/>
      它还检查错误：
      <code language="X#">
        USE sales NEW
        DBRLock()&#0009;&#0009;// 锁定当前记录
        // 添加新记录但保持旧锁
        IF DBAppend(FALSE) .AND. !NetErr()
        &#0009;? "多条记录被锁定"
        ELSE
        &#0009;? "发生错误！"
        ENDIF
      </code>
    </example>
    <seealsocmd>APPEND BLANK</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbAppend'>VODBAppend</seealso>
    <seealso cref='O:VO.DbServer.Append'>DBServer:Append</seealso>
  </dbappend>

  <dbappsdf>
    <summary>
      从 SDF 文件导入记录。
    </summary>
    <param name="cSourceFile">
      要从中添加记录的 SDF 文件名，包括可选的驱动器、目录和扩展名。<br/>
      有关文件搜索和创建规则，请参见 SetDefault() 和 SetPath()。<br/>
      默认扩展名为 .TXT。<br/>
      此函数尝试以共享模式打开 <paramref name="cSourceFile" />。<br/>
      如果文件不存在，则引发运行时错误。<br/>
      如果文件成功打开，操作继续进行。<br/>
      如果由于另一个进程独占使用该文件等原因而被拒绝访问，NetErr() 将被设置为 TRUE。
    </param>
    <param name="acFields">
      要从 <paramref name="cSourceFile" /> 复制的字段列表。<br/>
      默认为所有记录。
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      DBAppSDF() 在功能上等同于 APPEND FROM SDF 命令。
      它与 DBApp() 函数相同，只是它只能用于 SDF 文件。更多信息请参见 APPEND FROM 和 DBApp()。
    </remarks>
    <example>
      以下示例从 SDF 文件追加文本：
      <code language="X#">
        USE test NEW
        DBAppSDF("srcsdf")
      </code>
    </example>
    <seealsocmd>APPEND FROM</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbApp'>DBApp</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbAppDelim'>DBAppDelim</seealso>
    <seealso cref='O:VO.DbServer.AppendSDF'>DBServer:AppendSDF</seealso>
  </dbappsdf>

  <dbclearfilter>
    <summary>
      清除逻辑过滤条件。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBClearFilter() 的功能与不带表达式的 SET FILTER 命令相同。<br/>
      更多信息请参阅 SET FILTER。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      <note type="tip">
        逻辑记录：DBClearFilter() 影响工作区中记录的逻辑可见性。<br/>
        更多信息请参阅 DBSetFilter() 和 SET FILTER 命令。
      </note>
    </remarks>
    <example>
      以下示例设置过滤器，列出过滤后的数据，然后清除过滤器：
      <code language="X#">
        USE employee NEW
        DBSetFilter({|| Age &lt; 40}, "Age &lt; 40")
        GO TOP
        LIST Employee-&gt;Name
        DBClearFilter()
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFilter'>DBFilter</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetFilter'>DBSetFilter</seealso>
    <seealsocmd>SET FILTER</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbClearFilter'>VODBClearFilter</seealso>
    <seealso cref='O:VO.DbServer.ClearFilter'>DBServer:ClearFilter</seealso>
  </dbclearfilter>

  <dbclearindex>
    <summary>
      从工作区的排序列表中移除排序并关闭相关的索引文件。
    </summary>
    <param name="uOrder">
      要清除的排序名称或其在排序列表中的位置编号。<br/>
      推荐使用排序名称，因为在使用多重排序索引文件时，确定位置可能比较困难。<br/>
      如果未指定，将清除指定索引文件中的所有排序（如果未指定索引文件，则清除整个工作区）。<br/>
      无效值将被忽略。
    </param>
    <param name="cIndexFile">
      索引文件的名称，可包含可选的驱动器和目录（不应指定扩展名）。<br/>
      当不同索引文件中存在两个或多个同名排序时，可与 <paramref name="uOrder" /> 参数一起使用以消除歧义。<br/>
      单独使用时，仅关闭与指定文件相关的排序。<br/>
      如果当前进程未打开 <paramref name="cIndexFile" />，将引发运行时错误。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      在关闭索引文件之前，所有待处理的更新都将写入磁盘。<br/>
      一旦文件关闭且排序列表清除，数据库文件将恢复到其自然顺序。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      以下示例在有打开的索引文件时关闭它们：
      <code language="X#">
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", ;
        &#0009;&#0009;&#0009;TRUE)
        Sales-&gt;DBSetIndex("FirstName")
        Sales-&gt;DBSetIndex("LastName")
        // 是否有打开的索引文件？
        IF Sales-&gt;DBOrderInfo(DBOI_NUMBER) &gt; 0
        &#0009;Sales-&gt;DBClearIndex()&#0009;&#0009;// 关闭索引文件
        ENDIF
        // 以自然顺序复制到 SDF
        COPY TO temp SDF
      </code>
    </example>
    <seealsocmd>CLOSE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
    <seealso cref='O:VO.DbServer.ClearFilter'>DBServer:ClearFilter</seealso>
  </dbclearindex>

  <dbclearordercondition>
    <summary>
      清除排序的条件和范围。
    </summary>
    <returns>
    </returns>
    <remarks>
      此函数调用 OrdCondSet() 并使用其默认参数来清除排序条件。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrderCondition'>DBSetOrderCondition</seealso>
    <seealso cref='O:VO.DbServer.SetOrderCondition'>DBServer:SetOrderCondition</seealso>
  </dbclearordercondition>

  <dbclearrelation>
    <summary>
      清除所有活动的关系。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBClearRelation() 执行与不带子句的 SET RELATION 命令相同的功能。<br/>
      有关更多信息，请参阅 SET RELATION 命令。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      以下示例设置一个关系，列出数据，然后清除该关系：
      <code language="X#">
        USE employee NEW
        USE department NEW INDEX dept
        SELECT Employee
        DBSetRelation("Department", ;
        &#0009;{|| Employee-&gt;Dept}, "Employee-&gt;Dept")
        LIST Employee-&gt;Name, Department-&gt;Name
        DBClearRelation()
      </code>
    </example>
    <seealso cref='O:VO.DbServer.ClearRelation'>DBServer:ClearRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetRelation'>DBSetRelation</seealso>
    <seealsocmd>SET RELATION</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbClearRelation'>VODBClearRelation</seealso>
  </dbclearrelation>

  <dbcloseall>
    <summary>
      关闭所有工作区中的所有文件。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBCloseAll() 释放所有占用的工作区。<br/>
      它相当于对每个占用的工作区调用 DBCloseArea()。
      DBCloseAll() 的效果与 CLOSE DATABASES 命令相同。<br/>
      有关更多信息，请参阅 CLOSE 命令。
    </remarks>
    <example>
      以下示例关闭所有工作区：
      <code language="X#">
        cLast := "Winston"
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", TRUE)
        Sales-&gt;DBSetIndex("salefnam")
        Sales-&gt;DBSetIndex("salelnam")
        DBUseArea(TRUE, "DBFNTX", "colls", "Colls", TRUE)
        Colls-&gt;DBSetIndex("collffnam")
        Colls-&gt;DBSetIndex("colllnam")
        // 选择 "Sales" 工作区
        IF (Sales-&gt;DBSeek(cLast))
        &#0009;IF Sales-&gt;Deleted()
        &#0009;&#0009;IF Sales-&gt;RLock()
        &#0009;&#0009;&#0009;Sales-&gt;DBRecall()
        &#0009;&#0009;&#0009;QOut("记录已删除: ", Sales-&gt;Deleted())
        &#0009;&#0009;ENDIF
        &#0009;ENDIF
        ELSE
        &#0009;QOut("未找到")
        ENDIF
        DBCloseAll()&#0009;&#0009;&#0009;&#0009;// 关闭所有工作区
      </code>
    </example>
    <seealsocmd>CLOSE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbCloseArea'>DBCloseArea</seealso>
    <seealso cref='O:VO.DbServer.Close'>DBServer:Close</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbCloseAll'>VODBCloseAll</seealso>
  </dbcloseall>

  <dbclosearea>
    <summary>
      关闭工作区中的所有文件。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBCloseArea() 释放一个工作区的使用。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      DBCloseArea() 等同于 CLOSE 命令或不带子句的 USE 命令。<br/>
      有关更多信息，请参阅 USE 和 CLOSE 命令。
    </remarks>
    <example>
      以下示例通过别名引用关闭文件：
      <code language="X#">
        cLast := "Winston"
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", TRUE)
        Sales-&gt;DBSetIndex("salefnam")
        Sales-&gt;DBSetIndex("salelnam")
        DBUseArea(TRUE, "DBFNTX", "colls", "Colls", TRUE)
        Colls-&gt;DBSetIndex("collfnam")
        Colls-&gt;DBSetIndex("colllnam")
        // 选择 "Sales" 工作区
        IF Sales-&gt;DBSeek(cLast)
        &#0009;IF Sales-&gt;Deleted() .AND. ;
        &#0009;&#0009;Sales-&gt;RLock()
        &#0009;&#0009;QOut("记录已删除: ", Sales-&gt;Deleted())
        &#0009;ENDIF
        ELSE
        &#0009;QOut("未找到")
        &#0009;Colls-&gt;DBCloseArea()
        ENDIF
      </code>
    </example>
    <seealsocmd>CLOSE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbCloseAll'>DBCloseAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCommit'>DBCommit</seealso>
    <seealso cref='O:VO.DbServer.Close'>DBServer:Close</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUseArea'>DBUseArea</seealso>
    <seealsocmd>USE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbCloseArea'>VODBCloseArea</seealso>
  </dbclosearea>

  <dbcommit>
    <summary>
      将一个工作区中所有待处理的更新刷新到磁盘。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBCommit() 将工作区的所有更新写入磁盘。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      所有更新的数据库和索引缓冲区都会写入 DOS，并且会为数据库文件和与该工作区关联的任何索引文件发出 DOS Commit 请求。
      DBCommit() 执行与 DBCommitAll() 函数相同的功能，只是它仅对当前或别名工作区进行操作。
      <note type="tip">
        共享模式：DBCommit() 使数据库更新对其他进程可见。<br/>
        为确保数据完整性，请在解锁操作之前执行 DBCommit()。
        &#0009;DBCommit() 使用 DOS 中断 21h 功能 68h 执行实际的磁盘写入。<br/>
        网络软件是否正确实现此请求取决于具体情况。请与网络软件供应商确认是否支持此功能。
      </note>
    </remarks>
    <example>
      在此示例中，DBCommit() 用于在将一系列内存变量分配给字段变量后强制写入磁盘：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL cName, cAmount
        &#0009;USE sales EXCLUSIVE NEW
        &#0009;cName := Sales-&gt;Name
        &#0009;cAmount := Sales-&gt;Amount
        &#0009;@ 10, 10 GET cName
        &#0009;@ 11, 10 GET cAmount
        &#0009;READ
        &#0009;IF Updated()
        &#0009;&#0009;IF DBAppend()
        &#0009;&#0009;&#0009;REPLACE Sales-&gt;Name WITH cName
        &#0009;&#0009;&#0009;REPLACE Sales-&gt;Amount WITH cAmount
        &#0009;&#0009;&#0009;Sales-&gt;DBCommit()
        &#0009;&#0009;ENDIF
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCloseAll'>DBCloseAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCommitAll'>DBCommitAll</seealso>
    <seealso cref='O:VO.DbServer.Commit'>DBServer:Commit</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLock'>DBUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbCommit'>VODBCommit</seealso>
  </dbcommit>

  <dbcommitall>
    <summary>
      将所有工作区中所有待处理的更新刷新到磁盘。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBCommitAll() 将所有工作区的所有待处理更新写入磁盘。<br/>
      它相当于对每个占用的工作区调用 DBCommit()。
      有关更多信息，请参阅 DBCommit()。
      <note type="tip">
        DBCommitAll() 使用 DOS 中断 21h 功能 68h 执行实际的磁盘写入。<br/>
        网络软件是否正确实现此请求取决于具体情况。请与网络软件供应商确认是否支持此功能。
      </note>
    </remarks>
    <example>
      以下示例将所有待处理的更新写入磁盘：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL cLast := "Winston"
        &#0009;DBUseArea(TRUE, "DBFNTX", "sales", ;
        &#0009;&#0009;&#0009;&#0009;"Sales", TRUE)
        &#0009;Sales-&gt;DBSetIndex("salefnam")
        &#0009;Sales-&gt;DBSetIndex("salelnam")
        &#0009;DBUseArea(TRUE, "DBFNTX", "colls", "Colls", ;
        &#0009;&#0009;&#0009;&#0009;TRUE)
        &#0009;Colls-&gt;DBSetIndex("collfnam")
        &#0009;Colls-&gt;DBSetIndex("colllnam")
        &#0009;IF Sales-&gt;DBSeek(cLast)
        &#0009;&#0009;IF Sales-&gt;Deleted() .AND. Sales-&gt;RLock()
        &#0009;&#0009;&#0009;Sales-&gt;DBRecall()
        &#0009;&#0009;&#0009;QOut("已恢复删除的记录。")
        &#0009;&#0009;ENDIF
        &#0009;ELSE
        &#0009;&#0009;QOut("未找到")
        &#0009;ENDIF
        &#0009;// 处理完成，将更新写入磁盘并
        &#0009;// 关闭文件
        &#0009;DBCommitAll()
        &#0009;DBCloseAll()
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCloseAll'>DBCloseAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCommit'>DBCommit</seealso>
    <seealso cref='O:VO.DbServer.Commit'>DBServer:Commit</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLock'>DBUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbCommitAll'>VODBCommitAll</seealso>
  </dbcommitall>

  <dbcontinue>
    <summary>
      继续执行挂起的定位条件。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBContinue() 是 CONTINUE 命令的函数形式。<br/>
      有关更多信息，请参阅 CONTINUE 命令。
    </remarks>
    <example>
      以下示例搜索名称 "Winston" 的所有出现：
      <code language="X#">
        DBUseArea(TRUE, "DBFNTX", "address", "Address",;
        &#0009;&#0009;&#0009;&#0009;TRUE)
        LOCATE FOR UPPER(Address-&gt;Name) == "WINSTON"
        DO WHILE Found()
        &#0009;? RECNO()
        &#0009;DBContinue()
        ENDDO
      </code>
    </example>
    <seealsocmd>CONTINUE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbLocate'>DBLocate</seealso>
    <seealso cref='O:VO.DbServer.Continue'>DBServer:Continue</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbContinue'>VODBContinue</seealso>
  </dbcontinue>

  <dbcopy>
    <summary>
      将记录导出到新的数据库文件。
    </summary>
    <param name="cTargetFile">
      目标文件的名称，包括可选的驱动器、目录和扩展名。有关文件搜索和创建规则，请参阅 SetDefault() 和 SetPath()。<br/>
      数据库文件的默认扩展名由 RDD 决定。<br/>
      对于文本文件，默认扩展名是 .TXT。<br/>
      &#0009;如果 <paramref name="cTargetFile" /> 不存在，则会创建它。<br/>
      如果文件存在，此函数会尝试以独占模式打开文件，如果成功，则会覆盖文件，不会发出警告或错误。<br/>
      如果由于其他进程正在使用该文件等原因而拒绝访问，NetErr() 将被设置为 TRUE。<br/>
      &#0009;DBCreate() 根据 SetAnsi() 设置，以 ANSI 或 OEM 字符集格式创建指定的文件。（有关更多信息，请参阅 SetAnsi() 函数。）
    </param>
    <param name="acFields">
      要复制到 <paramref name="cTargetFile" /> 的字段列表。<br/>
      默认为所有字段。
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <param name="cDriver">
      将为工作区提供服务的 RDD 的名称。<br/>
      如果未指定，则使用由 RDDSetDefault() 确定的默认 RDD。
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/acrdds/*"/>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      默认情况下，此函数将当前选定工作区中的数据库文件中的记录复制到新文件。
      通过在别名表达式中指定未选定的工作区，可以使其在未选定的工作区上操作。
      如果 SetDeleted() 为 FALSE，源文件中已删除的记录将被复制到 <paramref name="cTargetFile" />，并保留其已删除状态。<br/>
      但是，如果 SetDeleted() 为 TRUE，则不会复制已删除的记录。同样，如果设置了过滤器，则不会复制不可见的记录。
      DBCopy() 在功能上等同于不带 DELIMITED 或 SDF 子句的 COPY TO 命令。
    </remarks>
    <example>
      以下示例将当前数据库文件中的记录复制到新的数据库文件：
      <code language="X#">
        USE Test NEW
        DBCopy("newdb.dbf")
      </code>
    </example>
    <seealsocmd>COPY TO</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbCopyDelim'>DBCopyDelim</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCopySDF'>DBCopySDF</seealso>
    <seealso cref='O:VO.DbServer.CopyDB'>DBServer:CopyDB</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </dbcopy>

  <dbcopydelim>
    <summary>
      将记录导出到新的分隔文本文件。
    </summary>
    <param name="cTargetFile">
      目标文件的名称，包括可选的驱动器、目录和扩展名。有关文件搜索和创建规则，请参见 SetDefault() 和 SetPath()。<br/>
      数据库文件的默认扩展名由 RDD 确定。<br/>
      对于文本文件，默认扩展名是 .TXT。<br/>
      &#0009;如果 <paramref name="cTargetFile" /> 不存在，则创建它。<br/>
      如果文件已存在，此函数会尝试以独占模式打开文件，如果成功，则会覆盖文件，不会发出警告或错误。<br/>
      如果因为其他进程正在使用该文件等原因而被拒绝访问，NetErr() 将被设置为 TRUE。
    </param>
    <param name="cDelim">
      用于分隔 <paramref name="cTargetFile" /> 中字段的分隔符。<br/>
      默认分隔符是双引号。
    </param>
    <param name="acFields">
      要复制到 <paramref name="cTargetFile" /> 的字段列表。<br/>
      默认为所有字段。
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      DBCopyDelim() 在功能上等同于 COPY TO DELIMITED 命令。
      它与 DBCopy() 相同，只是它将记录复制到分隔文本文件。有关更多信息，请参见 COPY TO 和 DBCopy()。
    </remarks>
    <example>
      以下示例将当前数据库文件中的记录复制到分隔文本文件：
      <code language="X#">
        USE Test NEW
        IF Used()
        &#0009;DBCopyDelim("newdelim")
        ENDIF
      </code>
    </example>
    <seealsocmd>COPY TO</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbCopy'>DBCopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCopySDF'>DBCopySDF</seealso>
    <seealso cref='O:VO.DbServer.CopyDelimited'>DBServer:CopyDelimited</seealso>
  </dbcopydelim>

  <dbcopysdf>
    <summary>
      将记录导出到新的 SDF 文件。
    </summary>
    <param name="cTargetFile">
      目标文件的名称，包括可选的驱动器、目录和扩展名。有关文件搜索和创建规则，请参见 SetDefault() 和 SetPath()。<br/>
      数据库文件的默认扩展名由 RDD 决定。<br/>
      对于文本文件，扩展名是 .TXT。<br/>
      &#0009;如果 <paramref name="cTargetFile" /> 不存在，则创建它。<br/>
      如果文件存在，此函数尝试以独占模式打开文件，如果成功，则覆盖文件，不发出警告或错误。<br/>
      如果访问被拒绝（例如，因为另一个进程正在使用该文件），NetErr() 将被设置为 TRUE。
    </param>
    <param name="acFields">
      要复制到 <paramref name="cTargetFile" /> 的字段列表。<br/>
      默认为所有字段。
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      DBCopySDF() 在功能上等同于 COPY TO SDF 命令。
      它与 DBCopy() 相同，只是它将记录复制到 SDF 文件。有关更多信息，请参见 COPY TO 和 DBCopy()。
    </remarks>
    <example>
      以下示例将当前数据库文件中的记录复制到 SDF 文件：
      <code language="X#">
        USE Test NEW
        IF Used()
        &#0009;DBCopySDF("newsdf")
        ENDIF
      </code>
    </example>
    <seealsocmd>COPY TO</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbCopy'>DBCopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCopyDelim'>DBCopyDelim</seealso>
    <seealso cref='O:VO.DbServer.CopySDF'>DBServer:CopySDF</seealso>
  </dbcopysdf>

  <dbcopystruct>
    <summary>
      从另一个数据库文件创建具有字段定义的空数据库文件。
    </summary>
    <param name="cTargetFile">
      目标数据库文件的名称，包括可选的驱动器、目录和扩展名。有关文件搜索和创建规则，请参见 SetDefault() 和 SetPath()。<br/>
      数据库文件的默认扩展名由 RDD 确定。<br/>
      &#0009;如果 <paramref name="cTargetFile" /> 不存在，则创建它。<br/>
      如果文件存在，此函数会尝试以独占模式打开文件，如果成功，则会覆盖文件，不会发出警告或错误。<br/>
      如果因为其他进程正在使用该文件等原因而被拒绝访问，NetErr() 将被设置为 TRUE。<br/>
      &#0009;DBCopyStruct() 根据 SetAnsi() 设置，以 ANSI 或 OEM 字符集格式创建指定的文件。（有关更多信息，请参阅 SetAnsi() 函数。）
    </param>
    <param name="acStruct">
      要复制到新数据库文件的字段名称的一维数组。<br/>
      默认为所有字段。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      DBCopyStruct() 在功能上等同于 COPY STRUCTURE 命令。
    </remarks>
    <example>
      以下示例将当前数据库文件的结构复制到新的数据库文件：
      <code language="X#">
        USE Test NEW
        IF Used()
        &#0009;DBCopyStruct("c:\savestru\test")
        ENDIF
      </code>
    </example>
    <seealsocmd>COPY STRUCTURE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbCopyXStruct'>DBCopyXStruct</seealso>
    <seealso cref='O:VO.DbServer.CopyStructure'>DBServer:CopyStructure</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbStruct'>DBStruct</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </dbcopystruct>

  <dbcopyxstruct>
    <summary>
      将数据库文件结构中的字段定义复制到结构扩展文件中作为数据。
    </summary>
    <param name="cTargetFile">
      目标结构扩展数据库文件的名称，包括可选的驱动器、目录和扩展名。有关文件搜索和创建规则，请参见 SetDefault() 和 SetPath()。<br/>
      数据库文件的默认扩展名由 RDD 确定。<br/>
      &#0009;如果 <paramref name="cTargetFile" /> 不存在，则创建它。<br/>
      如果文件存在，此函数会尝试以独占模式打开文件，如果成功，则会覆盖文件，不会发出警告或错误。<br/>
      如果因为其他进程正在使用该文件等原因而被拒绝访问，NetErr() 将被设置为 TRUE。<br/>
      &#0009;DBCreate() 根据 SetAnsi() 设置，以 ANSI 或 OEM 字符集格式创建指定的文件。（有关更多信息，请参阅 SetAnsi() 函数。）
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBCopyXStruct() 创建一个数据库文件，其内容是当前数据库文件的结构，每个字段的定义对应一条记录。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      结构扩展数据库文件具有以下结构：
      名称&#0009;类型&#0009;长度&#0009;小数位&#0009;
      Field_Name&#0009;字符&#0009;10&#0009;&#0009;
      Field_Type&#0009;字符&#0009;1&#0009;&#0009;
      Field_Len&#0009;数值&#0009;3&#0009;0&#0009;
      Field_Dec&#0009;数值&#0009;3&#0009;0&#0009;
      在应用程序中使用 DBCopyXStruct() 允许您以编程方式创建或修改数据库文件的结构。<br/>
      要从结构扩展文件创建新的数据库文件，请使用 CREATE FROM。<br/>
      如果您需要一个空的结构扩展文件，请使用 CREATE。
      DBCopyXStruct() 是 COPY STRUCTURE EXTENDED 命令的功能实现。
      <note type="tip">
        长度大于 255 的字符字段：大于 255 的字段长度表示为 Field_Dec 和 Field_Len 字段的组合。<br/>
        执行 DBCopyXStruct() 后，您可以使用以下公式确定任何字符字段的长度：
        <code language="X#">
          nFieldLen := If((Field_Type = "C" .AND. ;
          &#0009;&#0009;Field_Dec != 0), Field_Dec * 256 + ;
          &#0009;&#0009;Field_Len, Field_Len)
        </code>
      </note>
    </remarks>
    <example>
      以下示例创建一个新的结构扩展文件：
      <code language="X#">
        USE test
        IF Used()
        &#0009;DBCopyXStruct("stru.dbf")
        ENDIF
      </code>
    </example>
    <seealsocmd>COPY STRUCTURE EXTENDED</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbCopyStruct'>DBCopyStruct</seealso>
    <seealso cref='O:VO.DbServer.CopyStructure'>DBServer:CopyStructure</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </dbcopyxstruct>

  <dbcreate>
    <summary>
      从数据库结构数组创建数据库文件。
    </summary>
    <param name="cTargetFile">
      新数据库文件的名称，包括可选的驱动器、目录和扩展名。参见 SetDefault() 和 SetPath() 了解文件搜索和创建规则。<br/>
      数据库文件的默认扩展名由 RDD 决定。<br/>
      &#0009;如果 <paramref name="cTargetFile" /> 不存在，则创建它。<br/>
      如果存在，此函数会尝试以独占模式打开文件，如果成功，文件将被覆盖，不会发出警告或错误。<br/>
      如果访问被拒绝（例如，因为另一个进程正在使用该文件），NetErr() 将被设置为 TRUE。<br/>
      &#0009;DBCreate() 根据 SetAnsi() 设置，以 ANSI 或 OEM 字符集格式创建指定文件。（有关更多信息，请参阅 SetAnsi() 函数。）
    </param>
    <param name="aStruct">
      包含字段描述的数组，格式与 DBStruct() 返回的格式相同。<br/>
      此数组定义了新数据库文件的结构。
    </param>
    <param name="cDriver">
      将服务工作区的 RDD 的名称。<br/>
      如果未指定，则使用由 RDDSetDefault() 确定的默认 RDD。
    </param>
    <param name="lNew">
      TRUE 在新工作区（第一个可用的）中打开数据库文件。FALSE 在当前工作区中打开它。<paramref name="lNew" /> 仅在 <paramref name="lOpen" /> 值为 TRUE 时有用。默认为 FALSE。
    </param>
    <param name="cAlias">
      与打开文件的工作区关联的别名。在单个应用程序中，X# 不接受重复的别名。<paramref name="cAlias" /> 仅在 <paramref name="lOpen" /> 值为 TRUE 时有用。<br/>
      默认别名是八个字母的数据库文件名。
    </param>
    <param name="cDelim">
      分隔数据库文件中字段的分隔符。<br/>
      如果您使用提供的 RDD 之一来处理 .DBF 文件，分隔符应该是 NULL_STRING，如果省略该<br/>
      &#0009;参数，这是默认值。
    </param>
    <param name="lOpen">
      TRUE 指定打开现有数据库文件；FALSE 指定打开新数据库文件。<br/>
      默认为 FALSE。<br/>
      这可用于打开现有的 SDF 和分隔文件，这些文件在头部没有结构 — 在这种情况下，应使用 <paramref name="aStruct" />。
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/acrdds/*"/>
    <returns>
      如果请求的操作成功，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBCreate() 从包含文件结构的数组创建数据库文件。DBCreate() 类似于 CREATE FROM 命令，后者从结构扩展文件创建新的数据库文件结构。
      在使用 DBCreate() 之前，您必须首先创建 <paramref name="aStruct" /> 数组，并根据上表中的结构用字段定义数组填充它。您可以通过编程方式创建数组，也可以使用 DBStruct() 创建。
      创建字段定义数组有一些具体规则，包括：
      -&#0009;使用适当数据类型的值指定所有字段属性。<br/>
      必须指定小数属性 — 即使对于非数字字段。<br/>
      如果字段没有小数属性，请指定 0。
      -&#0009;使用数据类型的第一个字母作为最小值来指定类型属性。<br/>
      为了可读性，使用更长和更具描述性的术语。<br/>
      例如，"C" 和 "Character" 都可以指定为字符字段的类型属性。
      -&#0009;与 CREATE FROM 命令不同，DBCreate() 不使用小数属性来指定字段长度的高位部分。直接指定字段长度，不考虑其大小。
    </remarks>
    <example>
      以下示例演示了 DBCreate()：
      <code language="X#">
        USE test
        IF Used()
        &#0009;DBCreate("newdb.dbf", DBStruct(), "",;
        &#0009;&#0009;&#0009;&#0009;&#0009;TRUE,"", "", FALSE)
        ENDIF
      </code>
      此示例创建一个空数组，然后使用 AAdd() 函数添加字段定义子数组，然后创建 PEOPLE.DBF。您可以使用这种技术动态地向结构数组添加字段定义：
      <code language="X#">
        aDBF := {}
        AAdd(aDBF, {"Name", "C", 25, 0})
        AAdd(aDBF, {"Address", "C", 1024, 0})
        AAdd(aDBF, {"Phone", "N", 13, 0})
        DBCreate("people", aDBF)
      </code>
      下一个示例执行与上面示例相同类型的操作，但它将结构数组声明为二维数组，然后使用下标寻址来指定字段定义。<br/>
      数据库文件使用 DBFMDX RDD 创建：
      <code language="X#">
        LOCAL aDBF[1][4]
        aDBF[1][DBS_NAME] := "Name"
        aDBF[1][DBS_TYPE] := "Character"
        aDBF[1][DBS_LEN]  := 25
        aDBF[1][DBS_DEC]  := 0
        DBCreate("Name", aDBF, "DBFMDX")
      </code>
    </example>
    <seealsocmd>COPY STRUCTURE EXTENDED</seealsocmd>
    <seealsocmd>CREATE FROM</seealsocmd>
    <seealso cref='O:VO.DbServer.CopyStructure'>DBServer:CopyStructure</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbStruct'>DBStruct</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </dbcreate>

  <dbcreateindex>
    <summary>
      创建索引文件并向其添加一个顺序。
    </summary>
    <param name="cIndexFile">
      目标索引文件的名称，包括可选的驱动器、目录和扩展名。有关文件搜索和创建规则，请参见 SetDefault() 和 SetPath()。<br/>
      默认扩展名由 RDD 确定，可以使用 DBOrderInfo(DBOI_INDEXEXT) 获取。<br/>
      &#0009;在支持生产索引的 RDD 中，如果未指定 <paramref name="cIndexFile" />，则假定为生产索引文件。<br/>
      &#0009;如果 <paramref name="cIndexFile" /> 不存在，则创建它。<br/>
      &#0009;如果 <paramref name="cIndexFile" /> 存在，DBCreateIndex() 必须首先获得对文件的独占使用权。<br/>
      如果成功，文件将被覆盖，不会发出警告或错误。<br/>
      如果尝试失败（例如，因为文件被另一个进程打开），NetErr() 将被设置为 TRUE。
    </param>
    <param name="cKeyValue">
      以字符串形式指定的顺序键表达式。<br/>
      这是存储在索引文件中的键表达式，用于定位键值和重新创建顺序等目的。<br/>
      &#0009;虽然 <paramref name="cKeyValue" /> 是可选的，但强烈建议您指定此参数。没有它，顺序将使用 <paramref name="cbKeyValue" /> 正确创建，但键表达式将作为 NULL_STRING 存储在索引文件中，使顺序无法用于后续访问。
    </param>
    <param name="cbKeyValue">
      以代码块形式指定的顺序键表达式。<br/>
      此代码块用于初始创建顺序。<br/>
      如果您不提供 <paramref name="cbKeyValue" />，它将从 <paramref name="cKeyValue" /> 宏编译（例如，{||&amp;<paramref name="cKeyValue" />}）。<br/>
      &#0009;键表达式的数据类型和所有其他限制（包括键的长度和键表达式）由 RDD 确定。
    </param>
    <param name="lUnique">
      TRUE 通过仅包含具有唯一键值的记录来创建唯一顺序；FALSE 使用数据库文件中的所有记录。<br/>
      如果省略 <paramref name="lUnique" />，则使用 SetUnique() 设置。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      默认情况下，此函数为当前选定工作区关联的数据库文件创建索引文件。<br/>
      可以通过在别名表达式中指定未选定的工作区来使其在该工作区上操作。
      DBCreateIndex() 使用当前的 DBSetOrderCondition() 来确定顺序的条件（例如，其范围、for 条件和 while 条件）。
      如果工作区中有其他打开的索引文件，它们将被关闭。<br/>
      创建新索引文件后，使用索引文件名和指定的键向文件添加顺序。<br/>
      索引文件被打开（与其关联的数据库文件处于相同模式），设置工作区的控制顺序，并将数据库文件定位到第一个逻辑记录。
      注意：<br/>
      如果 RDD 支持每个索引文件有多个顺序，请使用 DBCreateOrder() 向索引文件添加后续顺序。
      <note type="tip">
        副作用：&#0009;DBCreateIndex() 保证创建一个顺序，当成为控制顺序时，将对数据库施加指定的逻辑顺序。<br/>
        键表达式不一定在任何特定时间、通过任何特定方式或在任何特定记录或一系列记录上进行评估。<br/>
        如果键表达式依赖于数据库文件或工作区外部的信息，效果是不可预测的。<br/>
        如果键表达式改变工作区的状态（例如，移动到不同的记录或更改记录的内容），效果是不可预测的。
        键评估：&#0009;在评估键表达式之前，相关工作区会自动选择为当前工作区；之后会自动恢复先前选择的工作区。
      </note>
    </remarks>
    <example>
      此示例创建一个索引文件 EMPNAME，以 Name 字段为索引：
      <code language="X#">
        USE employee NEW
        Employee-&gt;DBCreateIndex("EmpName", "Name", ;
        &#0009;{|| Employee-&gt;Name})
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearIndex'>DBClearIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
    <seealso cref='O:VO.DbServer.CreateIndex'>DBServer:CreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbReindex'>DBReindex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrder'>DBSetOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrderCondition'>DBSetOrderCondition</seealso>
    <seealsocmd>INDEX</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.NetErr'>NetErr</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
  </dbcreateindex>

  <dbcreateorder>
    <summary>
      在索引文件中创建或替换一个顺序。
    </summary>
    <param name="cOrder">
      要创建的顺序的名称。<br/>
      对于单顺序索引文件，不带扩展名或路径的文件名是默认的顺序名。<br/>
      对于多顺序索引文件，顺序名是必需的。
    </param>
    <param name="cIndexFile">
      目标索引文件的名称，包括可选的驱动器、目录和扩展名。参见 SetDefault() 和 SetPath() 了解文件搜索和创建规则。<br/>
      默认扩展名由 RDD 确定，可以使用 DBOrderInfo(DBOI_INDEXEXT) 获取。<br/>
      &#0009;在支持生产索引的 RDD 中，如果未指定 <paramref name="cIndexFile" />，则假定使用生产索引文件（即与数据库文件同名的文件）。<br/>
      &#0009;如果 <paramref name="cIndexFile" /> 不存在，则创建它。<br/>
      &#0009;如果 <paramref name="cIndexFile" /> 存在，INDEX 命令必须首先获得文件的独占使用权。<br/>
      如果尝试失败（例如，文件被另一个进程打开），NetErr() 将设置为 TRUE。<br/>
      &#0009;如果尝试成功，且 RDD 指定索引文件只能包含单个顺序，则文件的当前内容将被新顺序覆盖。<br/>
      如果 RDD 指定索引文件可以包含多个顺序，则如果 <paramref name="cIndexFile" /> 中不存在该顺序，则添加该顺序；否则替换它。
    </param>
    <param name="cKeyValue">
      以字符串形式指定的顺序键表达式。<br/>
      这是存储在索引文件中的键表达式，用于定位键值和重新创建顺序等目的。<br/>
      &#0009;虽然 <paramref name="cKeyValue" /> 是可选的，但强烈建议指定此参数。没有它，顺序将使用 <paramref name="cbKeyValue" /> 正确创建，但键表达式将作为 NULL_STRING 存储在索引文件中，使顺序无法进行后续访问。
    </param>
    <param name="cbKeyValue">
      以代码块形式指定的顺序键表达式。<br/>
      此代码块用于初始创建顺序。<br/>
      如果不提供 <paramref name="cbKeyValue" />，它将从 <paramref name="cKeyValue" /> 宏编译（例如，{||&amp;<paramref name="cKeyValue" />}）。<br/>
      &#0009;键表达式的数据类型和所有其他限制，包括键的长度和键表达式，由 RDD 确定。
    </param>
    <param name="lUnique">
      TRUE 创建唯一顺序，仅包含具有唯一键值的记录；FALSE 使用数据库文件中的所有记录。<br/>
      如果省略 <paramref name="lUnique" />，则使用 SetUnique() 设置。注意，已删除记录的键也包含在索引中，可能会隐藏未删除记录的键。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      DBCreateOrder() 使用当前的 DBSetOrderCondition() 来确定顺序的条件（例如，其范围、for 条件和 while 条件）。
      创建（或替换）后，新顺序将添加到工作区的顺序列表中。工作区已关联的其他顺序（包括控制顺序）不受影响。
      注意：<br/>
      虽然此函数设计用于处理单顺序和多顺序索引文件，但您可能会发现使用 DBCreateIndex() 创建单顺序索引文件更容易。
      <note type="tip">
        副作用：&#0009;DBCreateOrder() 保证创建一个顺序，当成为控制顺序时，将对数据库施加指定的逻辑顺序。<br/>
        键表达式不一定在任何特定时间、以任何特定方式或在任何特定记录或一系列记录上进行评估。<br/>
        如果键表达式依赖于数据库文件或工作区外部的信息，其效果是不可预测的。<br/>
        如果键表达式改变工作区的状态（例如，移动到不同的记录或更改记录的内容），其效果是不可预测的。
        键评估：&#0009;在评估键表达式之前，相关工作区会自动选为当前工作区；之后会自动恢复先前选择的工作区。
      </note>
    </remarks>
    <example>
      此示例创建顺序 CUACCT 并将其添加到生产索引文件 CUSTOMER 中：
      <code language="X#">
        USE customer VIA "DBFMDX" NEW
        Customer-&gt;DBCreateOrder("CuAcct", "Customer", ;
        &#0009;"Acct", {|| Customer-&gt;Acct})
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearIndex'>DBClearIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbReindex'>DBReindex</seealso>
    <seealso cref='O:VO.DbServer.CreateOrder'>DBServer:CreateOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrder'>DBSetOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrderCondition'>DBSetOrderCondition</seealso>
    <seealsocmd>INDEX</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
  </dbcreateorder>

  <dbdelete>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <summary>
      标记当前记录为删除状态。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      被标记为删除的记录可以通过 SetDeleted() 进行过滤，或使用 DBPack() 从文件中移除。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      DBDelete() 在功能上等同于作用于当前记录的 DELETE 命令。<br/>
      有关更多信息，请参阅 DELETE。
      <note type="tip">
        逻辑记录：&#0009;如果 SetDeleted() 为 TRUE，被删除的记录在逻辑上是不可见的。也就是说，对逻辑记录进行操作的数据库操作将不会考虑被标记为删除的记录。但请注意，如果在当前记录被标记为删除时 SetDeleted() 为 TRUE，该记录将保持可见状态，直到它不再是当前记录。
        共享模式：&#0009;对于共享数据库，DBDelete() 要求当前记录被锁定。
      </note>
    </remarks>
    <example>
      以下示例在成功锁定记录后删除该记录：
      <code language="X#">
        cLast := "Winston"
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", TRUE)
        Sales-&gt;DBSetIndex("LastName")
        IF Sales-&gt;DBSeek(cLast)
        &#0009;IF Sales-&gt;RLock()
        &#0009;&#0009;Sales-&gt;DBDelete()
        &#0009;&#0009;QOut("记录已删除: ", Sales-&gt;Deleted())
        &#0009;ELSE
        &#0009;&#0009;QOut("无法锁定记录...")
        &#0009;ENDIF
        ELSE
        &#0009;QOut("未找到")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRecall'>DBRecall</seealso>
    <seealso cref='O:VO.DbServer.Delete'>DBServer:Delete</seealso>
    <seealsocmd>DELETE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.Deleted'>Deleted</seealso>
    <seealsocmd>RECALL</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbDelete'>VODBDelete</seealso>
  </dbdelete>

  <dbdeleteorder>
    <summary>
      从打开的索引文件中删除一个排序。
    </summary>
    <param name="uOrder">
      要删除的排序名称或其在排序列表中的位置编号。<br/>
      使用排序名称是首选方法，因为在多重排序索引文件中确定位置可能比较困难。<br/>
      如果找不到排序，将引发运行时错误。
    </param>
    <param name="cIndexFile">
      索引文件的名称，包括可选的驱动器和目录（不应指定扩展名）。<br/>
      当不同索引文件中存在两个或多个同名排序时，使用此参数与 <paramref name="cOrder" /> 来消除歧义。<br/>
      &#0009;如果当前进程未打开 <paramref name="cIndexFile" />，将引发运行时错误。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBDeleteOrder() 要求当前数据库以独占模式打开。<br/>
      如果在调用 DBDeleteOrder() 时未满足此条件，将引发运行时错误。
      DBDeleteOrder() 从多重排序索引文件中删除一个排序，并从当前排序列表中移除该排序。
      要删除整个索引文件，请使用常规文件处理函数，如 Windows DeleteFile()。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      注意：<br/>
      RDD 决定索引文件的排序容量，DBDeleteOrder() 仅支持具有多重排序功能的 RDD。<br/>
      对于单一排序索引文件，您必须删除整个文件。
      <br/>
      第三方 RDD 供应商可能会为此函数定义特定行为。
    </remarks>
    <example>
      在此示例中，由于两个打开的索引文件可能都包含名为 CUACCT 的排序，DBDeleteOrder() 函数通过指定索引文件来区分要使用哪个：
      <code language="X#">
        USE customer VIA "DBFMDX" NEW
        Customer-&gt;DBSetIndex("customer")
        Customer-&gt;DBSetIndex("custtemp")
        Customer-&gt;DBDeleteOrder("cuacct", "customer")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:VO.DbServer.DeleteOrder'>DBServer:DeleteOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
  </dbdeleteorder>

  <dbdriver>
    <summary>
      返回应用程序的默认 RDD。
    </summary>
    <returns>
      当未明确指定驱动程序时，用于激活和管理应用程序的 RDD 的名称。<br/>
      如果此 RDD 对应用程序不可用，则调用不会产生任何效果。
    </returns>
    <remarks>
      要设置默认 RDD，请使用 RDDSetDefault()。
    </remarks>
    <example>
      以下示例检查默认 RDD 以报告索引文件的默认扩展名：
      <code language="X#">
        IF DBDriver() == "DBFMDX"
        &#0009;QOut(".MDX 扩展名")
        ENDIF
      </code>
    </example>
    <seealso cref='P:VO.DbServer.Driver'>DBServer:Driver</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddName'>RDDName</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddName'>VODBRDDName</seealso>
  </dbdriver>

  <dbeval>
    <summary>
      对符合指定范围和/或条件的每条记录评估代码块。
    </summary>
    <param name="cbExecute">对每条符合范围和条件的记录执行的代码块。</param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      在每次迭代中，DBEval() 评估指定的代码块。
      处理范围内或符合条件的所有记录，直到达到文件末尾。
      DBEval() 类似于 AEval()，后者对数组中的每个元素执行代码。
      与 AEval() 一样，DBEval() 可以用作构建处理数据库文件的命令的原语。
      事实上，许多 X# 数据库处理命令都是使用 DBEval() 创建的。
    </remarks>

    <example>
      此示例使用 DBEval() 来增强 DBList() 函数：
      <code language="X#">
        GLOBAL siFCount
        FUNCTION MyListAll(cFile AS STRING) AS LOGIC PASCAL
        &#0009;LOCAL lRetCode AS LOGIC
        &#0009;USE test
        &#0009;IF Used()
        &#0009;&#0009;siFCount := FCount()
        &#0009;&#0009;cbDisp  := {|| ShowFields()}
        &#0009;&#0009;GO TOP
        &#0009;&#0009;lRetCode := DBEval(cbDisp)
        &#0009;ENDIF
        &#0009;RETURN lRetCode
        FUNCTION ShowFields() AS VOID PASCAL
        &#0009;LOCAL i AS WORD
        &#0009;IF Deleted()
        &#0009;&#0009;QOut("*")
        &#0009;ELSE
        &#0009;&#0009;QOut()
        &#0009;ENDIF
        &#0009;FOR i := 1 UPTO siFCount
        &#0009;&#0009;QQOut(FieldGet(i))
        &#0009;&#0009;QQOut(" ")
        &#0009;NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:VO.DbServer.Eval'>DBServer:Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbEval'>VODBEval</seealso>
  </dbeval>

  <dbf>
    <summary>
      返回别名的名称。
      注意：DBF() 是一个兼容性函数，不再推荐使用。<br/>
      它已被 Alias0() 取代。更多信息请参见 Alias0()。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      工作区的别名，以字符串形式返回。<br/>
      如果工作区中没有活动的数据库文件，DBF() 返回一个 NULL_STRING。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias'>Alias</seealso>
    <seealso cref='P:VO.DbServer.Alias'>DBServer:Alias</seealso>
    <seealso cref='P:VO.DbServer.AliasSym'>DBServer:AliasSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.Used'>Used</seealso>
  </dbf>

  <dbfieldinfo>
    <summary>
      返回并可选择性地更改字段信息。
    </summary>
    <param name="kInfoType">
      指定信息类型。<br/>
      常量在下面的"常量"部分中描述。但请注意，并非所有 RDD 都支持所有常量。<br/>
      有关支持的常量列表，请参见"备注"部分。
    </param>
    <param name="nFieldPos">
      数据库文件结构中字段的位置或指向 BLOB 的数字指针。只有某些设计用于处理 BLOB 字段的 <paramref name="kInfoType" /> 常量（在下面的"常量"部分中都有注明）允许使用指针指定字段；其他所有常量都要求通过字段位置指定字段。
    </param>
    <param name="uNewSetting">
      如果指定，此参数用于更改设置的值。<br/>
      数据类型（以及是否可以指定 <paramref name="uNewSetting" />）取决于 <paramref name="kInfoType" /> 常量，并在下面的"常量"部分中有详细说明。<br/>
    </param>
    <returns>
      如果未指定 <paramref name="uNewSetting" />，DBFieldInfo() 返回当前设置。<br/>
      如果指定了 <paramref name="uNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      DBFieldInfo() 检索字段（列）状态的信息。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      <include file="RTComments.xml" path="Comments/DBS_Constants/*"  />
      可用的字段信息由 RDD 定义。
      在 DBF 工作区模型中，这仅限于存储在 DBF 文件结构中的信息
      （即名称、长度、小数位数和数据类型）以及可以在运行时更改的字段别名。
      为了支持其他数据库模型（如基于字典的数据库）的 RDD，这些数据库存储了
      每个字段或列的更多信息，X# RDD API 已经得到了增强。<br/>
      DBFieldInfo() 和 VODBFieldInfo() 函数旨在允许
      第三方 RDD 开发人员定义额外的 <paramref name="kInfoType" /> 值。
    </remarks>
    <example>
      以下示例使用 DBFieldInfo() 检索字段信息：
      <code language="X#">
        QOut(DBFieldInfo(DBS_NAME, 1))
        // 等同于 FieldName(1)
        FUNCTION DBOutStruct() AS ARRAY PASCAL
        &#0009;LOCAL aStruct AS ARRAY
        &#0009;LOCAL wFcount AS DWORD
        &#0009;LOCAL i       AS DWORD
        &#0009;aStruct := {}
        &#0009;wFcount := FCount()
        &#0009;FOR i := 1 UPTO wFcount
        &#0009;&#0009;AAdd(aStruct, {FieldName(i), ;
        &#0009;&#0009;DBFieldInfo(DBS_TYPE, i)  , ;
        &#0009;&#0009;DBFieldInfo(DBS_LEN, i)   , ;
        &#0009;&#0009;DBFieldInfo(DBS_DEC, i)}&#0009;)
        &#0009;NEXT
        &#0009;RETURN aStruct
      </code>
      下一个示例演示如何使用第三个参数为字段名分配别名：
      <code language="X#">
        FUNCTION Start()
        &#0009;USE datebook
        &#0009;DBFieldInfo(DBS_ALIAS, FieldPos("Name"), "NewName")
        &#0009;? Name&#0009;&#0009;&#0009;// 显示 name 字段
        &#0009;? NewName&#0009;&#0009;&#0009;// 也显示 name 字段
      </code>
      &#0009;
      &#0009;
      &#0009;
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRecordInfo'>DBRecordInfo</seealso>
    <seealso cref='O:VO.DbServer.FieldInfo'>DBServer:FieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddInfo'>RDDInfo</seealso>
  </dbfieldinfo>

  <dbfilter>
    <summary>
      返回过滤条件。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      工作区中定义的过滤条件。<br/>
      如果未设置过滤条件，DBFilter() 返回 NULL_STRING。
    </returns>
    <remarks>
      DBFilter() 是一个数据库函数，用于通过返回过滤表达式作为字符串来保存和重新执行活动过滤器。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      此函数的操作类似于 DBRelation() 和 DBRSelect() 函数，它们在工作区内保存和重新执行关系的链接表达式。
      <note type="tip">
        声明变量：&#0009;如果原始过滤表达式包含对局部或静态变量的引用，或者以其他方式依赖于编译时声明，则使用宏运算符 (&amp;) 重新编译和执行时，DBFilter() 返回的字符串将无法正确运行。
      </note>
    </remarks>
    <example>
      此示例打开两个数据库文件，设置两个过滤器，然后显示两个工作区的过滤表达式：
      <code language="X#">
        USE customer INDEX customer NEW
        SET FILTER TO Last = "Smith"
        USE invoices INDEX invoices NEW
        SET FILTER TO CustId = "Smi001"
        SELECT customer
        QOut(DBFilter())
        // 结果: Last = "Smith"
        QOut(Invoices-&gt;DBFilter())
        // 结果: Custid = "Smi001"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRelation'>DBRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRSelect'>DBRSelect</seealso>
    <seealso cref='P:VO.DbServer.Filter'>DBServer:Filter</seealso>
    <seealsocmd>SET FILTER</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbFilter'>VODBFilter</seealso>
  </dbfilter>

  <dbgetselect>
    <summary>
      返回工作区编号。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      表示工作区编号的数字。
    </returns>
    <remarks>
      DBGetSelect() 是获取当前选定工作区编号的推荐方法。但是，它不会检索有关数据库占用此工作区的任何信息。
    </remarks>
    <example>
      以下示例检查当前工作区：
      <code language="X#">
        IF !USED(DBGetSelect())
        &#0009;QOut("没有正在使用的工作区。")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbGetSelect'>VODBGetSelect</seealso>
  </dbgetselect>

  <dbgobottom>
    <summary>
      移动到最后一个逻辑记录。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      DBGoBottom() 在功能上等同于 GO BOTTOM 命令。<br/>
      有关更多信息，请参阅 GO 命令。
      <note type="tip">
        逻辑记录：&#0009;DBGoBottom() 操作逻辑记录。<br/>
        如果工作区有活动的排序列表，DBGoBottom() 将移动到控制顺序中的最后一条记录。<br/>
        如果设置了过滤器，则只考虑符合过滤条件的记录。
        共享模式：&#0009;对于共享文件，移动到不同的记录可能会导致当前记录的更新对其他进程可见。
      </note>
    </remarks>
    <example>
      以下示例使用 DBGoBottom() 将记录指针定位到最后一个逻辑记录：
      <code language="X#">
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", TRUE)
        Sales-&gt;DBSetIndex("lastname")
        Sales-&gt;DBGoBottom()
        IF Sales-&gt;Last == "Winston"
        &#0009;IF Sales-&gt;RLock()
        &#0009;&#0009;Sales-&gt;DBDelete()
        &#0009;&#0009;QOut("已删除记录：", Sales-&gt;Deleted())
        &#0009;ELSE
        &#0009;&#0009;QOut("无法锁定记录...")
        &#0009;ENDIF
        END
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bof'>BOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoTop'>DBGoTop</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealso cref='O:VO.DbServer.GoBottom'>DBServer:GoBottom</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSkip'>DBSkip</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealsocmd>GO</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbGoBottom'>VODBGoBottom</seealso>
  </dbgobottom>

  <dbgoto>
    <summary>
      移动到指定记录号的记录。
    </summary>
    <param name="uRecID">
      要移动到的记录号。<br/>
      如果 <paramref name="uRecID" /> 不存在，工作区将定位到 LastRec() + 1，并且 EOF() 和 BOF() 都返回 TRUE。
    </param>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      DbGoTo() 执行与 GO 命令相同的功能。<br/>
      有关更多信息，请参阅 GO 命令。
      <note type="tip">
        逻辑记录：&#0009;DBGoTo() 不遵循逻辑可见性。也就是说，如果指定的记录存在，它将成为当前记录，而不考虑任何排序或过滤条件。
        共享模式：&#0009;对于共享文件，移动到不同的记录可能会导致当前记录的更新对其他进程可见。
      </note>
    </remarks>
    <example>
      以下示例使用 DbGoTo() 迭代处理每四条记录：
      <code language="X#">
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", TRUE)
        // 切换每四条记录
        DO WHILE !EOF()
        &#0009;DBGoTo(RecNo() + 4)
        &#0009;Sales-&gt;Group := "Bear"
        ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bof'>BOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoBottom'>DBGoBottom</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoTop'>DBGoTop</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealso cref='O:VO.DbServer.GoTo'>DBServer:GoTo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSkip'>DBSkip</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealsocmd>GO</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbGoto'>VODBGoTo</seealso>
  </dbgoto>

  <dbgotop>
    <summary>
      移动到第一个逻辑记录。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      DBGoTop() 执行与 GO TOP 命令相同的功能。
      <note type="tip">
        逻辑记录：&#0009;DBGoTop() 操作逻辑记录。<br/>
        如果工作区有活动的排序列表，DBGoTop() 会移动到控制顺序中的第一条记录。<br/>
        如果设置了过滤器，则只考虑满足过滤条件的记录。
        共享模式：&#0009;对于共享文件，移动到不同的记录可能会导致当前记录的更新对其他进程可见。
      </note>
    </remarks>
    <example>
      此示例演示了 DBGoTop() 的典型用法：
      <code language="X#">
        DBGoTop()
        WHILE (!EOF())
        &#0009;QOut(_FIELD-&gt;Name)
        &#0009;DBSkip()
        END
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bof'>BOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoBottom'>DBGoBottom</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealso cref='O:VO.DbServer.GoTop'>DBServer:GoTop</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSkip'>DBSkip</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealsocmd>GO</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbGoTop'>VODBGoTop</seealso>
  </dbgotop>

  <dbinfo>
    <summary>
      返回并可选择性地更改有关工作区中打开的数据库文件的信息。
    </summary>
    <param name="kInfoType">
      指定信息的类型。<br/>
      常量在下面的"常量"部分中描述。但请注意，并非所有常量都适用于所有RDD。<br/>
    </param>
    <param name="uNewSetting">
      如果指定，此参数用于更改设置的值。<br/>
      数据类型（以及是否可以指定 <paramref name="uNewSetting" />）取决于 <paramref name="kInfoType" /> 常量，并在下面的"常量"部分中有详细说明。<br/>
    </param>
    <returns>
      如果未指定 <paramref name="uNewSetting" />，RDDInfo() 返回当前设置。<br/>
      如果指定了 <paramref name="uNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      <include file="RTComments.xml" path="Comments/DBI_Constants/*"  />
    </remarks>
    <example>
      以下示例返回工作区信息：
      <code language="X#">
        ? DBInfo(DBI_GETHEADERSIZE)&#0009;// 等同于 Header()
        ? DBInfo(DBI_LASTUPDATE)&#0009;&#0009;// 等同于 LUpdate()
        ? DBInfo(DBI_GETRECSIZE)&#0009;&#0009;// 等同于 RecSize()
        ? DBInfo(DBI_FULLPATH)&#0009;&#0009;// 完整路径名
      </code>
      以下示例将显示当前工作区中使用的所有RDD：
      <code language="X#">
        FUNCTION RddTest()
        &#0009;LOCAL n, i AS INT
        &#0009;LOCAL rddList AS _RDDLIST
        &#0009;USE Demo NEW
        &#0009;rddList := DBInfo(DBI_RDD_LIST)
        &#0009;? "涉及的Rdds: ", rddList.uiRddCount
        &#0009;FOR i := 1 UPTO rddList.uiRddCount
        &#0009;&#0009;&#0009;? rddList.atomRddName[I]
        &#0009;NEXT I
        &#0009;MemFree(rddList)
        &#0009;RETURN
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRecordInfo'>DBRecordInfo</seealso>
    <seealso cref='O:VO.DbServer.FieldInfo'>DBServer:FieldInfo</seealso>
    <seealso cref='O:VO.DbServer.Info'>DBServer:Info</seealso>
    <seealso cref='O:VO.DbServer.RecordInfo'>DBServer:RecordInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbInfo'>VODBInfo</seealso>
  </dbinfo>

  <dbjoin>
    <summary>
      通过合并两个工作区的记录/字段来创建一个新的数据库文件。
    </summary>
    <param name="cAlias">
      要加入的工作区的别名标识符。<br/>
      如果没有与<paramref name="cAlias" />关联的打开数据库，则会引发运行时错误。
    </param>
    <param name="cTargetFile">
      目标数据库文件的名称，包括可选的驱动器、目录和扩展名。请参阅SetDefault()和SetPath()了解文件搜索和创建规则。<br/>
      数据库文件的默认扩展名由RDD确定。<br/>
      &#0009;如果<paramref name="cTargetFile" />不存在，则会创建它。<br/>
      如果它存在，此函数会尝试以独占模式打开文件，如果成功，文件将被覆盖，不会发出警告或错误。<br/>
      如果访问被拒绝（例如，因为另一个进程正在使用该文件），NetErr()将被设置为TRUE。
    </param>
    <param name="acFields">
      两个工作区中字段到新数据库文件的投影。<br/>
      要指定次要工作区中的字段，请使用别名运算符(-&gt;)引用它们。<br/>
      如果未指定<paramref name="acFields" />，则源数据库文件中的所有字段都将包含在目标数据库文件中。
    </param>
    <param name="cbForCondition">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/cbfor/*" />
    </param>
    <returns>
      如果成功则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
      DBJoin()是JOIN命令的函数等价物。
    </remarks>
    <example>
      以下示例演示了DBJoin()的使用：
      <code language="X#">
        USE joinme
        IF Used()
        &#0009;DBJoin("test2", "merge.dbf")
        ENDIF
      </code>
    </example>
    <seealso cref='O:VO.DbServer.Join'>DBServer:Join</seealso>
    <seealsocmd>JOIN</seealsocmd>
  </dbjoin>

  <dblocate>
    <summary>
      搜索匹配指定条件和范围的第一条记录。
    </summary>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      如果成功则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      DBLocate()是LOCATE命令的函数形式。
      DBLocate()从范围的起始记录开始搜索。<br/>
      当找到匹配项或达到范围末尾时终止。<br/>
      如果成功，匹配的记录成为当前记录，Found()返回TRUE。
      如果不成功，Found()返回FALSE，记录指针的位置取决于范围。
      每个工作区可以有自己的定位条件。
      该条件保持活动状态，直到在该工作区执行另一个定位条件或应用程序终止。
      DBLocate()与DBContinue()配合使用。一旦发出DBLocate()，您可以使用DBContinue()从当前记录指针位置恢复搜索。
      然而，有一些例外。范围和<paramref name="cbWhileCondition" />仅适用于初始DBLocate()函数，对任何后续DBContinue()函数不起作用。<br/>
      要继续带有范围或<paramref name="cbWhileCondition" />的待定定位条件，请使用DBSkip()；然后使用<paramref name="lRest" />和<paramref name="cbWhileCondition" />参数的DBLocate()，而不是DBContinue()。
    </remarks>
    <example>
      此示例按顺序搜索字符串：
      <code language="X#">
        PROCEDURE Start()
        &#0009;DBUseArea(TRUE,, "sales")
        &#0009;&#0009;DBLocate({||"Widget" == Sales-&gt;Name},,,-1)
        &#0009;IF Found()
        &#0009;&#0009;QOut("我有一个小部件。")
        &#0009;ELSE
        &#0009;&#0009;QOut("未找到。")
        &#0009;ENDIF
        &#0009;RETURN
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbContinue'>DBContinue</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealso cref='O:VO.DbServer.Locate'>DBServer:Locate</seealso>
    <seealsocmd>LOCATE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbLocate'>VODBLocate</seealso>
  </dblocate>

  <dbmemoext>
    <summary>返回当前工作区文件的备注扩展名。例如DBT或FPT。</summary>
    <returns>文件的备注扩展名（如果有）。当没有打开文件时，返回默认RDD的默认备注扩展名。</returns>
  </dbmemoext>

  <dbmemofield>
    <summary>
      返回DBF记录的备注字段指针。
    </summary>
    <param name="uField">
      表示所需备注字段的名称、编号或符号。<br/>
      如果省略，默认为数据库中的第一个备注字段（如果有）。
    </param>
    <returns>
      如果成功，返回DBF记录中指定备注字段的内容；否则返回NIL。
    </returns>
    <remarks>
      DBMemoField()返回DBF中备注字段的10字节值。<br/>
      此值可用于特殊目的，因为它实际上是相关备注文件中适当备注块的指针（或偏移量）。
    </remarks>
    <example>
      以下示例演示了DBMemoField()函数的使用：
      <code language="X#">
        FUNC TestMField
        &#0009;LOCAL n         AS INT
        &#0009;LOCAL cMemoOffs AS STRING
        &#0009;USE demo1 VIA "DBFCDX"
        &#0009;n := FieldPos("comment")
        &#0009;DO WHILE !EOF()
        &#0009;cMemoOffs := DBMemoField(n)
        &#0009;? RECNO(), cMemoOffs
        &#0009;SKIP
        &#0009;ENDDO
        &#0009;CLOSE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
  </dbmemofield>

  <dborderinfo>
    <summary>
      返回并可选择性地更改有关索引顺序和索引文件的信息。
    </summary>
    <param name="kInfoType">
      指定信息的类型。<br/>
      常量列表如下。但请注意，并非所有常量都被所有RDD支持。<br/>
      &#0009;重要提示！DBOI_USER是一个常量，它返回第三方RDD开发人员可以用于定义新的<paramref name="kInfoType" />参数的最小值。小于DBOI_USER的值保留给Computer Associates开发使用。
    </param>
    <param name="cIndexFile">
      索引文件的名称，包括可选的驱动器和目录（不应指定扩展名）。<br/>
      与<paramref name="cOrder" />一起使用此参数，以消除不同索引文件中存在两个或多个同名顺序时的歧义。<br/>
      &#0009;如果当前进程未打开<paramref name="cIndexFile" />，则会引发运行时错误。
    </param>
    <param name="uOrder">
      您想获取信息的顺序名称，或表示其在顺序列表中位置的数字。（对于单顺序索引文件，顺序名称是八字母的索引文件名。）<br/>
      使用顺序名称是首选方法，因为使用多顺序索引文件时可能难以确定位置。无效值将被忽略。<br/>
      &#0009;如果未指定索引文件或顺序，则假定为控制顺序。
    </param>
    <param name="uNewSetting">
      如果指定，此参数用于更改设置的值。<br/>
      数据类型（以及是否可以指定<paramref name="uNewSetting" />）取决于<paramref name="kInfoType" />常量，并在下面的常量部分中有所说明。<br/>
    </param>
    <returns>
      如果未指定<paramref name="uNewSetting" />，DBOrderInfo()返回当前设置。<br/>
      如果指定了<paramref name="uNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      <include file="RTComments.xml" path="Comments/DBOI_Constants/*"  />
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      此示例使用DBOI_NAME保存当前控制顺序。<br/>
      更改为新的控制顺序后，它使用保存的值恢复原始顺序：
      <code language="X#">
        USE customer INDEX name, serial NEW
        cOrder := DBOrderInfo(DBOI_NAME)&#0009;&#0009;// name
        Customer-&gt;DBSetOrder("serial")
        ? DBOrderInfo(DBOI_NAME)&#0009;&#0009;&#0009;// serial
        Customer-&gt;DBSetOrder(cOrder)
        ? DBOrderInfo(DBOI_NAME)&#0009;&#0009;&#0009;// name
      </code>
      此示例使用别名表达式在两个不同的工作区中返回默认索引文件扩展名（使用DBOI_INDEXEXT）：
      <code language="X#">
        USE sales INDEX all_sales VIA "DBFCDX" NEW
        USE customer INDEX name, serial VIA "DBFNTX" NEW
        ? Sales-&gt;DBOrderInfo(DBOI_INDEXEXT)&#0009;// .CDX
        ? Customer-&gt;DBOrderInfo(DBOI_INDEXEXT)&#0009;// .NTX
      </code>
      在此示例中，DBOrderInfo(DBOI_INDEXEXT)检查CUSTOMER索引文件是否存在，而不依赖于链接到当前工作区的RDD：
      <code language="X#">
        USE customer NEW
        IF !File("customer" + DBOrderInfo(DBOI_INDEXEXT))
        &#0009;Customer-&gt;DBCreateIndex("customer", "CustName",;
        &#0009;&#0009;{|| Customer-&gt;CustName})
        ENDIF
      </code>
      此示例访问同一索引文件中几个顺序的键表达式：
      <code language="X#">
        USE customer INDEX all_cust VIA "DBFMDX" NEW
        Customer-&gt;DBSetOrder("serial")
        ? DBOrderInfo(DBOI_EXPRESSION,, "name")
        // 结果：name顺序的键表达式
        ? DBOrderInfo(DBOI_EXPRESSION,, "serial")
        // 结果：serial顺序的键表达式
      </code>
      此示例将DBOrderInfo()用作TOTAL ON键表达式的一部分。由于DBOrderInfo()将表达式作为字符串返回，因此使用宏表达式来强制评估键表达式：
      <code language="X#">
        USE sales INDEX salesman NEW
        TOTAL ON &amp;(DBOrderInfo(DBOI_EXPRESSION)) ;
        &#0009;FIELDS SaleAmount TO summary
      </code>
      在此示例中，ALL_CUST.MDX包含三个名为CUACCT、CUNAME、CUZIP的顺序。<br/>
      DBOI_INDEXNAME常量用于使用其中一个顺序显示索引文件的名称：
      <code language="X#">
        USE customer VIA "DBFNTX" NEW
        Customer-&gt;DBSetIndex("all_cust")
        ? DBOrderInfo(DBOI_INDEXNAME,, "cuname")
        // 返回：all_cust
      </code>
      以下示例在顺序列表中搜索CUNAME：
      <code language="X#">
        USE customer VIA "DBFNTX" NEW
        Customer-&gt;DBSetIndex("cuacct")
        Customer-&gt;DBSetIndex("cuname")
        Customer-&gt;DBSetIndex("cuzip")
        ? DBOrderInfo(DBOI_NUMBER,, "cuname")&#0009;// 2
      </code>
      此示例从顺序中检索"for条件"：
      <code language="X#">
        USE customer NEW
        INDEX ON Customer-&gt;Acct TO customer ;
        &#0009;FOR Customer-&gt;Acct &gt; "AZZZZZ"
        ? DBOrderInfo(DBOI_CONDITION,, "customer")
        // 返回：Customer-&gt;Acct &gt; "AZZZZZ"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRecordInfo'>DBRecordInfo</seealso>
    <seealso cref='O:VO.DbServer.FieldInfo'>DBServer:FieldInfo</seealso>
    <seealso cref='O:VO.DbServer.Info'>DBServer:Info</seealso>
    <seealso cref='O:VO.DbServer.OrderInfo'>DBServer:OrderInfo</seealso>
    <seealso cref='O:VO.DbServer.RecordInfo'>DBServer:RecordInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddInfo'>RDDInfo</seealso>
  </dborderinfo>

  <dbpack>
    <summary>
      从数据库文件中删除所有标记为删除的记录，重建所有活动顺序，并恢复被删除记录占用的所有物理空间。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      如果成功则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      此函数要求当前数据库以独占模式打开（参见SetExclusive()）。<br/>
      如果在调用函数时不满足此条件，将引发运行时错误。<br/>
      否则，操作将继续进行，并在终止时将记录指针重置为当前工作区中的第一个逻辑记录。
      警告！DBPack()不会创建备份文件。您可能想在发出此函数调用之前对文件进行备份；否则，您将无法恢复已删除的记录。
      提示：压缩大型数据库文件可能是一个耗时的过程，因此不建议在高容量事务应用程序中使用。通过修改应用程序设计，您可以消除从数据库文件中物理删除记录的必要性。只需使用SetDeleted(TRUE)或DBSetFilter(!Deleted())过滤已删除的记录，并重用已删除的记录而不是添加新记录。
    </remarks>
    <example>
      以下示例使用DBPack()和别名表达式从文件中删除所有标记为删除的记录：
      <code language="X#">
        Address-&gt;DBPack()
        // 对Address别名进行操作
      </code>
    </example>
    <seealso cref='O:VO.DbServer.Pack'>DBServer:Pack</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetExclusive'>SetExclusive</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbDelete'>VODBDelete</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbPack'>VODBPack</seealso>
  </dbpack>

  <dbrecall>
    <summary>
      如果当前记录已被标记为删除，则恢复该记录。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      如果成功则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      DBRecall()执行与RECALL命令相同的功能。<br/>
      有关更多信息，请参阅DELETE和RECALL命令。
      <note type="tip">
        逻辑记录：&#0009;如果SetDeleted()为TRUE，恢复已删除的记录会影响记录的逻辑可见性。<br/>
        有关更多信息，请参阅DBDelete()函数以及DELETE和RECALL命令。
        共享模式：&#0009;对于共享数据库，DBRecall()要求当前记录被锁定。
      </note>
    </remarks>
    <example>
      以下示例在记录被删除时恢复该记录，并尝试在成功时锁定该记录：
      <code language="X#">
        cLast := "Winston"
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", TRUE)
        Sales-&gt;DBSetIndex("LastName")
        IF Sales-&gt;DBSeek(cLast)
        &#0009;IF Sales-&gt;Deleted()
        &#0009;&#0009;IF Sales-&gt;RLock()
        &#0009;&#0009;&#0009;Sales-&gt;DBRecall()
        &#0009;&#0009;&#0009;QOut("记录已恢复")
        &#0009;&#0009;ELSE
        &#0009;&#0009;&#0009;QOut("无法锁定记录...")
        &#0009;&#0009;ENDIF
        &#0009;ENDIF
        ELSE
        &#0009;QOut("未找到")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDelete'>DBDelete</seealso>
    <seealso cref='O:VO.DbServer.Recall'>DBServer:Recall</seealso>
    <seealsocmd>DELETE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.Deleted'>Deleted</seealso>
    <seealsocmd>RECALL</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbRecall'>VODBRecall</seealso>
  </dbrecall>

  <dbrecordinfo>
    <summary>
      检索记录的字段定义信息。
    </summary>
    <param name="kInfoType">
      确定检索的信息类型。<br/>
      常量列表如下。
    </param>
    <param name="uRecID">
      您想要获取信息的记录ID。<br/>
      如果省略，则报告当前记录。
    </param>
    <param name="uNewValue">此参数保留给允许更改信息而不仅仅是检索信息的RDD。提供的RDD均不支持此参数。可以省略此参数或将其指定为NIL。</param>
    <returns>
    </returns>
    <remarks>
      <include file="RTComments.xml" path="Comments/DBRI_Constants/*"  />
    </remarks>
    <example>
      以下示例检索记录信息：
      <code language="X#">
        DBRecordInfo(DBRI_RECSIZE)
        // 等同于 RecSize()
        DBRecordInfo(DBRI_LOCKED, 200)
        // 记录200是否被锁定？
        DBRecordInfo(DBRI_DELETED, 201)
        // 记录201是否被删除？
        DBRecordInfo(DBRI_FORCEREFRESH)
        // 将当前记录重新读入缓冲区
        DBRecordInfo(DBRI_RECNO, 230)
        // 记录230在哪个位置？
        // 如果没有活动的排序，位置是230，
        // 否则将返回排序内的相对位置。
        DBRecordInfo(DBRI_BUFFPTR)
        // 返回缓冲区中当前记录的指针
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddInfo'>RDDInfo</seealso>
  </dbrecordinfo>

  <dbreindex>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <summary>
      重建工作区中 Order 列表的所有 Order 。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      所有 Order 都会被重建，遵循创建 Order 时指定的唯一性、降序标志和 for 条件。<br/>
      重建 Order 后，工作区将定位到控制 Order 中的第一个逻辑记录。
      尽管此操作在共享和独占模式下都可以工作，但强烈推荐使用独占模式。有关更多信息，请参阅 SetExclusive()。
      注意！DBReindex() 在重新创建 Order 时不会重新创建索引文件的头部。因此，如果文件头部发生损坏，DBReindex() 无法提供帮助。<br/>
      为保证索引有效，在重建损坏的索引文件时，请始终使用 DBCreateIndex() 而不是 DBReindex()。
    </remarks>
    <example>
      此示例在未找到特定记录时执行 DBReindex()：
      <code language="X#">
        DBUseArea(TRUE,, "Address")
        DBGoBottom()
        DBUseArea(TRUE,, "customer",, FALSE)
        &#0009;//以独占方式打开文件
        DBSetIndex("CustID")
        DBSeek(Address-&gt;Cust_ID)
        IF !Found()
        &#0009;? "引用完整性失败："
        &#0009;? "在客户索引文件中未找到最后一条地址记录。"
        &#0009;? "索引不是最新的或记录丢失。正在重新索引..."
        &#0009;IF !DBReindex()
        &#0009;&#0009;? "重新索引失败"
        &#0009;&#0009;DBCloseAll()
        &#0009;&#0009;QUIT
        &#0009;ENDIF
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
    <seealso cref='O:VO.DbServer.CreateOrder'>DBServer:CreateOrder</seealso>
    <seealso cref='O:VO.DbServer.Reindex'>DBServer:Reindex</seealso>
    <seealso cref='O:VO.DbServer.SetIndex'>DBServer:SetIndex DBServer:SetOrderCondition</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrderCondition'>DBSetOrderCondition</seealso>
    <seealsocmd>REINDEX</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetExclusive'>SetExclusive</seealso>
    <seealsocmd>USE</seealsocmd>
  </dbreindex>

  <dbrelation>
    <summary>
      返回指定关系的链接表达式。
    </summary>
    <param name="nRelation">
      所需关系在当前工作区关系列表中的位置。<br/>
      关系按照通过关系设置定义的顺序进行编号。
    </param>
    <returns>
      为 <paramref name="nRelation" /> 定义的链接表达式。<br/>
      如果 <paramref name="nRelation" /> 没有设置关系，DBRelation() 返回 NULL_STRING。
    </returns>
    <remarks>
      DBRelation() 是一个数据库函数，用于确定现有关系的链接表达式和工作区。
      DBRelation() 返回由 TO 子句定义的链接表达式。DBRSelect() 返回由 INTO 子句定义的链接工作区。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      <note type="tip">
        声明变量：&#0009;如果原始表达式包含对局部或静态变量的引用，或者依赖于编译时声明，则由 DBRelation() 返回的字符串在使用宏运算符 (&amp;) 重新编译和执行时无法正确运行。
      </note>
    </remarks>
    <example>
      此示例打开三个数据库文件，从父工作区设置两个子关系，然后显示到第二个子工作区的链接表达式：
      <code language="X#">
        USE invoices INDEX invoices NEW
        USE backorder INDEX backorder NEW
        USE customer INDEX customer NEW
        SET RELATION TO custnum INTO invoices, OrderNum ;
        &#0009;&#0009;INTO backorder
        QOut(DBRelation(2))&#0009;&#0009;&#0009;&#0009;// 结果：Ordernum
      </code>
      之后，您可以使用别名表达式从未选择的工作区查询相同的链接表达式，如下所示：
      <code language="X#">
        USE archive NEW
        QOut(Customer-&gt;DBRelation(2))
        // 结果：OrderNum
      </code>
      这个示例是一个函数 Relation()，它将 DBRelation() 和 DBRSelect() 的结果作为数组返回：
      <code language="X#">
        FUNCTION Relation(nRelation)
        &#0009;RETURN {;
        &#0009;&#0009;&#0009;&#0009;DBRelation(nRelation), ;
        &#0009;&#0009;&#0009;&#0009;Alias(DBRSelect(nRelation)) ;
        &#0009;&#0009;&#0009;}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFilter'>DBFilter</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRSelect'>DBRSelect</seealso>
    <seealso cref='O:VO.DbServer.Relation'>DBServer:Relation</seealso>
    <seealsocmd>SET RELATION</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbRelation'>VODBRelation</seealso>
  </dbrelation>

  <dbrlock>
    <summary>
      在共享数据库文件中锁定记录，可选择保留先前的记录锁定。
    </summary>
    <param name="uRecId">
      要锁定的记录的ID（通常是记录号）。<br/>
      如果指定，当前进程持有的记录锁将被保留。<br/>
      如果未指定，当前进程持有的所有锁将被释放，并假定为当前记录。
    </param>
    <returns>
      如果获得记录锁定则返回TRUE；否则返回FALSE。<br/>
      在空数据库中尝试锁定记录将返回TRUE。
    </returns>
    <remarks>
      如果数据库文件以共享模式打开，在尝试任何写入数据库文件的操作之前，必须获得记录锁定。
      对于每次调用DBRLock()，都会尝试一次锁定目标记录，并将结果作为逻辑值返回。<br/>
      如果另一个进程当前持有目标记录的文件锁或记录锁，则尝试获取记录锁将失败。
      如果DBRLock()成功，记录将被锁定，其他进程将被阻止更新该记录，直到锁被释放。DBRLock()提供共享锁，允许其他用户对锁定的记录进行只读访问，同时只允许当前进程修改它。
      记录锁将一直有效，直到您显式解锁它（例如，使用DBUnLock()），关闭数据库文件，或尝试另一个文件或记录锁（使用RLock()或不带参数的DBRLock()）。当指定参数时，DBRLock()不会释放当前进程持有的记录锁。相反，它会将新锁定的记录添加到锁定列表中（参见DBRLockList()）。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      这个特性很有用，因为DBRLock()不会自动尝试为相关文件锁定记录。
    </remarks>
    <example>
      这个例子使用DBRLock()从共享数据库文件中删除一条记录：
      <code language="X#">
        USE customer INDEX custname SHARED NEW
        SEEK "Smith"
        IF Found()
        &#0009;IF Customer-&gt;DBRLock()
        &#0009;&#0009;DELETE
        &#0009;&#0009;QOut("Smith已删除")
        &#0009;ELSE
        &#0009;&#0009;QOut("记录正被其他用户使用")
        &#0009;ENDIF
        ELSE
        &#0009;QOut("Smith不在客户文件中")
        ENDIF
        CLOSE
      </code>
      这个例子将DBRLock()指定为别名表达式，以锁定未选择的工作区中的记录：
      <code language="X#">
        USE sales SHARED NEW
        USE customer SHARED NEW
        IF !Sales-&gt;DBRLock()
        &#0009;QOut("当前销售记录正在使用中")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLockList'>DBRLockList</seealso>
    <seealso cref='O:VO.DbServer.LockCurrentRecord'>DBServer:LockCurrentRecord</seealso>
    <seealso cref='O:VO.DbServer.LockSelection'>DBServer:LockSelection</seealso>
    <seealso cref='P:VO.DbServer.RLockList'>DBServer:RLockList</seealso>
    <seealso cref='O:VO.DbServer.RLockVerify'>DBServer:RLockVerify</seealso>
    <seealso cref='O:VO.DbServer.UnLock'>DBServer:UnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLock'>DBUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUseArea'>DBUseArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.Flock'>FLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.RLock'>RLock</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetExclusive'>SetExclusive</seealso>
    <seealsocmd>UNLOCK</seealsocmd>
    <seealsocmd>USE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbRlock'>VODBRLock</seealso>
  </dbrlock>

  <dbrlocklist>
    <summary>
      获取锁定记录的列表。
    </summary>
    <returns>
      包含当前锁定记录编号的数组。
    </returns>
    <remarks>
      DBRLock()可用于在单个工作区中获取多个记录锁。<br/>
      此函数以数组形式返回所有锁定记录的编号。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      以下示例显示所有当前锁定的记录：
      <code language="X#">
        aRecs := DBRLockList()
        n := ALen(aRecs)
        ? "锁定的记录数: ", n
        ?
        FOR i := 1 UPTO n
        &#0009;? "锁定的记录 ", aRecs[i]
        NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:VO.DbServer.LockCurrentRecord'>DBServer:LockCurrentRecord</seealso>
    <seealso cref='O:VO.DbServer.LockSelection'>DBServer:LockSelection</seealso>
    <seealso cref='P:VO.DbServer.RLockList'>DBServer:RLockList</seealso>
    <seealso cref='O:VO.DbServer.RLockVerify'>DBServer:RLockVerify</seealso>
    <seealso cref='O:VO.DbServer.UnLock'>DBServer:UnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.RecNo'>RecNo</seealso>
  </dbrlocklist>

  <dbrselect>
    <summary>
      返回关系的工作区号。
    </summary>
    <param name="nRelation">
      工作区关系列表中所需关系的位置。<br/>
      关系按照关系设置中定义的顺序编号。
    </param>
    <returns>
      指定关系的工作区号。<br/>
      如果没有为 <paramref name="nRelation" /> 设置关系，DBRSelect() 返回 0。
    </returns>
    <remarks>
      DBRSelect() 是一个数据库函数，与 DBRelation() 结合使用，用于确定现有关系的工作区和链接表达式。DBRSelect() 返回由 INTO 子句定义的工作区。DBRelation() 返回由 TO 子句定义的链接表达式。<br/>
      要确定关系的别名而不是工作区号，请使用表达式 Alias(DBRSelect(<paramref name="nRelation" />))。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      此示例打开三个数据库文件，从父工作区设置两个子关系，然后显示到第二个子工作区的链接表达式以及关系的目标工作区：
      <code language="X#">
        USE invoices INDEX invoices NEW
        USE backorder INDEX backorder NEW
        USE customer INDEX customer NEW
        SET RELATION TO custnum INTO customer, ;
        &#0009;&#0009;Ordernum INTO Backorder
        QOut(DBRelation(2), DBRSelect(2))
        // 结果：Ordernum 3
        QOut(Alias(DBRSelect(2))
        // 结果：BackOrder
      </code>
      之后，您可以使用别名表达式从未选择的工作区查询相同的信息：
      <code language="X#">
        USE archive NEW
        QOut(Customer-&gt;DBRelation(2))
        // 结果：Ordernum
        QOut(Customer-&gt;DBRSelect(2))
        // 结果：3
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFilter'>DBFilter</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRelation'>DBRelation</seealso>
    <seealsocmd>SET RELATION</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbRSelect'>VODBRSelect</seealso>
  </dbrselect>

  <dbrunlock>
    <summary>
      释放所有或指定的记录锁。
    </summary>
    <param name="uRecID">
      由数据文件结构保证的唯一值，用于引用数据源（数据库）中的特定项。在数据库文件中，<paramref name="uRecID" /> 是记录号。在其他数据格式中，<paramref name="uRecID" /> 是唯一的主键值。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBRUnLock() 释放 <paramref name="uRecID" /> 的锁定并将其从锁定列表中移除。<br/>
      如果未指定 <paramref name="uRecID" />，则释放所有记录锁。
    </remarks>
    <example>
      以下示例解锁一系列记录：
      <code language="X#">
        PROCEDURE dbRUnLockRange(nLo AS SHORTINT, nHi AS SHORTINT)
        &#0009;LOCAL nCounter
        &#0009;// 解锁从 nLo 到 nHi 范围内的记录
        &#0009;FOR nCounter := nLo UPTO nHi
        &#0009;&#0009;DBRUnLock(nCounter)
        &#0009;NEXT
        &#0009;RETURN
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRLockList'>DBRLockList</seealso>
    <seealso cref='O:VO.DbServer.RLockVerify'>DBServer:RLockVerify</seealso>
    <seealso cref='O:VO.DbServer.UnLock'>DBServer:UnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.RLock'>RLock</seealso>
  </dbrunlock>

  <dbseek>
    <summary>
      移动到控制顺序中具有指定键值的记录。
    </summary>
    <param name="uKey">指定与所需记录关联的键值。</param>
    <param name="lSoftSeek">
      确定如果未找到指定的键值，工作区如何定位：TRUE 执行软查找；FALSE 不执行。<br/>
      如果省略 <paramref name="lSoftSeek" />，则使用当前的 SetSoftSeek() 设置。
    </param>
    <param name="lLast">
      TRUE 查找指定键值的最后一次出现。FALSE（默认值）查找第一次出现。<paramref name="lLast" /> 仅适用于 CDX 索引。
    </param>
    <returns>
      如果找到指定的键值，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBSeek() 移动到键值等于 <paramref name="uKey" /> 的第一个逻辑记录。<br/>
      如果找到这样的记录，它将成为当前记录，并且 DBSeek() 返回 TRUE。<br/>
      否则，DBSeek() 返回 FALSE，工作区的定位如下：对于正常（非软）查找，工作区定位到 LastRec() + 1，EOF() 返回 TRUE；对于软查找，工作区定位到键值大于指定键值的第一条记录。<br/>
      如果不存在这样的记录，工作区定位到 LastRec() + 1，EOF() 返回 TRUE。
      对于没有控制顺序的工作区，DBSeek() 无效。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      DBSeek() 执行与 SEEK 命令相同的功能。<br/>
      有关更多信息，请参阅 SEEK 命令。
      <note type="tip">
        逻辑记录：&#0009;DBSeek() 操作逻辑记录。记录按控制顺序处理。<br/>
        如果设置了过滤器，则只考虑满足过滤条件的记录。
        共享模式：&#0009;对于共享文件，移动到不同的记录可能会导致当前记录的更新对其他进程可见。
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbGoBottom'>DBGoBottom</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoTop'>DBGoTop</seealso>
    <seealso cref='O:VO.DbServer.Seek'>DBServer:Seek</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSkip'>DBSkip</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.Found'>Found</seealso>
    <seealsocmd>SEEK</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetSoftSeek'>SetSoftSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbSeek'>VODBSeek</seealso>
  </dbseek>

  <dbselect>
    <summary>
      选择一个新的工作区并检索当前工作区。
    </summary>
    <param name="nNew">新工作区的工作区号。</param>
    <returns>
      旧工作区的工作区号。
    </returns>
    <remarks>
      DBSelect() 允许您更改当前工作区并同时检索当前工作区的编号。<br/>
      这在团队编程项目或编写通用黑盒例程时非常有用：每次模块通过选择新工作区来更改环境时，您都必须保存和恢复旧环境。
    </remarks>
    <example>
      以下示例设置一个新工作区并存储当前工作区的编号：
      <code language="X#">
        nOld := 0
        nNew : = 10
        nOld := DBSelect(nNew)
        ...
        // 恢复旧工作区
        DBSelect(nOld)
        ? "新工作区               :", Select()
        ? "之前选择的工作区       :", nOld
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.VoDbSelect'>VODBSelect</seealso>
  </dbselect>

  <dbselectarea>
    <summary>
      更改当前工作区。
    </summary>
    <param name="uArea">指定要选择的工作区的数字或别名。</param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBSelectArea() 使指定的工作区成为当前工作区。<br/>
      除非为某个操作明确指定了另一个工作区，否则所有后续的数据库操作都将应用于该工作区。
      DBSelectArea() 执行与 SELECT 命令相同的功能。<br/>
      有关更多信息，请参阅 SELECT 命令。
      <note type="tip">
        选择 0：&#0009;选择工作区 0 会使最低编号的未占用工作区成为当前工作区。
        别名表达式：&#0009;别名运算符 (-&gt;) 可以在评估表达式时临时选择一个工作区，并在之后自动恢复先前选择的工作区。
      </note>
    </remarks>
    <example>
      以下示例通过别名选择工作区：
      <code language="X#">
        cLast := "Winston"
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", TRUE)
        Sales-&gt;DBSetIndex("salefnam")
        Sales-&gt;DBSetIndex("salelnam")
        DBUseArea(TRUE, "DBFNTX", "colls", "Colls", TRUE)
        Colls-&gt;DBSetIndex("collfnam")
        Colls-&gt;DBSetIndex("colllnam")
        DBSelectArea("Sales")&#0009;&#0009;// 选择 Sales 工作区
        DBSelectArea("Colls")&#0009;&#0009;// 选择 Colls 工作区
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbUseArea'>DBUseArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>SELECT</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
    <seealsocmd>USE</seealsocmd>
  </dbselectarea>

  <dbsetdriver>
    <summary>
      返回并可选地更改应用程序的默认 RDD 驱动程序。
      注意：DBSetDriver() 是一个兼容性函数，不再推荐使用。<br/>
      它已被 RDDSetDefault() 函数取代。有关更多信息，请参阅 RDDSetDefault()。
    </summary>
    <param name="cNewSetting">
      当未明确指定驱动程序时，用于激活和管理应用程序的 RDD 的名称。<br/>
      如果此 RDD 对应用程序不可用，则调用不会产生任何效果。
    </param>
    <returns>
      如果未指定 <paramref name="cNewSetting" />，DBSetDriver() 返回当前默认 RDD。<br/>
      如果指定了 <paramref name="cNewSetting" />，则返回先前的默认 RDD。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例将 DBFMDX 驱动程序设置为默认 RDD。<br/>
      如果 RDD 不可用，则会发出一条消息：
      <code language="X#">
        DBSetDriver("DBFMDX")
        IF DBSetDriver() != "DBFMDX"
        &#0009;QOut("DBFMDX 驱动程序不可用")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
  </dbsetdriver>

  <dbsetfilter>
    <summary>
      设置过滤条件。
    </summary>
    <param name="cbCondition">以可执行形式表达过滤条件的代码块。</param>
    <param name="cCondition">
      一个可选的字符值，以文本形式表达过滤条件。<br/>
      如果省略 <paramref name="cCondition" />，DBFilter() 函数将为该工作区返回一个空字符串。
    </param>
    <returns>
      如果当前记录满足过滤条件则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBSetFilter() 设置逻辑过滤条件。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      设置过滤器后，不满足过滤条件的记录在逻辑上不可见。<br/>
      也就是说，对逻辑记录进行操作的数据库操作将不会考虑这些记录。
      过滤表达式可以是代码块（<paramref name="bCondition" />）或同时包含代码块和等效文本（<paramref name="cCondition" />）。<br/>
      如果同时提供了两种版本，它们必须表达相同的条件。<br/>
      DBSetFilter() 执行与 SET FILTER 命令相同的功能。<br/>
      有关更多信息，请参阅 SET FILTER 命令。
      <note type="tip">
        如果您使用的 RDD 支持优化，请使用 SET OPTIMIZE 来控制 RDD 是否会根据工作区中可用的顺序优化过滤器搜索。
      </note>
      <note type="tip">
        <b>逻辑记录：</b><br/>
        DBSetFilter() 影响记录的逻辑可见性（见上文）。
        <br/><b>副作用：</b><br/>设置过滤条件只保证按上述方式限制某些记录的可见性。<br/>
        过滤表达式不一定在任何特定时间、以任何特定方式或在任何特定记录或一系列记录上进行评估。<br/>
        如果过滤表达式依赖于数据库文件或工作区之外的信息，其效果是不可预测的。<br/>
        如果过滤表达式改变了工作区的状态（例如，移动到不同的记录或改变记录的内容），其效果是不可预测的。
        <br/><b>评估上下文：</b><br/>
        当评估过滤表达式时，相关的工作区会自动被选为当前工作区；之后会自动恢复先前选择的工作区。
      </note>
    </remarks>
    <example>
      此示例将数据访问限制为 Age 字段值小于 40 的记录：
      <code language="X#">
        USE employee NEW
        DBSetFilter({|| Age &lt; 40}, "Age &lt; 40")
        DBGoTop()
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearFilter'>DBClearFilter</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbFilter'>DBFilter</seealso>
    <seealso cref='O:VO.DbServer.SetFilter'>DBServer:SetFilter</seealso>
    <seealsocmd>SET FILTER</seealsocmd>
    <seealsocmd>SET OPTIMIZE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbSetFilter'>VODBSetFilter</seealso>
  </dbsetfilter>

  <dbsetfound>
    <summary>
      设置找到标志。
    </summary>
    <param name="lFnd">找到标志的新设置：TRUE 或 FALSE</param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      找到标志在数据库搜索函数（如 DBSeek() 或 DBLocate()）之后设置。在团队编程项目或编写通用黑盒例程时，您不希望模块产生任何副作用。DBSetFound() 让您对全局环境设置有更多控制。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      此示例将找到标志设置为 true：
      <code language="X#">
        USE employee NEW
        DBSetFilter({|| Age &lt; 40}, "Age &lt; 40")
        DBSetFound(TRUE)
        DBGoTop()
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbLocate'>DBLocate</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealso cref='O:VO.DbServer.Locate'>DBServer:Locate</seealso>
    <seealso cref='O:VO.DbServer.Seek'>DBServer:Seek</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbSetFound'>VODBSetFound</seealso>
  </dbsetfound>

  <dbsetindex>
    <summary>
      在工作区中打开一个索引文件并将其所有排序添加到排序列表中。
    </summary>
    <param name="cIndexFile">
      要打开的索引文件的名称，包括可选的驱动器、目录和每个文件的扩展名。参见 SetDefault() 和 SetPath() 了解文件搜索和创建规则。<br/>
      默认扩展名由 RDD 决定，可以使用 DBOrderInfo(DBOI_INDEXEXT) 获取。<br/>
      如果 <paramref name="cIndexFile" /> 不存在，将引发运行时错误。<br/>
      如果存在，此函数将尝试以与相应数据库文件相同的模式打开文件。<br/>
      如果访问被拒绝（例如，因为另一个进程正在使用该文件而此进程请求独占使用），NetErr() 将被设置为 TRUE。<br/>
      否则，文件打开成功。<br/>
      <b>并发冲突</b>对于索引文件来说很少见，因为它们通常只与一个数据库文件一起使用。<br/>
      如果出现并发问题，通常会在尝试打开数据库文件时发生。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      如果在发出 DBSetIndex() 时工作区的排序列表为空，则索引文件中的第一个排序将成为控制排序。<br/>
      如果工作区已经关联了排序，它们不会受到影响 — 新排序只是简单地添加到当前排序列表中。<br/>
      在新索引文件打开后（使用与其关联的数据库文件相同的打开模式），工作区将定位到控制排序中的第一个逻辑记录。
      打开索引文件会对数据库文件中的记录施加逻辑顺序（由控制排序定义），并可能根据 for 条件或唯一标志过滤记录。<br/>
      这意味着当您处理数据库文件时，记录将按控制排序确定的顺序出现，而被过滤的记录虽然在数据库文件中仍然物理存在，但将无法访问。
      <note type="tip">
        除了某些 RDD 支持的生产索引文件外，索引文件在打开相应的数据库文件时不会自动打开。<br/>
        为确保索引文件得到准确维护，您应该在对相应数据库文件进行任何更新之前打开它们，或在稍后使用 DBReindex() 重建它们。
      </note>
    </remarks>
    <example>
      以下示例打开多个索引文件：
      <code language="X#">
        DBUseArea(TRUE, "DBFNTX", "sales", "Sales", TRUE)
        Sales-&gt;DBSetIndex("FirstName")
        Sales-&gt;DBSetIndex("LastName")
        IF Sales-&gt;DBSeek(cLast)
        &#0009;IF Sales-&gt;Deleted() .AND. Sales-&gt;RLock()
        &#0009;&#0009;Sales-&gt;DBRecall()
        &#0009;&#0009;QOut("已恢复已删除的记录。")
        &#0009;ENDIF
        ELSE
        &#0009;QOut("未找到")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearIndex'>DBClearIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbReindex'>DBReindex</seealso>
    <seealso cref='O:VO.DbServer.CreateIndex'>DBServer:CreateIndex</seealso>
    <seealso cref='O:VO.DbServer.CreateOrder'>DBServer:CreateOrder</seealso>
    <seealso cref='O:VO.DbServer.OrderInfo'>DBServer:OrderInfo</seealso>
    <seealso cref='O:VO.DbServer.Reindex'>DBServer:Reindex</seealso>
    <seealso cref='O:VO.DbServer.SetOrder'>DBServer:SetOrder</seealso>
    <seealso cref='O:VO.DbServer.SetIndex'>DBServer:SetIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrder'>DBSetOrder</seealso>
    <seealso cref='O:XSharp.Core.Functions.NetErr'>NetErr</seealso>
    <seealsocmd>SET INDEX</seealsocmd>
    <seealsocmd>USE</seealsocmd>
  </dbsetindex>

  <dbsetorder>
    <summary>
      为工作区设置控制排序。
    </summary>
    <param name="uOrder">
      新控制排序的名称或表示其在排序列表中位置的数字。<br/>
      使用排序名称是首选方法，因为在使用多排序索引文件时，确定位置可能比较困难。指定值 0 具有特殊效果，即将数据库文件返回到其自然顺序。指定无效值将引发运行时错误。
    </param>
    <param name="cIndexFile">
      索引文件的名称，包括可选的驱动器和目录（不应指定扩展名）。<br/>
      当不同索引文件中存在两个或多个同名排序时，请使用此参数与 <paramref name="cOrder" /> 一起消除歧义。<br/>
      如果当前进程未打开 <paramref name="cIndexFile" />，将引发运行时错误。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBSetOrder() 控制工作区排序列表中的哪个排序是控制排序。<br/>
      控制排序是决定工作区中记录逻辑顺序的排序。在使用此函数之前，请使用 DBSetIndex() 从索引文件添加排序到排序列表。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      此示例将第二个命名排序 AGE 设置为控制排序：
      <code language="X#">
        USE employee NEW
        Employee-&gt;DBSetIndex("name")
        Employee-&gt;DBSetIndex("age")
        DBSetOrder("age")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearIndex'>DBClearIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbReindex'>DBReindex</seealso>
    <seealso cref='O:VO.DbServer.CreateIndex'>DBServer:CreateIndex</seealso>
    <seealso cref='O:VO.DbServer.CreateOrder'>DBServer:CreateOrder</seealso>
    <seealso cref='O:VO.DbServer.Reindex'>DBServer:Reindex</seealso>
    <seealso cref='O:VO.DbServer.SetIndex'>DBServer:SetIndex</seealso>
    <seealso cref='O:VO.DbServer.SetOrder'>DBServer:SetOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
    <seealsocmd>SET ORDER</seealsocmd>
  </dbsetorder>

  <dbsetordercondition>
    <summary>
      设置创建下一个排序时使用的条件和范围。
    </summary>
    <param name="cForCondition">
      指定排序的for条件的字符串。<br/>
      此字符串由DBOrderInfo(DBOI_CONDITION, [<paramref name="cIndexFile" />], <paramref name="cOrder" />)返回。<br/>
      如果不需要此信息，可以指定NULL_STRING。
    </param>
    <param name="cbForCondition">
      定义条件（称为for条件）的代码块，范围内的每条记录必须满足该条件才能被处理。<br/>
      如果记录不满足指定条件，则会被忽略并处理下一条记录。使用for条件时，重复的键值不会添加到索引文件中。<br/>
      默认值为NIL。<br/>
      &#0009;此条件（而非<paramref name="cForCondition" />）是实际用于创建排序的条件。<br/>
      与while条件和其他范围信息不同，for条件作为索引文件的一部分存储，并在使用DBReindex()更新或重建排序时使用。<br/>
      for条件的任何限制由RDD决定。
    </param>
    <param name="lAll">
      值为TRUE时指定范围为所有记录。<br/>
      如果要指定其他记录范围条件（即<paramref name="nNext" />、<paramref name="nRecord" />或<paramref name="lRest" />），请使用FALSE。<br/>
      默认值为FALSE。
    </param>
    <param name="cbWhileCondition">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/cbwhile/*" /><br/>
      while条件仅用于创建排序。<br/>
      它不存储在索引文件中，也不用于更新或重新索引。<br/>
      默认值为NIL。
    </param>
    <param name="cbEval">
      在由<paramref name="nInterval" />指定的间隔评估的代码块。<br/>
      这对于生成状态栏或里程表以监视排序进度很有用。<br/>
      <paramref name="cbEval" />的返回值必须是逻辑值。<br/>
      如果<paramref name="cbEval" />返回FALSE，索引过程将停止。<br/>
      默认值为NIL。
    </param>
    <param name="nInterval">
      确定评估<paramref name="cbEval" />次数的数值表达式。<br/>
      此参数通过以间隔而不是对每个处理的记录进行评估来提高性能。<br/>
      要逐一处理每条记录，可以指定值为0。<br/>
      默认值为0。
    </param>
    <param name="nStart">
      起始记录号。<br/>
      要从文件开头开始，请指定值为0。<br/>
      默认值为0。<br/>
      &#0009;您可以使用这三个互斥参数之一定义范围（对其他参数使用0或FALSE）。<br/>
      默认为所有记录。记录范围信息仅用于创建排序。<br/>
      它不存储在索引文件中，也不用于索引更新和重新索引。
    </param>
    <param name="nNext">
      从<paramref name="nStart" />开始要处理的记录数。指定0以忽略此参数。
    </param>
    <param name="nRecord">要处理的单个记录号。指定0以忽略此参数。</param>
    <param name="lRest">
      TRUE仅处理从<paramref name="nStart" />到文件末尾的记录。FALSE处理所有记录。
    </param>
    <param name="lDescend">
      指定键值对是按值的递减还是递增顺序排序。TRUE表示降序。FALSE表示升序。<br/>
      默认值为FALSE。
    </param>
    <param name="lAdditive">
      指定在创建新排序时是否保持打开的排序继续打开。TRUE表示应保持打开。FALSE表示应关闭所有打开的排序。<br/>
      默认值为FALSE。
    </param>
    <param name="lCurrent">
      指定是否仅包括控制排序中的记录（以及由OrdSetScope()指定的当前范围内的记录）。TRUE表示应使用控制排序和范围来限制新创建排序的范围。FALSE表示数据库文件中的所有记录都包括在排序中。<br/>
      默认值为FALSE。
    </param>
    <param name="lCustom">
      指定新排序是否为自定义构建的排序（适用于支持此功能的RDD）。TRUE表示将创建自定义构建的排序。<br/>
      自定义构建的排序最初为空，使您可以完全控制排序维护。<br/>
      系统不会自动从自定义构建的排序中添加和删除键。相反，您需要使用OrdKeyAdd()和OrdKeyDel()显式添加和删除键。FALSE表示标准的系统维护排序。<br/>
      默认值为FALSE。
    </param>
    <param name="lNoOptimize">
      指定是否优化FOR条件（适用于支持此功能的RDD）。TRUE优化FOR条件，FALSE不优化。<br/>
      默认值为FALSE。
    </param>
    <returns>
      如果成功则为TRUE；否则为FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      除非您使用DBSetOrderCondition()另行指定，否则您创建的新排序将使用默认范围规则，处理工作区中的所有记录。
      DBSetOrderCondition()允许您指定记录必须满足的条件和范围规则，以便包含在下一个创建的排序中。
      因此，创建新排序会自动将工作区重置为使用默认范围规则。
      因此，如果需要范围设置，您必须在每次创建新排序时重新设置DBSetOrderCondition()。
      如果您想使用DBCreateOrder()和DBCreateIndex()创建条件排序，此函数至关重要，因为这些函数不支持执行此操作的参数。
    </remarks>
    <example>
      以下示例设置创建排序的条件：
      <code language="X#">
        LOCAL cFor AS STRING
        LOCAL lAll, lRest, lDescend AS LOGIC
        LOCAL cbForCondition, cbWhileCondition, cbEval AS USUAL
        LOCAL nStep, nStart, nNext, nRecord AS SHORTINT
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// For条件字符串格式
        cFor := 'Upper(Name) = "MELISSA"'
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 实际For条件
        cbForCondition := {|| Upper(Name) = "MELISSA"}
        lAll := TRUE
        cbWhileCondition := {|| TRUE}&#0009;&#0009;// While全部
        cbEval := {|| Name + City}&#0009;&#0009;// 索引代码
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 块
        nStep := 0&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 逐一处理
        nStart := 0&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 从顶部
        nNext := 0&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 全部
        nRecord := 0&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 所有记录
        lRest := FALSE&#0009;&#0009;&#0009;&#0009;&#0009;// 全部
        lDescend :=  FALSE&#0009;&#0009;
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
    <seealso cref='O:VO.DbServer.CreateIndex'>DBServer:CreateIndex</seealso>
    <seealso cref='O:VO.DbServer.CreateOrder'>DBServer:CreateOrder</seealso>
    <seealso cref='O:VO.DbServer.OrderInfo'>DBServer:OrderInfo</seealso>
    <seealso cref='O:VO.DbServer.OrderScope'>DBServer:OrderScope</seealso>
    <seealso cref='O:VO.DbServer.OrderKeyAdd'>DBServer:OrderKeyAdd</seealso>
    <seealso cref='O:VO.DbServer.OrderKeyDel'>DBServer:OrderKeyDel</seealso>
    <seealso cref='O:VO.DbServer.SetOrderCondition'>DBServer:SetOrderCondition</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealsocmd>INDEX</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyAdd'>OrdKeyAdd</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyDel'>OrdKeyDel</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdScope'>OrdScope</seealso>
  </dbsetordercondition>

  <dbsetrelation>
    <summary>
      将指定的工作区关联到当前工作区。
    </summary>
    <param name="xAlias">子工作区的编号，或子工作区的别名。</param>
    <param name="cbKey">以可执行形式表达关系表达式的代码块。</param>
    <param name="cKey">
      可选的字符值，以文本形式表达关系表达式。<br/>
      如果提供了<paramref name="cKey" />，它必须等同于<paramref name="cbKey" />。<br/>
      如果省略<paramref name="cKey" />，DBRelation()将为关系返回NULL_STRING。
    </param>
    <returns>
      如果成功则为TRUE；否则为FALSE。
    </returns>
    <remarks>
      DBSetRelation()将由<paramref name="nArea" />或<paramref name="cAlias" />指定的工作区（子工作区）关联到当前工作区（父工作区）。<br/>
      任何现有的关系仍然保持活动状态。
      关联工作区会使子工作区与父工作区同步。<br/>
      这是通过在父工作区移动到新记录时自动重新定位子工作区来实现的。<br/>
      如果子工作区中有控制顺序，移动父工作区会导致子工作区中自动进行查找操作；查找键基于由<paramref name="cbKey" />和/或<paramref name="cKey" />指定的表达式。<br/>
      如果子工作区没有控制顺序，移动父工作区会导致子工作区中自动进行"转到"操作；"转到"的记录号基于由<paramref name="cbKey" />和/或<paramref name="cKey" />指定的表达式。
      DBSetRelation()执行与带有ADDITIVE子句的SET RELATION命令相同的功能。<br/>
      有关更多信息，请参阅SET RELATION命令。
      <note type="tip">
        副作用：&#0009;DBSetRelation()只保证按上述方式同步工作区。<br/>
        关系表达式不一定在任何特定时间、以任何特定方式或在任何特定记录或一系列记录上进行评估。<br/>
        如果关系表达式依赖于父工作区或其关联数据库文件之外的信息，效果是不可预测的。<br/>
        如果表达式改变了任一工作区的状态（例如，移动到不同的记录或更改记录的内容），效果是不可预测的。
        评估上下文：&#0009;当评估关系表达式时，父工作区会在评估之前自动被选为当前工作区；之后会自动恢复先前选择的工作区。
        软查找：&#0009;作为关系定位一部分的查找操作绝不是软查找。<br/>
        如果关系移动不成功，子工作区将定位到LastRec() + 1，其Found()状态返回FALSE，其EOF()状态返回TRUE。
      </note>
    </remarks>
    <example>
      这个例子演示了DBSetRelation()函数的典型用法：
      <code language="X#">
        USE employee NEW
        USE department NEW INDEX dept
        SELECT employee
        DBSetRelation("Department", {|| Employee-&gt;Dept}, "Employee-&gt;Dept")
        LIST Employee-&gt;Name, Department-&gt;Name
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearRelation'>DBClearRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRelation'>DBRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRSelect'>DBRSelect</seealso>
    <seealso cref='O:VO.DbServer.ClearRelation'>DBServer:ClearRelation</seealso>
    <seealso cref='O:VO.DbServer.Relation'>DBServer:Relation</seealso>
    <seealso cref='O:VO.DbServer.SetRelation'>DBServer:SetRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.Found'>Found</seealso>
    <seealsocmd>SET RELATION</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbSetRelation'>VODBSetRelation</seealso>
  </dbsetrelation>

  <dbsetrestoreworkarea>
    <summary>
      控制RDD类关于恢复旧工作区的行为。
    </summary>
    <param name="lNewSetting">工作区恢复的新设置</param>
    <returns>
      工作区恢复的旧设置
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='T:VO.DbServer'>DbServer 类</seealso>
  </dbsetrestoreworkarea>

  <dbsetselect>
    <summary>
      选择一个新的工作区。
    </summary>
    <param name="nNewArea">新工作区的编号。</param>
    <returns>
      新选择的工作区。
    </returns>
    <remarks>
    </remarks>
    <example>
      以下示例设置一个新的工作区：
      <code language="X#">
        LOCAL nNewArea
        nNewArea := DBSetSelect(9)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbSetSelect'>VODBSetSelect</seealso>
  </dbsetselect>

  <dbskip>
    <summary>
      移动记录指针到相对于当前记录的位置。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <param name="nRecords">
      相对于当前记录要移动的逻辑记录数。<br/>
      正值表示向前跳过，负值表示向后跳过。<br/>
      如果省略 <paramref name="nRecords" />，则假定值为 1。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      尝试跳过最后一条记录会将工作区定位到 LastRec() + 1，并且 EOF() 返回 TRUE。<br/>
      尝试向后跳过第一条记录会将工作区定位到第一条记录，并且 BOF() 返回 TRUE。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      DBSkip() 是 SKIP 命令的功能等效项。<br/>
      更多信息请参阅 SKIP 命令。
      <note type="tip">
        逻辑记录：&#0009;DBSkip() 操作逻辑记录。<br/>
        如果工作区有活动的排序列表，则按控制顺序考虑记录。<br/>
        如果设置了过滤器，则只考虑满足过滤条件的记录。
        共享模式：&#0009;对于共享文件，移动到不同的记录可能会导致当前记录的更新对其他进程可见。
      </note>
    </remarks>
    <example>
      此示例演示了 DBSkip() 函数的典型用法：
      <code language="X#">
        DBGoTop()
        DO WHILE (!EOF())
        &#0009;QOut(_FIELD-&gt;Name)
        &#0009;DBSkip()
        ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bof'>BOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoBottom'>DBGoBottom</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoTop'>DBGoTop</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealso cref='O:VO.DbServer.GoBottom'>DBServer:GoBottom</seealso>
    <seealso cref='O:VO.DbServer.GoTop'>DBServer:GoTop</seealso>
    <seealso cref='O:VO.DbServer.Seek'>DBServer:Seek</seealso>
    <seealso cref='O:VO.DbServer.Skip'>DBServer:Skip</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealsocmd>SKIP</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbSkip'>VODBSkip</seealso>
  </dbskip>

  <dbsort>
    <summary>
      将记录按排序顺序复制到数据库文件中。
    </summary>
    <param name="cTargetFile">
      要写入排序记录的目标数据库文件名，包括可选的驱动器、目录和扩展名。有关文件搜索和创建规则，请参见 SetDefault() 和 SetPath()。<br/>
      数据库文件的默认扩展名由 RDD 确定。<br/>

      如果 <paramref name="cTargetFile" /> 不存在，将创建它。<br/>
      如果它存在，此函数将尝试以独占模式打开文件，如果成功，文件将被覆盖，不会发出警告或错误。<br/>
      如果由于另一个进程正在使用该文件等原因而被拒绝访问，NetErr() 将被设置为 TRUE。
    </param>
    <param name="acFields">排序键，指定为字段名称数组。您可以在字段名称后面选择性地添加 /A（按字典顺序排序），/C（忽略大小写）或 /D（按降序排序）。默认设置为 /A。</param>
    <param name="acOutPutFields">
      要复制到 <paramref name="cTargetFile" /> 的字段列表。<br/>
      默认为所有字段
    </param>
    <param name="lNoOpt">禁用（Rushmore）优化（尚不支持）。</param>
    <param name="lDesc">默认排序顺序是否为降序</param>

    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      DBSort() 将当前工作区的记录按排序顺序复制到另一个数据库文件中。
      X# 根据字符串中每个字符的 ASCII 值对字符字段进行排序。
      数字字段按数字顺序排序，日期字段按时间顺序排序，
      逻辑字段排序时 TRUE 为高值。
      备注字段不能排序。
      DBSort() 尽可能多地在内存中执行操作，然后将结果溢出
      到一个唯一命名的临时磁盘文件中。<br/>
      这个临时文件可能与源数据库文件一样大。
      还要注意，DBSort() 会使用三个文件句柄：源数据库文件、
      目标数据库文件和临时文件。
      如果数据库以共享模式打开，您必须使用 FLock() 锁定要排序的文件。
      DBSort() 在功能上等同于 SORT 命令。
      <note type="tip">
        已删除的源记录：<br/>
        如果 SetDeleted() 为 TRUE，VODBSort() 会将已删除的记录复制到目标数据库文件中；
        但是，这些已删除的记录不会保留其删除状态。
        无论源文件中的状态如何，目标文件中的记录都不会被标记为删除。<br/>
        如果 SetDeleted() 为 FALSE，已删除的记录不会被复制到目标数据库文件中。
        同样，在排序过程中会忽略经过过滤的记录，它们不会包含在目标
        文件中。<br/>
      </note>
    </remarks>
    <example>
      以下示例按两个字段（忽略大小写）对数据库进行排序，并将其用作
      当前文件：
      <code language="X#">
        IF DBSort("sortdb.dbf", {"Last/C", "First/C"})
        &#0009;DBCloseArea()
        &#0009;USE sortdb NEW
        ENDIF
      </code>
    </example>
    <seealso cref='O:VO.DbServer.Sort'>DBServer:Sort</seealso>
    <seealsocmd>SORT</seealsocmd>
  </dbsort>

  <dbstruct>
    <summary>
      创建包含数据库文件结构的数组。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      数据库文件的结构以数组形式返回，数组长度等于数据库文件中的字段数。<br/>
      数组的每个元素是一个子数组，包含一个字段的信息。<br/>
      子数组的格式如下：
      <include file="RTComments.xml" path="Comments/DbStruct_Constants/*"  />
      如果工作区中没有使用中的数据库文件，DBStruct() 将产生运行时错误。
    </returns>
    <remarks>
      DBStruct() 的功能类似于 COPY STRUCTURE EXTENDED，但创建的是结构信息数组而不是结构信息数据库文件。<br/>
      另有一个函数 DBCreate()，可以从结构数组创建数据库文件。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      此示例打开两个数据库文件，然后使用别名表达式中的 DBStruct() 创建包含数据库结构的数组。<br/>
      然后使用 AEval() 列出字段属性：
      <code language="X#">
        LOCAL aStruct
        USE customer NEW
        USE invoices NEW
        aStruct := Customer-&gt;DBStruct()
        AEval(aStruct, {|aField|QOut(aField[DBS_NAME]),;
        QOut(aField[DBS_TYPE]), QOut(aField[DBS_LEN]),;
        QOut(aField[DBS_DEC]), QOut(aField[DBS_ALIAS])})
      </code>
    </example>
    <seealsocmd>COPY STRUCTURE EXTENDED</seealsocmd>
    <seealso cref='O:VO.DbServer.CopyStructure'>DBServer:CopyStructure</seealso>
  </dbstruct>

  <dbsymselect>
    <summary>
      通过指定别名作为符号来选择新的工作区。
    </summary>
    <param name="symAlias">您想要选择的工作区的别名。</param>
    <returns>
      新选择的工作区的编号。
    </returns>
    <remarks>
    </remarks>
    <example>
      以下示例选择一个新的工作区：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL symAlias AS SYMBOL
        &#0009;USE test NEW
        &#0009;USE demo NEW
        &#0009;symAlias := SysFindAtom("test")
        &#0009;wSelect := DBSymSelect(symAlias)
        &#0009;? "选择的工作区：", wSelect
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.VoDbSymSelect'>VODBSymSelect</seealso>
  </dbsymselect>

  <dbtosb>
    <summary>
      将字符串中的双字节假名字符转换为其单字节等效字符。
    </summary>
    <param name="cMBTarget">要转换的字符串。</param>
    <returns>
      转换后的 <paramref name="cMBTarget" />，其中指定的字符已更改。
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.SBTODB'>SBToDB</seealso>
  </dbtosb>

  <dbtotal>
    <summary>
      根据键值将记录汇总到数据库文件中。
    </summary>
    <param name="cTargetFile">
      用于写入汇总记录的目标数据库文件名，包括可选的驱动器、目录和扩展名。有关文件搜索和创建规则，请参见 SetDefault() 和 SetPath()。<br/>
      数据库文件的默认扩展名由 RDD 确定。<br/>
      &#0009;如果 <paramref name="cTargetFile" /> 不存在，则创建它。<br/>
      如果存在，此函数会尝试以独占模式打开文件，如果成功，则会覆盖文件，不会发出警告或错误。<br/>
      如果由于另一个进程正在使用该文件等原因而被拒绝访问，NetErr() 将被设置为 TRUE。
    </param>
    <param name="cbKey">以代码块形式指定的键表达式。</param>
    <param name="acFields">要汇总的字段，以字符串数组形式指定。</param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      DBTotal() 在功能上等同于 TOTAL 命令。
    </remarks>
    <example>
      以下示例生成 Salary 和 Age 字段的汇总：
      <code language="X#">
        DBTotal("totals", {||Last}, {"salary", ;
        &#0009;&#0009;&#0009;&#0009;"age"})
      </code>
    </example>
    <seealso cref='O:VO.DbServer.Total'>DBServer:Total</seealso>
    <seealsocmd>TOTAL</seealsocmd>
  </dbtotal>

  <dbtrans>
    <summary>
      将记录传输到打开的数据库文件。
    </summary>
    <param name="wTarget">目标文件的工作区编号。</param>
    <param name="aStruct">
      包含字段描述的数组，格式与 DBStruct() 返回的格式相同。<br/>
      该数组包含源文件的结构。
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      DBTrans() 将记录从一个工作区复制到另一个打开的数据库文件。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      <note type="tip">
        已删除的源记录：
        &#0009;如果 SetDeleted() 为 FALSE，记录会被复制；但是，已删除的记录不会保留其已删除状态。无论源文件中的状态如何，目标文件中的记录都不会被标记为删除。
        &#0009;如果 SetDeleted() 为 TRUE，已删除的记录不会被复制到目标数据库文件。同样，在复制过程中会忽略经过过滤的记录，它们不会包含在目标文件中。
      </note>
    </remarks>
    <example>
      以下示例将 TESTFROM.DBF 文件的内容追加到 TESTTO.DBF：
      <code language="X#">
        USE testto
        IF !Used()
        &#0009;? "打开 TESTTO.DBF 时出错"
        ELSE
        &#0009;siTo := VODBGetSelect()
        &#0009;USE testfrom NEW
        &#0009;IF !Used()
        &#0009;&#0009;? "打开 TESTFROM.DBF 时出错"
        &#0009;ELSE
        &#0009;&#0009;siFrom := VODBGetSelect()
        &#0009;&#0009;aStruct := DBStruct()
        &#0009;&#0009;DBTrans(siTo, aStruct)
        &#0009;&#0009;CLOSE
        &#0009;&#0009;DBSetSelect(siTo)
        &#0009;ENDIF
        &#0009;CLOSE
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCopy'>DBCopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbStruct'>DBStructFunction</seealso>
    <seealsocmd>SORT</seealsocmd>
  </dbtrans>

  <dbunlock>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <param name="nRecord">
      要解锁的记录编号。<br/>
    </param>
    <summary>
      释放工作区的所有锁定或指定锁定。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBUnLock() 释放当前进程为工作区获得的任何记录或文件锁定。DBUnLock() 仅在共享数据库上有意义。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      <note type="tip">
        共享模式：&#0009;释放锁定可能导致数据库更新对其他进程可见。
      </note>
    </remarks>
    <example>
      以下示例说明了 DBUnLock() 函数的基本用法：
      <code language="X#">
        cLast := "Winston"
        USE sales SHARED NEW VIA "DBFNTX"
        Sales-&gt;DBSetIndex("lastname")
        IF Sales-&gt;DBSeek(cLast)
        &#0009;IF Sales-&gt;RLock()
        &#0009;&#0009;Sales-&gt;DBDelete()
        &#0009;&#0009;QOut("记录已删除: ", Sales-&gt;Deleted())
        &#0009;&#0009;Sales-&gt;DBUnLock()
        &#0009;ELSE
        &#0009;&#0009;QOut("无法锁定记录...")
        &#0009;ENDIF
        ELSE
        &#0009;QOut("未找到")
        ENDIF
      </code>
    </example>
    <seealso cref='O:VO.DbServer.UnLock'>DBServer:UnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLockAll'>DbUnLockAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.Flock'>FLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.RLock'>RLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbUnLock'>VODBUnLock</seealso>
  </dbunlock>

  <dbunlockall>
    <summary>
      释放所有工作区的所有锁定。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DbUnLockAll() 释放当前进程为任何工作区获得的任何记录或文件锁定。
      DbUnLockAll() 仅在共享数据库上有意义。<br/>
      它等同于对每个占用的工作区调用 DBUnLock()。
    </remarks>
    <example>
      以下示例如果 RLock() 尝试成功，则标记一条记录为删除，然后清除所有工作区中的所有锁定：
      <code language="X#">
        cLast := "Winston"
        USE sales SHARED NEW VIA "DBFNTX"
        Sales-&gt;DBSetIndex("salefnam")
        Sales-&gt;DBSetIndex("salelnam")
        USE colls SHARED NEW VIA "DBFNTX"
        Colls-&gt;DBSetIndex("collfnam")
        Colls-&gt;DBSetIndex("colllnam")
        IF Colls-&gt;DBSeek(cLast)
        &#0009;IF Colls-&gt;Deleted()
        &#0009;&#0009;QOut("记录已删除: ", Colls-&gt;Deleted())
        &#0009;&#0009;IF Colls-&gt;RLock()
        &#0009;&#0009;&#0009;Colls-&gt;DBRecall()
        &#0009;&#0009;&#0009;QOut("记录已恢复...")
        &#0009;&#0009;ENDIF
        &#0009;ENDIF
        ELSE
        &#0009;QOut("未找到")
        &#0009;DbUnLockAll()&#0009;&#0009;&#0009;// 移除所有工作区中
        ENDIF&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 的所有锁定
      </code>
    </example>
    <seealso cref='O:VO.DbServer.UnLock'>DBServer:UnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLock'>DBUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.Flock'>FLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.RLock'>RLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbUnLockAll'>VODbUnLockAll</seealso>
  </dbunlockall>

  <dbupdate>
    <summary>
      根据指定的键表达式，用另一个工作区的值替换当前工作区的字段。
    </summary>
    <param name="cAlias">
      用于更新当前工作区记录的源工作区的别名标识符。<br/>
      如果指定的别名没有关联的打开数据库文件，将引发运行时错误。
    </param>
    <param name="cbKey">定义源工作区中匹配记录的代码块表达式。</param>
    <param name="lRand">
      随机访问标志。<br/>
      如果为 TRUE，当前工作区必须按 <paramref name="cbKey" /> 排序（使用索引顺序），但源工作区的记录可以是任意顺序。<br/>
      如果为 FALSE，当前工作区和源工作区都必须按 Eval(<paramref name="cbKey" />) 排序（逻辑上或物理上）。
    </param>
    <param name="cbReplace">定义如何替换当前工作区中字段的代码块。</param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      对于共享数据库，DBUpdate() 需要对当前数据库文件进行文件锁定。<br/>
      源数据库文件可以以任何模式打开。
      DBUpdate() 在功能上等同于 UPDATE 命令。
      <note type="tip">
        已删除的记录：&#0009;如果 SetDeleted() 为 FALSE，两个源文件中的已删除记录都会被处理。被更新文件中的记录保留其删除状态，不受源文件中记录删除状态的影响。<br/>
        然而，如果 SetDeleted() 为 TRUE，则不会处理任何一个源文件中的已删除记录。
      </note>
    </remarks>
    <example>
      以下示例从 TEST2 数据库更新当前工作区（注意 <paramref name="bReplace" /> 评估所施加的条件）：
      <code language="X#">
        DBUpdate("test2", {||Last},, ;
        &#0009;&#0009;&#0009;&#0009;{||_FIELD-&gt;Salary := 0.00})
      </code>
    </example>
    <seealso cref='O:VO.DbServer.Update'>DBServer:Update</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUpdate'>DBUpdate</seealso>
    <seealso cref='O:XSharp.RT.Functions.Flock'>FLock</seealso>
    <seealsocmd>UPDATE</seealsocmd>
  </dbupdate>

  <dbusearea>
    <summary>
      打开一个数据库文件。
    </summary>
    <param name="lNewArea">
      指定是否在新的工作区中打开文件。TRUE 选择最低编号的未占用工作区作为使用操作前的当前工作区。<br/>
      如果 <paramref name="lNewArea" /> 为 FALSE 或省略，则使用当前工作区（如果工作区已被占用，则先关闭）。
    </param>
    <param name="cDriver">
      将为工作区提供服务的 RDD 的名称。<br/>
      如果未指定，则使用由 RDDSetDefault() 确定的默认 RDD。
    </param>
    <param name="cDataFile">
      要打开的数据库文件的名称，包括可选的驱动器、目录和扩展名。<br/>
      如果数据库文件有对应的备注文件，也会被打开。<br/>
      数据库和备注文件的默认扩展名由 RDD 确定。<br/>
      &#0009;如果数据库文件或其对应的备注文件不存在，将引发运行时错误。有关文件搜索和创建规则，请参阅 SetDefault() 和 SetPath()。
    </param>
    <param name="cAlias">
      当打开 <paramref name="cDataFile" /> 时与工作区关联的标识符名称。<br/>
      如果未指定，别名默认为数据库文件名。在单个应用程序中不允许重复的别名名称。
    </param>
    <param name="lShared">
      TRUE 尝试以共享模式打开 <paramref name="cDataFile" />。FALSE 尝试以独占（非共享）模式打开 <paramref name="xcDataFile" />，拒绝所有其他进程访问，直到数据库文件关闭。如果省略 <paramref name="lShared" />，当前的 SetExclusive() 设置决定是否允许共享访问。然而，强烈建议您在 USE 命令中指定打开模式，而不是依赖 SetExclusive() 来确定。
    </param>
    <param name="lReadOnly">
      TRUE 尝试以只读属性打开 <paramref name="cDataFile" />，禁止对工作区进行更新。FALSE 尝试以读写属性打开 <paramref name="cDataFile" />，允许更新。<br/>
      如果省略 <paramref name="lReadOnly" />，默认值为 FALSE。<br/>
      如果无法使用指定的属性访问 <paramref name="cDataFile" />，将引发运行时错误。
    </param>
    <param name="aStruct">
      包含字段描述的数组，格式与 DBStruct() 返回的格式相同。<br/>
      &#0009;此参数不适用于 DBF 文件。<br/>
      它旨在用于不存储字段描述的文件格式。<br/>
      例如，如果您使用支持 SDF 或分隔文件的 RDD，可以使用此参数定义文件结构，然后可以与其他命令或函数一起使用来访问字段描述。以下是此参数的示例：<br/>
      <code language="X#">
        &#0009;{"First", "C", 35, 0};<br/>

        &#0009;{"Last", "C", 35, 0};<br/>

        &#0009;{"Birthday", "D", 8, 0}}<br/>

        &#0009;? First&#0009;&#0009;&#0009;&#0009;&#0009;// 返回: Josie
      </code>
    </param>
    <param name="cDelim">
      分隔数据库文件中字段的分隔符。<br/>
      如果您使用提供的 RDD 之一来处理 .DBF 文件，分隔符应为 NULL_STRING，这是省略参数时的默认值。
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/acrdds/*"/>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBUseArea() 是 USE 命令的功能等效项。<br/>
      有关更多信息，请参阅 USE 命令。
    </remarks>
    <example>
      这个例子是 DBUseArea() 函数的典型用法：
      <code language="X#">DBUseArea(TRUE, "DBFMDX", "employees")</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCloseArea'>DBCloseArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbStruct'>DBStruct</seealso>
    <seealso cref='O:XSharp.Core.Functions.NetErr'>NetErr</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
    <seealsocmd>USE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbUseArea'>VODBUseArea</seealso>
  </dbusearea>

  <dbzap>
    <summary>
      从打开的文件中删除所有记录。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      DBZap() 永久删除工作区中打开文件的所有记录。<br/>
      这包括数据库文件、索引文件和相关的备注文件。被清除文件之前占用的磁盘空间将释放给操作系统。<br/>
      如果数据库文件中的所有记录都被标记为删除，DBZap() 执行与 DBPack() 相同的操作，但几乎是瞬时完成的。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      此操作要求当前数据库以独占模式打开（参见 SetExclusive()）。<br/>
      如果在调用函数时不满足这个条件，将引发运行时错误。<br/>
      否则，操作将继续进行，完成后将记录指针重置到当前工作区的第一个逻辑记录。
    </remarks>
    <example>
      以下示例演示了 DBZap() 的典型操作：
      <code language="X#">
        USE sales EXCLUSIVE NEW
        IF !NetErr()
        &#0009;SET INDEX TO sales, branch, salesman
        &#0009;IF DBZap()
        &#0009;&#0009;? "清除成功"
        &#0009;ELSE
        &#0009;&#0009;? "清除过程中检测到错误"
        &#0009;ENDIF
        &#0009;CLOSE sales
        ELSE
        &#0009;? "打开文件时检测到错误"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDelete'>DBDelete</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbPack'>DBPack</seealso>
    <seealso cref='O:VO.DbServer.Delete'>DBServer:Delete</seealso>
    <seealso cref='O:VO.DbServer.Zap'>DBServer:Zap</seealso>
    <seealsocmd>DELETE</seealsocmd>
    <seealsocmd>PACK</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetExclusive'>SetExclusive</seealso>
  </dbzap>

  <debout>
    <summary>
      向调试终端程序写入信息
    </summary>
    <param name="uValueList">
      要显示到调试窗口的任意数据类型表达式的逗号分隔列表。<br/>
      如果 DebOut() 没有指定参数，则显示一个回车/换行对。
    </param>
    <returns>
    </returns>
    <remarks>
      DebOut() 有助于调试 X# 应用程序。它使用与操作系统 OutPutDebugString() 函数相同的机制。
      要查看输出，您需要运行一个特殊程序来拦截此输出。您可以从以下网址下载这样的程序：
      http://www.sysinternals.com
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions._DebOut32'>_DebOut32</seealso>
    <seealso cref='O:XSharp.Core.Functions.DebOut32'>DebOut32</seealso>
  </debout>

  <debout32>
    <summary>
      向调试终端程序写入信息
    </summary>
    <param name="pszText">写入调试终端程序的字符串</param>
    <returns>
    </returns>
    <remarks>
      DebOut32() 有助于调试 X# 应用程序。它使用与操作系统 OutPutDebugString() 函数相同的机制。
      要查看输出，您需要运行一个特殊程序来拦截此输出。您可以从以下网址下载这样的程序：
      http://www.sysinternals.com
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions._DebOut32'>_DebOut32</seealso>
    <seealso cref='O:XSharp.RT.Functions.DebOut'>DebOut</seealso>
  </debout32>

  <decodebase64>
    <summary>
      从电子邮件传输中解码文件。
    </summary>
    <param name="cAttachment">要解码的附件文本。</param>
    <param name="hDestination">要将解码后的文本写入的文件句柄。</param>
    <returns>
      解码的字节数。
    </returns>
    <remarks>
      Base64解码用于读取通过互联网发送的邮件中的文件附件。
    </remarks>
    <example>
      假设收到的邮件消息已正确解析，并且附件部分已保存到 <paramref name="cFilePart" />，这是您可以如何解码附件：
      <code language="X#">
        hOut := FCreate("Attachment.txt")
        IF hfOut != F_ERROR
        &#0009;nTotalBytes := DecodeBase64(cFilePart, hOut)
        &#0009;TextBox{,"解码", "已解码字节数: " + ;
        &#0009;&#0009;&#0009;AsString(nTotalBytes)}:Show()
        ENDIF
        FClose(hfOut)
      </code>
      有关DecodeBase64()的更完整示例，包括如何解析电子邮件消息，请参见Mime解码示例应用程序（CAVOxx\SAMPLES\INTERNET\MIME\MDECODE.AEF）。
    </example>
    <seealso cref="T:VO.CEmail">CLASS CEmail</seealso>
    <seealso cref="T:VO.CMailAbstract">CLASS CMailAbstract</seealso>
    <seealso cref="T:VO.CSmtp">CLASS CSmtp</seealso>
    <seealso cref='O:XSharp.Core.Functions.EncodeBase64'>EncodeBase64</seealso>
  </decodebase64>

  <default>
    <summary>
      为 NIL 参数分配默认值。
    </summary>
    <param name="uVar">
      将被分配默认值的变量。<paramref name="uVar" /> 必须通过引用传递给 Default() 函数。
    </param>
    <param name="uDefault">要分配的默认值。</param>
    <returns>
    </returns>
    <remarks>
      如果 <paramref name="uVar" /> 等于 NIL，Default() 将 <paramref name="uDefault" /> 分配给 <paramref name="uVar" />。<br/>
        它在功能上等同于以下任一代码示例：
        与其使用 Default(@<paramref name="uVar" />, 0)，您可以使用 EnforceNumeric(@<paramref name="uVar" />)，它除了检查 <paramref name="uVar" /> 是否为 NIL 外，还会在 <paramref name="uVar" /> 既不是数字也不是 NIL 时调用错误系统。当 <paramref name="uDefault" /> 是其数据类型的空值（EmptyUsual()）时，您也可以使用 EnforceType()；如果 <paramref name="uVar" /> 不是特定数据类型，这会引发错误。<br/>
        因此，您可以调用 EnforceType(@<paramref name="uVar" />, STRING)，而不是调用 Default(@<paramref name="uVar" />, NULL_STRING)。
    </remarks>
    <code language="X#">
        IF uVar = NIL
        &#0009;uVar := uDefault
        ENDIF
        IF IsNil(uVar)
        &#0009;uVar := uDefault
        ENDIF
      </code>
    <example>
      此示例使用 Default() 检查函数中的所有参数：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL cCA1, cCA2
        &#0009;LOCAL nScore
        &#0009;LOCAL dDate
        &#0009;cCA1 := "CA"
        &#0009;cCA2 := "California"
        &#0009;// nScore 和 dDate 为 NIL
        &#0009;CheckArgs(cCA1, nScore, cCA2, dDate)
        &#0009;RETURN TRUE
        FUNCTION CheckArgs(uOne, uTwo, uThree, uFour)
        &#0009;Default(@uOne, "CA-VO")
        &#0009;// NIL 参数被分配一个值：
        &#0009;Default(@uTwo, 0)
        &#0009;Default(@uThree, NULL_STRING)
        &#0009;// NIL 参数被分配一个值：
        &#0009;Default(@uFour, 0.0.0)
        &#0009;RETURN TRUE
      </code>
      下面的示例不使用 CheckArgs()，除了检查 NIL 外，还检查正确的数据类型，如果传递了不正确的类型则会引发错误：
      <code language="X#">
        FUNCTION CheckArgs2(uOne, uTwo, uThree, uFour)
        &#0009;Default(@uOne, "CA-VO")
        &#0009;EnforceNumeric(@uTwo)
        &#0009;EnforceType(@uThree, STRING)
        &#0009;EnforceType(@uFour, DATE)
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EmptyUsual'>EmptyUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceNumeric'>EnforceNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
  </default>

  <deferrorgen>
    <summary>
      将ErrInfo结构转换为Error对象。
    </summary>
    <param name="strucErrorInfo">指向ErrInfo结构的指针。</param>
    <returns>
      一个Error对象，其属性与指定的ErrInfo结构中的信息匹配。
    </returns>
    <remarks>
      该函数在应用程序开始执行之前由ErrorGen()自动安装为默认错误函数。
      因此，除非使用ErrorFunc()安装了另一个错误函数，否则所有从ErrInfo结构创建Error对象的子系统都将使用DefErrorGen()。
    </remarks>
    <example>
    </example>
    <seealso cref='T:XSharp.Error'>Error类</seealso>
    <seealsocmd>ErrorGen</seealsocmd>
  </deferrorgen>

  <deleted>
    <summary>
      返回当前记录的删除状态。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      如果当前记录被标记为删除，则返回 TRUE；否则返回 FALSE。<br/>
      如果工作区中没有使用中的数据库文件，Deleted() 返回 FALSE。
    </returns>
    <remarks>
      Deleted() 确定活动工作区中的当前记录是否被标记为删除。由于每个具有打开数据库文件的工作区都可以有一个当前记录，因此每个工作区都有自己的 Deleted() 值。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      在应用程序中，Deleted() 通常用于查询删除状态作为记录处理条件的一部分，或在屏幕和报告中显示删除状态。
    </remarks>
    <example>
      此示例在当前工作区和未选择的工作区中使用 Deleted()：
      <code language="X#">
        USE customer NEW
        USE sales NEW
        QOut(Deleted())&#0009;&#0009;&#0009;// 结果: FALSE
        Delete
        QOut(Deleted())&#0009;&#0009;&#0009;// 结果: TRUE
        QOut(Customer-&gt;Deleted())&#0009;// 结果: FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDelete'>DBDelete</seealso>
    <conceptualLink target="cmd_Delete" />
    <seealso cref='O:XSharp.Core.Functions.SetDeleted'>SetDeleted</seealso>
  </deleted>

  <deletestorage>
    <summary>
      从包含 OLE 对象持久信息的存储文件中删除一个存储。
    </summary>
    <param name="cFileName">存储文件的名称。</param>
    <param name="cStorage">要从存储文件中删除的存储的名称。</param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealsocmd>GetStorageNames</seealsocmd>
  </deletestorage>

  <descend>
    <summary>
      创建降序键值。
    </summary>
    <param name="uValue">任何有效的字符串、日期、逻辑或数值类型表达式。备注类型的处理方式与字符串类型相同。</param>
    <returns>
      与 <paramref name="uValue" /> 相同数据类型的反转表达式，但日期类型除外，它返回数值。<br/>
      如果 <paramref name="uValue" /> 是 Chr(0)，Descend() 返回 Chr(0)。
    </returns>
    <remarks>
      Descend() 是一个转换函数，返回指定表达式的反转形式。您可以在使用 INDEX 命令或 DBCreateIndex() 或 DBCreateOrder() 函数创建顺序时，将其作为键表达式的一部分。<br/>
      要随后使用 SEEK 命令或 DBSeek() 函数执行查找，请在搜索表达式中指定 Descend()。
      创建降序的首选方法是使用 INDEX 命令的 DESCEND 子句，或在创建顺序之前使用 DBSetOrderCondition() 将 <paramref name="lDescend" /> 标志设置为 TRUE。<br/>
      这与在顺序键表达式中使用 Descend() 函数具有相同的效果，但在更新期间没有性能损失。<br/>
      如果您以这种方式创建降序，则在搜索操作期间不需要使用 Descend() 函数。
    </remarks>
    <example>
      此示例在顺序键表达式中使用 Descend() 对数据库文件强制执行降序日期排序：
      <code language="X#">
        USE sales NEW
        INDEX ON Descend(SaleDate) TO salesdate
      </code>
      之后，使用 Descend() 来 SEEK 键值：
      <code language="X#">SEEK Descend(dFindDate)</code>
      您可以使用 DESCEND 关键字代替 Descend()，这是推荐的做法：
      <code language="X#">
        USE sales NEW
        INDEX ON SaleDate TO salesdate DESCEND
      </code>
      然后，您可以以正常方式搜索键值：
      <code language="X#">Sales-&gt;DBSeek(dFindDate)</code>
      此示例演示如何使用多个数据类型创建降序。这里，键是在适当的类型转换发生后使用日期和字符字段的连接创建的。<br/>
      此示例使用 Str() 而不是 DToS()，因为日期的 Descend() 返回数值：
      <code language="X#">
        USE sales NEW
        INDEX ON Str(Descend(SaleDate)) + salesman TO;
        &#0009;lastsale
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrderCondition'>DBSetOrderCondition</seealso>
    <seealsocmd>INDEX</seealsocmd>
    <seealsocmd>SEEK</seealsocmd>
  </descend>

  <dirchange>
    <summary>
      更改当前 Windows 目录。
    </summary>
    <param name="pszDir">要更改到的目录名称，包括驱动器。</param>
    <returns>
      如果成功则返回 0；如果参数错误则返回 -1；否则返回 DOS 错误代码。
    </returns>
    <remarks>
      DirChange() 更改当前子目录或确定目录是否存在。请注意，如果在执行 DirChange() 后，您切换到另一个驱动器（例如通过 DiskChange()），另一个 Windows 任务可能会更改您最初执行 DirChange() 的磁盘目录。
    </remarks>
    <example>
      这个例子展示了 DirChange() 的使用：
      <code language="X#">
        siError :=  DirChange("c:\dos")
        IF siError != 0
        &#0009;? DOSErrString(siError)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.CurDir'>CurDir</seealso>
    <seealso cref='O:XSharp.RT.Functions.DirMake'>DirMake</seealso>
    <seealso cref='O:XSharp.RT.Functions.DirRemove'>DirRemove</seealso>
    <seealso cref='O:XSharp.RT.Functions.DiskChange'>DiskChange</seealso>
    <seealso cref='O:XSharp.Core.Functions.WorkDir'>WorkDir</seealso>
  </dirchange>

  <directory>
    <summary>
      创建一个包含目录和文件信息的数组。
    </summary>
    <param name="cFileSpec">
      用于搜索的文件规范。除文件名外，此规范还可以包括可选的驱动器、目录和扩展名。<br/>
      文件名和扩展名可以包含标准通配符（* 和 ?）。<br/>
      如果未指定驱动器和目录，将使用 Windows 默认值。
    </param>
    <param name="uAttributes">
      指定在返回的信息中包含具有特殊属性的文件。
      <paramref name="uAttributes" /> 可以是字符串或数字。当指定为字符串时，
      可以包含下表中列出的一个或多个字符。当指定为数字时，可以包含下表中
      列出的一个或多个常量：<br/>
      <list type="table">
        <listheader>
          <term>字符</term>
          <description>常量&#0009;描述</description>
        </listheader>
        <item>
          <term>D</term>
          <description>FA_DIRECTORY&#0009;目录</description>
        </item>
        <item>
          <term>H</term>
          <description>FC_HIDDEN&#0009;隐藏</description>
        </item>
        <item>
          <term>S</term>
          <description>FC_SYSTEM&#0009;系统</description>
        </item>
        <item>
          <term>V</term>
          <description>FA_VOLUME&#0009;卷标</description>
        </item>
      </list>
      要指定多个常量，可以使用 + 运算符将属性相加，或使用 _Or() 运算符，例如：_Or(FC_SYSTEM, FC_HIDDEN)。<br/>
      要指定多个字符串，只需将它们连接起来，例如 "SH"。<br/>
      <paramref name="uAttributes" /> 指定除了与 <paramref name="cFileSpec" /> 匹配的任何"可见"文件之外要满足的条件。可见文件不包括目录、卷标或隐藏或系统文件 — 所有其他文件都是可见的，无论它们的读取或存档属性的状态如何。<br/>
      要仅包含可见文件，请省略此参数。<br/>
      注意：要仅指定卷标，排除所有其他文件，请将 FA_VOLUME 或 "V" 作为唯一的 <paramref name="uAttributes" /> 参数。
    </param>
    <returns>
      一个子数组的数组，每个子数组包含与 <paramref name="cFileSpec" /> 匹配的每个文件的信息。<br/>
      子数组元素的引用如下（见下面的示例）：
      <include file="RTComments.xml" path="Comments/FileAttributes/*"  />
      如果没有找到与 <paramref name="cFileSpec" /> 匹配的文件，或者如果 <paramref name="cFileSpec" />
      是非法路径或文件规范，Directory() 返回一个空数组。
    </returns>
    <remarks>
      Directory() 返回当前或指定目录中文件的信息。您可以使用它对文件组执行操作。结合 AEval() 使用时，您可以定义一个应用于所有匹配指定 <paramref name="cFileSpec" /> 的文件的代码块。
    </remarks>
    <example>
      此示例获取当前目录中所有文件和目录的信息数组，然后使用 AEval() 和 QOut() 列出文件名：
      <code language="X#">
        aDirectory := Directory("*.*", "D")
        AEval(aDirectory, {|aFile| QOut(aFile[F_NAME])})
      </code>
      此示例获取当前目录中所有文件的信息数组：
      <code language="X#">aDirectory := Directory("*.*")</code>
      此示例显示与文件规范 *.PRG 匹配的每个文件的名称、大小、日期、时间和属性：
      <code language="X#">
        Function Start()
        &#0009;LOCAL aDir AS ARRAY
        &#0009;LOCAL i AS DWORD
        &#0009;LOCAL wLen AS DWORD
        &#0009;aDir := Directory("*.prg")
        &#0009;wLen := ALen(aDir)
        &#0009;FOR i := 1 UPTO wLen
        &#0009;&#0009;? aDir[i][F_NAME], aDir[i][F_SIZE],;
        &#0009;&#0009;  aDir[i][F_DATE], aDir[i][F_TIME],;
        &#0009;&#0009;  aDir[i][F_ATTR]
        &#0009;NEXT
        &#0009;// 除了上面的 FOR 循环外，您还可以
        &#0009;// 使用 AEval() 数组迭代器函数，如下所示：
        &#0009;AEval(aDir, {|aSub| QOut(aSub[F_NAME],;
        &#0009;&#0009;aSub[F_SIZE], aSub[F_DATE], aSub[F_TIME],;
        &#0009;&#0009;aSub[F_ATTR])})
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealsocmd>_Or</seealsocmd>
    <seealsocmd>operator__OrADir</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.Core.Functions.CurDir'>CurDir</seealso>
  </directory>

  <dirmake>
    <summary>
      创建一个目录。
    </summary>
    <param name="pszNewDir">
      要创建的目录名称，包括可选的驱动器。<br/>
      如果未指定驱动器，将使用 Windows 默认值。
    </param>
    <returns>
      如果成功则返回 0；如果参数错误则返回 -1；否则返回 DOS 错误代码。
    </returns>
    <remarks>
      DirMake() 创建指定的目录。您必须拥有足够的权限来创建目录。<br/>
      要创建嵌套的子目录，您必须分别创建每个子目录，从要创建的最顶层目录开始（请参见下面的示例）。
    </remarks>
    <example>
      此示例假设 C:\VO 已存在，并使用 DirMake() 两次来在其下创建嵌套的子目录：
      <code language="X#">
        DirMake("c:\vo\one")&#0009;&#0009;&#0009;// 创建最顶层的目录
        siResult := DirMake("c:\vo\one\two")
        IF siResult != 0
        &#0009;? DOSErrString(siResult)&#0009;// 检查 DOS 错误 ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DirChange'>DirChange</seealso>
    <seealso cref='O:XSharp.RT.Functions.DirRemove'>DirRemove</seealso>
  </dirmake>

  <dirremove>
    <summary>
      删除一个目录。
    </summary>
    <param name="pszDirName">
      要删除的目录名称，包括可选的驱动器。<br/>
      如果未指定驱动器，将使用 Windows 默认值。
    </param>
    <returns>
      如果成功则返回 0；如果参数错误则返回 -1；否则返回 DOS 错误代码。
    </returns>
    <remarks>
      DirRemove() 删除指定的目录。您必须拥有足够的权限来删除目录。<br/>
      目录必须为空才能被删除。因此，要删除包含子目录的目录，您必须先删除子目录（请参见下面的示例）。
    </remarks>
    <example>
      此示例使用 DirRemove() 删除名为 C:\VO\ONE 的子目录，该子目录仅包含一个名为 C:\VO\ONE\TWO 的空子目录：
      <code language="X#">
        DirRemove("c:\vo\one\two")&#0009;&#0009;// 首先删除最低层目录
        siResult := DirRemove("c:\vo\one")
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 然后删除上层目录
        ? DOSErrString(siResult)&#0009;&#0009;&#0009;// 检查是否有 DOS 错误
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DirChange'>DirChange</seealso>
    <seealso cref='O:XSharp.RT.Functions.DirMake'>DirMake</seealso>
  </dirremove>

  <diskchange>
    <summary>
      更改当前磁盘驱动器。
    </summary>
    <param name="pszDrive">要更改的磁盘驱动器的字母。</param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 DiskChange() 更改到 D 盘：
      <code language="X#">
        IF DiskChange("D:")
        &#0009;? "成功更改"
        ELSE
        &#0009;? "未更改"
        ENDIF
      </code>
      此示例构建一个包含系统上所有当前可用驱动器的字符串：
      <code language="X#">
        FUNCTION AllDrives()
        &#0009;LOCAL wI AS DWORD
        &#0009;LOCAL cDrives AS STRING
        &#0009;cDrives := NULL_STRING
        &#0009;FOR wI := 1 UPTO 27&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;
        &#0009;&#0009;IF DiskChange(Chr(wI +64))
        &#0009;&#0009;&#0009;cDrives := cDrives + Chr(wI+64)
        &#0009;&#0009;ENDIF
        &#0009;NEXT
        &#0009;RETURN cDrives
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.CurDrive'>CurDrive</seealso>
    <seealso cref='O:XSharp.RT.Functions.DirChange'>DirChange</seealso>
    <seealso cref='O:XSharp.Core.Functions.DiskFree'>DiskFree</seealso>
    <seealso cref='O:XSharp.Core.Functions.DiskName'>DiskName</seealso>
  </diskchange>

  <diskfree>
    <summary>
      返回指定磁盘上的可用空间。
    </summary>
    <param name="cDrive">
      要查询的磁盘驱动器的字母，例如 "C:"、"A:"。驱动器也可以用数字标识，其中 1 是 A 盘，2 是 B 盘，3 是 C 盘，以此类推。<br/>
      如果未指定驱动器，将使用 Windows 默认值。
    </param>
    <returns>
      指定磁盘驱动器上的空闲空间字节数。
    </returns>
    <remarks>
      DiskFree() 确定指定磁盘驱动器上剩余的可用字节数。<br/>
      在复制或排序到另一个驱动器时，它可用于在开始操作之前确定是否有足够的可用空间。
    </remarks>
    <example>
      这个例子是一个函数，演示了如何使用 DiskFree() 将数据库文件备份到另一个驱动器：
      <code language="X#">
        FUNCTION BackUp(cTargetFile, cTargetDrive)
        &#0009;LOCAL nSpaceNeeded
        &#0009;LOCAL lSuccess := FALSE
        &#0009;// 计算打开文件的大小
        &#0009;nSpaceNeeded := Integer((RecSize() * ;
        &#0009;&#0009;&#0009;&#0009;&#0009;LastRec()) + Header() + 1)
        &#0009;IF DiskFree(cTargetDrive) &lt; nSpaceNeeded
        &#0009;&#0009;lSuccess := FALSE
        &#0009;ELSE
        &#0009;&#0009;// 在复制之前关闭数据库文件
        &#0009;   DBCloseArea()
        &#0009;&#0009;FCopy("sales.dbf", cTargetDrive + ":"+ cTargetFile)
        &#0009;&#0009;lSuccess := TRUE
        &#0009;ENDIF
        &#0009;RETURN lSuccess
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.DiskSpace'>DiskSpace</seealso>
    <seealso cref='O:XSharp.RT.Functions.Header'>Header</seealso>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
    <seealso cref='O:XSharp.RT.Functions.RecSize'>RecSize</seealso>
  </diskfree>

  <diskname>
    <summary>
      返回当前 Windows 驱动器。
    </summary>
    <returns>
      当前驱动器的字母，不包含尾随冒号。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例说明了 DiskName() 和 DiskChange() 之间的关系，并显示 DiskName() 不受 SetDefault() 的影响：
      <code language="X#">
        FUNCTION DriveTest()
        &#0009;? DiskName()&#0009;&#0009;&#0009;// C
        &#0009;SetDefault("A")
        &#0009;? DiskName()&#0009;&#0009;&#0009;// C
        &#0009;DiskChange("A")
        &#0009;? DiskName()&#0009;&#0009;&#0009;// A
        &#0009;DiskChange("C")
        &#0009;? DiskName()&#0009;&#0009;&#0009;// C
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.CurDir'>CurDir</seealso>
    <seealso cref='O:XSharp.Core.Functions.CurDrive'>CurDrive</seealso>
    <seealso cref='O:XSharp.RT.Functions.DiskChange'>DiskChange</seealso>
    <seealso cref='O:XSharp.Core.Functions.WorkDir'>WorkDir</seealso>
  </diskname>

  <diskspace>
    <summary>
      返回指定磁盘的容量。
    </summary>
    <param name="nDrive">要查询的磁盘驱动器的编号，其中 1 是 A 盘，2 是 B 盘，3 是 C 盘，以此类推。驱动器也可以用字符串标识，例如 "C:"、"A:"。如果未指定驱动器，将使用 Windows 默认值。</param>
    <returns>
      指定磁盘驱动器的容量（以字节为单位）。
    </returns>
    <remarks>
      DiskSpace() 确定指定磁盘驱动器的容量（以字节为单位）。
      此函数仅对大小不超过 2 GB 的磁盘驱动器准确。<br/>
      对于更大的驱动器，请参考 Windows API 函数 GetDiskFreeSpaceEx()。
    </remarks>
    <example>
      此示例在 TextBox 中显示 C 盘的容量：
      <code language="X#">
        TextBox{, "C 盘容量", AsString( DiskSpace(3) ) }:Show()
        TextBox{, "C 盘容量", AsString( DiskSpace("C:") ) }:Show()
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.DiskFree'>DiskFree</seealso>
    <seealso cref='O:XSharp.RT.Functions.Header'>Header</seealso>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
    <seealso cref='O:XSharp.RT.Functions.RecSize'>RecSize</seealso>
  </diskspace>

  <doserror>
    <summary>
      返回与运行时错误块激活相关的最后一个 DOS 错误代码。
    </summary>
    <param name="nNewDosCode">一个 DOS 错误号，用于更改 DOSError() 返回的值。例如，您可以在尝试在黑盒模块中保留环境或尝试抵消其他模块的副作用时使用它来重置错误代码。</param>
    <returns>
      最后一个 DOS 错误的编号。<br/>
      如果失败的操作没有相关的 DOS 错误，DOSError() 返回 0。
    </returns>
    <remarks>
      当发生运行时错误且操作有相关的 DOS 错误时，DOSError() 被设置为该错误代码。<br/>
      此值将保留，直到发生另一个运行时错误或直到您通过指定 <paramref name="nNewDosCode" /> 参数来设置 DOSError() 的值。
      对于文件函数，FError() 返回与 DOSError() 相同的值。
    </remarks>
    <example>
      以下示例将 DOS 错误代码显示为字符串：
      <code language="X#">
        FUNCTION Start()
        &#0009;Dir AA:&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 错误的设备
        &#0009;QOut(DOSErrString(DOSError()))&#0009;
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 找不到路径
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.DosErrString'>DOSErrString</seealso>
    <seealso cref='O:XSharp.RT.Functions.ErrorBlock'>ErrorBlock</seealso>
    <seealso cref='O:XSharp.Core.Functions.ErrorLevel'>ErrorLevel</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.GetDosError'>GetDOSError</seealso>
  </doserror>

  <doserrstring>
    <summary>
      返回 DOS 错误号的描述字符串。
    </summary>
    <param name="dwError">您想要获取描述的 DOS 错误号。</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      以下示例将 DOS 错误代码显示为字符串：
      <code language="X#">
        FUNCTION Start()
        &#0009;Dir AA:&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 错误的设备
        &#0009;QOut(DOSErrString(DOSError()))&#0009;
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 找不到路径
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.DosError'>DOSError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.GetDosError'>GetDOSError</seealso>
  </doserrstring>

  <dow>
    <summary>
      从日期中提取星期几的数字。
    </summary>
    <param name="dDate">日期。</param>
    <returns>
      星期几的数字，范围从 1 到 7，其中 1 是星期日，2 是星期一，依此类推。<br/>
      对于无效或 NULL_DATE，DoW() 返回 0。
    </returns>
    <remarks>
      DoW() 是一个日期转换函数，将日期值转换为标识星期几的数字。<br/>
      当您想要进行每周的日期计算时，它非常有用。DoW() 类似于 CDoW()，后者返回星期几的字符串而不是数字。
    </remarks>
    <example>
      这些示例说明了 CDoW() 及其与 DoW() 的关系：
      <code language="X#">
        ? TODAY()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 09/01/98
        ? DOW(TODAY())&#0009;&#0009;&#0009;&#0009;&#0009;// 3
        ? CDOW(TODAY())&#0009;&#0009;&#0009;&#0009;// Tuesday
        ? DOW(TODAY() - 2)&#0009;&#0009;&#0009;&#0009;// 1
        ? CDOW(TODAY() – 2)&#0009;&#0009;&#0009;&#0009;// Sunday
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CDoW'>CDoW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Day'>Day</seealso>
    <seealso cref='O:XSharp.RT.Functions.Today'>Today</seealso>
  </dow>

  <dtoc>
    <summary>
      将日期转换为字符串。
    </summary>
    <param name="dDate">要转换的日期值。</param>
    <returns>
      <paramref name="dDate" /> 的字符串表示，格式化为当前日期格式。<br/>
      NULL_DATE 返回一个长度等于当前日期格式的空格字符串。
    </returns>
    <remarks>
      DToC() 是一个日期转换函数，用于格式化目的，当您想要以 SetDateFormat() 或 SetDateCountry() 格式显示日期，或者需要字符串时（例如在 LABEL FORM 中）。<br/>
      如果您需要特殊的日期格式，可以使用 Transform() 或自定义表达式。
      由于 DToS() 采用 yyyymmdd 的形式，它通常是与字符串组合索引日期的首选形式。
    </remarks>
    <example>
      这些示例展示了 DToC() 的一般用法：
      <code language="X#">
        ? TODAY()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 09/01/98
        ? DTOC(TODAY())&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 09/01/98
        ? "今天是 " + DTOC(TODAY())&#0009;&#0009;&#0009;&#0009;// 今天是 09/01/98
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CToD'>CToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToS'>DToS</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetCentury'>SetCentury</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDateCountry'>SetDateCountry</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDateFormat'>SetDateFormat</seealso>
    <seealso cref='O:XSharp.RT.Functions.Today'>Today</seealso>
    <seealso cref='O:XSharp.RT.Functions.Transform'>Transform</seealso>
  </dtoc>

  <dtos>
    <summary>
      将日期值转换为格式为 yyyymmdd 的字符串。
    </summary>
    <param name="dDate">要转换的日期值。</param>
    <returns>
      格式为 yyyymmdd 的 8 字符字符串。<br/>
      如果 <paramref name="dDate" /> 是 NULL_DATE，则返回八个空格的字符串。<br/>
      返回值不受当前日期格式的影响。
    </returns>
    <remarks>
      DToS() 是一个日期转换函数，用于创建由日期值和字符串组成的顺序键。DToS() 将日期值转换为可以与任何其他字符串连接的字符串。<br/>
      返回值的结构保留了日期顺序（年、月、日）。
    </remarks>
    <example>
      这些示例简单地将 DToS() 应用于日期：
      <code language="X#">
        ? TODAY()&#0009;&#0009;&#0009;&#0009;// 09/01/98
        ? DTOS(TODAY())&#0009;&#0009;&#0009;// 19980901
      </code>
      此示例将 DToS() 应用于日期字面量并报告其长度：
      <code language="X#">? SLen(DTOS(0.0.0)&#0009;&#0009;&#0009;// 8</code>
      此示例演示如何使用 DToS() 创建具有复合日期和字符键的顺序：
      <code language="X#">
        USE sales NEW
        INDEX ON DTOS(SaleDate) + LastName TO datename
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CToD'>CToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToC'>DToC</seealso>
    <seealso cref='O:XSharp.RT.Functions.SToD'>SToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.Today'>Today</seealso>
  </dtos>

  <dw2bin>
    <summary>
      将双字转换为包含32位无符号整数的字符串。
    </summary>
    <param name="dwValue">要转换的值。小数部分将被截断。</param>
    <returns>
      包含32位无符号整数的4字节字符串。
    </returns>
    <remarks>
      DW2Bin() 是一个转换函数，将双字转换为4字节字符串。典型应用包括以原生格式读取外部文件类型，然后以压缩的二进制形式而不是字符串形式保存、读取、解密和传输数值数据。<br/>
      其反函数是 Bin2DW()。
    </remarks>
    <example>
      此示例使用 DW2Bin() 将当前内存设置记录到调试文件中：
      <code language="X#">
        FUNCTION RecordMemory() AS LOGIC
        &#0009;LOCAL nh
        &#0009;LOCAL lSuccess := FALSE AS LOGIC
        &#0009;nh := FOpen2("debug.doc", FO_READWRITE)
        &#0009;// 假设 debug.doc 文件已存在
        &#0009;IF nh != F_ERROR
        &#0009;&#0009;FWrite3(nh, DW2Bin(Memory(1)), 4)
        &#0009;&#0009;FWrite3(nh, DW2Bin(Memory(2)), 4)
        &#0009;&#0009;FWrite3(nh, DW2Bin(Memory(3)), 4)
        &#0009;&#0009;FClose(nh)
        &#0009;&#0009;lSuccess := TRUE
        &#0009;ELSE
        &#0009;&#0009;? "打开 debug.doc 时发生错误"
        &#0009;&#0009;FError()
        &#0009;ENDIF
        &#0009;RETURN lSuccess
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </dw2bin>

  <elaptime>
    <summary>
      返回两个时间字符串之间的差值。
    </summary>
    <param name="cStartTime">以 hh:mO:ss 形式表示的起始时间。</param>
    <param name="cEndTime">以 hh:mO:ss 形式表示的结束时间。</param>
    <returns>
      从 <paramref name="cStartTime" /> 到 <paramref name="cEndTime" /> 经过的时间量，以 hh:mO:ss 格式的时间字符串表示。
    </returns>
    <remarks>
      ElapTime() 通过从 <paramref name="cEndTime" /> 中减去 <paramref name="cStartTime" /> 来计算两个时间字符串之间的差值。
    </remarks>
    <example>
      以下示例说明了 ElapTime() 的用法：
      <code language="X#">
        ? ElapTime("03:02:01", "09:09:09")&#0009;&#0009;// 06:07:08
        ? ElapTime("09:05:12", "23:10:07")&#0009;&#0009;// 14:04:55
        // 从晚上11点到凌晨5点经过的时间
        ? ElapTime("23:00:00", "05:00:00")&#0009;&#0009;// 06:00:00
        // 从凌晨5点到晚上11点经过的时间
        ? ElapTime("05:00:00", "23:00:00")&#0009;&#0009;// 18:00:00
        ? ElapTime(Time(), "20:01:03")&#0009;&#0009;
        // 取决于当前时间
      </code>
      <br/>
      系统库
    </example>
    <seealso cref='O:XSharp.Core.Functions.Seconds'>Seconds</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
  </elaptime>

  <empty>
    <summary>
      确定表达式的结果是否为空。
    </summary>
    <param name="uValue">
      任何数据类型的表达式。<br/>
      确定一个值是否被认为是空的标准取决于 <paramref name="uValue" /> 的数据类型，根据以下规则：<br/>
      <list type="table">
        <listheader>
          <term>数据类型</term>
          <description>内容</description>
        </listheader>
        <item>
          <term>数组</term>
          <description>NULL_ARRAY 或空数组</description>
        </item>
        <item>
          <term>代码块</term>
          <description>NULL_CODEBLOCK</description>
        </item>
        <item>
          <term>日期</term>
          <description>NULL_DATE</description>
        </item>
        <item>
          <term>逻辑值</term>
          <description>FALSE</description>
        </item>
        <item>
          <term>NIL</term>
          <description>NIL</description>
        </item>
        <item>
          <term>VOID</term>
          <description>TRUE</description>
        </item>
        <item>
          <term>数值</term>
          <description>0</description>
        </item>
        <item>
          <term>对象</term>
          <description>NULL_OBJECT</description>
        </item>
        <item>
          <term>PSZ</term>
          <description>NULL_PSZ</description>
        </item>
        <item>
          <term>PTR</term>
          <description>NULL_PTR</description>
        </item>
        <item>
          <term>字符串</term>
          <description>空格、制表符、回车/换行符或 NULL_STRING</description>
        </item>
        <item>
          <term>符号</term>
          <description>NULL_SYMBOL</description>
        </item>
      </list>
    </param>
    <returns>
      如果表达式结果为空值，则返回 TRUE；否则返回 FALSE。
    </returns>
    <seealso cref='O:XSharp.RT.Functions.ALen'>ALen</seealso>
    <seealso cref='O:XSharp.RT.Functions.EmptyUsual'>EmptyUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsSpace'>IsSpace</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.Core.Functions.SLen'>SLen</seealso>
  </empty>

  <emptytyped>
    <summary>
      确定表达式的结果是否为空。
    </summary>
    <param name="uValue">
      要检查"空性"的值
    </param>
    <param name="oObject">
      要检查"空性"的值
    </param>
    <returns>
      如果表达式结果为空值，则返回 TRUE；否则返回 FALSE。
    </returns>
    <seealso cref='O:XSharp.RT.Functions.ALen'>ALen</seealso>
    <seealso cref='O:XSharp.RT.Functions.EmptyUsual'>EmptyUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsSpace'>IsSpace</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.Core.Functions.SLen'>SLen</seealso>
  </emptytyped>

  <emptyfield>
    <summary>
      确定当前工作区中的字段 n 是否为空。
    </summary>
    <param name="n">当前工作区中的字段编号。</param>
    <returns>
      如果字段为空，则返回 TRUE；否则返回 FALSE。
    </returns>
  </emptyfield>

  <emptyrecord>
    <summary>
      确定当前工作区中的当前记录是否为空。
    </summary>
    <returns>
      如果记录为空，则返回 TRUE；否则返回 FALSE。
    </returns>
  </emptyrecord>
  <emptyusual>
    <summary>
      返回指定数据类型的空值。
    </summary>
    <param name="kType">
      需要获取空值的数据类型。<br/>
      下表列出了所有 X# 数据类型的常量。
    </param>
    <returns>
      由 <paramref name="kType" /> 指定的数据类型的空值。<br/>
      这些值如下所示：
      <list type="table">
        <listheader>
          <term>
            <paramref name="kType" />
          </term>
          <description>空值</description>
        </listheader>
        <item>
          <term>ARRAY</term>
          <description>NULL_ARRAY 或空数组</description>
        </item>
        <item>
          <term>BYTE, DWORD</term>
          <description>0</description>
        </item>
        <item>
          <term>FLOAT, INT</term>
          <description>0</description>
        </item>
        <item>
          <term>LONGINT, REAL4</term>
          <description>0</description>
        </item>
        <item>
          <term>
            REAL8, SHORTINT
          </term>
          <description>0</description>
        </item>
        <item>
          <term>WORD</term>
          <description>0</description>
        </item>
        <item>
          <term>CODEBLOCK</term>
          <description>NULL_CODEBLOCK</description>
        </item>
        <item>
          <term>DATE</term>
          <description>NULL_DATE</description>
        </item>
        <item>
          <term>LOGIC</term>
          <description>FALSE</description>
        </item>
        <item>
          <term>OBJECT</term>
          <description>NULL_OBJECT</description>
        </item>
        <item>
          <term>PSZ</term>
          <description>NULL_PSZ</description>
        </item>
        <item>
          <term>PTR</term>
          <description>NULL_PTR </description>
        </item>
        <item>
          <term>STRING</term>
          <description>空格、制表符、回车/换行符或 NULL_STRING</description>
        </item>
        <item>
          <term>SYMBOL</term>
          <description>NULL_SYMBOL</description>
        </item>
        <item>
          <term>USUAL</term>
          <description>
            NIL
          </description>
        </item>
        <item>
          <term>VOID</term>
          <description>NIL</description>
        </item>
      </list>
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例显示了 EmptyUsual() 对不同数据类型的结果：
      <code language="X#">
        &#0009;? EmptyUsual(LOGIC)&#0009;&#0009;&#0009;&#0009;// FALSE
        &#0009;? EmptyUsual(SHORTINT)&#0009;&#0009;// 0
        &#0009;? EmptyUsual(STRING)&#0009;&#0009;&#0009;// NULL_STRING
      </code>
      此示例将 EmptyUsual() 函数的结果传递给 Empty() 函数：
      <code language="X#">
        &#0009;? Empty(EmptyUsual(DATE))&#0009;&#0009;&#0009;// TRUE
        &#0009;? Empty(EmptyUsual(LONGINT))&#0009;// TRUE
        &#0009;? Empty(EmptyUsual(SYMBOL))  &#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.Empty'>Empty</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceNumeric'>EnforceNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
  </emptyusual>

  <enable3dcontrols>
    <summary>
      注意 - 此函数在32位程序中没有用途。它仅为了与16位应用程序向后兼容而包含。
      <br/>
      确定使用GUI类创建的窗口上的控件是否以雕刻的三维外观显示。
    </summary>
    <returns>
    </returns>
    <remarks>
      默认情况下，显示在窗口上的控件（如编辑控件）以平面的一维外观显示。但是，您可以使用诸如Control:Background或TextControl:TextColor属性等方法为控件分配各种颜色属性。调用Enable3DControls()会使它们以带有阴影的方式显示，产生雕刻的三维效果，并禁用所有颜色属性。
      注意：Enable3DControls()仅影响使用GUI类（如数据窗口）创建的窗口上的控件。<br/>
      它对终端仿真窗口没有影响。
    </remarks>
    <example>
      标准应用程序在App:Start()方法中调用此函数，如下例所示。<br/>
      如果您更喜欢一维外观，只需删除对Enable3DControls()的调用：
      <code language="X#">
        METHOD Start() CLASS App
        &#0009;LOCAL oWindow AS Window
        &#0009;Enable3DControls()
        &#0009;oWindow := StandardShellWindow{SELF}
        &#0009;oWindow:Show()
        &#0009;SELF:Exec()
      </code>
    </example>
  </enable3dcontrols>

  <encodebase64>
    <summary>
      对文件进行编码以用于电子邮件传输。
    </summary>
    <param name="hSource">要编码的文件句柄。</param>
    <param name="hDestination">编码后的文本将写入的文件句柄。</param>
    <returns>
      编码的字节数。
    </returns>
    <remarks>
      Base64编码用于在互联网上传输附加到邮件的文件。
    </remarks>
    <example>
      <code language="X#">
        hOut := FCreate("C:\MyFiles\MailOut.txt")
        IF hfOut != F_ERROR
        &#0009;hIn := FOpen("C:\MyFiles\Source.txt", FO_READ)
        &#0009;IF hIn != F_ERROR
        &#0009;&#0009;nTotalBytes := EncodeBase64(hIn, hOut)
        &#0009;&#0009;TextBox{,"编码", "已编码字节数: " + ;
        &#0009;&#0009;&#0009;AsString(nTotalBytes)}:Show()
        ENDIF
        ENDIF
        FClose(hfOut)
        FClose(hf)
      </code>
      有关EncodeBase64()的更完整示例，请参见Mime编码示例应用程序(CAVOxx\SAMPLES\INTERNET\MIME\MENCODE.AEF)。
    </example>
    <seealsocmd>CLASS CEmail</seealsocmd>
    <seealsocmd>CLASS CMailAbstract</seealsocmd>
    <seealsocmd>CLASS CSmtp</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.DecodeBase64'>DecodeBase64</seealso>
  </encodebase64>

  <enforcenumeric>
    <summary>
      确保变量是数值类型。
    </summary>
    <param name="u">
      要检查的变量。<br/>
      如果 <paramref name="u" /> 为 NIL，则将其赋值为 0。
      如果 <paramref name="u" /> 不是通过引用传递且不是数值类型，错误系统将中止程序。
      如果 <paramref name="u" /> 是通过引用传递但不是数值类型，将调用错误系统并将 <paramref name="u" /> 赋值为 0。
    </param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 EnforceNumeric() 确保参数是数值类型，并初始化为 0：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL nOne
        &#0009;LOCAL nTwo
        &#0009;LOCAL cName
        &#0009;CheckNumbers()
        FUNCTION CheckNumbers(nOne, nTwo)
        &#0009;EnforceNumeric(@nOne)&#0009;// Assigns 0 since NIL
        &#0009;Default(@nTwo, 100)&#0009;&#0009;// Assigns 100 since NIL
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EmptyUsual'>EmptyUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
  </enforcenumeric>

  <enforcetype>
    <summary>
      确保变量是特定类型。
    </summary>
    <param name="u">
      要检查的变量。<br/>
      如果 <paramref name="u" /> 为 NIL 且通过引用传递，则将 <paramref name="dwType" /> 指定的数据类型的 EmptyUsual() 赋值给它。<br/>
      如果 <paramref name="u" /> 不是通过引用传递且不是 <paramref name="dwType" /> 指定的数据类型，错误系统将中止程序。<br/>
      如果 <paramref name="u" /> 是通过引用传递但不是 <paramref name="dwType" /> 指定的数据类型，将调用错误系统并将 <paramref name="dwType" /> 指定的数据类型的 EmptyUsual() 赋值给 <paramref name="u" />。
    </param>
    <param name="dwType">要强制执行的数据类型。</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 EnforceType() 确保所有参数都是正确的类型：
      <code language="X#">
        FUNCTION CheckArgs(cName, nScore, dDate, nMoney)
        &#0009;EnforceType(@cName, STRING)
        &#0009;EnforceType(@nScore, SHORTINT)
        &#0009;&#0009;// 如果为 NIL 则赋值为 0
        &#0009;EnforceType(@dDate, DATE)
        &#0009;EnforceType(@nMoney, LONGINT)&#0009;// 如果为 NIL 则赋值为 0
        &#0009;EnforceType(@nOne, SHORTINT)&#0009;// 如果为 NIL 则赋值为 0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EmptyUsual'>EmptyUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceNumeric'>EnforceNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
  </enforcetype>

  <eof>
    <summary>
      确定何时遇到文件结尾。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      当尝试将记录指针移动到数据库文件中最后一个逻辑记录之后，或者数据库文件不包含记录时，返回 TRUE；否则返回 FALSE。<br/>
      如果工作区中没有打开的数据库文件，EOF() 返回 TRUE。
    </returns>
    <remarks>
      EOF() 是一个数据库函数，用于在记录指针向前移动通过数据库文件时测试文件结尾边界条件。<br/>
      任何可以移动记录指针的命令都可以设置 EOF()。<br/>
      最典型的应用是作为 DO WHILE 结构的 <paramref name="lCondition" /> 参数的一部分，该结构顺序处理数据库文件中的记录。这里 <paramref name="lCondition" /> 将包括 .NOT. EOF() 的测试，当 EOF() 返回 TRUE 时强制 DO WHILE 循环终止。<br/>
      EOF() 和 Found() 经常可以互换使用，以测试 SEEK、FIND 或 LOCATE 命令是否失败。<br/>
      然而，对于这些命令，Found() 更受欢迎。<br/>
      当 EOF() 返回 TRUE 时，无论是否有活动的过滤器设置或 SetDeleted() 为 TRUE，记录指针都位于 LastRec() + 1 的位置。<br/>
      进一步尝试向前移动记录指针将返回相同的结果而不会出错。<br/>
      一旦 EOF() 设置为 TRUE，它将保持其值，直到再次尝试移动记录指针。<br/>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      此示例通过故意将记录指针移动到最后一条记录之后来演示 EOF()：
      <code language="X#">
        USE sales
        DBGoBottom()
        QOut(EOF())&#0009;&#0009;&#0009;// 结果: FALSE
        SKIP
        QOut(EOF())&#0009;&#0009;&#0009;// 结果: TRUE
      </code>
      此示例使用别名表达式查询未选定工作区中 EOF() 的值：
      <code language="X#">
        USE sales NEW
        USE customer NEW
        QOut(Sales-&gt;EOF())
        QOut(Customer-&gt;EOF())
      </code>
      此示例说明如何将 EOF() 用作顺序数据库文件操作条件的一部分：
      <code language="X#">
        USE sales INDEX custnum NEW
        DO WHILE !(Sales-&gt;EOF())
        &#0009;nOldCust := Sales-&gt;CustNum
        &#0009;nTotalAmount := 0
        &#0009;DO WHILE nOldCust = Sales-&gt;CustNum .AND. ;
        &#0009;&#0009;&#0009;&#0009;!(Sales-&gt;EOF()
        &#0009;&#0009;QOut(Sales-&gt;CustNum, ;
        &#0009;&#0009;&#0009;Sales-&gt;Description, ;
        &#0009;&#0009;&#0009;Sales-&gt;SaleAmount)
        &#0009;&#0009;nTotalAmount += Sales-&gt;SaleAmount
        &#0009;&#0009;SKIP
        &#0009;ENDDO
        &#0009;QOut("总金额: ", nTotalAmount)
        ENDDO
      </code>
      您也可以在上面的代码中使用带有别名参数的 EOF() 来编写 EOF 检查：
      <code language="X#">
        DO WHILE !EOF("Sales")
        &#0009;.
        &#0009;.
        ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bof'>BOF</seealso>
    <seealsocmd>DO WHILE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.Found'>Found</seealso>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
    <seealsocmd>LOCATE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.RecNo'>RecNo</seealso>
    <seealsocmd>SEEK</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbEof'>VODBEOF</seealso>
    <seealso cref='P:VO.DbServer.EoF'>DBServer:EoF</seealso>
  </eof>

  <errorbuild>
    <summary>从异常创建错误对象。</summary>
    <param name="pErrInfo">用于创建Error对象的异常对象。</param>
  </errorbuild>

  <errorblock>
    <summary>
      返回并可选择性地更改在发生运行时错误时执行的代码块。
    </summary>
    <param name="cbNewSetting">当发生运行时错误时要执行的代码块。</param>
    <returns>
      如果未指定<paramref name="cbNewSetting" />，ErrorBlock()返回当前设置。<br/>
      如果指定了<paramref name="cbNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      X#定义了一个默认的错误处理代码块，用于确定在发生运行时错误时该做什么。ErrorBlock()允许您用自定义的错误处理机制覆盖此默认机制。
      将错误处理程序指定为具有以下形式的代码块：
      <code language="X#">
        {|<paramref name="oError" />| <paramref name="uList" />}
      </code>
      其中<paramref name="oError" />是包含错误信息的错误对象，<paramref name="uList" />是调用实际处理错误的函数的USUAL表达式的逗号分隔列表。<br/>
      在代码块内，可以向错误对象发送消息以获取有关错误的信息。<br/>
      错误处理代码块返回TRUE值会重试失败的操作，而返回FALSE值则恢复处理。
      错误处理代码块可以指定为表达式列表或函数调用。<br/>
      函数调用更有用，因为您可以使用X#控制语句而不是表达式。<br/>
      特别是在有待处理的BEGIN SEQUENCE或LabelPush()，并且您想要BREAK到最近的RECOVER语句时，这一点尤为重要。<br/>
      这意味着错误处理代码块可以与BEGIN SEQUENCE...END控制结构结合使用。<br/>
      在错误处理代码块内，您可以处理具有通用恢复机制的设备、低级和常见错误。<br/>
      如果操作需要特定的错误处理，请定义BEGIN SEQUENCE或LabelPush()，然后BREAK到RECOVER语句，返回错误对象进行本地处理。请参见下面的示例。
      有关错误对象的结构和操作的更多信息，请参阅Error类条目。<br/>
    </remarks>
    <example>
      此代码片段在BEGIN SEQUENCE结构内发生错误时发布并调用错误处理代码块：
      <code language="X#">
        LOCAL cbErrorHandler, cbLastHandler, oError
        cbErrorHandler := {|oError|MyErrorHandler(oError)}
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 保存当前处理程序
        cbLastHandler := ErrorBlock(cbErrorHandler)
        BEGIN SEQUENCE
        &#0009;.
        &#0009;. <paramref name="OperationStatements" />
        &#0009;.
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 从BREAK接收错误对象
        RECOVER USING oErrorInfo
        &#0009;.
        &#0009;. <paramref name="RecoveryStatements" />
        &#0009;.
        END
        ErrorBlock(cbLastHandler)&#0009;&#0009;&#0009;// 恢复处理程序
        FUNCTION MyErrorHandler(oError)
        &#0009;BREAK oError
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 将错误对象返回到RECOVER
      </code>
      此示例改进了前面的示例。不是设置ErrorBlock({|oError| _Break(oError)})（它只是执行BREAK而不利用错误系统的功能，例如VOERROR.LOG），
      您可以为Error类设置Init方法，如下所示：
    </example>
    <seealsocmd>BEGIN SEQUENCE</seealsocmd>
    <seealsocmd>ErrorSys</seealsocmd>
  </errorblock>

  <errorcount>
    <summary>
      返回程序执行期间发生的错误数量。
    </summary>
    <param name="wValue">将应用程序的错误计数重置为指定值。</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      这个例子故意产生一个错误并显示 ErrorCount() 的返回值：
      <code language="X#">
        FUNCTION Start()
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 产生一个错误并获取错误计数
        LOCAL oError, nVal
        BEGIN SEQUENCE
        &#0009;oError := ErrorBlock({|| _Break(NIL)})
        &#0009;nVal := 0
        &#0009;? 1/nVal&#0009;&#0009;&#0009;// 除以0错误
        END
        ErrorBlock(oError)
        ? ErrorCount()&#0009;&#0009;&#0009;&#0009;// 1
        ErrorCount(0)&#0009;&#0009;&#0009;&#0009;// 将错误计数重置为零
      </code>
    </example>
  </errorcount>

  <errorgen>
    <summary>
      重新安装默认错误函数。
    </summary>
    <returns>
    </returns>
    <remarks>
      ErrorGen() 过程因为使用 _INIT1 关键字声明，所以在每个 X# 应用程序启动时自动执行，以安装默认错误处理函数 DefErrorGen()。<br/>
      如果您选择安装自己的错误处理函数，并且在应用程序的任何时候想要重新安装默认函数，只需调用 ErrorGen()。
    </remarks>
    <example>
    </example>
    <seealsocmd>DefErrorGen</seealsocmd>
    <seealso cref='O:XSharp.VO.Functions.ErrorFunc'>ErrorFunc</seealso>
    <seealsocmd>ErrorSys</seealsocmd>
  </errorgen>

  <errorlevel>
    <summary>
      获取并可选择性地设置 X# 返回码。
    </summary>
    <param name="dwNewSetting">
      新的返回码设置。<br/>
      这可以是 0 到 255 之间的值。<br/>
      默认初始值为 0。<br/>

      &#0009;当 X# 程序终止时，如果进程因致命错误而结束，返回码设置为 1。<br/>
      如果进程正常结束，返回码设置为 0（除非在程序中通过 ErrorLevel() 设置为其他值）。<br/>

      &#0009;通常，您会使用 ErrorLevel() 设置返回码，以向调用当前 X# 程序的程序指示错误状态。在大多数情况下，这是应用程序批处理文件。在这里，您可以使用 DOS ErrorLevel 命令测试返回码。（有关更多信息，请参阅您的 DOS 手册。）
    </param>
    <returns>
      如果未指定 <paramref name="dwNewSetting" />，ErrorLevel() 返回当前设置。<br/>
      如果指定了 <paramref name="dwNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      <note type="tip">
        在 RUN 命令之后，ErrorLevel() 返回值小于 32 表示发生错误。（有关更多信息，请参阅 Windows API WinExec() 函数。）
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.DosError'>DOSError</seealso>
    <seealso cref='O:XSharp.Core.Functions._Quit'>QUIT</seealso>
  </errorlevel>

  <errornew>
    <summary>
      创建新的错误对象。
      注意：ErrorNew() 是一个兼容性函数，不再推荐使用。<br/>
      它被直接调用 Error 类构造函数 (Error{}) 所取代，后者直接创建错误对象。
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 ErrorNew() 创建新的错误对象：
      <code language="X#">
        LOCAL oError AS ERROR
        oError := ErrorNew()
      </code>
      此示例与上面的示例执行相同的操作，但通过直接创建错误对象更加高效：
      <code language="X#">
        LOCAL oError AS ERROR
        oError := Error{}
      </code>
    </example>
  </errornew>
  <errorstackoptions>
    <summary>
    </summary>
    <param name="ulAddProcFile">（可选）LOGIC：是否在调用堆栈中包含模块名称</param>
    <param name="uliStackLength">（可选）LONG：在错误调用堆栈中包含的层级数</param>
    <param name="ulAddLevelNumber">（可选）LOGIC：是否在调用堆栈中包含层级编号</param>
    <param name="uliUntilExecOrDispatch">（可选）LONG：在调用堆栈中包含的 Dispatch()、Eval() 或 Exec() 层级数。</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </errorstackoptions>

  <errorsys>
    <summary>
      重新安装默认错误处理程序。
    </summary>
    <returns>
    </returns>
    <remarks>
      ErrorSys() 过程由于使用 _INIT1 关键字声明，所以在每个 X# 应用程序启动时自动执行，以安装默认错误处理程序。<br/>
      如果您选择安装自己的错误处理程序，并且在应用程序的任何时候想要重新安装默认程序，只需调用 ErrorSys()。
      默认错误处理程序的源代码定义在 ERRORSYS.PRG 文件中，位于您的 X# \SAMPLES 目录下。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ErrorBlock'>ErrorBlock</seealso>
    <seealsocmd>ErrorGen</seealsocmd>
  </errorsys>

  <errstring>
    <summary>
      返回与系统生成的错误代码相关联的错误消息。
    </summary>
    <param name="dwNewReturnCode">由错误对象导出的错误代码。</param>
    <returns>
      与错误代码相关联的消息字符串。错误消息是与国家/地区相关的。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例显示与保护错误相关联的错误消息：
      <code language="X#">
        FUNCTION Start()
        &#0009;QOut("EG_PROTECTION:", ErrString(EG_PROTECTION))
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.DosError'>DOSError</seealso>
  </errstring>

  <eval>
    <summary>
      评估代码块或对象的Eval()方法。
    </summary>
    <param name="obj">
      要执行的代码。<br/>
      使用其Eval()方法。
    </param>
    <param name="block">
      要执行的代码。<br/>
      如果指定了对象，则使用其Eval()方法。
    </param>
    <param name="uCodeBlock">
      要执行的代码。<br/>
      如果指定了对象，则使用其Eval()方法。
    </param>
    <param name="args">可以发送给要评估的代码块或方法的参数列表。</param>
    <returns>
      代码块内最后一个表达式的值。
    </returns>
    <remarks>
      X#编译器通常在编译时编译代码块。<br/>
      如果需要在运行时从字符串编译代码块，请使用宏运算符(&amp;)。
      Eval()经常用于创建迭代器函数。<br/>
      这些函数，如AEval()、ASort()、AScan()和DBEval()，将代码块应用于数据结构的每个成员。<br/>
      例如，AEval()可用于将代码块应用于数组中的每个元素。
    </remarks>
    <example>
      此示例创建一个递增数字的代码块，然后对其进行评估：
      <code language="X#">
        cbBlock := {|nArg| nArg + 1}
        ? Eval(cbBlock, 1)&#0009;&#0009;&#0009;&#0009;&#0009;// 2
      </code>
      此示例演示了使用宏运算符(&amp;)在运行时编译代码块：
      <code language="X#">
        // 将字符串编译为代码块
        cbBlock := &amp;("{|nArg| nArg + 1}")
        // 评估代码块
        ? Eval(cbBlock, 1)&#0009;&#0009;&#0009;&#0009;&#0009;// 2
      </code>
      此示例将Eval()应用于对象：
      <code language="X#">
        CLASS Greet
        METHOD Eval(cStr) CLASS Greet
        ? "你好", cStr
        FUNCTION Start()
        &#0009;LOCAL oHello AS OBJECT
        &#0009;oHello := Greet{}
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 调用类的Eval()方法：
        &#0009;Eval(oHello, "朋友") &#0009;// 你好 朋友
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanBinExact'>AScanBinExact</seealso>
    <seealso cref='O:XSharp.RT.Functions.AScanExact'>AScanExact</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbEval'>DBEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.SEval'>SEval</seealso>
  </eval>

  <evaluate>
    <summary>
      评估包含在字符串中的表达式。
    </summary>
    <param name="cString">包含要评估的表达式的字符串。</param>
    <returns>
      表达式的值。
    </returns>
    <remarks>
      Evaluate() 每次评估表达式时都会调用宏编译器。<br/>
      另外，您可以使用 MCompile() 只编译一次表达式，然后使用 MExec() 根据需要多次执行编译后的形式。
    </remarks>
    <example>
      此示例展示了 Evaluate() 的典型用法：
      <code language="X#">
        LOCAL cVar AS STRING
        cVar := "World"
        World := "Hello"&#0009;// World 是一个 PRIVATE 变量
        ? Evaluate(cVar)&#0009;// Hello
        ? Evaluate("2+3")&#0009;// 5
        Two := 2&#0009;// Two 是一个 PRIVATE 变量
        Evaluate("Two+3")&#0009;// 5
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MAssign'>MAssign</seealso>
    <seealso cref='O:XSharp.RT.Functions.MCompile'>MCompile</seealso>
    <seealso cref='O:XSharp.RT.Functions.MExec'>MExec</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrEvaluate'>StrEvaluate</seealso>
  </evaluate>

  <exp>
    <summary>
      计算自然对数的数值。
    </summary>
    <param name="nExponent">e 要被提升的幂。</param>
    <returns>
      等价于 e 的 <paramref name="nExponent" /> 次方的浮点数。
    </returns>
    <remarks>
      Exp() 计算以下方程的 y 值（反对数）：
      <code language="X#">e^x = y</code>
      其中 e 是自然对数的底数（2.71828...），x 是 <paramref name="nExponent" />。
      Exp() 和 Log() 是互逆函数。
    </remarks>
    <example>
      此示例演示了 Exp() 的几种调用：
      <code language="X#">
        ? Exp(1)&#0009;&#0009;&#0009;&#0009;&#0009;// 2.72
        SetDecimal(10)
        ? Exp(1)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 2.7182818285
        ? Log(Exp(1))&#0009;&#0009;&#0009;&#0009;// 1.0000000000
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.LOG'>Log</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pow'>Pow</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetFixed'>SetFixed</seealso>
  </exp>

  <f2bin>
    <summary>
      将浮点数转换为包含 80 位浮点数的字符串。
    </summary>
    <param name="fValue">要转换的值。</param>
    <returns>
      表示浮点数的字符串。
    </returns>
    <remarks>
      F2Bin() 是一个转换函数，用于将浮点数转换为字符串。典型应用包括以原生格式读取外部文件类型，然后以压缩的二进制形式而不是字符串形式保存、读取、解密和传输数值数据。<br/>
      其逆函数是 Bin2F()。
    </remarks>
    <example>
      此示例将 Seconds() 函数的返回值保存到二进制调试文件中：
      <code language="X#">
        FUNCTION StoreData() AS LOGIC
        &#0009;LOCAL nh
        &#0009;LOCAL lSuccess := FALSE AS LOGIC
        &#0009;nh := FOpen2("debug.bin", FO_READWRITE)
        &#0009;// 假设文件 debug.doc 已存在
        &#0009;IF nh != F_ERROR
        &#0009;&#0009;FWrite(nh, F2Bin(Seconds()))
        &#0009;&#0009;FClose(nh)
        &#0009;&#0009;lSuccess := TRUE
        &#0009;ELSE
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;ENDIF
        &#0009;RETURN lSuccess
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </f2bin>

  <fact>
    <summary>
      计算一个数的阶乘。
    </summary>
    <param name="wValue">一个正数。</param>
    <returns>
    </returns>
    <remarks>
      整数n的阶乘计算如下：
      <code language="X#">阶乘(n)=n*(n-1)*(n-2) ... 3*2*1</code>
      0的阶乘定义为1。
    </remarks>
    <example>
      这个例子使用Fact()计算5的阶乘，然后验证结果：
      <code language="X#">
        ? Fact(5)&#0009;&#0009;&#0009;&#0009;&#0009;// 120
        // 验证
        ? 5*4*3*2*1&#0009;&#0009;&#0009;&#0009;&#0009;// 120
      </code>
    </example>
  </fact>

  <fattr2string>
    <summary>
      将文件属性显示为字符串。
    </summary>
    <param name="dwAttributes">
      以下一个或多个常量，指示要返回的文件属性（文件属性由FAttrib()返回）：<br/>
      <br/>
      &#0009;常量&#0009;返回值<br/>
      &#0009;FA_DIRECTORY&#0009;D<br/>
      &#0009;FA_VOLUME&#0009;V<br/>
      &#0009;FC_ARCHIVED&#0009;A<br/>
      &#0009;FC_HIDDEN&#0009;H<br/>
      &#0009;FC_NORMAL&#0009;NULL_STRING<br/>
      &#0009;FC_READONLY&#0009;R<br/>
      &#0009;FC_SYSTEM&#0009;S&#0009;
    </param>
    <returns>
      根据<paramref name="dwAttributes" />中指定的文件属性常量，返回上表中指示的一个或多个字符。<br/>
      如果存在多个属性，这些字符将被连接成一个字符串。您可以使用字符串搜索函数At()来确定是否设置了特定属性（请参见下面的示例）。
    </returns>
    <remarks>
    </remarks>
    <example>
      这些示例展示了FAttr2String()的返回值：
      <code language="X#">
        ? FAttr2String(FC_HIDDEN)&#0009;&#0009;&#0009;&#0009;&#0009;// H
        ? FAttr2String(FC_HIDDEN + FC_SYSTEM)&#0009;&#0009;// HS
      </code>
      这个示例使用FAttr2String()来查找名为ABC.DBF的文件是否为只读文件：
      <code language="X#">
        FFirst("abc.dbf", FC_NORMAL)
        IF At(FAttr2String(FAttrib()), "R") &gt; 0
        &#0009;// 属性字符串包含"R"，所以文件是只读的
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
  </fattr2string>

  <fattrib>
    <summary>
      确定 FFCount()、FFirst() 或 FNext() 找到的文件的属性。
    </summary>
    <returns>
      表示当前文件属性的值。
      以下表格中的常量可以单独使用或组合使用，以确定哪些属性适用：
      常量&#0009;描述&#0009;
      FA_DIRECTORY&#0009;目录&#0009;
      FA_VOLUME&#0009;卷&#0009;
      FC_ARCHIVED&#0009;已归档&#0009;
      FC_HIDDEN&#0009;隐藏&#0009;
      FC_NORMAL&#0009;读/写&#0009;
      FC_READONLY&#0009;只读&#0009;
      FC_SYSTEM&#0009;系统&#0009;
      注意：<br/>
      一个文件拥有多个属性并不罕见。<br/>
      例如，它可能是只读的和已归档的，这将表示为 FC_READONLY + FC_ARCHIVED 或 _Or(FC_READONLY, FC_ARCHIVED)。
    </returns>
    <remarks>
      由于 FFCount() 和 FFirst() 无法根据文件的读取和归档属性来区分文件，因此 FAttrib() 在确定这些属性时很有用。<br/>
      例如，如果 FAttrib() 返回 FC_NORMAL，则说明当前文件是读/写的且未归档；如果返回 FC_ARCHIVED（或 FC_NORMAL + FC_ARCHIVED），则说明文件是读/写的且已归档。
    </remarks>
    <example>
      此示例展示了 FAttrib() 与 FFirst() 和 FNext() 的配合使用：
      <code language="X#">
        // 查找第一个匹配 docu*.txt 的文件
        ? FFirst("docu*.txt", FC_NORMAL)
        ? FAttrib()&#0009;&#0009;&#0009;//  32 (FC_ARCHIVED)
        ? FNext()&#0009;&#0009;&#0009;&#0009;// 下一个匹配 docu*.txt 的文件
        ? FAttrib()&#0009;&#0009;&#0009;//  33
        // 33 是 FC_READONLY + FC_ARCHIVED
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FDate'>FDate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFCount'>FFCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFirst'>FFirst</seealso>
    <seealso cref='O:XSharp.Core.Functions.FName'>FName</seealso>
    <seealso cref='O:XSharp.Core.Functions.FNext'>FNext</seealso>
    <seealso cref='O:XSharp.Core.Functions.FSize'>FSize</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTime'>FTime</seealso>
  </fattrib>

  <fchsize>
    <summary>
      通过低级文件函数更改已打开文件的大小。
    </summary>
    <param name="ptrHandle">要更改大小的已打开文件的句柄。</param>
    <param name="dwOffset">文件应设置的新长度。</param>
    <returns>
      如果成功，返回文件的新长度；否则，返回 F_ERROR。可以使用 FError() 确定具体错误。
    </returns>
    <remarks>
      FChSize() 将文件截断或扩展到指定长度。<br/>
      文件应该以写入模式打开，且其句柄必须可用。<br/>
      如果文件大小增加，将追加空字符 (Chr(0))。
    </remarks>
    <example>
      此示例展示了 FChSize() 与 FOpen2() 的配合使用：
      <code language="X#">
        LOCAL hFile
        hFile := FOpen2("docs.txt", F0_READWRITE)
        IF hFile != F_ERROR
        &#0009;IF FChSize(hFile, 100) != F_ERROR
        &#0009;&#0009;? "成功将大小更改为 100"
        &#0009;ELSE
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;ENDIF
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
  </fchsize>

  <fclose>
    <summary>
      关闭打开的文件并将缓冲区写入磁盘。
    </summary>
    <param name="ptrHandle">要关闭的打开文件的句柄。</param>
    <returns>
      如果写入时发生错误则返回 FALSE；否则返回 TRUE。
    </returns>
    <remarks>
      FClose() 是一个低级文件函数，用于关闭文件并强制将相关缓冲区写入磁盘。<br/>
      如果操作失败，FClose() 返回 FALSE，可以使用 FError() 确定具体错误。<br/>
      例如，尝试使用无效句柄调用 FClose() 会返回 FALSE，而 FError() 会返回错误 6，即无效句柄。
    </remarks>
    <example>
      此示例使用 FClose() 关闭新创建的文件，如果关闭失败则显示错误消息：
      <code language="X#">
        ptrHandle := FCreate("testfile", FC_NORMAL)
        IF !FClose(ptrHandle)
        &#0009;? DOSErrString(FError())
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
  </fclose>

  <fcommit>
    <summary>
      刷新文件缓冲区。
    </summary>
    <param name="ptrHandle">要刷新的打开文件的句柄。</param>
    <returns>
    </returns>
    <remarks>
      FCommit() 将文件缓冲区的内容写入文件。<br/>
      在多用户或多任务环境中共享文件时，FCommit() 有助于让每个用户看到文件的最新内容。<br/>
      磁盘写入还可以防止系统崩溃导致的可能数据丢失。
    </remarks>
    <example>
      此示例使用 FCommit() 确保缓冲区被写入磁盘：
      <code language="X#">
        LOCAL ptrFile AS PTR
        ptrFile := FOpen2("myfile.txt", F0_READWRITE + FO_SHARED)
        FWrite3(ptrFile, Space(550), 550)
        // 保持其他用户/任务更新
        FCommit(ptrFile)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FFlush'>FFlush</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
  </fcommit>

  <fcopy>
    <summary>
      将文件复制到新文件或设备。
    </summary>
    <param name="cSourceFile">
      要复制的源文件名，可包含可选的驱动器、目录和扩展名。<br/>
      &#0009;如果 <paramref name="cSourceFile" /> 不存在，将引发运行时错误。<br/>
      如果存在，此函数尝试以共享模式打开文件，如果成功则继续。<br/>
      如果访问被拒绝（例如，另一个进程正在独占使用该文件），NetErr() 将被设置为 TRUE。
    </param>
    <param name="cTargetFile">
      目标文件名，可包含可选的驱动器、目录和扩展名。<br/>
      &#0009;如果 <paramref name="cTargetFile" /> 不存在，将创建它。<br/>
      如果存在，此函数尝试以独占模式打开文件，如果成功，文件将被覆盖，不会发出警告或错误。<br/>
      如果访问被拒绝（例如，另一个进程正在使用该文件），NetErr() 将被设置为 TRUE。<br/>
      &#0009;有关文件搜索和创建规则，请参见 SetDefault() 和 SetPath()。<br/>
      此函数不为任何文件名提供默认扩展名。<br/>
      &#0009;<paramref name="cTargetFile" /> 也可以是目标设备的名称，指定时不带尾随冒号。当您指定以下设备名之一时：PRN、LPT1、LPT2、LPT3、COM1 或 COM2，FCopy() 会在 Windows 注册表中搜索用于打印设备的 Device 条目。<br/>
      如果没有 Device 条目，它会查找 Devices 条目并向用户显示一个设备列表框供选择。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      FCopy() 是 COPY FILE 命令的函数形式。
    </remarks>
    <example>
      此示例将文件从默认驱动器和目录复制到 D 驱动器上的 MYDIR 目录：
      <code language="X#">? FCopy("thisfile.txt",; "d:\mydir\thisfile.txt")</code>
    </example>
    <seealso >COPY FILE</seealso>
    <!--<seealso href="XSharp.chm::/command_copy_file.html" >COPY FILE</seealso>
    <seealso href="ms-its:XSharp.chm::/command_copy_file.html" >COPY FILE</seealso>
    <seealso href="MSITStore:XSharp.chm::/command_copy_file.html" >COPY FILE</seealso>
    <seealso href="mk:@ms-its:XSharp.chm::/command_copy_file.html" >COPY FILE</seealso>
    <seealso href="mk:MSITStore::XSharp.chm::/command_copy_file.html" >COPY FILE</seealso>-->
    <seealso cref='O:XSharp.Core.Functions.DiskSpace'>DiskSpace</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDefault'>SetDefault</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPath'>SetPath</seealso>
  </fcopy>

  <fcount>
    <summary>
      返回当前数据库文件中的字段数量。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      如果没有打开的数据库文件，FCount() 返回 0。
    </returns>
    <remarks>
      FCount() 在包含可操作任何数据库文件的数据独立程序的应用程序中很有用。<br/>
      这包括通用的导入/导出和报告程序。通常，您可以使用 FCount() 来设置 FOR...NEXT 或 DO WHILE 循环的上限，以一次处理一个字段。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      此示例使用 FCount() 返回当前和未选择工作区的字段数：
      <code language="X#">
        USE Sales NEW
        USE Customer NEW
        ? FCount()&#0009;&#0009;&#0009;&#0009;&#0009;// 结果: 5
        ? Sales -&gt;(FCount())&#0009;&#0009;&#0009;// 结果: 8
      </code>
      此示例使用 FCount() 声明一个包含字段信息的数组：
      <code language="X#">
        LOCAL aFields := ARRAY(FCount())
        AFields(aFields)
      </code>
      此示例使用 FCount() 作为 FOR 循环的上界，处理当前工作区字段列表：
      <code language="X#">
        LOCAL nField
        USE Sales NEW
        FOR nField := 1 UPTO FCount()
        &#0009;? FIELDNAME(nField)
        NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AFields'>AFields</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldName'>FieldName</seealso>
    <seealso cref='O:XSharp.RT.Functions.Type'>Type</seealso>
  </fcount>

  <fcreate>
    <summary>
      创建文件或打开并截断现有文件。
    </summary>
    <param name="cFileName">
      要创建的文件名，包括可选的驱动器、目录和扩展名。忽略 SetDefault() 和 SetPath() 设置；除非您在文件名中指定驱动器和目录，否则使用 Windows 默认设置。不假定任何扩展名。<br/>
      如果文件已存在，其长度将被截断为 0，且不会发出警告。<br/>
      &#0009;在并发控制冲突的情况下，此函数会设置 NetErr()。
    </param>
    <param name="kAttributes">
      以下常量之一，指示创建文件时要设置的属性：<br/>
      &#0009;常量&#0009;描述<br/>
      &#0009;FC_ARCHIVED&#0009;已归档文件<br/>
      &#0009;FC_HIDDEN&#0009;隐藏文件<br/>
      &#0009;FC_NORMAL&#0009;普通读/写文件<br/>
      &#0009;FC_READONLY&#0009;只读文件<br/>
      &#0009;FC_SYSTEM&#0009;系统文件&#0009;
    </param>
    <returns>
      新文件的 DOS 文件句柄号。<br/>
      如果发生错误，FCreate() 返回 F_ERROR。可以使用 FError() 确定具体错误。
    </returns>
    <remarks>
      FCreate() 是一个低级文件函数，可以创建新文件或打开现有文件并将其截断为 0 长度。<br/>
      如果 <paramref name="cFileName" /> 不存在，则创建并打开它以进行写入。<br/>
      如果文件存在且可以打开进行写入，则将其截断为 0 长度。
      当 FCreate() 成功创建新文件时，文件以兼容共享模式和读/写访问模式保持打开状态。<br/>
      <paramref name="nAttribute" /> 指定的文件属性在文件关闭时应用于新文件，允许您写入新创建的只读文件。<br/>
      有关访问模式的列表，请参见 FOpen()。
      由于其他文件函数需要文件句柄来识别打开的文件，因此始终将 FCreate() 的返回值分配给变量以供后续使用。
    </remarks>
    <example>
      此示例创建一个名为 TESTFILE 的文件并打开它以进行读写：
      <code language="X#">
        IF (ptrHandle := FCreate("testfile")) = F_ERROR
        &#0009;? DOSErrString(FError())
        ELSE
        &#0009;FWrite(ptrHandle, "你好")
        &#0009;FClose(ptrHandle)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate2'>FCreate2</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
  </fcreate>

  <fcreate2>
    <summary>
      创建文件或打开并截断现有文件，指定两个强类型参数。
    </summary>
    <param name="cFileName">
      要创建的文件名，包括可选的驱动器、目录和扩展名。忽略 SetDefault() 和 SetPath() 设置；除非您在文件名中指定驱动器和目录，否则使用 Windows 默认设置。不假定任何扩展名。<br/>
      如果文件已存在，其长度将被截断为 0，且不会发出警告。<br/>
      &#0009;在并发控制冲突的情况下，此函数会设置 NetErr()。
    </param>
    <param name="dwAttributes">
      以下常量之一，指示创建文件时要设置的属性：<br/>
      &#0009;常量&#0009;描述<br/>
      &#0009;FC_ARCHIVED&#0009;已归档文件<br/>
      &#0009;FC_HIDDEN&#0009;隐藏文件<br/>
      &#0009;FC_NORMAL&#0009;普通读/写文件<br/>
      &#0009;FC_READONLY&#0009;只读文件<br/>
      &#0009;FC_SYSTEM&#0009;系统文件&#0009;
    </param>
    <returns>
      新文件的 DOS 文件句柄号。<br/>
      如果发生错误，FCreate2() 返回 F_ERROR。可以使用 FError() 确定具体错误。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例创建一个名为 TESTFILE.TXT 的文件并打开它以进行读写：
      <code language="X#">
        ptrHandle := FCreate2("testfile.txt", FC_NORMAL)
        IF ptrHandle = F_ERROR
        &#0009;? DOSErrString(FError())
        ELSE
        &#0009;FWrite(ptrHandle, "你好")
        &#0009;FClose(ptrHandle)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
  </fcreate2>

  <fdate>
    <summary>
      返回由 FFCount()、FFirst() 或 FNext() 找到的文件的日期戳。
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 FDate() 来查找文件最后更新的时间：
      <code language="X#">
        // 查找第一个匹配 *.txt 的文件
        IF FFirst("*.txt", FC_NORMAL)
        &#0009;? FDate()&#0009;&#0009;&#0009;&#0009;&#0009;// 08/13/98
        ENDIF
        // 下一个匹配 *.txt 的文件
        IF FNext()&#0009;&#0009;&#0009;&#0009;
        &#0009;? FDate()&#0009;&#0009;&#0009;&#0009;&#0009;// 08/21/98
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFCount'>FFCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFirst'>FFirst</seealso>
    <seealso cref='O:XSharp.Core.Functions.FName'>FName</seealso>
    <seealso cref='O:XSharp.Core.Functions.FNext'>FNext</seealso>
    <seealso cref='O:XSharp.Core.Functions.FSize'>FSize</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTime'>FTime</seealso>
  </fdate>

  <feof>
    <summary>
      确定文件指针是否位于文件末尾。
    </summary>
    <param name="ptrHandle">打开文件的句柄。</param>
    <returns>
      如果文件指针位于文件末尾，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例在尝试移动101字节后检查是否到达文件末尾：
      <code language="X#">
        LOCAL ptrHandle AS PTR
        ptrHandle := FOpen("docu.txt")
        FSeek(ptrHandle, 101)
        ? FEOF(ptrHandle)
      </code>
      此示例一次读取一行，直到到达文件末尾：
      <code language="X#">
        ptrHandle := FOpen2("docs.txt", FO_READ)
        IF ptrHandle != F_ERROR
        &#0009;DO WHILE !FEOF(ptrHandle)
        &#0009;&#0009;? FReadLine2(ptrHandle, 80)
        &#0009;ENDDO
        ENDIF
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTell'>FTell</seealso>
  </feof>

  <ferase>
    <summary>
      从磁盘删除文件。
    </summary>
    <param name="cFileName">文件名，包括可选的驱动器、目录和扩展名。忽略 SetDefault() 和 SetPath() 设置；除非您在文件名中指定驱动器和目录，否则使用 Windows 默认设置。不假定任何扩展名。</param>
    <returns>
      如果操作成功，则返回 TRUE；否则返回 FALSE。如果失败，可以使用 FError() 确定具体错误。
    </returns>
    <remarks>
      FErase() 与 ERASE 命令相同，但会返回一个值，并且可以在表达式中指定。
      警告！在使用 FErase() 删除文件之前，必须先关闭文件。
    </remarks>
    <example>
      此示例删除匹配通配符模式的一组文件：
      <code language="X#">
        AEval(Directory("*.bak"), {|aFile|;
        &#0009;&#0009;&#0009;&#0009;FErase(aFile[F_NAME])})
      </code>
      此示例删除一个文件，如果操作失败则显示消息：
      <code language="X#">
        IF .NOT. FErase("afile.txt")
        &#0009;? DOSErrString(FError())
        ENDIF
      </code>
    </example>
    <seealsocmd>CLOSE</seealsocmd>
    <seealsocmd>ERASE</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FRename'>FRename</seealso>
  </ferase>

  <ferror>
    <summary>
      获取或设置文件操作的错误代码。
    </summary>
    <param name="nError">
      要设置 FError() 的后续错误代码。<br/>
      以下是 X# 使用的附加错误代码：
    </param>
    <param name="Error">含义&#0009;</param>
    <param name="256">磁盘已满&#0009;</param>
    <param name="257">尝试读取时已经到达文件末尾&#0009;</param>
    <returns>
      上次文件操作的错误或上次用户指定的设置。<br/>
      如果没有错误，FError() 返回 0。
    </returns>
    <remarks>
      FError() 是一个低级文件函数，用于指示使用文件函数后的错误。<br/>
      这些函数包括 FClose()、FCreate()、FErase()、FOpen()、FRead()、FReadStr() 和 FRename()。FError() 保留其值，直到下一次执行文件函数。
    </remarks>
    <example>
      此示例在创建文件后测试 FError()，如果创建失败则显示错误消息：
      <code language="X#">
        ptrHandle := FCreate("temp.txt", FC_NORMAL)
        IF ptrHandle == F_ERROR
        &#0009;? FError()
        &#0009;? DOSErrString(FError())
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.DosError'>DOSError</seealso>
    <seealso cref='O:XSharp.Core.Functions.DosErrString'>DOSErrString</seealso>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FErase'>FErase</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.FRename'>FRename</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.GetDosError'>GetDOSError</seealso>
  </ferror>

  <ffcount>
    <summary>
      返回与给定文件规范和属性匹配的文件数量。
    </summary>
    <param name="pszFileSpec">
      要包含的文件名，包括可选的驱动器、目录和扩展名。<br/>
      文件名和扩展名可以包含标准通配符（* 和 ?）。<br/>
      如果省略驱动器和目录，则使用 Windows 默认值。
    </param>
    <param name="dwAttributes">
      以下一个或多个常量，指示要与 <paramref name="pszFileSpec" /> 一起用作搜索条件的文件属性：<br/>
      <br/>
      &#0009;常量&#0009;描述<br/>
      &#0009;FA_DIRECTORY&#0009;目录<br/>
      &#0009;FA_VOLUME&#0009;卷<br/>
      &#0009;FC_HIDDEN&#0009;隐藏<br/>
      &#0009;FC_NORMAL&#0009;可见<br/>
      &#0009;FC_SYSTEM&#0009;系统<br/>
      &#0009;要指定多个常量，可以将属性相加，如 FC_SYSTEM + FC_HIDDEN，或使用 _Or() 运算符，如 _Or(FC_SYSTEM, FC_HIDDEN)。<br/>
      &#0009;<paramref name="dwAttributes" /> 指定除与 <paramref name="pszFileSpec" /> 匹配的任何"可见"文件之外要满足的条件。可见文件不包括目录、卷或隐藏或系统文件 — 所有其他文件都是可见的，无论其读取或存档属性的状态如何。<br/>
      要仅包含可见文件，请使用 FC_NORMAL 作为 <paramref name="dwAttributes" /> 参数。<br/>
      &#0009;注意：要仅指定卷标，排除所有其他文件，请将 FA_VOLUME 指定为唯一的 <paramref name="dwAttributes" /> 参数。
    </param>
    <returns>
      匹配指定条件的文件数量。<br/>
      如果未找到匹配项，则返回零。
    </returns>
    <remarks>
      FFCount() 还会找到与指定条件匹配的第一个文件。<br/>
      因此，在 FFCount() 之后不需要立即调用 FFirst()。相反，可以使用其他相关函数（如 FName()、FSize()、FAttrib()、FTime() 或 FDate()）检索有关第一个匹配文件的必要信息，然后调用 FNext() 移动到下一个文件。<br/>
      下面的示例说明了这种技术。
    </remarks>
    <example>
      此示例使用 FFCount() 与 FNext() 和 FName() 结合，显示所有与 "C:\DOCS\*.TXT" 匹配的文件：
      <code language="X#">
        dwMatches := FFCount("c:\docs\*.txt", FC_NORMAL)
        FOR i:= 1 UPTO dwMatches
        &#0009;? FName()
        &#0009;FNext()
        NEXT
      </code>
      此示例说明了 <paramref name="dwAttributes" /> 参数的用法，将文件搜索扩展到包括隐藏文件和目录以及可见文件：
      <code language="X#">
        dwCnt := FFCount("c:\i*.*", FC_HIDDEN + FA_DIRECTORY)
        FOR i:= 1 UPTO dwCnt
        &#0009;? FName()
        &#0009;FNext()
        NEXT
      </code>
    </example>
    <seealsocmd>_Or</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
    <seealso cref='O:XSharp.RT.Functions.FCount'>FCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.FDate'>FDate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFirst'>FFirst</seealso>
    <seealso cref='O:XSharp.Core.Functions.FName'>FName</seealso>
    <seealso cref='O:XSharp.Core.Functions.FNext'>FNext</seealso>
    <seealso cref='O:XSharp.Core.Functions.FSize'>FSize</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTime'>FTime</seealso>
    <seealso cref='O:XSharp.Core.Functions.GetFAttr'>GetFAttr</seealso>
    <seealso cref='O:XSharp.Core.Functions.GetFMask'>GetFMask</seealso>
  </ffcount>

  <ffirst>
    <summary>
      查找与给定文件规范或属性匹配的第一个文件。
    </summary>
    <param name="pszFileSpec">
      搜索的文件规范。除文件名外，此规范还可以包含可选的驱动器、目录和扩展名。<br/>
      文件名和扩展名可以包含标准通配符（* 和 ?）。<br/>
      如果省略驱动器和目录，则使用 Windows 默认值。
    </param>
    <param name="kAttributes">
      以下一个或多个常量，指示要与 <paramref name="pszFileSpec" /> 一起用作搜索条件的文件属性：<br/>
      &#0009;常量&#0009;描述<br/>
      &#0009;FA_DIRECTORY&#0009;目录<br/>
      &#0009;FA_VOLUME&#0009;卷<br/>
      &#0009;FC_HIDDEN&#0009;隐藏<br/>
      &#0009;FC_NORMAL&#0009;可见<br/>
      &#0009;FC_SYSTEM&#0009;系统<br/>
      &#0009;要指定多个常量，可以将属性相加，如 FC_SYSTEM + FC_HIDDEN，或使用 _Or() 运算符，如 _Or(FC_SYSTEM, FC_HIDDEN)。<br/>
      &#0009;<paramref name="kAttributes" /> 指定除与 <paramref name="pszFileSpec" /> 匹配的任何"可见"文件之外要满足的条件。可见文件不包括目录、卷或隐藏或系统文件 — 所有其他文件都是可见的，无论其读取或存档属性的状态如何。<br/>
      要仅包含可见文件，请使用 FC_NORMAL 作为 <paramref name="kAttributes" /> 参数。<br/>
      &#0009;注意：要仅指定卷标，排除所有其他文件，请将 FA_VOLUME 指定为唯一的 <paramref name="kAttributes" /> 参数。
    </param>
    <returns>
      如果找到匹配项，则为 TRUE；否则为 FALSE。
    </returns>
    <remarks>
      FFirst() 获取第一个匹配的文件；使用 FNext() 查找后续匹配的文件。
      FFCount() 返回匹配数。FAttrib()、FDate()、FName()、FSize() 和 FTime() 分别返回匹配文件的属性、日期戳、名称、大小和时间戳。
    </remarks>
    <example>
      此示例使用 FFirst() 查找文件：
      <code language="X#">
        IF FFirst("c:\docs\*.txt", FC_NORMAL)
        &#0009;? "找到了一个文件"
        ELSE
        &#0009;? "未找到文件"
        ENDIF
      </code>
      此示例说明了 <paramref name="kAttributes" /> 参数的用法，将文件搜索扩展到包括隐藏文件和目录以及可见文件：
      <code language="X#">
        IF FFirst("c:\i*.*", FC_HIDDEN + FA_DIRECTORY)
        &#0009;? "找到了一个文件"
        ELSE
        &#0009;? "未找到文件"
        ENDIF
      </code>
    </example>
    <seealsocmd>_Or</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
    <seealso cref='O:XSharp.Core.Functions.FDate'>FDate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFCount'>FFCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.FName'>FName</seealso>
    <seealso cref='O:XSharp.Core.Functions.FNext'>FNext</seealso>
    <seealso cref='O:XSharp.Core.Functions.FSize'>FSize</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTime'>FTime</seealso>
    <seealso cref='O:XSharp.Core.Functions.GetFAttr'>GetFAttr</seealso>
    <seealso cref='O:XSharp.Core.Functions.GetFMask'>GetFMask</seealso>
  </ffirst>

  <fflock>
    <summary>
      锁定已打开文件的一部分。
    </summary>
    <param name="ptrHandle">要锁定的已打开文件的句柄。</param>
    <param name="offset">
      开始锁定的文件偏移量。<br/>
      值为零对应文件的第一个字节。
    </param>
    <param name="length">要锁定的字节数。</param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      FFLock() 锁定文件的指定部分。<br/>
      这可以防止其他进程访问该部分。
      可以锁定文件的多个部分，但同一个字节不应被锁定多次。<br/>
      还可以锁定超出文件末尾的部分。<br/>
      这允许您在多用户环境中追加文件。
    </remarks>
    <example>
      此示例使用 FFLock() 锁定文件中从偏移量 300 开始的 100 个字节：
      <code language="X#">
        ptrHandle := FOpen2("c:\data\myfile.txt", ;
        &#0009;&#0009;FO_READWRITE + FO_SHARED)
        IF FFLock(ptrHandle, 300, 100)
        &#0009;? "锁定成功"
        ENDIF
      </code>
      此示例实现了一个带有可选重试的 FFLock()：
      <code language="X#">
        FUNCTION FileLock(ptrHandle AS PTR,;
        &#0009;&#0009;dwOffset AS DWORD, dwLength AS DWORD,;
        &#0009;&#0009;wSeconds AS DWORD) AS LOGIC PASCAL
        &#0009;LOCAL lForever AS LOGIC
        &#0009;IF FFLock(ptrHandle, dwOffset, dwLength)
        &#0009;&#0009;RETURN TRUE&#0009;&#0009;&#0009;// 已锁定
        &#0009;ENDIF
        &#0009;// 如果 wSeconds 为零，则重试直到成功
        &#0009;lForever := (wSeconds = 0)
        &#0009;DO WHILE (lForever .OR. wSeconds &gt; 0)
        &#0009;&#0009;IF FFLock(ptrHandle, dwOffset, dwLength)
        &#0009;&#0009;&#0009;RETURN TRUE&#0009;// 已锁定
        &#0009;&#0009;ENDIF
        &#0009;&#0009;InKey(.5)&#0009;&#0009;&#0009;// 等待
        &#0009;&#0009;nSeconds -= 1
        &#0009;ENDDO
        &#0009;RETURN FALSE&#0009;&#0009;&#0009;&#0009;// 未锁定
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FFUnLock'>FFUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
  </fflock>

  <fflush>
    <summary>
      将使用低级文件函数打开的文件刷新到磁盘。
    </summary>
    <param name="ptrHandle">要刷新的打开文件的句柄。</param>
    <param name="lCommit">当此参数传入 TRUE 时，所有中间缓冲区也会被刷新。</param>
    <returns>
    </returns>
    <remarks>
      FFlush() 将缓冲区写入磁盘，从而释放这些缓冲区使用的内存。<br/>
      如果在多用户或多任务环境中共享文件，FFlush() 允许每个用户看到文件的最新内容。
      通过从内存中刷新数据，FFlush() 还可以防止系统崩溃可能导致的数据丢失。
      使用 2 个参数调用该方法，且第二个参数值为 TRUE 时，将显著降低应用程序的速度！
      使用 1 个参数调用的效果与调用 FFlush() 并为第二个参数传入 FALSE 值相同。
    </remarks>
    <example>
      此示例使用 FFlush() 在等待按键后自动刷新数据：
      <code language="X#">
        ptrHandle := FOpen2("docs.txt", ;
        &#0009;&#0009;FO_READWRITE + FO_SHARED)
        IF ptrHandle != F_ERROR
        &#0009;FWrite(ptrHandle, Space(100))&#0009;
        &#0009;nKey := Inkey(50)
        &#0009;FFlush(ptrHandle)&#0009;&#0009;&#0009;// 保存数据
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FCommit'>FCommit</seealso>
  </fflush>

  <ffunlock>
    <summary>
      解锁已打开文件的一部分。
    </summary>
    <param name="ptrHandle">要解锁的已打开文件的句柄。</param>
    <param name="offset">开始解锁的文件偏移量。</param>
    <param name="length">要解锁的字节数。</param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      FFUnLock() 解锁文件的指定部分。<br/>
      这允许其他进程访问该部分。<br/>
      被解锁的部分必须之前已被锁定。
    </remarks>
    <example>
      此示例使用 FFLock() 和 FFUnLock() 锁定然后解锁文件的前 300 个字节：
      <code language="X#">
        ptrHandle := FOpen2("c:\data\myfile.txt", ;
        &#0009;&#0009;FO_READWRITE + FO_SHARED)
        IF FFLock(ptrHandle, 0, 300)
        &#0009;? "锁定成功"
        &#0009;IF FFUnLock(ptrHandle, 0, 300)
        &#0009;&#0009;? "解锁成功"
        &#0009;ENDIF
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FFLock'>FFLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
  </ffunlock>

  <fgets>
    <summary>
      从打开的文件中读取一行。
    </summary>
    <param name="ptrHandle">要读取的文件句柄。</param>
    <param name="nMax">
      每行读取的最大字符数。FGets() 将读取直到遇到硬回车（Chr(13)）、到达文件末尾或读取了 <paramref name="nMax" /> 个字符。<br/>
      <paramref name="nMax" /> 的默认值为 256。
    </param>
    <returns>
      读取的行。当到达文件末尾时，FGets() 返回 NULL_STRING，并且 FError() 被设置为 257。
    </returns>
    <remarks>
      此函数与 FReadLine() 相同。这两个函数都假定处理原始二进制数据，并且不依赖于 SetAnsi() 的状态。而 FReadText() 和 FRead4() 则依赖于 SetAnsi()。
    </remarks>
    <example>
      此示例使用 FGets() 读取整个文件，而不指定 <paramref name="nMax" /> 的值：
      <code language="X#">
        ptrHandle := FOpen2("docs.txt", FO_READ)
        IF ptrHandle != F_ERROR
        &#0009;DO WHILE !FEOF(ptrHandle)
        &#0009;&#0009;? FGets(ptrHandle)
        &#0009;ENDDO
        ENDIF
        FClose(ptrHandle)
      </code>
      以下示例提供了一个实用程序，用于显示并计算文件中字符串的所有出现次数：
      <code language="X#">
        FUNCTION Grep(cSearch, cFile AS STRING) ;
        &#0009;&#0009;AS DWORD PASCAL
        &#0009;LOCAL handle AS PTR
        &#0009;LOCAL Count AS DWORD
        &#0009;LOCAL Line AS STRING
        &#0009;handle := FOpen2(cFile, FO_READ)
        &#0009;cSearch := Upper(cSearch)
        &#0009;DO WHILE !FEOF(handle)
        &#0009;&#0009;line := Upper(FGets(handle))
        &#0009;&#0009;IF InStr(cSearch, line)
        &#0009;&#0009;&#0009;? line
        &#0009;&#0009;&#0009;Count += 1
        &#0009;&#0009;ENDIF
        &#0009;ENDDO
        &#0009;RETURN Count
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FGetS2'>FGets2</seealso>
    <seealso cref='O:XSharp.RT.Functions.FReadLine'>FReadLine</seealso>
  </fgets>

  <fgets2>
    <summary>
      从打开的文件中读取一行，指定两个强类型参数。
    </summary>
    <param name="ptrHandle">要读取的文件句柄。</param>
    <param name="dwMax">
      每行读取的最大字符数。FGets2() 将读取直到遇到硬回车（Chr(13)），到达文件末尾，或读取了 <paramref name="dwMax" /> 个字符。<br/>
      <paramref name="dwMax" /> 的默认值为 256。
    </param>
    <returns>
      读取的行。当到达文件末尾时，FGets2() 返回 NULL_STRING，并且 FError() 被设置为 257。
    </returns>
    <remarks>
      此函数与 FReadLine2() 相同。这两个函数都假定处理原始二进制数据，并且不依赖于 SetAnsi() 的状态。而 FReadText() 和 FRead4() 则依赖于 SetAnsi()。
    </remarks>
    <example>
      此示例使用 FGets2() 读取整个文件，每行最多80个字符：
      <code language="X#">
        ptrHandle := FOpen2("docs.txt", FO_READ)
        IF ptrHandle != F_ERROR
        &#0009;DO WHILE !FEOF(ptrHandle)
        &#0009;&#0009;? FGets2(ptrHandle, 80)
        &#0009;ENDDO
        ENDIF
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FGetS'>FGets</seealso>
    <seealso cref='O:XSharp.RT.Functions.FReadLine'>FReadLine</seealso>
  </fgets2>

  <fieldblock>
    <summary>
      返回一个用于通过名称标识的字段的设置-获取代码块。
    </summary>
    <param name="cFieldName">
      设置-获取块将引用的字段名称。当带参数执行时，此函数创建的代码块将参数的值赋给 <paramref name="cFieldName" />。<br/>
      如果省略参数，代码块将获取 <paramref name="cFieldName" /> 的值。
    </param>
    <returns>
      一个运行时代码块（实现为对象），当求值时，设置（赋值）或获取（检索）给定字段的值。<br/>
      如果 <paramref name="cFieldName" /> 在当前工作区不存在，FieldBlock() 返回 NULL_OBJECT。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      注意，指定的字段变量在创建代码块时不必存在，但必须在执行代码块之前存在。
      <note type="tip">
        工作区：<br/>
        FieldBlock() 返回的代码块在运行时设置或获取当前工作区中指定字段的值。<br/>
        例如，给定工作区1和2，都包含字段FName：
        <code language="X#">
          DBSetSelect(1)
          _FIELD-&gt;FName := "Kate"
          DBSetSelect(2)
          _FIELD-&gt;FName := "Cindy"
          cbFName := FieldBlock("FName")
          DBSetSelect(1)
          ? EVAL(cbFName)&#0009;&#0009;&#0009;&#0009;&#0009;// "Kate"
          DBSetSelect(2)
          ? EVAL(cbFName)&#0009;&#0009;&#0009;&#0009;&#0009;// "Cindy"
        </code>
        使用 FieldWBlock() 为特定工作区的字段提供设置-获取块。
      </note>
    </remarks>
    <example>
      此示例比较了 FieldBlock() 与使用宏运算符创建的代码块。注意，使用 FieldBlock() 避免了宏运算符的速度和大小开销：
      <code language="X#">
        // 使用宏运算符定义的设置-获取块
        cbSetGet := &amp;("{|SetVal| If(SetVal == NIL,;
        &#0009;&#0009;&#0009;&#0009;&#0009; FName, FName := SetVal)}")
        // 使用 FieldBlock() 定义的设置-获取块
        // 这里创建的 cbSetGet 在功能上
        // 等同于上面的 cbSetGet
        cbSetGet := FieldBlock("FName")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldBlockSym'>FieldBlockSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldWBlock'>FieldWBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarBlock'>MemVarBlock</seealso>
  </fieldblock>

  <fieldblocksym>
    <summary>
      返回一个用于通过符号标识的字段的设置-获取代码块。
    </summary>
    <param name="symFieldName">
      一个作为设置-获取块引用的字段名称的符号。当带参数执行时，此函数创建的代码块将参数的值赋给 <paramref name="symFieldName" />。<br/>
      如果省略参数，代码块将获取 <paramref name="symFieldName" /> 的值。
    </param>
    <returns>
      一个运行时代码块（实现为对象），当求值时，设置（赋值）或获取（检索）给定字段的值。<br/>
      如果 <paramref name="symFieldName" /> 在当前工作区不存在，FieldBlockSym() 返回 NULL_OBJECT。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      注意，指定的字段变量在创建代码块时不必存在，但必须在执行代码块之前存在。
      <note type="tip">
        工作区：<br/>
        FieldBlockSym() 返回的代码块在运行时设置或获取当前工作区中指定字段的值。<br/>
        例如，给定工作区1和2，都包含字段FName：
        <code language="X#">
          DBSetSelect(1)
          _FIELD-&gt;FName := "Kate"
          DBSetSelect(2)
          _FIELD-&gt;FName := "Cindy"
          cbFName := FieldBlockSym(#FNAME)
          DBSetSelect(1)
          ? EVAL(cbFName)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// "Kate"
          DBSetSelect(2)
          ? EVAL(cbFName)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// "Cindy"
        </code>
        使用 FieldWBlock() 为特定工作区的字段提供设置-获取块。
      </note>
    </remarks>
    <example>
      此示例比较了 FieldBlockSym() 与使用宏运算符创建的代码块。注意，使用 FieldBlockSym() 避免了宏运算符的速度和大小开销：
      <code language="X#">
        // 使用宏运算符定义的设置-获取块
        cbSetGet := &amp;("{|SetVal| If(SetVal == NIL, FName, FName := SetVal)}")
        // 使用 FieldBlockSym() 定义的设置-获取块
        String2Symbol("FName")
        cbSetGet := FieldBlockSym(#FNAME)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldBlock'>FieldBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldWBlock'>FieldWBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarBlock'>MemVarBlock</seealso>
  </fieldblocksym>

  <fieldget>
    <summary>
      获取由其位置标识的字段的内容。
    </summary>
    <param name="nFieldPos">当前工作区数据库文件结构中字段的位置。</param>
    <returns>
      指定字段的值。<br/>
      如果 <paramref name="nFieldPos" /> 不对应当前数据库文件中任何字段的位置，FieldGet() 将生成运行时错误。只有在 Xbase++ 方言中才会返回 NIL。
    </returns>
    <remarks>
      FieldGet() 使用字段在数据库文件结构中的位置而不是字段名称来检索字段的值。在通用数据库服务函数中，这允许（除其他功能外）在不使用宏运算符的情况下检索字段值。
      <note type="tip">
        FieldGet() 可以用于 BLOB 字段（即与 BLOB 文件关联的备注字段），前提是字段长度不超过 64 KB。<br/>
        对于长度超过 64 KB 的 BLOB 字段，请改用 BLOBGet() 函数。
      </note>
    </remarks>
    <example>
      此示例比较了 FieldGet() 与使用宏运算符检索字段值的功能等效代码：
      <code language="X#">
        LOCAL nFieldPos := 1, FName, FVal
        USE customer NEW
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 使用宏运算符
        FName := FIELDNAME(nFieldPos)&#0009;&#0009;&#0009;// 获取字段名
        FVal := &amp;FName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 获取字段值
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 使用 FieldGet()
        FVal := FieldGet(nFieldPos)&#0009;&#0009;&#0009;&#0009;// 获取字段值
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBGet'>BLOBGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetSym'>FieldGetSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPut'>FieldPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutSym'>FieldPutSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldGet'>VODBFieldGet</seealso>
  </fieldget>

  <fieldgetalias>
    <summary>
      获取由工作区别名和字段名标识的字段的内容。
    </summary>
    <param name="symAlias">工作区别名。</param>
    <param name="symFieldName">字段名。</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 FieldGetAlias() 查询两个工作区中字段的内容：
      <code language="X#">
        USE region1 NEW
        USE region2 NEW
        SELECT region1
        _FIELD-&gt;FName := "Kate"
        SELECT region2
        _FIELD-&gt;FName := "Cindy"
        QOut(FieldGetAlias(#REGION1, #FNAME))&#0009;// Kate
        QOut(FieldGetAlias(#REGION2, #FNAME))&#0009;// Cindy
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetArea'>FieldGetArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldGet'>VODBFieldGet</seealso>
  </fieldgetalias>

  <fieldgetarea>
    <summary>
      获取由工作区和符号标识的字段的内容。
    </summary>
    <param name="dwWorkArea">
      <paramref name="symFieldName" /> 所在的工作区。
    </param>
    <param name="symFieldName">对应字段名的符号。</param>
    <returns>
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      此示例使用 FieldGetArea()：
      <code language="X#">
        USE region1 NEW
        nSelect1 := VODBGetSelect()
        USE region2 NEW
        nSelect2 := VODBGetSelect()
        VODBSetSelect(nSelect1)
        _FIELD-&gt;FName := "Kate"
        VODBSetSelect(nSelect2)
        _FIELD-&gt;FName := "Cindy"
        // 下面这行打印 Kate
        ? FieldGetArea(nSelect1, #FNAME)
        // 下面这行打印 Cindy
        ? FieldGetArea(nSelect2, #FNAME)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldGet'>VODBFieldGet</seealso>
  </fieldgetarea>

  <fieldgetsym>
    <summary>
      通过符号名称获取字段内容。
    </summary>
    <param name="symField">当前工作区数据库文件结构中字段的符号名称。</param>
    <returns>
      指定字段的值。<br/>
      如果 <paramref name="symField" /> 不对应当前数据库文件中的字段，FieldGetSym() 返回 NIL。
    </returns>
    <remarks>
      FieldGetSym() 使用数据库文件结构中的符号字段名称而不是字符串表示来检索字段的值。
      注意：FieldGetSym() 可以用于 BLOB 字段（即与 BLOB 文件关联的备注字段），前提是字段长度不超过 64KB。<br/>
      对于长度超过 64KB 的 BLOB 字段，请改用 BLOBGet() 函数。
    </remarks>
    <example>
      此示例检索 TestDBF 数据库中 Lastname 字段的内容：
      <code language="X#">
        USE TestDBF NEW
        DO WHILE !EOF()
        &#0009;? FieldGetSym(#Lastname)&#0009;// Smith
        &#0009;Skip
        ENDDO
        USE
        WAIT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.BLOBGet'>BLOBGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutSym'>FieldPutSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldGet'>VODBFieldGet</seealso>
  </fieldgetsym>

  <fieldname>
    <summary>
      返回字段名称作为字符串。
    </summary>
    <param name="dwFieldPos">数据库文件结构中字段的位置。</param>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      指定字段的名称作为字符串。<br/>
      如果 <paramref name="dwFieldPos" /> 不对应数据库文件中的现有字段，或者没有打开数据库文件，FieldName() 返回 NULL_STRING。
    </returns>
    <remarks>
      FieldName() 使用数据库结构中字段名称的索引位置返回字段名。<br/>
      在字段名未知的数据独立应用程序中使用它。<br/>
      如果需要多个字段的信息，请使用 DBStruct()。
      如果需要额外的数据库文件结构信息，请使用 Type() 和 Len()。<br/>
      例如，要获取数值字段的小数位数，请使用以下表达式：
      <code language="X#">
        Len(Substr(Str(<paramref name="idField" />), RAt(".", Str(<paramref name="idField" />)) + 1))
      </code>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      这些示例展示了 FieldName() 与其他几个函数一起使用：
      <code language="X#">
        USE sales
        QOut(FIELDNAME(1))&#0009;&#0009;&#0009;&#0009;// 结果: BRANCH
        QOut(FCount())&#0009;&#0009;&#0009;&#0009;&#0009;// 结果: 5
        QOut(LEN(FIELDNAME(0)))&#0009;&#0009;&#0009;// 结果: 0
        QOut(LEN(FIELDNAME(40)))&#0009;&#0009;&#0009;// 结果: 0
      </code>
      此示例使用 FieldName() 列出 CUSTOMER.DBF 中每个字段的名称和类型：
      <code language="X#">
        USE customer NEW
        FOR nField := 1 UPTO FCount()
        &#0009;? FIELDNAME(nField), DBFieldInfo(DBS_TYPE, nField)
        NEXT
      </code>
      此示例使用别名表达式访问未选定工作区中的字段：
      <code language="X#">
        USE sales NEW
        USE customer NEW
        USE invoices NEW
        QOut(Sales-&gt;FIELDNAME(1))&#0009;&#0009;// 结果: SaleNum
        QOut(Customer-&gt;FIELDNAME(1))&#0009;&#0009;// 结果: CustNum
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbStruct'>DBStruct</seealso>
    <seealso cref='O:XSharp.RT.Functions.FCount'>FCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldSym'>FieldSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.RT.Functions.Type'>Type</seealso>
    <seealso cref='O:XSharp.RT.Functions.ValType'>ValType</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldInfo'>VODBFieldInfo</seealso>
  </fieldname>

  <fieldpos>
    <summary>
      返回字段的位置。
    </summary>
    <param name="cFieldName">字段的名称。</param>
    <param name="nArea">
      指定表的工作区号。
    </param>
    <returns>
      指定字段在与工作区关联的字段列表中的位置。<br/>
      如果工作区没有指定名称的字段，FieldPos() 返回 0。
    </returns>
    <remarks>
      FieldPos() 是 FieldName() 函数的反函数。FieldPos() 最常与 FieldPut() 和 FieldGet() 函数一起使用。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      此示例演示了 FieldPos() 函数的典型用法：
      <code language="X#">
        USE customer NEW
        QOut(FIELDPOS("Name"))&#0009;&#0009;&#0009;&#0009;&#0009;// 结果: 1
        QOut(FieldGet(FIELDPOS("Name")))&#0009;&#0009;&#0009;// 结果: Kate
      </code>
      此示例使用 FieldPos() 返回未选定工作区中指定字段的位置：
      <code language="X#">
        USE customer NEW
        USE invoices NEW
        QOut(Customer-&gt;FIELDPOS("Name"))&#0009;&#0009;&#0009;// 结果: 1
        QOut(Customer-&gt;FieldGet(FIELDPOS("Name")))&#0009;// 结果: Kate
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.CharPos'>CharPos</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldName'>FieldName</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPosSym'>FieldPosSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPut'>FieldPut</seealso>
  </fieldpos>

  <fieldpossym>
    <summary>
      返回由符号标识的字段的位置。
    </summary>
    <param name="sFieldName">对应字段名称的符号。</param>
    <returns>
      指定字段在与工作区关联的字段列表中的位置。<br/>
      如果工作区没有指定名称的字段，FieldPosSym() 返回 0。
    </returns>
    <remarks>
      FieldPosSym() 是 FieldName() 函数的反函数。FieldPosSym() 最常与 FieldPut() 和 FieldGet() 函数一起使用。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      此示例演示了 FieldPosSym() 函数的典型用法：
      <code language="X#">
        USE customer NEW
        QOut(FieldPosSym(#Name))&#0009;&#0009;&#0009;&#0009;// 结果: 1
        QOut(FieldGet(FieldPosSym(#NAME)))&#0009;&#0009;&#0009;// 结果: Kate
      </code>
      此示例使用 FieldPosSym() 返回未选定工作区中指定字段的位置：
      <code language="X#">
        USE customer NEW
        USE invoices NEW
        QOut(Customer-&gt;FieldPosSym(#Name))&#0009;&#0009;&#0009;// 结果: 1
        QOut(Customer-&gt;FieldGet(FieldPosSym(#Name)))&#0009;// 结果: Kate
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPos'>FieldPos</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPut'>FieldPut</seealso>
  </fieldpossym>

  <fieldput>
    <summary>
      通过位置设置字段的值。
    </summary>
    <param name="nFieldPos">字段在数据库文件结构中的位置。</param>
    <param name="uNewValue">
      要赋给字段的值。<br/>
      此表达式的数据类型必须与字段的数据类型匹配。
    </param>
    <returns>
      赋给字段的值。
      如果 <paramref name="nFieldPos" /> 不对应数据库文件中任何字段的位置，FieldPut() 将生成错误。
      例外情况是在 XBase++ 方言中，无效的 <paramref name="nFieldPos" /> 不会生成异常，而是返回 NIL。
    </returns>
    <remarks>
      FieldPut() 允许您使用字段在数据库文件结构中的位置而不是字段名来设置字段的值。在通用数据库服务函数中，这允许（除其他外）在不使用宏运算符的情况下设置字段值。
      注意：FieldPut() 可用于 BLOB 字段（即与 BLOB 文件关联的备注字段），前提是字段长度不超过 64 KB。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      共享模式：<br/>
      对于共享数据库，此函数需要记录锁定。
    </remarks>
    <example>
      此示例比较了 FieldPut() 与使用宏运算符设置字段值的功能等效代码：
      <code language="X#">
        // 使用宏运算符
        FName := FIELDNAME(nFieldPos)&#0009;&#0009;&#0009;&#0009;// 获取字段名
        _FIELD-&gt;&amp;FName := FVal&#0009;&#0009;&#0009;&#0009;&#0009;// 设置字段值
        // 使用 FieldPut()
        FieldPut(nFieldPos, FVal)&#0009;&#0009;&#0009;&#0009;&#0009;// 设置字段值
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetSym'>FieldGetSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutSym'>FieldPutSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldPut'>VODBFieldPut</seealso>
  </fieldput>

  <fieldputalias>
    <summary>
      设置由工作区别名和字段名标识的字段的值。
    </summary>
    <param name="symAlias">
      <paramref name="symField" /> 所在的工作区别名。
    </param>
    <param name="symField">字段名。</param>
    <param name="uNewValue">
      要赋给字段的值。<br/>
      此表达式的数据类型必须与字段的数据类型匹配。
    </param>
    <returns>
      赋给字段的值。<br/>
      如果 <paramref name="symField" /> 不对应 <paramref name="symAlias" /> 指定的工作区中的任何字段，FieldPutAlias() 返回 NIL。
    </returns>
    <remarks>
      此函数允许您使用指定字段名的符号来设置字段的值。在通用数据库服务函数中，这允许（除其他外）在不使用宏运算符的情况下设置字段值。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      共享模式：<br/>
      对于共享数据库，此函数需要记录锁定。
    </remarks>
    <example>
      此示例使用 FieldPutAlias() 在两个不同的工作区中设置字段值：
      <code language="X#">
        USE region1 NEW
        USE region2 NEW
        FieldPutAlias(#REGION1, #FNAME, "Kate")
        FieldPutAlias(#REGION2, #FNAME, "Cindy")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetAlias'>FieldGetAlias</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPut'>FieldPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutArea'>FieldPutArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutSelect'>FieldPutSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldPut'>VODBFieldPut</seealso>
  </fieldputalias>

  <fieldputselect>
    <summary>
      通过工作区别名和字段名设置字段的值。
    </summary>
    <param name="symAlias">
      <paramref name="symField" /> 所在的工作区别名。
    </param>
    <param name="symField">字段名。</param>
    <param name="uNewValue">
      要赋给字段的值。<br/>
      此表达式的数据类型必须与字段的数据类型匹配。
    </param>
    <returns>
      赋给字段的值。<br/>
      如果 <paramref name="symField" /> 不对应 <paramref name="symAlias" /> 指定的工作区中的任何字段，FieldPutAlias() 返回 NIL。
    </returns>
    <remarks>
      此函数允许您使用指定字段名的符号来设置字段的值。在通用数据库服务函数中，这允许（除其他外）在不使用宏运算符的情况下设置字段值。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      共享模式：<br/>
      对于共享数据库，此函数需要记录锁定。
    </remarks>
    <example>
      此示例使用 FieldPutSelect() 在两个不同的工作区中设置字段值：
      <code language="X#">
        USE region1 NEW
        USE region2 NEW
        FieldPutSelect(#REGION1, #FNAME, "Kate")
        FieldPutSelect(#REGION2, #FNAME, "Cindy")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetAlias'>FieldGetAlias</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPut'>FieldPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutAlias'>FieldPutAlias</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutArea'>FieldPutArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldPut'>VODBFieldPut</seealso>
  </fieldputselect>

  <fieldputarea>
    <summary>
      通过工作区号和字段名设置字段的值。
    </summary>
    <param name="dwWorkArea">
      <paramref name="symField" /> 所在的工作区。
    </param>
    <param name="symField">字段名。</param>
    <param name="uNewValue">
      要赋给字段的值。<br/>
      此表达式的数据类型必须与字段的数据类型匹配。
    </param>
    <returns>
      赋给字段的值。<br/>
      如果 <paramref name="symField" /> 不对应 <paramref name="dwWorkArea" /> 指定的工作区中的任何字段，FieldPutArea() 返回 NIL。
    </returns>
    <remarks>
      FieldPutArea() 允许您使用指定字段名的符号来设置字段的值。在通用数据库服务函数中，这允许（除其他外）在不使用宏运算符的情况下设置字段值。
      共享模式：<br/>
      对于共享数据库，此函数需要记录锁定。
    </remarks>
    <example>
      此示例使用 FieldPutArea() 设置字段值：
      <code language="X#">
        USE sales NEW
        USE region1 NEW
        USE region2 NEW
        String2Symbol("FName")
        FieldPutArea(Select("region1"), #FNAME, "Kate")
        FieldPutArea(Select("region2"), #FNAME, "Cindy")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetArea'>FieldGetArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPut'>FieldPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldPut'>VODBFieldPut</seealso>
  </fieldputarea>

  <fieldputsym>
    <summary>
      通过符号名称设置字段的值。
    </summary>
    <param name="symField">当前工作区数据库文件结构中字段的符号名称。</param>
    <param name="uNewValue">
      要赋给字段的值。<br/>
      此表达式的数据类型必须与字段的数据类型匹配。
    </param>
    <returns>
      赋给字段的值。<br/>
      如果 <paramref name="symField" /> 不对应当前数据库文件中的字段，FieldPutSym() 返回 NIL。
    </returns>
    <remarks>
      FieldPutSym() 使用数据库文件结构中的符号字段名称而不是字符串表示来为字段赋新值。
      注意：FieldPutSym() 可以用于 BLOB 字段（即与 BLOB 文件关联的备注字段），前提是字段长度不超过 64KB。
    </remarks>
    <example>
      此示例为 TestDBF 数据库中的 Firstname 字段设置新值：
      <code language="X#">
        USE TestDBF NEW
        FieldPutSym(#Firstname, "Marijo")
        ? FieldGetSym(#Firstname)&#0009;&#0009;&#0009;// Marijo
        USE
        WAIT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldGetSym'>FieldGetSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPut'>FieldPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldGet'>VODBFieldGet</seealso>
  </fieldputsym>

  <fieldsym>
    <summary>
      返回字段名称作为符号。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <param name="dwFieldPos">字段在数据库文件结构中的位置。</param>
    <returns>
      指定字段的名称作为符号。<br/>
      如果 <paramref name="dwFieldPos" /> 不对应数据库文件中的现有字段，或者没有打开数据库文件，FieldSym() 返回 NULL_SYMBOL。
    </returns>
    <remarks>
      FieldSym() 使用数据库结构中字段名称的索引位置返回字段名称作为符号。<br/>
      在字段名称未知的数据独立应用程序中使用它。<br/>
      如果需要多个字段的信息，请使用 DBStruct()。
      如果需要额外的数据库文件结构信息，请使用 Type() 和 Len()。<br/>
      例如，要获取数值字段的小数位数，请使用以下表达式：
      <code language="X#">
        Len(Substr(Str(<paramref name="idField" />), RAt(".", Str(<paramref name="idField" />)) + 1))
      </code>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      这些示例演示了 FieldSym() 与其他几个函数一起使用：
      <code language="X#">
        USE sales
        QOut(FieldSym(1))&#0009;&#0009;&#0009;&#0009;// 结果: BRANCH
        QOut(FCount())&#0009;&#0009;&#0009;&#0009;&#0009;// 结果: 5
        QOut(LEN(FieldSym(0)))&#0009;&#0009;&#0009;// 结果: 0
        QOut(LEN(FieldSym(40)))&#0009;&#0009;&#0009;// 结果: 0
      </code>
      此示例使用 FieldSym() 列出 CUSTOMER.DBF 中每个字段的名称和类型：
      <code language="X#">
        USE customer NEW
        FOR nField := 1 UPTO FCount()
        &#0009;QOut(PadR(FieldSym(nField), 10),;
        &#0009;&#0009;&#0009;VALTYPE(&amp;(FieldSym(nField))))
        NEXT
      </code>
      此示例使用别名表达式访问未选定工作区中的字段：
      <code language="X#">
        USE sales NEW
        USE customer NEW
        USE invoices NEW
        QOut(Sales-&gt;FieldSym(1))&#0009;&#0009;&#0009;// 结果: Salenum
        QOut(Customer-&gt;FieldSym(1))&#0009;&#0009;// 结果: Custnum
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbStruct'>DBStruct</seealso>
    <seealso cref='O:XSharp.RT.Functions.FCount'>FCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldName'>FieldName</seealso>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.RT.Functions.Type'>Type</seealso>
    <seealso cref='O:XSharp.RT.Functions.ValType'>ValType</seealso>
  </fieldsym>

  <fieldwblock>
    <summary>
      返回指定工作区中以字符串指定的字段的设置-获取代码块。
    </summary>
    <param name="cFieldName">字段的名称。</param>
    <param name="dwWorkArea">字段所在的工作区号。</param>
    <returns>
      一个运行时代码块（实现为对象），当求值时，设置（赋值）或获取（检索）<paramref name="dwWorkArea" />指定工作区中<paramref name="cFieldName" />的值。<br/>
      如果<paramref name="cFieldName" />在指定工作区不存在，FieldWBlock()返回NULL_OBJECT。
    </returns>
    <remarks>
      FieldWBlock()构建一个代码块。当使用Evaluate()函数求值时，代码块首先选择指定的<paramref name="dwWorkArea" />。<br/>
      如果传递了参数，代码块随后将参数的值赋给<paramref name="cFieldName" />。<br/>
      如果没有传递参数，代码块检索<paramref name="cFieldName" />的值。<br/>
      在代码块返回控制权之前，原始工作区被重新选中。
      注意，指定的字段变量在创建代码块时不必存在，但必须在执行代码块之前存在。
    </remarks>
    <example>
      此示例比较了FieldWBlock()与使用宏运算符创建的代码块。注意，使用FieldWBlock()避免了宏运算符的速度和大小开销：
      <code language="X#">
        // 使用宏运算符定义的工作区1的设置-获取块
        cbSetGet := &amp;("{|SetVal| If(SetVal == NIL, ;
        &#0009;1-&gt;FName, 1-&gt;FName := SetVal)}")
        // 使用FieldWBlock()定义的设置-获取块
        // 这里创建的cbSetGet在功能上等同于上面的cbSetGet
        cbSetGet := FieldWBlock("FName", 1)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldBlock'>FieldBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldWBlockSym'>FieldWBlockSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarBlock'>MemVarBlock</seealso>
  </fieldwblock>

  <fieldwblocksym>
    <summary>
      返回指定工作区中以符号指定的字段的设置-获取代码块。
    </summary>
    <param name="symFieldname">字段的名称。</param>
    <param name="dwWorkArea">字段所在的工作区号。</param>
    <returns>
      一个运行时代码块（实现为对象），当求值时，设置（赋值）或获取（检索）<paramref name="dwWorkArea" />指定工作区中<paramref name="symFieldName" />的值。<br/>
      如果<paramref name="symFieldName" />在指定工作区不存在，FieldWBlockSym()返回NULL_OBJECT。
    </returns>
    <remarks>
      FieldWBlockSym()构建一个代码块。当使用Evaluate()函数求值时，代码块首先选择指定的<paramref name="dwWorkArea" />。<br/>
      如果传递了参数，代码块随后将参数的值赋给<paramref name="symFieldName" />。<br/>
      如果没有传递参数，代码块检索<paramref name="symFieldName" />的值。<br/>
      在代码块返回控制权之前，原始工作区被重新选中。
      注意，指定的字段变量在创建代码块时不必存在，但必须在执行代码块之前存在。
    </remarks>
    <example>
      此示例比较了FieldWBlockSym()与使用宏运算符创建的代码块。注意，使用FieldWBlockSym()避免了宏运算符的速度和大小开销：
      <code language="X#">
        // 使用宏运算符定义的工作区1的设置-获取块
        cbSetGet := &amp;("{|SetVal| If(SetVal == NIL, ;
        &#0009;1-&gt;FName, 1-&gt;FName := SetVal)}")
        // 使用FieldWBlockSym()定义的设置-获取块
        // 这里创建的cbSetGet在功能上等同于上面的cbSetGet
        cbSetGet := FieldWBlockSym(#FName, 1)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldBlock'>FieldBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldWBlock'>FieldWBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarBlock'>MemVarBlock</seealso>
  </fieldwblocksym>

  <file>
    <summary>
      判断是否有任何文件匹配给定的文件规范。
    </summary>
    <param name="cFileSpec">
      用于搜索的文件规范。除了文件名外，此规范还可以包括可选的驱动器、目录和扩展名。<br/>
      文件名和扩展名可以包含标准通配符（* 和 ?）。<br/>
      如果未指定驱动器和目录，此函数仅在 SetDefault() 和 SetPath() 设置的范围内搜索。还要注意，File() 在搜索时不识别隐藏或系统文件。如果 <paramref name="cFileSpec" /> 长度超过127个字符且没有路径，VO 仅在当前目录中搜索。
    </param>
    <returns>
      如果有任何文件匹配 <paramref name="cFileSpec" /> 模式，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例说明了 File() 如何尝试查找文件：
      <code language="X#">
        ? File("sales.dbf")&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        ? File("\apps\dbf\sales.dbf")&#0009;&#0009;&#0009;// TRUE
        SetPath("\apps\dbf")
        ? File("sales.dbf")&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
        SetPath("")
        SetDefault("\apps\dbf\")
        ? File("sales.dbf")&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
        ? File("*.dbf")&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FPathName'>FPathName</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDefault'>SetDefault</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPath'>SetPath</seealso>
  </file>

  <floatformat>
    <summary>
      设置浮点数的显示格式。
    </summary>
    <param name="fValue">任何数值。</param>
    <param name="iLen">
      <paramref name="fValue" />的期望显示长度，包括小数位、小数点和符号。<br/>
      值为-1表示只显示小数点左侧的有效数字（任何左侧填充将被抑制）。
    </param>
    <param name="iDec">
      <paramref name="fValue" />显示中期望的小数位数。<br/>
      值为-1表示只显示小数点右侧的有效数字（任何右侧填充将被抑制）。
    </param>
    <returns>
    </returns>
    <remarks>
      FloatFormat()用于格式化浮点数。注意，FloatFormat()只影响数字的显示格式，不影响计算的实际数值精度。
    </remarks>
    <example>
      这些示例使用FloatFormat()以三种不同格式显示相同的数字。注意每个结果中前导空格的数量：
      <code language="X#">
        ? FloatFormat(1234.546, 12,2)&#0009;&#0009;//  1234.54
        ? FloatFormat(1234.546, -1,4)&#0009;&#0009;//  1234.5460
        ? Floatformat(1234.546, 12,-1)&#0009;&#0009;//  1234.546
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDigit'>SetDigit</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
  </floatformat>

  <flock>
    <summary>
      锁定已打开并共享的数据库文件。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <returns>
      如果锁定成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      如果数据库文件以共享模式打开，在尝试任何更新数据库文件的操作之前，必须获得文件锁。
      对于每次调用 FLock()，都会尝试锁定数据库文件（以及其他相关文件，如索引和备忘录文件），并将结果作为逻辑值返回。<br/>
      如果另一个进程当前持有相同数据库文件的文件锁或记录锁，则文件锁定失败。
      如果 FLock() 成功，文件将被锁定，其他进程将被阻止进行更新，直到锁被释放。FLock() 提供共享锁，允许其他用户对锁定文件进行只读访问，而只允许当前进程修改它。
      文件锁将一直有效，直到您关闭数据库、显式解锁（例如使用 DBUnLock()），或尝试另一个文件或记录锁（使用 RLock() 或 DBRLock()）。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      这个特性很有用，因为 FLock() 不会自动尝试锁定相关文件。
    </remarks>
    <example>
      此示例使用 FLock() 对 INVENTORY.DBF 中的价格进行批量更新：
      <code language="X#">
        USE inventory SHARED NEW
        IF Inventory-&gt;FLock()
        &#0009;REPLACE ALL Inventory-&gt;Price WITH ;
        &#0009;&#0009;&#0009;Inventory-&gt;Price * 1.1
        ELSE
        &#0009;QOut("文件不可用")
        ENDIF
      </code>
      此示例尝试在未选择的工作区中锁定文件：
      <code language="X#">
        USE sales NEW
        USE customer NEW
        IF !Sales-&gt;FLock()
        &#0009;QOut("Sales 正在使用中")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLock'>DBUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUseArea'>DBUseArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.RLock'>RLock</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetExclusive'>SetExclusive</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFlock'>VODBFLock</seealso>
  </flock>

  <floor>
    <summary>
      将数字向下舍入到最接近的较小整数。
    </summary>
    <param name="nNum">要舍入的数字。</param>
    <returns>
      小于或等于 <paramref name="nNum" /> 的最接近整数。
    </returns>
    <remarks>
      Floor() 将带有小数部分的负数向下舍入到前一个整数，并返回正数的整数部分。
    </remarks>
    <example>
      此示例对一个正数和一个负数使用 Floor()：
      <code language="X#">
        ? Floor(1.6)&#0009;&#0009;&#0009;// 1
        ? Floor(-1.6)&#0009;&#0009;&#0009;// -2 (因为 -2 &lt; -1)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Ceil'>Ceil</seealso>
    <seealso cref='O:XSharp.RT.Functions.Integer'>Integer</seealso>
    <seealso cref='O:XSharp.RT.Functions.Round'>Round</seealso>
  </floor>

  <fname>
    <summary>
      返回由 FFCount()、FFirst() 或 FNext() 找到的文件名。
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 FName() 返回匹配 *.TXT 的文件名：
      <code language="X#">
        ? FFirst("*.txt", FC_NORMAL)
        ? FName()&#0009;&#0009;&#0009;&#0009;// 返回第一个匹配的文件
        ? FNext()&#0009;&#0009;&#0009;&#0009;// 查找下一个匹配 *.txt 的文件
        ? FName()&#0009;&#0009;&#0009;&#0009;// 返回第二个匹配的文件
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
    <seealso cref='O:XSharp.Core.Functions.FDate'>FDate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFCount'>FFCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFirst'>FFirst</seealso>
    <seealso cref='O:XSharp.Core.Functions.FNext'>FNext</seealso>
    <seealso cref='O:XSharp.Core.Functions.FSize'>FSize</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTime'>FTime</seealso>
  </fname>

  <fnext>
    <summary>
      查找与之前由 FFirst() 找到的文件匹配的下一个文件。
    </summary>
    <returns>
      如果找到另一个文件，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      FNext() 查找与原始 FFirst() 或 FFCount() 搜索匹配的下一个文件。换句话说，FFirst() 获取第一个匹配的文件，而 FNext() 查找后续匹配的文件。当 FNext() 返回 FALSE 时，表示没有更多匹配的文件了。
      FFCount() 返回匹配的数量。FAttrib()、FDate()、FName()、FSize() 和 FTime() 分别返回当前匹配文件的属性、日期戳、名称、大小和时间戳。
    </remarks>
    <example>
      此示例使用 FFirst() 和 FNext() 获取所有匹配 "C:\DOCS\*.TXT" 的可见文件：
      <code language="X#">
        IF FFirst("c:\docs\*.txt", FC_NORMAL)
        &#0009;? FName()&#0009;&#0009;&#0009;// 返回第一个匹配的文件
        &#0009;DO WHILE FNext()&#0009;// 查找下一个匹配
        &#0009;&#0009;? FName()&#0009;&#0009;// 返回第二个匹配的文件
        &#0009;ENDDO
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
    <seealso cref='O:XSharp.Core.Functions.FDate'>FDate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFCount'>FFCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFirst'>FFirst</seealso>
    <seealso cref='O:XSharp.Core.Functions.FName'>FName</seealso>
    <seealso cref='O:XSharp.Core.Functions.FSize'>FSize</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTime'>FTime</seealso>
  </fnext>

  <fopen>
    <summary>
      打开一个文件。
    </summary>
    <param name="cFileName">
      文件名，包括可选的驱动器、目录和扩展名。忽略 SetDefault() 和 SetPath() 设置；除非您在文件名中指定驱动器和目录，否则使用 Windows 默认值。不假定任何扩展名。<br/>
      &#0009;在发生并发控制冲突的情况下，此函数设置 NetErr()。
    </param>
    <param name="kMode">
      DOS 打开模式，决定文件的可访问性。<br/>
      打开模式由两种类型的模式组成：访问模式 + 共享模式。指定访问模式常量表示如何访问打开的文件；共享模式决定其他进程如何访问该文件。<br/>
      &#0009;可用的打开和共享模式常量如下：<br/>
      &#0009;访问模式&#0009;操作<br/>
      &#0009;FO_READ&#0009;打开以读取（默认）<br/>
      &#0009;FO_READWRITE&#0009;打开以读取或写入<br/>
      &#0009;FO_WRITE&#0009;打开以写入<br/>
      <br/>
      &#0009;共享模式&#0009;操作<br/>
      &#0009;FO_COMPAT&#0009;兼容模式（默认）<br/>
      &#0009;FO_DENYNONE&#0009;允许其他人读取或写入<br/>
      &#0009;FO_DENYREAD&#0009;阻止其他人读取<br/>
      &#0009;FO_DENYWRITE&#0009;阻止其他人写入<br/>
      &#0009;FO_EXCLUSIVE&#0009;独占使用<br/>
      &#0009;FO_SHARED&#0009;与 FO_DENYNONE 相同<br/>
      &#0009;默认打开模式是不可共享和只读。<br/>
      如果仅使用访问模式，文件将以不可共享的方式打开。
    </param>
    <returns>
      打开文件的文件句柄，范围为 0 到 32,767。<br/>
      此值类似于数据库系统中的别名，用于向其他文件函数标识打开的文件。<br/>
      因此，将返回值分配给变量以供后续使用很重要，如下面的示例所示。
      如果发生错误，FOpen() 返回 F_ERROR。可以使用 FError() 确定具体错误。
    </returns>
    <remarks>
      FOpen() 是一个低级文件函数，用于打开现有文件以进行读取和写入，具体取决于 <paramref name="kMode" /> 参数。
      请注意，为了让两个进程同时使用同一个文件，两个文件都应以 FO_SHARED 共享模式打开。
      每当出现错误时，可以使用 FError() 确定具体错误。<br/>
      例如，如果文件不存在，FOpen() 返回 F_ERROR，FError() 返回 2 表示未找到文件。
    </remarks>
    <example>
      此示例使用 FOpen() 以可共享读/写状态打开文件，如果打开失败则显示错误消息：
      <code language="X#">
        ptrHandle := FOpen("temp.txt")
        IF ptrHandle = F_ERROR
        &#0009;? DOSErrString(FError())
        ENDIF
      </code>
      此示例使用 FOpen() 打开文件，如果 FOpen() 失败则可选重试：
      <code language="X#">
        FUNCTION NetOpen(cFile AS STRING,;
        &#0009;&#0009;wMode AS DWORD, wSeconds AS DWORD);
        &#0009;&#0009;AS LOGIC PASCAL
        &#0009;LOCAL lForever AS LOGIC
        &#0009;// 如果 wSeconds 为零则永远重试
        &#0009;lForever := (wSeconds = 0)
        &#0009;DO WHILE (lForever .OR. wSeconds &gt; 0)
        &#0009;&#0009;IF FOpen(cFile, wMode) != F_ERROR
        &#0009;&#0009;RETURN TRUE  &#0009;&#0009;// 打开成功
        &#0009;&#0009;ENDIF
        &#0009;&#0009;InKey(1)&#0009;&#0009;&#0009;// 等待一秒
        &#0009;&#0009;wSeconds -= 1
        &#0009;ENDDO
        &#0009;RETURN FALSE&#0009;&#0009;&#0009;// 打开失败
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen2'>FOpen2</seealso>
  </fopen>

  <fopen2>
    <summary>
      打开文件，指定两个强类型参数。
    </summary>
    <param name="cFileName">
      文件名，包括可选的驱动器、目录和扩展名。忽略 SetDefault() 和 SetPath() 设置；除非您在文件名中指定驱动器和目录，否则使用 Windows 默认值。不假定任何扩展名。<br/>
      &#0009;在发生并发控制冲突的情况下，此函数设置 NetErr()。
    </param>
    <param name="kMode">
      此参数与 FOpen() 中使用的 <paramref name="kMode" /> 相同。有关详细信息，请参阅 FOpen()。
    </param>
    <returns>
      打开文件的文件句柄，范围为 0 到 32,767。<br/>
      如果发生错误，FOpen2() 返回 F_ERROR。可以使用 FError() 确定具体错误。
    </returns>
    <remarks>
      请注意，为了让两个进程同时使用同一个文件，两个文件都应以 FO_SHARED 共享模式打开。
    </remarks>
    <example>
      此示例使用 FOpen2() 以可共享读/写状态打开文件，如果打开失败则显示错误消息：
      <code language="X#">
        ptrHandle := FOpen2("temp.txt",;
        &#0009;FO_READWRITE + FO_SHARED)
        IF ptrHandle = F_ERROR
        &#0009;? DOSErrString(FError())
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
  </fopen2>

  <found>
    <summary>
      确定上一次搜索操作是否成功。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      如果上次搜索成功则返回 TRUE；否则返回 FALSE。如果工作区中没有打开的数据库，Found() 也将返回 FALSE。
    </returns>
    <remarks>
      Found() 用于确定搜索操作（如 DBSeek()、DBLocate()、DBContinue() 或 DBSetRelation()）是否成功。当执行这些命令时，如果有匹配项，Found() 设置为 TRUE；否则设置为 FALSE。
      如果搜索命令是 LOCATE 或 CONTINUE，匹配项是满足范围和条件的下一条记录。<br/>
      如果搜索命令是 FIND、SEEK 或 SET RELATION，匹配项是控制顺序中等于搜索参数的第一个键。<br/>
      如果键值等于搜索参数，Found() 为 TRUE；否则为 FALSE。
      Found() 的值保持不变，直到执行另一个记录移动命令。<br/>
      除非该命令是另一个搜索命令，否则 Found() 会自动设置为 FALSE。您也可以使用 DBSetFound() 手动设置此标志。
      每个工作区都有一个 Found() 值。<br/>
      这意味着如果一个工作区与子工作区设置了关系，在子工作区中查询 Found() 如果有匹配项则返回 TRUE。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      此示例说明了记录移动命令后 Found() 的行为：
      <code language="X#">
        USE sales INDEX sales
        SEEK "1000"
        QOut(Found())&#0009;&#0009;&#0009;// 结果：FALSE
        SEEK "100"
        QOut(Found())&#0009;&#0009;&#0009;// 结果：TRUE
        SKIP
        QOut(Found())&#0009;&#0009;&#0009;// 结果：FALSE
      </code>
      此示例使用别名表达式测试未选定工作区中的 Found() 值：
      <code language="X#">
        USE sales INDEX sales NEW
        USE customer INDEX customer NEW
        SET RELATION TO CustNum INTO sales
        SEEK "Smith"
        QOut(Found(), Sales-&gt;Found())
      </code>
      此代码片段使用 Found() 处理所有键值为 "Smith" 的 CUSTOMER 记录，以确定键值何时发生变化：
      <code language="X#">
        USE customer INDEX customer NEW
        SEEK "Smith"
        DO WHILE Found()
        &#0009;.
        &#0009;. <paramref name="语句" />
        &#0009;.
        &#0009;SKIP
        &#0009;LOCATE REST WHILE Name == "Smith"
        ENDDO
      </code>
    </example>
    <seealsocmd>CONTINUE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbSetFound'>DBSetFound</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealsocmd>LOCATE</seealsocmd>
    <seealsocmd>SEEK</seealsocmd>
    <seealsocmd>SET RELATION</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.VoDbFound'>VODBFound</seealso>
  </found>

  <fparamcount>
    <summary>
      返回使用 CLIPPER 调用约定的函数预期的本地参数数量。
    </summary>
    <param name="symFunction">
      要检查的函数的符号。<br/>
      该函数必须使用 CLIPPER 调用约定。
    </param>
    <returns>
    </returns>
    <remarks>
      只计算在函数括号内声明的参数。<br/>
      因此，使用 PARAMETERS 语句声明的参数不计算在内。
    </remarks>
    <example>
      此示例使用 FParamCount() 和 PCount() 来确定缺少的参数数量：
      <code language="X#">
        Missing("hi")
        FUNCTION Missing(uOne, uTwo, uThree)
        &#0009;? FParamCount(#Missing) - PCount(),;
        &#0009;&#0009;"缺少的参数"&#0009;// 2 缺少的参数
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CParamCount'>CParamCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.MParamCount'>MParamCount</seealso>
  </fparamcount>

  <fpathname>
    <summary>
      返回由 File() 使用的文件的名称和路径。
    </summary>
    <returns>
      File() 最后使用的文件的完整名称，包括路径。请注意，系统内部也可能使用 File()。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例在调用 File 后使用 FPathName()：
      <code language="X#">
        SetDefault("\vo")
        ? File("*.exe")
        ? FPathName()&#0009;&#0009;&#0009;&#0009;// C:\VO\EXISTS.EXE
        ? File("d:\backup\notexist.txt")
        ? FPathName()&#0009;&#0009;&#0009;&#0009;// D:\BACKUP\NOTEXIST.TXT
        SetDefault("c:\backup")
        File("exists.txt")&#0009;&#0009;&#0009;// c:\backup\exists.txt
        ? FPathName()
        SetDefault("c:\vo\data")
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.File'>File</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDefault'>SetDefault</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPath'>SetPath</seealso>
    <seealso cref='O:XSharp.RT.Functions.SplitPath'>SplitPath</seealso>
  </fpathname>

  <fputs>
    <summary>
      向打开的文件写入一个字符串、回车符和换行符。
    </summary>
    <param name="ptrHandle">要写入的文件句柄。</param>
    <param name="cBuffer">要写入的字符串。</param>
    <param name="nBytes">
      从当前文件指针位置开始，要写入 <paramref name="cBuffer" /> 的字节数。<br/>
      如果未指定 <paramref name="nBytes" />，则使用 SLen(<paramref name="cBuffer" />) 的值。
    </param>
    <returns>
      写入的字节数。<br/>
      如果返回值等于 <paramref name="nBytes" /> + 2，则操作成功。<br/>
      如果返回值小于 <paramref name="nBytes" /> + 2 或为 0，则表示 <paramref name="cBuffer" /> 的长度小于 <paramref name="nBytes" />，或磁盘已满，或发生了其他错误。
    </returns>
    <remarks>
      FPuts() 是一个低级文件函数，用于将数据从字符串缓冲区写入打开的文件。您可以写入全部或部分缓冲区内容。写入从当前文件位置开始，函数返回实际写入的字节数。
      此函数假定处理原始二进制数据，不依赖于 SetAnsi() 的状态。相比之下，FWriteText() 和 FWrite4() 依赖于 SetAnsi()。
    </remarks>
    <example>
      此示例使用 FPuts() 从文件开头开始写入行。<br/>
      回车符/换行符对使返回值增加 2：
      <code language="X#">
        ptrHandle := FOpen2("c:\data\sales", FO_READWRITE)
        ? FPuts(ptrHandle, "Line1")&#0009;&#0009;&#0009;&#0009;//  7
        ? FPuts(ptrHandle, "Line1", 2)&#0009;&#0009;&#0009;&#0009;//  4
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FWriteLine'>FWriteLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.FPutS3'>FPuts3</seealso>
  </fputs>

  <fputs3>
    <summary>
      向打开的文件写入一个字符串、回车符和换行符，指定三个强类型参数。
    </summary>
    <param name="ptrHandle">要写入的文件句柄。</param>
    <param name="cBuffer">要写入的字符串。</param>
    <param name="dwBytes">
      从当前文件指针位置开始，要写入 <paramref name="cBuffer" /> 的字节数。
    </param>
    <returns>
      写入的字节数。<br/>
      如果返回值等于 <paramref name="dwBytes" /> + 2，则操作成功。<br/>
      如果返回值小于 <paramref name="dwBytes" /> + 2 或为 0，则表示 <paramref name="cBuffer" /> 的长度小于 <paramref name="dwBytes" />，或磁盘已满，或发生了其他错误。
    </returns>
    <remarks>
      此函数假定处理原始二进制数据，不依赖于 SetAnsi() 的状态。相比之下，FWriteText() 和 FWrite4() 依赖于 SetAnsi()。
    </remarks>
    <example>
      此示例使用 FPuts3() 写入 5 个字节。回车符/换行符对使返回值增加 2：
      <code language="X#">
        ptrHandle := FOpen2("c:\data\sales", FO_READWRITE)
        ? FPuts3(ptrHandle, "Line1", 5)&#0009;&#0009;&#0009;//  7
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FWriteLine'>FWriteLine</seealso>
  </fputs3>

  <frac>
    <summary>
      返回数字的小数部分。
    </summary>
    <param name="fValue">要返回其小数部分的数字。</param>
    <returns>
    </returns>
    <remarks>
      一个数字可能在其整数部分后包含小数部分。<br/>
      此函数仅返回小数部分。
    </remarks>
    <example>
      此示例使用 Frac() 实现自动售货机或找零机的逻辑：
      <code language="X#">
        FUNCTION GiveChange(fMoney AS FLOAT) AS VOID PASCAL
        LOCAL fChange AS FLOAT
        ? "美元: $", Integer(fMoney)
        fChange := Frac(fMoney)
        // 当还有一分钱时
        DO WHILE fChange &gt;= 0.01
        &#0009;// 必须先检查小额：
        &#0009;DO CASE
        &#0009;CASE fChange &lt; 0.05
        &#0009;&#0009;? "支付一分钱"
        &#0009;&#0009;fChange -= 0.01
        &#0009;CASE fChange &lt; 0.10
        &#0009;&#0009;? "支付一个五分硬币"
        &#0009;&#0009;fChange -= 0.05
        &#0009;CASE fChange &lt; 0.25
        &#0009;&#0009;? "支付一个十分硬币"
        &#0009;&#0009;fChange -= 0.10
        &#0009;CASE fChange &lt; 0.5
        &#0009;&#0009;? "支付一个二十五分硬币"
        &#0009;&#0009;fChange -= 0.25
        &#0009;OTHERWISE
        &#0009;&#0009;? "支付半美元"
        &#0009;&#0009;fChange -= 0.50
        &#0009;ENDCASE
        ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Integer'>Integer</seealso>
  </frac>

  <fread>
    <summary>
      从文件中读取字符到通过引用传递的缓冲区变量中。
    </summary>
    <param name="ptrHandle">要读取的文件句柄。</param>
    <param name="cBufferVar">
      用于存储从指定文件读取的数据的变量。<br/>
      如果 <paramref name="cBufferVar" /> 的长度小于 <paramref name="dwBytes" />，则会分配一个新的字符串，其长度为 <paramref name="dwBytes" /> 和文件中剩余字节数的最小值。<paramref name="cBufferVar" /> 必须通过引用传递，因此必须在前面加上引用传递运算符 (@)。
    </param>
    <param name="dwBytes">要读入缓冲区的字节数。</param>
    <returns>
      成功读取的字节数。<br/>
      返回值小于 <paramref name="dwBytes" /> 或为 0 表示已到达文件末尾或发生其他读取错误。可以使用 FError() 确定具体错误。
    </returns>
    <remarks>
      FRead() 从当前 DOS 文件指针位置开始读取，并将文件指针前进读取的字节数。<br/>
      所有字符都会被读取，包括控制字符、空字符和高位字符（高于 Chr(127)）。
      FRead() 在某些方面类似于 FReadStr() 和 FSeek()。FReadStr() 从文件中读取指定数量的字节，直到遇到下一个空字符（Chr(0)）。FSeek() 移动文件指针但不进行读取。
      此函数假定处理原始二进制数据，不依赖于 SetAnsi() 的状态。相比之下，FReadText() 和 FRead4() 依赖于 SetAnsi()。
    </remarks>
    <example>
      此示例在成功打开文件后使用 FRead() 将 128 个字节读入缓冲区：
      <code language="X#">
        DEFINE F_BLOCK := 128
        ...
        cBuffer := Space(F_BLOCK)
        ptrHandle := FOpen2("temp.txt", FO_READ)
        IF FError() != 0
        &#0009;? DOSErrString(FError())
        ELSE
        &#0009;IF FRead(ptrHandle, @cBuffer, F_BLOCK) <paramref name="" /> F_BLOCK
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;ENDIF
        &#0009;FClose(ptrHandle)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead3'>FRead3</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadText'>FReadText</seealso>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </fread>

  <fread3>
    <summary>
      从文件中读取字符到分配的缓冲区中。
    </summary>
    <param name="ptrHandle">要读取的文件句柄。</param>
    <param name="ptrBufferVar">
      指向用于存储从指定文件读取的数据的已分配缓冲区的指针。<br/>
      此变量的长度必须大于或等于 <paramref name="dwBytes" />。
    </param>
    <param name="dwBytes">要读入缓冲区的字节数。</param>
    <returns>
      成功读取的字节数。<br/>
      返回值小于 <paramref name="dwBytes" /> 或为 0 表示已到达文件末尾或发生其他读取错误。可以使用 FError() 确定具体错误。
    </returns>
    <remarks>
      FRead3() 与 FRead() 相同，只是缓冲区变量的名称是一个指针，不是通过引用传递的。
      详细信息请参见 FRead()。
      此函数假定处理原始二进制数据，不依赖于 SetAnsi() 的状态。相比之下，FReadText() 和 FRead4() 依赖于 SetAnsi()。
    </remarks>
    <example>
      此示例在成功打开文件后使用 FRead3() 将 128 个字节读入缓冲区：
      <code language="X#">
        DEFINE F_BLOCK := 128
        Function Start()
        &#0009;LOCAL cBuffer AS PTR
        &#0009;cBuffer := MemAlloc(F_BLOCK)
        &#0009;IF cBuffer = NULL PTR
        &#0009;&#0009;RETURN FALSE
        &#0009;ENDIF
        &#0009;ptrHandle := FOpen2("temp.txt", FO_READ)
        &#0009;IF ptrHandle = F_ERROR
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;&#0009;RETURN FALSE
        &#0009;ELSE
        &#0009;&#0009;IF FRead3(ptrHandle, cBuffer, F_BLOCK) <paramref name="" /> F_BLOCK
        &#0009;&#0009;&#0009;? DOSErrString(FError())
        &#0009;&#0009;&#0009;RETURN FALSE
        &#0009;&#0009;ENDIF
        &#0009;&#0009;FClose(ptrHandle)
        &#0009;ENDIF
        &#0009;MemFree(cBuffer)
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.RT.Functions.FReadText3'>FReadText3</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </fread3>

  <fread4>
    <summary>
      从文件中读取字符到已分配的缓冲区。
    </summary>

    <param name="ptrHandle">要读取的文件句柄。</param>
    <param name="ptrBufferVar">
      指向用于存储从指定文件读取的数据的已分配缓冲区的指针。<br/>
      此变量的长度必须大于或等于 <paramref name="dwBytes" />。
    </param>
    <param name="dwBytes">要读入缓冲区的字节数。</param>
    <param name="lAnsi">如果为 FALSE，则进行 OEM 到 ANSI 的转换。</param>
    <returns>
      成功读取的字节数。<br/>
      返回值小于 <paramref name="dwBytes" /> 或为 0 表示到达文件末尾或发生其他读取错误。可以使用 FError() 来确定具体错误。
    </returns>
    <remarks>
      FRead4() 与 FRead3() 相同，只是它提供了执行 OEM 到 ANSI 转换的选项。
    </remarks>
    <example>
      此示例在成功打开文件后使用 FRead4() 将 128 个字节读入缓冲区：
      <code language="X#">
        DEFINE F_BLOCK := 128
        Function Start()
        &#0009;LOCAL cBuffer AS PTR
        &#0009;cBuffer := MemAlloc(F_BLOCK)
        &#0009;IF cBuffer = NULL PTR
        &#0009;&#0009;RETURN FALSE
        &#0009;ENDIF
        &#0009;ptrHandle := FOpen2("temp.txt", FO_READ)
        &#0009;IF ptrHandle = F_ERROR
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;&#0009;RETURN FALSE
        &#0009;ELSE
        &#0009;&#0009;IF FRead4(ptrHandle, cBuffer, F_BLOCK, FALSE) != F_BLOCK
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;&#0009;&#0009;RETURN FALSE
        &#0009;&#0009;ENDIF
        &#0009;&#0009;FClose(ptrHandle)
        &#0009;ENDIF
        &#0009;MemFree(cBuffer)
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2OEM</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>OEM2Ansi</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </fread4>

  <freadline>
    <summary>
      从打开的文件中读取一行。
    </summary>
    <param name="ptrHandle">要读取的文件句柄。</param>
    <param name="nMax">
      每行要读取的最大字符数。FReadLine() 将读取直到遇到硬回车（Chr(13)），到达文件末尾，或读取了 <paramref name="nMax" /> 个字符。<br/>
      <paramref name="nMax" /> 的默认值为 256。
    </param>
    <returns>
      读取的行。当到达文件末尾时，FReadLine() 返回 NULL_STRING，并且 FError() 被设置为 257。
    </returns>
    <remarks>
      此函数与 FGets() 相同。这两个函数都假定处理原始二进制数据，不依赖于 SetAnsi() 的状态。相比之下，FReadText() 和 FRead4() 依赖于 SetAnsi()。
    </remarks>
    <example>
      此示例使用 FReadLine() 读取整个文件，不指定 <paramref name="nMax" /> 的值：
      <code language="X#">
        ptrHandle := FOpen2("docs.txt", FO_READ)
        IF ptrHandle != F_ERROR
        &#0009;DO WHILE !FEOF(ptrHandle)
        &#0009;&#0009;? FReadLine(ptrHandle)
        &#0009;ENDDO
        ENDIF
        FClose(ptrHandle)
      </code>
      以下示例提供了一个实用程序，用于显示并计算文件中字符串的所有出现次数：
      <code language="X#">
        FUNCTION Grep(cSearch, cFile AS STRING) ;
        &#0009;&#0009;AS DWORD PASCAL
        &#0009;LOCAL handle AS PTR
        &#0009;LOCAL Count AS DWORD
        &#0009;LOCAL Line AS STRING
        &#0009;Line := " "
        &#0009;handle := FOpen2(file, FO_READ)
        &#0009;cSearch := Upper(cSearch)
        &#0009;DO WHILE !FEOF(handle)
        &#0009;&#0009;line := Upper(FReadLine(handle))
        &#0009;&#0009;IF InStr(cSearch, line)
        &#0009;&#0009;&#0009;? line
        &#0009;&#0009;Count += 1
        &#0009;&#0009;ENDIF
        &#0009;ENDDO
        &#0009;RETURN Count
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FGetS'>FGets</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadLine2'>FReadLine2</seealso>
  </freadline>

  <freadline2>
    <summary>
      从打开的文件中读取一行，指定两个强类型参数。
    </summary>
    <param name="ptrHandle">要读取的文件句柄。</param>
    <param name="dwMax">
      每行读取的最大字符数。FReadLine2() 将读取直到遇到硬回车（Chr(13)）、到达文件末尾，或读取了 <paramref name="dwMax" /> 个字符。<br/>
      <paramref name="dwMax" /> 的默认值为 256。
    </param>
    <returns>
      读取的行。当到达文件末尾时，FReadLine2() 返回 NULL_STRING，并且 FError() 被设置为 257。
    </returns>
    <remarks>
      此函数与 FGets2() 相同。这两个函数都假定处理原始二进制数据，并且不依赖于 SetAnsi() 的状态。而 FReadText() 和 FRead4() 则依赖于 SetAnsi()。
    </remarks>
    <example>
      此示例使用 FReadLine2() 读取整个文件，每行最多80个字符：
      <code language="X#">
        hF := FOpen2("docs.txt", FO_READ)
        IF hF != F_ERROR
        &#0009;DO WHILE !FEOF(hF)
        &#0009;&#0009;? FReadLine2(hF, 80)
        &#0009;ENDDO
        ENDIF
        FClose(hF)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FGetS'>FGets</seealso>
    <seealso cref='O:XSharp.RT.Functions.FReadLine'>FReadLine</seealso>
  </freadline2>

  <freadstr>
    <summary>
      从文件中读取字符。
    </summary>
    <param name="ptrHandle">要读取的文件句柄。</param>
    <param name="dwBytes">
      要读取的字节数，从当前 DOS 文件指针位置开始。字符读取至 <paramref name="dwBytes" /> 或直到遇到文件末尾。<br/>
      然后文件指针向前移动 <paramref name="dwBytes" />。<br/>
      如果 <paramref name="dwBytes" /> 大于从指针位置到文件末尾的字节数，文件指针将定位于文件的最后一个字节。
    </param>
    <returns>
      一个字符串。<br/>
      NULL_STRING 表示错误或文件结束。<br/>
      如果在读取时到达文件末尾，FError() 被设置为 257。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例显示文本文件前 16 个字节的 ASCII 值：
      <code language="X#">
        ptrHandle := FOpen2("new.txt", FC_NORMAL)
        IF ptrHandle = F_ERROR
        &#0009;? DOSErrString(FError())
        ELSE
        &#0009;cString := FReadStr(ptrHandle, 16)
        &#0009;? cString
        &#0009;FClose(ptrHandle)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
  </freadstr>

  <freadtext>
    <summary>
      从文件中读取字符到通过引用传递的缓冲区变量中。
    </summary>

    <param name="ptrHandle">要读取的文件句柄。</param>
    <param name="cBufferVar">
      用于存储从指定文件读取的数据的变量。<br/>
      如果 <paramref name="cBufferVar" /> 的长度小于 <paramref name="dwBytes" />，则分配一个新字符串，其长度为 <paramref name="dwBytes" /> 和文件中剩余字节数的最小值。<paramref name="cBufferVar" /> 必须通过引用传递，因此必须加上通过引用传递的操作符 (@)。
    </param>
    <param name="dwBytes">要读入缓冲区的字节数。</param>
    <returns>
      成功读取的字节数。<br/>
      返回值小于 <paramref name="dwBytes" /> 或为 0 表示已到达文件末尾或发生其他读取错误。可以使用 FError() 确定具体错误。
    </returns>
    <remarks>
      FReadText() 与 FRead() 相同，只是在 SetAnsi() 为 FALSE 时会进行 OEM 到 ANSI 的转换。
    </remarks>
    <example>
      此示例在成功打开文件后使用 FRead() 将 128 个字节读入缓冲区：
      <code language="X#">
        DEFINE F_BLOCK := 128
        ...
        cBuffer := Space(F_BLOCK)
        ptrHandle := FOpen("temp.txt")
        IF FError() != 0
        &#0009;? DOSErrString(FError())
        ELSE
        &#0009;IF FReadText(ptrHandle, @cBuffer, F_BLOCK) <paramref name="" /> F_BLOCK
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;ENDIF
        &#0009;FClose(ptrHandle)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.RT.Functions.FReadText3'>FReadText3</seealso>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </freadtext>

  <freadtext3>
    <summary>
      从文件中读取字符到分配的缓冲区，并根据当前的 SetAnsi() 设置进行可能的 OEM 到 ANSI 转换。
    </summary>
    <param name="ptrHandle">要读取的文件句柄。</param>
    <param name="ptrBufferVar">
      指向用于存储从指定文件读取的数据的已分配缓冲区的指针。<br/>
      此变量的长度必须大于或等于 <paramref name="dwBytes" />。
    </param>
    <param name="dwBytes">要读入缓冲区的字节数。</param>
    <returns>
      成功读取的字节数。<br/>
      返回值小于 <paramref name="dwBytes" /> 或为 0 表示已到达文件末尾或发生其他读取错误。可以使用 FError() 确定具体错误。
    </returns>
    <remarks>
      FReadText3() 与 FRead3() 相同，只是在 SetAnsi() 为 FALSE 时会进行 OEM 到 ANSI 的转换。
    </remarks>
    <example>
      此示例在成功打开文件后使用 FReadText3() 将 128 个字节读入缓冲区：
      <code language="X#">
        DEFINE F_BLOCK := 128
        Function Start()
        &#0009;LOCAL cBuffer AS PTR
        &#0009;cBuffer := MemAlloc(F_BLOCK)
        &#0009;IF cBuffer = NULL PTR
        &#0009;&#0009;RETURN FALSE
        &#0009;ENDIF
        &#0009;ptrHandle := FOpen("temp.txt")
        &#0009;IF ptrHandle = F_ERROR
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;&#0009;RETURN FALSE
        &#0009;ELSE
        &#0009;&#0009;IF FReadText3(ptrHandle, cBuffer, F_BLOCK) <paramref name="" /> F_BLOCK
        &#0009;&#0009;&#0009;? DOSErrString(FError())
        &#0009;&#0009;&#0009;RETURN FALSE
        &#0009;&#0009;ENDIF
        &#0009;&#0009;FClose(ptrHandle)
        &#0009;ENDIF
        &#0009;MemFree(cBuffer)
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadText'>FReadText</seealso>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </freadtext3>

  <frename>
    <summary>
      更改文件名。
    </summary>
    <param name="cOldFile">原始文件名，包括可选的驱动器、目录和扩展名。SetDefault() 和 SetPath() 设置被忽略；除非您在文件名中指定驱动器和目录，否则使用 Windows 默认设置。不假定任何扩展名。</param>
    <param name="cNewFile">
      新文件名，包括可选的驱动器、目录和扩展名。SetDefault() 和 SetPath() 设置被忽略；除非您在文件名中指定驱动器和目录，否则使用 Windows 默认设置。不假定任何扩展名。<br/>
      如果源目录与目标目录不同，文件将移动到目标目录。<br/>
      如果 <paramref name="cNewFile" /> 已存在或当前打开，则 FRename() 失败并返回 FALSE。
    </param>
    <returns>
      如果操作成功，则返回 TRUE；否则返回 FALSE。在失败的情况下，可以使用 FError() 确定具体错误。警告！在重命名之前，文件必须关闭。<br/>
      尝试重命名打开的文件将产生不可预测的结果。当数据库文件被重命名时，相关的备忘录文件（如果有）也必须重命名。未能这样做可能会损害数据库的完整性。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例演示文件重命名：
      <code language="X#">
        IF !FRename("oldfile.txt", "newfile.txt")
        &#0009;? DOSErrString(FError())
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FErase'>FErase</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.File'>File</seealso>
    <seealsocmd>RENAME</seealsocmd>
  </frename>

  <frewind>
    <summary>
      将文件指针设置在打开文件的顶部。
    </summary>
    <param name="ptrHandle">打开文件的句柄。</param>
    <returns>
    </returns>
    <remarks>
      FRewind() 将文件指针设置为文件的开始位置。<br/>
      它与发出 FSeek() 以返回到文件顶部相同。
    </remarks>
    <example>
      此示例使用 FRewind() 返回到文件的顶部：
      <code language="X#">
        hF := Fopen2("c:\vo.txt", FO_READ)
        FSeek(hF, 10, FS_SET)&#0009;&#0009;// 移动 10 个字节
        FRewind(hF)&#0009;&#0009;&#0009;&#0009;&#0009;// 返回到顶部
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FEof'>FEOF</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTell'>FTell</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
  </frewind>

  <fseek>
    <summary>
      将文件指针设置到新位置。
    </summary>
    <param name="ptrHandle">打开文件的句柄。</param>
    <param name="nOffset">
      从 <paramref name="nOrigin" /> 指定的位置移动文件指针的字节数。<br/>
      可以是正数或负数。<br/>
      正数将指针向前移动，负数则向后移动。<br/>
      如果 <paramref name="nOrigin" /> 为文件末尾，则 <paramref name="nOffset" /> 必须为 0 或负数。
    </param>
    <param name="kOrigin">
      指示文件指针起始位置的常量之一，告诉文件开始搜索的位置:<br/>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>从哪里开始寻址</description>
        </listheader>
        <item>
          <term>FS_END</term>
          <description>文件末尾</description>
        </item>
        <item>
          <term>FS_RELATIVE</term>
          <description>当前位置</description>
        </item>
        <item>
          <term>FS_SET</term>
          <description>文件开头</description>
        </item>
      </list>
    </param>
    <returns>
      文件指针的新位置，相对于文件开头（位置 0）。(文件指针的原始位置不重要。)
    </returns>
    <remarks>
      FSeek() 是一个低级文件函数，用于在打开的文件中向前或向后移动文件指针，而不实际读取指定文件的内容。<br/>
      文件指针不能移动超过文件的开头或末尾边界。
    </remarks>
    <example>
      这个示例使用 FSeek() 从文件末尾确定文件的长度。<br/>
      然后，将文件指针重置到文件开头:
      <code language="X#">
        // 以只读方式打开文件
        IF (ptrHandle := FOpen2("temp.txt", FO_READ)) != F_ERROR
        &#0009;// 获取文件长度
        &#0009;nLength := FSeek(ptrHandle, 0, FS_END)
        &#0009;// 将文件位置重置到文件开头
        &#0009;FSeek(ptrHandle, 0)
        &#0009;FClose(ptrHandle)
        ELSE
        &#0009;? DOSErrString(FError())
        ENDIF
      </code>
      这个示例将文件指针定位到文件中的最后一个字节:
      <code language="X#">
        FUNCTION FileBottom(ptrHandle) AS LONGINT
        &#0009;RETURN (FSeek(ptrHandle, 0, FS_END))
      </code>
      这个示例将文件指针定位到文件中的第一个字节（与 Rewind() 函数相同）:
      <code language="X#">
        FUNCTION FileTop(ptrHandle) AS LONGINT
        &#0009;RETURN (FSeek(ptrHandle, 0))
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.FRewind'>FRewind</seealso>
    <seealso cref='O:XSharp.Core.Functions.FSeek3'>FSeek3</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTell'>FTell</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
  </fseek>

  <fseek3>
    <summary>
      设置文件指针到一个新位置，指定三个强类型参数。
    </summary>
    <param name="ptrHandle">打开文件的句柄。</param>
    <param name="liOffset">
      从由 <paramref name="dwOrigin" /> 定义的位置移动文件指针的字节数。<br/>
      可以是正数或负数。<br/>
      正数将指针向前移动，负数将指针向后移动。
    </param>
    <param name="dwOrigin">
      与 FSeek() 中的 <paramref name="nOrigin" /> 相同，但为必需参数。有关详细信息，请参见 FSeek()。
    </param>
    <returns>
      文件指针的新位置，相对于文件开头（位置 0）。（文件指针的原始位置不重要。）
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用第三个参数报告指定文件中文件指针的当前位置信息（与 FTell() 相同）：
      <code language="X#">
        FUNCTION FilePos(ptrHandle) AS LONGINT
        &#0009;RETURN(FSeek3(ptrHandle, 0, FS_RELATIVE))
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTell'>FTell</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
  </fseek3>

  <fsize>
    <summary>
      返回由 FFCount()、FFirst() 或 FNext() 找到的文件的大小。
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 FSize() 查看名为 DOCS*.DOC 的文件的大小：
      <code language="X#">
        ? FFirst("docs*.doc", FC_NORMAL)
        ? FSize()&#0009;&#0009;&#0009;// 返回第一个匹配文件的大小
        ? FNext()&#0009;&#0009;&#0009;// 查找下一个匹配 docs*.doc 的文件
        ? FSize()&#0009;&#0009;&#0009;// 返回下一个匹配文件的大小
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
    <seealso cref='O:XSharp.Core.Functions.FDate'>FDate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFCount'>FFCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFirst'>FFirst</seealso>
    <seealso cref='O:XSharp.Core.Functions.FName'>FName</seealso>
    <seealso cref='O:XSharp.Core.Functions.FNext'>FNext</seealso>
    <seealso cref='O:XSharp.Core.Functions.FTime'>FTime</seealso>
  </fsize>

  <ftell>
    <summary>
      返回文件指针的当前位置。
    </summary>

    <param name="ptrHandle">要检查的文件句柄。</param>
    <returns>
      文件指针的当前位置，相对于文件的开头。
    </returns>
    <remarks>
      FTell() 获取当前文件位置。<br/>
      这对应于以二进制模式打开的文件的当前物理字节偏移量。
    </remarks>
    <example>
      此示例使用 FTell() 在 FWrite() 和 FSeek() 之前和之后反映文件指针位置：
      <code language="X#">
        hF := FOpen2("myfile.txt", FO_READWRITE)
        IF hF != F_ERROR
        &#0009;? FTell(hF)&#0009;&#0009;&#0009;&#0009;//  0
        &#0009;FWrite3(hF, "Hello", 5)
        &#0009;? FTell(hF)&#0009;&#0009;&#0009;&#0009;//  5
        &#0009;FSeek3(hF, 10, FS_SET)
        &#0009;? FTell(hF)&#0009;&#0009;&#0009;&#0009;//  10
        ELSE
        &#0009;? "打开失败"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FSeek'>FSeek</seealso>
  </ftell>

  <ftime>
    <summary>
      返回由 FFCount()、FFirst() 或 FNext() 找到的文件的时间戳。
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 FTime() 查找文件的最后更新时间：
      <code language="X#">
        // 查找第一个匹配 *.txt 的文件
        ? FFirst("*.txt", FC_NORMAL)&#0009;&#0009;&#0009;// TRUE
        ? FTime()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 13:18:26
        // 获取下一个匹配 *.txt 的文件
        ? FNext()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
        ? FTime()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 17:53:06
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
    <seealso cref='O:XSharp.Core.Functions.FDate'>FDate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFCount'>FFCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.FFirst'>FFirst</seealso>
    <seealso cref='O:XSharp.Core.Functions.FName'>FName</seealso>
    <seealso cref='O:XSharp.Core.Functions.FNext'>FNext</seealso>
    <seealso cref='O:XSharp.Core.Functions.FSize'>FSize</seealso>
  </ftime>

  <fwrite>
    <summary>
      将字符串写入打开的文件。
    </summary>
    <param name="ptrHandle">要写入的文件句柄。</param>
    <param name="cBuffer">要写入的字符串。</param>
    <param name="nBytes">
      从当前文件指针位置开始，要写入 <paramref name="cBuffer" /> 的字节数。<br/>
      如果省略，则写入 <paramref name="cBuffer" /> 的整个内容。
    </param>
    <returns>
      写入的字节数。<br/>
      如果返回值等于 <paramref name="nBytes" />，则操作成功。<br/>
      如果返回值小于 <paramref name="nBytes" /> 或为 0，则表示 <paramref name="cBuffer" /> 的长度小于 <paramref name="nBytes" />，或磁盘已满，或发生了其他错误。可以使用 FError() 确定具体错误。当发生磁盘满错误时，FError() 设置为 256。
      FWrite() 和 FWrite3 假定处理原始二进制数据，不依赖于 SetAnsi() 的状态。相反，FWriteText() 和 FWrite4() 依赖于 SetAnsi()。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例将一个文件的内容复制到另一个文件：
      <code language="X#">
        DEFINE F_BLOCK := 512
        ...
        cBuffer := Space(F_BLOCK)
        nInfile := FOpen2("temp.txt", FO_READ)
        nOutfile := FCreate("newfile.txt", FC_NORMAL)
        lDone := FALSE
        DO WHILE !lDone
        &#0009;nBytesRead := FRead(nInfile, @cBuffer,;
        &#0009;F_BLOCK)
        &#0009;IF FWrite(nOutfile, cBuffer) &lt; SLen(cBuffer)
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;&#0009;lDone := TRUE
        &#0009;ELSE
        &#0009;&#0009;lDone := (nBytesRead = 0)
        &#0009;ENDIF
        ENDDO
        FClose(nInfile)
        FClose(nOutfile)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </fwrite>

  <fwrite3>
    <summary>
      将缓冲区的内容写入打开的文件。
    </summary>
    <param name="ptrHandle">要写入的文件句柄。</param>
    <param name="ptrBuffer">指向要写入的缓冲区的指针。</param>
    <param name="dwBytes">
      要写入的 <paramref name="ptrBuffer" /> 中的字节数，从当前文件指针位置开始。
    </param>
    <returns>
      写入的字节数。<br/>
      如果返回值等于 <paramref name="dwBytes" />，则操作成功。<br/>
      如果返回值小于 <paramref name="dwBytes" /> 或为 0，则表示 <paramref name="ptrBuffer" /> 的长度小于 <paramref name="dwBytes" />，或磁盘已满，或发生了其他错误。可以使用 FError() 确定具体错误。
    </returns>
    <remarks>
      FWrite3() 是 FWrite() 的强类型版本。此外，FWrite3() 的第二个参数是指向缓冲区的指针，而不是字符串。有关详细信息，请参见 FWrite()。
    </remarks>
    <example>
      此示例将 PSZ 的内容写入文件：
      <code language="X#">
        LOCAL pszBuff AS PSZ
        LOCAL ptrHandle AS PTR
        pszBuff := "hello" // psz 转换的数据
        ptrHandle := FOpen2("temp.bin", FO_READWRITE)
        IF ptrHandle != F_ERROR
        &#0009;FWrite3(ptrHandle, pszBuff, PszLen(pszBuff))
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </fwrite3>

  <fwrite4>
    <summary>
      将缓冲区的内容写入打开的文件，并提供ANSI到OEM转换选项。
    </summary>
    <param name="ptrHandle">要写入的文件句柄。</param>
    <param name="ptrBuffer">指向要写入的缓冲区的指针。</param>
    <param name="dwBytes">
      要写入的 <paramref name="ptrBuffer" /> 中的字节数，从当前文件指针位置开始。
    </param>
    <param name="lAnsi">如果为 FALSE，将进行ANSI到OEM转换。</param>
    <returns>
      写入的字节数。<br/>
      如果返回值等于 <paramref name="dwBytes" />，则操作成功。<br/>
      如果返回值小于 <paramref name="dwBytes" /> 或为 0，则表示 <paramref name="ptrBuffer" /> 的长度小于 <paramref name="dwBytes" />，或磁盘已满，或发生了其他错误。可以使用 FError() 确定具体错误。
    </returns>
    <remarks>
      FWrite4() 与 FWrite3() 相同，只是提供了进行ANSI到OEM转换的选项。
    </remarks>
    <example>
      此示例在执行ANSI到OEM转换的同时，将PSZ的内容写入文件：
      <code language="X#">
        LOCAL pszBuff AS PSZ
        LOCAL ptrHandle AS PTR
        pszBuff := "hello" // psz 转换的数据
        ptrHandle := FOpen2("temp.bin", FO_READWRITE)
        IF ptrHandle != F_ERROR
        &#0009;FWrite4(ptrHandle, pszBuff,;
        &#0009;PszLen(pszBuff), FALSE)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </fwrite4>

  <fwriteline>
    <summary>
      将字符串、回车符和换行符写入打开的文件。
    </summary>
    <param name="ptrHandle">要写入的文件句柄。</param>
    <param name="cBuffer">要写入的字符串。</param>
    <param name="nBytes">
      <paramref name="cBuffer" /> 中要写入的字节数，写入从当前文件指针位置开始。<br/>
      如果未指定 <paramref name="nBytes" />，则使用 SLen(<paramref name="cBuffer" />) 的值。
    </param>
    <returns>
      写入的字节数。<br/>
      如果返回值等于 <paramref name="nBytes" /> + 2，则操作成功。<br/>
      如果返回值小于 <paramref name="nBytes" /> + 2 或为 0，则表示 <paramref name="cBuffer" /> 的长度小于 <paramref name="nBytes" />，或磁盘已满，或发生了其他错误。
    </returns>
    <remarks>
      FWriteLine() 是一个低级文件函数，从字符串缓冲区向打开的文件写入数据。您可以选择写入整个缓冲区或部分缓冲区内容。写入从当前文件位置开始，函数返回实际写入的字节数。
      此函数假定处理原始二进制数据，并不依赖于 SetAnsi() 的状态。相反，FWriteText() 和 FWrite4() 则依赖于 SetAnsi()。
    </remarks>
    <example>
      此示例使用 FWriteLine() 从文件开头开始写入行。<br/>
      回车符/换行符对使返回值增加 2：
      <code language="X#">
        hF := FOpen2("c:\data\sales", FO_READWRITE)
        IF hF != F_ERROR
        &#0009;? FWriteLine(hF, "Line1")&#0009;&#0009;// 7
        &#0009;? FWriteLine(hF, "Line1", 2)&#0009;// 4
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FPutS'>FPuts</seealso>
    <seealso cref='O:XSharp.Core.Functions.FWriteLine3'>FWriteLine3</seealso>
  </fwriteline>

  <fwriteline3>
    <summary>
      将字符串、回车符和换行符写入打开的文件，指定两个强类型参数。
    </summary>
    <param name="ptrHandle">要写入的文件句柄。</param>
    <param name="cBuffer">要写入的字符串。</param>
    <param name="dwBytes">
      从当前文件指针位置开始，要写入 <paramref name="cBuffer" /> 的字节数。
    </param>
    <returns>
      写入的字节数。<br/>
      如果返回值等于 <paramref name="dwBytes" /> + 2，则操作成功。<br/>
      如果返回值小于 <paramref name="dwBytes" /> + 2 或为 0，则表示 <paramref name="cBuffer" /> 的长度小于 <paramref name="dwBytes" />，或磁盘已满，或发生了其他错误。
    </returns>
    <remarks>
      此函数假定处理原始二进制数据，并不依赖于 SetAnsi() 的状态。相反，FWriteText() 和 FWrite4() 则依赖于 SetAnsi()。
    </remarks>
    <example>
      此示例使用 FWriteLine3() 写入 5 个字节。回车符/换行符对使返回值增加 2：
      <code language="X#">
        hF := FOpen2("c:\data\sales", FO_READWRITE)
        IF hF != F_ERROR
        &#0009;? FWriteLine3(hF, "Line1", 5)&#0009;&#0009;//  7
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FPutS3'>FPuts3</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWriteLine'>FWriteLine</seealso>
  </fwriteline3>

  <fwritetext>
    <summary>
      将字符串写入打开的文件，具有 SetAnsi() 依赖性。
    </summary>
    <param name="ptrHandle">要写入的文件句柄。</param>
    <param name="cBuffer">要写入的字符串。</param>
    <param name="nBytes">
      从当前文件指针位置开始，要写入 <paramref name="cBuffer" /> 中的字节数。<br/>
      如果省略，则写入 <paramref name="cBuffer" /> 的整个内容。
    </param>
    <returns>
      写入的字节数。<br/>
      如果返回值等于 <paramref name="nBytes" />，则操作成功。<br/>
      如果返回值小于 <paramref name="nBytes" /> 或为 0，则表示 <paramref name="cBuffer" /> 的长度小于 <paramref name="nBytes" />，或磁盘已满，或发生了其他错误。可以使用 FError() 确定具体错误。
    </returns>
    <remarks>
      FWriteText() 与 FWrite() 相同，只是在 SetAnsi() 为 FALSE 时进行 ANSI 到 OEM 的转换。
    </remarks>
    <example>
      此示例将一个文件的内容复制到另一个文件。
      <code language="X#">
        DEFINE F_BLOCK := 512
        ...
        cBuffer := Space(F_BLOCK)
        // 启用 OEM <paramref name="=" /> ANSI 转换
        SetAnsi(FALSE)
        nInfile := FOpen2("temp.txt", FO_READ)
        nOutfile := FCreate("newfile.txt", FC_NORMAL)
        lDone := FALSE
        DO WHILE !lDone
        &#0009;nBytesRead := FReadText(nInfile, @cBuffer, F_BLOCK)
        &#0009;IF FWriteText(nOutfile, cBuffer) &lt;
        &#0009;&#0009;SLen(cBuffer)
        &#0009;&#0009;? DOSErrString(FError())
        &#0009;&#0009;lDone := TRUE
        &#0009;ELSE
        &#0009;&#0009;lDone := (nBytesRead = 0)
        &#0009;ENDIF
        ENDDO
        FClose(nInfile)
        FClose(nOutfile)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </fwritetext>

  <fwritetext3>
    <summary>
      将缓冲区的内容写入打开的文件，具有 SetAnsi() 依赖性。
    </summary>
    <param name="ptrHandle">要写入的文件句柄。</param>
    <param name="ptrBuffer">指向要写入的缓冲区的指针。</param>
    <param name="dwBytes">
      从当前文件指针位置开始，要写入 <paramref name="ptrBuffer" /> 中的字节数。
    </param>
    <returns>
      写入的字节数。<br/>
      如果返回值等于 <paramref name="dwBytes" />，则操作成功。<br/>
      如果返回值小于 <paramref name="dwBytes" /> 或为 0，则表示 <paramref name="ptrBuffer" /> 的长度小于 <paramref name="dwBytes" />，或磁盘已满，或发生其他错误。可以使用 FError() 确定具体错误。
    </returns>
    <remarks>
      FWriteText3() 与 FWrite3() 相同，仅在 SetAnsi() 为 FALSE 时进行 ANSI 到 OEM 的转换。
    </remarks>
    <example>
      此示例将 PSZ 的内容写入文件。
      <code language="X#">
        LOCAL pszBuff AS PSZ
        LOCAL ptrHandle AS PTR
        pszBuff := "hello" // psz 转换后的数据
        ptrHandle := FOpen2("temp.bin", FO_READWRITE)
        IF ptrHandle != F_ERROR
        &#0009;FWriteText3(ptrHandle, pszBuff, PszLen(pszBuff))
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.Core.Functions.FClose'>FClose</seealso>
    <seealso cref='O:XSharp.Core.Functions.FCreate'>FCreate</seealso>
    <seealso cref='O:XSharp.Core.Functions.FError'>FError</seealso>
    <seealso cref='O:XSharp.Core.Functions.FOpen'>FOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite3'>FWrite3</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </fwritetext3>

  <getamext>
    <summary>
      返回一个字符串，表示12小时格式时间字符串的上午扩展。
    </summary>
    <returns>
    </returns>
    <remarks>
      使用12小时时间格式的时间字符串有一个扩展来指明时间是上午还是下午。GetAMExt() 返回当前的上午时间字符串扩展设置（即在午夜12:00到中午12:00之间的时间）。<br/>
      上午时间字符串的典型扩展是 "AM"，这也是该函数名称的由来。
      上午扩展的初始默认值受 SetInternational() 的影响，您可以参考更多信息。<br/>
      使用 SetAMExt() 来更改此设置的值。
    </remarks>
    <example>
      此示例打开 SetInternational() 标志，导致时间字符串扩展由 Windows 控制面板中的国际设置决定：
      <code language="X#">
        SetInternational(#Windows)
        ? GetAMExt()&#0009;// 返回值因系统而异
        ? GetPMExt()&#0009;// 通常显示 AM 和 PM
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetPMExt'>GetPMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAMExt'>SetAMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAmPm'>SetAMPM</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
  </getamext>

  <getapplocaleid>
    <summary>
      获取运行时在 Windows 排序模式下比较字符串时使用的区域 ID（SetCollation(#Windows)）。
    </summary>
    <returns>
      当前安装的区域设置。
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.SetAppLocaleID'>SetAppLocaleId</seealso>
  </getapplocaleid>

  <getcurpath>
    <summary>
      获取当前 X# 搜索路径以打开文件。
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 GetCurPath() 指定要处理的文件所在的目录：
      <code language="X#">FCreate2(GetCurPath() + "newfile.txt", FC_NORMAL)</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetPath'>SetPath</seealso>
  </getcurpath>

  <getdateformat>
    <summary>
      返回当前的日期格式。
    </summary>
    <returns>
      默认的日期格式，或通过 SetDateFormat() 或 SetDateCountry() 函数定义的自定义日期格式。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例返回默认日期格式：
      <code language="X#">
        FUNCTION Start()
        &#0009;QOut(GetDateFormat())&#0009;// 结果: MM/DD/YY
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetDateCountry'>SetDateCountry</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDateFormat'>SetDateFormat</seealso>
  </getdateformat>

  <getdefault>
    <summary>
      返回 X# 默认的驱动器和目录。
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 GetDefault() 显示默认驱动器：
      <code language="X#">
        FUNCTION Start
        &#0009;? GetDefault()&#0009;&#0009;&#0009;// NULL_STRING
        &#0009;SetDefault("c:\vo\prg")
        &#0009;? GetDefault()&#0009;&#0009;&#0009;// c:\vo\prg\
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetDefault'>SetDefault</seealso>
  </getdefault>

  <getdefaultdir>
    <summary>
      返回当前 SetDefault() 设置。
    </summary>
    <returns>
    </returns>
    <remarks>
      返回当前 SetDefault() 设置。字符串以尾随的 "\" 结尾。
    </remarks>
    <example>
      此示例使用 GetDefaultDir() 显示错误日志文件的位置：
      <code language="X#">
        FUNCTION Start()
        &#0009;? GetDefaultDir()&#0009;&#0009;&#0009;// NULL_STRING
        &#0009;SetDefault("c:\vo\prg")
        &#0009;? GetDefaultDir()&#0009;&#0009;&#0009;// c:\vo\prg
      </code>
    </example>
    <seealso  cref="M:XSharp.Core.Functions.SetDefault">SetDefault</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetErrorLog'>SetErrorLog</seealso>
  </getdefaultdir>

  <getdllmajorversion>
    <summary>
      返回 DLL 的主要版本号
    </summary>
    <param name="cDLL">要读取版本的 DLL 名称</param>
    <returns>
    </returns>
    <remarks>
      返回 DLL 的当前主要版本号
      <br/>
      DLL 必须包含一个名为 DllGetVersion 的函数，该函数填充 _WINDLLVERSIONINFO 结构。此确定 DLL 版本的约定由 Windows DLL（如 Shell32.DLL）遵循。
    </remarks>
    <example>
    </example>
    <seealsocmd>GetShellMajorVersion 函数</seealsocmd>
  </getdllmajorversion>

  <getdoserror>
    <summary>
      返回来自任何应用程序的 DOS 错误代码。
    </summary>
    <returns>
    </returns>
    <remarks>
      GetDOSError() 的值是一个扩展的 DOS 错误代码，永远不会被清除。<br/>
      设置此错误代码的应用程序不需要是当前应用程序，甚至不需要是 X# 应用程序。相比之下，在 X# 应用程序中的每个 DOS 调用中，如果发生错误，DOSError() 的值会设置为当前 DOS 错误，或者在没有错误时清除为 0。
    </remarks>
    <example>
      在这个例子中，DOSError() 指示当前应用程序中的最后一个 DOS 调用没有产生错误。相比之下，GetDOSError() 指示系统中之前发生了一个 DOS 错误：
      <code language="X#">
        ? DOSError()&#0009;&#0009;&#0009;// 0
        ? GetDOSError()&#0009;&#0009;// 2
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.DosError'>DOSError</seealso>
  </getdoserror>

  <getenv>
    <summary>
      检索 DOS 环境变量的内容。
    </summary>
    <param name="cEnvVariable">您要检索的环境变量的名称。 （请注意，GetEnv() 不区分大小写。）</param>
    <returns>
      指定环境变量的内容。<br/>
      如果找不到该变量，GetEnv() 返回 NULL_STRING。
    </returns>
    <remarks>
      GetEnv() 允许您从 DOS 环境中检索信息到应用程序中。通常，这些是配置相关的信息，包括描述文件（数据库、索引、标签或报告）位置的路径名。
      注意：与其使用环境变量配置您的应用程序，不如考虑使用注册表设置。
      <note type="tip">
        空返回值：<br/>
        如果您确定环境变量存在，而 GetEnv() 总是返回 NULL_STRING，请确保在 DOS SET 命令中环境变量名称与其分配的第一个字符之间没有空格。
      </note>
    </remarks>
    <example>
      此示例检索当前的 DOS 路径设置，并将其设为当前 X# 路径：
      <code language="X#">
        cPath := GetEnv("PATH")
        SET PATH TO (cPath)
      </code>
      此示例使用环境变量来配置各种文件的特定位置。当您设置系统时，定义包含各种文件类型位置的环境变量，如下所示：
      <code language="X#">
        C&gt;SET LOC_DBF=<paramref name="DatabaseFilePath" />
        C&gt;SET LOC_NTX=<paramref name="IndexFilePath" />
        C&gt;SET LOC_RPT=<paramref name="ReportFilePath" />
      </code>
      在您的应用程序的配置部分，将环境变量的内容分配给变量。<br/>
      然后，当您访问文件时，使用路径作为前缀，如下所示：
      <code language="X#">
        cDdfDirectory := GetEnv("LOC_DBF")
        USE (cDdfDirectory + "invoices.dbf")
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegInt'>QueryRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegString'>QueryRTRegString</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetEnv'>SetEnv</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegInt'>SetRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegString'>SetRTRegString</seealso>
  </getenv>

  <getfattr>
    <summary>
      将文件属性转换为数字。
    </summary>
    <param name="uAttributes">
      一个或多个以下常量或字符串：<br/>
      &#0009;字符&#0009;常量&#0009;描述<br/>
      &#0009;A&#0009;FC_ARCHIVED&#0009;已归档<br/>
      &#0009;D&#0009;FA_DIRECTORY&#0009;目录<br/>
      &#0009;H&#0009;FC_HIDDEN&#0009;隐藏<br/>
      &#0009;NULL_STRING&#0009;FC_NORMAL&#0009;可读/写<br/>
      &#0009;R&#0009;FC_READONLY&#0009;只读<br/>
      &#0009;S&#0009;FC_SYSTEM&#0009;系统<br/>
      &#0009;V&#0009;FA_VOLUME&#0009;搜索 DOS 卷标签并排除所有其他文件<br/>
      &#0009;要指定多个常量，可以将属性相加，例如 FC_SYSTEM + FC_HIDDEN，或使用 _Or() 操作符，例如 _Or(FC_SYSTEM, FC_HIDDEN)。<br/>
      要指定多个字符串，只需连接它们，例如 "SH."
    </param>
    <returns>
      一个表示指定文件属性的数字。<br/>
      该数字可以表示两个或更多文件属性相加的结果。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 GetFAttr() 返回文件属性作为数字：
      <code language="X#">
        ? GetFAttr(FA_DIRECTORY)&#0009;&#0009;&#0009;&#0009;// 16
        ? GetFAttr(FC_ARCHIVED + FC_READONLY)&#0009;// 33
        ? GetFAttr("AR")&#0009;&#0009;&#0009;&#0009;&#0009;// 33
        // 以下 GetFAttr() 将字符串转换为所需的数字格式
        ? FFirst("*.txt", GetFAttr("H"))
      </code>
    </example>
    <seealsocmd>_Or</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.FAttrib'>FAttrib</seealso>
  </getfattr>

  <getfmask>
    <summary>
      准备一个文件规范，以便进行通配符搜索。
    </summary>
    <param name="cString">驱动器和/或目录和/或文件的名称。</param>
    <returns>
      如果 <paramref name="cString" /> 以 ":" 或 "\" 结尾，则返回修改后的 <paramref name="cString" /> +"*.*"；否则返回 <paramref name="cString" />。
    </returns>
    <remarks>
      如果 <paramref name="cString" /> 以 ":" 或 "\" 结尾，表示 <paramref name="cString" /> 是一个驱动器或目录，则会添加 "*.*"。<br/>
      这使得可以搜索指定驱动器或目录中的所有文件。
    </remarks>
    <example>
      此示例使用 GetFMask() 将通配符搜索添加到传递给 Dir() 和 File() 的参数中。
      <code language="X#">
        LOCAL cOrigin AS STRING
        LOCAL cSearch AS STRING
        cOrigin := "c:"
        cSearch := GetFMask(cOrigin)
        ? cSearch&#0009;&#0009;&#0009;&#0009;&#0009;// c:*.*
        Dir(cSearch)
        File(cSearch)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FFirst'>FFirst</seealso>
  </getfmask>

  <getfolderpath>
    <summary>
      返回文件夹路径作为字符串。
    </summary>
    <param name="nFolder">常量或整数，表示您需要路径的文件夹。</param>
    <param name="CSIDL_PERSONAL"> := 0x0005 // 我的文档</param>
    <param name="CSIDL_MYMUSIC"> := 0x000d // “我的音乐”文件夹</param>
    <param name="CSIDL_APPDATA"> := 0x001A // 应用程序数据，新的NT4版本</param>
    <param name="CSIDL_LOCAL_APPDATA"> := 0x001C // 非漫游，用户\本地设置\应用程序数据</param>
    <param name="CSIDL_INTERNET_CACHE"> := 0x0020</param>
    <param name="CSIDL_COOKIES"> := 0x0021</param>
    <param name="CSIDL_HISTORY"> := 0x0022</param>
    <param name="CSIDL_COMMON_APPDATA"> := 0x0023 // 所有用户\应用程序数据</param>
    <param name="CSIDL_WINDOWS"> := 0x0024 // GetWindowsDirectory()</param>
    <param name="CSIDL_SYSTEM"> := 0x0025 // GetSystemDirectory()</param>
    <param name="CSIDL_PROGRAM_FILES"> := 0x0026 // C:\Program Files</param>
    <param name="CSIDL_MYPICTURES"> := 0x0027 // 我的图片，新的Win2K版本</param>
    <param name="CSIDL_PROGRAM_FILES_COMMON"> := 0x002b // C:\Program Files\Common</param>
    <param name="CSIDL_COMMON_DOCUMENTS"> := 0x002e // 所有用户\文档</param>
    <param name="CSIDL_RESOURCES"> := 0x0038 // %windir%\Resources\, 用于主题和其他Windows资源。</param>
    <param name="CSIDL_RESOURCES_LOCALIZED">
      := 0x0039 // %windir%\Resources\<paramref name="LangID" />，用于主题和其他Windows特定资源。
    </param>
    <param name="CSIDL_COMMON_ADMINTOOLS"> := 0x002f // 所有用户\开始菜单\程序\管理工具</param>
    <param name="CSIDL_ADMINTOOLS"> := 0x0030</param>
    <param name="lCreate">TRUE表示创建指定文件夹，FALSE表示检索</param>
    <param name="hToken">仅在特殊情况下需要。请参见SHGetFolderPath API函数。</param>
    <param name="dwFlags">仅在特殊情况下需要。请参见SHGetFolderPath API函数。</param>
    <returns>
      所请求文件夹的路径作为字符串。
      <br/>
      这需要IE4（Shell 4.71）或更高版本。
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </getfolderpath>

  <getnatdll>
    <summary>
      获取当前用于国家依赖操作和消息的DLL。
    </summary>
    <returns>
      当前国家依赖DLL的名称。
    </returns>
    <remarks>
      国家依赖操作的默认库是VO28NAT.DLL，但您可以使用SetNatDLL()进行更改。GetNatDLL()返回国家依赖DLL的当前设置。
    </remarks>
    <example>
      此示例显示在调用SetNatDLL()之前和之后GetNatDLL()返回值的差异：
      <code language="X#">
        ? GetNatDLL()&#0009;&#0009;&#0009;&#0009;// VO28NAT.DLL
        ? SetNatDLL("GERMAN.DLL")&#0009;&#0009;// .T.
        ? GetNatDLL()&#0009;&#0009;&#0009;&#0009;// GERMAN.DLL
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetNatDLL'>SetNatDLL</seealso>
  </getnatdll>

  <getpmext>
    <summary>
      返回一个字符串，表示12小时制时间字符串的晚上扩展。
    </summary>
    <returns>
    </returns>
    <remarks>
      使用12小时制格式化的时间字符串具有扩展，以指定时间是在早上还是晚上。GetPMExt() 返回当前设置的晚上时间字符串扩展（即在中午12:00:00到午夜12:00:00之前的时间）。<br/>
      晚上时间字符串的典型扩展是 "PM"，这就是该函数名称的来源。
      晚上扩展的初始默认值受 SetInternational() 的影响，您可以参考更多信息。<br/>
      使用 SetPMExt() 来更改该设置的值。
      注意：<br/>
      如果 SetInternational(#Windows) 生效，则晚上扩展也会作为24小时制时间格式的一部分显示。<br/>
      这是Windows标准，不特定于X#。
    </remarks>
    <example>
      此示例打开 SetInternational() 标志，导致时间字符串扩展由Windows控制面板中的国际设置确定：
      <code language="X#">
        SetInternational(#Windows)
        ? GetAMExt()&#0009;&#0009;&#0009;// 返回值因系统而异
        ? GetPMExt()&#0009;&#0009;&#0009;// 通常显示 AM 和 PM
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetAMExt'>GetAMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAmPm'>SetAMPM</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPMExt'>SetPMExt</seealso>
  </getpmext>

  <getshellmajorversion>
    <summary>
      返回 DLL 的主要版本号
    </summary>
    <returns>
    </returns>
    <remarks>
      返回 Windows Shell 的主要版本号，SHELL32.DLL。
    </remarks>
    <example>
    </example>
    <seealsocmd>GetDLLMajorVersion 函数</seealsocmd>
  </getshellmajorversion>

  <getstoragenames>
    <summary>
      填充传递的数组，包含OLE对象存储文件中的存储名称。
    </summary>
    <param name="cFileName">存储文件的名称。</param>
    <param name="cStorages">数组的名称。</param>
    <returns>
      如果成功则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      以下示例来自OLE容器应用程序 \CAVOxx\SAMPLES\OLE\CONT：
      <code language="X#">
        METHOD FileLoad() CLASS ContainerShell
        LOCAL oOle AS DraggableOleObject
        LOCAL oOD AS OpenDialog
        LOCAL aStgNames AS ARRAY
        LOCAL i AS INT
        LOCAL oCont AS Container
        (oOD := OpenDialog{SELF, "*.CDF"}):Show()
        aStgNames := {}
        IF (!EMPTY(oOD:FileName) .and. GetStorageNames(oOD:FileName, aStgNames))
        &#0009;oCont := SELF:FileNew()
        &#0009;oCont:Caption := oOD:FileName
        &#0009;IF (oCont != NULL_OBJECT)
        &#0009;  FOR i:=1 TO ALen(aStgNames)
        &#0009;&#0009;oOle := DraggableOleObject{oCont}
        &#0009;&#0009;IF (oOle:ImportFromStorage(oOD:Filename, aStgNames[i]))
        &#0009;&#0009;oCont:SetupOLEObject(oOle, NIL, TRUE)
        &#0009;  &#0009;ELSE
        &#0009;&#0009;oOle:Destroy()
        &#0009;&#0009;ENDIF
        &#0009;  NEXT
        &#0009;ENDIF
        ENDIF
      </code>
      <br/>
      OLE库
    </example>
    <seealsocmd>DeleteStorage</seealsocmd>
  </getstoragenames>

  <getsystemmessage>
    <summary>
      将系统错误代码转换为文本消息。
    </summary>
    <param name="dwId">一个 DWord 系统错误代码。通常是 GetLastError() 的结果。</param>
    <returns>
      与传入的错误代码相关联的系统消息。
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </getsystemmessage>

  <gettickcountlow>
    <summary>
      获取自 Windows 启动以来经过的 1/10000 秒数。
    </summary>
    <returns>
      自 Windows 上次启动以来经过的 1/10000 秒数（毫秒/10）。
    </returns>
    <remarks>
      由于 DWORD 的范围，经过 5 天后将会发生数字溢出。
    </remarks>
    <example>
      此示例返回自 Windows 启动以来的秒数：
      <code language="X#">
        ? "Windows 已运行",;
        GetTickCountLow()/10000, "秒"
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Seconds'>Seconds</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
  </gettickcountlow>

  <gettimesep>
    <summary>
      返回当前用于时间字符串的分隔字符。
    </summary>
    <returns>
      当前时间分隔符的 ASCII 值（用于分隔时间字符串中的小时、分钟和秒的字符）。由于默认的时间分隔符是冒号（:），因此 GetTimeSep() 默认返回 58。请注意，您可以使用 Chr() 函数将此返回值转换为字符。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 GetTimeSep() 显示当前时间分隔符：
      <code language="X#">
        ? TIME()&#0009;&#0009;&#0009;&#0009;// 08:31:53
        ? GetTimeSep()&#0009;&#0009;&#0009;// 58
        ? CHR(GetTimeSep())&#0009;&#0009;// :
        SetTimeSep(ASC("*"))&#0009;&#0009;// 将时间分隔符设置为 *
        ? TIME()&#0009;&#0009;&#0009;&#0009;// 08*31*56
        ? GetTimeSep()&#0009;&#0009;&#0009;// 42
        ? CHR(GetTimeSep())&#0009;&#0009;// *
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Asc'>Asc</seealso>
    <seealso cref='O:XSharp.Core.Functions.Chr'>Chr</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetTimeSep'>SetTimeSep</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
  </gettimesep>

  <hardcr>
    <summary>
      将字符串中的所有软回车符（Chr(141)）替换为硬回车符（Chr(13)）。
    </summary>
    <param name="cString">要转换的字符串。</param>
    <returns>
    </returns>
    <remarks>
      软回车符是在行换行时由 MemoEdit() 添加的。X# 控制台命令，如 REPORT 和 LABEL FORM，不会自动将软回车符转换为硬回车符；因此，为了显示包含软回车符的长字符串和备忘录字段，您必须进行转换。
    </remarks>
    <example>
      此示例使用 HardCR() 来显示经过 MemoEdit() 自动换行格式化的备忘录字段：
      <code language="X#">
        USE sales NEW
        ? HARDCR(sales-&gt;Notes)
      </code>
      此示例格式化一个字符串：
      <code language="X#">
        ? HARDCR(_Chr(141) + _Chr(10))
        // 结果: _Chr(13) + _Chr(10)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Chr'>Chr</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemoTran'>MemoTran</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrTran'>StrTran</seealso>
  </hardcr>

  <header>
    <summary>
      返回数据库文件头的长度。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      数据库文件头中的字节数。<br/>
      如果没有数据库文件在使用中，Header() 将返回 0。
    </returns>
    <remarks>
      Header() 与 LastRec()、RecSize() 和 DiskSpace() 一起使用，以创建备份文件的过程。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      此示例确定 SALES.DBF 的头部大小：
      <code language="X#">
        USE sales NEW
        QOut(Header())&#0009;&#0009;&#0009;// 结果: 258
      </code>
      此示例定义一个伪函数 DBFSize()，使用 Header()、RecSize() 和 LastRec() 计算当前数据库文件的大小（以字节为单位）：
      <code language="X#">define DBFSize() ((RecSize() * LastRec()) + Header() + 1)</code>
      然后，您可以像使用任何函数一样使用 DBFSize()：
      <code language="X#">
        USE sales NEW
        USE customer NEW
        QOut(DBFSize())
        QOut(Sales-&gt;DBFSize())
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.Core.Functions.DiskSpace'>DiskSpace</seealso>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
    <seealso cref='O:XSharp.RT.Functions.RecSize'>RecSize</seealso>
  </header>

  <hibyte>
    <summary>
      返回一个数字中的高位（最左边）字节。
    </summary>
    <param name="wValue">要获取其高位字节的数字。</param>
    <returns>
    </returns>
    <remarks>
      相关数据可以存储在变量的高位和低位字中。<br/>
      因此，返回一个包含两个字节的字可能比创建和返回一个2元素数组更高效。
    </remarks>
    <example>
      此示例将 HiByte() 和 LoByte() 应用于一个二进制数字。<br/>
      它还将二进制数字的高位和低位部分显示为两个单独的数字：
      <code language="X#">
        bHi := HiByte(0b0000000011111111)
        bLow := LoByte(0b0000000011111111)
        // 高位字节
        ? 0b00000000&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 0
        ? bHi&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 0
        // 低位字节
        ? 0b11111111&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 255
        ? bLow&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 255
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.HiWord'>HiWord</seealso>
    <seealso cref='O:XSharp.Core.Functions.LoByte'>LoByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.LoWord'>LoWord</seealso>
  </hibyte>

  <hiword>
    <summary>
      返回数字中的高位（最左边）字。
    </summary>
    <param name="dwValue">要获取其高位字的数字。</param>
    <returns>
    </returns>
    <remarks>
      相关数据可以存储在变量的高位和低位字中。<br/>
      因此，返回一个包含两个字的双字可能比创建和返回一个2元素数组更高效。<br/>
      此外，许多 Windows API 函数接收 LONGINT 参数。<br/>
      通常，此参数的高位和低位字包含有关窗口及其消息的不同信息。 HiWord() 可用于提取此参数的高位字。
    </remarks>
    <example>
      此示例将 HiWord() 和 LoWord() 应用于一个二进制数字。<br/>
      它还将二进制数字的高位和低位部分显示为两个单独的数字：
      <code language="X#">
        ? HiWord(0b00001000100000011111111100001111)
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;//  2177
        ? LoWord(0b00001000100000011111111100001111)
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 65295
        // 高位部分
        ? 0b0000100010000001&#0009;&#0009;&#0009;&#0009;//  2177
        // 低位部分
        ? 0b1111111100001111&#0009;&#0009;&#0009;&#0009;// 65295
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.HiByte'>HiByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.LoByte'>LoByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.LoWord'>LoWord</seealso>
  </hiword>

  <i2bin>
    <summary>
      将短整型转换为包含 16 位有符号整数的字符串。
    </summary>
    <param name="siValue">要转换的值。小数位数将被截断。</param>
    <returns>
    </returns>
    <remarks>
      I2Bin() 是一个转换函数，用于将短整型转换为 2 字节字符串。典型应用包括以其本地格式读取外部文件类型，然后以压缩的二进制形式保存、读取、解密和传输数值数据，而不是以字符串形式表现。<br/>
      其逆函数是 Bin2I()。
    </remarks>
    <example>
      此示例使用文件函数打开一个数据库文件，并将最新更新的日期写入字节 1-3：
      <code language="X#">
        ptrHandle = FOpen2("sales.dbf", FO_READWRITE)
        // 将最新更新日期转换为整数
        cYear := I2Bin(1990)
        // 使用更高效的 _Chr() 代替 I2Bin()，因为返回值适合一个字节
        cMonth := _Chr(12)
        cDay := _Chr(15)
        // 定位到最新更新的日期
        FSeek(ptrHandle, 1, FS_SET)
        // 仅使用第一个字节写入新的更新日期
        FWrite3(ptrHandle, cYear, 1)
        FWrite3(ptrHandle, cMonth, 1)
        FWrite3(ptrHandle, cDay, 1)
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </i2bin>

  <incollect>
    <summary>
      检查应用程序是否处于垃圾回收阶段。
    </summary>
    <returns>
      如果应用程序正在收集垃圾，则为 TRUE；否则为 FALSE。
    </returns>
    <remarks>
      在 Axit() 方法和注册为在垃圾收集时调用的例程内部，InCollect() 可能为 TRUE。在这种情况下，您应避免更改动态对象或调用 UnregisterAxit() 来终止 Axit() 方法或垃圾收集例程的注册。
    </remarks>
    <example>
      此示例在清除字符串并调用 UnregisterAxit() 之前检查应用程序是否正在进行垃圾收集：
      <code language="X#">
        Method AXIT() CLASS CaptainCautious
        IF !InCollect()
        &#0009;cInstanceVar := ""
        &#0009;UnregisterAxit(SELF)
      </code>
      &#0009;
      <code language="X#">
        ENDIF
        RETURN NIL
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.RegisterAxit'>RegisterAxit</seealso>
    <seealso cref='O:XSharp.RT.Functions.UnRegisterAxit'>UnregisterAxit</seealso>
  </incollect>

  <indexcount>
    <summary>返回当前工作区中打开的索引数量</summary>
  </indexcount>

  <indexext>
    <summary>
      返回由其 RDD 定义的工作区的默认索引文件扩展名。
    </summary>
    <returns>
      一个字符串，指示由其 RDD 定义的工作区的默认索引文件扩展名。
    </returns>
    <remarks>
      此函数仅提供兼容性。<br/>
      获取默认索引文件扩展名的推荐函数是 DBOrderInfo(DBOI_INDEXEXT)。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </indexext>

  <indexhplock>
    <summary>
      返回并可选择更改用于新创建的 .NTX 文件的高性能（HP）锁定方案的设置。
    </summary>
    <param name="lNewSetting">
      TRUE 使用 HP 锁定方案。FALSE 使用由 NewIndexLock() 定义的标准锁定方案。<br/>
      初始默认值为 FALSE，可以通过 WIN.INI 中 X# 部分的 HPLock 条目（1 表示 TRUE，0 表示 FALSE）进行更改。
    </param>
    <returns>
      如果未指定 <paramref name="lNewSetting" />，则 IndexHPLock() 返回当前设置。<br/>
      如果指定了 <paramref name="lNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      默认情况下，此函数为当前工作区设置索引锁定方案。<br/>
      通过在别名表达式中指定，可以使其在未选择的工作区上操作。因此，您可以为每个工作区设置单独的标志。然而，您不能在同一工作区中使用具有不同锁定方案的索引文件。
      此设置仅影响新创建的索引文件。<br/>
      对于现有文件，它没有影响，锁定方案由文件头记录中存储的信息决定。
      注意：<br/>
      此函数仅在使用 DBFNTX RDD 时适用。
      重要提示！<br/>
      如果您的应用程序必须与 Xbase 产品共享数据，无论是同时还是在不同时间，请勿将 IndexHPLock(TRUE) 设置为 TRUE，或在 WIN.INI 中包含 HPLock=1 的设置。这样会使您的 .NTX 文件与这些产品不兼容。
    </remarks>
    <example>
      此示例说明了在对 IndexHPLock() 函数进行多次调用后的状态：
      <code language="X#">
        ? IndexHPLock()&#0009;&#0009;// FALSE（初始设置）
        ? IndexHPLock(TRUE)&#0009;// FALSE（先前设置）
        ? IndexHPLock()&#0009;&#0009;// TRUE（当前设置）
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
  </indexhplock>

  <indexkey>
    <summary>
      返回指定 Order 的关键表达式。
    </summary>
    <param name="nPosition">
       Order 在工作区的 Order 列表中的位置。<br/>
      值为 0 指定控制 Order ，而不考虑其在列表中的实际位置。
    </param>
    <returns>
      指定 Order 的关键表达式。<br/>
      如果没有相应的 Order 或没有打开数据库文件，IndexKey() 将返回 NULL_STRING。
    </returns>
    <remarks>
      此函数仅为兼容性提供。<br/>
      获取 Order 关键表达式的推荐函数是 DBOrderInfo(DBOI_EXPRESSION,, <paramref name="nPosition" />)。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </indexkey>

  <indexord>
    <summary>
      返回控制 Order 在 Order 列表中的位置。
    </summary>
    <returns>
      控制 Order 的位置。<br/>
      值为 0 表示没有打开数据库文件，或者没有控制 Order ，记录以自然顺序访问。
    </returns>
    <remarks>
      此函数仅为兼容性提供。<br/>
      获取控制 Order 位置的推荐函数是 DBOrderInfo(DBOI_NUMBER)。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </indexord>

  <inlist>
    <summary>
      指示系列中的第一个表达式是否在后续中重复。
    </summary>
    <param name="uValue">
      要在列表中查找的值。可以是任何数据类型。
    </param>
    <param name="uValueList">
      用逗号分隔的表达式列表。<br/>
      这些表达式应与 <paramref name="uValue" /> 中的表达式具有相同的数据类型。<br/>
      如果这些表达式中有一个或多个与第一个表达式的类型不同，可能会发生运行时错误，指示数据类型不匹配。
    </param>
    <returns>
      如果第一个表达式与其他列出的表达式中的任何一个匹配，则返回 TRUE；否则返回 FALSE。
    </returns>
    <example>
      此示例使用 InList() 指示每个系列中的第一个表达式是否在后续中重复：
      <code language="X#">
        ? InList("b", "a", "b", "c")&#0009;&#0009;// TRUE
        ? InList("d", "a", "b", "c")&#0009;&#0009;// FALSE
        nJack  := 11
        nQueen := 12
        nKing  := 13
        nAce   := 14
        ? InList(nJack, nQueen, nKing, nAce) &#0009;// FALSE
        ? InList(nJack, nAce, nJack, nQueen, nKing) &#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Instr'>InStr</seealso>
  </inlist>

  <instr>
    <summary>
      指示子串是否包含在字符串中。
    </summary>

    <param name="cSearch">要搜索的子串。</param>
    <param name="cTarget">要在其中搜索的字符串。</param>
    <returns>
      如果找到子串，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      InStr() 是 $ 操作符的强类型版本。
    </remarks>
    <example>
      此示例使用 InStr() 指示特定子串是否是较长字符串的一部分：
      <code language="X#">
        LOCAL cSearch AS STRING
        LOCAL cTarget AS STRING
        cSearch := "Bend"
        cTarget := "Indian Bend Road"
        IF InStr(cSearch, cTarget)
        &#0009;? "找到它"
        END
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.RT.Functions.InList'>InList</seealso>
    <seealso cref='O:XSharp.RT.Functions.InListExact'>InList</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </instr>

  <integer>
    <summary>
      截断或向下取整带小数位的数字为整数。
    </summary>
    <param name="nValue">要截断或向下取整的数字。</param>
    <returns>
      小数点左侧的整数。由于 <paramref name="uValue" /> 和返回值都是 USUAL 数据类型，您不受整数大小的限制。
    </returns>
    <remarks>
      Integer() 通过向下取整数字来将数值转换为整数。注意——这与截断并不相同，除了对于正整数——它不是四舍五入。Integer() 在不需要数字的小数部分的操作中非常有用。
      请注意，浮点数的精度损失可能会显著。<br/>
      例如，您可能不知道一个数字在内部表示为 0.99999999999999999，因为当该数字通过 QOut() 显示或传递给 Str() 函数时，内部四舍五入返回值为 1.0。
      然而，当这样的数字传递给 Integer() 函数时，它的小数部分被截断，返回值为零。<br/>
      如果这不是您所期望的，您可以使用 Round(<paramref name="nValue" />, 0) 代替 Integer()。
      <note type="tip">
        Integer() 与 CA-Clipper 中的 Int() 函数相同，但 INT 在 X# 中是一个保留字。
        在 X# 中，Int() 是一个转换运算符。对于不大于短整型的数字，它产生与 Integer() 相同的结果，并保持与 CA-Clipper 的兼容性。
      </note>
    </remarks>
    <example>
      这些示例演示了对 Integer() 函数的各种调用的结果：
      <code language="X#">
        ? Integer(100.00)&#0009;&#0009;// 100
        ? Integer(.5)&#0009;&#0009;&#0009;// 0
        ? Integer(-100.75)&#0009;&#0009;// -100
        ? Integer(-1.2)&#0009;&#0009;// -1
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Ceil'>Ceil</seealso>
    <seealso cref='O:XSharp.RT.Functions.Floor'>Floor</seealso>
    <seealso cref='O:XSharp.RT.Functions.Frac'>Frac</seealso>
    <seealso cref='O:XSharp.RT.Functions.Round'>Round</seealso>
  </integer>

  <isaccess>
    <summary>
      检查是否可以向对象发送特定的访问方法。
    </summary>
    <param name="oObject">一个对象。</param>
    <param name="symAccess">访问方法名称。</param>
    <returns>
      如果指定的访问方法在指定对象的类中定义，则返回 TRUE；否则返回 FALSE。
      <br/>
      此示例检查 CLASS MyClass 的 x 和 y 是否为真正的实例变量，或是否被访问方法覆盖：
      <code language="X#">
        CLASS MyClass
        &#0009;EXPORT x
        ACCESS y CLASS MyClass
        FUNCTION Start()
        &#0009;LOCAL o AS MyClass
        &#0009;o := MyClass{}
        ?IsAccess(o,#x)&#0009;&#0009;&#0009;// FALSE
        ?IsAccess(o,#y)&#0009;&#0009;&#0009;// TRUE
      </code>
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IsAssign'>IsAssign</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethod'>IsMethod</seealso>
  </isaccess>

  <isalnum>
    <summary>
      确定字符串的左侧字符是否为字母数字。
    </summary>
    <param name="pszString">要检查的字符串。</param>
    <returns>
      如果 <paramref name="pszString" /> 的第一个字符是字母或数字，则返回 TRUE；如果字符串以数字或字母以外的任何字符开头，则返回 FALSE。
    </returns>
    <remarks>
      此功能与国别有关。例如，在美国版本中，字母数字字符是从 '0' 到 '9' 的数字或从 A 到 Z 的大写或小写英文字母。
    </remarks>
    <example>
      这些示例演示了 IsAlNum() 的各种结果：
      <code language="X#">
        ? IsAlNum("AbcDe")&#0009;&#0009;// TRUE
        ? IsAlNum("aBcDE")&#0009;&#0009;// TRUE
        ? IsAlNum("1BCde")&#0009;&#0009;// TRUE
        ? IsAlNum(".Steve")&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsAlpha'>IsAlpha</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsDigit'>IsDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsSpace'>IsSpace</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsXDigit'>IsXDigit</seealso>
  </isalnum>

  <isalpha>
    <summary>
      确定字符串的左侧字符是否为字母。
    </summary>
    <param name="pszString">要检查的字符串。</param>
    <returns>
      如果 <paramref name="pszString" /> 的第一个字符是字母，则返回 TRUE；如果字符串以数字或任何其他非字母字符开头，则返回 FALSE。
    </returns>
    <remarks>
      此功能与国别有关。例如，在美国版本中，字母字符是从 A 到 Z 的任何大写或小写英文字母。
    </remarks>
    <example>
      这些示例演示了 IsAlpha() 的各种结果：
      <code language="X#">
        ? IsAlpha("Carl")&#0009;&#0009;&#0009;// TRUE
        ? IsAlpha("aBcDE")&#0009;&#0009;// TRUE
        ? IsAlpha("1BCde")&#0009;&#0009;// TRUE
        ? IsAlpha("..Flemming")&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsAlNum'>IsAlNum</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsDigit'>IsDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
  </isalpha>

  <isappthemed>
    <summary>
      返回当前应用程序的主题设置。
    </summary>
    <returns>
      报告当前应用程序的用户界面是否使用视觉样式。视觉样式可以在控制面板中关闭，因此应用程序可以支持视觉样式，但在某个时刻没有应用视觉样式。
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </isappthemed>

  <isarray>
    <summary>
      确定一个值是否为数组。
    </summary>
    <param name="uValue">要检查的值。</param>
    <returns>
      如果值是数组，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 IsArray() 确定采取的行动:
      <code language="X#">
        DO CASE
        &#0009;CASE IsArray(uValue)
        &#0009;&#0009;AEval(uValue, cbBlock)
        &#0009;CASE IsString(uValue)
        &#0009;&#0009;SEval(uValue, cbBlock)
        &#0009;OTHERWISE
        &#0009;&#0009;Eval(cbBlock)
        ENDCASE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsClass'>IsClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsCodeBlock'>IsCodeBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsInstanceOfUsual'>IsInstanceOfUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </isarray>

  <isassign>
    <summary>
      检查是否可以向对象发送特定的赋值方法。
    </summary>
    <param name="oObject">一个对象。</param>
    <param name="symAssign">赋值方法名称。</param>
    <returns>
      如果指定的赋值方法在指定对象的类中定义，则返回 TRUE；否则返回 FALSE。
      <br/>
      此示例检查 CLASS MyClass 的 x 和 y 是否为真正的实例变量，或是否被赋值方法覆盖：
      <code language="X#">
        CLASS MyClass
        &#0009;EXPORT x
        ASSIGN y(a) CLASS MyClass
        FUNCTION Start()
        &#0009;LOCAL o AS MyClass
        &#0009;o := MyClass{}
        ?IsAssign(o,#x)&#0009;&#0009;&#0009;// FALSE
        ?IsAssign(o,#y)&#0009;&#0009;&#0009;// TRUE
      </code>
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IsAccess'>IsAccess</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethod'>IsMethod</seealso>
  </isassign>

  <isbdigit>
    <summary>
      确定字符串的左侧字符是否为二进制数字（0或1）。
    </summary>
    <param name="pszString">要检查的字符串。</param>
    <returns>
      如果字符串的第一个字符是0或1，则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      这些示例演示了 IsBDigit() 的各种结果：
      <code language="X#">
        ? IsBDigit("AbcDe")&#0009;&#0009;// FALSE
        ? IsBDigit("1abcd")&#0009;&#0009;// TRUE
        ? IsBDigit("012345")&#0009;// TRUE
        ? IsBDigit("21345")&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsAlpha'>IsAlpha</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsDigit'>IsDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsXDigit'>IsXDigit</seealso>
  </isbdigit>

  <isclass>
    <summary>
      确定类是否存在。
    </summary>
    <param name="symClassName">要检查的类的符号。</param>
    <returns>
      如果类存在，则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例显示 IsClass() 对声明的类名返回 TRUE：
      <code language="X#">
        CLASS Cars&#0009;&#0009;&#0009;// 声明一个名为 Cars 的类
        ? IsClass(#Cars)&#0009;&#0009;// TRUE
      </code>
      此示例使用 IsClass() 决定如何操作颜色：
      <code language="X#">
        LOCAL uColor AS USUAL
        IF IsClass(#CustomPalette)
        &#0009;uColor := CustomPalette{}
        ELSE
        &#0009;uColor := SetColor()
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsClassOf'>IsClassOf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsCodeBlock'>IsCodeBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
  </isclass>

  <isclassof>
    <summary>
      确定一个类是否是另一个类的子类。
    </summary>
    <param name="symClassName">要检查的类的符号。</param>
    <param name="symSuperClassName">要检查的超类的符号。</param>
    <returns>
      如果 <paramref name="symClassName" /> 继承自 <paramref name="symSuperClassName" />，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      以下示例展示了查询 IsClassOf() 的结果：
      <code language="X#">
        CLASS A
        CLASS B INHERIT A
        CLASS C
        FUNCTION CheckClasses()
        ? IsClassOf(#B, #A)      // TRUE
        ? IsClassOf(#B, #C)      // FALSE
        ? IsClassOf(#C, #A)      // FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IsClass'>IsClass</seealso>
  </isclassof>

  <iscodeblock>
    <summary>
      确定一个值是否为代码块。
    </summary>
    <param name="uValue">要检查的值。</param>
    <returns>
      如果该值是代码块则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      IsCodeBlock() 识别运行时和编译时的代码块作为代码块。<br/>
      而 UsualType() 则将运行时代码块视为对象。
    </remarks>
    <example>
      此示例使用 IsCodeBlock() 和 UsualType() 对运行时代码块进行检查：
      <code language="X#">
        LOCAL cbRunTime
        // 在运行时创建代码块
        cbRunTime := &amp;("{||TRUE}")
        ? UsualType(cbRunTime)&#0009;&#0009;&#0009;&#0009;// OBJECT
        ? IsCodeBlock(cbRunTime)&#0009;&#0009;&#0009;&#0009;// TRUE
      </code>
      此示例使用 IsCodeBlock() 和 UsualType() 对编译时代码块进行检查：
      <code language="X#">
        LOCAL cbCompileTime
        // 编译时已知的代码块
        cbCompileTime := {||TRUE}
        ? UsualType(cbCompileTime)&#0009;&#0009;&#0009;// CODEBLOCK
        ? IsCodeBlock(cbCompileTime)&#0009;&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsClass'>IsClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </iscodeblock>

  <isdate>
    <summary>
      确定值是否为日期（DATE）。
    </summary>
    <param name="uValue">要检查的值。</param>
    <returns>
      如果值是日期数据类型，则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 IsDate() 来确定是否需要进行数据转换：
      <code language="X#">
        IF IsString(uValue)
        &#0009;uValue := CToD(uValue)
        ELSEIF !IsDate(uValue)
        &#0009;uValue := Today()
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </isdate>

  <isdigit>
    <summary>
      确定字符串的左侧字符是否为数字（即 0 到 9 之间的数字）。
    </summary>
    <param name="pszString">要检查的字符串。</param>
    <returns>
      如果字符串的第一个字符是从 0 到 9 的数字，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      IsDigit() 在您需要知道当前字符串是否为数字之前很有用，以便使用 Val() 函数将其转换为数字值。
    </remarks>
    <example>
      这些示例演示了 IsDigit() 的各种结果：
      <code language="X#">
        ? IsDigit("AbcDe")&#0009;&#0009;&#0009;&#0009;// FALSE
        ? IsDigit("1abcd")&#0009;&#0009;&#0009;&#0009;// TRUE
        ? IsDigit(".12345")&#0009;&#0009;&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsAlpha'>IsAlpha</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsBDigit'>IsBDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsXDigit'>IsXDigit</seealso>
  </isdigit>

  <isfloat>
    <summary>
      确定值是否为浮点数（FLOAT）。
    </summary>
    <param name="uValue">要检查的值。</param>
    <returns>
      如果值是FLOAT数据类型，则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用IsFloat()来确定如何格式化数字数据以便显示：
      <code language="X#">
        IF IsFloat(uValue)
        &#0009;nDecimal := 2
        ELSE
        &#0009;nDecimal := 0
        ENDIF
        ? Str(uValue, 10, nDecimal)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </isfloat>

  <isinstanceof>
    <summary>
      确定对象是否为特定类的实例。
    </summary>
    <param name="oObject">要检查的对象。</param>
    <param name="symClassName">要检查的类的符号。</param>
    <returns>
      如果 <paramref name="oObject" /> 是 <paramref name="symClassName" /> 的实例，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      继承类的实例也是原始（超）类的实例。然而，超类的实例不是其任何继承类的实例。
      IsInstanceOf() 类似于 CheckInstanceOf()，但如果指定的对象不是指定类的实例，它不会生成错误消息。
    </remarks>
    <example>
      这些示例说明了 IsInstanceOf() 在继承类上的用法：
      <code language="X#">
        CLASS Employee
        &#0009;EXPORT name, age
        CONSTRUCTOR(tName, tAge)
        &#0009;name := tName
        &#0009;age := tAge
        END CLASS
        CLASS Programmer INHERIT Employee
        END CLASS
        CLASS Assembler INHERIT Programmer
        END CLASS
        FUNCTION CheckArgument()
        &#0009;LOCAL x, y AS OBJECT
        &#0009;x := Employee{"John", "25"}
        &#0009;y := Assembler{"Bill", "30"}
        &#0009;? IsInstanceOf(x, #Employee)&#0009;&#0009;// TRUE
        &#0009;? IsInstanceOf(x, #Programmer)&#0009;&#0009;// FALSE
        &#0009;? IsInstanceOf(x, #Assembler)&#0009;&#0009;// FALSE
        &#0009;? IsInstanceOf(y, #Employee)&#0009;&#0009;// TRUE
        &#0009;? IsInstanceOf(y, #Programmer)&#0009;&#0009;// TRUE
        &#0009;? IsInstanceOf(y, #Assembler)&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CheckInstanceOf'>CheckInstanceOf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsInstanceOfUsual'>IsInstanceOfUsual</seealso>
  </isinstanceof>

  <isinstanceofusual>
    <summary>
      确定 USUAL 中的对象是否为某个类的实例。
    </summary>
    <param name="uObject">包含要检查的对象的 USUAL 类型。</param>
    <param name="symClassName">类的符号表示。</param>
    <returns>
      如果 <paramref name="uObject" /> 是 <paramref name="symClassName" /> 的实例，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      IsInstanceOfUsual() 用于确定多态值 <paramref name="uObject" /> 是否属于符号为 <paramref name="symClassName" /> 的类。<br/>
      继承类的实例也是原始（超）类的实例。然而，超类的实例不是其任何继承类的实例。
      IsInstanceOfUsual() 与以下内容相同：UsualType(<paramref name="uObject" />) = OBJECT .AND. IsInstanceOf(<paramref name="uObject" />, <paramref name="symClassName" />)。因此，在不知道变量是否为对象的情况下应使用它，而不是 IsInstanceOf()。
      IsInstanceOfUsual() 也类似于 CheckInstanceOf()，但如果指定的对象不是指定类的实例，它不会生成错误消息。
    </remarks>
    <example>
      此示例使用 IsInstanceOfUsual() 检查 USUAL 变量是否是特定类的对象：
      <code language="X#">
        CLASS Cars
        &#0009;EXPORT Wheels
        LOCAL uMercedes
        uMercedes := Cars{}
        ? IsInstanceOfUsual(uMercedes, #Cars)&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CheckInstanceOf'>CheckInstanceOf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsInstanceOf'>IsInstanceOf</seealso>
  </isinstanceofusual>

  <iskanji>
    <summary>
      确定字符串的第一个字符是否为汉字。
    </summary>
    <param name="cMBTarget">要检查的字符串。</param>
    <returns>
      如果 <paramref name="cMBTarget" /> 的第一个字符是汉字，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.DBToSB'>DBToSB</seealso>
    <seealso cref='O:XSharp.VO.Functions.ToJNum'>ToJNum</seealso>
    <seealso cref='O:XSharp.VO.Functions.SBTODB'>SBToDB</seealso>
  </iskanji>

  <islogic>
    <summary>
      确定一个值是否为逻辑值。
    </summary>
    <param name="uValue">要检查的值。</param>
    <returns>
      如果值是 LOGIC 数据类型，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 IsLogic() 显示调查的可能结果：
      <code language="X#">
        IF IsLogic(uValue)
        &#0009;IF uValue
        &#0009;&#0009;? "回答是"
        &#0009;ELSE
        &#0009;&#0009;? "回答否"
        &#0009;ENDIF
        ELSEIF IsNil(uValue)
        &#0009;? "未回应"
        ELSE
        &#0009;? "其他回应或传输错误"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </islogic>

  <islong>
    <summary>
      确定值是否为 LONGINT。
    </summary>
    <param name="uValue">要检查的值。</param>
    <returns>
      如果值是 LONGINT 数据类型，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 IsLong() 来确定适当的转换函数：
      <code language="X#">
        IF IsLong(uValue)
        &#0009;cTransmit := L2Bin(uValue)
        ELSEIF IsFloat(uValue)&#0009;
        &#0009;cTransmit := F2Bin(uValue)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </islong>

  <islower>
    <summary>
      确定字符串的左侧字符是否为小写字母。
    </summary>
    <param name="pszString">要检查的字符串。</param>
    <returns>
      如果字符串的第一个字符是小写字母，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      IsLower() 是 IsUpper() 的逆函数，后者确定一个字符是否以大写字母开头。
      IsLower() 和 IsUpper() 与 Lower() 和 Upper() 函数相关，这些函数实际上将小写字符转换为大写，反之亦然。
      此功能与国别有关。
    </remarks>
    <example>
      这些示例演示了 IsLower() 的各种结果：
      <code language="X#">
        ? IsLower("aBcDe")&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
        ? IsLower("AbcDe")&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        ? IsLower("1abcd")&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        ? IsLower("abcd")&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsAlpha'>IsAlpha</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsDigit'>IsDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.Lower'>Lower</seealso>
    <seealso cref='O:XSharp.Core.Functions.Upper'>Upper</seealso>
  </islower>

  <ismethod>
    <summary>
      检查特定方法是否可以发送到对象。
    </summary>
    <param name="oObject">一个对象。</param>
    <param name="symMethod">方法名称，不带括号。</param>
    <returns>
      如果指定的方法在指定对象的类中定义，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 IsMethod() 检查对象是否能够发出声音：
      <code language="X#">
        CLASS Animal
        &#0009;EXPORT sound, weight
        CONSTRUCTOR(s, w)
        &#0009;sound := s
        &#0009;weight := w
        METHOD Speaks CLASS
        &#0009;QOut(sound)
        END CLASS

        CLASS Programmer
        &#0009;EXPORT language
        CONSTRUCTOR(lang)
        &#0009;language := lang
        METHOD Speaks
        &#0009;QOut(language)
        &#0009;QOut("Hello World")
        &#0009;QOut(Chr(7))
        END CLASS
        Function Start()
        &#0009;LOCAL dog AS Animal
        &#0009;LOCAL hacker AS Programmer
        &#0009;dog := Animal{"Bark Bark!", 50}
        &#0009;hacker := Programmer{"VO"}
        &#0009;IF IsMethod(dog, #Speaks)
        &#0009;&#0009;dog:Speaks()&#0009;// 说：Bark Bark
        &#0009;ENDIF
        &#0009;IF IsMethod(hacker, #Speaks)
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 说：VO，Hello World，响起铃声
        &#0009;&#0009;hacker:Speaks()&#0009;
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CheckInstanceOf'>CheckInstanceOf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethodClass'>IsMethodClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethodUsual'>IsMethodUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.NoMethod'>NoMethod</seealso>
  </ismethod>

  <ismethodclass>
    <summary>
      检查特定方法是否可以发送到类。
    </summary>
    <param name="symClass">类名的符号。</param>
    <param name="symMethod">方法名称，不带括号。</param>
    <returns>
      如果指定的方法在指定对象的类中定义，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 IsMethodClass() 检查类是否能够发出声音：
      <code language="X#">
        CLASS Animal
        &#0009;EXPORT sound, weight
        CONSTRUCTOR(s, w)
        &#0009;sound := s
        &#0009;weight := w
        METHOD Speaks
        &#0009;QOut(sound)
        END CLASS
        CLASS Programmer
        &#0009;EXPORT language
        CONSTRUCTOR(lang)
        &#0009;language := lang
        METHOD Speaks
        &#0009;QOut(language)
        &#0009;QOut("Hello World")
        &#0009;QOut(Chr(7))
        END CLASS

        Function Start()
        &#0009;LOCAL dog AS Animal
        &#0009;LOCAL hacker AS Programmer
        &#0009;dog := Animal{"Bark Bark!", 50}
        &#0009;hacker := Programmer{"VO"}
        &#0009;IF IsMethodClass(#Animal, #Speaks)
        &#0009;&#0009;dog:Speaks()&#0009;&#0009;&#0009;&#0009;// 说：Bark Bark
        &#0009;ENDIF
        &#0009;IF IsMethodClass(#Programmer, #Speaks)
        &#0009;&#0009;hacker:Speaks()&#0009;&#0009;&#0009;// 说：VO
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 说：Hello World
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 响起铃声
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CheckInstanceOf'>CheckInstanceOf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethod'>IsMethod</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethodUsual'>IsMethodUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.NoMethod'>NoMethod</seealso>
  </ismethodclass>

  <ismethodusual>
    <summary>
      检查特定方法是否可以发送到USUAL中的对象。
    </summary>
    <param name="uObject">包含对象的USUAL。</param>
    <param name="symMethod">方法名称，不带括号。</param>
    <returns>
      如果指定的方法在指定对象的类中定义，则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
      IsMethodUsual()用于确定多态值<param name="uObject"/>是否是一个对象，并且该对象有方法<param name="symMethod"/>。IsMethodUsual()等同于以下内容：UsualType(<param name="uObject"/>) = OBJECT .AND. IsMethod(<param name="uObject"/>, <param name="symMethod"/>)。因此，在不确定变量是否为对象的情况下，应使用它而不是IsMethod()。
    </remarks>
    <example>
      此示例使用IsMethodUsual()检查是否可以发送特定方法。<br/>
      如果有对象并且存在特定方法，则调用该方法；否则，调用一个函数：
      <code language="X#">
        IF IsMethodUsual(uO, #GoTop)
        &#0009;uO:GoTop()
        ELSE
        &#0009;MyGoTop()&#0009;
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CheckInstanceOf'>CheckInstanceOf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethod'>IsMethod</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethodClass'>IsMethodClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.NoMethod'>NoMethod</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </ismethodusual>

  <isnil>
    <summary>
      确定一个值是否为NIL。
    </summary>
    <param name="uValue">要检查的值。</param>
    <returns>
      如果值为NIL，则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用IsNil()来确定是否向用户查询文件名：
      <code language="X#">
        FUNCTION GetFile(cFile)
        &#0009;IF IsNil(cFile)
        &#0009;&#0009;? "输入缺失的文件名"
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceNumeric'>EnforceNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsClass'>IsClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </isnil>

  <isnumeric>
    <summary>
      确定一个值是否为数字。
    </summary>
    <param name="uValue">要检查的值。</param>
    <returns>
      如果值为数字，则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
      IsNumeric() 等价于 UsualType(<paramref name="uValue" /> = LONG .OR. UsualType(<paramref name="uValue" /> = FLOAT.
    </remarks>
    <example>
      此示例使用 IsNumeric() 来确定应使用的格式：
      <code language="X#">
        IF IsNumeric(uValue)
        &#0009;? Str3(uValue, 7, 2)
        ELSE
        &#0009;? uValue
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </isnumeric>

  <isobject>
    <summary>
      确定值是否为对象。
    </summary>
    <param name="uValue">要检查的值。</param>
    <returns>
      如果值是对象，则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 IsObject() 来检查是否传递了正确的参数：
      <code language="X#">
        FUNCTION OOpsCheck(uObject) AS LOGIC
        &#0009;LOCAL lSuccess AS LOGIC
        &#0009;LOCAL aObject AS ARRAY
        &#0009;lSuccess := IsObject(uObject)
        &#0009;IF lSuccess
        &#0009;&#0009;// 显示对象内容
        &#0009;&#0009;aObject := Object2Array(uObject)
        &#0009;&#0009;FOR i := UPTO ALen(aObject)
        &#0009;&#0009;&#0009;QOut(aObject[i])
        &#0009;&#0009;NEXT
        &#0009;&#0009;ELSE
        &#0009;&#0009;? "需要对象"
        &#0009;&#0009;ENDIF
        &#0009;RETURN lSuccess
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsClass'>IsClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethodUsual'>IsMethodUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </isobject>

  <isptr>
    <summary>
      确定一个值是否为指针。
    </summary>
    <param name="uValue">要检查的值。</param>
    <returns>
      如果值是指针，则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 IsPtr() 检查是否需要转换为指针：
      <code language="X#">
        IF !IsPtr(uValue)
        &#0009;uValue := Ptr(_CAST, uValue)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </isptr>

  <isspace>
    <summary>
      确定字符串的左侧字符是否为空白（即，Chr(9) 到 Chr(13) 或 Chr(32)）。
    </summary>
    <param name="pszString">要检查的字符串。</param>
    <returns>
      如果第一个字符为空白，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      这些示例演示了 IsSpace() 应用于各种值：
      <code language="X#">
        LOCAL cString2Examine AS STRING
        cString2Examine := Chr(9) + "Hello"
        ? IsSpace(Substr(cString2Examine, 1, 1))&#0009;// TRUE
        ? IsSpace(Substr(cString2Examine, 2, 1))&#0009;// TRUE
        ? IsSpace(Substr(cString2Examine, 3, 1))&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsAlpha'>IsAlpha</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsDigit'>IsDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsXDigit'>IsXDigit</seealso>
  </isspace>

  <isstring>
    <summary>
      确定一个值是否为字符串。
    </summary>
    <param name="uValue">要检查的值。</param>
    <returns>
      如果值是字符串，则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 IsString() 确定是否需要向用户查询文件名：
      <code language="X#">
        FUNCTION TBDemo(cFile)
        &#0009;IF !IsString(cFile)
        &#0009;&#0009;cFile := Space(12)
        &#0009;&#0009;? "输入正确的文件名"
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsString'>AsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </isstring>

  <issymbol>
    <summary>
      确定一个值是否为符号。
    </summary>
    <param name="uValue">要检查的值。</param>
    <returns>
      如果值是符号，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 IsSymbol() 检查变量是否包含符号：
      <code language="X#">
        IF IsSymbol(uValue) .AND.;
        uValue != NULL_SYMBOL
        &#0009;? "符号是" + Symbol2String(uValue)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsSymbol'>AsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsClass'>IsClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethodUsual'>IsMethodUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </issymbol>

  <isupper>
    <summary>
      确定字符串的左侧字符是否为大写字母。
    </summary>
    <param name="pszString">要检查的字符串。</param>
    <returns>
      如果第一个字符是大写字母，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      IsUpper() 是 IsLower() 的逆函数。IsUpper() 和 IsLower() 与 Upper() 和 Lower() 函数相关，这两个函数实际上将大写字符转换为小写，反之亦然。
      此函数与国别有关。
    </remarks>
    <example>
      这些示例演示了 IsUpper() 应用于各种值：
      <code language="X#">
        ? IsUpper("AbCdE")&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
        ? IsUpper("aBCdE")&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        ? IsUpper("$abcd")&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        ? IsUpper("8ABCD")&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsAlpha'>IsAlpha</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsDigit'>IsDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsSpace'>IsSpace</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsXDigit'>IsXDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.Lower'>Lower</seealso>
    <seealso cref='O:XSharp.Core.Functions.Upper'>Upper</seealso>
  </isupper>

  <isvoobject>
    <summary>
      确定给定对象是否为有效的 VO 对象。
    </summary>
    <param name="oObject">要检查的对象。</param>
    <returns>
      如果对象是有效的 VO 对象，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      IsVoObject() 可用于测试任何对象是否符合以下条件 -
      它不检查 -
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.IsVOString'>IsVoString</seealso>
  </isvoobject>

  <isvostring>
    <summary>
      确定给定字符串是否为有效的 VO 字符串。
    </summary>
    <param name="cString">要检查的字符串。</param>
    <returns>
      如果字符串是有效的 VO 字符串，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      IsVoString() 可用于测试任何字符串是否符合以下条件 -
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.IsVOObject'>IsVoObject</seealso>
  </isvostring>

  <isxdigit>
    <summary>
      确定字符串的左侧字符是否为十六进制字符（即，数字1到9和字母A到F）。
    </summary>
    <param name="pszString">要检查的字符串。</param>
    <returns>
      如果第一个字符是十六进制，则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      这些示例演示了 IsXDigit() 应用于各种值：
      <code language="X#">
        ? IsXDigit("3FDE")&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
        ? IsXDigit("hjku")&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsAlpha'>IsAlpha</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsDigit'>IsDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
  </isxdigit>

  <ivarget>
    <summary>
      返回导出实例变量的内容。
    </summary>
    <param name="oObject">包含导出实例变量的对象。</param>
    <param name="symInstanceVar">要获取的导出实例变量。</param>
    <returns>
      <paramref name="symInstanceVar" /> 的值。
    </returns>
    <remarks>
      IVarGet() 返回导出实例变量的内容。<br/>
      此实例变量的符号可以在运行时存储在 <paramref name="symInstanceVar" /> 中。<br/>
      因此，实例变量在编译时并不必已知。<br/>
      类操作符（:）也返回导出实例变量的内容，但实例变量必须在编译时已知。
    </remarks>
    <example>
      此示例使用 IVarGet() 检索导出实例变量的内容。请注意，cTrick 的内容无法通过 IVarGet() 检索，因为它是一个实例变量。
      <code language="X#">
        CLASS GetVars
        &#0009;EXPORT cName
        &#0009;INSTANCE cTrick
        CONSTRUCTOR CLASS GetVars
        &#0009;cName := "Eve"
        &#0009;cTrick := "Apple"
        END CLASS

        FUNCTION Start()
        &#0009;LOCAL oVars AS OBJECT
        &#0009;oVars := GetVars{}
        &#0009;? IVarGet(oVars, #cName)&#0009;&#0009;&#0009;// Eve
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarGetSelf'>IVarGetSelf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IVarPut'>IVarPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarGet'>MemVarGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.VarGet'>VarGet</seealso>
  </ivarget>

  <ivargetinfo>
    <summary>
      获取有关特定实例变量（或访问方法）声明方式的信息。
    </summary>
    <param name="oObject">包含实例变量的对象。</param>
    <param name="symInstanceVar">您要获取信息的实例变量。</param>
    <returns>
      一个数字值，可以解释如下：
      wIvarInfo&#0009;描述&#0009;
      0&#0009;未找到&#0009;
      1&#0009;实例声明&#0009;
      2&#0009;导出声明&#0009;
      3&#0009;访问声明&#0009;
      注意：  保护和隐藏变量无法通过此函数进行测试。
    </returns>
    <remarks>
      IVarGetInfo() 测试给定名称的实例变量或访问方法，并返回一个数字值，指示变量是如何（或是否）声明的。
    </remarks>
    <example>
      此示例说明 IVarGetInfo() 的各种返回值：
      <code language="X#">
        CLASS A
        &#0009;INSTANCE x
        &#0009;EXPORT y
        ACCESS z CLASS A
        FUNCTION Start()
        &#0009;LOCAL o AS A
        &#0009;o := a{}
        ? IVarGetInfo(o,#x)&#0009;&#0009;&#0009;// 1
        ? IVarGetInfo(o,#y)&#0009;&#0009;&#0009;// 2
        ? IVarGetInfo(o,#z)&#0009;&#0009;&#0009;// 3
        ? IVarGetInfo(o,#none)&#0009;&#0009;&#0009;// 0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarPutInfo'>IVarPutInfo</seealso>
  </ivargetinfo>

  <ivargetself>
    <summary>
      返回实例变量的内容。
    </summary>
    <param name="oObject">包含实例变量的对象。</param>
    <param name="symInstanceVar">要获取的实例变量。</param>
    <returns>
      <paramref name="symInstanceVar" /> 的值。
    </returns>
    <remarks>
      IVarGetSelf() 返回特定 EXPORT 或 INSTANCE 变量的内容。<br/>
      函数调用的作用域是 SELF。
    </remarks>
    <example>
      此示例使用 IVarGetSelf() 检索 EXPORT 和 INSTANCE 变量的内容：
      <code language="X#">
        CLASS GetVars
        &#0009;EXPORT cName
        &#0009;INSTANCE cPhone
        &#0009;PROTECT cID
        &#0009;HIDDEN cPassWord
        CONSTRUCTOR CLASS GetVars
        &#0009;cName := "Adam"&#0009;
        &#0009;cPhone := "4460"
        END CLASS

        FUNCTION Start()
        &#0009;LOCAL oVars AS OBJECT
        &#0009;oVars := GetVars{}
        &#0009;? IVarGetSelf(oVars, #cName)&#0009;&#0009;&#0009;// Adam
        &#0009;? IVarGetSelf(oVars, #cPhone)&#0009;&#0009;&#0009;// 4460
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarGet'>IVarGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.IVarPutSelf'>IVarPutSelf</seealso>
    <seealso cref='O:XSharp.RT.Functions.VarGet'>VarGet</seealso>
  </ivargetself>

  <ivarlist>
    <summary>
      将对象的所有实例变量存储到数组中。
    </summary>
    <param name="oObject">包含要存储的实例变量的对象。</param>
    <returns>
      包含 <paramref name="oObject" /> 的所有实例变量和访问方法名称的符号数组。
    </returns>
    <remarks>
      这种转换可以为您提供额外的数据操作灵活性，并可以让您利用强大的数组函数，如 AEval() 和 AScan()。<br/>
      函数调用中的作用域是 SELF。
    </remarks>
    <example>
      此示例使用 IVarList() 将 INSTANCE 和 EXPORT 实例变量存储到数组中。<br/>
      然后打印存储的实例变量。（请注意，密码未存储在数组中，因为它是受保护的实例变量。）
      <code language="X#">
        CLASS Person
        &#0009;EXPORT name
        &#0009;INSTANCE grade
        &#0009;PROTECT password
        CONSTRUCTOR(tname, tgrade, tpassword)
        &#0009;name := tname
        &#0009;grade := tgrade
        &#0009;password := tpassword
        END CLASS

        FUNCTION MakeArray() AS VOID
        &#0009;LOCAL x AS OBJECT
        &#0009;LOCAL a AS ARRAY
        &#0009;x := Person{"Randal", "A", "123"}
        &#0009;a := IVarList(x)
        &#0009;// Print them
        &#0009;FOR i := UPTO ALen(a)
        &#0009;&#0009;QOut(a[i])
        &#0009;NEXT
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// NAME
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// GRADE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IvarListClass'>IVarListClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.MethodList'>MethodList</seealso>
    <seealso cref='O:XSharp.RT.Functions.Object2Array'>Object2Array</seealso>
  </ivarlist>

  <ivarlistclass>
    <summary>
      将类的所有实例变量存储到数组中。
    </summary>
    <param name="symClass">包含要存储的实例变量的类。</param>
    <returns>
      包含 <paramref name="symClass" /> 的所有实例变量和访问方法名称的符号数组。
    </returns>
    <remarks>
      这种转换可以为您提供额外的数据操作灵活性，并可以让您利用强大的数组函数，如 AEval() 和 AScan()。<br/>
      函数调用中的作用域是 SELF。
      注意：此函数不会存储受保护或隐藏的实例变量。
    </remarks>
    <example>
      此示例使用 IVarListClass() 将 INSTANCE 和 EXPORT 实例变量存储到数组中。<br/>
      然后打印存储的实例变量。（请注意，密码未存储在数组中，因为它是受保护的实例变量。）
      <code language="X#">
        CLASS Person
        &#0009;EXPORT name
        &#0009;INSTANCE grade
        &#0009;PROTECT password
        CONSTRUCTOR(tname, tgrade, tpassword)
        &#0009;name := tname
        &#0009;grade := tgrade
        &#0009;password := tpassword
        END CLASS

        FUNCTION MakeArray() AS VOID
        &#0009;LOCAL a AS ARRAY
        &#0009;a := IVarListClass(#Person)
        &#0009;// 打印它们
        &#0009;FOR i := UPTO ALen(a)
        &#0009;&#0009;QOut(a[i])
        &#0009;NEXT
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 名称
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 年级
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IvarList'>IVarList</seealso>
    <seealso cref='O:XSharp.RT.Functions.MethodListClass'>MethodListClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.Object2Array'>Object2Array</seealso>
  </ivarlistclass>

  <ivarput>
    <summary>
      将值分配给导出实例变量。
    </summary>
    <param name="oObject">包含导出实例变量的对象。</param>
    <param name="symInstanceVar">要分配值的导出实例变量。</param>
    <param name="uValue">要分配给导出实例变量的值。</param>
    <returns>
      分配给 <paramref name="symInstanceVar" /> 的值（<paramref name="uValue" />）。
    </returns>
    <remarks>
      IVarPut() 提供了一种通过封装的面向对象编程方法来分配实例变量的值，而不是通过 := 或 = 操作符修改实例变量，从而防止对实例变量的意外修改。
    </remarks>
    <example>
      此示例使用 IVarPut() 将值分配给导出实例变量。
      <code language="X#">
        CLASS GetVars
        &#0009;EXPORT cName
        &#0009;INSTANCE cPhone
        FUNCTION Start()
        &#0009;LOCAL oVars AS OBJECT
        &#0009;oVars := GetVars{}
        &#0009;? IVarPut(oVars, #cName, "VO")&#0009;&#0009;// VO
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarGet'>IVarGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.IVarPutSelf'>IVarPutSelf</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarPut'>MemVarPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.VarPut'>VarPut</seealso>
  </ivarput>

  <ivarputinfo>
    <summary>
      获取有关特定实例变量（或赋值方法）声明方式的信息。
    </summary>
    <param name="oObject">包含实例变量的对象。</param>
    <param name="symInstanceVar">您要获取信息的实例变量。</param>
    <returns>
      一个数字值，可以解释如下：
      wIvarInfo&#0009;描述&#0009;
      0&#0009;未找到&#0009;
      1&#0009;实例声明&#0009;
      2&#0009;导出声明&#0009;
      3&#0009;赋值声明&#0009;
      注意：  保护和隐藏变量无法通过此函数进行测试。
    </returns>
    <remarks>
      IVarPutInfo() 测试给定名称的实例变量或赋值方法，并返回一个数字值，指示变量是如何（或是否）声明的。
    </remarks>
    <example>
      此示例说明 IVarPutInfo() 的各种返回值：
      <code language="X#">
        CLASS A
        &#0009;INSTANCE x
        &#0009;EXPORT y
        ASSIGN z(value) CLASS A
        &#0009;z := value
        &#0009;RETURN value
      </code>
      &#0009;
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL o AS A
        &#0009;o := a{}
        ? IVarPutInfo(o,#x)&#0009;&#0009;&#0009;// 1
        ? IVarPutInfo(o,#y)&#0009;&#0009;&#0009;// 2
        ? IVarPutInfo(o,#z)&#0009;&#0009;&#0009;// 3
        ? IVarPutInfo(o,#none)&#0009;&#0009;&#0009;// 0
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarGetInfo'>IVarGetInfo</seealso>
  </ivarputinfo>

  <ivarputself>
    <summary>
      将值分配给实例变量。
    </summary>
    <param name="oObject">包含实例变量的对象。</param>
    <param name="symInstanceVar">要分配值的实例变量。</param>
    <param name="uValue">要分配给实例变量的值。</param>
    <returns>
      分配给 <paramref name="symInstanceVar" /> 的值（<paramref name="uValue" />）。
    </returns>
    <remarks>
      IVarPutSelf() 将值分配给特定的 EXPORT 或 INSTANCE 变量。
    </remarks>
    <example>
      此示例使用 IVarPutSelf() 为 EXPORT 和 INSTANCE 变量分配值。
      <code language="X#">
        CLASS GetVars
        &#0009;EXPORT cName
        &#0009;INSTANCE cPhone
        &#0009;PROTECT cID
        &#0009;HIDDEN cPassWord
        FUNCTION Start()
        &#0009;LOCAL oVars AS OBJECT
        &#0009;oVars := GetVars{}
        &#0009;? IVarPutSelf(oVars, #cName, "Adam")&#0009;// Adam
        &#0009;? IVarPutSelf(oVars, #cPhone, "4460")&#0009;// 4460
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarGetSelf'>IVarGetSelf</seealso>
    <seealso cref='O:XSharp.RT.Functions.IVarPut'>IVarPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.VarPut'>VarPut</seealso>
  </ivarputself>

  <l2bin>
    <summary>
      将长整型转换为包含32位带符号整数的字符串。
    </summary>
    <param name="liValue">要转换的值。小数位被截断。</param>
    <returns>
    </returns>
    <remarks>
      L2Bin() 是一个转换函数，将长整型转换为4字节字符串。典型应用包括以原生格式读取外部文件类型，然后以压缩的二进制形式而非字符串形式保存、读取、解密和传输数字数据。<br/>
      其逆函数是 Bin2L()。
    </remarks>
    <example>
      此示例创建一个新的二进制文件，然后使用 L2Bin() 将数字值转换为32位二进制并写入文件：
      <code language="X#">
        LOCAL nNumber, ptrHandle
        ptrHandle := FCreate("MyFile", FC_NORMAL)
        FOR nNumber := 1 UPTO 100
        &#0009;FWrite3(ptrHandle, L2BIN(nNumber), 4)
        NEXT
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </l2bin>

  <lastrec>
    <summary>
      返回数据库文件中最后一条记录的编号。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      数据库文件中的物理记录数。过滤或已删除的设置对返回值没有影响。如果没有数据库文件在使用中，LastRec() 将返回 0。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      此示例说明 LastRec()、RecCount() 和 COUNT 之间的关系：
      <code language="X#">
        USE sales NEW
        QOut(LastRec(), RecCount())
        // 结果: 84 84
        SET FILTER TO Salesman = "1001"
        COUNT TO nRecords
        QOut(nRecords, LastRec())&#0009;// 结果: 14 84
      </code>
      此示例使用别名表达式访问未选中工作区中打开的数据库文件中的记录数：
      <code language="X#">
        USE sales NEW
        USE customer NEW
        QOut(LastRec(), Sales-&gt;LastRec())
      </code>
    </example>
    <seealsocmd>COUNT</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbLastRec'>VODBLastRec</seealso>
  </lastrec>

  <left>
    <summary>
      从字符串中提取以第一个字符开始的子字符串。
    </summary>
    <param name="cString">要提取字符的字符串。</param>
    <param name="dwCount">要提取的字符数。</param>
    <returns>
      <paramref name="cString" /> 的左侧 <paramref name="dwCount" /> 个字符。<br/>
      如果 <paramref name="dwCount" /> 为负数或 0，Left() 将返回 NULL_STRING。<br/>
      如果 <paramref name="dwCount" /> 大于字符串的长度，Left() 将返回整个字符串。
    </returns>
    <remarks>
      Left() 与 Substr(<paramref name="cString" />, 1, <paramref name="wCount" />) 相同。
      Left()、Right() 和 Substr() 通常与 At() 和 RAt() 函数一起使用，以在提取之前定位子字符串的第一个和/或最后一个位置。
    </remarks>
    <example>
      此示例从目标字符串的左侧提取前三个字符：
      <code language="X#">? LEFT("ABCDEF", 3)&#0009;&#0009;&#0009;&#0009;&#0009;// ABC</code>
      此示例从字符串的开头提取子字符串，直到第一个逗号出现：
      <code language="X#">
        LOCAL cName := "James, William" AS STRING
        ? LEFT(cName, AT(",", cName))&#0009;&#0009;// James
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.Stuff'>Stuff</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </left>

  <len>
    <summary>
      返回字符串或数组的长度。
    </summary>
    <param name="uValue">
      要测量的字符串或数组。在字符串中，每个字节计为 1，包括嵌入的空字符 (Chr(0))。<br/>
      NULL_STRING 计为 0。在数组中，每个元素计为 1。
    </param>
    <returns>
      <paramref name="uValue" /> 的长度。
    </returns>
    <remarks>
      <note type="tip">
        ALen()、PszLen() 和 SLen() 是 Len() 的强类型版本。
      </note>
    </remarks>
    <example>
      这些示例演示了使用各种参数的 Len()：
      <code language="X#">
        ? LEN("string of characters")&#0009;&#0009;// 20
        ? LEN(NULL_STRING)&#0009;&#0009;&#0009;&#0009;// 0
        ? LEN(CHR(0))&#0009;&#0009;&#0009;&#0009;&#0009;// 1
        LOCAL aTest[10]
        ? LEN(aTest)&#0009;&#0009;&#0009;&#0009;&#0009;// 10
        ? LEN(ArrayNew(5))&#0009;&#0009;&#0009;&#0009;// 5
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AAdd'>AAdd</seealso>
    <seealso cref='O:XSharp.RT.Functions.ALen'>ALen</seealso>
    <seealso cref='O:XSharp.RT.Functions.ASize'>ASize</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszLen'>PszLen</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.SLen'>SLen</seealso>
  </len>

  <lennum>
    <summary>
      返回数字的字符数，包括数字、十进制点和符号。
    </summary>
    <param name="nNum">您想要获取长度的数字。</param>
    <returns>
    </returns>
    <remarks>
      LenNum() 返回数字转换为字符串时所占用的字节数。
    </remarks>
    <example>
      此示例使用 LenNum() 处理各种数字：
      <code language="X#">
        ? LenNum(1234)&#0009;&#0009;&#0009;&#0009;&#0009;// 4
        ? LenNum(1234.56) &#0009;&#0009;&#0009;&#0009;// 7
        ? LenNum(1234.5678) &#0009;&#0009;&#0009;&#0009;// 9
        ? LenNum(-1234.5678) &#0009;&#0009;&#0009;&#0009;// 10
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.RT.Functions.NTrim'>NTrim</seealso>
  </lennum>

  <loadresstring>
    <summary>
      在字符串表中查找标识符并返回其对应的字符串。
    </summary>
    <param name="cDefault">
      如果 <paramref name="nStringID" /> 在指定的字符串表中找不到，则返回的默认字符串。省略此值等同于指定 NULL_STRING。
    </param>
    <param name="nStringID">
      您想查找的唯一整数标识符。<br/>
      该值在通过 RESOURCE...STRINGTABLE 语句声明字符串表时定义。
    </param>
    <param name="xModule">
      包含要执行查找的字符串表的模块。<br/>
      此参数可以指定为字符串，即 .DLL 或 .EXE 文件的名称，或识别模块的 WORD 句柄。<br/>
      如果未指定，LoadResString() 假定字符串表位于当前执行的模块中。<br/>
      &#0009;重要！<br/>
      在 LoadResString() 函数中指定的模块不会自动加载。<br/>
      因此，在调用 LoadResString() 之前，您必须直接引用该模块（例如，通过调用其函数），或使用 Windows API 函数 LoadLibrary() 手动加载该模块。
    </param>
    <returns>
    </returns>
    <remarks>
      LoadResString() 函数允许您轻松地从 X# 应用程序中的字符串表中读取信息。字符串表通过 RESOURCE 语句使用 STRINGTABLE 关键字定义，并由 Windows 资源编译器编译。<br/>
      在 X# 应用程序中，您可以声明任意数量的字符串表资源实体；但是，当应用程序构建时，所有这些都合并到一个单一的字符串表中，允许每个可执行文件或 DLL 中只有一个表。<br/>
      这意味着在应用程序及其库搜索路径中，字符串表资源声明中的字符串标识符必须是唯一的。请注意，但另一个模块（例如 DLL）由应用程序引用，也可以有一个字符串表，这就是 LoadResString() 允许您指定要引用的模块的原因。标识符只需在模块内（即 .EXE 或 .DLL 文件）唯一。
    </remarks>
    <example>
      此示例说明了一种使用字符串表查找对象的 HyperLabel:Caption 属性的技术。<br/>
      使用此技术可以通过将需要翻译的自然语言部分隔离到字符串表中，从而促进应用程序的国际化：
      <code language="X#">
        oDCMyControl:HyperLabel := HyperLabel{#MyControl, ;
        &#0009;LoadResString("&amp;File", MyFileString, MyLanguage),,}
        DEFINE MyFileString := 100
        GLOBAL MyLanguage AS STRING
        METHOD Start() CLASS App
        &#0009;...
        &#0009;IF ...      // 是法语
        &#0009;&#0009;MyLanguage := "MYFRENCH.DLL"
        &#0009;ELSEIF ... // 是德语
        &#0009;&#0009;MyLanguage := "MYGERMAN.DLL"
        &#0009;ENDIF
      </code>
      &#0009;
      <code language="X#">&#0009;RETURN NULL_STRING</code>
      MYFRENCH DLL 字符串表的代码如下：
      <code language="X#">
        DEFINE MyFileString := 100
        RESOURCE French STRINGTABLE
        BEGIN
        &#0009;MyFileString, "&amp;Fichier"
        &#0009;...
        END
      </code>
      MYGERMAN DLL 字符串表的代码如下：
      <code language="X#">
        DEFINE MyFileString := 100
        RESOURCE German STRINGTABLE
        BEGIN
        &#0009;MyFileString, "&amp;Datei"
        &#0009;...
        END
      </code>
    </example>
    <seealsocmd>RESOURCE</seealsocmd>
  </loadresstring>

  <lobyte>
    <summary>
      返回数字中的低位（最右侧）字节。
    </summary>
    <param name="wValue">您想要获取低位字节的数字。</param>
    <returns>
    </returns>
    <remarks>
      相关数据可以存储在变量的高位和低位字中。<br/>
      因此，与其创建并返回一个 2 元素数组，不如返回一个字，其 2 个字节包含单独的信息。
    </remarks>
    <example>
      Windows API 函数 GetVersion() 在高位 WORD 中返回 DOS 版本，在低位 WORD 中返回 Windows 版本。此外，DOS 主版本号在其 WORD 的高位字节中，DOS 次版本号在其 WORD 的低位字节中，Windows 主版本号在其 WORD 的低位字节中，Windows 次版本号在其 WORD 的高位字节中：
      <code language="X#">
        LOCAL dwVersion AS DWORD
        LOCAL wDOS, wWindows AS DWORD
        LOCAL bDOSMinor, bDOSMajor AS BYTE
        LOCAL bWindowsMajor, bWindowsMinor AS BYTE
        dwVersions := GetVersion()
        wDOS :=  HiWord(dwVersions)
        bDOSMajor := HiByte(wDOS)
        bDOSMinor := LoByte(wDOS)
        wWindows := LoWord(dwVersions)
        bWindowsMinor := HiByte(wWindows)
        bWindowsMajor := LoByte(wWindows)
        ? "DOS 主版本号和次版本号是",;
        &#0009; bDOSMajor, bDOSMinor
        // DOS 主版本号和次版本号是 5          0
        ? "Windows 主版本号和次版本号是",;
        &#0009; bWindowsMajor, bWindowsMinor
        // Windows 主版本号和次版本号是 3      10
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.HiByte'>HiByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.HiWord'>HiWord</seealso>
    <seealso cref='O:XSharp.Core.Functions.LoWord'>LoWord</seealso>
  </lobyte>

  <log>
    <summary>
      计算数字值的自然对数。
    </summary>
    <param name="nValue">要转换为自然对数的数字，必须大于0。</param>
    <returns>
      <paramref name="nValue" />的自然对数。<br/>
      如果<nValue />小于或等于0，Log()将生成数字溢出。
    </returns>
    <remarks>
      Log()函数返回以下方程中的x：
      <code language="X#">e^x = y</code>
      其中e是自然对数的底数（大约为2.7183），y是用作Log()参数的数字表达式（即，Log(y) = x）。<br/>
      由于数学舍入，Log()和Exp()返回的值可能不完全一致（即，Exp(Log(n))不一定等于n）。<br/>
      Log()是Exp()的反函数。
    </remarks>
    <example>
      这些示例演示了Log()的各种结果：
      <code language="X#">
        ? Log(10)&#0009;&#0009;&#0009;&#0009;&#0009;// 2.30
        ? Log(10 * 2)&#0009;&#0009;&#0009;&#0009;// 3.00
        ? Exp(Log(1))&#0009;&#0009;&#0009;&#0009;// 1.00
        ? Log(2.71)&#0009;&#0009;&#0009;&#0009;&#0009;// 1.00
      </code>
      这个示例是一个返回以10为底的对数的函数：
      <code language="X#">
        FUNCTION MyLog10(nNumber)
        &#0009;IF nNumber &gt; 0
        &#0009;&#0009;RETURN Log(nNumber)/Log(10)
        &#0009;ELSE
        &#0009;&#0009;RETURN 0
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Exp'>Exp</seealso>
    <seealso cref='O:XSharp.RT.Functions.Log10'>Log10</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pow'>Pow</seealso>
  </log>

  <log10>
    <summary>
      计算数字值的常用对数。
    </summary>
    <param name="nValue">要转换为其常用对数的数字，必须大于0。</param>
    <returns>
      <paramref name="nValue" />的常用对数。<br/>
      如果<paramref name="nValue" />小于或等于0，Log10()将生成运行时错误。
    </returns>
    <remarks>
      Log10()是幂（以10为底）运算符（**或^）的反函数。<br/>
      常用对数的底数为10。<br/>
      Log10()函数返回以下方程中的x：<br/>
      <code language="X#">10^x = y</code>
      其中y是用作Log10()参数的数字表达式（即，Log10(y) = x）。<br/>
      由于数学舍入，Log10()和幂运算符（**或^）返回的值可能不完全一致（即，10^(Log10(n))不一定等于n）。
    </remarks>
    <example>
      这些示例演示了Log10()的各种结果：
      <code language="X#">
        ? Log10(10)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 1.00
        ? Log10(10 ^ 2)&#0009;&#0009;&#0009;&#0009;&#0009;// 2.00
        ? 10 ^(Log10(1))&#0009;&#0009;&#0009;&#0009;&#0009;// 1.00
        ? 10 ^(Log10(10))&#0009;&#0009;&#0009;&#0009;&#0009;// 10.00
        ? Log10(1000)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 3.00
        ? Log10(1100.9)&#0009;&#0009;&#0009;&#0009;&#0009;// 3.04
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Exp'>Exp</seealso>
    <seealso cref='O:XSharp.RT.Functions.LOG'>Log</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pow'>Pow</seealso>
  </log10>

  <logic2bin>
    <summary>
      将逻辑值转换为包含 8 位逻辑值的字符串。
    </summary>
    <param name="lValue">要转换的逻辑值。</param>
    <returns>
    </returns>
    <remarks>
      Logic2Bin() 是一个转换函数，将逻辑数据类型转换为 1 字节的字符串。典型应用包括以其原生格式保存数据、数据解密以及以二进制形式传输逻辑数据。<br/>
      它的逆函数是 Bin2Logic()。
    </remarks>
    <example>
      此示例创建一个新的二进制文件，然后以二进制形式写入逻辑值：
      <code language="X#">
        LOCAL ptrHandle AS PTR
        ptrHandle := FCreate("MyFile", FC_NORMAL)
        FWrite3(ptrHandle, Logic2Bin(TRUE), 1)
        FClose(ptrHandle)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTOC'>LToC</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </logic2bin>

  <longjmp>
    <summary>
      恢复堆栈环境并将控制权返回到与之前的 SetJmp() 调用相对应的点。
    </summary>
    <param name="strucMark">一个结构体，其中存储了之前调用 SetJmp() 时的环境。</param>
    <param name="siValue">
      出现在之前的 SetJmp() 调用中返回的值。<br/>
      该值不应为 0。<br/>
      如果它为 0，LongJmp() 将替换为 1。
    </param>
    <returns>
    </returns>
    <remarks>
      LongJmp() 恢复之前通过调用 SetJmp() 保存的堆栈环境，然后跳转到 SetJmp() 的返回地址。执行将在 SetJmp() 之后的点恢复，因此似乎 <paramref name="siValue" /> 只是从 SetJmp() 返回。
      SetJmp() 和 LongJmp() 提供了一种机制，允许你跳转到特定的代码行。<br/>
      它们通常用于模拟“返回主控”命令或跳转到错误恢复代码。
      必须在调用 LongJmp() 之前调用 SetJmp()。<br/>
      然后，必须在调用 SetJmp() 的例程返回之前调用 LongJmp()。
    </remarks>
    <example>
      此示例显示了 LongJmp() 和 SetJmp() 如何协同工作以保存和恢复堆栈环境：
      <code language="X#">
        STATIC GLOBAL strucMark IS _JMP_BUF
        FUNCTION Start()
        &#0009;LOCAL siJMPRetVal AS SHORTINT
        &#0009;siJMPRetVal := SetJmp(@strucMark)
        &#0009;IF siJMPRetVal <paramref name="" />0
        &#0009;&#0009;? "LongJmp() 在这里，值为", siJMPRetVal
        &#0009;&#0009;RETURN FALSE
        &#0009;ENDIF
        &#0009;IF .NOT. File("voerror.log")
        &#0009;&#0009;LongJmp(@strucMark, 1)
        &#0009;ENDIF
        &#0009;SubFunc()
        &#0009;RETURN TRUE
        FUNCTION SubFunc()
        &#0009;LOCAL cLog AS STRING
        &#0009;cLog := MemoRead("voerror.log")
        &#0009;IF SLen(cLog) = MAX_ALLOC
        &#0009;&#0009;LongJmp(@strucMark, 2)
        &#0009;ENDIF
        &#0009;RETURN 0
      </code>
    </example>
    <seealsocmd>SetJmp</seealsocmd>
  </longjmp>

  <lower>
    <summary>
      将字符串中的大写和混合大小写字符转换为小写。
    </summary>
    <param name="cString">要转换为小写的字符串。</param>
    <returns>
      <paramref name="cString" /> 中的所有字母字符都被转换为小写。<br/>
      其他字符保持与原始字符串相同。
    </returns>
    <remarks>
      Lower() 与 Upper() 相关，它将小写和混合大小写字符串转换为大写。Lower() 还与 IsLower() 和 IsUpper() 相关，这两个函数确定字符串是以小写字母还是大写字母开头。
      Lower() 通常用于格式化字符串以便于显示。<br/>
      然而，它也可以用于归一化字符串以进行不区分大小写的比较或索引目的。
      此函数与国别有关。
    </remarks>
    <example>
      这些示例演示了 Lower() 的各种结果：
      <code language="X#">
        ? Lower("1234 CHARS = ")&#0009;&#0009;// 1234 chars =
        LOCAL cString AS STRING
        cString := "DATA"
        ? Lower(cString)&#0009;&#0009;&#0009;&#0009;// data
        ? cString&#0009;&#0009;&#0009;&#0009;&#0009;// DATA
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.LowerA'>LowerA</seealso>
    <seealso cref='O:XSharp.Core.Functions.Upper'>Upper</seealso>
  </lower>

  <lowera>
    <summary>
      将字符串中的大写和混合大小写字符转换为小写，改变参数的内容以及返回值。
    </summary>
    <param name="cString">要转换为小写的字符串。</param>
    <returns>
      <paramref name="cString" /> 中的所有字母字符都被转换为小写。<br/>
      其他字符保持与原始字符串相同。
    </returns>
    <remarks>
      LowerA() 与 Lower() 相同，不同之处在于 LowerA() 同时将原始字符串中的字符和返回值中的字符转换为小写。有关更多信息，请参见 Lower()。
      <note type="tip">
        您可以同时更改多个变量（请参见下面的示例）。
      </note>
    </remarks>
    <example>
      此示例显示了 LowerA() 如何将原始字符串和返回值都转换为小写。与 Lower() 示例中的结果进行比较：
      <code language="X#">
        LOCAL cString AS STRING
        cString := "DATA"
        ? LowerA(cString)&#0009;&#0009;// data
        ? cString&#0009;&#0009;&#0009;&#0009;&#0009;// DATA
      </code>
      此示例显示了如何同时更改多个变量：
      <code language="X#">
        a := "I Change"
        b := a
        LowerA(b)
        ? b &#0009;&#0009;&#0009;&#0009;&#0009;// "i change"
        ? a &#0009;&#0009;&#0009;&#0009;&#0009;// "i change"
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.Lower'>Lower</seealso>
    <seealso cref='O:XSharp.Core.Functions.Upper'>Upper</seealso>
  </lowera>

  <loword>
    <summary>
      返回数字中的低位（最右边）字。
    </summary>
    <param name="dwValue">要获取其低位字的数字。</param>
    <returns>
    </returns>
    <remarks>
      相关数据可以存储在变量的高位和低位字中。<br/>
      因此，返回一个包含两个字的双字可能比创建和返回一个2元素数组更高效。<br/>
      此外，许多 Windows API 函数接收 LONGINT 参数。<br/>
      通常，此参数的高位和低位字包含有关窗口及其消息的不同信息。 LoWord() 可用于提取此参数的低位字。
    </remarks>
    <example>
      此示例将 LoWord() 和 HiWord() 应用于确定像素的坐标。<br/>
      它假设 liParam 被传递到 Windows 回调函数：
      <code language="X#">CRTSetPixel(LoWord(liParam), HiWord(liParam), 0L)</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.HiByte'>HiByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.HiWord'>HiWord</seealso>
    <seealso cref='O:XSharp.Core.Functions.LoByte'>LoByte</seealso>
  </loword>

  <ltoc>
    <summary>
      将逻辑值转换为字符串。
    </summary>
    <param name="lValue">要转换的逻辑值。</param>
    <returns>
    </returns>
    <remarks>
      LToC() 在形成组合索引时非常有用。
    </remarks>
    <example>
      此示例使用 LToC() 将逻辑函数的返回值写入文本文件：
      <code language="X#">FWriteText(ptrHandle, LToC(Deleted()), 1)</code>
      此示例使用 LToC() 形成组合字符串表达式：
      <code language="X#">? LToC(_FIELD-&gt;lRegister) + _FIELD-&gt;cName</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsString'>AsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Logic2Bin'>Logic2Bin</seealso>
  </ltoc>

  <ltrim>
    <summary>
      删除字符串中的前导空格。
    </summary>
    <param name="cString">要修剪的字符串。</param>
    <returns>
      <paramref name="cString" /> 中的前导空格已被删除。<br/>
      如果 <paramref name="cString" /> 是 NULL_STRING 或全空格，LTrim() 返回 NULL_STRING。
    </returns>
    <remarks>
      LTrim() 用于格式化带有前导空格的字符串，例如，使用 Str() 转换为字符串的数字。
      LTrim() 与 RTrim() 相关，后者删除尾随空格，AllTrim() 则删除前导和尾随空格。<br/>
      AllTrim()、LTrim() 和 RTrim() 的反向操作是 PadC()、PadR() 和 PadL() 函数，它们通过用填充字符填充字符串来使其居中、右对齐和左对齐。
    </remarks>
    <example>
      这些示例说明了 LTrim() 如何与其他几个函数一起使用：
      <code language="X#">
        nNumber = 18
        ? Str(nNumber)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 18
        ? SLen(Str(nNumber))&#0009;&#0009;&#0009;&#0009;&#0009;// 10
        ? LTrim(Str(nNumber))&#0009;&#0009;&#0009;&#0009;&#0009;// 18
        ? NTrim(nNumber)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 18
        ? SLen(LTrim(Str(nNumber)))&#0009;// 2
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AllTrim'>AllTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadC'>PadC</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadL'>PadL</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadR'>PadR</seealso>
    <seealso cref='O:XSharp.RT.Functions.NTrim'>NTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Trim'>Trim</seealso>
  </ltrim>

  <lupdate>
    <summary>
      返回数据库文件最后修改和关闭的日期。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      最后更改的日期。<br/>
      如果没有使用数据库文件，LUpdate() 返回 NULL_DATE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      此示例演示了数据库文件的修改日期在文件关闭之前不会更改：
      <code language="X#">
        QOut(TODAY())&#0009;&#0009;&#0009;&#0009;// 结果: 09/01/90
        USE sales NEW
        QOut(LUpdate())&#0009;&#0009;&#0009;// 结果: 08/31/90
        APPEND BLANK
        QOut(LUpdate())&#0009;&#0009;&#0009;// 结果: 08/31/90
        DBCloseAll()
        USE sales NEW
        QOut(LUpdate())&#0009;&#0009;&#0009;// 结果: 09/01/90
      </code>
      此示例使用别名表达式返回未选定工作区中数据库文件的最后修改日期：
      <code language="X#">
        USE sales NEW
        USE customer NEW
        QOut(LUpdate(), Sales-&gt;LUpdate())
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldName'>FieldName</seealso>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
    <seealso cref='O:XSharp.RT.Functions.RecSize'>RecSize</seealso>
  </lupdate>

  <makedword>
    <summary>
      从两个字创建一个 DWORD
    </summary>
    <param name="wLow">您希望在 DWORD 的低字中拥有的数字</param>
    <param name="wHigh">您希望在 DWORD 的高字中拥有的数字</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      <code language="X#">
        ? MakeDword(0x0001, 0x0001) // 65537
        ? MakeDword(0xFFFF, 0xFFFF) // 4294967295
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MakeLong'>MakeLong</seealso>
    <seealso>MakeShort</seealso>
    <seealso cref='O:XSharp.Core.Functions.MakeWord'>MakeWord</seealso>
  </makedword>

  <makelong>
    <summary>
      从两个字创建一个长整型
    </summary>
    <param name="wLow">您希望在长整型的低字中拥有的数字</param>
    <param name="wHigh">您希望在长整型的高字中拥有的数字</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      <code language="X#">
        ? MakeLong(0x0001, 0x0001) // 65537
        ? MakeLong(0xFFFF, 0xFFFF) // -1
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MakeDWord'>MakeDword</seealso>
    <seealso>MakeShort</seealso>
    <seealso cref='O:XSharp.Core.Functions.MakeWord'>MakeWord</seealso>
  </makelong>

  <makeshort>
    <summary>
      从两个字节创建一个短整型
    </summary>
    <param name="bLow">您希望在短整型的低字节中拥有的数字</param>
    <param name="bHigh">您希望在短整型的高字节中拥有的数字</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      <code language="X#">
        ?  MakeShort(0x01, 0x01) // 256
        ?  MakeShort(0xFF, 0xFF) // -1
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MakeDWord'>MakeDword</seealso>
    <seealso cref='O:XSharp.Core.Functions.MakeLong'>MakeLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.MakeWord'>MakeWord</seealso>
  </makeshort>

  <makeword>
    <summary>
      从两个字节创建一个字
    </summary>
    <param name="bLow">您希望在字的低字节中拥有的数字</param>
    <param name="bHigh">您希望在字的高字节中拥有的数字</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      <code language="X#">
        ?  MakeWord(0x01, 0x01) // 256
        ?  MakeWord(0xFF, 0xFF) // 65535
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MakeDWord'>MakeDword</seealso>
    <seealso cref='O:XSharp.Core.Functions.MakeLong'>MakeLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.MakeShort'>MakeShort</seealso>
  </makeword>

  <massign>
    <summary>
      对存储在指定字符串中的变量名执行赋值。
    </summary>
    <param name="cExp">
      包含您要赋值给 <paramref name="uValue" /> 的变量名的字符串。
    </param>
    <param name="uValue">要赋的值。</param>
    <returns>
      分配的值。
    </returns>
    <remarks>
      MAssign() 是使用宏操作符 (&amp;) 执行赋值的功能等价物。
    </remarks>
    <example>
      以下示例使用 MAssign() 函数执行赋值：
      <code language="X#">
        MEMVAR iValue
        LOCAL cVar AS STRING
        cVar := "iValue"
        MAssign(cVar, 5)&#0009;&#0009;// 与 &amp;cVar := 5 相同
        ? iValue&#0009;&#0009;&#0009;&#0009;&#0009;// 结果: 5
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Evaluate'>Evaluate</seealso>
    <seealso cref='O:XSharp.RT.Functions.MCompile'>MCompile</seealso>
    <seealso cref='O:XSharp.RT.Functions.MExec'>MExec</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrEvaluate'>StrEvaluate</seealso>
  </massign>

  <max>
    <summary>
      返回两个值中的较大者。
    </summary>
    <param name="uValue1">要比较的第一个值。</param>
    <param name="uValue2">
      要比较的第二个值。<br/>
      这必须与 <paramref name="uValue1" /> 的类型相同，但允许不同类型的数字。
    </param>
    <returns>
      两个参数中较大的那个。<br/>
      返回的值与较大参数的类型相同。
    </returns>
    <remarks>
      Max() 的反函数是 Min()，它返回两个表达式中的较小者。
    </remarks>
    <example>
      在以下示例中，Max() 返回两个数字中的较大者：
      <code language="X#">
        ? MAX(99, 100)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 100
        ? MAX(100, 99)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 100
      </code>
      在以下示例中，Max() 比较日期值：
      <code language="X#">
        ? TODAY()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 05/27/93
        ? MAX(TODAY(), TODAY() + 1)&#0009;&#0009;&#0009;// 05/28/93
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Between'>Between</seealso>
    <seealso cref='O:XSharp.RT.Functions.Min'>Min</seealso>
    <seealso cref="O:XSharp.Core.Functions.Max" />
  </max>

  <maxatom>
    <summary>
      确定原子表中的符号数量。
    </summary>
    <returns>
      MaxAtom() 返回最高符号值，告诉您整个系统中使用的原子总数。<br/>
      每当将符号添加到原子表中时，可用空间的数量减少 1，MaxAtom() 的值增加 1。
      请注意，返回值取决于应用程序中的具体情况。<br/>
      例如，如果您在 IDE 中动态执行应用程序，返回值将与运行可执行版本的应用程序时的值不同。
    </returns>
    <remarks>
      MaxAtom() 返回与 Memory(MaxAtom) 相同的值。
    </remarks>
    <example>
      此示例使用 MaxAtom() 打印最高系统值（请注意，实际结果可能会有所不同）：
      <code language="X#">
        ? MaxAtom()&#0009;&#0009;&#0009;&#0009;// 5346
        ? SysAddAtom("First")&#0009;&#0009;// First
        ? MaxAtom()&#0009;&#0009;&#0009;&#0009;&#0009;// 5347
        ? SysAddAtom("Second")&#0009;&#0009;// Second
        ? MaxAtom()&#0009;&#0009;&#0009;&#0009;&#0009;// 5348
        ? Memory(MaxAtom)&#0009;&#0009;&#0009;// 5348
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.Memory'>Memory</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysAddAtom'>SysAddAtom</seealso>
  </maxatom>

  <mballtrim>
    <summary>
      删除字符串中的前导和尾随空格，包括双字节空格。
    </summary>
    <param name="cMBString">要修剪的字符串。</param>
    <returns>
      一个修剪后的字符串，前导和尾随空格已被删除。
    </returns>
    <remarks>
      此函数的功能与 AllTrim() 相同，但它处理包含双字节字符的字符串。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AllTrim'>AllTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLTrim'>MBLTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRTrim'>MBRTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBTrim'>MBTrim</seealso>
  </mballtrim>

  <mbat>
    <summary>
      返回子字符串在字符串中第一次出现的位置 — 子字符串和字符串均可包含双字节字符。
    </summary>
    <param name="cMBSearch">要搜索的子字符串。</param>
    <param name="cMBTarget">要搜索的字符串。（要从特定偏移量开始，请使用 MBAt3()。）</param>
    <returns>
      <paramref name="cMBSearch" /> 在 <paramref name="cMBTarget" /> 中第一次出现的位置。<br/>
      如果未找到 <paramref name="cMBSearch" />，则 MBAt() 返回零。
    </returns>
    <remarks>
      此函数类似于 At()，但它处理包含双字节字符的字符串。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt2'>MBAt2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt3'>MBAt3</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtC'>MBAtC</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtC2'>MBAtC2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtLine'>MBAtLine</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtLine2'>MBAtLine2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLEFT'>MBLeft</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRight'>MBRight</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
  </mbat>

  <mbat2>
    <summary>
      返回子字符串在字符串中第一次出现的位置 — 子字符串和字符串均可包含双字节字符。
    </summary>
    <param name="cMBSearch">要搜索的子字符串。</param>
    <param name="cMBTarget">要搜索的字符串。（要从特定偏移量开始，请使用 MBAt3()。）</param>
    <returns>
      <paramref name="cMBSearch" /> 在 <paramref name="cMBTarget" /> 中第一次出现的位置。<br/>
      如果未找到 <paramref name="cMBSearch" />，则 MBAt2() 返回零。
    </returns>
    <remarks>
      此函数类似于 MBAt()，但返回 WORD 类型。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At2'>At2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt3'>MBAt3</seealso>
  </mbat2>

  <mbat3>
    <summary>
      返回子字符串在字符串中第一次出现的位置，从特定位置开始搜索 — 子字符串和字符串均可包含双字节字符。
    </summary>
    <param name="cMBSearch">要搜索的子字符串。</param>
    <param name="cMBTarget">要搜索的字符串。</param>
    <param name="wOffset">
      在字符串中开始搜索的位置。<br/>
      值为零对应于第一个字节。
    </param>
    <returns>
      <paramref name="cMBSearch" /> 在 <paramref name="cMBTarget" /> 中第一次出现的位置。<br/>
      如果未找到 <paramref name="cMBSearch" />，则 MBAt3() 返回零。
    </returns>
    <remarks>
      此函数与 MBAt() 相同，但允许您指定开始搜索的偏移量。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At3'>At3</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt2'>MBAt2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtC'>MBAtC</seealso>
  </mbat3>

  <mbatc>
    <summary>
      返回子字符串在字符串中第一次出现的位置，不区分大小写 — 子字符串和字符串均可包含双字节字符。
    </summary>
    <param name="cMBSearch">要搜索的子字符串。</param>
    <param name="cMBTarget">要搜索的字符串。</param>
    <returns>
      <paramref name="cMBSearch" /> 在 <paramref name="cMBTarget" /> 中第一次出现的位置。<br/>
      如果未找到 <paramref name="cMBSearch" />，则 MBAtC() 返回零。
    </returns>
    <remarks>
      此函数类似于 AtC()，但处理包含双字节字符的字符串。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AtC'>AtC</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtC2'>MBAtC2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
  </mbatc>

  <mbatc2>
    <summary>
      返回子字符串在字符串中第一次出现的位置，不区分大小写 — 子字符串和字符串均可包含双字节字符。
    </summary>
    <param name="cMBSearch">要搜索的子字符串。</param>
    <param name="cMBTarget">要搜索的字符串。</param>
    <returns>
      <paramref name="cMBSearch" /> 在 <paramref name="cMBTarget" /> 中第一次出现的位置。<br/>
      如果未找到 <paramref name="cMBSearch" />，则 MBAtC2() 返回零。
    </returns>
    <remarks>
      此函数类似于 MBAtC()，但返回 WORD 类型。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AtC2'>AtC2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtC'>MBAtC</seealso>
  </mbatc2>

  <mbatline>
    <summary>
      返回子字符串在多行字符串中第一次出现的行号 — 子字符串和字符串均可包含双字节字符。
    </summary>
    <param name="cMBSearch">要搜索的子字符串。</param>
    <param name="cMBTarget">要搜索的字符串。</param>
    <returns>
      <paramref name="cMBSearch" /> 在 <paramref name="cMBTarget" /> 中第一次出现的位置。<br/>
      如果未找到 <paramref name="cMBSearch" />，则 MBAtLine() 返回零。
    </returns>
    <remarks>
      此函数与 AtLine() 类似，但它处理包含双字节字符的字符串。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ATLine'>AtLine</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtC'>MBAtC</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtLine2'>MBAtLine2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
  </mbatline>

  <mbatline2>
    <summary>
      返回子字符串在多行字符串中第一次出现的行号 — 子字符串和字符串均可包含双字节字符。
    </summary>
    <param name="cMBSearch">要搜索的子字符串。</param>
    <param name="cMBTarget">要搜索的字符串。</param>
    <returns>
      <paramref name="cMBSearch" /> 在 <paramref name="cMBTarget" /> 中第一次出现的位置。<br/>
      如果未找到 <paramref name="cMBSearch" />，则 MBAtLine2() 返回零。
    </returns>
    <remarks>
      此函数与 MBAtLine() 类似，但返回 WORD 类型。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ATLine2'>AtLine2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAtLine'>MBAtLine</seealso>
  </mbatline2>

  <mbleft>
    <summary>
      返回包含双字节字符的字符串的子字符串，从第一个字符开始提取。
    </summary>
    <param name="cMBString">要提取字符的字符串。</param>
    <param name="wCount">要提取的字符数。</param>
    <returns>
      <paramref name="cMBString" /> 的左侧<paramref name="wCount" />个字符 — 每个双字节字符计为一个字符。<br/>
      如果<paramref name="wCount" />为零，MBLeft()返回NULL_STRING。<br/>
      如果<paramref name="wCount" />大于字符串的长度，MBLeft()返回整个字符串。
    </returns>
    <remarks>
      此函数类似于Left()，但处理包含双字节字符的字符串。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLTrim'>MBLTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRight'>MBRight</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRTrim'>MBRTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBStuff'>MBStuff</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
  </mbleft>

  <mblen>
    <summary>
      返回包含双字节字符的字符串或数组的长度。
    </summary>
    <param name="uMBValue">
      要测量的字符串或数组。在字符串中，每个单字节字符计为1，包括嵌入的空字符（Chr(0)）。双字节字符也计为1。<br/>
      NULL_STRING计为零。在数组中，每个元素计为1。
    </param>
    <returns>
      <paramref name="uMBValue" /> 的长度，其中每个双字节字符计为一个字符。
    </returns>
    <remarks>
      此函数类似于Len()，但处理包含双字节字符的字符串。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLTrim'>MBLTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRTrim'>MBRTrim</seealso>
  </mblen>

  <mbltrim>
    <summary>
      从字符串中移除前导空格 — 包括双字节空格。
    </summary>
    <param name="cMBString">要修剪的字符串。</param>
    <returns>
      去除前导空格后的<paramref name="cMBString" />。<br/>
      如果<paramref name="cMBString" />是NULL_STRING或全是空格，MBLTrim()返回NULL_STRING。
    </returns>
    <remarks>
      此函数类似于LTrim()，但处理包含双字节字符的字符串。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBAllTrim'>MBAllTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRTrim'>MBRTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBTrim'>MBTrim</seealso>
  </mbltrim>

  <mbrat>
    <summary>
      返回子字符串在字符串中最后一次出现的位置 — 子字符串和字符串均可包含双字节字符。
    </summary>
    <param name="cMBSearch">要搜索的子字符串。</param>
    <param name="cMBTarget">要搜索的字符串。（要从特定偏移量开始，请使用 MBRAt3()。）</param>
    <returns>
      <paramref name="cMBSearch" /> 在 <paramref name="cMBTarget" /> 中的位置。<br/>
      如果未找到 <paramref name="cMBSearch" />，则 MBRAt() 返回零。
    </returns>
    <remarks>
      此函数类似于 RAt()，但它处理包含双字节字符的字符串。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLEFT'>MBLeft</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat2'>MBRAt2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat3'>MBRAt3</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRight'>MBRight</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
  </mbrat>

  <mbrat2>
    <summary>
      返回子字符串在字符串中最后一次出现的位置 — 子字符串和字符串均可包含双字节字符。
    </summary>
    <param name="cMBSearch">要搜索的子字符串。</param>
    <param name="cMBTarget">要搜索的字符串。（要从特定偏移量开始，请使用 MBRAt3()。）</param>
    <returns>
      <paramref name="cMBSearch" /> 在 <paramref name="cMBTarget" /> 中的位置。<br/>
      如果未找到 <paramref name="cMBSearch" />，则 MBRAt2() 返回零。
    </returns>
    <remarks>
      此函数类似于 MBRAt()，但返回 DWORD 类型。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat3'>MBRAt3</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt2'>RAt2</seealso>
  </mbrat2>

  <mbrat3>
    <summary>
      返回子字符串在字符串中最后一次出现的位置，从特定位置开始搜索 — 子字符串和字符串均可包含双字节字符。
    </summary>
    <param name="cMBSearch">要搜索的子字符串。</param>
    <param name="cMBTarget">要搜索的字符串。</param>
    <param name="wOffset">
      在字符串中开始搜索的位置。<br/>
      值为零对应于第一个字节。
    </param>
    <returns>
      <paramref name="cMBSearch" /> 在 <paramref name="cMBTarget" /> 中的位置。<br/>
      如果未找到 <paramref name="cMBSearch" />，则 MBRAt3() 返回零。
    </returns>
    <remarks>
      此函数类似于 MBRAt()，但允许您指定开始搜索的偏移量。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat2'>MBRAt2</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt3'>RAt3</seealso>
  </mbrat3>

  <mbright>
    <summary>
      返回包含双字节字符的字符串的子字符串，从最后一个字符开始提取。
    </summary>
    <param name="cMBString">要提取字符的字符串。</param>
    <param name="wCount">要提取的字符数。</param>
    <returns>
      <paramref name="cMBString" /> 的右侧 <paramref name="wCount" /> 个字符 — 每个双字节字符计为一个字符。<br/>
      如果 <paramref name="wCount" /> 为零，MBRight() 返回 NULL_STRING。<br/>
      如果 <paramref name="wCount" /> 大于字符串的长度，MBRight() 返回 <paramref name="cMBString" />。
    </returns>
    <remarks>
      此函数类似于 Right()，但处理包含双字节字符的字符串。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBLEFT'>MBLeft</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLTrim'>MBLTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRTrim'>MBRTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBStuff'>MBStuff</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
  </mbright>

  <mbrtrim>
    <summary>
      从字符串中移除尾部空格 — 包括双字节空格。
    </summary>
    <param name="cMBString">要修剪的字符串。</param>
    <returns>
      去除尾部空格后的 <paramref name="cMBString" />。<br/>
      如果 <paramref name="cMBString" /> 是 NULL_STRING 或全是空格，MBRTrim() 返回 NULL_STRING。
    </returns>
    <remarks>
      此函数类似于 RTrim()，但处理包含双字节字符的字符串。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBAllTrim'>MBAllTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLTrim'>MBLTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBTrim'>MBTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
  </mbrtrim>

  <mbslen>
    <summary>
      返回包含双字节字符的强类型字符串的长度。
    </summary>
    <param name="cMBString">要计数的字符串。</param>
    <returns>
      <paramref name="cMBString" /> 的长度，其中每个双字节字符计为一个字符。<br/>
      如果字符串是 NULL_STRING，MBSLen() 返回零。
    </returns>
    <remarks>
      此函数类似于 SLen()，但处理包含双字节字符的字符串。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBAllTrim'>MBAllTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLen'>MBLen</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLTrim'>MBLTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRTrim'>MBRTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBTrim'>MBTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.SLen'>SLen</seealso>
  </mbslen>

  <mbstuff>
    <summary>
      将字符串插入到另一个字符串中，可选地从原始字符串中删除指定数量的字符 — 两个字符串均可包含双字节字符。
    </summary>
    <param name="cMBTarget">要插入和删除字符的字符串。</param>
    <param name="wStart">
      在 <paramref name="cMBTarget" /> 中进行插入/删除的起始位置。
    </param>
    <param name="wDelete">要删除的字符数量 — 每个双字节字符计为一个字符。</param>
    <param name="cMBInsert">要插入的字符串。</param>
    <returns>
      <paramref name="cMBTarget" /> 删除指定字符并插入 <paramref name="cMBInsert" /> 后的结果。
    </returns>
    <remarks>
      此函数类似于 Stuff()，但处理包含双字节字符的字符串。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLEFT'>MBLeft</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRight'>MBRight</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Stuff'>Stuff</seealso>
  </mbstuff>

  <mbsubstr>
    <summary>
      从字符串中提取子字符串 — 子字符串和字符串均可包含双字节字符。
    </summary>
    <param name="cMBTarget">要提取子字符串的字符串。</param>
    <param name="nStart">
      在 <paramref name="cMBTarget" /> 中的起始位置。<br/>
      如果 <paramref name="nStart" /> 是正数，则相对于 <paramref name="cMBTarget" /> 的最左字符；<br/>
      如果 <paramref name="nStart" /> 是负数，则相对于 <paramref name="cMBTarget" /> 的最右字符。
    </param>
    <param name="nCount">
      要提取的字符数 — 双字节字符计为一个字符。<br/>
      如果省略，则子字符串从 <paramref name="nStart" /> 开始，直到字符串的末尾。<br/>
      如果 <paramref name="nCount" /> 大于从 <paramref name="nStart" /> 到 <paramref name="cMBTarget" /> 末尾的字符数，则多余的部分将被忽略。
    </param>
    <returns>
      子字符串。<br/>
      如果未找到子字符串，或者如果您指定 <paramref name="nStart" /> 为零，则 MBSubstr() 返回 NULL_STRING。
    </returns>
    <remarks>
      此函数类似于 Substr()，但处理包含双字节字符的字符串。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLEFT'>MBLeft</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRight'>MBRight</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr2'>MBSubstr2</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr3'>MBSubstr3</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </mbsubstr>

  <mbsubstr2>
    <summary>
      从字符串中提取子字符串，使用强类型和仅两个参数 — 子字符串和字符串均可包含双字节字符。
    </summary>
    <param name="cMBTarget">要提取子字符串的字符串。</param>
    <param name="wStart">
      相对于 <paramref name="cMBTarget" /> 的最左字符的起始位置。
    </param>
    <returns>
      子字符串。<br/>
      如果未找到子字符串，或者如果您指定 <paramref name="wStart" /> 为零，则 MBSubstr2() 返回 NULL_STRING。
    </returns>
    <remarks>
      MBSubstr2() 是 MBSubstr() 的类型化版本。<br/>
      MBSubstr() 的第三个参数（计数字符数）不允许。相反，此函数从指定位置开始，提取到字符串的末尾。<br/>
      由于 <paramref name="wStart" /> 不能为负，MBSubstr2() 无法相对于 <paramref name="cMBTarget" /> 的最右字符提取子字符串，正如 MBSubstr() 所能做到的那样。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLEFT'>MBLeft</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRight'>MBRight</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr3'>MBSubstr3</seealso>
    <seealso cref='O:XSharp.Core.Functions.SubStr2'>Substr2</seealso>
  </mbsubstr2>

  <mbsubstr3>
    <summary>
      从字符串中提取子字符串，使用强类型和三个必需参数 — 子字符串和字符串均可包含双字节字符。
    </summary>
    <param name="cMBTarget">要提取子字符串的字符串。</param>
    <param name="wStart">
      相对于 <paramref name="cMBTarget" /> 的最左字符的起始位置。
    </param>
    <param name="wCount">
      要提取的字符数 — 双字节字符计为一个字符。<br/>
      如果 <paramref name="wCount" /> 大于从 <paramref name="wStart" /> 到 <paramref name="cMBTarget" /> 末尾的字符数，则多余的部分将被忽略。
    </param>
    <returns>
      子字符串。<br/>
      如果未找到子字符串，或者如果您指定 <paramref name="wStart" /> 为零，则 MBSubstr3() 返回 NULL_STRING。
    </returns>
    <remarks>
      MBSubstr3() 是 MBSubstr() 的类型化版本，其中所有三个参数都是必需的。由于 <paramref name="wStart" /> 不能为负，MBSubstr3() 无法相对于 <paramref name="cMBTarget" /> 的最右字符提取子字符串，正如 MBSubstr() 所能做到的那样。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBAt'>MBAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLEFT'>MBLeft</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRat'>MBRAt</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRight'>MBRight</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr2'>MBSubstr2</seealso>
    <seealso cref='O:XSharp.Core.Functions.SubStr3'>Substr3</seealso>
  </mbsubstr3>

  <mbtrim>
    <summary>
      从字符串中移除尾部空格 — 包括双字节空格。
    </summary>
    <param name="cMBString">要修剪的字符串。</param>
    <returns>
      去除尾部空格后的 <paramref name="cMBString" />。<br/>
      如果 <paramref name="cMBString" /> 是 NULL_STRING 或全是空格，MBTrim() 返回 NULL_STRING。
    </returns>
    <remarks>
      此函数类似于 Trim()，但处理包含双字节字符的字符串。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.MBAllTrim'>MBAllTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBLTrim'>MBLTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBRTrim'>MBRTrim</seealso>
    <seealso cref='O:XSharp.VO.Functions.MBSubstr'>MBSubstr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Trim'>Trim</seealso>
  </mbtrim>

  <mcompile>
    <summary>
      宏编译字符串。
    </summary>
    <param name="cString">要编译的字符串。</param>
    <returns>
      以宏编译形式的字符串。
    </returns>
    <remarks>
      MCompile() 允许您使用宏编译器编译字符串并存储编译结果以供后续执行。您可以通过仅编译一次表达式并按需执行编译形式来加速应用程序，而不是每次评估表达式时调用宏编译器。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/mcompilemexec/*" />
    </remarks>
    <example>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/mcompileexamples/*" />
    </example>
    <seealso cref='O:XSharp.RT.Functions.Evaluate'>Evaluate</seealso>
    <seealso cref='O:XSharp.RT.Functions.ExecScript'>ExecScript</seealso>
    <seealso cref='O:XSharp.RT.Functions.MAssign'>MAssign</seealso>
    <seealso cref='O:XSharp.RT.Functions.MExec'>MExec</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrEvaluate'>StrEvaluate</seealso>
    <seealso cref='T:XSharp._Codeblock'>_Codeblock 类型</seealso>
  </mcompile>

  <mem2string>
    <summary>
      从缓冲区的左侧提取指定大小的子字符串。
    </summary>
    <param name="ptrSource">指向要提取子字符串的缓冲区的指针。</param>
    <param name="dwCount">
      从 <paramref name="ptrSource" /> 的左侧提取的字节数。
    </param>
    <returns>
      指定字节数的子字符串。
    </returns>
    <remarks>
      <note type="tip">
        与正常的 PSZ 不同，字符串不是静态的，可能会被垃圾收集器收集。<br/>
        因此，如果您将字符串作为参数传递给一个像 Mem2String 这样的函数，该函数直接或间接分配动态内存，您可能会遇到问题。<br/>
        例如，Mem2String(Time(), 5) 可能会导致问题。但 Mem2String("hi there", 5) 则不会因为字面量字符串不会被收集。
      </note>
    </remarks>
    <example>
      此示例使用 Mem2String() 获取 PSZ 的三个最左侧字符：
      <code language="X#">
        LOCAL pszSource AS PSZ
        pszSource := "ABCDEF"
        ? Mem2String(pszSource, 3)&#0009;&#0009;&#0009;// ABC
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Psz2String'>Psz2String</seealso>
  </mem2string>

  <memalloc>
    <summary>
      分配指定大小的静态内存缓冲区。
    </summary>
    <param name="wBytes">要分配的字节数。</param>
    <returns>
      如果有足够的内存可用，则返回指向分配空间的指针；否则，返回 NULL_PTR。您应该始终检查返回值以确保分配成功。
    </returns>
    <remarks>
      MemAlloc() 分配至少为 <paramref name="wBytes" /> 的内存缓冲区。<br/>
      分配的内存被定义为静态，因此不会被垃圾收集器移动。由于内存是以 32 字节为增量分配的，因此可能会分配一些额外的空间。<br/>
      例如，请求甚至 1 个字节将分配 32 个字节。由 MemAlloc() 分配的空间由 MemFree() 释放。
      <note type="tip">
        此函数允许直接操作内存位置，应极为小心使用。
      </note>
    </remarks>
    <example>
      此示例使用 MemAlloc() 检查指定块是否可用：
      <code language="X#">
        FUNCTION IsAvailable(wRequest AS DWORD) AS LOGIC
        &#0009;LOCAL ptrBuff AS PTR
        &#0009;LOCAL lAvailable AS LOGIC
        &#0009;ptrBuff := MemAlloc(wRequest)
        &#0009;IF ptrBuff = NULL_PTR
        &#0009;&#0009;? "内存分配失败"
        &#0009;&#0009;lAvailable := FALSE
        &#0009;ELSE
        &#0009;&#0009;lAvailable := TRUE
        &#0009;&#0009;MemFree(ptrBuff)
        &#0009;ENDIF
        &#0009;RETURN lAvailable
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemCAlloc'>MemCAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemFree'>MemFree</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemGrpAlloc'>MemGrpAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemGrpClose'>MemGrpClose</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemGrpOpen'>MemGrpOpen</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemTotal'>MemTotal</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemWalk'>MemWalk</seealso>
    <seealso cref='O:XSharp.RT.Functions.StringAlloc'>StringAlloc</seealso>
  </memalloc>

  <mematspecial>
    <summary>
      获取缓冲区中第一个特殊控制字符的位置。
    </summary>
    <param name="ptrBuffer">指向缓冲区的指针。</param>
    <param name="dwCount">
      要检查的 <paramref name="ptrBuffer" /> 中的字节数。
    </param>
    <returns>
      在指定的 <paramref name="ptrBuffer" /> 部分中第一个特殊控制字符的位置。<br/>
      如果不存在特殊控制字符，MemAtSpecial() 返回 0。
    </returns>
    <remarks>
      特殊控制字符是 ASCII 值小于或等于 13 的字符，显示在屏幕上时可能需要特殊处理。此外，终端驱动程序可以为它们分配特殊含义，例如在指定 Chr(7) 时发出铃声。
    </remarks>
    <example>
      此示例使用 MemAtSpecial() 迭代检测字符串中的所有特殊控制字符：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL s := "AB" + _Chr(10) + "CD" + _Chr(7) + ;
        &#0009;&#0009;&#0009;"EF" + _Chr(13) + "GH" AS STRING
        &#0009;LOCAL wAt AS DWORD
        &#0009;DO WHILE SLen(s) &gt; 0
        &#0009;&#0009;wAt := MemAtSpecial(Ptr(_CAST, s), SLen(s))
        &#0009;&#0009;IF wAt &gt; 0
        &#0009;&#0009;&#0009;? "检测到 ASCII 代码为:",;
        &#0009;&#0009;&#0009;&#0009;Asc(Substr3(s, wAt, 1)), "的特殊字符"
        &#0009;&#0009;&#0009;// 查询字符串的其余部分
        &#0009;&#0009;&#0009;// （从 wAt+1 开始）
        &#0009;&#0009;&#0009;s := Substr(s, wAt+1)
        &#0009;&#0009;ELSE
        &#0009;&#0009;&#0009;s := ""
        &#0009;&#0009;ENDIF
        &#0009;ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemChr'>MemChr</seealso>
  </mematspecial>

  <membyte>
    <summary>
      获取指向内存缓冲区中字节的指针。
    </summary>
    <param name="ptrBuffer">要检查的内存缓冲区的指针。</param>
    <param name="bChar">要匹配的字节值。</param>
    <param name="dwCount">
      要检查的 <paramref name="ptrBuffer" /> 中的字节数。
    </param>
    <returns>
      指向 <paramref name="bChar" /> 在 <paramref name="ptrBuffer" /> 前 <paramref name="dwCount" /> 字节中的第一次出现的指针。<br/>
      如果未匹配 <paramref name="bChar" />，MemChr() 将返回 NULL_PTR。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 MemByte() 在 PSZ 上：
      <code language="X#">
        FUNCTION FindChar()
        &#0009;LOCAL pszC1 := "ABCDEF" AS PSZ
        &#0009;? MemByte(pszC1, ASC("A"), 6)&#0009;&#0009;&#0009;// 3F37:2788
        &#0009;? MemByte(pszC1, ASC("B"), 6)&#0009;&#0009;&#0009;// 3F37:2789
        &#0009;? MemByte(pszC1, ASC("B"), 1)&#0009;&#0009;&#0009;// 0000:0000
        &#0009;// NULL_PTR: ASC("B") 未在
        &#0009;// PSZ 的前 "1" 个字符中找到
      </code>
      此示例使用 MemByte() 在分配的块上：
      <code language="X#">
        FUNCTION FindChar2()
        &#0009;LOCAL ptrBuff := MemAlloc(10) AS PTR
        &#0009;IF ptrBuff != NULL_PTR
        &#0009;&#0009;// 将 68 写入前 10 个字节
        &#0009;&#0009;MemSet(ptrBuff, 68, 10)
        &#0009;&#0009;// 用 67 覆盖前 5 个字节
        &#0009;&#0009;MemSet(ptrBuff, 67, 5)
        &#0009;&#0009;? MemByte(ptrBuff, 68, 10)&#0009;&#0009;&#0009;// 3CA7:07DD
        &#0009;&#0009;? MemByte(ptrBuff, 67, 10)&#0009;&#0009;&#0009;// 3CA7:07D8
        &#0009;ENDIF
        &#0009;MemFree(ptrBuff)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemChr'>MemChr</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemComp'>MemComp</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemDWord'>MemDWord</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemInt'>MemInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemLong'>MemLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemShort'>MemShort</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemWord'>MemWord</seealso>
  </membyte>

  <memcalloc>
    <summary>
      分配指定大小的静态内存缓冲区。
    </summary>
    <param name="wItems">要分配内存的项目数量。</param>
    <param name="wBytes">每个项目要分配的字节数。</param>
    <returns>
      如果有足够的内存可用，则返回指向分配空间的指针；否则，返回 NULL_PTR。您应该始终检查 MemCAlloc() 的返回值以确保分配成功。
    </returns>
    <remarks>
      MemCAlloc() 用于一次性分配多个项目的空间。<br/>
      分配的内存被定义为静态，因此不会被垃圾收集器移动。由 MemCAlloc() 分配的空间由 MemFree() 释放。
      <note type="tip">
        此函数允许直接操作内存位置，应极为小心使用。
      </note>
    </remarks>
    <example>
      此示例使用 MemCAlloc() 为十个长整型分配空间：
      <code language="X#">
        LOCAL ptrLongs AS PTR
        ptrLongs := MemCAlloc(10, 4)
      </code>
      我们还可以使用以下方式代替硬编码 4：
      <code language="X#">ptrLongs := MemCAlloc(10, _SizeOf(LONG))</code>
      下一个示例使用 MemCAlloc() 为五个实例的定义结构分配空间：
      <code language="X#">
        STRUCTURE StatInfo
        &#0009;MEMBER wAverageHit AS DWORD
        &#0009;MEMBER wMaxHit AS DWORD
        &#0009;MEMBER wMinHit AS DWORD
        FUNCTION MemCAlloc2() AS VOID
        &#0009;LOCAL ptrStruct AS PTR
        &#0009;ptrStruct := MemCAlloc(5, _SizeOf(StatInfo))
        &#0009;IF ptrStruct = NULL_PTR
        &#0009;&#0009;? "分配失败"
        &#0009;ELSE
        &#0009;&#0009;MemFree(ptrStruct)
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemAlloc'>MemAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemFree'>MemFree</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemGrpAlloc'>MemGrpAlloc</seealso>
  </memcalloc>

  <memcheckptr>
    <summary>
      检查指向内存缓冲区的指针的有效性。
    </summary>
    <param name="ptrValue">要检查的指针。</param>
    <param name="wBytes">要检查的字节数。</param>
    <returns>
      如果它是有效的动态分配内存指针，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      MemCheckPtr() 可以保护您免受无效的野指针或空指针的影响，这些指针的使用可能会带来不良后果。
    </remarks>
    <example>
      此示例使用 MemCheckPtr():
      <code language="X#">
        ptrV := MemAlloc(100)
        ? MemCheckPtr(ptrV, 100)&#0009;&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemAlloc'>MemAlloc</seealso>
  </memcheckptr>

  <memchr>
    <summary>
      获取指向内存缓冲区中匹配字符值的指针。
    </summary>
    <param name="ptrBuffer">要检查的内存缓冲区的指针。</param>
    <param name="dwChar">要匹配的字符的字表示。</param>
    <param name="dwCount">
      要检查的 <paramref name="ptrBuffer" /> 中的字符数。
    </param>
    <returns>
      指向 <paramref name="dwChar" /> 在 <paramref name="ptrBuffer" /> 前 <paramref name="dwCount" /> 字符中的第一次出现的指针。<br/>
      如果未匹配 <paramref name="dwChar" />，MemChr() 将返回 NULL_PTR。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例在 PSZ 上使用 MemChr()：
      <code language="X#">
        FUNCTION FindChar() AS VOID
        &#0009;LOCAL pszC1 := "ABCDEF" AS PSZ
        &#0009;? MemChr(pszC1, ASC("A"), 6)&#0009;&#0009;&#0009;// 指针
        &#0009;? MemChr(pszC1, ASC("B"), 6)&#0009;&#0009;&#0009;// 指针
        &#0009;? MemChr(pszC1, ASC("B"), 1)
        &#0009;// NULL_PTR: ASC("B") 不在
        &#0009;// PSZ 的前 "1" 个字符中
      </code>
      下一个示例在分配的块上使用 MemChr()：
      <code language="X#">
        FUNCTION FindChar2() AS VOID
        &#0009;LOCAL ptrBuff := MemAlloc(10) AS PTR
        &#0009;IF ptrBuff != NULL_PTR
        &#0009;&#0009;// 在前 10 个字节写入 68
        &#0009;&#0009;MemSet(ptrBuff, 68, 10)
        &#0009;&#0009;// 用 67 覆盖前 5 个字节
        &#0009;&#0009;MemSet(ptrBuff, 67, 5)
        &#0009;&#0009;? MemChr(ptrBuff, 68, 10)&#0009;&#0009;&#0009;//3CEF:07DD
        &#0009;&#0009;? MemChr(ptrBuff, 67, 10)&#0009;&#0009;&#0009;//3CEF:07D8
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemByte'>MemByte</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemDWord'>MemDWord</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemInt'>MemInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemLong'>MemLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemShort'>MemShort</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemWord'>MemWord</seealso>
  </memchr>

  <memclear>
    <summary>
      用空字符填充内存缓冲区。
    </summary>
    <param name="ptrDest">指向要填充的内存缓冲区的指针。</param>
    <param name="dwCount">要填充的字节数。</param>
    <returns>
      指向填充后的内存缓冲区的指针。
    </returns>
    <remarks>
      MemClear() 将指向 <paramref name="ptrDest" /> 的内存缓冲区的前 <paramref name="dwCount" /> 字节设置为 ASCII CHR(0) 字符。
      <note type="tip">
        此函数允许直接操作内存位置，使用时需格外小心。
      </note>
    </remarks>
    <example>
      此示例清除已分配块的内容：
      <code language="X#">
        LOCAL ptrBuff AS PTR
        ptrBuff := MemAlloc(10)
        MemClear(ptrBuff, 10)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemCopyString'>MemCopyString</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemSet'>MemSet</seealso>
  </memclear>

  <memcomp>
    <summary>
      比较两个内存缓冲区中的字节。
    </summary>
    <param name="ptrFirst">指向第一个内存缓冲区的指针。</param>
    <param name="ptrSecond">指向第二个内存缓冲区的指针。</param>
    <param name="dwCount">要比较的字节数。</param>
    <returns>
      -1、0 或 1，表示第一个 <paramref name="dwCount" /> 字节的 <paramref name="ptrFirst" /> 小于、等于或大于第一个 <paramref name="dwCount" /> 字节的 <paramref name="ptrSecond" />。
    </returns>
    <remarks>
      <code language="X#">
        MemComp() 比较每个内存缓冲区中前 <paramref name="dwCount" /> 字节的 ANSI 值。请注意，有些字符（例如 ä）可能具有更高的 ANSI 值，但 OEM 值低于其他字符（例如）。<br/>
        系统仅使用 ANSI 集。
      </code>
    </remarks>
    <example>
      此示例使用 MemComp():
      <code language="X#">
        FUNCTION Compare()
        &#0009;LOCAL pszC1 := "abc" AS PSZ
        &#0009;LOCAL pszC2 := "abcd" AS PSZ
        &#0009;LOCAL pszChar1 := "ä" AS PSZ
        &#0009;LOCAL pszChar2 := "ß" AS PSZ
        &#0009;? MemComp(pszC1, pszC2, 4)&#0009;&#0009;&#0009;&#0009;// -1
        &#0009;? MemComp(pszC2, pszC1, 4)&#0009;&#0009;&#0009;&#0009;//  1
        &#0009;// "ä" 的 ANSI 值大于 "ß"
        &#0009;// 尽管其 OEM 值较小。
        &#0009;? MemComp(pszChar1, pszChar2)&#0009;&#0009;&#0009;//  1
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemByte'>MemByte</seealso>
  </memcomp>

  <memcopy>
    <summary>
      复制一个内存缓冲区到另一个。
    </summary>
    <param name="ptrDest">指向目标内存缓冲区的指针。</param>
    <param name="ptrSource">指向要复制的源字符串的指针。</param>
    <param name="dwCount">要复制的字节数。</param>
    <returns>
      指向目标内存缓冲区的指针。
    </returns>
    <remarks>
      MemCopy() 将指定数量的字节从源内存缓冲区复制到目标内存缓冲区。<br/>
      如果源字符串占用的内存部分与目标中的部分重叠，则重叠区域会被覆盖。<br/>
      使用 MemMove() 复制在被覆盖之前的重叠区域。
      <note type="tip">
        此函数允许直接操作内存位置，使用时需格外小心。
      </note>
    </remarks>
    <example>
      此示例使用 MemCopy():
      <code language="X#">
        LOCAL pszDest := "Hi there" AS PSZ
        LOCAL pszSrc := "***" AS PSZ
        MemCopy(pszDest, pszSrc, 3)
        ? pszDest&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// ***there
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemCopyString'>MemCopyString</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemMove'>MemMove</seealso>
  </memcopy>

  <memcopystring>
    <summary>
      复制一个内存缓冲区到另一个，并用空格填充任何剩余空间。
    </summary>
    <param name="ptrDest">指向目标内存缓冲区的指针。</param>
    <param name="cSource">要复制的源字符串。</param>
    <param name="dwCount">要复制的字节数。</param>
    <returns>
    </returns>
    <remarks>
      MemCopyString() 将指定数量的字节从源内存缓冲区复制到目标内存缓冲区。<br/>
      如果源字符串占用的内存部分与目标中的部分重叠，则重叠区域会被覆盖。<br/>
      如果源内存缓冲区中的字节数少于 <paramref name="dwCount" />，则目标内存缓冲区的其余部分用空格填充。<br/>
      使用 MemMove() 复制在被覆盖之前的重叠区域。
      <note type="tip">
        此函数允许直接操作内存位置，使用时需格外小心。
      </note>
    </remarks>
    <example>
      此示例使用 MemCopyString():
      <code language="X#">
        LOCAL pszDest := "Hi there" AS PSZ
        LOCAL pszSrc := "***" AS PSZ
        MemCopyString(pszDest, pszSrc, 5)
        ? pszDest&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// "***  ere"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemCopy'>MemCopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemMove'>MemMove</seealso>
  </memcopystring>

  <memdword>
    <summary>
      获取指向内存缓冲区中匹配的双字的指针。
    </summary>
    <param name="ptrBuffer">要检查的内存缓冲区的指针。</param>
    <param name="dwValue">要匹配的双字值。</param>
    <param name="dwCount">
      要检查的 <paramref name="ptrBuffer" /> 中的双字数量。
    </param>
    <returns>
      指向 <paramref name="ptrBuffer" /> 中前 <paramref name="dwCount" /> 字符的第一次出现的 <paramref name="dwValue" /> 的指针。<br/>
      如果未匹配 <paramref name="dwValue" />，MemDWord() 将返回 NULL_PTR。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 MemDWord() 在 PSZ 上：
      <code language="X#">
        FUNCTION FindDWord() AS VOID
        &#0009;LOCAL pszC := "ABCDEFGHIJ" AS PSZ
        &#0009;? MemDWord(pszC, Bin2DW("EFGH"), 2)&#0009;// 一个指针
        &#0009;? MemDWord(pszC, Bin2DW("EFGH"), 1)
        &#0009;// 模式未在 pszC 的第一个 DWord 中找到
        &#0009;//  0000:0000
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemByte'>MemByte</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemChr'>MemChr</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemInt'>MemInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemLong'>MemLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemShort'>MemShort</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemWord'>MemWord</seealso>
  </memdword>

  <memfree>
    <summary>
      释放指定的内存缓冲区。
    </summary>
    <param name="ptrBuffer">
      指向先前分配的内存缓冲区的指针。<br/>
      如果指定了无效的指针，将弹出消息框通知您释放失败。
    </param>
    <returns>
      0 表示成功；否则返回 65,535。
    </returns>
    <remarks>
      MemFree() 是一个用于释放由 MemAlloc() 分配的内存的内存函数。<br/>
      释放的字节数是之前由 MemAlloc() 分配的字节数。
      <note type="tip">
        此函数允许直接操作内存位置，使用时需格外小心。
      </note>
    </remarks>
    <example>
      此示例使用 MemFree() 释放新分配的块：
      <code language="X#">
        LOCAL ptrBuff AS PTR
        ptrBuff := MemAlloc(128)
        IF ptrBuff = NULL_PTR
        &#0009;? "分配失败"
        ELSE
        &#0009;MemFree(ptrBuff)
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemAlloc'>MemAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.StringAlloc'>StringAlloc</seealso>
  </memfree>

  <memgrpalloc>
    <summary>
      在组中分配一个新的内存缓冲区。
    </summary>
    <param name="wGroup">
      新分配的内存缓冲区将属于的组。<br/>
      此组应该已经通过 MemGrpOpen() 打开。
    </param>
    <param name="wBytes">要分配的字节数。</param>
    <returns>
      如果有足够的内存可用，则返回指向新分配空间的指针；否则，返回 NULL_PTR。您应该始终检查返回值以确保分配成功。
    </returns>
    <remarks>
      MemGrpAlloc() 分配至少 <paramref name="wBytes" /> 的内存缓冲区。由于内存是以 32 字节为增量分配的，因此可能会分配一些额外的空间。<br/>
      例如，甚至请求 1 字节也将分配 32 字节。由 MemGrpAlloc() 分配的空间由 MemGrpClose() 释放。
      <note type="tip">
        此函数允许直接操作内存位置，使用时需格外小心。
      </note>
    </remarks>
    <example>
      此示例使用 MemGrpAlloc():
      <code language="X#">
        Function Start()
        &#0009;LOCAL ptrCurrent AS PTR
        &#0009;LOCAL wGroup AS DWORD
        &#0009;LOCAL lRet AS LOGIC
        &#0009;wGroup := MemGrpOpen()&#0009;&#0009;// 首先需要有一个组
        &#0009;IF wGroup != 0
        &#0009;&#0009;ptrCurrent := MemGrpAlloc(wGroup, 100)
        &#0009;&#0009;MemGrpClose(wGroup)
        &#0009;&#0009;lRet := FALSE
        &#0009;ELSE
        &#0009;&#0009;lRet := TRUE
        &#0009;ENDIF
        &#0009;RETURN lRet
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemGrpClose'>MemGrpClose</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemGrpOpen'>MemGrpOpen</seealso>
  </memgrpalloc>

  <memgrpclose>
    <summary>
      关闭内存组。
    </summary>
    <param name="wGroup">
      您想要关闭的组。<br/>
      如果指定了无效的组，将弹出消息框通知您关闭无效组的失败尝试。
    </param>
    <returns>
      0 表示成功；否则返回 65,535。
    </returns>
    <remarks>
      在调用 MemGrpClose() 之后，组持有的任何内存都将被垃圾收集，并且 <paramref name="wGroup" /> 不再作为有效组句柄存在。
      <note type="tip">
        此函数允许直接操作内存位置，使用时需格外小心。
      </note>
    </remarks>
    <example>
      此示例使用 MemGrpClose() 关闭两个不同的组。
      <code language="X#">
        w1 := MemGrpOpen()&#0009;&#0009;&#0009;&#0009;// 1
        IF w1 != 0
        &#0009;? MemGrpClose(w1)&#0009;&#0009;// TRUE
        ENDIF
        IF w2 != 0
        &#0009;w2 := MemGrpOpen()&#0009;&#0009;// 1 (同一句柄被重用)
        ENDIF
        MemGrpClose(w2)&#0009;&#0009;&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemGrpAlloc'>MemGrpAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemGrpOpen'>MemGrpOpen</seealso>
  </memgrpclose>

  <memgrpopen>
    <summary>
      打开一个新的内存组。
    </summary>
    <returns>
      如果成功，返回新组的句柄；否则返回 0。您应该始终检查组句柄是否有效。
    </returns>
    <remarks>
      MemGrpOpen() 打开一个新的内存组。结合 MemGrpAlloc()，MemGrpOpen() 允许您对动态分配的内存缓冲区进行分组或组织。
      <note type="tip">
        此函数允许直接操作内存位置，使用时需格外小心。
      </note>
    </remarks>
    <example>
      此示例使用 MemGrpOpen() 并检查是否为有效组号：
      <code language="X#">
        wGrp := MemGrpOpen()
        IF wGrp = 0
        &#0009;? "不成功 - 无效句柄"
        ELSE
        &#0009;? "新有效句柄", wGrp
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemGrpAlloc'>MemGrpAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemGrpClose'>MemGrpClose</seealso>
  </memgrpopen>

  <memint>
    <summary>
      获取指向内存缓冲区中匹配整数的指针。
    </summary>
    <param name="ptrBuffer">要检查的内存缓冲区的指针。</param>
    <param name="iValue">要匹配的整数。</param>
    <param name="dwCount">
      要检查的 <paramref name="ptrBuffer" /> 中的整数数量。
    </param>
    <returns>
      指向 <paramref name="ptrBuffer" /> 的前 <paramref name="dwCount" /> 个整数中首次出现的 <paramref name="iValue" /> 的指针。<br/>
      如果未匹配 <paramref name="iValue" />，MemInt() 返回 NULL_PTR。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例在 PSZ 上使用 MemInt()：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL ptrI := "ABCDEFGHIJ" AS PSZ
        &#0009;? MemInt(ptrI, Bin2I("EFGH"), 2)&#0009;// 一个指针
        &#0009;? MemInt(ptrI, Bin2I("EFGH"), 1)
        // 在 ptrI 的第一个整数中未找到 0000:0000
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemByte'>MemByte</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemChr'>MemChr</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemDWord'>MemDWord</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemLong'>MemLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemShort'>MemShort</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemWord'>MemWord</seealso>
  </memint>

  <memlines>
    <summary>
      计算字符串或备忘字段中的行数。
    </summary>
    <param name="cString">要计算的字符串。</param>
    <returns>
      根据 <paramref name="nLineLength" />、<paramref name="nTabSize" /> 以及是否启用换行，返回 <paramref name="cString" /> 中的行数。
    </returns>
    <remarks>
      MemLines() 与 MemoLine() 一起使用，以根据每行的字符数打印字符串和备忘字段。在基本操作中，使用 MemLines() 返回字符串或备忘字段中的行数。<br/>
      然后，使用 MemoLine() 提取每一行，循环遍历备忘字段，直到没有剩余行。
    </remarks>
    <example>
      此示例逐行显示 SALES.DBF 文件中每个 Notes 备忘字段的内容：
      <code language="X#">
        USE sales NEW
        nLineLength = 65
        DO WHILE !EOF()
        &#0009;nLines = MemLines(Sales-&gt;Notes)
        &#0009;FOR nCurrLine = 1 UPTO nLines
        &#0009;&#0009;? MemoLine(Sales-&gt;Notes, nLineLength,;
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;nCurrLine)
        &#0009;NEXT
        &#0009;SKIP
        &#0009;?
        ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MemoLine'>MemoLine</seealso>
  </memlines>

  <memlong>
    <summary>
      获取指向内存缓冲区中匹配长整数的指针。
    </summary>
    <param name="ptrBuffer">要检查的内存缓冲区的指针。</param>
    <param name="liValue">要匹配的长整数值。</param>
    <param name="dwCount">
      要检查的 <paramref name="ptrBuffer" /> 中的长整数数量。
    </param>
    <returns>
      指向 <paramref name="ptrBuffer" /> 的前 <paramref name="dwCount" /> 个长整数中首次出现的 <paramref name="liValue" /> 的指针。<br/>
      如果未匹配 <paramref name="liValue" />，MemLong() 返回 NULL_PTR。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例在 PSZ 上使用 MemLong()：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL ptrLI := "ABCDEFGHIJ" AS PSZ
        &#0009;? MemLong(ptrLI, Bin2L("EFGH", 2))&#0009;&#0009;// 一个指针
        &#0009;? MemLong(ptrLI, Bin2L("EFGH", 1))
        &#0009;// 在 ptrLI 的第一个长整数中未找到 0000:0000
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemByte'>MemByte</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemChr'>MemChr</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemDWord'>MemDWord</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemInt'>MemInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemShort'>MemShort</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemWord'>MemWord</seealso>
  </memlong>

  <memmove>
    <summary>
      将一个内存缓冲区移动到另一个。
    </summary>
    <param name="ptrDest">指向目标内存缓冲区的指针。</param>
    <param name="ptrSource">指向源内存缓冲区的指针。</param>
    <param name="dwCount">要复制的字节数。</param>
    <returns>
      指向目标内存缓冲区的指针。
    </returns>
    <remarks>
      MemMove() 将指定数量的字节从源内存缓冲区复制到目标内存缓冲区。<br/>
      如果源缓冲区的某些部分与目标缓冲区的某些部分重叠，则重叠区域在操作期间被复制并保留，随后才被覆盖。
      <note type="tip">
        此函数允许直接操作内存位置，使用时需格外小心。
      </note>
    </remarks>
    <example>
      此示例使用 MemMove():
      <code language="X#">
        LOCAL pszDest := "你好" AS PSZ
        LOCAL pszSrc := "***" AS PSZ
        MemMove(pszDest, pszSrc, 3)
        ? pszDest&#0009;&#0009;&#0009;&#0009;&#0009;// ***好
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemCopy'>MemCopy</seealso>
  </memmove>

  <memoline>
    <summary>
      从字符串中提取一行文本。
    </summary>
    <param name="cString">要从中提取文本的字符串。</param>
    <param name="nLineLength">
      每行的字符数。<br/>
      该值可以在 4 到 254 之间。<br/>
      默认值为 79。
    </param>
    <param name="nLineNumber">
      要提取的行号。<br/>
      默认值为 1。
    </param>
    <param name="nTabSize">
      当用户按下 Tab 键时要插入的字符数。<br/>
      如果未指定 <paramref name="nTabSize" />，则插入 4 个空格。<br/>
      如果 <paramref name="nTabSize" /> 大于或等于 <paramref name="nLineLength" />，则 Tab 大小自动转换为 <paramref name="nLineLength" /> 减 1。
    </param>
    <param name="lWrap">
      TRUE 切换换行开；FALSE 切换换行关。<br/>
      默认值为 TRUE。
    </param>
    <returns>
      <paramref name="cString" /> 中由 <paramref name="nLineNumber" /> 指定的文本行。<br/>
      如果该行的字符数少于指示的长度，则返回值用空格填充。<br/>
      如果行号大于 <paramref name="cString" /> 中的总行数，则 MemoLine() 返回 NULL_STRING。
      如果 <paramref name="lWrap" /> 为 TRUE 且指示的行长度在单词中断开，则该单词不包括在返回值中，而是出现在使用 MemoLine() 提取的下一行的开头。
      如果 <paramref name="lWrap" /> 为 FALSE，则 MemoLine() 仅返回行长度指定的字符数。<br/>
      使用 MemoLine() 提取的下一行从下一个硬回车后的字符开始，所有中间字符不被处理。
    </returns>
    <remarks>
      MemoLine() 是一个备忘函数，与 MLCount() 一起使用，根据每行的字符数从字符串和备忘字段中提取文本行。<br/>
      它是 X# 提供的用于显示备忘字段和长字符串的最基本功能。
      操作的基本方法是使用 MLCount() 确定字符串中的行数，并指定与您打算在 MemoLine() 中使用的相同数量的每行字符、制表符大小和换行行为。<br/>
      使用此值作为 FOR...NEXT 的上限，可以用 MemoLine() 提取字符串的每一行，并处理所需的任何组合的输出命令和函数。
    </remarks>
    <example>
      此示例演示了使用 MLCount() 和 MemoLine() 组合显示备忘字段和长字符串的一般方法：
      <code language="X#">
        LOCAL nLineLength := 40, nTabSize := 3, lWrap := TRUE
        LOCAL nLines, nCurrentLine
        USE customer INDEX custname NEW
        nLines := MLCount(CustNotes, nLineLength, nTabSize, lWrap)
        SET PRINTER ON
        FOR nCurrentLine := 1 UPTO nLines
        &#0009;? MemoLine(CustNotes, nLineLength, nCurrentLine, nTabSize, lWrap)
        NEXT
        SET PRINTER OFF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MemLines'>MemLines</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemoTran'>MemoTran</seealso>
    <seealso cref='O:XSharp.RT.Functions.MLCount'>MLCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.MLine'>MLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.MLine3'>MLine3</seealso>
    <seealso cref='O:XSharp.RT.Functions.MLPos'>MLPos</seealso>
  </memoline>

  <memoread>
    <summary>
      返回文本文件的内容作为字符串。
    </summary>
    <param name="cFileName">要从磁盘读取的文本文件的名称，包括可选的驱动器、目录和扩展名。SetDefault() 和 SetPath() 设置将被忽略；除非您在文件名中指定驱动器和目录，否则将使用 Windows 默认值。不假定有扩展名。</param>
    <returns>
      文件的内容。<br/>
      可读取的最大文件大小为 MAX_ALLOC 字节 - 字符串的最大大小。
      如果 <paramref name="cFileName" /> 不存在，MemoRead() 返回 NULL_STRING。<br/>
      如果存在，此函数尝试以共享模式打开文件，成功后继续。<br/>
      如果由于另一个进程独占使用文件而导致访问被拒绝，MemoRead() 返回 NULL_STRING，且 NetErr() 被设置为 TRUE。
    </returns>
    <remarks>
      MemoRead() 将磁盘文件读取到内存中，您可以将其作为字符串操作或分配给备忘字段。MemoRead() 与 MemoEdit() 和 MemoWrit() 一起使用，以编辑导入的磁盘文件；然后写回磁盘。
      当 SetAnsi() 为 FALSE 时，此函数会自动进行 OEM 到 ANSI 的转换。
    </remarks>
    <example>
      这个例子使用 MemoRead() 将文本文件的内容分配给 Notes 备忘字段和字符变量：
      <code language="X#">
        REPLACE Notes WITH MemoRead("temp.txt")
        cString = MemoRead("temp.txt")
      </code>
      这个例子定义了一个编辑磁盘文件的函数：
      <code language="X#">
        FUNCTION Editor(cFile)
        &#0009;LOCAL cString AS STRING
        &#0009;If(cString := MemoRead(cFile)) = NULL_STRING
        &#0009;&#0009;? "读取错误 " + cFile
        &#0009;&#0009;RETURN FALSE
        &#0009;ELSE
        &#0009;&#0009;MemoWrit(cFile, MemoEdit(cString))
        &#0009;&#0009;RETURN TRUE
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.RT.Functions.FReadLine'>FReadLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadStr'>FReadStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.MemoWrit'>MemoWrit</seealso>
  </memoread>

  <memory>
    <summary>
      报告内存状态。
    </summary>
    <param name="iFunc">以下常量之一，指示您希望报告的内存信息类型（注意每个常量以 MEMORY_ 前缀开头，如下面的示例所示）：</param>
    <param name="Constant">操作/返回值&#0009;</param>
    <param name="MEMORY_ACTIVATION">激活堆栈表的大小（最大为 64）&#0009;</param>
    <param name="MEMORY_CLASSCOUNT">ClassCount()&#0009;</param>
    <param name="MEMORY_COLLECT">CollectForced()&#0009;</param>
    <param name="MEMORY_COLLECTCOUNT">CollectCount()&#0009;</param>
    <param name="MEMORY_DYNINFOFREE">DynInfoFree()&#0009;</param>
    <param name="MEMORY_DYNINFOMAX">DynInfoMax()&#0009;</param>
    <param name="MEMORY_DYNINFOSIZE">DynInfoSize()&#0009;</param>
    <param name="MEMORY_DYNINFOUSED">DynInfoUsed()&#0009;</param>
    <param name="MEMORY_FUNCTIONCOUNT">FCount()&#0009;</param>
    <param name="MEMORY_MAXATOM">MaxAtom()&#0009;</param>
    <param name="MEMORY_MEMTOTAL">MemTotal()&#0009;</param>
    <param name="MEMORY_PRIVAT">私有变量表的大小（最大为 64）&#0009;</param>
    <param name="MEMORY_PUBLIC">公共变量表的大小（最大为 64）&#0009;</param>
    <param name="MEMORY_REGCOLLNOTIFYEND_COUNT">活动的 _RegCollNotifyEnd() 数量&#0009;</param>
    <param name="MEMORY_REGCOLLNOTIFYSTART_COUNT">活动的 _RegCollNotifyStart() 数量&#0009;</param>
    <param name="MEMORY_REGISTERAXIT">活动的 RegisterAxit() 数量&#0009;</param>
    <param name="MEMORY_REGISTEREXIT_COUNT">活动的 _RegisterExit() 数量&#0009;</param>
    <param name="MEMORY_REGISTERKID">活动的 RegisterKid() 数量&#0009;</param>
    <param name="MEMORY_SEQUENCE">SEQUENCE 表的大小（最大为 64）（见 LABEL...()）&#0009;</param>
    <param name="MEMORY_SP">应用程序的栈指针&#0009;</param>
    <param name="MEMORY_STACK_FREE">可用栈空间（字节）&#0009;</param>
    <param name="MEMORY_STACK_SIZE">应用程序栈段的大小&#0009;</param>
    <param name="MEMORY_STACKKID">活动的堆栈 KID 数量&#0009;</param>
    <param name="MEMORY_SYSTEM_FREE">调用 Windows API GlobalMemoryStatus() 函数，返回 MemoryStatus.dwTotalPhys&#0009;</param>
    <param name="MEMORY_SYSTEM_MAX">调用 Windows API GlobalMemoryStatus() 函数，返回 MemoryStatus.dwAvailPhys&#0009;</param>
    <param name="MEMORY_WINDOWS_SYSTEMRESOURCES">调用 Windows API GlobalMemoryStatus() 函数，返回 MemoryStatus.dwMemoryLoad&#0009;</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      这个例子使用 Memory() 查询各种内存状态：
      <code language="X#">
        ? Memory(MEMORY_SYSTEM_FREE)
        ? Memory(MEMORY_SYSTEM_MAX)
        ? Memory(MEMORY_DYNINFOFREE)
        ? Memory(MEMORY_DYNINFOMAX)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ClassCount'>ClassCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.CollectCount'>CollectCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.CollectForced'>CollectForced</seealso>
    <seealso cref='O:XSharp.VO.Functions.DynCheckError'>DynCheckError</seealso>
    <seealso cref='O:XSharp.VO.Functions.DynInfoFree'>DynInfoFree</seealso>
    <seealso cref='O:XSharp.VO.Functions.DynInfoSize'>DynInfoSize</seealso>
    <seealso cref='O:XSharp.VO.Functions.DynInfoUsed'>DynInfoUsed</seealso>
    <seealso cref='O:XSharp.RT.Functions.FCount'>FCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.MaxAtom'>MaxAtom</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemTotal'>MemTotal</seealso>
  </memory>

  <memotran>
    <summary>
      用可显示的字符替换回车/换行符。
    </summary>
    <param name="cTarget">包含回车/换行符的字符串。</param>
    <param name="cReplaceHardCR">
      用于替换硬回车/换行符对的字符。<br/>
      默认值为分号（;）。
    </param>
    <param name="cReplaceSoftCR">
      用于替换软回车/换行符的字符。<br/>
      默认值为空格。
    </param>
    <returns>
      用指定的回车/换行符对替换后的<cString>副本</cString>。
    </returns>
    <remarks>
      回车/换行符是由MemoEdit()放置在字符串中的行结束格式指示符：
      &#0009;软回车（Chr(141)）是在MemoEdit()窗口宽度超过的情况下插入的换行。
      &#0009;硬回车（Chr(13)）是在用户明确按下Enter键时插入的。
      MemoTran()在显示不在软回车遇到的报告表单的备忘录字段时特别有用。MemoTran()通过将软回车转换为空格来解决这个问题。
    </remarks>
    <example>
      该示例从备忘录字段中删除所有行结束字符：
      <code language="X#">REPLACE _FIELD-&gt;Notes WITH MemoTran(_FIELD-&gt;Notes)</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.HardCR'>HardCR</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrTran'>StrTran</seealso>
  </memotran>

  <memowrit>
    <summary>
      将字符串写入磁盘文件。
    </summary>
    <param name="cFileName">
      目标磁盘文件的名称，包括可选的驱动器、目录和扩展名。SetDefault()和SetPath()设置被忽略；除非您在文件名中指定驱动器和目录，否则使用Windows默认设置。未假定任何扩展名。<br/>

      &#0009;如果<param name="cFileName"/>不存在，则会创建它。<br/>
      如果存在，此函数尝试以独占模式打开文件，如果成功，文件将被覆盖而不发出警告或错误。<br/>
      如果由于例如其他进程正在使用该文件而拒绝访问，则MemoWrit()返回FALSE，并将NetErr()设置为TRUE。
    </param>
    <param name="cString">
      要写入<param name="cFileName"/>的字符串。
    </param>
    <returns>
      如果写入操作成功则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
      MemoWrit()通常与MemoRead()一起使用，将文本文件加载到内存中，可以进行编辑、显示并写回磁盘。您还可以使用MemoWrit()作为将备忘录字段导出到文本文件的快速方法。
      <note type="tip">
        一些字符，例如“ß”，在ANSI和OEM代码中有所不同。当将这些字符从Windows写入文件时，您可能需要发出Ansi2Oem()函数。相反，当将文件读回Windows时，您可能需要发出Oem2Ansi()函数。<br/>
        为避免此类问题，当SetAnsi()为FALSE时，MemoWrit()会自动进行ANSI到OEM的转换。
      </note>
    </remarks>
    <example>
      该示例使用MemoWrit()将字段的内容保存到文本文件：
      <code language="X#">
        USE Sales
        IF MemoWrit("votmp.txt", Sales-&gt;Notes)
        &#0009;? "已保存"
        ELSE
        &#0009;? "写入cliptmp.txt时出错"
        &#0009;BREAK
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.MemoRead'>MemoRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
  </memowrit>

  <memset>
    <summary>
      用指定字符填充内存缓冲区。
    </summary>
    <param name="ptrBuffer">要填充的内存缓冲区的指针。</param>
    <param name="bValue">字符的代码，范围从 0 到 255。</param>
    <param name="wCount">要填充的字节数。</param>
    <returns>
      指向填充后的内存缓冲区的指针。
    </returns>
    <remarks>
      MemSet() 将指向的内存缓冲区的前 <paramref name="wCount" /> 个字符设置为指定的字符。
      <note type="tip">
        此函数允许直接操作内存位置，使用时需格外小心。
      </note>
    </remarks>
    <example>
      此示例使用 MemSet() 用 "A" 填充分配的缓冲区的所有字符：
      <code language="X#">
        FUNCTION MemReplicate() AS VOID
        &#0009;LOCAL ptrC AS PTR
        &#0009;ptrC := MemAlloc(10)
        &#0009;ptrC := MemSet(ptrC, Asc("A"),10)
        &#0009;? ptrC&#0009;&#0009;&#0009;&#0009;&#0009;// AAAAAAAAAA
        &#0009;MemFree(ptrC)
      </code>
      此示例使用 MemSet() 将 PSZ 的所有字符更改为 "Z"：
      <code language="X#">
        FUNCTION PszQ()
        &#0009;LOCAL pszS := "ABC" AS PSZ
        &#0009;// Asc("Z") = 90
        &#0009;MemSet(pszS, 90,3)
        &#0009;? pszS&#0009;&#0009;&#0009;&#0009;&#0009;// ZZZ
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemClear'>MemClear</seealso>
  </memset>

  <memshort>
    <summary>
      获取内存缓冲区中匹配的短整数的指针。
    </summary>
    <param name="ptrBuffer">要检查的内存缓冲区的指针。</param>
    <param name="siValue">要匹配的短整数值。</param>
    <param name="dwCount">
      要检查的 <paramref name="ptrBuffer" /> 中的短整数数量。
    </param>
    <returns>
      指向 <paramref name="ptrBuffer" /> 中前 <paramref name="dwCount" /> 个短整数的第一次出现的 <paramref name="siValue" /> 的指针。<br/>
      如果未匹配 <paramref name="siValue" />，MemShort() 将返回 NULL_PTR。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例在 PSZ 上使用 MemShort()：
      <code language="X#">
        FUNCTION StartShort()
        &#0009;LOCAL ptrSI := "ABCDEFGHIJ" AS PSZ
        &#0009;// 注意：短整数转换的 "AB" 的值为 16961
        &#0009;? MemShort(ptrSI, 16961,2) &#0009;&#0009;// 一个指针
        &#0009;? MemShort(ptrSI, 16961,1) &#0009;&#0009;// 一个指针
        &#0009;// 与上面的指针相同
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemByte'>MemByte</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemChr'>MemChr</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemDWord'>MemDWord</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemInt'>MemInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemLong'>MemLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemWord'>MemWord</seealso>
  </memshort>

  <memtotal>
    <summary>
      报告其他内存管理函数使用的总字节数。
    </summary>
    <returns>
      内存管理函数消耗的总内存。<br/>
      此值四舍五入或在 4 KB 增量内准确。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例在通过 MemAllocSeg() 函数分配内存缓冲区之前和之后使用 MemTotal()：
      <code language="X#">
        ? MemTotal()
        w := MemAllocSeg(100)
        ? MemTotal()&#0009;&#0009;&#0009;// 大于第一次调用的值
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemAlloc'>MemAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemCAlloc'>MemCAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemGrpAlloc'>MemGrpAlloc</seealso>
  </memtotal>

  <memvarblock>
    <summary>
      返回给定内存变量的设置-获取代码块。
    </summary>
    <param name="cMemvarName">设置-获取块所指代的变量的名称。</param>
    <returns>
      一个运行时代码块（实现为对象），当被评估时，设置（赋值）或获取（检索）<paramref name="cMemvarName" /> 的值。<br/>
      如果 <paramref name="cMemvarName" /> 不存在，MemVarBlock() 将返回 NULL_OBJECT。
    </returns>
    <remarks>
      MemVarBlock() 创建的代码块有两个操作，具体取决于在评估代码块时是否传递了参数：
      &#0009;如果评估代码块时带有参数，则将该参数的值赋给 <paramref name="cMemvarName" />。
      &#0009;如果评估代码块时不带参数，则检索 <paramref name="cMemvarName" /> 的值。
      <note type="tip">
        MemVarBlock() 仅为运行时已知的变量名创建设置-获取块。因此，MemVarBlock() 不能用于为局部或静态变量创建设置-获取块。
        &#0009;同样的限制适用于使用宏操作符 (&amp;) 创建块。
      </note>
    </remarks>
    <example>
      此示例将 MemVarBlock() 与使用宏操作符 (&amp;) 创建的代码块进行比较。请注意，使用 MemVarBlock() 可以避免宏操作符的速度和大小开销：
      <code language="X#">
        PRIVATE var := "这是一个字符串"
        // 使用宏操作符定义的设置-获取块
        cbSetGet := &amp;("{|setVal|;
        &#0009;&#0009;如果(setVal = NIL, var, var := setVal)}")
        // 使用 MemVarBlock() 定义的设置-获取块。
        // 它与上面的 cbSetGet 功能等效
        cbSetGet := MemVarBlock("var")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldBlock'>FieldBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldWBlock'>FieldWBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarBlockSym'>MemVarBlockSym</seealso>
  </memvarblock>

  <memvarblocksym>
    <summary>
      获取给定内存变量的设置-获取代码块。
    </summary>
    <param name="symMemvarName">一个作为设置-获取块引用的变量名称的符号。</param>
    <returns>
      一个运行时代码块（实现为对象），当被评估时，设置（赋值）或获取（检索）<paramref name="cMemvarName" /> 的值。<br/>
      如果 <paramref name="cMemvarName" /> 不存在，MemVarBlockSym() 返回 NULL_OBJECT。
    </returns>
    <remarks>
      MemVarBlockSym() 创建的代码块有两个操作，具体取决于在评估代码块时是否传递了参数：<br/>
      如果评估代码块时带有参数，则将该参数的值赋给 <paramref name="cMemvarName" />；<br/>
      如果评估代码块时不带参数，则检索 <paramref name="cMemvarName" /> 的值。<br/>
      <note type="tip">
        MemVarBlockSym() 仅为运行时已知的变量名创建设置-获取块。因此，MemVarBlockSym() 不能用于为局部或静态变量创建设置-获取块。<br/>
        同样的限制适用于使用宏操作符 (&amp;) 创建块。
      </note>
    </remarks>
    <example>
      此示例将 MemVarBlockSym() 与使用宏操作符 (&amp;) 创建的代码块进行比较。请注意，使用 MemVarBlockSym() 可以避免宏操作符的速度和大小开销：
      <code language="X#">
        PRIVATE var := "这是一个字符串"
        // 使用宏操作符定义的设置-获取块
        cbSetGet := &amp;({"|setVal|;
        &#0009;&#0009;如果(setVal = NIL, var, var := setVal)}")
        // 使用 MemVarBlockSym() 定义的设置-获取块。
        // 它与上面的 cbSetGet 功能等效
        cbSetGet := MemVarBlockSym(#var)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldBlock'>FieldBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldWBlock'>FieldWBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarBlock'>MemVarBlock</seealso>
  </memvarblocksym>

  <memvarget>
    <summary>
      返回内存变量的内容。
    </summary>
    <param name="cVarName">内存变量的名称。</param>
    <returns>
    </returns>
    <remarks>
      当变量的名称在字符串中时，使用 MemVarGet() 代替宏。
    </remarks>
    <example>
      此示例使用 MemVarGet() 检索内存变量的内容：
      <code language="X#">
        cPrivate := "hi"
        cHasName := "cPrivate"
        // 替代 ? &amp;cHasName，使用：
        ? MemVarGet(cHasName)&#0009;&#0009;&#0009;// hi
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarGet'>IVarGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarPut'>MemVarPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.VarGet'>VarGet</seealso>
  </memvarget>

  <memvarput>
    <summary>
      为给定名称的内存变量分配一个值。
    </summary>
    <param name="cVarName">您想要创建的变量的名称。</param>
    <param name="uValue">要分配给变量的值。</param>
    <returns>
      分配给 <paramref name="uValue" /> 的值。
    </returns>
    <remarks>
      如果名为 <paramref name="cVarName" /> 的内存变量不存在，则会创建一个名为 <paramref name="cVarName" /> 的内存变量。<br/>
      因此，MemVarPut() 和 VarPut() 可用于创建未声明的内存变量。<br/>
      它应代替宏使用。
      <note type="tip">
        此函数允许直接操作内存位置，使用时需极其小心。
      </note>
    </remarks>
    <example>
      此示例使用 MemVarPut() 创建一个内存变量：
      <code language="X#">
        LOCAL cHasName AS STRING
        cHasName := "cPrivate"
        // 替代 &amp;cHasName := "new"，使用：
        MemVarPut(cHasName, "new")
        ? cPrivate&#0009;&#0009;&#0009;&#0009;&#0009;// new
      </code>
      此示例显示新创建的变量是一个 MEMVAR：
      <code language="X#">
        MemVarPut("cVar", "hi")
        ? _MEMVAR-&gt;cVar&#0009;&#0009;&#0009;// hi
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarPut'>IVarPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarGet'>MemVarGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.VarPut'>VarPut</seealso>
  </memvarput>

  <memwalk>
    <summary>
      遍历内存系统，检查有效性。
    </summary>
    <returns>
      如果成功返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例在使用其他内存管理函数分配和释放内存后使用 MemWalk()：
      <code language="X#">
        p := MemAlloc(100)
        MemFree(p)
        ? MemWalk()
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemAlloc'>MemAlloc</seealso>
  </memwalk>

  <memword>
    <summary>
      获取指向内存缓冲区中匹配字的指针。
    </summary>
    <param name="ptrBuffer">要检查的内存缓冲区的指针。</param>
    <param name="dwValue">要匹配的字值。</param>
    <param name="dwCount">
      要检查的 <paramref name="ptrBuffer" /> 中的字数。
    </param>
    <returns>
      指向 <paramref name="dwValue" /> 在 <paramref name="ptrBuffer" /> 前 <paramref name="dwCount" /> 个字中的第一次出现的指针。<br/>
      如果未匹配 <paramref name="dwValue" />，MemWord() 返回 NULL_PTR。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例在 PSZ 上使用 MemWord()：
      <code language="X#">
        Function Start()
        &#0009;LOCAL ptrW := "ABCDEFGHIJ" AS PSZ
        &#0009;? MemWord(ptrW, Bin2W("CD"), 3)&#0009;// 一个指针
        &#0009;? MemWord(ptrW, Bin2W("CD"), 1)
        &#0009;// 在 ptrW 的第一个字中未找到
        &#0009;//   0000:0000
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemAtSpecial'>MemAtSpecial</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemByte'>MemByte</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemChr'>MemChr</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemClear'>MemClear</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemComp'>MemComp</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemDWord'>MemDWord</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemInt'>MemInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemLong'>MemLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemShort'>MemShort</seealso>
  </memword>

  <methodlist>
    <summary>
      创建指定对象的类列表，以数组形式返回。
    </summary>
    <param name="oClass">要列出方法的对象。</param>
    <returns>
      包含为 <paramref name="symObject" /> 定义的所有方法名称的符号数组。
    </returns>
    <remarks>
      此函数创建为指定对象定义的所有方法的列表。<br/>
      生成的方法列表数组不包括 ACCESS 或 ASSIGN 方法。
    </remarks>
    <example>
      此示例使用 MethodList() 存储 Person 类对象的方法列表，然后显示结果数组。请注意，ACCESS 方法被忽略。
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL oPerson AS Person
        &#0009;oPerson := Person{"Susan", 5, "Cue"}
        &#0009;AEval(MethodList(oPerson),{|x| QOut(x)})
        &#0009;// 结果是：
        &#0009;// INIT
        &#0009;// SHOWGRADE
        CLASS Person
        &#0009;EXPORT name
        &#0009;INSTANCE grade
        &#0009;PROTECT password
        CONSTRUCTOR(tname, tgrade, tpassword)
        &#0009;name := tname
        &#0009;grade := tgrade
        &#0009;password := tpassword
        METHOD ShowGrade()
        &#0009;? grade
        ACCESS Grade()
        &#0009;RETURN grade
        END CLASS
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IvarList'>IVarList</seealso>
    <seealso cref='O:XSharp.RT.Functions.MethodListClass'>MethodListClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.Object2Array'>Object2Array</seealso>
  </methodlist>

  <methodlistclass>
    <summary>
      创建指定类的类列表，以数组形式返回。
    </summary>
    <param name="symClass">要列出方法的类。</param>
    <returns>
      包含为 <paramref name="symClass" /> 定义的所有方法名称的符号数组。
    </returns>
    <remarks>
      此函数创建为指定类定义的所有方法的列表。<br/>
      生成的方法列表数组不包括 ACCESS 或 ASSIGN 方法。
    </remarks>
    <example>
      此示例使用 MethodListClass() 存储 Person 类对象的方法列表，然后显示结果数组。请注意，ACCESS 方法被忽略。
      <code language="X#">
        FUNCTION Start()
        &#0009;AEval(MethodListClass(#Person),{|x| QOut(x)})
        &#0009;// 结果是：
        &#0009;// INIT
        &#0009;// SHOWGRADE
        CLASS Person
        &#0009;EXPORT name
        &#0009;INSTANCE grade
        &#0009;PROTECT password
        CONSTRUCTOR(tname, tgrade, tpassword)
        &#0009;name := tname
        &#0009;grade := tgrade
        &#0009;password := tpassword
        METHOD ShowGrade()
        &#0009;? grade
        ACCESS Grade()
        &#0009;RETURN grade
        END CLASS
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IvarListClass'>IVarListClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.MethodList'>MethodList</seealso>
    <seealso cref='O:XSharp.RT.Functions.Object2Array'>Object2Array</seealso>
  </methodlistclass>

  <mexec>
    <summary>
      评估宏编译的字符串。
    </summary>
    <param name="oBlock">宏编译的字符串。</param>
    <returns>
      编译表达式的值。
    </returns>
    <remarks>
      MExec() 评估先前宏编译的表达式。
      与其每次评估表达式时调用宏编译器，不如仅编译一次表达式，并在需要时执行已编译的结果，从而加快应用程序速度。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/mcompilemexec/*" />
    </remarks>
    <example>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/mcompileexamples/*" />
    </example>
    <seealso cref='O:XSharp.RT.Functions.Evaluate'>Evaluate</seealso>
    <seealso cref='O:XSharp.RT.Functions.MAssign'>MAssign</seealso>
    <seealso cref='O:XSharp.RT.Functions.MCompile'>MCompile</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.ExecScript'>ExecScript</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrEvaluate'>StrEvaluate</seealso>
    <seealso cref='T:XSharp._Codeblock'>_Codeblock 类型</seealso>
  </mexec>

  <min>
    <summary>
      返回两个值中的较小者。
    </summary>
    <param name="dValue1">要比较的第一个值。</param>
    <param name="dValue2">要比较的第二个值。</param>
    <param name="uValue1">要比较的第一个值。</param>
    <param name="uValue2">
      要比较的第二个值。<br/>
      这必须与 <paramref name="uValue1" /> 的类型相同，但允许不同类型的数字。
    </param>
    <returns>
      两个参数中较小的那个。<br/>
      返回的值与较小参数的类型相同。
    </returns>
    <remarks>
      Min() 的反函数是 Max()，它返回两个表达式中的较大者。
    </remarks>
    <example>
      在以下示例中，Min() 返回两个数字中的较小者：
      <code language="X#">
        ? MIN(99, 100)&#0009;&#0009;&#0009;&#0009;&#0009;// 99
        ? MIN(100, 99)&#0009;&#0009;&#0009;&#0009;&#0009;// 99
      </code>
      在以下示例中，Min() 比较日期值：
      <code language="X#">
        ? TODAY()&#0009;&#0009;&#0009;&#0009;&#0009;// 05/27/93
        ? MIN(TODAY(), TODAY() + 30)&#0009;&#0009;// 05/27/93
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Between'>Between</seealso>
    <seealso cref='O:XSharp.RT.Functions.Max'>Max</seealso>
    <seealso cref="O:XSharp.Core.Functions.Min" />
  </min>

  <mlcount>
    <summary>
      计算字符串中的行数。
    </summary>
    <param name="cString">要计数的字符串。</param>
    <param name="nLineLength">
      每行字符数，范围从 4 到 254。<br/>
      默认行长度为 79。
    </param>
    <param name="nTabSize">
      用户按下 Tab 键时要插入的字符数。<br/>
      默认值为 4。<br/>
      如果 <paramref name="nTabSize" /> 大于或等于 <paramref name="nLineLength" />，则 Tab 大小自动转换为 <paramref name="nLineLength" /> 减 1。
    </param>
    <param name="lWrap">
      控制单词是否换行到下一行：TRUE 表示换行；FALSE 表示不换行。<br/>
      默认值为 TRUE。
    </param>
    <returns>
      <paramref name="cString" /> 中的行数，取决于 <paramref name="nLineLength" />、<paramref name="nTabSize" /> 和换行是否开启。
    </returns>
    <remarks>
      MLCount() 是一个备忘录函数，用于与 MemoLine() 一起打印字符串和备忘录字段，基于每行的字符数。基本操作中，使用 MLCount() 返回字符串的行数。<br/>
      然后，使用 MemoLine() 提取每一行，循环遍历字符串，直到没有剩余行。
      如果 <paramref name="lWrap" /> 为 TRUE，并且行末位置断开了一个单词，则该单词将换到下一行，下一行以该单词开始。<br/>
      如果 <paramref name="lWrap" /> 为 FALSE，MLCount() 计算当前行中的字符数，按照 <paramref name="nLineLength" /> 指定的字符数进行计算。<br/>
      下一行从下一个硬回车或软回车后的字符开始，中间的字符将被忽略。
    </remarks>
    <example>
      此示例逐行显示 SALES 数据库文件中每个 Notes 备忘录字段的内容：
      <code language="X#">
        USE sales NEW
        nLineLength = 65
        DO WHILE !EOF()
        &#0009;nLines = MLCount(Sales-&gt;Notes, nLineLength)
        &#0009;FOR nCurrLine = 1 UPTO nLines
        &#0009;&#0009;? MemoLine(Sales-&gt;Notes, nLineLength, nCurrLine)
        &#0009;NEXT
        &#0009;SKIP
        &#0009;?
        ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MemLines'>MemLines</seealso>
    <seealso cref='O:XSharp.Core.Functions.MemoLine'>MemoLine</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemoTran'>MemoTran</seealso>
    <seealso cref='O:XSharp.Core.Functions.MLCount1'>MLCount1</seealso>
    <seealso cref='O:XSharp.RT.Functions.MLPos'>MLPos</seealso>
  </mlcount>

  <mlcount1>
    <summary>
      计算字符串中的行数。
    </summary>
    <param name="cString">要计数的字符串。</param>
    <returns>
      <paramref name="cString" /> 中的行数。
    </returns>
    <remarks>
      MLCount1() 与 MLCount() 类似，但 MLCount1() 只有一个参数，并且该参数是强类型的。有关更多信息，请参见 MLCount()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MLCount'>MLCount</seealso>
  </mlcount1>

  <mlctopos>
    <summary>
      返回格式化字符串中字符的位置。
    </summary>
    <param name="cText">字符串。</param>
    <param name="nWidth">
      <paramref name="cText" /> 格式化后每行的长度。
    </param>
    <param name="nLine">格式化文本中的行号，从顶部开始，起始值为 1。</param>
    <param name="nCol">格式化文本中的列号，从左侧开始，起始值为 0。</param>
    <param name="nTabSize">
      用户按下 Tab 键时插入的字符数。<br/>
      如果未指定 <paramref name="nTabSize" />，则插入 4 个空格。
    </param>
    <param name="lWrap">
      单词换行标志。<br/>
      默认值为 TRUE。
    </param>
    <returns>
      在 <paramref name="cText" /> 中字符的字节位置，从 1 开始计数。
    </returns>
    <remarks>
      MLCToPos() 确定在格式化文本中特定行和列对应的字符位置。请注意，行号是以 1 为基数，而列号是以 0 为基数。<br/>
      这与 MemoEdit() 兼容。<br/>
      返回值是以 1 为基数，适用于 Substr() 或其他字符串函数。
      MLCToPos() 与 MPosToLC() 一起使用，以创建搜索例程或其他文本处理，用于 MemoEdit()。
    </remarks>
    <example>
      此示例给出在格式化时行长度为 5 字符的情况下，第三行、零列中将出现的字符的当前字符位置：
      <code language="X#">
        cText := "注意面包的涂抹侧" + "是黄油的。"
        ? MLCToPos(cText, 5, 3, 0)&#0009;&#0009;// 结果：10
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MLPos'>MLPos</seealso>
    <seealso cref='O:XSharp.RT.Functions.MPosToLc'>MPosToLC</seealso>
  </mlctopos>

  <mline>
    <summary>
      从字符串中提取文本行，并指定可选的偏移量参数。
    </summary>
    <param name="cString">包含文本行的字符串。</param>
    <param name="nLine">要提取的行号。</param>
    <param name="nOffset">
      提取字符的位置。<br/>
      偏移量为 0 对应于 <paramref name="cString" /> 中的第一个字节。<br/>
      这是默认值。<br/>
      或者，<paramref name="nOffset" /> 可以通过引用传递（在前面加上 @），此时函数调用后，它将包含返回行的大小。
    </param>
    <returns>
      指定的行。<br/>
      如果指定的行不存在，则返回值为 NULL_STRING。<br/>
      当遇到硬回车时，新行开始。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 MLine() 提取超过偏移量 10 的第一行（第 11 个字符）。
      <code language="X#">? MLine(Customer-&gt;Memos, 1, 10)</code>
      此示例将 MLine() 应用到具有两行的字符串：
      <code language="X#">
        ? MLine(Space(30)+Chr(13)+Space(40), 1)
        // 返回第一行 (Space(30))
      </code>
      此示例通过引用传递 <paramref name="nOffset" />：
      <code language="X#">
        nOffset := 0
        ? MLine(Space(30)+Chr(13)+Space(40), 1, @nOffset)
        &#0009;// Space(30)
        ? nOffset&#0009;&#0009;&#0009;&#0009;// 30
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MemoLine'>MemoLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.MLine3'>MLine3</seealso>
  </mline>

  <mline3>
    <summary>
      从字符串中提取文本行，并指定必需的偏移量参数。
    </summary>
    <param name="cString">包含文本行的字符串。</param>
    <param name="dwLine">要提取的行号。</param>
    <param name="ptrN">
      <paramref name="ptrN" /> 必须是一个 DWORD 变量，通过引用传递。<br/>
      在函数调用结束时，<paramref name="ptrN" /> 将包含返回行 (cLineString) 的最后一个字符的偏移量。
    </param>
    <returns>
      指定的行。<br/>
      如果指定的行不存在，则返回值为 NULL_STRING，且 <paramref name="ptrN" /> 的值为 0。
    </returns>
    <remarks>
      MLine3() 类似于 MLine()，但所有三个参数都是必需的，并且它存储相对于 <paramref name="cString" /> 开始位置的最后返回字符的偏移量。有关更多信息，请参见 MLine()。
    </remarks>
    <example>
      此示例显示字符或备忘字段中所有行的内容和大小：
      <code language="X#">
        LOCAL dwOffset AS DWORD
        LOCAL dwLines AS DWORD
        LOCAL i AS DWORD
        dwLines := MemLines(_FIELD-&gt;Mail)
        FOR i := 1 UPTO dwLines
        &#0009;// 按顺序提取行
        &#0009;? MLine3(_FIELD-&gt;Mail, i, @dwOffset)
        &#0009;? dwOffset&#0009;&#0009;&#0009;// 行的长度
        NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MemoLine'>MemoLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.MLine'>MLine</seealso>
  </mline3>

  <mlpos>
    <summary>
      确定字符串中行的位置。
    </summary>
    <param name="cText">一个字符串。</param>
    <param name="nWidth">
      <paramref name="cText" /> 格式化后每行的长度。
    </param>
    <param name="nLine">格式化文本中的行号，从顶部开始，起始值为 1。</param>
    <param name="nTabSize">
      用户按下 Tab 键时插入的字符数。<br/>
      如果未指定 <paramref name="nTabSize" />，则插入 4 个空格。
    </param>
    <param name="lWrap">
      单词换行标志。<br/>
      默认值为 TRUE。
    </param>
    <returns>
      <paramref name="wLine" /> 在 <paramref name="cString" /> 中的字符位置。<br/>
      如果 <paramref name="wLine" /> 大于 <paramref name="cString" /> 中的行数，MLPos() 返回 <paramref name="cString" /> 的长度。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 MLPos() 查找特定行的位置，给定行长度为 40：
      <code language="X#">
        LOCAL cString AS STRING
        LOCAL wLine AS DWORD
        LOCAL wPosition AS DWORD
        cString = MemoRead("temp.txt")
        nLineLength = 40
        wLine = 5
        wPosition = MLPos(cString, nLineLength, wLine)
        ? Substr(cString, wPosition, 12)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.MemoLine'>MemoLine</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemoTran'>MemoTran</seealso>
    <seealso cref='O:XSharp.RT.Functions.MLCount'>MLCount</seealso>
    <seealso cref='O:XSharp.Core.Functions.MLPos2'>MLPos2</seealso>
  </mlpos>

  <mlpos2>
    <summary>
      确定字符串中行的位置。
    </summary>
    <param name="cString">一个字符串。</param>
    <param name="dwLine">行号。</param>
    <returns>
      <paramref name="dwLine" /> 在 <paramref name="cString" /> 中的字符位置。<br/>
      如果 <paramref name="dwLine" /> 大于 <paramref name="cString" /> 中的行数，MLPos2() 返回 <paramref name="cString" /> 的长度。
    </returns>
    <remarks>
      MLPos2() 类似于 MLPos()，但 MLPos2() 只有两个参数，并且这些参数是强类型的。有关更多信息，请参见 MLPos()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MLPos'>MLPos</seealso>
  </mlpos2>

  <mod>
    <summary>
      返回一个数字除以另一个数字的余数。
    </summary>
    <param name="nDividend">除法运算的被除数。</param>
    <param name="nDivisor">除法运算的除数。</param>
    <returns>
      一个数字，表示 <paramref name="nDividend" /> 除以 <paramref name="nDivisor" /> 的余数。
    </returns>
    <remarks>
      Mod() 并不是使用 X# 的取模运算符 (%) 实现的。请注意，Mod() 函数和取模运算符之间存在差异，具体如下表所示：
      被除数&#0009;除数&#0009;取模运算符&#0009;Mod() 函数&#0009;
      3&#0009; 0&#0009;错误&#0009; 3&#0009;
      3&#0009;-2&#0009; 1&#0009;-1&#0009;
      -3&#0009; 2&#0009;-1&#0009; 1&#0009;
      -3&#0009; 0&#0009;错误&#0009;-3&#0009;
      -1&#0009; 3&#0009;-1&#0009; 2&#0009;
      -2&#0009; 3&#0009;-2&#0009; 1&#0009;
      2&#0009;-3&#0009; 2&#0009;-1&#0009;
      1&#0009;-3&#0009; 1&#0009;-2&#0009;
      <note type="tip">
        在 dBASE III PLUS 中，0 除数对所有被除数返回被除数。在 CA-Clipper 夏季 '87 之前的版本中，0 除数对所有被除数返回 0。相反，在 X# 中，任何被除数使用 0 除数的取模会导致运行时错误。
      </note>
    </remarks>
    <example>
    </example>
  </mod>

  <month>
    <summary>
      从日期中提取月份的数字。
    </summary>
    <param name="dDate">日期。</param>
    <returns>
      从 0 到 12 的数字。指定 NULL_DATE 返回 0。
    </returns>
    <remarks>
      Month() 是一个日期转换函数，当您在计算中需要数字月份值时非常有用，例如用于定期报告。
      Month() 是一组函数中的一个，它们将日期值的组成部分作为数字返回。<br/>
      该组包括 Day() 和 Year()，用于返回日期的日和年值作为数字。CMonth() 是一个相关函数，允许您从日期值返回月份的名称。
    </remarks>
    <example>
      这些示例返回系统日期的月份：
      <code language="X#">
        ? Today()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 09/01/90
        ? Month(Today())&#0009;&#0009;&#0009;&#0009;// 9
        // 提前一个月：
        ? Month(Today()) + 1&#0009;&#0009;&#0009;// 10
      </code>
      该示例结合使用 month、Day() 和 Year()：
      <code language="X#">
        ?"我们已经", Year(Today()), "年,",;
        &#0009;&#0009;Month(Today()), "个月，和", Day(Today()),;
        &#0009;&#0009;&#0009;"天进入我们的历史！"
      </code>
      该示例显示传递 NULL_DATE 时的结果：
      <code language="X#">? Month(NULL_DATE)&#0009;&#0009;&#0009;&#0009;// 0</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CMonth'>CMonth</seealso>
    <seealso cref='O:XSharp.RT.Functions.Day'>Day</seealso>
    <seealso cref='O:XSharp.RT.Functions.DoW'>DoW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Year'>Year</seealso>
  </month>

  <mparamcount>
    <summary>
      返回方法期望的参数数量。
    </summary>
    <param name="symClass">包含要检查方法的类的符号。</param>
    <param name="symMethod">方法名称，不带括号。</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 MParamCount() 获取 Rectangle 类中 Area 方法期望的参数数量。此外，示例设置了一个 Geometry 类，其中的 IdentifyObject() 方法使用 MParamCount() 收集有关不同对象的信息：
      <code language="X#">
        CLASS Rectangle
        METHOD Area(x, y) CLASS Rectangle
        RETURN x*y
        CLASS Geometry
        METHOD IdentifyObject(symObject, symMethod);
        &#0009;CLASS Geometry
        RETURN MParamCount(symObject, symMethod)
        Function Start()
        &#0009;LOCAL oShapes AS OBJECT
        &#0009;? MParamCount(#Rectangle, #Area)&#0009;&#0009;// 2
        &#0009;oShapes := Geometry{}
        &#0009;? "这是一个 "+NTrim(oShapes:IdentifyObject;
        &#0009;&#0009;(#Rectangle, #Area))+ " 维的对象"
        &#0009;// 它是一个 2 维的对象
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CParamCount'>CParamCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.FParamCount'>FParamCount</seealso>
  </mparamcount>

  <mpostolc>
    <summary>
      返回格式化字符串中字符的行和列位置。
    </summary>
    <param name="cText">一个字符串。</param>
    <param name="nWidth">
      <paramref name="cText" /> 格式化后每行的长度。
    </param>
    <param name="nPos">在格式化文本中的字节位置，从 1 开始计数。</param>
    <param name="nTabSize">
      用户按下 Tab 时插入的字符数。<br/>
      如果未指定 <paramref name="nTabSize" />，则插入 4 个空格。
    </param>
    <param name="lWrap">
      单词换行标志。<br/>
      默认值为 TRUE。
    </param>
    <returns>
      包含指定位置字符的行和列号的数组。
    </returns>
    <remarks>
      MPosToLC() 确定与 <paramref name="cText" /> 中特定字符位置对应的格式化行和列。请注意，返回的行号是以 1 为基数，列号是以 0 为基数。<br/>
      这与 MemoEdit() 兼容。<paramref name="nPos" /> 是以 1 为基数，这与 At()、RAt() 和其他字符串函数兼容。
      MPosToLC() 与 MLCToPos() 一起使用，以创建搜索例程或其他文本处理，用于 MemoEdit()。
    </remarks>
    <example>
      此示例确定文本字符串第十个字符对应的行和列，假设格式化宽度为五列。<br/>
      五列的格式化宽度会导致前 3 个单词分别放在一行中。<br/>
      文本的第十个字符是 "side" 中的 "s"。<br/>
      单词 "side" 将位于格式化文本的第三行的最左侧列，因此返回值为 {3, 0}：
      <code language="X#">
        cText := "注意面包的涂抹面向哪一侧" + "。"
        aLC := MPosToLC(cText, 5, 10)&#0009;// 结果: {3, 0}
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MLcToPos'>MLCToPos</seealso>
    <seealso cref='O:XSharp.RT.Functions.MLPos'>MLPos</seealso>
  </mpostolc>

  <neterr>
    <summary>
      检测并发冲突。
    </summary>
    <param name="lNewError">设置 NetErr() 返回的值为 TRUE 或 FALSE。设置 NetErr() 允许运行时错误处理程序控制某些并发控制错误的处理方式。</param>
    <returns>
      如果发生并发冲突或通过 <paramref name="lNewError" /> 参数程序性设置为 TRUE，则返回 TRUE；否则返回 FALSE。<br/>
      初始值为 FALSE。
    </returns>
    <remarks>
      NetErr() 是由某些操作设置的全局标志，用于测试以下情况的并发控制冲突：
      尝试的操作
      &#0009;NetErr() 为 TRUE&#0009;
      使用 APPEND BLANK 或 DBAppend() 追加空白记录
      &#0009;如果另一个进程在进行文件锁定或记录锁定 LastRec() + 1（例如，同时追加空白操作）&#0009;
      以共享或独占模式打开文件（例如，使用 USE 或 DBUseArea()）
      &#0009;如果另一个进程独占使用该文件&#0009;
      以独占模式打开文件（例如，使用 USE...EXCLUSIVE 或 DBUseArea()，并将 <paramref name="lShared" /> 设置为 FALSE）
      &#0009;如果另一个进程以共享或独占模式打开该文件&#0009;
      在这些情况下，内部结果会导致运行时错误，调用已安装的错误处理程序。
      &#0009;默认错误处理程序的源代码定义在 X# \SAMPLES 目录中的 ERRORSYS.PRG 文件中，在这些情况下不会显示错误消息，允许您的应用程序继续。
      NetErr() 通常通过测试这些操作之一在程序中应用。
      &#0009;如果函数返回 FALSE，您可以执行下一个操作。<br/>
      否则，您必须通过重试操作或通过使用 BREAK 或 RETURN 来处理错误。
    </remarks>
    <example>
      此示例演示 NetErr() 的典型用法。<br/>
      如果 USE 成功，则打开索引文件并继续处理。<br/>
      如果 USE 失败，则显示消息，并控制返回到最近的 BEGIN SEQUENCE 构造：
      <code language="X#">
        USE customer SHARED NEW
        IF !NetErr()
        &#0009;SET INDEX TO custnum, custorders, custzip
        ELSE
        &#0009;? "文件正在被另一个进程使用"
        ENDIF
      </code>
    </example>
    <seealsocmd>APPEND BLANK</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.Flock'>FLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.RLock'>RLock</seealso>
    <seealsocmd>USE</seealsocmd>
  </neterr>

  <netname>
    <summary>
      识别当前工作站。
    </summary>
    <returns>
      工作站 ID，字符串长度最多为 15 个字符。<br/>
      如果工作站 ID 从未设置或应用程序未在 Microsoft LAN Manager 下运行，则返回 NULL_STRING。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例演示当工作站作为网络节点启动，且站点标识符为 "STATION 1" 时 NetName() 的结果：
      <code language="X#">? NetName()&#0009;&#0009;// 结果: STATION 1</code>
      此示例演示当工作站作为独立单元启动时 NetName() 的结果：
      <code language="X#">? NetName()&#0009;&#0009;// 结果: NULL_STRING</code>
    </example>
  </netname>

  <newindexlock>
    <summary>
      返回并可选择更改设置，以确定是否在 .NTX 文件中使用新的锁定偏移量 -1 (0xFFFFFFFF)。
    </summary>
    <param name="lNewSetting">
      TRUE 使用新的锁定偏移量。 FALSE 使用 10 亿字节的锁定偏移量。<br/>
      &#0009;初始默认值为 FALSE。
    </param>
    <returns>
      如果未指定 <paramref name="lNewSetting" />，则 NewIndexLock() 返回当前设置。<br/>
      如果指定了 <paramref name="lNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      默认情况下，此函数设置当前工作区域的索引锁定偏移量。<br/>
      可以通过在别名表达式中指定，使其作用于未选择的工作区域。因此，您可以为每个工作区域设置单独的标志。然而，您不能在同一工作区域中使用具有不同锁定偏移量的索引文件。
      此设置仅影响新创建的索引文件。<br/>
      对于现有文件，其锁定偏移量由文件头记录中存储的信息决定。
      注意：<br/>
      此函数可能未针对除 DBFNTX 之外的 RDD 实现。
      使用 NewIndexLock(FALSE) 创建的索引文件实际上具有一个内置限制，将数据库文件的大小限制为 1 GB。<br/>
      如果您不需要与 Xbase 应用程序兼容，可以使用 NewIndexLock(TRUE) 实现不限制文件大小的锁定偏移量。
      重要！<br/>
      如果您的应用程序必须与 Xbase 产品同时或不同时共享数据，则不要设置 NewIndexLock(TRUE)，除非其他应用程序也可以这样做。这样会使您的 .NTX 文件与这些产品不兼容。
    </remarks>
    <example>
      此示例说明在对函数进行几次调用后 NewIndexLock() 的状态：
      <code language="X#">
        ? NewIndexLock()&#0009;&#0009;// FALSE (初始设置)
        ? NewIndexLock(TRUE)&#0009;// FALSE (先前设置)
        ? NewIndexLock()&#0009;&#0009;// TRUE  (当前设置)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
  </newindexlock>

  <newlocks>
    <summary>
      返回设置以确定是否在 .NTX 文件中使用新的锁定偏移量 -1 (0xFFFFFFFF)。
      注意：NewLocks() 是一个兼容函数，因此不推荐使用。<br/>
      它被 NewIndexLock() 函数取代，后者允许您更改和检索设置。有关更多信息，请参考 NewIndexLock()。
    </summary>
    <returns>
      一个逻辑值，指示 NewIndexLock() 的当前状态。
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
  </newlocks>

  <nomethod>
    <summary>
      识别无效的方法调用。
    </summary>
    <returns>
      如果该方法不存在，则返回 NULL_SYMBOL。
    </returns>
    <remarks>
      您可以为任何类声明一个名为 NoMethod() 的方法，当调用该类中未定义的方法时将被执行。<br/>
      通过这种方式，您可以在生成运行时错误之前捕获错误的方法调用。<br/>
      可以从 NoMethod() 方法中调用 NoMethod() 函数，以确定缺失方法的名称。
    </remarks>
    <example>
      此示例显示了 NoMethod() 的使用：
      <code language="X#">
        METHOD NoMethod() CLASS MyDataWindow
        &#0009;// 每当调用一个不存在于 MyDataWindow 中的方法时，这将被调用。
        &#0009;// 此函数调用在状态栏中显示缺失方法的名称。
        SELF:StatusMessage(Symbol2String(NoMethod()) ;
        &#0009;+ "方法未定义", MESSAGEERROR)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IsMethodUsual'>IsMethodUsual</seealso>
  </nomethod>

  <ntocdow>
    <summary>
      将标识日期的数字转换为日期的名称。
    </summary>
    <param name="dwDayNum">一个从 1 到 7 的数字。</param>
    <returns>
      与 <paramref name="dwDayNum" /> 对应的日期名称，其中星期日是 1，星期一是 2，以此类推。
    </returns>
    <remarks>
      此函数与国家/地区相关。
    </remarks>
    <example>
      此示例展示了 NToCDoW() 在英语中的工作原理：
      <code language="X#">
        ? NToCDoW(1)&#0009;&#0009;&#0009;// "星期日"
        ? NToCDoW(4)&#0009;&#0009;&#0009;&#0009;// "星期三"
        ? NToCDoW(7)&#0009;&#0009;&#0009;&#0009;// "星期六"
        ? NToCDoW(8)&#0009;&#0009;&#0009;&#0009;// NULL_STRING
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CDoW'>CDoW</seealso>
    <seealso cref='O:XSharp.RT.Functions.DoW'>DoW</seealso>
    <seealso cref='O:XSharp.Core.Functions.NToCMonth'>NToCMonth</seealso>
  </ntocdow>

  <ntocmonth>
    <summary>
      将标识月份的数字转换为月份的名称。
    </summary>
    <param name="dwMonthNum">一个从 1 到 12 的数字。</param>
    <returns>
      与 <paramref name="dwMonthNum" /> 对应的月份名称，其中一月是 1，二月是 2，依此类推，直到十二月，即 12。
    </returns>
    <remarks>
      此函数与国家/地区相关。
    </remarks>
    <example>
      此示例展示了 NToCMonth() 在英语中的工作原理：
      <code language="X#">
        ? NToCMonth(1)&#0009;&#0009;&#0009;&#0009;// "一月"
        ? NToCMonth(2)&#0009;&#0009;&#0009;&#0009;// "二月"
        ? NToCMonth(12)&#0009;&#0009;&#0009;// "十二月"
        ? NToCMonth(14)&#0009;&#0009;&#0009;// NULL_STRING
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CMonth'>CMonth</seealso>
    <seealso cref='O:XSharp.RT.Functions.Month'>Month</seealso>
    <seealso cref='O:XSharp.Core.Functions.NToCDoW'>NToCDoW</seealso>
  </ntocmonth>

  <ntrim>
    <summary>
      将数值表达式转换为左侧修剪的字符串。
    </summary>
    <param name="nNum">要转换为字符串的表达式。</param>
    <returns>
    </returns>
    <remarks>
      NTrim() 返回与 LTrim(Str(<paramref name="nNum" />)) 相同的值。因此，适用于 Str() 函数的任何转换规则同样适用于 NTrim() 函数。
    </remarks>
    <example>
      此示例比较 NTrim() 的输出与 Str() 的输出：
      <code language="X#">
        ? NTrim(234)&#0009;&#0009;&#0009;// "234"
        ? LTrim(Str(234))&#0009;&#0009;// "234"
        ? Str(234)&#0009;&#0009;&#0009;&#0009;// "       234"
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
  </ntrim>

  <nversion>
    <summary>
      通过其国家驱动程序识别字符集。
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 NVersion() 来识别国家驱动程序：
      <code language="X#">
        ? NVersion()&#0009;&#0009;&#0009;//<br/>
        US ASCII
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
    <seealso cref='O:XSharp.RT.Functions.Version'>Version</seealso>
  </nversion>

  <object2array>
    <summary>
      将对象的实例变量的值转换为数组。
    </summary>
    <param name="oObject">包含要转换的实例变量的对象。</param>
    <returns>
      包含 <paramref name="oObject" /> 所有实例变量内容的数组。
    </returns>
    <remarks>
      这种转换可以为您提供更大的灵活性以操作数据，并允许您利用强大的数组函数，例如 AEval() 和 AScan()。<br/>
      函数调用的作用域是 SELF。
    </remarks>
    <example>
      此示例使用 Object2Array() 将 INSTANCE 和 EXPORT 实例变量存储到数组中。<br/>
      然后打印存储的实例变量。（请注意，密码未存储在数组中，因为它是受保护的实例变量。）
      <code language="X#">
        CLASS Person
        &#0009;EXPORT name
        &#0009;INSTANCE grade
        &#0009;PROTECT password
        CONSTRUCTOR(tname, tgrade, tpassword)
        &#0009;name := tname
        &#0009;grade := tgrade
        &#0009;password := tpassword
        END CLASS
        FUNCTION Start()
        &#0009;LOCAL x AS OBJECT
        &#0009;LOCAL a AS ARRAY
        &#0009;LOCAL i AS SHORT
        &#0009;x := Person{"Randal", "A", "123"}
        &#0009;a := Object2Array(x)
        &#0009;// 打印它们
        &#0009;FOR i := 1 UPTO ALen(a)
        &#0009;&#0009;QOut(a[i])
        &#0009;NEXT
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Randal
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// A
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarGet'>IVarGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.IvarList'>IvarList</seealso>
    <seealso cref='O:XSharp.RT.Functions.IvarListClass'>IvarListClass</seealso>
  </object2array>

  <occurs>
    <summary>
      返回子串在字符串中出现的次数。
    </summary>
    <param name="cSearch">要搜索的子串。</param>
    <param name="cTarget">要在其中搜索的字符串。（要指定偏移量，请使用 Occurs3()。）</param>
    <returns>
      <paramref name="cSearch" /> 在 <paramref name="cTarget" /> 中出现的次数。
    </returns>
    <remarks>
      Occurs() 对大小写敏感且依赖于国家/地区。
    </remarks>
    <example>
      此示例展示了 Occurs() 的典型用法：
      <code language="X#">
        LOCAL cSearch AS STRING
        LOCAL cTarget AS STRING
        cSearch := "any"
        cTarget := "Anything goes anyway anytime."
        ? Occurs(cSearch, cTarget)&#0009;&#0009;// 2
        ? Occurs("any","ANY any")&#0009;&#0009;&#0009;// 1
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.At3'>At3</seealso>
    <seealso cref='O:XSharp.Core.Functions.Instr'>InStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Occurs2'>Occurs2</seealso>
    <seealso cref='O:XSharp.Core.Functions.Occurs3'>Occurs3</seealso>
  </occurs>

  <occurs2>
    <summary>
      返回子串在字符串中出现的次数。
    </summary>
    <param name="cSearch">要搜索的子串。</param>
    <param name="cTarget">要在其中搜索的字符串。（要指定偏移量，请使用 Occurs3()。）</param>
    <returns>
      <paramref name="cSearch" /> 在 <paramref name="cTarget" /> 中出现的次数。
    </returns>
    <remarks>
      Occurs2() 与 Occurs() 相同。
    </remarks>
    <example>
      此示例展示了 Occurs2() 的典型用法：
      <code language="X#">
        LOCAL cSearch AS STRING
        LOCAL cTarget AS STRING
        cSearch := "any"
        cTarget := "Anything goes anyway anytime."
        ? Occurs2(cSearch, cTarget)&#0009;&#0009;// 2
        ? Occurs2("any","ANY any")&#0009;&#0009;// 1
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Occurs'>Occurs</seealso>
    <seealso cref='O:XSharp.Core.Functions.Occurs3'>Occurs3</seealso>
  </occurs2>

  <occurs3>
    <summary>
      返回子串在字符串中出现的次数，从指定位置开始搜索。
    </summary>
    <param name="cSearch">要搜索的子串。</param>
    <param name="cTarget">要在其中搜索的字符串。</param>
    <param name="dwOffset">
      在字符串中开始搜索的位置。<br/>
      值为零（0）表示第一个字节。
    </param>
    <returns>
      <paramref name="cSearch" /> 在 <paramref name="cTarget" /> 中出现的次数。
    </returns>
    <remarks>
      Occurs3() 与 Occurs() 相同，只是您可以指定一个偏移量来告诉从何处开始搜索。有关更多信息，请参见 Occurs()。
    </remarks>
    <example>
      此示例展示了 Occurs3() 的典型用法：
      <code language="X#">
        LOCAL cSearch AS STRING
        LOCAL cTarget AS STRING
        cSearch := "any"
        cTarget := "Anything goes anyway anytime."
        ? Occurs3(cSearch,cTarget,18)&#0009;&#0009;// 1
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.At3'>At3</seealso>
    <seealso cref='O:XSharp.Core.Functions.Occurs'>Occurs</seealso>
    <seealso cref='O:XSharp.Core.Functions.Occurs2'>Occurs2</seealso>
  </occurs3>

  <oem2ansi>
    <summary>
      将OEM字符字符串转换为ANSI字符。
    </summary>
    <param name="cOemString">源OEM字符字符串。</param>
    <returns>
      转换后的ANSI字符字符串。
    </returns>
    <remarks>
      Oem2Ansi()将源字符串中的单个字符转换为ANSI字符集中的匹配字符。<br/>
      由于某些符号，例如ß，在ANSI和OEM字符集中的代码值不同，因此在使用Windows读取或显示DOS字符串数据或文件名时，通常需要将字符从OEM转换为ANSI。
      请注意，当SetAnsi()为FALSE时，大多数X# for Clipper应用程序会自动执行OEM到ANSI的转换。然而，有些应用程序，例如FRead()，假设它们正在处理二进制数据，因此不会执行这样的转换。
    </remarks>
    <example>
      此示例使用Oem2Ansi()将OEM字符转换为ANSI字符，以便将DOS文件读取到Windows中：
      <code language="X#">
        SetAnsi(TRUE)
        // 无需在ANSI和OEM之间进行转换
        Oem2Ansi(FReadLine(ptrFileHandle))
        // 如有需要，请自行进行转换
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2AnsiA'>Oem2AnsiA</seealso>
    <seealso cref='O:XSharp.RT.Functions.Oem2AnsiBuff'>Oem2AnsiBuff</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAnsi'>SetAnsi</seealso>
  </oem2ansi>

  <oem2ansia>
    <summary>
      将OEM字符字符串转换为ANSI字符，改变参数的内容以及返回值。
    </summary>
    <param name="cOemString">源OEM字符字符串。</param>
    <returns>
      转换后的ANSI字符字符串。
    </returns>
    <remarks>
      Oem2AnsiA()与Oem2Ansi()相同，不同之处在于Oem2AnsiA()还会用OEM字符替换原始字符串的内容。
    </remarks>
    <example>
      此示例使用Oem2AnsiA()通过将每个字符从OEM转换为ANSI来改变变量的内容：
      <code language="X#">
        LOCAL cString AS STRING
        cString := "ßá"
        Oem2AnsiA(cString)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2OemA'>Ansi2OemA</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
    <seealso cref='O:XSharp.RT.Functions.Oem2AnsiBuff'>Oem2AnsiBuff</seealso>
  </oem2ansia>

  <oem2ansibuff>
    <summary>
      将源缓冲区中的指定数量的OEM字符转换为相应的ANSI字符缓冲区。
    </summary>
    <param name="pszTarget">将包含转换字符串的缓冲区的指针。</param>
    <param name="pszSource">包含要转换字符串的缓冲区的指针。</param>
    <param name="dwCount">要转换的字符数。</param>
    <returns>
      指向包含转换字符串的缓冲区的指针。
    </returns>
    <remarks>
      Oem2AnsiBuff()与Oem2Ansi相同，不同之处在于结果指针存储在由<paramref name="pszTarget" />指向的缓冲区中。<br/>
      此外，<paramref name="dwCount" />参数让您指定要转换的字符数量。
      <note type="tip">
        您负责为<paramref name="pszTarget" />指向的缓冲区分配空间。<br/>
        使用未分配的缓冲区指针可能会导致不良后果。
      </note>
    </remarks>
    <example>
      此示例从OEM转换为ANSI。请注意，源字符串也用作目标字符串：
      <code language="X#">
        LOCAL cStr := "ßá"
        Oem2AnsiBuff(Ptr(_CAST, cStr),;
        &#0009;&#0009;&#0009;Ptr(_CAST, cStr), sLen(cStr))
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Ansi2OemBuff'>Ansi2OemBuff</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2AnsiA'>Oem2AnsiA</seealso>
  </oem2ansibuff>

  <oledatetimeasdate>
    <summary>
      将OLE日期值的返回值更改为VO日期值。
    </summary>
    <param name="lSet">新的设置。FALSE允许返回值为OleDateTime类的实例，TRUE强制所有OLE DateTime值为VO日期。默认值为FALSE</param>
    <returns>
    </returns>
    <remarks>
      OLE日期实际上是日期和时间的组合，通常在SQL数据库中称为时间戳。这种日期和时间的组合不能存储在DBF日期字段中，并且不被日期字段规范识别为有效日期。
      当返回OLE日期字段时，它是OleDateTime类的实例，可以从中提取值。另一种选择是使用OleDateTimeAsDate(TRUE)函数，它将所有返回的日期转换为标准VO格式。
    </remarks>
    <example>
    </example>
    <seealsocmd>OleDateTime类</seealsocmd>
  </oledatetimeasdate>

  <ooptree>
    <summary>
      返回构成类的所有面向对象编程符号的多维数组。
    </summary>
    <param name="oObject">您想要检索其类符号的对象。</param>
    <returns>
      每个类占用一个数组，该数组由类名、实例变量的子数组和方法的子数组组成。
    </returns>
    <remarks>
      OOPTree()检索类定义树中的祖先（超类）、实例数据和方法的名称。
    </remarks>
    <example>
      此示例使用OOPTree():
      <code language="X#">
        CLASS Thing_1
        &#0009;EXPORT x1
        CONSTRUCTOR() CLASS Thing_1
        &#0009;x1 := 1
        METHOD Meth_1() CLASS Thing_1
        METHOD Meth_1x() CLASS Thing_1
        CLASS Thing_2 INHERIT Thing_1
        &#0009;EXPORT x2
        METHOD Meth_2 CLASS Thing_2
        METHOD Meth_2x CLASS Thing_2
        CLASS Thing_3 INHERIT Thing_2
        &#0009;EXPORT x3
        METHOD Meth_3 CLASS Thing_3
        METHOD Meth_3x CLASS Thing_3
        FUNCTION Start()
        &#0009;LOCAL o AS OBJECT, aTree AS ARRAY
        &#0009;o := Thing_3{}
        &#0009;aTree := OOPTree(o)
      </code>
      数组aTree包含以下信息：
      <code language="X#">
        /***************************
        Thing-1
        &#0009;&#0009;&#0009;x1
        &#0009;&#0009;&#0009;Meth_1x
        &#0009;&#0009;&#0009;Meth_1
        &#0009;&#0009;&#0009;Init
        Thing-2
        &#0009;&#0009;&#0009;x2
        &#0009;&#0009;&#0009;x1
        &#0009;&#0009;&#0009;Meth_2x
        &#0009;&#0009;&#0009;Meth_2
        &#0009;&#0009;&#0009;Meth_1x
        &#0009;&#0009;&#0009;Meth_1
        &#0009;&#0009;&#0009;Init
        Thing-3
        &#0009;&#0009;&#0009;x2
        &#0009;&#0009;&#0009;x1
        &#0009;&#0009;&#0009;x3
        &#0009;&#0009;&#0009;Meth_3x
        &#0009;&#0009;&#0009;Meth_3
        &#0009;&#0009;&#0009;Meth_2x
        &#0009;&#0009;&#0009;Meth_2
        &#0009;&#0009;&#0009;Meth_1x
        &#0009;&#0009;&#0009;Meth_1
        &#0009;&#0009;&#0009;Init
        ***************************/
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ClassCount'>ClassCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassList'>ClassList</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassName'>ClassName</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTree'>ClassTree</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTreeClass'>ClassTreeClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.OOPTreeClass'>OOPTreeClass</seealso>
  </ooptree>

  <ooptreeclass>
    <summary>
      返回构成对象类的所有面向对象编程符号的多维数组。
    </summary>
    <param name="symClass">要检索其类符号的类名。</param>
    <returns>
      每个类占用一个数组，该数组由类名、实例变量的子数组和方法的子数组组成。
    </returns>
    <remarks>
      OOPTreeClass() 检索类定义树中的祖先（超类）、实例数据和方法的名称。
    </remarks>
    <example>
      此示例使用 OOPTreeClass():
      <code language="X#">
        CLASS Thing_1
        &#0009;EXPORT x1
        CONSTRUCTOR() CLASS Thing_1
        &#0009;x1 := 1
        METHOD Meth_1() CLASS Thing_1
        METHOD Meth_1x() CLASS Thing_1
        CLASS Thing_2 INHERIT Thing_1
        &#0009;EXPORT x2
        METHOD Meth_2 CLASS Thing_2
        METHOD Meth_2x CLASS Thing_2
        CLASS Thing_3 INHERIT Thing_2
        &#0009;EXPORT x3
        METHOD Meth_3 CLASS Thing_3
        METHOD Meth_3x CLASS Thing_3
        Function Start()
        &#0009;LOCAL aTree AS ARRAY
        &#0009;aTree := OOPTreeClass(#Thing_3)
      </code>
      数组 aTree 包含以下信息：
      <code language="X#">
        /***************************
        Thing-1
        &#0009;&#0009;&#0009;x1
        &#0009;&#0009;&#0009;Meth_1x
        &#0009;&#0009;&#0009;Meth_1
        &#0009;&#0009;&#0009;Init
        Thing-2
        &#0009;&#0009;&#0009;x2
        &#0009;&#0009;&#0009;x1
        &#0009;&#0009;&#0009;Meth_2x
        &#0009;&#0009;&#0009;Meth_2
        &#0009;&#0009;&#0009;Meth_1x
        &#0009;&#0009;&#0009;Meth_1
        &#0009;&#0009;&#0009;Init
        Thing-3
        &#0009;&#0009;&#0009;x2
        &#0009;&#0009;&#0009;x1
        &#0009;&#0009;&#0009;x3
        &#0009;&#0009;&#0009;Meth_3x
        &#0009;&#0009;&#0009;Meth_3
        &#0009;&#0009;&#0009;Meth_2x
        &#0009;&#0009;&#0009;Meth_2
        &#0009;&#0009;&#0009;Meth_1x
        &#0009;&#0009;&#0009;Meth_1
        &#0009;&#0009;&#0009;Init
        ***************************/
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ClassCount'>ClassCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassList'>ClassList</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassName'>ClassName</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTree'>ClassTree</seealso>
    <seealso cref='O:XSharp.RT.Functions.ClassTreeClass'>ClassTreeClass</seealso>
    <seealso cref='O:XSharp.RT.Functions.OOPTree'>OOPTree</seealso>
  </ooptreeclass>

  <ordbagext>
    <summary>
      返回由其 RDD 定义的工作区的默认索引文件扩展名。
    </summary>
    <returns>
      一个字符串，指示由其 RDD 定义的工作区的默认索引文件扩展名。
    </returns>
    <remarks>
      <note type="tip">
        您也可以使用 DBOrderInfo(DBOI_INDEXEXT) 获取默认索引文件扩展名。
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </ordbagext>

  <ordbagname>
    <summary>
      返回特定顺序的索引文件名称。
    </summary>
    <param name="uOrder">
      要获取其索引文件名称的顺序名称或表示其在顺序列表中位置的数字。<br/>
      使用顺序名称是首选方法，因为使用多个顺序索引文件时可能难以确定位置。无效值将被忽略。
    </param>
    <returns>
      包含该顺序的索引文件的名称。
    </returns>
    <remarks>
      <note type="tip">
        您也可以使用 DBOrderInfo(DBOI_INDEXNAME, <paramref name="cOrder" />) 获取索引文件名称。
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </ordbagname>

  <ordcondset>
    <summary>
      设置顺序的条件和范围。
    </summary>
    <param name="cForCondition">
      指定顺序的 for 条件的字符串。<br/>
      此字符串由 DBOrderInfo(DBOI_CONDITION, [<paramref name="cIndexFile" />], <paramref name="cOrder" />) 返回。
      如果您不需要此信息，可以指定 NULL_STRING。
    </param>
    <param name="cbForCondition">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/cbfor/*" /><br/>
      这个条件（而不是 <paramref name="cForCondition" />）是实际用于创建顺序的条件。
      与 while 条件和其他范围信息不同，for 条件作为索引文件的一部分存储，并在使用 DBReindex() 更新或重建顺序时使用。
      对于 for 条件的任何限制由 RDD 决定。
    </param>
    <param name="lAll">
      TRUE 的值指定所有记录的范围。<br/>
      如果您希望指示其他记录范围条件（即 <paramref name="nNext" />、<paramref name="nRecord" /> 或 <paramref name="lRest" />），请使用 FALSE。<br/>
      默认值为 FALSE。
    </param>
    <param name="cbWhileCondition">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/cbwhile/*" />
    </param>
    <param name="cbEval">
      在 <paramref name="nInterval" /> 指定的间隔内评估的代码块。<br/>
      这在生成监控排序进度的状态栏或里程表时非常有用。<br/>
      <paramref name="cbEval" /> 的返回值必须是逻辑值。<br/>
      如果 <paramref name="cbEval" /> 返回 FALSE，则索引将停止。<br/>
      默认值为 NIL。
    </param>
    <param name="nInterval">
      确定评估 <paramref name="cbEval" /> 的次数的数值表达式。<br/>
      此参数通过在间隔内评估条件而不是对处理的每条记录进行评估，提供了性能提升。<br/>
      要遍历每条记录，可以指定 0 的值。<br/>
      默认值为 0。
    </param>
    <param name="nStart">
      起始记录编号。<br/>
      要从文件开头开始，请指定 0 的值。<br/>
      默认值为 0。<br/>
      您通过这三个互斥参数之一定义范围（对其他参数使用 0 或 FALSE）。<br/>
      默认值为所有记录。记录范围信息仅用于创建顺序。<br/>
      它不会存储在索引文件中，也不用于索引更新和重建目的。
    </param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <param name="lDescend">
      指定键对是否按值的降序或升序排序。 TRUE 结果为降序。 FALSE 结果为升序。<br/>
      默认值为 FALSE。
    </param>
    <param name="lAdditive">
      指定在创建新顺序时打开的顺序是否应保持打开。 TRUE 指定它们应保持打开。 FALSE 指定所有打开的顺序应关闭。<br/>
      默认值为 FALSE。
    </param>
    <param name="lCurrent">
      指定仅控制顺序中的记录 — 并在当前范围内（由 OrdSetScope() 指定） — 将包含在此顺序中。 TRUE 指定应使用控制顺序和范围来限制新创建顺序的范围。 FALSE 指定数据库文件中的所有记录均包含在顺序中。<br/>
      默认值为 FALSE。
    </param>
    <param name="lCustom">
      指定新顺序是否将是一个自定义构建的顺序（对于支持此功能的 RDD）。 TRUE 指定将创建自定义构建的顺序。<br/>
      自定义构建的顺序最初为空，使您完全控制顺序维护。<br/>
      系统不会自动添加和删除自定义构建顺序中的键。相反，您使用 OrdKeyAdd() 和 OrdKeyDel() 显式添加和删除键。 FALSE 指定标准的、系统维护的顺序。<br/>
      默认值为 FALSE。
    </param>
    <param name="lNoOptimize">
      指定是否优化 FOR 条件（对于支持此功能的 RDD）。 TRUE 优化 FOR 条件，FALSE 不优化。<br/>
      默认值为 FALSE。
    </param>
    <returns>
    </returns>
    <remarks>
      此函数与 DBSetOrderCondition() 相同，您可以参考它以获取更多信息。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrderCondition'>DBSetOrderCondition</seealso>
  </ordcondset>

  <ordcreate>
    <summary>
      创建或替换索引文件中的顺序。
    </summary>
    <returns>
    </returns>
    <remarks>
      除了参数的顺序外，此函数与 DBCreateOrder() 相同，您可以参考它以获取更多信息。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
  </ordcreate>

  <orddescend>
    <summary>
      返回并可选地更改顺序的降序标志。
    </summary>
    <param name="uOrder">
      要获取的顺序名称或表示其在顺序列表中位置的数字。<br/>
      使用顺序名称是首选方法，因为在多个顺序索引文件中确定位置可能很困难。<br/>
      如果省略或为 NIL，则假定为控制顺序。<br/>
      &#0009;指定无效值将引发运行时错误。
    </param>
    <param name="cIndexFile">
      索引文件的名称，包括可选的驱动器和目录（不应指定扩展名）。<br/>
      使用此参数与 <paramref name="cOrder" /> 一起消除在不同索引文件中具有相同名称的两个或多个顺序之间的歧义。<br/>
      &#0009;如果 <paramref name="cIndexFile" /> 未被当前进程打开，将引发运行时错误。
    </param>
    <param name="lNewDescend">TRUE 动态开启顺序的降序标志，导致降序。 FALSE 动态关闭标志，导致升序。</param>
    <returns>
      如果未指定 <paramref name="lNewDescend" />，OrdDescend() 返回当前设置。<br/>
      如果指定 <paramref name="lNewDescend" />，则返回先前的设置。
    </returns>
    <remarks>
      OrdDescend() 仅在运行时更改升序/降序标志 — 它不会更改实际索引文件中存储的降序标志。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      以下示例演示了 OrdDescend()，每个顺序可以是升序和降序。
      <code language="X#">
        USE customer VIA "DBFCDX"
        INDEX ON LastName TAG Last
        INDEX ON FirstName TAG First DESCENDING
        SET ORDER TO TAG Last
        // last 最初创建为升序
        // 将其切换为降序
        OrdDescend(,, TRUE)
        // Last 现在将以降序处理
        SET ORDER TO TAG First
        // First 最初创建为降序
        // 将其切换为升序
        OrdDescend(,, FALSE)
        // First 现在将以升序处理
      </code>
    </example>
    <seealsocmd>INDEX</seealsocmd>
  </orddescend>

  <orddestroy>
    <summary>
      从打开的索引文件中移除顺序。
    </summary>
    <param name="uOrder">
      要移除的顺序名称或表示其在顺序列表中位置的数字。<br/>
      使用顺序名称是首选方法，因为在多个顺序索引文件中确定位置可能很困难。无效值将被忽略。
    </param>
    <param name="cIndexFile">
      索引文件的名称，包括可选的驱动器和目录（不应指定扩展名）。<br/>
      使用此参数与 <paramref name="cOrder" /> 一起消除在不同索引文件中具有相同名称的两个或多个顺序之间的歧义。<br/>
      &#0009;如果 <paramref name="cIndexFile" /> 未被当前进程打开，将引发运行时错误。<br/>
      默认值为 NULL_STRING。
    </param>
    <returns>
    </returns>
    <remarks>
      此函数与 DBDeleteOrder() 相同，您可以参考它以获取更多信息。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDeleteOrder'>DBDeleteOrder</seealso>
  </orddestroy>

  <ordfor>
    <summary>
      返回顺序的 for 条件。
    </summary>
    <param name="uOrder">
      要获取其 for 条件的顺序名称或表示其在顺序列表中位置的数字。<br/>
      使用顺序名称是首选方法，因为在多个顺序索引文件中确定位置可能很困难。无效值将被忽略。
    </param>
    <param name="cIndexFile">
      索引文件的名称，包括可选的驱动器和目录（不应指定扩展名）。<br/>
      使用此参数与 <paramref name="cOrder" /> 一起消除在不同索引文件中具有相同名称的两个或多个顺序之间的歧义。<br/>
      &#0009;如果 <paramref name="cIndexFile" /> 未被当前进程打开，将引发运行时错误。
    </param>
    <returns>
      一个字符串，表示指定顺序的 for 条件。<br/>
      如果顺序未使用 for 条件创建，则返回值将为 NULL_STRING。<br/>
      如果 RDD 不支持 for 条件，则可能返回 NULL_STRING 或导致错误，具体取决于 RDD。
    </returns>
    <remarks>
      <note type="tip">
        您也可以使用 DBOrderInfo(DBOI_CONDITION, [<paramref name="cIndexFile" />], <paramref name="cOrder" />) 获取 for 条件。
      </note>
    </remarks>
    <example>
    </example>
  </ordfor>

  <ordisunique>
    <summary>
      返回给定顺序的唯一标志状态。
    </summary>
    <param name="uOrder">
      顺序的名称或表示其在顺序列表中位置的数字。<br/>
      使用顺序名称是首选方法，因为在多个顺序索引文件中确定位置可能很困难。<br/>
      如果省略或为 NIL，则假定为控制顺序。<br/>
      &#0009;指定无效顺序将引发运行时错误。
    </param>
    <param name="cIndexFile">
      索引文件的名称，包括可选的驱动器和目录（不应指定扩展名）。<br/>
      使用此参数与 <paramref name="cOrder" /> 一起消除在不同索引文件中具有相同名称的两个或多个顺序之间的歧义。<br/>
      &#0009;如果 <paramref name="cIndexFile" /> 未被当前进程打开，将引发运行时错误。
    </param>
    <returns>
      指示顺序唯一标志状态的逻辑值。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      此示例展示了使用各种顺序的 OrdIsUnique() 返回值：
      <code language="X#">
        USE customer VIA "DBFCDX"
        INDEX ON LastName TAG Last UNIQUE
        INDEX ON FirstName TAG First
        INDEX ON AGE TO j:\test\tmp\age UNIQUE
        SET ORDER TO last
        ? OrdIsUnique()&#0009;&#0009;&#0009;// 结果: TRUE, 对于 last
        ? OrdIsUnique("First")&#0009;&#0009;// 结果: FALSE
        ? OrdIsUnique("Age")&#0009;&#0009;// 结果: TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.OrdDescend'>OrdDescend</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdFor'>OrdFor</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdKey'>OrdKey</seealso>
  </ordisunique>

  <ordkey>
    <summary>
      返回给定顺序的键表达式。
    </summary>
    <param name="uOrder">
      要获取其键表达式的顺序名称或表示其在顺序列表中位置的数字。<br/>
      使用顺序名称是首选方法，因为在多个顺序索引文件中确定位置可能很困难。无效值将被忽略。
    </param>
    <param name="cIndexFile">
      索引文件的名称，包括可选的驱动器和目录（不应指定扩展名）。<br/>
      使用此参数与 <paramref name="cOrder" /> 一起消除在不同索引文件中具有相同名称的两个或多个顺序之间的歧义。<br/>
      &#0009;如果 <paramref name="cIndexFile" /> 未被当前进程打开，将引发运行时错误。
    </param>
    <returns>
      表示指定顺序键表达式的字符串。
    </returns>
    <remarks>
      <note type="tip">
        您也可以使用 DBOrderInfo(DBOI_EXPRESSION, [<paramref name="cIndexFile" />], <paramref name="cOrder" />) 获取顺序的键表达式。
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </ordkey>

  <ordkeyadd>
    <summary>
      向自定义构建的顺序添加键。
    </summary>
    <param name="uOrder">
      顺序的名称或表示其在顺序列表中位置的数字。<br/>
      使用顺序名称是首选方法，因为在多个顺序索引文件中确定位置可能很困难。<br/>
      如果省略或为 NIL，则假定为控制顺序。<br/>
      &#0009;指定无效顺序（例如，未自定义构建的顺序）将引发运行时错误。
    </param>
    <param name="cIndexFile">
      索引文件的名称，包括可选的驱动器和目录（不应指定扩展名）。<br/>
      使用此参数与 <paramref name="cOrder" /> 一起消除在不同索引文件中具有相同名称的两个或多个顺序之间的歧义。<br/>
      &#0009;如果 <paramref name="cIndexFile" /> 未被当前进程打开，将引发运行时错误。
    </param>
    <param name="uKeyValue">
      要为当前记录添加的特定键值。<br/>
      数据类型必须与顺序匹配。<br/>
      如果未指定，则将评估顺序的键表达式并添加到该顺序中。
    </param>
    <returns>
      如果成功则为 TRUE；否则为 FALSE。
      <br/>
      从标准 RDD 中，只有 DBFCDX RDD 支持自定义索引。此 RDD 不支持使用 <paramref name="uKeyValue" /> 参数。它总是使用键表达式来计算要插入的键值。
    </returns>
    <remarks>
      自定义构建的顺序是指未由 DBFCDX 驱动程序自动维护的顺序。 您可以使用 DBOrderInfo(DBOI_CUSTOM, ...) 确定顺序是否自定义构建。当您创建这样的顺序时，它最初是空的。您必须使用 OrdKeyAdd() 和 OrdKeyDel() 手动添加和删除键。
      OrdKeyAdd() 评估键表达式（或 <paramref name="uKeyValue" />，如果指定），然后将当前记录的键添加到顺序中。<br/>
      如果顺序有一个 for 条件，则只有在满足该条件时，键才会被添加，并且仅在其落在当前范围内时。
      注意：RDD 可能允许您通过连续调用 OrdKeyAdd() 为同一记录添加多个键。
      OrdKeyAdd() 将失败，如果：
      &#0009;记录指针位于无效记录上（即，位于 EOF()）
      &#0009;指定的顺序不是自定义构建的
      &#0009;指定的顺序不存在
      &#0009;未指定顺序且没有控制顺序
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      此示例创建一个自定义索引并将每五十条记录添加到其中：
      <code language="X#">
        USE customer VIA "DBFCDX"
        // 创建自定义构建的顺序，最初为空
        INDEX ON LastName TO Last CUSTOM
        // 添加每第50条记录
        FOR n := 1 UPTO RecCount() STEP 50&#0009;
        &#0009;GOTO n
        &#0009;OrdKeyAdd()
        NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.OrdFor'>OrdFor</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyDel'>OrdKeyDel</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdScope'>OrdScope</seealso>
  </ordkeyadd>

  <ordkeycount>
    <summary>
      返回顺序中的键的数量。
    </summary>
    <param name="uOrder">
      顺序的名称或表示其在顺序列表中位置的数字。<br/>
      使用顺序名称是首选方法，因为在多个顺序索引文件中确定位置可能很困难。<br/>
      如果省略或为 NIL，则假定为控制顺序。<br/>
      &#0009;指定无效顺序将引发运行时错误。
    </param>
    <param name="cIndexFile">
      索引文件的名称，包括可选的驱动器和目录（不应指定扩展名）。<br/>
      使用此参数与 <paramref name="cOrder" /> 一起消除在不同索引文件中具有相同名称的两个或多个顺序之间的歧义。<br/>
      &#0009;如果 <paramref name="cIndexFile" /> 未被当前进程打开，将引发运行时错误。
    </param>
    <returns>
    </returns>
    <remarks>
      OrdKeyCount() 计算指定顺序中的键并返回结果作为数值。<br/>
      如果顺序没有条件且未设置范围，则 OrdKeyCount() 与 RecCount() 相同，返回数据库文件中的记录数。然而，对于条件顺序，键的数量可能少于记录的数量，因为某些记录可能不符合顺序的条件或不在 OrdScope() 指定的范围内 — 在计算键时，OrdKeyCount() 尊重当前定义的范围和条件。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      <br/>
      如果没有顺序在操作，返回值将是 0 而不是 RecCount() 的值。
    </remarks>
    <example>
      此示例演示使用 OrdKeyCount() 与各种顺序。
      <code language="X#">
        USE customer
        // 假设总记录数为 1000，
        // 小于三十岁的人数为 500，和
        // 工资低于 50,000 的记录为 895
        ? RecCount()&#0009;&#0009;&#0009;&#0009;&#0009;// 结果: 1000
        ? OrdKeyCount()&#0009;&#0009;&#0009;// 结果: 0
        INDEX ON Age TO Age
        INDEX ON First TO First FOR Age &lt; 30
        INDEX ON Last TO Last FOR Salary &lt; 50000
        // Age 是控制顺序
        SET INDEX TO Age, First, Last
        ? RecCount()&#0009;&#0009;&#0009;&#0009;&#0009;// 结果: 1000
        ? OrdKeyCount()&#0009;&#0009;&#0009;// 结果: 1000
        ? OrdKeyCount("First")&#0009;&#0009;// 结果: 500
        ? OrdKeyCount(3)&#0009;&#0009;&#0009;// 结果: 895
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyGoto'>OrdKeyGoTo</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyNo'>OrdKeyNo</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdScope'>OrdScope</seealso>
  </ordkeycount>

  <ordkeydel>
    <summary>
      从自定义构建的顺序中删除一个键。
    </summary>
    <param name="uOrder">
      顺序的名称或表示其在顺序列表中位置的数字。<br/>
      使用顺序名称是首选方法，因为在多个顺序索引文件中确定位置可能很困难。<br/>
      如果省略或为 NIL，则假定为控制顺序。<br/>
      &#0009;指定无效顺序（例如，未自定义构建的顺序）将引发运行时错误。
    </param>
    <param name="cIndexFile">
      索引文件的名称，包括可选的驱动器和目录（不应指定扩展名）。<br/>
      使用此参数与 <paramref name="cOrder" /> 一起消除在不同索引文件中具有相同名称的两个或多个顺序之间的歧义。<br/>
      &#0009;如果 <paramref name="cIndexFile" /> 未被当前进程打开，将引发运行时错误。
    </param>
    <returns>
      如果成功则为 TRUE；否则为 FALSE。
    </returns>
    <remarks>
      自定义构建的顺序是指未由 DBFCDX 驱动程序自动维护的顺序。您可以使用 DBOrderInfo(DBOI_CUSTOM, ...) 确定顺序是否自定义构建。当您创建这样的顺序时，它最初是空的。您必须使用 OrdKeyAdd() 和 OrdKeyDel() 手动添加和删除键。
      OrdKeyDel() 将失败如果：
      &#0009;记录指针位于无效记录上（例如，EOF() 返回 TRUE 或记录指针位于超出顺序范围或条件的记录上）
      &#0009;指定的顺序不是自定义构建
      &#0009;指定的顺序不存在
      &#0009;未指定顺序且没有控制顺序
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      此示例创建一个自定义索引，添加每五十条记录到其中，并删除每一百条记录：
      <code language="X#">
        USE customer VIA "DBFCDX"
        // 创建自定义构建的顺序，最初为空
        INDEX ON LastName TO Last CUSTOM
        // 添加每第50条记录
        FOR n := 1 UPTO RecCount() STEP 50&#0009;
        &#0009;GOTO n
        &#0009;OrdKeyAdd()
        NEXT
        // 删除每第100条记录
        FOR n := 1 UPTO RecCount() STEP 100
        &#0009;GOTO n
        &#0009;OrdKeyDel()
        NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.OrdFor'>OrdFor</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyAdd'>OrdKeyAdd</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdScope'>OrdScope</seealso>
  </ordkeydel>

  <ordkeygoto>
    <summary>
      移动到控制顺序中由其逻辑记录编号指定的记录。
    </summary>
    <param name="nKeyNo">
      逻辑记录编号。<br/>
      如果指定的值不满足范围或顺序的条件，记录指针将被定位到文件末尾。
    </param>
    <returns>
      如果成功则为 TRUE；否则为 FALSE。
    </returns>
    <remarks>
      OrdKeyGoTo() 是 OrdKeyNo() 的补充。OrdKeyNo() 返回当前记录的逻辑记录编号（即它在控制顺序中的位置），而 OrdKeyGoTo() 将记录指针移动到指定的逻辑记录。
      提示：<br/>
      此函数在显示滚动条时非常有用。<br/>
      如果用户点击滚动条上的某个位置，可以通过调用 OrdKeyGoTo() 移动到相应的记录。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      此示例展示了物理和逻辑记录编号之间的区别：
      <code language="X#">
        USE customer
        SET INDEX TO first&#0009;&#0009;&#0009;// 按名字排序记录
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;//
        OrdKeyGoTo(100)&#0009;&#0009;&#0009;&#0009;// 转到第100个逻辑记录
        ? RECNO()&#0009;&#0009;&#0009;&#0009;&#0009;// 返回物理记录
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 编号
        ? OrdKeyNo()&#0009;&#0009;&#0009;&#0009;// 返回100，逻辑
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 记录编号
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbGoto'>DBGoTo</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyCount'>OrdKeyCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyNo'>OrdKeyNo</seealso>
  </ordkeygoto>

  <ordkeyno>
    <summary>
      获取当前记录的逻辑记录编号。
    </summary>
    <param name="uOrder">
      顺序的名称或表示其在顺序列表中位置的数字。<br/>
      使用顺序名称是首选方法，因为在多个顺序索引文件中确定位置可能很困难。<br/>
      如果省略或为 NIL，则假定为控制顺序。<br/>
      &#0009;指定无效顺序将引发运行时错误。
    </param>
    <param name="cIndexFile">
      索引文件的名称，包括可选的驱动器和目录（不应指定扩展名）。<br/>
      使用此参数与 <paramref name="cOrder" /> 一起消除在不同索引文件中具有相同名称的两个或多个顺序之间的歧义。<br/>
      &#0009;如果 <paramref name="cIndexFile" /> 未被当前进程打开，将引发运行时错误。
    </param>
    <returns>
      当前记录在指定顺序中的相对位置，作为数值。OrdKeyNo() 尊重顺序的范围和条件，如果记录指针位于无效记录上或 EOF() 为 TRUE，则返回零。
    </returns>
    <remarks>
      OrdKeyNo() 返回顺序中键的逻辑记录编号。<br/>
      这与物理记录编号（使用 RecNo() 函数返回）形成对比，后者是记录在物理数据库文件中的相对位置。
      提示：<br/>
      此函数在浏览记录时用于显示滚动条和消息，例如“第9条记录，共123条”时非常有用。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      此示例展示了物理和逻辑记录编号之间的区别：
      <code language="X#">
        USE customer&#0009;&#0009;&#0009;// 假设有1000条记录
        SET INDEX TO first&#0009;&#0009;// 按名字排序记录
        ? OrdKeyNo()&#0009;&#0009;&#0009;// 结果: 1
        DBSkip(10)
        ? OrdKeyNo()&#0009;&#0009;&#0009;// 结果: 11
        ? RECNO()&#0009;&#0009;&#0009;&#0009;// 结果: 未知
        DBGoBottom()
        ? OrdKeyNo()&#0009;&#0009;&#0009;// 结果: 1000
        ? RECNO()&#0009;&#0009;&#0009;&#0009;// 结果: 未知
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyCount'>OrdKeyCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdKeyGoto'>OrdKeyGoTo</seealso>
    <seealso cref='O:XSharp.RT.Functions.OrdScope'>OrdScope</seealso>
    <seealso cref='O:XSharp.RT.Functions.RecNo'>RecNo</seealso>
  </ordkeyno>

  <ordkeyval>
    <summary>
      获取当前记录在控制顺序中的键值。
    </summary>
    <returns>
      当前记录的键值。<br/>
      返回值的数据类型与创建顺序时使用的键表达式的数据类型相同。<br/>
      使用 ValType() 或 UsualType() 来确定数据类型。
      OrdKeyVal() 在以下情况下返回 NIL：
      &#0009;没有控制顺序
      &#0009;记录指针位于文件末尾（EOF() 返回 TRUE）
      &#0009;此记录没有定义键（例如，您已将记录指针定位到不符合顺序条件或超出其指定范围的记录）
    </returns>
    <remarks>
      键值是从控制顺序中检索的，而不是从数据库文件中检索。<br/>
      这使得检索更快，因为没有时间花费在读取实际记录上。
      提示：OrdKeyVal() 很快，但如果您多次使用该值，存储结果在局部变量中会更快。<br/>
      然后使用局部变量，而不是对同一记录多次调用 OrdKeyVal()。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      此示例显示了顺序中所有键的值，而无需将单个记录读入内存：
      <code language="X#">
        FUNCTION DisplayKeys()
        &#0009;LOCAL cKey, cFirst, cLast
      </code>
      &#0009;
      <code language="X#">
        &#0009;USE customer
        &#0009;// 假设 LastName 和 FirstName 都是
        &#0009;// 20 个字符
        &#0009;INDEX ON LastName + FirstName TO lastfir
      </code>
      &#0009;
      <code language="X#">
        &#0009;DO WHILE !Customer-&gt;EOF()
        &#0009;&#0009;cKey := Customer-&gt;OrdKeyVal()&#0009;&#0009;// 获取键
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 值
        &#0009;&#0009;cLast := LEFT(cKey, 20)&#0009;&#0009;&#0009;// 获取姓
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 名字
        &#0009;&#0009;cFirst := RIGHT(cKey, 20)&#0009;&#0009;// 获取名
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 字
        &#0009;&#0009;? cLast, cFirst
        &#0009;&#0009;Customer-&gt;DBSkip()
        &#0009;ENDDO
      </code>
      &#0009;
      <code language="X#">&#0009;CLOSE</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.OrdScope'>OrdScope</seealso>
  </ordkeyval>

  <ordlistadd>
    <summary>
      打开索引文件并将指定的顺序添加到工作区的顺序列表中。
    </summary>
    <param name="cIndexFile">
      要打开的索引文件的名称，包括可选的驱动器、目录和扩展名。有关文件搜索和创建规则，请参阅 SetDefault() 和 SetPath()。<br/>
      默认扩展名由 RDD 确定，可以通过 DBOrderInfo(DBOI_INDEXEXT) 获取。<br/>
      &#0009;如果 <paramref name="cIndexFile" /> 不存在，则会引发运行时错误。<br/>
      如果存在且当前进程尚未打开该文件，则此函数会尝试以与相应数据库文件相同的模式打开文件。<br/>
      如果由于另一个进程正在使用文件并且该进程请求独占使用，导致访问被拒绝，则 NetErr() 会被设置为 TRUE。<br/>
      否则，文件打开成功。<br/>
      &#0009;索引文件的并发冲突很少发生，因为它们应该只与一个数据库文件一起使用。<br/>
      如果出现并发问题，通常是在尝试打开数据库文件时发生。
    </param>
    <param name="cOrder">
      要添加的特定顺序的名称。<br/>
      如果未指定，则索引文件中的所有顺序将添加到顺序列表中。无效值将被忽略。<br/>
      &#0009;重要！<br/>
      使用此参数可能会很危险，因为在 <paramref name="cIndexFile" /> 中未添加到顺序列表的顺序将无法与对数据库文件所做的更改保持同步。
    </param>
    <returns>
      如果成功，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      除了能够从索引文件中选择顺序之外，它在功能上与 DBSetIndex() 等效，有关更多信息，请参阅该函数。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
  </ordlistadd>

  <ordlistclear>
    <summary>
      从工作区的顺序列表中删除订单并关闭相关的索引文件。
    </summary>
    <returns>
    </returns>
    <remarks>
      除了参数的顺序外，此函数与 DBClearIndex() 完全相同，可以参考该函数以获取更多信息。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearIndex'>DBClearIndex</seealso>
  </ordlistclear>

  <ordlistrebuild>
    <summary>
      重建工作区的顺序列表中的所有订单。
    </summary>
    <returns>
    </returns>
    <remarks>
      此函数与 DBReindex() 完全相同，可以参考该函数以获取更多信息。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbReindex'>DBReindex</seealso>
  </ordlistrebuild>

  <ordname>
    <summary>
      返回工作区的顺序列表中某个订单的名称。
    </summary>
    <param name="uOrder">
      您要获取名称的订单的名称或代表其在顺序列表中位置的数字。<br/>
      使用位置是首选方法，因为这是您要获取的名称。无效值将被忽略。
    </param>
    <param name="cIndexFile">
      索引文件的名称，包括可选的驱动器和目录（不应指定扩展名）。<br/>
      使用此参数与 <paramref name="cOrder" /> 结合使用，以消除在不同索引文件中具有相同名称的两个或多个订单之间的歧义。<br/>
      &#0009;如果 <paramref name="cIndexFile" /> 未被当前进程打开，将引发运行时错误。
    </param>
    <returns>
      指定订单的名称。
    </returns>
    <remarks>
      <note type="tip">
        您还可以使用 DBOrderInfo(DBOI_NAME, [<paramref name="cIndexFile" />], <paramref name="cOrder" />) 来获取订单名称。
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </ordname>

  <ordnumber>
    <summary>
      返回工作区的顺序列表中某个订单的位置。
    </summary>
    <param name="uOrder">
      您要获取位置的订单的名称或代表其在顺序列表中位置的数字。<br/>
      使用订单名称是首选方法，因为这是您要获取的位置。无效值将被忽略。
    </param>
    <param name="cIndexFile">
      索引文件的名称，包括可选的驱动器和目录（不应指定扩展名）。<br/>
      使用此参数与 <paramref name="cOrder" /> 结合使用，以消除在不同索引文件中具有相同名称的两个或多个订单之间的歧义。<br/>
      &#0009;如果 <paramref name="cIndexFile" /> 未被当前进程打开，将引发运行时错误。
    </param>
    <returns>
      等于指定订单在顺序列表中位置的数值。
    </returns>
    <remarks>
      <note type="tip">
        您还可以使用 DBOrderInfo(DBOI_NUMBER, [<paramref name="cIndexFile" />], <paramref name="cOrder" />) 来获取订单位置。
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </ordnumber>

  <ordscope>
    <summary>
      设置或清除控制顺序中的键值范围。
    </summary>
    <param name="kScope">一个数字，指定顶部（TOPSCOPE）或底部（BOTTOMSCOPE）边界。</param>
    <param name="uNewValue">
      当前控制顺序中将包含的键值的顶部或底部范围。<paramref name="uNewValue" /> 可以是与控制顺序中的键表达式匹配的数据类型的表达式，或返回正确数据类型的代码块。<br/>
      &#0009;省略 <paramref name="uNewValue" /> 或将其指定为 NIL 具有特殊效果，重置指定范围为其原始默认值。<br/>
      默认的顶部范围是控制顺序中的第一个逻辑记录，默认底部范围是最后一个逻辑记录。
    </param>
    <returns>
      如果未指定 <paramref name="uNewValue" />，OrdScope() 将返回并清除当前设置。<br/>
      如果指定了 <paramref name="uNewValue" />，函数将其设置并返回先前的设置。
    </returns>
    <remarks>
      使用 OrdScope() 指定的值范围是包含的。换句话说，包括在范围内的键将大于或等于顶部边界，小于或等于底部边界。
      注意：<br/>
      要在不更改当前设置的情况下返回当前设置，请调用 DBOrderInfo() 函数，使用 DBOI_SCOPETOP 和 DBOI_SCOPEBOTTOM 常量。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      此示例说明如何使用 OrdScope() 设置对顺序的各种范围限制：
      <code language="X#">
        USE friends
        SET INDEX TO age
        // 使 25 成为范围内的最低年龄
        OrdScope(TOPSCOPE, 25)
        // 使 30 成为范围内的最高年龄
        OrdScope(BOTTOMSCOPE, 30)
        LIST Age&#0009;&#0009;&#0009;&#0009;// 显示年龄在 25
        &#0009;&#0009;&#0009;&#0009;&#0009;// &lt;= 年龄 &lt;= 30
        // 将最高年龄更改为 35
        OrdScope(BOTTOMSCOPE, 35)
        LIST Age&#0009;&#0009;&#0009;&#0009;// 显示年龄在 25
        &#0009;&#0009;&#0009;&#0009;&#0009;// &lt;= 年龄 &lt;= 35
        // 重置顶部边界
        OrdScope(TOPSCOPE, NIL)
        LIST Age&#0009;&#0009;&#0009;&#0009;// 显示年龄 &lt;= 35 的记录
        // 重置底部边界
        OrdScope(BOTTOMSCOPE, NIL)
        LIST Age&#0009;&#0009;&#0009;&#0009;// 显示所有记录
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealsocmd>SET SCOPE</seealsocmd>
    <seealsocmd>SET SCOPEBOTTOM</seealsocmd>
    <seealsocmd>SET SCOPETOP</seealsocmd>
  </ordscope>

  <ordsetfocus>
    <summary>
      设置工作区的控制顺序。
    </summary>
    <returns>
    </returns>
    <remarks>
      此函数类似于 DBSetOrder()，有关更多信息，请参考该函数。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrder'>DBSetOrder</seealso>
  </ordsetfocus>

  <ordsetrelation>
    <summary>
      将指定的工作区与当前工作区关联。
    </summary>
    <param name="uArea">子工作区的编号或别名。</param>
    <param name="cbKey">以可执行形式表达的关系表达式的代码块。</param>
    <param name="cKey">
      表达关系表达式的可选字符串值。<br/>
      如果提供 <paramref name="cKey" />，它必须等同于 <paramref name="cbKey" />。<br/>
      如果省略 <paramref name="cKey" />，DBRelation() 将返回 NULL_STRING 作为关系。
    </param>
    <returns>
    </returns>
    <remarks>
      OrdSetRelation() 将由 <paramref name="nArea" /> 或 <paramref name="cAlias" /> 指定的工作区（子工作区）与当前工作区（父工作区）相关联。<br/>
      任何现有的关系保持活动状态。
      关联工作区使子工作区与父工作区同步。<br/>
      通过在父工作区移动到新记录时自动重新定位子工作区来实现此目的。<br/>
      如果子工作区中有控制顺序，移动父工作区会导致在子工作区中进行自动寻址；寻址键基于 <paramref name="cbKey" /> 和/或 <paramref name="cKey" /> 指定的表达式。<br/>
      如果子工作区没有控制顺序，移动父工作区会导致在子工作区中进行自动“转到”；“转到”的记录编号基于 <paramref name="cbKey" /> 和/或 <paramref name="cKey" /> 指定的表达式。
      OrdSetRelation() 与 DBSetRelation() 完全相同（以及 SET RELATION...SCOPED 命令），但它还在子工作区的顺序上设置了范围。<br/>
      这意味着每当您选择子工作区时，仅当前父记录相关的记录将可见。<br/>
      这允许轻松处理一对多关系，在子数据窗口中显示相关数据时特别有用。有关更多信息，请参考 DBSetRelation()。
    </remarks>
    <example>
      此示例显示每个发票及其相关的行项目：
      <code language="X#">
        USE lineitem NEW VIA "DBFCDX"
        SET ORDER TO TAG InvNo
        USE invoice NEW VIA "DBFCDX"
        // 从发票到行项目设置选择性关系
        OrdSetRelation("LineItem", {|| Invoice-&gt;InvNo}, "Invoice-&gt;InvNo")
        GO TOP
        DO WHILE !EOF()
        &#0009;? InvNo, InvDate&#0009;&#0009;// 显示发票字段
        &#0009;SELECT LineItem
        &#0009;// 仅当前发票 # 的记录可见
        &#0009;LIST "   ", PartNo, Qty, Price
        &#0009;SELECT Invoice&#0009;&#0009;&#0009;// 继续到下一张发票
        &#0009;SKIP
        ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearRelation'>DBClearRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRelation'>DBRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRSelect'>DBRSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetRelation'>DBSetRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.Found'>Found</seealso>
    <seealsocmd>SET RELATION</seealsocmd>
  </ordsetrelation>

  <ordskipunique>
    <summary>
      移动记录指针到控制顺序中的下一个或上一个唯一键。
    </summary>
    <param name="nDirection">指定函数将跳过下一个或上一个键。省略此值或将其指定为1将跳到下一个唯一键。指定负值将跳到上一个键。</param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      OrdSkipUnique() 允许您使非唯一顺序看起来像唯一顺序。<br/>
      每次使用 OrdSkipUnique() 时，您将移动到下一个（或上一个）唯一键，就像您在跳过唯一顺序一样。<br/>
      此函数消除了维护唯一顺序时遇到的问题，同时为您提供对唯一键的快速访问。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
    </remarks>
    <example>
      此示例使用 OrdSkipUnique() 构建一个以字母“J”开头的唯一姓氏数组：
      <code language="X#">
        FUNCTION LastUnique()
        &#0009;LOCAL aLast[0]
        &#0009;SET INDEX TO last&#0009;&#0009;&#0009;// 使用姓氏顺序
        &#0009;? OrdIsUnique()&#0009;&#0009;&#0009;// 结果：FALSE
        &#0009;SET SCOPE TO "J"&#0009;&#0009;&#0009;// 仅查找以 J 开头的
        &#0009;GO TOP
        &#0009;DO WHILE !EOF()&#0009;&#0009;&#0009;// 将所有唯一 J
        &#0009;&#0009;AADD(aLast, Last)&#0009;&#0009;// 姓氏添加到 aLast
        &#0009;&#0009;OrdSkipUnique()
        &#0009;ENDDO
        &#0009;SET SCOPE TO&#0009;&#0009;&#0009;// 清除范围
        &#0009;RETURN aLast&#0009;&#0009;&#0009;// 返回唯一 J 名称的数组
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;//
      </code>
    </example>
    <seealsocmd>INDEX</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.OrdIsUnique'>OrdIsUnique</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetUnique'>SetUnique</seealso>
  </ordskipunique>

  <os>
    <summary>
      返回操作系统名称。
    </summary>
    <param name="lExtended">此参数可以包含任何内容。</param>
    <returns>
      OS() 返回当前工作站所运行的磁盘操作系统的名称，以及版本号。
    </returns>
    <remarks>
      如果没有参数，函数将返回
      &#0009;"Windows 2000...."
      对于 W2K、WXP 和 Windows Server 2003，以保持向后兼容。
      如果有参数，内容和类型无关紧要，它将返回正确的操作系统名称，例如
      &#0009;"Windows XP...."
      或
      &#0009;"Windows 2003 Server...."
      如果需要更准确的答案。
    </remarks>
    <example>
      此示例使用 OS() 报告当前工作站正在运行的操作系统：
      <code language="X#">? OS()&#0009;&#0009;// DOS 6.00, Windows 3.10</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetEnv'>GetEnv</seealso>
    <seealso cref='O:XSharp.RT.Functions.Version'>Version</seealso>
  </os>

  <pad>
    <summary>
      用填充字符在右侧填充字符、数字和日期值。
    </summary>
    <param name="uValue">要用填充字符填充的字符、数字或日期值。</param>
    <param name="nLength">要返回的字符串长度。</param>
    <param name="cFillChar">
      用于填充 <paramref name="uValue" /> 的字符。<br/>
      默认是一个空格字符。
    </param>
    <returns>
      一个包含 <paramref name="uValue" /> 的字符串，并用 <paramref name="cFillChar" /> 填充到总长度为 <paramref name="nLength" />。<br/>
      如果 <paramref name="uValue" /> 的长度超过 <paramref name="nLength" />，Pad() 将裁剪 cPaddedString 到 <paramref name="nLength" />。
    </returns>
    <remarks>
      Pad() 在固定长度区域内显示可变长度字符串。<br/>
      例如，它可以用来确保与连续的 ?? 命令对齐。<br/>
      另一个用途是将文本显示到固定宽度的屏幕区域，确保之前的文本完全被覆盖。
      Pad() 是 Trim() 的反向操作，后者从字符串中修剪尾部空格。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.PadC'>PadC</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadL'>PadL</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadR'>PadR</seealso>
    <seealso cref='O:XSharp.Core.Functions.Trim'>Trim</seealso>
  </pad>

  <padc>
    <summary>
      用填充字符在左右两侧填充字符、数字和日期值。
    </summary>
    <param name="uValue">要用填充字符填充的字符、数字或日期值。</param>
    <param name="nLength">要返回的字符串长度。</param>
    <param name="cFillChar">
      用于填充 <paramref name="uValue" /> 的字符。<br/>
      默认是一个空格字符。
    </param>
    <returns>
      一个包含 <paramref name="uValue" /> 的字符串，并用 <paramref name="cFillChar" /> 填充到总长度为 <paramref name="nLength" />。<br/>
      如果 <paramref name="uValue" /> 的长度超过 <paramref name="nLength" />，Pad() 将裁剪 cPaddedString 到 <paramref name="nLength" />。
    </returns>
    <remarks>
      PadC 与 Pad() 相同，只是 PadC() 在 <paramref name="nLength" /> 内居中 <paramref name="uValue" /> 并在左右两侧添加填充字符。<br/>
      有关更多信息，请参见 Pad()。
      PadC() 是 AllTrim() 的反向操作，后者修剪字符串的前导和尾部空格。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AllTrim'>AllTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
  </padc>

  <padl>
    <summary>
      用填充字符在左侧填充字符、数字和日期值。
    </summary>
    <param name="uValue">要用填充字符填充的字符、数字或日期值。</param>
    <param name="nLength">要返回的字符串长度。</param>
    <param name="cFillChar">
      用于填充 <paramref name="uValue" /> 的字符。<br/>
      默认是一个空格字符。
    </param>
    <returns>
      一个包含 <paramref name="uValue" /> 的字符串，并用 <paramref name="cFillChar" /> 填充到总长度为 <paramref name="nLength" />。<br/>
      如果 <paramref name="uValue" /> 的长度超过 <paramref name="nLength" />，Pad() 将裁剪 cPaddedString 到 <paramref name="nLength" />。
    </returns>
    <remarks>
      PadL 与 Pad() 相同，只是 PadL() 在左侧添加填充字符。<br/>
      有关更多信息，请参见 Pad()。
      PadL() 是 LTrim() 的反向操作，后者修剪字符串的前导空格。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
  </padl>

  <padr>
    <summary>
      用填充字符在右侧填充字符、数字和日期值。
    </summary>

    <param name="uValue">要用填充字符填充的字符、数字或日期值。</param>
    <param name="nLength">要返回的字符串长度。</param>
    <param name="cFillChar">
      用于填充 <paramref name="uValue" /> 的字符。<br/>
      默认是一个空格字符。
    </param>
    <returns>
      一个包含 <paramref name="uValue" /> 的字符串，并用 <paramref name="cFillChar" /> 填充到总长度为 <paramref name="nLength" />。<br/>
      如果 <paramref name="uValue" /> 的长度超过 <paramref name="nLength" />，PadR() 将裁剪 cPaddedString 到 <paramref name="nLength" />。
    </returns>
    <remarks>
      PadR() 与 Pad() 相同。<br/>
      有关更多信息，请参见 Pad()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
  </padr>

  <palettergb>
    <summary>
      从用户定义的调色板中获取特定颜色。
    </summary>
    <param name="bR">颜色中的红色量，范围从 0 到 255。</param>
    <param name="bG">颜色中的绿色量，范围从 0 到 255。</param>
    <param name="bB">颜色中的蓝色量，范围从 0 到 255。</param>
    <returns>
      描述的颜色相对于调色板中其他颜色的编号。<br/>
      如果描述的颜色在调色板中没有编号，则返回下一个最接近的编号。
    </returns>
    <remarks>
      PaletteRGB() 只能与支持调色板的设备一起使用，这些调色板可以由 Windows 程序员创建。有关调色板的更多信息，请参见 Windows API PaletteRGB() 函数。
    </remarks>
    <example>
      此示例使用 PaletteRGB() 创建一个红色的画笔。CreateSolidBrush() 和 SelectObject() 在 Win32 API 库中定义：
      <code language="X#">
        hBr :=  CreateSolidBrush(PaletteRGB(255, 0, 0))
        SelectObject(hdc, hBr)
        // 将创建的画笔选入当前 DC
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.RGB'>RGB</seealso>
  </palettergb>

  <pause>
    <summary>
      显示系统模态对话框以暂停当前应用程序。
    </summary>
    <returns>
      对话框的句柄。
    </returns>
    <remarks>
      Pause() 打开一个系统模态对话框，显示当前模块、实体和行号以及“等待...”消息。<br/>
      对话框有两个按钮：忽略和中止。按下忽略将继续应用程序执行，而按下中止将中止应用程序。
    </remarks>
    <example>
    </example>
    <seealsocmd>ASSERT</seealsocmd>
  </pause>

  <pcount>
    <summary>
      返回调用过程中传递的最后一个参数在参数列表中的位置。
    </summary>
    <returns>
      最后一个传递参数的位置。<br/>
      如果没有传递参数，PCount() 返回 0。
    </returns>
    <remarks>
      PCount() 用于确定参数列表末尾是否省略了参数。<br/>
      省略了参数列表中间的参数无法通过此函数检测到。<br/>
      不过，可以通过其他方式检测：
      &#0009;省略的参数未初始化，因此在访问时返回 NIL.<br/>
      因此，您可以通过测试参数是否为 NIL 来确定参数是否未接收值。<br/>
      要检查参数是否为 NIL，请使用 IsNil() 函数。
      &#0009;您可以使用 Default() 函数设置省略参数的默认值。
      &#0009;您可以通过使用 EnforceType() 或 EnforceNumeric() 来强制正确的数据类型。
    </remarks>
    <example>
      此示例是一个函数，它打开一个数据库文件，并使用 PCount() 来确定调用过程是否传递了要打开的数据库文件的名称。<br/>
      如果名称未传递，OpenFile() 将询问名称：
      <code language="X#">
        FUNCTION OpenFile(cFile)
        &#0009;IF PCount() = 0
        &#0009;&#0009;ACCEPT "使用的文件: " TO cFile
        &#0009;ENDIF
        &#0009;USE (cFile)
        &#0009;RETURN (NetErr())
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Default'>Default</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceNumeric'>EnforceNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.EnforceType'>EnforceType</seealso>
  </pcount>

  <pow>
    <summary>
      将第一个参数提升到第二个参数指定的数值幂。
    </summary>
    <param name="nBase">底数。</param>
    <param name="nExponent">要将底数提升到的幂。</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 Pow() 将 2 提升到 3 次方：
      <code language="X#">? Pow(2,3)&#0009;&#0009;&#0009;// 8.00</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Exp'>Exp</seealso>
  </pow>

  <procfile>
    <summary>
      返回激活模块的名称。
    </summary>
    <param name="wActivation">
      指定要查询的激活。<br/>
      值为 0 指当前激活，值为 1 指上一个激活，以此类推。<br/>
      默认值为 0。
    </param>
    <returns>
      对于当前激活，ProcFile() 返回当前模块的名称。<br/>
      对于先前的激活，ProcFile() 返回调用当前模块的模块的名称。
    </returns>
    <remarks>
      ProcFile() 查询 X# 激活堆栈以确定当前正在执行的模块的名称。
      ProcFile() 与 ProcLine() 和 ProcName() 一起使用，以报告调试信息。
      不是每个函数调用都会设置激活堆栈。<br/>
      如果在激活堆栈中使用了 PRIVATE 或 PUBLIC 变量或发出了 SET PROCNAME ON 命令，则函数会调用激活堆栈。
    </remarks>
    <example>
      此示例展示了在程序开发的调试阶段可以调用的函数，以显示当前和先前激活模块的名称：
      <code language="X#">
        // 在 Module1 中：
        FUNCTION Start()
        &#0009;MyFunction()
        // 在 Module2 中：
        FUNCTION MyFunction() AS VOID
        &#0009;? ProcFile()&#0009;&#0009;&#0009;// Module2 (当前)
        &#0009;? ProcFile(1)&#0009;&#0009;&#0009;// Module1 (上一个)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ProcLine'>ProcLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.ProcName'>ProcName</seealso>
  </procfile>

  <procline>
    <summary>
      返回激活实体中最后执行的行的源行号。
    </summary>
    <param name="dwActivation">
      指定要查询的激活。0 指当前激活，1 指上一个激活，依此类推。<br/>
      默认值为 0。
    </param>
    <returns>
      对于当前激活，ProcLine() 返回当前行的行号。<br/>
      对于先前的激活，ProcLine() 返回调用当前实体中 ProcLine() 的过程、函数或方法的行号。
      由于 X# 不是基于文件的，行号是相对于激活实体的开始，而不是相对于包含该实体的源文件的开始。<br/>
      一行可以包括注释、空行、自定义命令或续行。<br/>
      多语句行计算为单行。
    </returns>
    <remarks>
      ProcLine() 查询 X# 激活堆栈以确定当前正在执行的过程、函数或方法中的最后一行。
      ProcLine() 与 ProcFile() 和 ProcName() 一起使用，以报告调试信息。ProcLine() 和 ProcName() 受到应用程序菜单中的两个选项的控制：
      1.&#0009;应用程序编译器选项显示 CA-Clipper 兼容性选项列表，其中之一是 PROCNAME/PROCLINE：
      &#0009;如果选择了 PROCNAME/PROCLINE，这些函数将准确编译和运行。
      &#0009;如果未选择 PROCNAME/PROCLINE，这些函数将编译和运行，但可能不会产生准确的结果。
      2.&#0009;应用程序属性显示调试选项。<br/>
      如果选择了此选项，这些函数即使在未选择 PROCNAME/PROCLINE 的情况下也会产生准确的结果。
      SET PROCLINE 命令在实体级别覆盖这些编译器选项和应用程序设置。有关更多信息，请参见 SET PROCLINE 条目。
    </remarks>
    <example>
      此示例呈现一个可以在程序开发的调试阶段调用的函数，以显示激活堆栈的一部分及行号：
      <code language="X#">
        FUNCTION Start()
        &#0009;? "运行中"
        &#0009;MyFunction()
        FUNCTION MyFunction() AS VOID
        &#0009;? ProcLine()&#0009;&#0009;// 2 (当前函数中的行)
        &#0009;? ProcLine(1)&#0009;&#0009;// 3 (上一个函数中的行)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ProcFile'>ProcFile</seealso>
    <seealso cref='O:XSharp.Core.Functions.ProcName'>ProcName</seealso>
    <seealsocmd>SET PROCLINE</seealsocmd>
    <seealsocmd>SET PROCNAME</seealsocmd>
  </procline>

  <procname>
    <summary>
      返回激活实体的名称。
    </summary>
    <param name="wActivation">
      指定要查询的激活。<br/>
      值为 0 指当前激活，值为 1 指上一个激活，依此类推。<br/>
      默认值为 0。
    </param>
    <returns>
      对于当前激活，ProcName() 返回当前过程、函数或方法的名称。<br/>
      对于先前的激活，ProcName() 返回调用当前实体的过程、函数或方法的名称。
    </returns>
    <remarks>
      ProcName() 查询 X# 激活堆栈以确定当前正在执行的过程、函数或方法的名称。
      ProcName() 与 ProcFile() 和 ProcLine() 一起使用，以报告调试信息。ProcLine() 和 ProcName() 受到应用程序菜单中的两个选项的控制：
      1.&#0009;应用程序编译器选项显示 CA-Clipper 兼容性选项列表，其中之一是 PROCNAME/PROCLINE：
      &#0009;如果选择了 PROCNAME/PROCLINE，这些函数将准确编译和运行。
      &#0009;如果未选择 PROCNAME/PROCLINE，这些函数将编译和运行，但可能不会产生准确的结果。
      2.&#0009;应用程序属性显示调试选项。<br/>
      如果选择了此选项，这些函数即使在未选择 PROCNAME/PROCLINE 的情况下也会产生准确的结果。
      SET PROCNAME 命令在实体级别覆盖这些编译器选项和应用程序设置。有关更多信息，请参见 SET PROCNAME 条目。
    </remarks>
    <example>
      此示例呈现一个可以在程序开发的调试阶段调用的函数，以显示激活堆栈及行号：
      <code language="X#">
        FUNCTION ListStack() AS VOID
        &#0009;LOCAL wActivation := 1 AS DWORD
      </code>
      &#0009;
      <code language="X#">
        &#0009;DO WHILE "" != ProcName(wActivation)
        &#0009;&#0009;? "调用自:", ProcName(wActivation),;
        &#0009;&#0009;&#0009;"(" + NTrim(ProcLine(wActivation))+ + ")"
        &#0009;&#0009;++wActivation
        &#0009;ENDDO
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ProcFile'>ProcFile</seealso>
    <seealso cref='O:XSharp.Core.Functions.ProcLine'>ProcLine</seealso>
    <seealsocmd>SET PROCLINE</seealsocmd>
    <seealsocmd>SET PROCNAME</seealsocmd>
  </procname>

  <proper>
    <summary>
      将每个单词的首字母转换为大写
    </summary>
    <param name="cText">一串文本。</param>
    <returns>
      <paramref name="cText" /> 的每个单词开头都为大写字母。
    </returns>
    <remarks>
      Proper() 依赖于国家/地区。
    </remarks>
    <example>
      此示例使用 Proper() 来大写一个人的名字：
      <code language="X#">
        LOCAL cName AS STRING
        cName := "terry a. brown"
        ? Proper(cName)&#0009;&#0009;&#0009;// Terry A. Brown
        ? cName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// terry a. brown
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ProperA'>ProperA</seealso>
  </proper>

  <propera>
    <summary>
      正确地大写一个专有名词，同时改变参数的内容以及返回值。
    </summary>
    <param name="cName">一个专有名词。</param>
    <returns>
      <paramref name="cName" /> 的每个单词开头都为大写字母。
    </returns>
    <remarks>
      ProperA() 与 Proper() 相同，不同之处在于 ProperA() 同时更改原始字符串。
      <note type="tip">
        您可以同时更改多个变量（请参见下面的示例）。
      </note>
    </remarks>
    <example>
      此示例使用 ProperA() 来大写一个人的名字。将结果与 Proper 示例中的结果进行比较：
      <code language="X#">
        LOCAL cName AS STRING
        cName : = "terry a. brown"
        ? ProperA(cName)&#0009;&#0009;&#0009;// Terry A. Brown
        ? cName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// Terry A. Brown
      </code>
      此示例展示了如何同时更改多个变量：
      <code language="X#">
        a:= "i change"
        b:= a
        ProperA(b)
        ? b &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// "I Change"
        ? a &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// "I Change"
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Proper'>Proper</seealso>
  </propera>

  <psz2string>
    <summary>
      将一个以 NULL 结束的字符串转换为强类型字符串。
    </summary>
    <param name="pszString">一个以 NULL 结束的字符串。</param>
    <returns>
    </returns>
    <remarks>
      Psz2String() 可用于在调用期望强类型字符串作为参数的函数之前进行必要的转换。
    </remarks>
    <example>
      此示例使用 Psz2String() 将一个以 NULL 结束的字符串转换为强类型字符串：
      <code language="X#">
        LOCAL cMyBuffer AS STRING
        LOCAL pszString AS PSZ
        pszString := String2Psz("零终止")
        cMyBuffer := Psz2String(pszString)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Mem2String'>Mem2String</seealso>
    <seealso cref='O:XSharp.RT.Functions.Psz2Usual'>Psz2Usual</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszAlloc'>PszAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszLen'>PszLen</seealso>
  </psz2string>

  <psz2usual>
    <summary>
      将 PSZ 转换为带有 PSZ 标签的 USUAL。
    </summary>
    <param name="pszString">要转换的 PSZ。</param>
    <returns>
      将 <paramref name="pszString" /> 转换为带有 PSZ 标签的 USUAL。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 Psz2Usual() 将 PSZ 转换为带有 PSZ 标签的 USUAL：
      <code language="X#">
        LOCAL uMyBuffer AS USUAL
        LOCAL pszString AS PSZ
        pszString := String2Psz("零终止")
        uMyBuffer := Psz2Usual(pszString)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Mem2String'>Mem2String</seealso>
    <seealso cref='O:XSharp.RT.Functions.Psz2String'>Psz2String</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszAlloc'>PszAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszLen'>PszLen</seealso>
  </psz2usual>

  <pszalloc>
    <summary>
      将一个 PSZ 指向的缓冲区复制到新分配的内存块，并返回指向该内存的新指针。
    </summary>
    <param name="pszString">一个以 NULL 结束的字符串。</param>
    <returns>
    </returns>
    <remarks>
      新分配的字符串是一个静态对象，这意味着垃圾回收器不会移动该字符串。
    </remarks>
    <example>
      此示例显示两个变量的存储地址：
      <code language="X#">
        LOCAL pszString AS PSZ
        LOCAL pszOrigString AS PSZ
        pszOrigString := "Cavo tree"
        pszString := PszAlloc(pszOrigString)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemAlloc'>MemAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemFree'>MemFree</seealso>
    <seealso cref='O:XSharp.RT.Functions.Psz2String'>Psz2String</seealso>
    <seealso cref='O:XSharp.RT.Functions.Psz2Usual'>Psz2Usual</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszLen'>PszLen</seealso>
    <seealso cref='O:XSharp.RT.Functions.StringAlloc'>StringAlloc</seealso>
  </pszalloc>

  <pszlen>
    <summary>
      返回 PSZ 的长度。
    </summary>
    <param name="pszString">一个以 NULL 结束的字符串。</param>
    <returns>
      <paramref name="pszString" /> 的长度。<br/>
      不计算 NULL 终止字符。
    </returns>
    <remarks>
      PszLen() 是 Len() 的强类型版本。
    </remarks>
    <example>
      此示例使用 PszLen() 来确定一个以 NULL 结束的字符串的长度：
      <code language="X#">
        LOCAL pszString AS PSZ
        pszString := PszAlloc("CAVO2x tree")
        ? PszLen(pszString)&#0009;&#0009;&#0009;&#0009;&#0009;// 11
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.RT.Functions.Psz2String'>Psz2String</seealso>
    <seealso cref='O:XSharp.RT.Functions.Psz2Usual'>Psz2Usual</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszAlloc'>PszAlloc</seealso>
    <seealso cref='O:XSharp.Core.Functions.SLen'>SLen</seealso>
  </pszlen>

  <ptrlen>
    <summary>
      确定在给定指针处可以读取的字节数。
    </summary>
    <param name="ptrRead">要检查的指针。</param>
    <returns>
      从 <paramref name="ptrRead" /> 指向的位置开始可以读取的字节数。<br/>
      如果 <paramref name="ptrRead" /> 是无效指针，则返回值为 0。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例说明 PtrLen()：
      <code language="X#">
        LOCAL ptrFunc AS PTR
        ptrFunc := @ MyFunc()
        ? PtrLen(ptrFunc)
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.PtrLenWrite'>PtrLenWrite</seealso>
  </ptrlen>

  <ptrlenwrite>
    <summary>
      确定在给定指针处可以写入的字节数。
    </summary>
    <param name="ptrWrite">要检查的指针。</param>
    <returns>
      从 <paramref name="ptrRead" /> 指向的位置开始可以写入的字节数。<br/>
      如果 <paramref name="ptrRead" /> 是无效指针或写保护指针，则返回值为 0。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 PtrLen() 作为 HexDump() 的参数：
      <code language="X#">HexDump(ptrBuff, PtrLen(ptrBuff))</code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.PtrLen'>PtrLen</seealso>
  </ptrlenwrite>

  <qout>
    <summary>
      在终端窗口向控制台显示一个或多个表达式的结果。
    </summary>
    <param name="uValueList">
      要显示到控制台的任意数据类型的表达式的逗号分隔列表。<br/>
      如果 QOut() 没有指定参数，则显示一个回车/换行符对。
    </param>
    <returns>
    </returns>
    <remarks>
      QOut() 是一个控制台函数。<br/>
      它是创建 ? 命令的基本原语。与 ? 命令一样，它将一个或多个表达式的结果显示到控制台。QOut() 在显示 <paramref name="uValueList" /> 的结果之前输出回车和换行字符。<br/>
      当 QOut() 显示到控制台时，Row() 和 Col() 会被更新。<br/>
      如果 SetPrinter() 为 TRUE，则 PRow() 和 PCol() 会被更新。<br/>
      如果指定 <paramref name="uValueList" />，QOut() 在每个表达式的结果之间显示一个空格。<br/>
      可以在表达式中使用 QOut() 进行控制台显示。<br/>
      这对于块、迭代函数如 AEval() 和 DBEval() 以及命令定义的输出模式中的语句列表特别有用。
    </remarks>
    <example>
      此示例显示了三个用逗号分隔的表达式的值：
      <code language="X#">
        QOut("你好", 20, TODAY())
        // 你好     20        12/17/98
      </code>
      此示例使用 QOut() 和 AEval() 将文字数组的内容列出到控制台：
      <code language="X#">
        LOCAL aElements := {1, 2, 3, 4, 5}
        AEval(aElements, {|element| QOut(element)})
      </code>
    </example>
    <seealsocmd>?</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.QQOut'>QQOut</seealso>
  </qout>

  <qqout>
    <summary>
      在终端窗口向控制台显示一个或多个表达式的结果。
    </summary>
    <param name="uValueList">
      要显示到控制台的任意数据类型的表达式的逗号分隔列表。<br/>
      如果 QQOut() 没有指定参数，则不显示任何内容。
    </param>
    <returns>
    </returns>
    <remarks>
      QQOut() 与 QOut() 相同，只是它创建 ?? 命令，并在当前 Row() 和 Col() 位置显示 <paramref name="uValueList" /> 的结果。<br/>
      有关更多信息，请参见 QOut()。
    </remarks>
    <example>
      此示例显示了三个用逗号分隔的表达式的值：
      <code language="X#">
        QQOut("你好", 20, TODAY())
        // 你好     20        12/17/2006
      </code>
      此示例使用 QQOut() 和 AEval() 将文字数组的内容列出到控制台：
      <code language="X#">
        LOCAL aElements := {1, 2, 3, 4, 5}
        AEval(aElements, {|element| QQOut(element)})
      </code>
    </example>
    <seealsocmd>??</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.QOut'>QOut</seealso>
  </qqout>

  <queryrtregint>
    <summary>
      从注册表中检索数值。
    </summary>
    <param name="cSubkey">您要搜索数值的子键。</param>
    <param name="cKey">您要搜索数值的键。</param>
    <returns>
      如果条目 <paramref name="cKey" /> = <paramref name="dwValue" /> 存在，则返回 <paramref name="dwValue" />；否则返回零。
    </returns>
    <remarks>
      QueryRTRegInt() 在以下键中搜索注册表：
      HKEY_CURRENT_USER
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      或：
      HKEY_LOCAL_MACHINE
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      QueryRTRegInt() 首先尝试从 HKEY_CURRENT_USER 读取。当在 HKEY_CURRENT_USER 下找不到键时，它会尝试从 HKEY_LOCAL_MACHINE 读取。
    </remarks>
    <example>
      此示例使用 QueryRTRegInt() 获取与子键 SSA 下的 LOCK_RETRIES 注册表项相关联的值。<br/>
      生成的值用于 DO WHILE 循环，确定尝试 RLock() 操作的次数：
      <code language="X#">
        nRetries := QueryRTRegInt("SSA", "LOCK_RETRIES")
        DO WHILE nRetries &gt; 0
        &#0009;IF RLock()
        &#0009;&#0009;EXIT
        &#0009;ENDIF
        &#0009;nRetries--
        ENDDO
        IF nRetries = 0
        &#0009;// 错误消息
        ENDIF
        ...
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegString'>QueryRTRegString</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegInt'>SetRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegString'>SetRTRegString</seealso>
  </queryrtregint>

  <queryrtregstring>
    <summary>
      从注册表中检索字符串值。
    </summary>
    <param name="cSubkey">您要搜索字符串值的子键。</param>
    <param name="cKey">您要搜索字符串值的键。</param>
    <returns>
      如果条目 <paramref name="cKey" /> = <paramref name="cValue" /> 存在，则返回 <paramref name="cValue" />；否则返回零。
    </returns>
    <remarks>
      QueryRTRegString() 在以下键中搜索注册表：
      HKEY_CURRENT_USER
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      或：
      HKEY_LOCAL_MACHINE
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      QueryRTRegString() 首先尝试从 HKEY_CURRENT_USER 读取。当在 HKEY_CURRENT_USER 下找不到键时，它会尝试从 HKEY_LOCAL_MACHINE 读取。
    </remarks>
    <example>
      此示例使用 QueryRTRegString() 获取与子键 SSA 下的 APP_DIR 注册表项相关联的值。<br/>
      生成的目录名称在打开文件之前附加到数据库文件名：
      <code language="X#">
        cDbf:=QueryRTRegString("SSA","APP_DIR") + "test.dbf"
        USE (cDbf)
        ...
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegInt'>QueryRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegInt'>SetRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegString'>SetRTRegString</seealso>
  </queryrtregstring>

  <rand>
    <summary>
      返回一个介于 0 和 1 之间的随机数。
    </summary>
    <param name="nSeed">
      一个可选的起始值。<br/>
      这是初始化随机数生成器的点。随后的随机数将受到 <paramref name="nSeed" /> 的影响。<br/>
      如果您首先调用 Rand() 而不带 <paramref name="nSeed" />，则它的起始值默认为 100001。<br/>
      如果您以 100001 作为 <paramref name="nSeed" /> 调用该函数，它允许您重新启动生成器。<br/>
      然后，如果您多次调用该函数而不指定 <paramref name="nSeed" />，它将返回“标准序列”的数字。<br/>
      如果 <paramref name="nSeed" /> 小于或等于 0，系统时间将被引入该过程。
    </param>
    <returns>
    </returns>
    <remarks>
      Rand() 允许您生成伪随机数字。多次调用 Rand() 总是返回相同的随机数序列，只要它们在首次调用时使用相同的起始值 (<paramref name="nSeed" />)，并且任何后续调用不指定 <paramref name="nSeed" />。
    </remarks>
    <example>
      此示例使用 Rand() 生成每次运行时相同的序列：
      <code language="X#">
        // 初始化为默认起始种子
        ? Rand(100001.0)
        ? Rand()&#0009;&#0009;&#0009;// 已知序列（未传入参数）
        ? Rand()&#0009;&#0009;&#0009;// 已知序列（未传入参数）
      </code>
      此示例生成与前一个示例相同的起始值，但后续调用接受一个种子值，该值也受系统时间的影响：
      <code language="X#">
        ? Rand(100001.0)
        ? Rand(0.0)&#0009;&#0009;// 依赖于确切的时间
        ? Rand(0.0)&#0009;&#0009;// 依赖于时间
      </code>
      此示例生成一系列随机数，然后重新初始化为相同的种子，以再现相同的数字：
      <code language="X#">
        ? Rand(100.0)&#0009;// 非默认种子值
        ? Rand()&#0009;&#0009;&#0009;// 已知序列
        ? Rand()
        ? Rand(100.0)&#0009;// 再次生成相同序列
        ? Rand()
        ? Rand()
      </code>
      此示例将结果乘以 100 以增加返回值的范围：
      <code language="X#">? Rand()*100</code>
    </example>
  </rand>

  <rat>
    <summary>
      返回子字符串在字符串中最后一次出现的位置。
    </summary>
    <param name="cSearch">要搜索的子字符串。</param>
    <param name="cTarget">要在其中搜索的字符串。（要指定偏移量，请使用 RAt3()。）</param>
    <returns>
      <paramref name="cSearch" /> 在 <paramref name="cTarget" /> 中的位置。<br/>
      如果未找到 <paramref name="cSearch" />，则 RAt() 返回 0。
    </returns>
    <remarks>
      RAt() 类似于 At()，后者返回子字符串在另一个字符串中第一次出现的位置。<br/>
      如果您只需要知道一个子字符串是否存在于另一个字符串中，请使用 InStr() 函数或 $ 运算符。
      RAt() 和 At() 函数可与 Substr()、Left() 和 Right() 一起使用，以提取子字符串。
    </remarks>
    <example>
      此示例使用 RAt() 创建一个函数 FilePath()，该函数从文件规范中提取路径。<br/>
      如果未指定路径，FilePath() 返回 NULL_STRING：
      <code language="X#">
        ? FilePath("c:\dbf\sales.dbf")&#0009;&#0009;// c:\dbf\
        FUNCTION FilePath(cFile AS STRING)
        &#0009;LOCAL nPos AS DWORD
        &#0009;LOCAL cFilePath AS STRING
        &#0009;IF (nPos := RAt("\", cFile)) != 0
        &#0009;&#0009;cFilePath := Substr(cFile, 1, nPos)
        &#0009;ELSE
        &#0009;&#0009;cFilePath := NULL_STRING
        &#0009;ENDIF
        &#0009;RETURN cFilePath
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.Instr'>InStr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt2'>RAt2</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt3'>RAt3</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAtLine'>RAtLine</seealso>
    <seealso cref='O:XSharp.Core.Functions.RATLine2'>RAtLine2</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </rat>

  <rat2>
    <summary>
      返回子字符串在字符串中最后一次出现的位置。
    </summary>
    <param name="cSearch">要搜索的子字符串。</param>
    <param name="cTarget">要在其中搜索的字符串。（要指定偏移量，请使用 RAt3()。）</param>
    <returns>
      <paramref name="cSearch" /> 在 <paramref name="cTarget" /> 中的位置。<br/>
      如果未找到 <paramref name="cSearch" />，则 RAt2() 返回 0。
    </returns>
    <remarks>
      RAt2() 与 RAt() 相同，但 RAt2() 返回 WORD。有关更多信息，请参见 RAt()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt3'>RAt3</seealso>
  </rat2>

  <rat3>
    <summary>
      返回子字符串在字符串中最后一次出现的位置。
    </summary>
    <param name="cSearch">要搜索的子字符串。</param>
    <param name="cTarget">要在其中搜索的字符串。</param>
    <param name="dwOffSet">
      开始搜索的字符串位置。<br/>
      值为零（0）表示第一个字节。
    </param>
    <returns>
      <paramref name="cSearch" /> 在 <paramref name="cTarget" /> 中的位置。<br/>
      如果未找到 <paramref name="cSearch" />，则 RAt3() 返回 0。
    </returns>
    <remarks>
      RAt3() 与 RAt() 相同，但您可以指定一个偏移量，以指示从哪里开始搜索。有关更多信息，请参见 RAt()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt2'>RAt2</seealso>
  </rat3>

  <ratline>
    <summary>
      返回多行字符串中子字符串最后一次出现的行号。
    </summary>
    <param name="cSearch">要搜索的子字符串。</param>
    <param name="cTarget">要在其中搜索的字符串。</param>
    <returns>
      <paramref name="cSearch" /> 在 <paramref name="cTarget" /> 中最后一次出现的位置。<br/>
      如果未找到 <paramref name="cSearch" />，RAтLine() 返回 0。
    </returns>
    <remarks>
      RAtLine() 通过从右侧搜索目标字符串来返回子字符串最后一次出现的位置。
    </remarks>
    <example>
      该示例使用 RAtLine() 来指示“line”最后一次出现在线上：
      <code language="X#">
        LOCAL cBigString AS STRING
        cBigString := "这是第一行" + ;
        &#0009;&#0009;_Chr(K_RETURN) + "这是第二行" + ;
        &#0009;&#0009;_Chr(K_RETURN) + "这是第三行"
        ? RAtLine("line", cBigString)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 3
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt2'>RAt2</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt3'>RAt3</seealso>
    <seealso cref='O:XSharp.Core.Functions.RATLine2'>RAtLine2</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrTran'>StrTran</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </ratline>

  <ratline2>
    <summary>
      返回多行字符串中子字符串最后一次出现的行号。
    </summary>
    <param name="cSearch">要搜索的子字符串。</param>
    <param name="cTarget">要在其中搜索的字符串。</param>
    <returns>
      <paramref name="cSearch" /> 在 <paramref name="cTarget" /> 中最后一次出现的位置。<br/>
      如果未找到 <paramref name="cSearch" />，RAтLine2() 返回 0。
    </returns>
    <remarks>
      RAtLine2() 与 RAtLine() 相同，但 RAtLine2() 返回 WORD。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.RAtLine'>RAtLine</seealso>
  </ratline2>

  <rddcount>
    <summary>
      获取当前加载的 RDD 数量。
    </summary>
    <param name="kRDDType">
      要计数的 RDD 类型。<br/>
      类型为<br/>
      &#0009;常量&#0009;描述<br/>
      &#0009;RDT_FULL&#0009;完全实现的 RDD<br/>
      &#0009;RDT_TRANSFER&#0009;转移 RDD<br/>
      &#0009;RDT_HIDDEN&#0009;特定 RDD<br/>
      &#0009;如果未指定 <paramref name="kRDDType" />，则假定为 RDT_FULL + RDT_TRANSFER。
    </param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      以下示例通过 DBFNTX 驱动程序打开两个文件，并通过 DBFMDX 驱动程序打开另一个文件。<br/>
      然后计数并列出所有正在使用的 RDD：
      <code language="X#">
        PROCEDURE Start()
        &#0009;LOCAL aRDD &#0009;AS ARRAY
        &#0009;LOCAL wRDDs&#0009;AS SHORTINT
        &#0009;LOCAL i &#0009;&#0009;AS SHORTINT
        &#0009;USE customer NEW
        &#0009;USE address NEW
        &#0009;USE memos VIA DBFMDX NEW
        &#0009;wRDDs:= ;&#0009;RDDCount(RDT_FULL+RDT_TRANSFER+RDT_HIDDEN)
        &#0009;aRDD := ;&#0009;RDDList(RDT_FULL+RDT_TRANSFER+RDT_HIDDEN)
        &#0009;FOR i := 1 UPTO wRDDs
        &#0009;&#0009;QOut(aRDD[i])
        &#0009;NEXT
        &#0009;RETURN
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.RddList'>RDDList</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddName'>RDDName</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddList'>VODBRDDLIST</seealso>
  </rddcount>

  <rddinfo>
    <summary>
      返回并可选择性地更改由 RDD 直接控制的设置。
    </summary>
    <param name="kInfoType">
      指定设置类型。<br/>
      <include file="RTComments.xml" path="Comments/RddInfoParam/*"  />
    </param>
    <param name="uNewSetting">
      如果指定，此参数用于更改设置的值。<br/>
      数据类型（以及是否可以指定 <paramref name="uNewSetting" />）取决于 <paramref name="kInfoType" /> 常量，并在下面的"常量"部分中有详细说明。<br/>
    </param>
    <remarks>
      <include file="RTComments.xml" path="Comments/RddInfoRemarks/*"  />
    </remarks>
    <returns>
      如果未指定 <paramref name="uNewSetting" />，RDDInfo() 返回当前设置。<br/>
      如果指定了 <paramref name="uNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRecordInfo'>DBRecordInfo</seealso>
  </rddinfo>

  <rddlist>
    <summary>
      获取正在使用的 RDD 列表。
    </summary>
    <param name="kRDDType">
      要包含在列表中的 RDD 类型。<br/>
      类型如下：<br/>
      &#0009;常量&#0009;描述<br/>
      &#0009;RDT_FULL&#0009;完全实现的 RDD<br/>
      &#0009;RDT_TRANSFER&#0009;转移 RDD<br/>
      &#0009;RDT_HIDDEN&#0009;特定 RDD<br/>
      &#0009;如果未指定 <paramref name="kRDDType" />，则假定为 RDT_FULL + RDT_TRANSFER。
    </param>
    <returns>
      包含当前加载的 RDD 名称的数组。
    </returns>
    <remarks>
    </remarks>
    <example>
      以下示例通过默认的 DBFNTX 打开两个文件，并通过 DBFMDX 驱动程序打开另一个文件。<br/>
      然后计数并列出所有正在使用的 RDD：
      <code language="X#">
        PROCEDURE Start()
        &#0009;LOCAL aRDD &#0009;AS ARRAY
        &#0009;LOCAL wRDDs&#0009;AS SHORTINT
        &#0009;LOCAL i &#0009;&#0009;AS SHORTINT
        &#0009;USE customer NEW
        &#0009;USE address NEW
        &#0009;USE memos VIA DBFMDX NEW
        &#0009;wRDDs:= ;&#0009;RDDCount(RDT_FULL+RDT_TRANSFER+RDT_HIDDEN)
        &#0009;aRDD := ;&#0009;RDDList(RDT_FULL+RDT_TRANSFER+RDT_HIDDEN)
        &#0009;FOR i := 1 UPTO wRDDs
        &#0009;&#0009;QOut(aRDD[i])
        &#0009;NEXT
        &#0009;RETURN
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.RddCount'>RDDCount</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddName'>RDDName</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddList'>VODBRDDLIST</seealso>
  </rddlist>

  <rddname>
    <summary>
      返回 RDD 名称。
    </summary>
    <returns>
    </returns>
    <remarks>
      默认情况下，此函数返回当前选定工作区中的 RDD 名称。<br/>
      通过在别名表达式中指定工作区，可以使其在未选定工作区上操作。
      默认 RDD 可以通过 RDDSetDefault() 设置。
    </remarks>
    <example>
      以下示例检查默认 RDD，以报告索引文件的默认扩展名：
      <code language="X#">
        IF RDDName() == "DBFMDX"
        &#0009;QOut(".MDX 扩展名")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDriver'>DBDriver</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddList'>RDDList</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddName'>VODBRDDName</seealso>
  </rddname>

  <rddsetdefault>
    <summary>
      返回并可选地更改应用程序的默认 RDD。
    </summary>
    <param name="cNewSetting">
      将用于激活和管理应用程序的 RDD 名称，当未明确指定 RDD 时使用。<br/>
      如果此 RDD 对应用程序不可用，则调用没有效果。<br/>
      要返回当前默认 RDD，请指定 NULL_STRING。
    </param>
    <returns>
      如果 <paramref name="cNewSetting" /> 被指定为 NULL_STRING，RDDSetDefault() 返回当前默认 RDD。<br/>
      如果 <paramref name="cNewSetting" /> 被指定，则返回之前的默认 RDD。
    </returns>
    <remarks>
      除非通过调用 RDDSetDefault()（或其他明确设置默认值的函数）进行建立，否则默认 RDD 的名称是未确定的。
      此函数替代了 DBSetDriver() 函数。<br/>
      要在不更改的情况下返回默认 RDD，请使用 DBDriver()。
    </remarks>
    <example>
      以下示例检查默认 RDD，然后在必要时设置不同的 RDD：
      <code language="X#">
        IF RDDSetDefault("") == "DBFMDX"
        &#0009;RDDSetDefault("DBFNTX")
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDriver'>DBDriver</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddList'>RDDList</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddSetDefault'>VODBRDDSetDefault</seealso>
  </rddsetdefault>

  <real42bin>
    <summary>
      将 Real4 值转换为包含 32 位浮点数的字符串。
    </summary>
    <param name="r4Value">要转换的值。</param>
    <returns>
    </returns>
    <remarks>
      Real42Bin() 是一个转换函数，将 Real4 数据类型转换为 4 字节字符串。典型应用包括以原生格式读取外部文件类型，然后以压缩的二进制形式而非字符串形式保存、读取、解密和传输数据。<br/>
      其逆函数是 Bin2Real4()。
    </remarks>
    <example>
      此示例以二进制格式写入数值数据，以节省磁盘空间和可能的传输时间：
      <code language="X#">
        FUNCTION Compressed() AS LOGIC
        &#0009;LOCAL nh
        &#0009;LOCAL lSuccess := FALSE AS LOGIC
        &#0009;nh := FOpen2("data.bin", FO_READWRITE)
        &#0009;// 假设文件 debug.bin 已存在
        &#0009;IF nh != F_ERROR
        &#0009;&#0009;FWrite3(nh, Real42Bin(123456.789), 4)
        &#0009;&#0009;FWrite3(nh, Real42Bin(12 ^ 6), 4)
        &#0009;&#0009;FWrite3(nh, Real42Bin(4566.969), 4)
        &#0009;&#0009;FClose(nh)
        &#0009;&#0009;lSuccess := TRUE
        &#0009;ELSE
        &#0009;&#0009;? DOSErrString(siError)
        &#0009;ENDIF
        &#0009;RETURN lSuccess
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </real42bin>

  <real82bin>
    <summary>
      将 Real8 值转换为包含 8 字节浮点数的字符串。
    </summary>
    <param name="r8Value">要转换的值。</param>
    <returns>
    </returns>
    <remarks>
      Real82Bin() 是一个转换函数，将 Real8 数据类型转换为 8 字节字符串。典型应用包括以原生格式读取外部文件类型，然后以压缩的二进制形式而非字符串形式保存、读取、解密和传输数据。<br/>
      其逆函数是 Bin2Real8()。
    </remarks>
    <example>
      此示例以二进制格式写入数值数据，以节省磁盘空间和可能的传输时间：
      <code language="X#">
        FUNCTION Compressed() AS LOGIC
        &#0009;LOCAL nh
        &#0009;LOCAL lSuccess := FALSE AS LOGIC
        &#0009;nh := FOpen2("data.bin", FO_READWRITE)
        &#0009;// 假设文件 debug.bin 已存在
        &#0009;IF nh != F_ERROR
        &#0009;&#0009;FWrite3(nh, Real82Bin(123456.789), 8)
        &#0009;&#0009;FWrite3(nh, Real82Bin(12 ^ 6), 8)
        &#0009;&#0009;FWrite3(nh, Real82Bin(4566.969), 8)
        &#0009;&#0009;FClose(nh)
        &#0009;&#0009;lSuccess := TRUE
        &#0009;ELSE
        &#0009;&#0009;? DOSErrString(siError)
        &#0009;ENDIF
        &#0009;RETURN lSuccess
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real8'>Bin2Real8</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.W2Bin'>W2Bin</seealso>
  </real82bin>

  <reccount>
    <summary>
      确定数据库文件中的记录数量。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
  </reccount>

  <recno>
    <summary>
      返回当前记录编号。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      当前记录编号。<br/>
      如果工作区包含 0 条记录，RecNo() 返回 1，BOF() 和 EOF() 都返回 TRUE，LastRec() 返回 0。
      如果记录指针移动到最后一条记录之后，RecNo() 返回 LastRec() + 1，EOF() 返回 TRUE。<br/>
      如果试图移动到第一条记录之前，RecNo() 返回数据库文件中第一条逻辑记录的记录编号，BOF() 返回 TRUE。<br/>
      如果没有数据库文件打开，RecNo() 将返回 0。
    </returns>
    <remarks>
      X# 数据库文件按记录编号物理排序。<br/>
      每个工作区依次维护一个指向其打开的数据库文件中当前记录的指针。该记录编号由 RecNo() 报告。<br/>
      这允许直接访问记录，而无需顺序扫描数据库文件以达到指定的记录位置。
      通常，RecNo() 会对处理记录的例程进行概括。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      此示例在故意移动记录指针后查询 RecNo()：
      <code language="X#">
        USE customer NEW
        GO 3
        QOut(RECNO())&#0009;&#0009;&#0009;&#0009;// 结果：3
        GO TOP
        QOut(RECNO())&#0009;&#0009;&#0009;&#0009;// 结果：1
        nRecord := 3
        GO nRecord
        QOut(RECNO())&#0009;&#0009;&#0009;&#0009;// 结果：3
        DBGoBottom()
        SKIP
        QOut(RECNO(), LastRec())&#0009;&#0009;// 结果：11 10
      </code>
      此示例使用别名表达式查询未选择工作区中的 RecNo() 值：
      <code language="X#">
        USE sales NEW
        USE customer NEW
        QOut(Sales-&gt;RECNO())
        QOut(Customer-&gt;RECNO())
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bof'>BOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
  </recno>

  <recsize>
    <summary>
      确定数据库文件的记录长度。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      记录长度，以字节为单位。若没有数据库文件打开，RecSize() 返回 0。
    </returns>
    <remarks>
      RecSize() 通过求和每个字段的长度，然后加上一个用于 Deleted() 状态标志的长度，来确定记录的长度。当这个值乘以 LastRec() 时，结果是文件中所有记录所占据的空间量。
      RecSize() 在执行自动文件备份的程序中很有用。当与 DiskSpace() 一起使用时，RecSize() 函数可以帮助确保在存储文件之前磁盘上有足够的可用空间。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      以下函数 DBFSize() 使用 RecSize() 来计算当前数据库文件的大小：
      <code language="X#">
        FUNCTION DBFSize
        &#0009;RETURN ((RecSize() * LastRec()) + Header() + 1)
      </code>
      此示例说明了如何使用 RecSize() 来确定未选定工作区中数据库文件的记录长度：
      <code language="X#">
        USE customer NEW
        USE sales NEW
        QOut(RecSize(), Customer-&gt;RecSize())
        QOut(DBFSize(), Customer-&gt;DBFSize())
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbRecordInfo'>DBRecordInfo</seealso>
    <seealso cref='O:XSharp.Core.Functions.DiskSpace'>DiskSpace</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldName'>FieldName</seealso>
    <seealso cref='O:XSharp.RT.Functions.Header'>Header</seealso>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
  </recsize>

  <reference>
    <summary>
      按类别的字母顺序列出
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </reference>

  <registeraxit>
    <summary>
      注册一个对象，以便在被垃圾回收器销毁之前接收 Axit 消息。
    </summary>
    <param name="oObject">要注册的对象。</param>
    <returns>
    </returns>
    <remarks>
      RegisterAxit() 会在指定对象被销毁之前，导致垃圾回收器向该对象发送 Axit 消息。<br/>
      通过这种方式，您可以为对象的类编写一个名为 Axit() 的方法，该方法将在对象的标准垃圾回收过程中自动调用。RegisterAxit() 通常在 Init() 方法中发出，如下面的示例所示。
      Axit() 方法通常用于清理代码。<br/>
      例如，您可能会关闭所有打开的文件，恢复旧的环境设置，释放内存等。
      提示：<br/>
      使用 Memory(MEMORY_REGISTERAXIT) 获取为 Axit 注册的对象数量。
    </remarks>
    <example>
      此示例说明了一个类声明，该类在 Init() 方法中分配内存，并在 Axit() 方法中释放它：
      <code language="X#">
        CLASS SysOne&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 定义 SysOne 类
        &#0009;INSTANCE ptrX AS PTR
        CONSTRUCTOR() CLASS SysOne
        &#0009;ptrX := MemAlloc(1000)
        &#0009;RegisterAxit(SELF)
        &#0009;RETURN SELF
        METHOD Axit() CLASS SysOne
        &#0009;MemFree(ptrX)
        FUNCTION UseClass()
        &#0009;LOCAL oLowLevel AS SysOne
        &#0009;oLowLevel := SysOne{}&#0009;&#0009;&#0009;// 调用 SysOne:Init()
        &#0009;. . .
        &#0009;// 由于对象已被注册，
        &#0009;// 垃圾回收器在对象销毁之前调用 SysOne:Axit()
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.RegisterExit'>_RegisterExit</seealso>
    <seealso cref='O:XSharp.RT.Functions.InCollect'>InCollect</seealso>
    <seealso cref='O:XSharp.VO.Functions.RegisterKid'>RegisterKid</seealso>
    <seealso cref='O:XSharp.RT.Functions.UnRegisterAxit'>UnregisterAxit</seealso>
  </registeraxit>

  <registerkid>
    <summary>
      注册一个动态对象，以便在垃圾回收后进行更新。
    </summary>
    <param name="ptrKid">要注册的动态对象的指针。</param>
    <param name="dwCount">
      要注册的连续对象的数量。<br/>
      这些对象可以是 USUAL 或类型动态对象（字符串、浮点数、类对象或数组）。
    </param>
    <param name="lItem">确定注册的对象是否为多态：TRUE 指定为 USUAL，FALSE 指定为类型。</param>
    <returns>
    </returns>
    <remarks>
      RegisterKid() 确保动态对象在垃圾回收后被保留。动态对象会受到垃圾回收的影响，其指针在收集后变得无效。但是，如果指针被注册，它会自动更新并在收集后保持有效。
      使用 Memory(MEMORY_REGISTERKID) 获取活动注册对象的数量。
      <note type="tip">
        警告！无效参数会导致垃圾收集器内发生一般保护故障。
        您必须始终确保在指针超出范围之前执行 UnregisterKid()；因此，例如，您总是应使用以下逻辑进行 BEGIN SEQUENCE 构造：
        <code language="X#">
          BEGIN SEQUENCE
          &#0009;...
          &#0009;RegisterKid(...)
          END SEQUENCE
          UnregisterKid(...)
        </code>
      </note>
    </remarks>
    <example>
      此示例使用 RegisterKid() 来保留可能被垃圾收集器清除的数据：
      <code language="X#">
        STRUCTURE strucMyStrings
        &#0009;MEMBER DIM aStr[10] AS PTR
        Function Start()
        &#0009;LOCAL wI AS DWORD
        &#0009;LOCAL strucMyArray AS strucMyStrings
        &#0009;strucMyArray :=;
        &#0009;&#0009; MemCAlloc(_SizeOf(strucMyStrings), 1)
        &#0009;RegisterKid(strucMyArray, 10, FALSE)
        &#0009;FOR wI := 1 UPTO 10
        &#0009;&#0009;strucMyArray.aStr[wI] := Ptr(_CAST, Str(wI))
        &#0009;NEXT
        &#0009;CollectForced()&#0009;&#0009;// 强制进行垃圾收集
        &#0009;UnregisterKid(strucMyArray)
        &#0009;// 收集完成。取消注册对象。
        &#0009;// 对象在收集后得以存活。
        &#0009;FOR wI := 1 UPTO 10
        &#0009;&#0009;MessageBox(0, strucMyArray.aStr[wI], Psz(wI), 0)
        &#0009;NEXT
        &#0009;MemFree(strucMyArray)
        &#0009;// 完成后不要忘记释放分配的内存
      </code>
      下面是一个使用 BEGIN SEQUENCE 的示例：
      <code language="X#">
        STRUCT StrucMyStrings
        &#0009;MEMBER DIM aStr[10] AS PTR
        FUNCTION Start()
        LOCAL I AS DWORD
        LOCAL strucMyArray AS StrucMyStrings
        BEGIN SEQUENCE
        strucMyArray := MemCAlloc(_SizeOf(StrucMyStrings),1)
        &#0009;RegisterKid(strucMyArray, 10, FALSE)
        &#0009;FOR I := 1 UPTO 10
        &#0009;&#0009;strucMyArray.aStr[I] :=STR(I)
        &#0009;NEXT
        &#0009;Collect()&#0009;&#0009;// 压力测试...
        END SEQUENCE
        UnregisterKid(strucMyArray)
        FOR I := 1 UPTO 10 &#0009;// 我们存活了吗？
        &#0009;MessageBox(0, strucMyArray.aStr[I], Psz(I), 0)
        NEXT
        MemFree(strucMyArray)
        // 完成后不要忘记释放分配的内存
      </code>
    </example>
    <seealsocmd>_DynCheck</seealsocmd>
    <seealso cref='O:XSharp.VO.Functions.DynCheckError'>DynCheckError</seealso>
    <seealso cref='O:XSharp.VO.Functions.Memory'>Memory</seealso>
    <seealso cref='O:XSharp.RT.Functions.RegisterAxit'>RegisterAxit</seealso>
    <seealso cref='O:XSharp.VO.Functions.UnRegisterKid'>UnregisterKid</seealso>
  </registerkid>

  <registeroleautomation>
    <summary>
      注册 X# 对象作为活动自动化服务器对象。
    </summary>
    <param name="oObject">实现自动化服务器的对象。</param>
    <param name="cProgID">
      自动化服务器的程序 ID。<br/>
      程序 ID 是唯一标识自动化服务器的字符串。默认为 NULL_STRING。
    </param>
    <param name="iResID">
      自动化服务器类型库的资源 ID。<br/>
      默认值为 1。
    </param>
    <param name="lASP">
      一个标志，指定自动化服务器是否用作 ASP 组件。<br/>
      默认值为 FALSE。
    </param>
    <returns>
      唯一标识自动化服务器的句柄（指针）。
    </returns>
    <remarks>
      RegisterOLEAutomationObject() 将任何 X# 对象注册为当前自动化服务器。<br/>
      这意味着服务器的所有方法、访问和分配都通过 OLE 自动化暴露。
      注意：<br/>
      如果您使用 AutoServer 基类或 GUI 类中的 Automated 属性，则不必显式调用此函数。
      有关详细信息，请参阅在线帮助中的“如何创建 OLE 服务器”部分。
    </remarks>
    <example>
    </example>
    <seealsocmd>CLASS AutoServer</seealsocmd>
    <seealsocmd>UnRegisterOLEAutomationObject</seealsocmd>
    <seealsocmd>Window:Automated</seealsocmd>
  </registeroleautomation>

  <replicate>
    <summary>
      重复一个字符串指定的次数。
    </summary>
    <param name="cString">要重复的字符串。</param>
    <param name="dwCount">
      重复 <paramref name="cString" /> 的次数，最大值为 MAX_ALLOC。指定值为零将返回一个 NULL_STRING。
    </param>
    <returns>
    </returns>
    <remarks>
      Replicate() 多次显示、打印或输入一个或多个字符。Replicate() 类似于 Space() 函数，后者返回指定数量的空格字符。
    </remarks>
    <example>
      这些示例演示了 Replicate() 重复字符串的用法：
      <code language="X#">
        ? Replicate("*", 5)&#0009;&#0009;&#0009;&#0009;&#0009;// *****
        ? Replicate("Hi ", 2)&#0009;&#0009;&#0009;&#0009;// Hi Hi
        ? Replicate(_Chr(42), 5)&#0009;&#0009;&#0009;&#0009;// *****
      </code>
      该示例使用 Replicate() 输入多个向下箭头键：
      <code language="X#">Keyboard(Replicate(_Chr(K_DN), 5))</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Space'>Space</seealso>
  </replicate>

  <rgb>
    <summary>
      获取特定的 Windows 颜色。
    </summary>
    <param name="bRed">颜色中的红色量，范围从 0 到 255。</param>
    <param name="bGreen">颜色中的绿色量，范围从 0 到 255。</param>
    <param name="bBlue">颜色中的蓝色量，范围从 0 到 255。</param>
    <returns>
      Windows 用于标识所描述颜色的数字。
    </returns>
    <remarks>
      如果所有三个参数均指定为 0，则颜色为黑色。<br/>
      如果所有三个参数均指定为 255，则颜色为白色。
    </remarks>
    <example>
      以下示例识别一种主要为红色和绿色、并含有少量蓝色的颜色：
      <code language="X#">RGB(225,225,50)</code>
      此示例列出常用颜色的 RGB 值：
      <code language="X#">
        ? "红", RGB(255, 0, 0)
        ? "绿", RGB(0, 255, 0)
        ? "蓝", RGB(0, 0, 255)
        ? "黄", RGB(255, 255, 0)
        ? "品红", RGB(255, 0, 255)
        ? "青色", RGB(0, 255, 255)
        ? "黑", RGB(0, 0, 0)
        ? "灰", RGB(128, 128, 128)
        ? "棕", RGB(128, 128, 0)
        ? "紫", RGB(128, 0, 128)
        ? "水蓝", RGB(0, 128, 128)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.PaletteRGB'>PaletteRGB</seealso>
  </rgb>

  <right>
    <summary>
      返回从右侧开始的子字符串。
    </summary>
    <param name="cString">要提取字符的字符串。</param>
    <param name="dwCount">要提取的字符数。</param>
    <returns>
      <paramref name="cString" /> 的右侧 <paramref name="dwCount" /> 个字符。<br/>
      如果 <paramref name="dwCount" /> 为 0，Right() 返回一个 NULL_STRING。<br/>
      不允许负值，因为 WORD 不能为负。<br/>
      如果 <paramref name="dwCount" /> 大于字符串的长度，Right() 返回 <paramref name="cString" />。
    </returns>
    <remarks>
      Right() 与 Substr(<paramref name="cString" />, -<paramref name="wCount" />) 相同。<br/>
      例如，Right("ABC", 1) 与 Substr("ABC", -1) 相同。Right() 与 Left() 相关，它从 <paramref name="cString" /> 的左侧提取子字符串。
      Right()、Left() 和 Substr() 函数通常与 At() 和 RAt() 函数一起使用，以定位子字符串的第一个/最后一个位置，然后提取它。
    </remarks>
    <example>
      此示例展示了 Right() 和 Substr() 之间的关系：
      <code language="X#">
        ? Right("ABCDEF", 3)&#0009;&#0009;&#0009;&#0009;// DEF
        ? Substr("ABCDEF", 3)&#0009;&#0009;&#0009;&#0009;// CDEF
        ? Substr("ABCDEF", -3)&#0009;&#0009;&#0009;&#0009;// DEF
      </code>
      此示例从另一个字符串的末尾提取子字符串，直到最后一个逗号：
      <code language="X#">
        LOCAL cName AS STRING
        cName := "James, William"
        ? Right(cName, SLen(cName) - RAt(",", cName) -1)&#0009;// William
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.Stuff'>Stuff</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </right>

  <rlock>
    <summary>
      锁定当前记录。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaOperation/*" />
    </param>
    <param name="cRecordNumberList">
      指定 RLOCK( ) 尝试锁定多个记录。
      字符表达式 cRecordNumberList 指定一个或多个记录编号，用逗号分隔，RLOCK( ) 尝试锁定。
      例如，要尝试锁定表中的前四条记录，cRecordNumberList 应包含 1, 2, 3, 4。
    </param>
    <returns>
      如果成功获得记录锁，则返回 TRUE；否则返回 FALSE。<br/>
      如果尝试锁定多个记录且其中之一失败，则成功的锁将被释放。<br/>
      在空数据库中尝试锁定记录返回 TRUE。
    </returns>
    <remarks>
      如果数据库文件以共享模式打开，则在执行任何写入数据库文件的操作之前，必须获得记录锁。
      对于 RLock() 的每次调用，都会尝试锁定目标记录，并返回结果作为逻辑值。<br/>
      如果另一个进程当前对目标记录拥有文件锁或记录锁，则获取记录锁的尝试将失败。
      如果 RLock() 成功，记录将被锁定，其他进程将在锁释放之前无法更新该记录。
      RLock() 提供共享锁，允许其他用户对锁定记录进行只读访问，同时仅允许当前进程进行修改。
      记录锁在您显式解锁（例如使用 DBUnLock()）、关闭数据库文件或尝试另一个文件或记录锁（使用 RLock() 或 DBRLock() 而不带参数）之前保持有效。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
      该功能很有用，因为 RLock() 不会自动尝试锁定相关文件。
    </remarks>
    <example>
      此示例使用 RLock() 删除共享数据库文件中的一条记录：
      <code language="X#">
        USE customer INDEX custname SHARED NEW
        SEEK "Smith"
        IF Customer-&gt;Found()
        &#0009;IF Customer-&gt;RLock()
        &#0009;&#0009;Customer-&gt;DBDelete()
        &#0009;&#0009;QOut("Smith 已删除")
        &#0009;ELSE
        &#0009;&#0009;QOut("记录正在被其他人使用")
        &#0009;ENDIF
        ELSE
        &#0009;QOut("Smith 不在客户文件中")
        ENDIF
        CLOSE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLock'>DBUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUseArea'>DBUseArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.Flock'>FLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetExclusive'>SetExclusive</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRlock'>VODBRLock</seealso>
  </rlock>

  <round>
    <summary>
      将数字四舍五入到指定的位数。
    </summary>
    <param name="nNumber">要四舍五入的数字。</param>
    <param name="siDecimals">
      要保留的小数位数。对于 <paramref name="siDecimals" /> 指定 0 或负值将四舍五入到整数。<br/>
      负的 <paramref name="siDecimals" /> 还指示要向小数点左侧四舍五入的位数（见示例）。
    </param>
    <returns>
    </returns>
    <remarks>
      小于 5 的数字向下舍入。5 到 9 的数字向上舍入。
      返回值的显示不遵循小数设置，除非 SetFixed() 为 TRUE。<br/>
      如果 SetFixed() 为 FALSE，返回值的显示包含 <paramref name="siDecimals" /> 位小数（如果 <paramref name="siDecimals" /> 大于 0），如果 <paramref name="siDecimals" /> 小于或等于 0 则显示零位小数。
    </remarks>
    <example>
      这些示例演示了用小数位数四舍五入值：
      <code language="X#">
        SetDecimal(2)
        SetFixed(TRUE)
        ? Round(10.4, 0)&#0009;&#0009;&#0009;&#0009;&#0009;// 10
        ? Round(10.5, 0)&#0009;&#0009;&#0009;&#0009;&#0009;// 11
        ? Round(10.51, 0)&#0009;&#0009;&#0009;&#0009;&#0009;// 11
        ? Round(10.49999999999999, 2)&#0009;&#0009;&#0009;// 10.50
      </code>
      这些示例使用负的 <paramref name="siDecimals" /> 参数将数字值四舍五入到整数：
      <code language="X#">
        ? Round(101.99, -1)&#0009;&#0009;&#0009;&#0009;&#0009;// 100
        ? Round(109.99, -1)&#0009;&#0009;&#0009;&#0009;&#0009;// 110
        ? Round(109.99, -2)&#0009;&#0009;&#0009;&#0009;&#0009;// 100
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Integer'>Integer</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetFixed'>SetFixed</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Val'>Val</seealso>
  </round>

  <row>
    <summary>
      返回终端窗口中光标的屏幕行位置。
    </summary>
    <returns>
      光标的行位置。<br/>
      返回值的范围为 0 到 MaxRow()。
    </returns>
    <remarks>
      Row() 是一个屏幕函数，返回屏幕光标的当前行或线位置。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Col'>Col</seealso>
  </row>

  <rtrim>
    <summary>
      删除字符串末尾的空格。
    </summary>
    <param name="cString">要修剪的字符串。</param>
    <returns>
      <paramref name="cString" /> 删除后缀空格的结果。<br/>
      如果 <paramref name="cString" /> 是 NULL_STRING 或全为空格，RTrim() 返回 NULL_STRING。
    </returns>
    <remarks>
      RTrim() 与 Trim() 相同。有关详细信息，请参阅 Trim()。
    </remarks>
    <example>
      这是一个使用 RTrim() 格式化城市、州和邮政编码字段以用于标签或表单信的函数：
      <code language="X#">
        FUNCTION CityState(cCity, cState, cZip)
        &#0009;RETURN RTrim(cCity) + ", " ;
        &#0009;&#0009;&#0009;+ RTrim(cState) + "  " + cZip
      </code>
      为了完成示例，函数 CityState() 从 CUSTOMER.DBF 显示记录：
      <code language="X#">
        USE customer INDEX custname NEW
        SEEK "Kate"
        ? CityState(City, State, ZipCode)&#0009;// Athens, GA 10066
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AllTrim'>AllTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
    <seealso cref='O:XSharp.Core.Functions.Trim'>Trim</seealso>
  </rtrim>

  <sbtodb>
    <summary>
      将单字节假名字符转换为其双字节等效字符的字符串。
    </summary>
    <param name="cMBTarget">要转换的字符串。</param>
    <returns>
      <paramref name="cMBTarget" /> 的转换结果。
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.DBToSB'>DBToSB</seealso>
  </sbtodb>

  <sclone>
    <summary>
      创建与原始字符串相同字符的新字符变量。
    </summary>
    <param name="cString">要克隆的字符串。</param>
    <returns>
      相同字符串，但与原始字符串具有不同的地址。<br/>
      新字符串是动态分配的。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 SClone() 展示如何克隆字符串：
      <code language="X#">
        LOCAL cString1 AS STRING
        LOCAL cString2 AS STRING
        cString1 := "Hello"
        cString2 := SClone(cString1)
        ? cString1 == cString2&#0009;&#0009;// TRUE
        cString1 := "World"
        ? cString1 == cString2&#0009;&#0009;// FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.StringAlloc'>StringAlloc</seealso>
  </sclone>

  <seconds>
    <summary>
      返回自午夜以来经过的秒数。
    </summary>
    <returns>
      自午夜以来经过的秒数，以 seconds.hundredths 形式表示。数字范围为 0 到 86,399。
    </returns>
    <remarks>
      Seconds() 提供了一种简单的方法来计算程序执行期间的经过时间，基于系统时钟。<br/>
      它与 Time() 函数相关，后者返回以 hh:mO:ss 形式表示的系统时间。<br/>
      最小分辨率取决于硬件定时器的滴答声。
    </remarks>
    <example>
      此示例对比 Time() 与 Seconds() 的值：
      <code language="X#">
        ? Time()&#0009;&#0009;&#0009;&#0009;&#0009;// 10:00:00
        ? Seconds()&#0009;&#0009;&#0009;&#0009;&#0009;// 36000.00
      </code>
      此示例使用 Seconds() 跟踪经过的时间（秒）：
      <code language="X#">
        LOCAL nStart, nElapsed AS FLOAT
        nStart := Seconds()
        .
        . <paramref name="Statements" />
        .
        nElapsed := Seconds() - nStart
        ? "经过的时间: " + NTrim(nElapsed) + " 秒"
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ElapTime'>ElapTime</seealso>
    <seealso cref='O:XSharp.RT.Functions.GetTickCountLow'>GetTickCountLow</seealso>
    <seealso cref='O:XSharp.Core.Functions.Secs'>Secs</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
  </seconds>

  <secs>
    <summary>
      返回自午夜以来经过的秒数。
    </summary>
    <param name="cTime">要转换为秒的时间，以 hh:mO:ss 形式表示。</param>
    <returns>
      从午夜到指定时间的秒数。<br/>
      返回值不能大于 86,400，即一天中的秒数。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例显示自午夜以来经过的秒数：
      <code language="X#">? Secs(Time())</code>
      此示例指定超过 24 小时的时间：
      <code language="X#">? Secs("25:05:09")&#0009;&#0009;&#0009;// 90309</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.TString'>TString</seealso>
  </secs>

  <select>
    <summary>
      确定工作区的编号。
    </summary>
    <param name="uWorkArea">
      标识工作区的值。<br/>
      这可以是工作区的编号或其别名，可以用符号或字符串指定。<br/>
      如果未指定 <paramref name="uWorkArea" />，则返回当前工作区编号。<br/>
      因此，Select() 与 DBGetSelect() 相同。
    </param>
    <returns>
      从 0 到 4096 的数字。如果 <paramref name="uWorkArea" /> 没有标识有效的工作区或不对应有效的别名，则返回 0。
    </returns>
    <remarks>
      Select() 函数和与扩展表达式参数一起指定的 SELECT 命令看起来有些相似。
    </remarks>
    <example>
      此示例展示了 Select() 如何接受不同的参数：
      <code language="X#">
        USE sales NEW
        USE customer NEW
        QOut(Select())&#0009;&#0009;&#0009;&#0009;// 结果: 2
        QOut(Select(#sales))&#0009;&#0009;// 结果: 1
        QOut(Select("customer"))&#0009;&#0009;// 结果: 2
        QOut(Select("sales"))&#0009;&#0009;// 结果: 1
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias'>Alias</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGetSelect'>DBGetSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetSelect'>DBSetSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>SELECT</seealso>
    <seealso cref='O:XSharp.RT.Functions.Used'>Used</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbGetSelect'>VoDbGetSelect</seealso>
  </select>

  <send>
    <summary>
      调用一个方法。
    </summary>
    <param name="oObject">要调用其方法的对象。</param>
    <param name="symMethod">方法名称，不带括号。</param>
    <param name="MethodArgList">
      传递给 <paramref name="symMethod" /> 的参数列表，以逗号分隔。
    </param>
    <returns>
      方法的返回值。
    </returns>
    <remarks>
      Send() 允许您通过函数调用发送一个方法。
    </remarks>
    <example>
      此示例使用 Send() 调用一个名为 Horn() 的方法，该方法期望两个参数：
      <code language="X#">
        CLASS Automobile
        &#0009;EXPORT model
        CONSTRUCTOR(tmodel) CLASS Automobile
        &#0009;model := tmodel
        METHOD Horn(nSound, cSay) CLASS Automobile
        &#0009;Tone(nSound, 2)
        &#0009;QOut(cSay)
        FUNCTION Start()
        &#0009;LOCAL x AS OBJECT
        &#0009;x := Automobile{"Car"}
        &#0009;// x:Horn(100, "Hello!")
        &#0009;Send(x, #Horn, 100, "Hello!")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ASend'>ASend</seealso>
    <seealso cref='O:XSharp.RT.Functions.NoMethod'>NoMethod</seealso>
  </send>

  <setamext>
    <summary>
      设置12小时格式时间字符串的上午扩展。
    </summary>
    <param name="cAMExt">
      用于上午时间字符串的扩展。<br/>
      此字符串最多可包含八个字符 - 额外的字符将被忽略。<br/>
      初始默认值依赖于 SetInternational()，您可以参考更多信息。
    </param>
    <returns>
    </returns>
    <remarks>
      使用12小时格式的时间字符串有一个扩展来指定时间是上午还是下午。 SetAMExt() 允许您程序化地设置标识上午时间字符串的扩展（即在午夜12:00到中午12:00之间的时间）。<br/>
      上午时间字符串的典型扩展是 "AM"，这也是该函数名称的由来。
      上午扩展的初始默认值受 SetInternational() 的影响，您可以参考更多信息。<br/>
      使用 GetAMExt() 来检索当前值。
    </remarks>
    <example>
      此示例打开12小时制时间格式并使用两种不同的扩展显示时间字符串：
      <code language="X#">
        SetAMPM(TRUE)
        SetAMExt(" am")
        ? TString(3800)&#0009;// 01:03:20 am
        SetAMExt(" morning")
        ? TString(3800)&#0009;// 01:03:20 morning
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetAMExt'>GetAMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAmPm'>SetAMPM</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPMExt'>SetPMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
    <seealso cref='O:XSharp.RT.Functions.TString'>TString</seealso>
  </setamext>

  <setampm>
    <summary>
      返回并可选择更改时间字符串是12小时格式还是24小时格式的设置。
    </summary>
    <param name="lNewSetting">
      TRUE 表示12小时格式。 FALSE 表示24小时格式。<br/>
      初始默认值依赖于 SetInternational()，您可以参考更多信息。
    </param>
    <returns>
      如果未指定 <paramref name="lNewSetting" />，则 SetAMPM() 返回当前设置。<br/>
      如果指定了 <paramref name="lNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例显示12小时和24小时显示格式之间的差异：
      <code language="X#">
        SetPMExt(" pm")
        SetAMPM(FALSE)
        ? TIME()&#0009;&#0009;// 结果: 13:10:15 pm
        SetAMPM(TRUE)
        ? TIME()&#0009;&#0009;// 结果: 01:10:15 pm
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetAMExt'>SetAMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPMExt'>SetPMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
  </setampm>

  <setansi>
    <summary>
      返回并可选择更改设置，以确定数据库文件是使用ANSI格式还是OEM格式创建，以及某些文本文件操作是否在这两种字符集之间转换。
    </summary>
    <param name="lNewSetting">
      TRUE表示ANSI格式；FALSE表示OEM格式。<br/>
      如果WIN.INI的X#部分中不存在Ansi条目，将写入Ansi=1，初始默认值设置为TRUE；如果该条目设置为0，则初始默认值为FALSE。
    </param>
    <returns>
      如果未指定<paramref name="lNewSetting" />，SetAnsi()返回当前设置。<br/>
      如果指定了<paramref name="lNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      SetAnsi()是一个双重目的函数。
      <br/>
      首先，它确定用于创建新数据库文件的格式—ANSI，使用Windows字符集，或OEM，使用ASCII字符集。因此，像DBCreate()和DBCopyStruct()这样的函数受此设置的影响。<br/>
      决定数据库文件ANSI/OEM格式的信息存储在文件的头记录中。
      重要提示！<br/>
      如果您的应用程序必须与基于DOS的产品共享数据，无论是同时还是不同时间，都必须在创建.DBF文件时使用OEM格式。
      如果SetAnsi()为TRUE，您的X#应用程序将在处理为OEM格式的现有数据库文件时自动进行ANSI和OEM之间的转换，从而保留数据的格式并允许其被不支持ANSI格式的其他应用程序使用。
      如果SetAnsi()为FALSE，则在读取或写入任何数据库文件时不会执行自动转换。在这种情况下，数据将在运行时显示为从磁盘读取的内容。<br/>
      对于OEM数据库，因此，程序员完全负责显示数据或通过任何编辑控制或终端功能修改的数据的ANSI/OEM转换。您可以使用Ansi2Oem()和Oem2Ansi()函数在这两种格式之间转换数据。
      <br/>
      SetAnsi()的第二个目的控制读取和写入文本文件的函数如何处理这两种不同的字符集。当SetAnsi()为FALSE时，从文本文件读取（FReadText()和MemoRead()）和写入文本文件（FWriteText()和MemoWrit()）的函数会自动在ANSI和OEM之间转换。当SetAnsi()为TRUE时，这些函数不进行转换。
      不管SetAnsi()如何，使用FRead()、FWrite()和相关函数读取或写入的所有数据都不会转换为OEM字符集。
    </remarks>
    <example>
      此示例在应用程序开始时存储SetAnsi()设置，并在结束时恢复到其原始设置：
      <code language="X#">
        METHOD Start() CLASS App
        &#0009;LOCAL lAnsiSetting AS LOGIC
        &#0009;lAnsiSetting := SetAnsi(FALSE)
        &#0009;...
        &#0009;SetAnsi(lAnsiSetting)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Ansi2Oem'>Ansi2Oem</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCopy'>DBCopy</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCopyStruct'>DBCopyStruct</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCopyXStruct'>DBCopyXStruct</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreate'>DBCreate</seealso>
    <seealso cref='O:XSharp.RT.Functions.FRead'>FRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.FReadText'>FReadText</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWriteText'>FWriteText</seealso>
    <seealso cref='O:XSharp.Core.Functions.MemoRead'>MemoRead</seealso>
    <seealso cref='O:XSharp.Core.Functions.MemoWrit'>MemoWrit</seealso>
    <seealso cref='O:XSharp.Core.Functions.Oem2Ansi'>Oem2Ansi</seealso>
  </setansi>

  <setapplocaleid>
    <summary>
      设置运行时在Windows排序模式下比较字符串时使用的区域设置（SetCollation(#Windows)）。
    </summary>
    <param name="uiNewLocale">必须是有效的LocaleId，可以使用MAKELCID()和MAKELANGID()函数构造。</param>
    <returns>
      之前安装的区域。
    </returns>
    <remarks>
      此函数设置运行时在Windows排序模式（SetCollation(#Windows)）下比较字符串时使用的区域，这是X#的默认模式。字符串比较负责DBF文件的排序、比较字符串（包括排序字符串数组）以及索引内的排序顺序。运行时的默认行为是通过调用GetUserDefaultLCID()函数从当前用户读取区域ID。为了避免不同用户在其计算机上选择不同区域时出现问题，您现在可以从代码中控制应用程序使用的区域。
    </remarks>
    <example>
      // 使用标准德语在电话簿排序模式下：
      <br/>
      <br/>
      // 在默认排序模式下使用瑞士德语
      <br/>
      &#0009;
      // 使用挪威博克马尔语，默认排序模式
      <br/>
      &#0009;
      // 使用语言独立排序
      <br/>
      &#0009;
    </example>
    <seealso cref='O:XSharp.VO.Functions.GetAppLocaleID'>GetAppLocaleId</seealso>
  </setapplocaleid>

  <setbeep>
    <summary>
      返回并可选择更改错误系统发生错误时是否发出蜂鸣声的设置。
    </summary>
    <param name="lNewSetting">
      TRUE表示开启蜂鸣；FALSE表示关闭蜂鸣。<br/>
      如果WIN.INI的Windows部分中不存在Beep条目或该条目设置为yes，则初始默认值为TRUE；如果该条目设置为no，则初始默认值为FALSE。
    </param>
    <returns>
      如果未指定<paramref name="lNewSetting" />，SetBeep()返回当前设置。<br/>
      如果指定了<paramref name="lNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例在开启时关闭错误蜂鸣：
      <code language="X#">
        IF SetBeep()
        &#0009;MessageBeep(MB_OK)
        &#0009;SetBeep(FALSE)
        &#0009;? "从现在开始，不再有错误蜂鸣！"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Tone'>Tone</seealso>
  </setbeep>

  <setcentury>
    <summary>
      返回并可选择更改设置，以确定在日期格式中是否包含或省略世纪数字。
    </summary>
    <param name="lNewSetting">
      TRUE 包含世纪数字，意味着日期格式包含四位数字的年份，可以包括19xx以外的世纪。 FALSE 省略世纪数字，意味着日期格式仅包含两位数字的年份。<br/>
      这意味着世纪数字的日期不会显示且无法输入。<br/>
      初始默认值为 TRUE。
    </param>
    <returns>
      如果未指定 <paramref name="lNewSetting" />，SetCentury() 返回当前设置。<br/>
      如果指定了 <paramref name="lNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      SetCentury() 修改当前日期格式，格式由 SetDateFormat() 设置。请注意，只有日期的显示和输入格式受到影响；日期计算在任何情况下都保留世纪信息。
    </remarks>
    <example>
      此示例展示了简单 SetCentury 函数的结果：
      <code language="X#">
        SetCentury(FALSE)
        ? TODAY()&#0009;&#0009;&#0009;&#0009;&#0009;// 06/15/93
        SetCentury(TRUE)
        ? TODAY()&#0009;&#0009;&#0009;&#0009;&#0009;// 06/15/1993
      </code>
    </example>
  </setcentury>

  <setcollation>
    <summary>
      返回并可选择更改设置，以确定用于字符串比较的内部排序例程。
    </summary>
    <param name="symNewSetting">
      要使用的排序模式。<br/>
      可用的模式有 #Windows（默认）和 #Clipper。
    </param>
    <returns>
      如果未指定 <paramref name="symNewSetting" />，SetCollation() 返回当前设置。<br/>
      如果指定了 <paramref name="symNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      SetCollation() 设置用于所有字符串比较的内部排序例程，除了使用 == 运算符的比较。请注意，这包括排序和索引操作，以及使用各种运算符的程序化字符串比较。
      注意：更改 SetInternational() 会自动更改 SetCollation()，以使这两个设置相同。
      此设置允许 X# 在不同的排序模式下操作。<br/>
      #Clipper 模式提供了与 CA-Clipper 应用程序的兼容性，并使用在国家模块（VO28NAT.DLL）中定义的排序例程。<br/>
      #Windows 模式使用 Windows 提供的字符串比较服务，自动处理外文字符集。
      因此，如果应用程序使用 #Clipper 排序模式，它将在所有机器上表现相同。因此，要实现基于英语以外语言的不同排序序列，您将需要一个针对所需语言的专用 VO28NAT.DLL 版本。另一方面，如果应用程序使用 #Windows 排序模式，它将根据控制面板中的国际设置定义的语言，在不同的机器上表现不同。在这种情况下，Windows 支持的所有语言也将受到您的应用程序的支持，包括从右到左的语言，如希伯来语和阿拉伯语，以及双字节语言，如中文、日文和韩文。
      注意：操作在字节级别的字符串函数（如 Substr() 和 SLen()）在处理双字节字符时将无法正常工作。
      常规拉丁字符集的排序序列在 #Clipper 和 #Windows 之间是不同的。<br/>
      对于 #Clipper:
      A &lt; B &lt; C &lt; ... &lt; Z &lt; a &lt; b &lt; c &lt; ... &lt; z
      对于 #Windows:
      A &lt; a &lt; B &lt; b &lt; C &lt; c &lt; ... &lt; Z &lt; z
      警告！ SetCollation() 决定了索引文件及其内部顺序的创建和维护方式。<br/>
      在同一顺序中尝试使用不同的排序模式将会损坏该顺序。
    </remarks>
    <example>
      此示例基于标准应用程序的 Start() 方法，检查当前 Windows 语言配置，仅在设置为使用法语排序时允许应用程序运行：
      <code language="X#">
        METHOD Start() CLASS App
        &#0009;LOCAL oWindow AS Window
        &#0009;LOCAL nLen, nBufSize := 10 AS SHORTINT
        &#0009;LOCAL pszLang := Psz(Space(nBufSize)) AS PSZ
        &#0009;// 初始化 StandardShellWindow
        &#0009;Enable3DControls()
        &#0009;oWindow := StandardShellWindow{SELF}
        &#0009;oWindow:Show()
        &#0009;// 从 WIN.INI 检索语言排序设置
        &#0009;nLen := GetProfileString("intl", "sLanguage",&#0009;;
        &#0009;&#0009;"", pszLang, nBufSize)
      </code>
      &#0009;
      <code language="X#">
        &#0009;// 仅在系统配置为使用
        &#0009;// 法语 Windows 排序时运行应用程序
        &#0009;IF (Left(String(_CAST, pszLang), nLen) != "fra")
        &#0009;&#0009;// 语言不正确，给出错误并退出。
        &#0009;&#0009;TextBox{oWindow, "系统配置",&#0009;;
        &#0009;&#0009;&#0009;"要运行此应用程序，您必须在控制面板的国际部分将语言设置为 " +&#0009;;
        &#0009;&#0009;&#0009;"'法语'。"}:Show()
        &#0009;ELSE
        &#0009;&#0009;// 运行应用程序
        &#0009;&#0009;SELF:Exec()
        &#0009;ENDIF
      </code>
    </example>
    <seealsocmd>SET COLLATION</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
  </setcollation>

  <setcolor>
    <summary>
      返回并可选择更改当前终端窗口的颜色设置。
    </summary>
    <param name="cNewSetting">
      在后续屏幕绘制中使用的颜色。<br/>
      <br/>
      &#0009;颜色必须作为前景和背景颜色对指定，用斜杠（/）字符分隔：<br/>
      &#0009;前景定义了在屏幕上显示的字符的颜色。<br/>
      &#0009;背景定义了字符后面显示的颜色。空格和不可显示字符显示为背景。<br/>
      &#0009;在为特定区域指定前景颜色时，您还可以使用加号（+）或星号（*）指定高亮度。<br/>
      &#0009;颜色可以使用以下表中的字母指定。例如，您可以指定 W+/N。
    </param>
    <param name="Letter">颜色</param>
    <param name="B">蓝色</param>
    <param name="B+">亮蓝色</param>
    <param name="BG">青色</param>
    <param name="BG+">亮青色</param>
    <param name="G">绿色</param>
    <param name="G+">亮绿色</param>
    <param name="GR">棕色</param>
    <param name="GR+">黄色</param>
    <param name="N">黑色</param>
    <param name="N+">灰色</param>
    <param name="R">红色</param>
    <param name="R+">亮红色</param>
    <param name="RB">洋红色</param>
    <param name="RB+">亮洋红色</param>
    <param name="W">白色</param>
    <param name="W+">亮白色</param>
    <returns>
      如果未指定 <paramref name="cNewSetting" />，SetColor() 返回当前颜色设置。<br/>
      如果指定了 <paramref name="cNewSetting" />，则返回先前的颜色设置。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例将当前颜色设置分配给变量 <paramref name="cColor" />：
      <code language="X#">
        LOCAL cColor AS STRING
        cColor := SetColor()
      </code>
      此示例使用 SetColor() 设置新的颜色设置并保存当前设置：
      <code language="X#">
        cNewColor := "RB+/N"
        cOldColor := SetColor(cNewColor)
      </code>
    </example>
  </setcolor>

  <setcpu>
    <summary>
      返回并可选地更改确定您拥有的中央处理器类型的设置。
    </summary>
    <param name="nNewSetting">
      一个值，例如 386 或 486，用于新的设置。<br/>
      初始默认值是您中央处理器的数字标识符。
    </param>
    <returns>
      如果未指定 <paramref name="lNewSetting" />，SetCPU() 返回当前设置。<br/>
      如果指定了 <paramref name="lNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      SetCPU() 是一個相容性函數。它在 X# 中並沒有真正做任何事情。
    </remarks>

    <seealso cref='O:XSharp.Core.Functions.SetMath'>SetMath</seealso>
  </setcpu>

  <setdatecountry>
    <summary>
      返回并可选地更改确定 X# 日期格式的设置，通过从常量列表中选择对应的日期格式。
    </summary>
    <param name="dwNewSetting">以下常量之一，初始化相应的日期格式（年份值的字符数由 SetCentury() 控制）：</param>
    <list type="table">
      <listheader>
        <term>常量</term>
        <description>日期格式</description>
      </listheader>
      <item>
        <term>
          AMERICAN
        </term>
        <description>mm/dd/yy 或 mm/dd/yyyy</description>
      </item>
      <item>
        <term>ANSI</term>
        <description>yy.mm.dd 或 yyyy.mm.dd</description>
      </item>
      <item>
        <term>BRITISH</term>
        <description>dd/mm/yy 或 dd/mm/yyyy</description>
      </item>
      <item>
        <term>FRENCH</term>
        <description>dd/mm/yy 或 dd/mm/yyyy</description>
      </item>
      <item>
        <term>GERMAN</term>
        <description>dd.mm.yy 或 dd.mm.yyyy</description>
      </item>
      <item>
        <term>ITALIAN</term>
        <description>dd-mm-yy 或 dd-mm-yyyy</description>
      </item>
      <item>
        <term>JAPANESE</term>
        <description>yy/mm/dd 或 yyyy/mm/dd</description>
      </item>
      <item>
        <term>USA</term>
        <description>mm-dd-yy 或 mm-dd-yyyy</description>
      </item>
    </list>
    <returns>
      如果未指定 <paramref name="dwNewSetting" />，SetDateCountry() 返回上述之一的数字值，表示当前日期和国家设置。<br/>
      如果指定了 <paramref name="dwNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 SetDateCountry() 以所有 16 种格式显示今天的日期：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL I AS INT
        &#0009;SetDateCountry(2)
        &#0009;SetCentury(FALSE)
        &#0009;? DTOC(TODAY())
        &#0009;? DTOC(92.12.31)
        &#0009;? DTOC(1992.12.31)
        &#0009;FOR I := 1 UPTO 8
        &#0009;&#0009;SetDateCountry(I)
        &#0009;&#0009;? I, DTOC(TODAY()), "!" + DTOC(0) + "!"
        &#0009;NEXT
        &#0009;?
        &#0009;SetCentury(TRUE)
        &#0009;FOR I := 1 UPTO 8
        &#0009;&#0009;SetDateCountry(I)
        &#0009;&#0009;? I, DTOC(TODAY()), "!" + DTOC(0) + "!"
        &#0009;NEXT
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CToD'>CToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToC'>DToC</seealso>
    <seealsocmd>SET DATE</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetDateFormat'>SetDateFormat</seealso>
  </setdatecountry>

  <setdateformat>
    <summary>
      更改确定 X# 日期格式的设置。
    </summary>
    <param name="cNewSetting">
      要设置的新日期格式，字符串长度不超过 37 个字符。<br/>
      日期格式可以用多种方式指定，但必须包含一个或多个 D、M 和 Y 字母（分别）。<br/>
      例如：
    </param>
    <returns>
      如果参数与当前设置相同，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      SetDateFormat() 分析由 <paramref name="cNewSetting" /> 指定的新格式，并根据找到的 D、M 和 Y 字母确定日期、月份和年份的适当位置和数字。
      SetDateFormat() 是一个全局设置，影响程序中日期的行为，允许您以便于将应用程序移植到外国的方式控制日期格式。
    </remarks>
    <example>
      此示例使用 SetDateFormat() 设置日期格式：
      <code language="X#">
        FUNCTION T()
        &#0009;LOCAL x AS STRING
        &#0009;? GetDateFormat()
        &#0009;x:="DD-ABC-YYYY-123-MM"
        &#0009;? x
        &#0009;SetDateFormat(x)
        &#0009;? GetDateFormat()
        &#0009;? TODAY()
        &#0009;? 00.00.00
        &#0009;? CTOD("31.1992.12")
        &#0009;? CTOD(NULL_STRING)
        &#0009;SetCentury(FALSE)
        &#0009;? GetDateFormat()
      </code>
      此示例说明了 SetDateFormat() 如何忽略或包含世纪数字：
      <code language="X#">
        SetDateFormat("Year: YY, month: MM, day: DD")
        ? SetCentury()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        SetDateFormat("DD. 月中的第 MM 天，年份 YYYY")
        ? SetCentury()&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CToD'>CToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToC'>DToC</seealso>
    <seealsocmd>SET DATE FORMAT</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetDateCountry'>SetDateCountry</seealso>
  </setdateformat>

  <setdecimal>
    <summary>
      返回并可选择性地更改决定用于显示数字的小数位数的设置。
    </summary>
    <param name="nNewSetting">
      要显示的小数位数。<br/>
      初始默认值为2。<br/>
      负值表示返回所有有效数字。
    </param>
    <returns>
      如果未指定 <paramref name="nNewSetting" />，SetDecimal() 返回当前设置。<br/>
      如果指定了 <paramref name="nNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      SetDecimal() 决定在数字函数和计算的结果中显示的小数位数。<br/>
      它的操作直接依赖于 SetFixed() 设置：
      &#0009;如果 SetFixed() 为 FALSE，SetDecimal() 设定了在 Exp()、Log()、SqRt() 和除法操作中显示的小数位数的最小值。<br/>
      如果 SetFixed() 为 FALSE，SetDecimal() 仍然生效。
      &#0009;如果 SetFixed() 为 TRUE，所有数字值将显示为 SetDecimal() 指定的小数位数。
      请注意，SetDecimal() 和 SetFixed() 均不影响计算的实际数值精度 — 仅影响显示格式。
      所有包含 FLOAT 类型的变量都有与数字和小数相关的内部图片信息（请参见 FloatFormat()）。<br/>
      对于 FLOAT 类型的数据库字段，这些图片信息存在于数据库头结构中，并可通过 FieldVal() 获取。
      当通过表达式或函数生成新浮点数时，小数位数始终取自 SetDigit()，小数位数的确定如下：
      操作符&#0009;小数位数&#0009;
      + 或 -&#0009;最多两个操作数&#0009;
      *&#0009;两个操作数的总和&#0009;
      /&#0009;当前设置的 SetDecimal()&#0009;
      对于函数，小数位数由当前设置的 SetDecimal() 或特殊情况下的零决定，例如 Integer() 函数。
    </remarks>
    <example>
      这些示例显示了 SetDecimal() 函数的各种结果：
      <code language="X#">
        SetDecimal(2)
        ? 2.0/4.0               // 0.50
        ? 1.0/3.0               // 0.33
        SetDecimal(4)
        ? 2.0/4.0               // 0.5000
        ? 1.0/3.0               // 0.3333
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FloatFormat'>FloatFormat</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDecimalSep'>SetDecimalSep</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetFixed'>SetFixed</seealso>
    <seealso cref='O:XSharp.RT.Functions.Transform'>Transform</seealso>
  </setdecimal>

  <setdecimalsep>
    <summary>
      返回并可选择性地更改用于数字到字符串转换函数的十进制分隔符设置。
    </summary>
    <param name="nNewSetting">
      表示新十进制分隔符的 ASCII 码。<br/>
      初始默认值为46，即 "." 字符的 ASCII 码。<br/>
      可能的值为 ASC(".") 和 ASC(",")。
    </param>
    <returns>
      如果未指定 <paramref name="nNewSetting" />，SetDecimalSep() 返回当前设置。<br/>
      如果指定了 <paramref name="nNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例将小数分隔符从句点 (.) 更改为逗号 (,)：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL rPi := 3.14 AS REAL4
        &#0009;SetDecimalSep(Asc(","))
        &#0009;QOut(rPi)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetTimeSep'>SetTimeSep</seealso>
  </setdecimalsep>

  <setdefault>
    <summary>
      更改决定 X# 默认驱动器和目录的设置。
    </summary>
    <param name="cPathSpec">
      默认的磁盘驱动器和目录。<br/>
      如果您同时指定驱动器和目录，则驱动器字母后必须包含一个冒号。（使用 GetDefault() 获取当前设置。）
    </param>
    <returns>
    </returns>
    <remarks>
      默认情况下，当 X# 程序启动时，默认驱动器和目录为当前 X# 驱动器和目录。在程序中，您可以使用 SetDefault() 更改此设置 — 它设置应用程序创建和搜索未指定路径名称的文件的驱动器和目录。
      注意：某些打开文件的命令和函数不遵循 SetDefault() 设置。<br/>
      这些情况在这些命令和函数的文档中明确说明。
      SetDefault() 不更改 X# 驱动器和目录，而是使应用程序使用不同的默认值。<br/>
      要为文件访问设置额外的搜索路径，请使用 SetPath()。
    </remarks>
    <example>
      此示例使用 SetDefault() 设置并查询当前默认驱动器和目录：
      <code language="X#">
        FUNCTION Start()
        ? GetCurPath()&#0009;&#0009;&#0009;// 打印当前路径
        SetPath("c:\")&#0009;&#0009;&#0009;// 设置新路径
        ? GetCurPath()&#0009;&#0009;&#0009;// 打印当前路径
        ? GetDefault()&#0009;&#0009;&#0009;// 打印当前默认
        SetDefault("c:\")&#0009;&#0009;// 设置新默认
        ? GetDefault()&#0009;&#0009;&#0009;// 打印当前默认
        WAIT
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetDefault'>GetDefault</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPath'>SetPath</seealso>
  </setdefault>

  <setdefaultdir>
    <summary>
      更改决定错误日志文件位置的设置。
    </summary>
    <param name="cPathSpec">
      您希望应用程序创建和搜索错误日志文件的磁盘驱动器和目录。<br/>
      如果同时指定驱动器和目录，则驱动器字母后必须包含一个冒号。<br/>
      SetDefaultDir() 的初始默认值为当前目录。
    </param>
    <returns>
    </returns>
    <remarks>
      默认情况下 — 如果您没有在 WIN.INI 的 X# 部分中放置 DefaultDir 条目，也没有调用 SetDefaultDir() — 错误日志文件的位置如下确定：
      &#0009;已设置的 SetDefault() 位置
      &#0009;否则，当前 Windows 目录
      如果您将 DefaultDir 条目设置为除其初始默认值以外的值 (DefaultDir=)，此设置将确定此及所有其他 X# 应用程序的错误日志文件位置。
      如果您调用 SetDefaultDir()，它将使用指定位置覆盖当前应用程序的 DefaultDir 条目。
    </remarks>
    <example>
      此示例使用 SetDefaultDir() 更改设置并查询当前默认驱动器和目录：
      <code language="X#">
        Function Start()
        &#0009;SetDefaultDir("c:\errfiles")
        &#0009;...
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetDefaultDir'>GetDefaultDir</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDefault'>SetDefault</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetErrorLog'>SetErrorLog</seealso>
  </setdefaultdir>

  <setdeleted>
    <summary>
      返回并可选地更改决定是否忽略或包含已标记为删除的记录的设置。
    </summary>
    <param name="lNewSetting">
      TRUE 忽略已删除的记录；FALSE 处理已删除的记录。<br/>
      初始默认值为 FALSE。
    </param>
    <returns>
      如果未指定 <paramref name="lNewSetting" />，SetDeleted() 返回当前设置。<br/>
      如果指定了 <paramref name="lNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      SetDeleted() 切换所有工作区中标记为删除的记录的自动过滤。指定 TRUE 时，大多数命令忽略删除的记录。<br/>
      但是，如果通过记录编号（GOTO 或任何支持 RECORD 范围的命令）引用记录，则即使该记录被标记为删除，也不会被忽略。<br/>
      此外，TRUE 对 INDEX 或重新索引没有影响。
      注意：RECALL ALL 尊重 SetDeleted()，并且不会恢复任何记录。
      <note type="tip">
        在单个工作区中过滤已删除记录：<br/>
        要将已删除记录的过滤限制于特定工作区，请选择工作区，然后将过滤器设置为 !Deleted()。
      </note>
    </remarks>
    <example>
      此示例说明使用 SetDeleted() 的效果：
      <code language="X#">
        USE sales NEW
        ? LastRec()&#0009;&#0009;&#0009;&#0009;// 84
        DELETE RECORD 4
        COUNT TO nCount
        ? nCount&#0009;&#0009;&#0009;&#0009;&#0009;// 84
        SetDeleted(TRUE)
        COUNT TO nCount
        ? nCount&#0009;&#0009;&#0009;&#0009;&#0009;// 83
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetFilter'>DBSetFilter</seealso>
    <seealsocmd>DELETE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.Deleted'>Deleted</seealso>
    <seealsocmd>RECALL</seealsocmd>
  </setdeleted>

  <setdigit>
    <summary>
      返回并可选地更改决定在数字显示时小数点左侧显示的数字个数的设置。
    </summary>
    <param name="nNewSetting">
      要显示的数字个数。<br/>
      初始默认值为 10。<br/>
      负值表示仅返回小数点左侧的重要整数位（即尾数）。<br/>
      任何右侧填充也将被抑制。
    </param>
    <returns>
      如果未指定 <paramref name="nNewSetting" />，SetDigit() 返回当前设置。<br/>
      如果指定了 <paramref name="nNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      SetDigit() 和 SetDigitFixed() 可以一起使用，以控制数字的显示方式：
      &#0009;当 SetDigitFixed() 为 TRUE 时，数字输出的显示根据 SetDigit() 值固定。
      &#0009;当 SetDigitFixed() 为 FALSE 时，数字输出根据数字显示的默认规则显示。
      要提供更精细的数字显示控制，可以使用 @...SAY、@...GET 的 PICTURE 子句和 Transform() 函数。
      对于 <paramref name="nNewSetting" /> 为 -1 表示仅显示小数点左侧的重要整数位（任何前导零将被抑制）。
      <note type="tip">
        SetDigit() 仅影响数字的显示格式，而不影响计算的实际数值精度。
      </note>
    </remarks>
    <example>
      此示例展示了 SetDigit() 的典型用法：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL nSaveDigit AS SHORTINT
        &#0009;? 1234&#0009;&#0009;&#0009;&#0009;// 1234
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 初始设置为 10 位数字
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 数字右对齐显示
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 保存当前设置，然后重置为 5 位数字
        &#0009;nSaveDigit := SetDigit(5)
        &#0009;? 1234&#0009;&#0009;&#0009;&#0009;//  234
        &#0009;? 1234.567&#0009;&#0009;&#0009;&#0009;//  1234.567
        &#0009;? 123456&#0009;&#0009;&#0009;&#0009;// *****
        &#0009;SetDigit(nSaveDigit)&#0009;&#0009;// 恢复旧设置
        &#0009;? 1234&#0009;&#0009;&#0009;&#0009;//  1234
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDigitFixed'>SetDigitFixed</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetFixed'>SetFixed</seealso>
  </setdigit>

  <setdigitfixed>
    <summary>
      返回并可选地更改用于显示数字输出的数字位数设置。
    </summary>
    <param name="lNewSetting">
      TRUE 将固定显示的数字位数。 FALSE 将显示的数字位数保持不固定。<br/>
      初始默认值为 FALSE。
    </param>
    <returns>
      如果未指定 <paramref name="lNewSetting" />，则 SetDigitFixed() 返回当前设置。<br/>
      如果指定了 <paramref name="lNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      SetDigit() 和 SetDigitFixed() 可以一起使用以控制数字的显示方式：
      &#0009;当 SetDigitFixed() 为 TRUE 时，数字输出的显示根据 SetDigit() 的值固定。
      &#0009;当 SetDigitFixed() 为 FALSE 时，数字输出根据数字显示的默认规则显示。
      <note type="tip">
        SetDigitFixed() 仅影响数字的显示格式，而不影响计算的实际数值精度。
      </note>
    </remarks>
    <example>
      此示例使用 SetDigitFixed() 在例程开始时固定显示的数字位数，并在例程结束时停止固定：
      <code language="X#">
        LOCAL lSDFSetting AS LOGIC
        lSDFSetting := SetDigitFixed(TRUE)
        MyFunc()
        SetDigitFixed(lSDFSetting)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDigit'>SetDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetFixed'>SetFixed</seealso>
  </setdigitfixed>

  <setenv>
    <summary>
      更新或替换 DOS 环境变量的内容。
    </summary>
    <param name="cVar">要修改的环境变量。</param>
    <param name="cValue">要分配给环境变量的新值。</param>
    <param name="lAppend">指示是否应将新值附加到旧值（TRUE），或是否应替换旧值（FALSE）的逻辑值。</param>
    <returns>
      如果成功，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      SetEnv() 允许您从应用程序中附加或替换 DOS 环境变量。通常这是配置信息，包括描述文件位置（数据库、索引、标签或报告）的路径名。
      注意：与其使用环境变量来配置您的应用程序，您可能想考虑使用注册表设置。
    </remarks>
    <example>
      这些示例修改 DOS PATH：
      <code language="X#">
        ? SetEnv("PATH","D:\CAVO2x\BIN", .F.)  //覆盖 PATH
        ? GetEnv("PATH")
        ? SetEnv("PATH", "C:\MyApp", .T.)  //附加到 PATH 末尾
        ? GetEnv("PATH")
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetEnv'>GetEnv</seealso>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegInt'>QueryRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegString'>QueryRTRegString</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegInt'>SetRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegString'>SetRTRegString</seealso>
  </setenv>

  <setepoch>
    <summary>
      返回并可选地更改决定如何解释没有世纪数字的日期的设置。
    </summary>
    <param name="nNewSetting">
      指定一个 100 年期间的基年，所有仅包含两个年份数字的日期都被假定在此期间内。<br/>
      初始默认值为 1900，导致没有世纪数字的日期被解释为属于二十世纪。
    </param>
    <returns>
      如果未指定 <paramref name="lNewSetting" />，则 SetEpoch() 返回当前设置。<br/>
      如果指定了 <paramref name="lNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      SetEpoch() 是一个环境函数，决定仅包含两个年份数字的日期字符串的解释。当这样的字符串被转换为日期值时，其年份数字与 <paramref name="nNewSetting" /> 的年份数字进行比较。<br/>
      如果日期中的年份数字大于或等于 <paramref name="nNewSetting" /> 的年份数字，则该日期被假定在与 <paramref name="nNewSetting" /> 相同的世纪内。<br/>
      否则，假定该日期属于下一个世纪。
    </remarks>
    <example>
      此示例显示 SetEpoch() 的效果：
      <code language="X#">
        SetDateFormat("mm/dd/yyyy")
        ? CTOD("05/27/1904")&#0009;&#0009;// 05/27/1904
        ? CTOD("05/27/67")&#0009;&#0009;// 05/27/1967
        ? CTOD("05/27/04")&#0009;&#0009;// 05/27/1904
        SetEpoch(1960)
        ? CTOD("05/27/1904")&#0009;&#0009;// 05/27/1904
        ? CTOD("05/27/67")&#0009;&#0009;// 05/27/1967
        ? CTOD("05/27/04")&#0009;&#0009;// 05/27/2004
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CToD'>CToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToC'>DToC</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToS'>DToS</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetCentury'>SetCentury</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDateCountry'>SetDateCountry</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDateFormat'>SetDateFormat</seealso>
    <seealso cref='O:XSharp.RT.Functions.Today'>Today</seealso>
    <seealso cref="F:XSharp.Set.Epoch" />
    <seealso cref="F:XSharp.Set.EpochYear" />
    <seealso cref="F:XSharp.Set.EpochCent" />
    <seealso cref="P:XSharp.RuntimeState.EpochCent" />
    <seealso cref="P:XSharp.RuntimeState.EpochYear" />
    <seealso cref="P:XSharp.RuntimeState.Epoch" />
  </setepoch>

  <seterrorlog>
    <summary>
      返回并可选地更改决定默认运行时错误处理程序是否将错误信息写入错误日志文件的设置。
    </summary>
    <param name="lNewSetting">
      TRUE 会将错误信息写入名为 X# 错误日志文件的文本文件。 FALSE 会抑制在错误日志文件中记录错误。<br/>
      &#0009;如果 WIN.INI 的 X# 部分中没有 ErrorLog 条目，将写入条目 ErrorLog=1，初始默认值设置为 TRUE；如果该条目设置为 0，则初始默认值为 FALSE。
    </param>
    <returns>
      如果未指定 <paramref name="lNewSetting" />，SetErrorLog() 返回当前设置。<br/>
      如果指定了 <paramref name="lNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      SetErrorLog() 让您能够跟踪应用程序在运行时发生的错误。<br/>
      如果设置为 TRUE，并且您的应用程序在执行时生成一个或多个错误，则默认错误处理程序会将错误信息写入名为 VOERROR.LOG 的错误日志文件。
      如果 WIN.INI 的 X# 部分中没有 ErrorLogAppend 条目，将写入条目 ErrorLogAppend=0，导致每次应用程序运行时重新创建错误日志文件。<br/>
      如果该条目设置为 1，错误信息将附加到现有的错误日志文件中。<br/>
      此功能在多个应用程序同时在同一计算机上运行时非常有用。无论如何，如果错误日志文件不存在，将创建该文件。
      错误日志文件的位置由 SetDefaultDir() 控制，您可以参考该函数以获取更多信息。
      尽管将错误信息写入文件通常是有用的，但在某些情况下（例如，当您受到网络创建权限、最大打开文件数、磁盘空间不足或目录条目不足的限制时），您必须使用 SetErrorLog() 来防止系统写入错误文件。
    </remarks>
    <example>
      此示例将 SetErrorLog() 设置为 FALSE 并保存先前的设置：
      <code language="X#">
        lSaveErrorLog := SetErrorLog(FALSE)
        MyFunc()
        SetErrorLog(lSaveErrorLog)
      </code>
    </example>
    <seealsocmd>SetDefaultDir</seealsocmd>
  </seterrorlog>

  <setexact>
    <summary>
      切换字符字符串比较的精确匹配。
    </summary>
    <param name="lNewSetting">
      TRUE 导致字符串按长度和值进行比较； FALSE 导致字符串仅按长度和位置进行比较。初始默认值为 FALSE。<br/>
      &#0009;此函数等同于字符串评估的 == 操作符，并且在大多数字符串评估中更为推荐。
    </param>
    <returns>
      如果未指定 <paramref name="lNewSetting" />，SetExact() 返回当前设置。<br/>
      如果指定了 <paramref name="lNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      SetExact() 返回并可选地设置默认字符串比较方法。
      SetExact() 是一个兼容性函数，不推荐使用。
    </remarks>
    <example>
    </example>
    <seealsocmd>SET EXACT</seealsocmd>
  </setexact>

  <setexclusive>
    <summary>
      返回并可选地更改决定以独占或共享模式打开数据库文件的设置。
    </summary>
    <param name="lNewSetting">
      TRUE 导致数据库文件以独占（非共享）模式打开； FALSE 导致数据库文件以共享模式打开。<br/>
      初始默认值为 TRUE。
    </param>
    <returns>
      如果未指定 <paramref name="lNewSetting" />，SetExclusive() 返回当前设置。<br/>
      如果指定了 <paramref name="lNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      SetExclusive() 决定没有指定 EXCLUSIVE 或 SHARED 子句的 USE 命令是否自动以 EXCLUSIVE 模式打开数据库、备忘录和索引文件。当数据库文件以 EXCLUSIVE 模式打开时，其他用户在关闭之前无法使用它们。在此模式下，不需要文件和记录锁。
      指定 TRUE 时，除非 USE 命令指定了 SHARED 子句，否则所有数据库和关联文件都以非共享（独占）模式打开。<br/>
      仅在绝对需要数据库文件独占使用的操作中使用此选项，例如 PACK、REINDEX 和 ZAP。
      指定 FALSE 时，所有文件都以共享模式打开，除非 USE 命令指定了 EXCLUSIVE 子句。
      不要使用 SetExclusive() 来控制其他用户对记录和文件的访问。您可以使用 RLock() 和 FLock() 进行编程控制访问。
      SetExclusive() 是一个兼容性函数，不推荐使用。<br/>
      它已被 USE 命令的 EXCLUSIVE 和 SHARED 子句所取代。
      <note type="tip">
        错误处理：<br/>
        尝试使用另一个用户已经以独占方式打开的数据库文件会生成运行时错误，并将 NetErr() 设置为 TRUE。<br/>
        控制返回到错误点后，您可以测试 NetErr() 以确定 USE 命令是否失败。
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Flock'>FLock</seealso>
    <seealso cref='O:XSharp.Core.Functions.NetErr'>NetErr</seealso>
    <seealso cref='O:XSharp.RT.Functions.RLock'>RLock</seealso>
    <seealsocmd>USE</seealsocmd>
  </setexclusive>

  <setfdatetime>
    <summary>
      重置文件的日期和时间戳。
    </summary>
    <param name="cFile">要修改的文件名称（可选地包含驱动器和目录信息）。</param>
    <param name="dDate">
      要用于日期戳的新日期。<br/>
      如果未指定，默认值为 Today()。
    </param>
    <param name="cTime">
      要用于时间戳的新时间字符串。<br/>
      如果未指定，默认值为 Time()。
    </param>
    <returns>
      如果成功，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </setfdatetime>

  <setfieldstore>
    <summary>
      返回并可选地更改决定赋值是对字段还是对内存变量的设置。
    </summary>
    <param name="lNewSetting">
      TRUE 开启字段赋值；FALSE 关闭字段赋值。<br/>
      初始默认值为 FALSE。
    </param>
    <returns>
      如果未指定 <paramref name="lNewSetting" />，则 SetFieldStore() 返回当前设置。<br/>
      如果指定了 <paramref name="lNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      如果当前工作区中存在与数据库字段同名的 PRIVATE 或 PUBLIC 变量，则赋值将被分配给内存变量（PRIVATE，PUBLIC），除非 SetFieldStore() 设置为 TRUE。
    </remarks>
    <example>
      此示例展示了 SetFieldStore() 对私有变量的影响：
      <code language="X#">
        PRIVATE LName
        LName := "MyMemVar"
        USE Test
        ? Test-&gt;LName&#0009;&#0009;&#0009;&#0009;&#0009;// OldField
        // 这指的是名为 LName 的 PRIVATE 变量：
        ? LName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// MyMemVar
        // 默认设置为 FALSE
        ? SetFieldStore()&#0009;&#0009;&#0009;&#0009;// FALSE
        // 由于 SetFieldStore() 为 FALSE，此操作将
        // 将值分配给名为 LName 的 PRIVATE 内存变量
        LName := "NewVal"
        ? Test-&gt;LName&#0009;&#0009;&#0009;&#0009;&#0009;// OldField
        ? LName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// NewVal
        ? SetFieldStore(TRUE)
        &#0009;// FALSE（返回先前设置）
        // 由于 SetFieldStore() 为 TRUE，此操作将
        // 将值分配给名为 LName 的数据库字段
        LName := "NewestVal"
        ? Test-&gt;LName&#0009;&#0009;&#0009;&#0009;&#0009;// NewestVal
        // 这仍然指的是名为 LName 的 PRIVATE 变量：
        ? LName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// NewVal
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias'>别名</seealso>
    <seealsocmd>REPLACE</seealsocmd>
  </setfieldstore>

  <setfixed>
    <summary>
      返回并可选地更改用于显示数字的固定小数位数设置。
    </summary>
    <param name="lNewSetting">TRUE 使用当前 SetDecimal() 设置显示数字输出。FALSE 忽略 SetDecimal()，允许操作或函数根据数字显示的默认规则确定小数位数。</param>
    <returns>
      如果未指定 <paramref name="lNewSetting" />，则 SetDecimal() 返回当前设置。<br/>
      如果指定了 <paramref name="lNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      <note type="tip">
        SetFixed() 仅影响数字的显示格式，不影响计算的实际数值精度。
      </note>
    </remarks>
    <example>
      此示例使用 SetFixed() 在例程开始时固定显示的小数位数，并在例程结束时停止固定：
      <code language="X#">
        LOCAL lSFSetting AS LOGIC
        lSFSetting := SetFixed(TRUE)
        MyFunc()
        SetFixed(lSFSetting)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FloatFormat'>浮点格式</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>设置小数</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDigitFixed'>设置固定数字</seealso>
  </setfixed>

  <setfloatdelta>
    <summary>
      返回并可选地更改决定两个浮点数被认为相等的设置，即使它们是不同的。
    </summary>
    <param name="nNewSetting">两个数字之间可接受的差异。</param>
    <returns>
      如果未指定 <paramref name="nNewSetting" />，则 SetFloatDelta() 返回当前设置。<br/>
      如果指定了 <paramref name="nNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      SetFloatDelta() 决定两个浮点数可以不同的最大值，而仍然被视为相等。如果两个数字之间的差异小于 SetFloatDelta() 的设置，则该差异将被忽略。
    </remarks>
    <example>
      此示例使用 SetFloatDelta() 来改变数值比较的结果：
      <code language="X#">
        ? 1.231 =  1.23&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        ? 1.33 = 1.23&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        SetFloatDelta(0.01)&#0009;&#0009;&#0009;&#0009;// Delta 设置为 0.01
        ? 1.231 = 1.23&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE 因为 1.231-1.23 &lt; 0.01
        ? 1.33 = 1.23&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE 因为 1.33-1.23 &gt; 0.01
        ? 1.4 &lt; 1.40123456&#0009;&#0009;&#0009;&#0009;// FALSE
        ? 1.4 &lt; 1.42&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Between'>Between</seealso>
  </setfloatdelta>

  <setrefresh>
    <summary>
      检索并可选地设置 RDD 系统缓存数据的时间。
    </summary>
    <param name="nNewSetting">缓存数据的时间（秒）。</param>
    <returns>
      如果未指定 <paramref name="nNewSetting" />，则 SetRefresh() 返回当前设置。<br/>
      如果指定了 <paramref name="nNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      SetRefresh() 决定 RDD 系统在检查其他用户的更改之前，将数据保留在内存中的时间（秒）。
    </remarks>
    <seealso cref='O:XSharp.Core.Functions.SetRefresh'>SetRefresh</seealso>
  </setrefresh>

  <setinternational>
    <summary>
      返回并可选地更改决定应用程序的国际模式的设置。
    </summary>
    <param name="symNewSetting">
      要使用的国际模式。<br/>
      可用的模式有 #Windows（默认）和 #Clipper。
    </param>
    <returns>
      如果未指定 <paramref name="symNewSetting" />，则 SetInternational() 返回当前设置。<br/>
      如果指定了 <paramref name="symNewSetting" />，则返回先前的设置。
    </returns>
    <remarks>
      SetInternational() 允许 X# 在不同的国际模式下运行。<br/>
      #Clipper 模式是为了与 CA-Clipper 应用程序的兼容性而提供的，使用在国家模块（VO28NAT.DLL）中定义的国际化程序。<br/>
      #Windows 模式使用 Windows 提供的国际服务。
      因此，如果应用程序使用 #Clipper 国际模式，它将在所有机器上表现相同。因此，为了实现不同的国际化程序，您需要一个 VO28NAT.DLL 的专门版本。另一方面，如果应用程序使用 #Windows 国际模式，它将根据控制面板中的国际设置在不同机器上表现不同。
      更改 SetInternational() 会自动更改 SetCollation()，使这两个设置保持一致。SetInternational() 还确定下面列表中函数的初始默认值，并在每次调用该函数时重置它们。<br/>
      对于 SetInternational(#Windows)，设置来自控制面板中的对应国际设置：
      函数&#0009;SetInternational(#Clipper) 默认值
      GetAMExt()/SetAMExt()&#0009;NULL_STRING
      GetPMExt()/SetPMExt()&#0009;NULL_STRING
      SetAMPM()&#0009;24 小时格式
      SetDateFormat()&#0009;mm/dd/yy&#0009;
      SetDecimal()&#0009;2&#0009;
      SetDecimalSep()&#0009;小数点 (.)&#0009;
      SetTimeSep()&#0009;冒号 (:)&#0009;
      SetThousandSep()&#0009;逗号 (,)&#0009;
      <note type="tip">
        时间字符串中的前导零：<br/>
        控制面板中的前导零国际设置将被忽略。时间字符串中的前导零始终会显示。
        图片子句中的小数和千位分隔符：<br/>
        在图片子句中使用的逗号作为千位分隔符和用于小数的句点不受此设置的影响。<br/>
        因此，您的源代码不会因 SetInternational() 的状态而改变。注意，图片子句是通过 @...SAY...GET 命令、Transform() 函数或 FieldSpec:Picture 属性定义的。
        @E 图片函数：<br/>
        如果 SetInternational(#Windows) 生效，则 @E 图片函数被忽略。
      </note>
    </remarks>
    <example>
      此示例在应用程序的启动例程中将国际模式设置为 #Clipper，以保持与 CA-Clipper 应用程序的向后兼容性。注意，SetCollation() 也因此更改为 #Clipper：
      <code language="X#">
        METHOD Start() CLASS App
        &#0009;...
        &#0009;SetInternational(#Clipper)
        &#0009;...
      </code>
    </example>
    <seealsocmd>SET INTERNATIONAL</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetCollation'>SetCollation</seealso>
  </setinternational>

  <setjmp>
    <summary>
      保存堆栈环境。
    </summary>
    <param name="strucMark">将存储环境的结构。</param>
    <returns>
      零 (0)，在调用以保存堆栈环境时。如果 SetJmp() 由于 LongJmp() 调用而被调用，则返回 LongJmp() 的第二个参数。
    </returns>
    <remarks>
      SetJmp() 将当前堆栈环境（包括基于堆栈的变量和 SetJmp() 的返回地址）保存在 <paramref name="strucMark" /> 中。<paramref name="strucMark" /> 定义如下：
      <code language="X#">
        STRUCTURE _JMP_BUF
        &#0009;MEMBER pJumpAddr<br/>
        AS PTR
        &#0009;MEMBER nEBP       AS DWORD
        &#0009;MEMBER nESP       AS DWORD
        &#0009;MEMBER pKIDStack<br/>
        AS PTR
        &#0009;MEMBER nDASOff  <br/>
        AS DWORD
        &#0009;MEMBER nCallStack AS DWORD
      </code>
      随后对 LongJmp() 的调用将恢复堆栈环境，并恢复执行，就好像 SetJmp() 返回了 LongJmp() 的第二个参数一样。
      SetJmp() 和 LongJmp() 为您提供了一种转到特定代码行的机制。<br/>
      它们通常用于模拟“返回主程序”命令或分支到错误恢复代码。
    </remarks>
    <example>
      此示例演示了 LongJmp() 和 SetJmp() 如何一起工作以保存和恢复堆栈环境：
      <code language="X#">
        STATIC GLOBAL strucMark IS _JMP_BUF
        FUNCTION Start()
        &#0009;LOCAL siJMPRetVal AS SHORTINT
        &#0009;siJMPRetVal :=SetJmp(@strucMark)
        &#0009;? siJMPRetVal
        &#0009;IF siJMPRetVal <paramref name="" />0
        &#0009;&#0009;? "LongJmp() got me here", siJMPRetVal
        &#0009;&#0009;RETURN FALSE
        &#0009;ENDIF
        &#0009;LongJmp(@strucMark, 1)|
        &#0009;? "你将永远看不到这个屏幕上的内容。"
        &#0009;RETURN TRUE
      </code>
      这里是另一个示例，如果检测到错误，则发出 LongJmp()：
      <code language="X#">
        STATIC GLOBAL strucMark IS _JMP_BUF
        FUNCTION Start()
        &#0009;LOCAL siJMPRetVal AS SHORTINT
        &#0009;siJMPRetVal := SetJmp(@strucMark)
        &#0009;IF siJMPRetVal <paramref name="" />0
        &#0009;&#0009;? "LongJmp() was here with", siJMPRetVal
        &#0009;&#0009;RETURN FALSE
        &#0009;ENDIF
        &#0009;IF .NOT. FILE("voerror.log")
        &#0009;&#0009;LongJmp(@strucMark, 1)
        &#0009;ENDIF
        &#0009;SUBFUNC()
        &#0009;RETURN TRUE
        FUNCTION Subfunc
        &#0009;LOCAL cLog AS STRING
        &#0009;cLog := MEMOREAD("voerror.log")
        &#0009;IF SLen(cLog) =MAX_ALLOC
        &#0009;&#0009;LongJmp(@strucMark, 2)
        &#0009;ENDIF
        &#0009;RETURN 0
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.LongJmp'>LongJmp</seealso>
  </setjmp>

  <setmath>
    <summary>
      返回并可选地更改决定底层浮点系统的内部操作特性的设置。
    </summary>
    <param name="nNewSetting">以下值之一，指示要使用的数学处理器类型：</param>
    <returns>
      如果未指定<paramref name="nNewSetting" />，SetMath()返回当前设置。<br/>
      如果指定了<paramref name="nNewSetting" />，则返回之前的设置。
    </returns>
    <remarks>
      SetMath() 是一個相容性函數。它在 X# 中並沒有真正做任何事情。
    </remarks>
    <seealso cref='O:XSharp.Core.Functions.SetCpu'>SetCPU</seealso>
  </setmath>

  <setnatdll>
    <summary>
      激活用于国家相关操作和消息的新DLL。
    </summary>
    <param name="cNewDLL">要使用的新DLL的名称。</param>
    <returns>
      如果成功，则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
      国家相关操作的默认库是VO28NAT.DLL。SetNatDLL()禁用默认DLL并加载指定的DLL<paramref name="cNewDLL" />，该DLL在下次调用SetNatDLL()之前是活动的。
    </remarks>
    <example>
      此示例将DLL CAVONT20.GER设置为国家相关操作：
      <code language="X#">
        ? GetNatDLL()&#0009;&#0009;&#0009;&#0009;// VO28NAT.DLL
        ? SetNatDLL("GERMAN.DLL")&#0009;&#0009;// .T.
        ? GetNatDLL()&#0009;&#0009;&#0009;&#0009;// GERMAN.DLL
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetNatDLL'>GetNatDLL</seealso>
  </setnatdll>

  <setpath>
    <summary>
      更改确定X#打开文件的搜索路径的设置。
    </summary>
    <param name="cPathList">
      X#在搜索默认目录中未找到的文件时使用的路径。<br/>
      路径是指向目录的指针。<br/>
      它由可选的驱动器字母和冒号组成，后跟用反斜杠（\）字符分隔的从根到所需目录的目录列表。<br/>
      路径列表是要搜索的路径序列，每个路径之间用逗号或分号分隔。<br/>
      &#0009;如果省略，则释放路径列表，使X#仅搜索默认目录。（使用GetCurPath()获取当前设置。）
    </param>
    <returns>
    </returns>
    <remarks>
      SetPath()允许打开数据库和关联文件的命令和函数在另一个驱动器和/或目录中找到并打开现有文件。<br/>
      它通过指定搜索的路径列表来实现，如果引用的文件在默认目录中找不到，则进行搜索。
      当您尝试访问文件而未指定其路径时，X#首先搜索默认驱动器和目录。<br/>
      默认驱动器和目录由Windows在加载应用程序时建立，或者在执行过程中通过SetDefault()函数建立。<br/>
      如果未找到文件，X#将继续搜索指定路径列表中的每个路径，直到找到文件的第一次出现。
      要在另一个驱动器或目录中创建新文件，请使用SetDefault()或在指定新文件名时明确声明路径。
      注意：某些打开文件的命令和函数不尊重SetPath()设置。<br/>
      这些情况在这些命令和函数的文档中明确说明。
    </remarks>
    <example>
      此示例设置两个路径以打开文件：
      <code language="X#">SetPath("a:\inventory;b:\vendors")</code>
      此示例通过将DOS环境变量传递给程序来配置运行时路径设置，使用GetEnv()获取其值，然后使用此值设置路径。<br/>
      例如，在DOS中：
      <code language="X#">SET VO_PATH = c:\apps\data;c:\apps\progs</code>
      然后在您应用程序的配置部分中：
      <code language="X#">SetPath(GetEnv("VO_PATH"))</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetCurPath'>GetCurPath</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDefault'>SetDefault</seealso>
  </setpath>

  <setpmext>
    <summary>
      设置12小时格式时间字符串的晚上扩展。
    </summary>
    <param name="cPMExt">
      用于在晚上时间字符串中使用的扩展。<br/>
      此字符串的长度最多为八个字符——忽略额外字符。
    </param>
    <returns>
    </returns>
    <remarks>
      使用12小时时间格式格式化的时间字符串具有扩展，以指定时间是在早晨还是晚上。SetPMExt()允许您以编程方式设置标识晚上时间字符串的扩展（即，在12:00:00中午到12:00:00午夜之间的时间）。<br/>
      晚上的时间字符串的典型扩展是“PM”，这也是该函数名称的来源。
      晚上扩展的初始默认值受SetInternational()的影响，您可以参考以获取更多信息。<br/>
      使用GetPMExt()检索当前此设置的值。
      注意：<br/>
      如果SetInternational(#Windows)生效，则晚上扩展也会作为24小时时间格式的一部分显示。<br/>
      这是Windows标准，而不是特定于X#。
    </remarks>
    <example>
      此示例打开12小时格式并使用两个不同的扩展显示时间字符串：
      <code language="X#">
        SetAMPM(TRUE)
        SetPMExt(" pm")
        ? TString(47000)&#0009;&#0009;// 01:03:20 pm
        SetAMExt(" evening")
        ? TString(47000)&#0009;&#0009;// 01:03:20 evening
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.GetPMExt'>GetPMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAMExt'>SetAMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAmPm'>SetAMPM</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
    <seealso cref='O:XSharp.RT.Functions.TString'>TString</seealso>
  </setpmext>

  <setpos>
    <summary>
      将光标移动到终端窗口的新位置。
    </summary>
    <param name="iRow">光标的新行位置</param>
    <param name="iCol">光标的新列位置</param>
    <returns>
    </returns>
    <remarks>
      SetPos() 将光标移动到指定位置，并用新光标位置更新 Row() 和 Col()。
    </remarks>
    <example>
      这个示例展示了 DevPos() 函数与 @...SAY 命令之间的关系：
      <code language="X#">
        SetPos(10, 10)
        ? Qout("你好")
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Row'>Row</seealso>
    <seealso cref='O:XSharp.RT.Functions.Col'>Col</seealso>
  </setpos>

  <setrtregint>
    <summary>
      将数字值保存到注册表。
    </summary>
    <param name="cSubkey">您希望添加数字的子键。</param>
    <param name="cKey">您希望添加数字的键。</param>
    <param name="dwKeyValue">您希望添加到注册表的键值。</param>
    <returns>
      如果成功，返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
      SetRTRegInt() 可用于将运行时设置保存到注册表中。<br/>
      值将作为 <paramref name="cKey" /> = <paramref name="dwKeyValue" /> 保存到以下键下：
      HKEY_CURRENT_USER
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      并可选地在
      HKEY_LOCAL_MACHINE
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      如果 <paramref name="cSubkey" /> 为空 (NULL_STRING)，注册表项将无子键地保存：
      HKEY_LOCAL_MACHINE
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      SetRtRegInt() 仅在键已存在时写入 HKEY_LOCAL_MACHINE（并忽略写入错误）。它总是也写入 HKEY_CURRENT_USER。返回值反映写入 HKEY_CURRENT_USER 的结果。
    </remarks>
    <example>
      这个示例将条目 LOCK_RETRIES = 10 添加到 SSA 下的注册表：
      <code language="X#">
        SetRTRegInt("SSA", "LOCK_RETRIES", 10)
        ...
        nRetries := QueryRTRegInt("SSA", "LOCK_RETRIES")
        DO WHILE nRetries &gt; 0
        &#0009;IF RLock()
        &#0009;&#0009;EXIT
        &#0009;ENDIF
        &#0009;nRetries--
        ENDDO
        IF nRetries = 0
        &#0009;// 错误消息
        ENDIF
        ...
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegInt'>QueryRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegString'>QueryRTRegString</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegString'>SetRTRegString</seealso>
  </setrtregint>

  <deletertregkey>
    <summary>
      从 VO 注册表分支删除一个子树
    </summary>
    <param name="cSubkey">您希望删除的子键。</param>
    <returns>
      如果成功，返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
      DeleteRtRegKey() 可用于清除注册表中的设置。<br/>
      它将清除以下子键：
      HKEY_CURRENT_USER
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      并可选地在
      HKEY_LOCAL_MACHINE
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      如果 <paramref name="cSubkey" /> 为空 (NULL_STRING)，注册表项将无子键地保存：
      HKEY_LOCAL_MACHINE
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
    </remarks>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegInt'>QueryRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegString'>QueryRTRegString</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegString'>SetRTRegString</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegInt'>SetRTRegInt</seealso>
  </deletertregkey>

  <setrtregstring>
    <summary>
      将字符串值保存到注册表。
    </summary>
    <param name="cSubkey">您希望添加字符串的子键。</param>
    <param name="cKey">您希望添加字符串的键。</param>
    <param name="cValue">您希望添加到注册表的键值。</param>
    <returns>
      如果成功，则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
      SetRTRegString() 可用于将运行时设置保存到注册表中。<br/>
      值将作为 <paramref name="cKey" /> = <paramref name="dwKeyValue" /> 保存到以下键下：
      HKEY_CURRENT_USER
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      并可选地在
      HKEY_LOCAL_MACHINE
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      \\<paramref name="cSubkey" />
      如果 <paramref name="cSubkey" /> 为空 (NULL_STRING)，则注册表项将无子键地保存：
      HKEY_LOCAL_MACHINE
      \\Software
      \\ComputerAssociates
      \\CA-Visual Objects Applications
      SetRTRegString() 仅在键已存在时写入 HKEY_LOCAL_MACHINE（并忽略写入错误）。它始终也写入 HKEY_CURRENT_USER。返回值反映写入 HKEY_CURRENT_USER 的结果。
    </remarks>
    <example>
      此示例将条目 APP_DIR = \SSA\ 添加到 SSA 下的注册表：
      <code language="X#">
        SetRTRegString("SSA", "APP_DIR", "\SSA\")
        ...
        cDbf:=QueryRTRegString("SSA","APP_DIR") + "test.dbf"
        USE (cDbf)
        ...
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegInt'>QueryRTRegInt</seealso>
    <seealso cref='O:XSharp.VO.Functions.QueryRTRegString'>QueryRTRegString</seealso>
    <seealso cref='O:XSharp.VO.Functions.SetRTRegInt'>SetRTRegInt</seealso>
  </setrtregstring>

  <setscience>
    <summary>
      返回并可选地更改以科学计数法显示数字的设置。
    </summary>
    <param name="lNewSetting">
      TRUE 启用科学计数法；指定 FALSE 将其禁用。<br/>
      初始默认值为 FALSE。
    </param>
    <returns>
      如果 <paramref name="lNewSetting" /> 未指定，SetScience() 返回当前设置。<br/>
      如果指定了 <paramref name="lNewSetting" />，则返回之前的设置。
    </returns>
    <remarks>
      SetScience() 是一个环境函数，允许您以科学计数法显示数字。<br/>
      任何数字都可以以科学计数法显示，其中数字由一个尾数（其整数部分）乘以 10 的指数表示。
    </remarks>
    <example>
      此示例使用 SetScience() 以科学计数法显示数字：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL lSNSetting AS LOGIC
        &#0009;lSNSetting := SetScience(TRUE)
        &#0009;? 1234567890
        &#0009;? 12345.678
        &#0009;SetScience(lSNSetting)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FloatFormat'>FloatFormat</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetFixed'>SetFixed</seealso>
  </setscience>

  <setsoftseek>
    <summary>
      返回并可选地更改设置，以确定当未找到精确匹配时，寻址操作是否会找到近似匹配。
    </summary>
    <param name="lNewSetting">
      TRUE 在未找到精确匹配后将记录指针移动到下一个具有更高键值的记录；FALSE 在未找到精确匹配后将记录指针移动到文件末尾。<br/>
      初始默认值为 FALSE。
    </param>
    <returns>
      如果 <paramref name="lNewSetting" /> 未指定，SetSoftSeek() 返回当前设置。<br/>
      如果指定了 <paramref name="lNewSetting" />，则返回之前的设置。
    </returns>
    <remarks>
      SetSoftSeek() 启用相对寻址，这是一种搜索命令并返回记录的方法，即使未找到指定键的匹配项。
      当指定 TRUE 时，如果未找到寻址操作的匹配项（例如 SEEK 命令或 DBSeek() 函数），记录指针将设置为下一个逻辑记录，具有比寻址参数更高的键值。由于 DBSetFilter()、SetDeleted() 或控制顺序的条件，未可见的记录在搜索下一个更高的键值时会被跳过。<br/>
      如果没有记录具有更高的键值，记录指针将定位在 LastRec() + 1，EOF() 返回 TRUE，Found() 返回 FALSE。只有实际找到记录时，Found() 才会返回 TRUE。<br/>
      对于相对查找，它永远不会返回 TRUE。<br/>
      当指定 FALSE 时，如果寻址操作不成功，记录指针将定位在 LastRec() + 1，EOF() 返回 TRUE，Found() 返回 FALSE。
    </remarks>
    <example>
      此示例从例程的开头开始相对寻址，并在例程结束时停止：
      <code language="X#">
        LOCAL lSSSetting AS LOGIC
        lSSSetting := SetSoftSeek(TRUE)
        SEEK UPPER("CarlM")
        ? Found()&#0009;&#0009;&#0009;// FALSE
        ? EOF()&#0009;&#0009;&#0009;// FALSE
        ? cName&#0009;&#0009;&#0009;// CarlT
        SetSoftSeek(lSSSetting)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrder'>DBSetOrder</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSetRelation'>DBSetRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.Found'>Found</seealso>
    <seealsocmd>SEEK</seealsocmd>
  </setsoftseek>

  <setthousandsep>
    <summary>
      返回并可选地更改在数字到字符串转换函数中使用的千位分隔符设置。
    </summary>
    <param name="nNewSetting">
      表示新的千位分隔符的 ASCII 代码。<br/>
      初始默认值取决于 SetInternational()，您可以参考以获取更多信息。
    </param>
    <returns>
      如果 <paramref name="nNewSetting" /> 未指定，SetThousandSep() 返回当前设置。<br/>
      如果指定了 <paramref name="nNewSetting" />，则返回之前的设置。
    </returns>
    <remarks>
      通常情况下，数值在没有千位分隔符的情况下显示，除非您明确指定数字使用了图像输出。图像输出是通过使用图像子句来实现的，可以通过 @...SAY...GET 命令、Transform() 函数或 FieldSpec:Picture 属性来定义。
      注意：<br/>
      在您的源代码中用于表示图像子句中千位分隔符的逗号字符不受此设置影响，正如用来表示小数分隔符的句点字符不受 SetDecimalSep() 影响一样。
      因此，您的源代码不会根据这些设置而变化，如下面的示例所示。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetDecimalSep'>SetDecimalSep</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
  </setthousandsep>

  <settimesep>
    <summary>
      更改用于时间字符串的分隔字符设置。
    </summary>
    <param name="dwNewSetting">
      用作时间字符串分隔符的字符的 ASCII 代码（例如，句点或破折号）。<br/>
      初始默认值为冒号 ( : )，其 ASCII 代码为 58。 （使用 GetTimeSep() 获取当前设置。）
    </param>
    <returns>
      之前的设置。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例将时间显示方式从 24:00:00 更改为 24.00.00：
      <code language="X#">
        FUNCTION Start()
        &#0009;SetTimeSep(Asc("."))
        &#0009;QOut(Time())&#0009;&#0009;&#0009;// 24.00.00
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Asc'>Asc</seealso>
    <seealso cref='O:XSharp.Core.Functions.Chr'>Chr</seealso>
    <seealso cref='O:XSharp.Core.Functions.GetTimeSep'>GetTimeSep</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDecimalSep'>SetDecimalSep</seealso>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
  </settimesep>

  <setunique>
    <summary>
      返回并可选地更改设置，以确定在顺序中是否包含唯一记录键。
    </summary>
    <param name="lNewSetting">
      TRUE 仅创建唯一记录的顺序； FALSE 创建所有记录的顺序，即使它们的键相同。<br/>
      初始默认值为 FALSE。
    </param>
    <returns>
      如果未指定 <paramref name="lNewSetting" />，SetUnique() 返回当前设置。<br/>
      如果指定了 <paramref name="lNewSetting" />，则返回之前的设置。
    </returns>
    <remarks>
      SetUnique() 是一个数据库函数，控制创建的顺序是否具有唯一性属性。当指定 TRUE 时，新创建的顺序仅包括唯一键。<br/>
      这与使用 INDEX...UNIQUE 命令创建顺序相同。
      在大多数基于 DBF 的 RDD 中，非唯一键的处理方式是只包括对特定键值的记录引用一次。因此，在创建或更新唯一顺序时，如果遇到两个或多个具有相同键值的记录，则仅第一个记录会被包含在顺序中。当唯一顺序被更新、重新索引或打包时，仅维护唯一记录，而不考虑当前的 SetUnique() 值。
      更改唯一顺序中的键值具有重要影响。首先，如果将唯一键更改为顺序中已存在的键的值，则更改的记录将从顺序中丢失。其次，如果数据库文件中有多个实例的键值，则更改可见键值不会在顺序中带来另一个具有相同键的记录，直到顺序被重建。
      当指定 FALSE 时，创建的顺序包含所有记录。对数据库文件的后续更新将将所有键值添加到顺序中，而不考虑当前的 UNIQUE 设置。
      请注意，已删除记录的键也会包含在索引中，并可能隐藏非删除记录的键。
    </remarks>
    <example>
      此示例设置一个例程，仅创建具有唯一键的记录的顺序：
      <code language="X#">
        LOCAL lUniqueSetting AS LOGIC
        lUniqueSetting := SetUnique(TRUE)
        MyFunc()
        SetUnique(lUniqueSetting)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealsocmd>INDEX</seealsocmd>
    <seealsocmd>PACK</seealsocmd>
    <seealsocmd>REINDEX</seealsocmd>
  </setunique>

  <setwipedynspace>
    <summary>
      设置 WipeDynSpace 的值。
    </summary>
    <param name="lWipe">
      用于设置 WipeDynSpace 开启和关闭的逻辑值。<br/>
      &#0009;TRUE 打开，FALSE 关闭。<br/>
      &#0009;注意，改变此设置将在下次垃圾收集器激活时生效。
    </param>
    <returns>
      WipeDynSpace 的现有值。
    </returns>
    <remarks>
      允许更改垃圾收集器的 WipeDynSpace 设置。
      使用此函数所做的更改将在下次垃圾收集器激活时生效。
      注意：此函数在 X# 的 2.7 版本中引入。在之前的版本中，此功能是通过每台机器上的注册表设置实现的。
    </remarks>
    <example>
    </example>
  </setwipedynspace>

  <seval>
    <summary>
      对字符串中的每个单个字符执行代码块。
    </summary>
    <param name="cString">要扫描的字符串。</param>
    <param name="cbBlock">对每个遇到的字符执行的代码块。</param>
    <param name="nStart">
      起始字符。<br/>
      负值从末尾开始。<br/>
      如果 <paramref name="nCount" /> 为正，则默认值为 1；如果 <paramref name="nCount" /> 为负，则默认值为 <paramref name="cString" /> 的长度。
    </param>
    <param name="nCount">
      从 <paramref name="nStart" /> 开始处理的字符数量。<br/>
      负值向下计数。<br/>
      默认是字符串末尾的所有字符。
    </param>
    <returns>
      处理后字符串的字符。
    </returns>
    <remarks>
      SEval() 是一个字符函数，它对字符串中的每个字符评估一个代码块，传递 ASCII 值和字符索引作为参数。<br/>
      代码块的返回值被忽略。<br/>
      除非指定 <paramref name="nStart" /> 或 <paramref name="nCount" /> 参数，否则处理 <paramref name="cString" /> 中的所有字符。
    </remarks>
    <example>
      此示例使用 SEval() 从包含完整街道地址的字符串中提取街道号：
      <code language="X#">
        LOCAL cStreetNumber AS STRING
        LOCAL cAddress AS STRING
        cStreetNumber := NULL_STRING
        cAddress := "1209 West Golden Lane"
        SEval(cAddress, ;
        &#0009;&#0009;{|c| cStreetNumber += ;
        &#0009;&#0009;If(IsDigit(Chr(c)), Chr(c), NULL_STRING)})
        ? cStreetNumber&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 1209
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEval'>AEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbEval'>DBEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.QOut'>QOut</seealso>
    <seealso cref='O:XSharp.RT.Functions.SEvalA'>SEvalA</seealso>
  </seval>

  <sevala>
    <summary>
      对字符串中的每个单个字符执行代码块，并更改参数的内容以及返回值。
    </summary>
    <param name="cString">要扫描的字符串。</param>
    <param name="cbBlock">对每个遇到的字符执行的代码块。</param>
    <param name="iStart">
      起始字符。<br/>
      负值从末尾开始。<br/>
      如果 <paramref name="nCount" /> 为正，则默认值为 1；如果 <paramref name="nCount" /> 为负，则默认值为 <paramref name="cString" /> 的长度。
    </param>
    <param name="iCount">
      从 <paramref name="iStart" /> 开始处理的字符数量。<br/>
      负值向下计数。<br/>
      默认是字符串末尾的所有字符。
    </param>
    <returns>
      处理后字符串的字符。
    </returns>
    <remarks>
      SEvalA() 与 SEval() 相同，都是对字符串的每个字符评估一个代码块，并传递 ASCII 值和字符索引作为参数。<br/>
      唯一的区别是，SEval() 忽略代码块的返回值，而 SEvalA() 将返回值赋值给原始字符串。有关详细信息，请参阅 SEval()。
    </remarks>
    <example>
      此示例使用 SEvalA() 将字符串的一部分更改为大写：
      <code language="X#">
        LOCAL cString
        cString := "He was doa."
        ? SEvalA(cString,;
        &#0009;{|cChar| Asc(Upper(Chr(cCha-r)))}, 8, 3)
        // "He was DOA."
        ? cString&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// "He was DOA."
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AEvalA'>AEvalA</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbEval'>DBEval</seealso>
    <seealso cref='O:XSharp.RT.Functions.Eval'>Eval</seealso>
    <seealso cref='O:XSharp.RT.Functions.QOut'>QOut</seealso>
    <seealso cref='O:XSharp.RT.Functions.SEval'>SEval</seealso>
  </sevala>

  <shellautocomplete>
    <summary>
      允许用户通过按 TAB 键从自动建议列表中选择。
    </summary>
    <param name="hWnd">句柄 H</param>
    <param name="dwFlags"></param>
    <param name="SHACF_AUTOAPPEND_FORCE_OFF">忽略注册表默认值，强制关闭自动追加功能。此标志必须与一个或多个 SHACF_FILESYS* 或 SHACF_URL* 标志组合使用。</param>
    <param name="SHACF_AUTOAPPEND_FORCE_ON">忽略注册表值，强制开启自动追加功能。完成的字符串将在编辑框中显示，添加的字符将被高亮显示。此标志必须与一个或多个 SHACF_FILESYS* 或 SHACF_URL* 标志组合使用。</param>
    <param name="SHACF_AUTOSUGGEST_FORCE_OFF">忽略注册表默认值，强制关闭自动建议功能。此标志必须与一个或多个 SHACF_FILESYS* 或 SHACF_URL* 标志组合使用。</param>
    <param name="SHACF_AUTOSUGGEST_FORCE_ON">忽略注册表值，强制开启自动建议功能。将显示可能完成字符串的选择作为下拉列表，位于编辑框下方。此标志必须与一个或多个 SHACF_FILESYS* 或 SHACF_URL* 标志组合使用。</param>
    <param name="SHACF_DEFAULT">默认设置，相当于 SHACF_FILESYSTEM | SHACF_URLALL。SHACF_DEFAULT 不能与其他标志组合使用。</param>
    <param name="SHACF_FILESYSTEM">包含文件系统。</param>
    <param name="SHACF_URLALL">包含用户历史记录和最近使用列表中的 URL。相当于</param>
    <param name="SHACF_URLHISTORY">包含用户的历史记录列表中的 URL。</param>
    <param name="SHACF_URLMRU">包含用户最近使用列表中的 URL。</param>
    <param name="SHACF_USETAB">允许用户通过按 TAB 键从自动建议列表中选择。如果未设置此标志，则按 TAB 键将焦点移到下一个控件并关闭自动建议列表。如果设置了 SHACF_USETAB，则按 TAB 键将选择列表中的第一个项目。再次按 TAB 将选择列表中的下一个项目，依此类推。当用户到达列表末尾时，下一个 TAB 键按下将循环焦点返回到编辑控件。此标志必须与一个或多个 SHACF_FILESYS* 或 SHACF_URL* 标志组合使用。</param>
    <returns>
    </returns>
    <remarks>
      <note type="tip">
        这将需要版本 5.0 或更高版本的 shlwapi.dll
        支持的操作系统包括 Windows 2000、Windows NT 4.0（带 Internet Explorer 5）、Windows 98、Windows 95（带 Internet Explorer 5）
        这将需要包含 OLE 库或调用 CoInitialize(NULL) 以进行自动完成。CoInitialize 将在稍后调用 CoUninit。
      </note>
    </remarks>
    <example>
    </example>
    <seealsocmd>[****]</seealsocmd>
  </shellautocomplete>

  <showbitmap>
    <summary>
      在窗口或控件中显示位图。
    </summary>
    <param name="hWnd">要显示位图的窗口或控件的句柄。</param>
    <param name="cFileName">要显示的位图文件。</param>
    <param name="cTitle">窗口或控件的标题。</param>
    <returns>
      如果成功则为 TRUE，否则为 FALSE。
    </returns>
    <remarks>
      此函数允许您在窗口或控件中显示位图。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.StretchBitmap'>StretchBitmap</seealso>
  </showbitmap>

  <sin>
    <summary>
      计算一个数的正弦值。
    </summary>
    <param name="nNum">以弧度表示的角度。</param>
    <returns>
      指定角度的正弦值。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 Sin() 计算 2.7 的正弦值：
      <code language="X#">? Sin(2.7)&#0009;&#0009;&#0009;&#0009;// 0.43</code>
      此示例查找 60 度角的正弦值。<br/>
      第一步是将 60 度转换为弧度。这是通过将角度除以 180/PI 完成的：
      <code language="X#">? Sin(60/(180/PI))&#0009;&#0009;&#0009;// 0.87</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Cos'>Cos</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cot'>Cot</seealso>
    <seealso cref='O:XSharp.RT.Functions.Tan'>Tan</seealso>
  </sin>

  <slen>
    <summary>
      返回强类型字符串的长度。
    </summary>
    <param name="cString">要计数的字符串。</param>
    <returns>
      字符串的长度。<br/>
      如果字符串为 NULL_STRING，SLen() 返回 0。
    </returns>
    <remarks>
      SLen() 是 Len() 的类型版本。有关完整描述，请参见 Len()。
    </remarks>
    <example>
      此示例显示如何使用强类型来确定字符串的长度：
      <code language="X#">
        LOCAL cName AS STRING
        cName := "威廉·莎士比亚"
        ? SLen(cName)&#0009;&#0009;&#0009;&#0009;&#0009;// 19
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AllTrim'>AllTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.ALen'>ALen</seealso>
    <seealso cref='O:XSharp.RT.Functions.Len'>Len</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszLen'>PszLen</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.Trim'>Trim</seealso>
  </slen>

  <soundex>
    <summary>
      将字符串转换为 Soundex 形式。
    </summary>
    <param name="cString">要转换的字符串。</param>
    <returns>
      一个以字母字符开头并以三个数字结尾的 4 位字符串。
    </returns>
    <remarks>
      Soundex() 是一种字符函数，用于索引和搜索声音相似或发音匹配的项。<br/>
      它用于精确拼写不确定的字符键的应用，或者在拼写错误概率较高的情况下。拼写错误在实时交易系统中很常见，数据输入操作员通过电话接收信息。Soundex() 通过将声音相似的项聚集在相同的键值下实现。请注意，Soundex 方法并不是绝对的。拼写差异较大的键可能会导致相同的 Soundex 值。
    </remarks>
    <example>
      此示例使用 Soundex() 创建键值构建订单。<br/>
      然后它搜索销售员字段中找到的值：
      <code language="X#">
        USE sales
        INDEX ON Soundex(Salesman) TO salesman
        SEEK Soundex("史密斯")
        ? Found(), salesman&#0009;&#0009;&#0009;&#0009;// TRUE 史密斯
      </code>
      在这里，对上面相同键的搜索，但拼写不同：
      <code language="X#">
        SEEK Soundex("斯密斯")
        ? Found(), salesman&#0009;&#0009;&#0009;&#0009;// TRUE 史密斯
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
    <seealsocmd>INDEX</seealsocmd>
    <seealsocmd>LOCATE</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetSoftSeek'>SetSoftSeek</seealso>
  </soundex>

  <space>
    <summary>
      创建一串空格。
    </summary>
    <param name="dwSize">
      要返回的空格数量，最大为 MAX_ALLOC 字节。<br/>
      如果 <paramref name="dwSize" /> 为 0，Space() 返回 NULL_STRING。
    </param>
    <returns>
      一串空格。
    </returns>
    <remarks>
      Space() 类似于 Buffer()，但使用初始化字符为 " "。<br/>
      如果不需要初始化字符，则 Buffer() 更有效。Space() 也与 Replicate(" ", <paramref name="dwCount" />) 相同。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
    <seealso cref='O:XSharp.Core.Functions.Replicate'>Replicate</seealso>
  </space>

  <splitpath>
    <summary>
      将路径名拆分为其组件。
    </summary>
    <param name="pszPathName">要拆分的路径名。</param>
    <param name="pszDrive">
      驱动器字母后跟冒号。<paramref name="pszDrive" /> 必须包含 2 个字节，以及 1 个字节用于终止的 _Chr(0) 字符。
    </param>
    <param name="pszDir">
      目录，包括尾部斜杠。<br/>
      <paramref name="pszFile" /> 中可能同时存在正斜杠和反斜杠。<br/>
      正斜杠 (/) 会转换为反斜杠 (\)。<paramref name="pszDir" /> 必须包含 255 个字节，以及 1 个字节用于终止的 _Chr(0) 字符。
    </param>
    <param name="pszFile">
      文件名，不带扩展名。<paramref name="pszFile" /> 必须包含 255 个字节，以及 1 个字节用于终止的 _Chr(0) 字符。
    </param>
    <param name="pszExt">
      扩展名，包括前导句点。<paramref name="pszExt" /> 必须包含 7 个字节，以及 1 个字节用于终止的 _Chr(0) 字符。
    </param>
    <returns>
    </returns>
    <remarks>
      SplitPath() 将路径名拆分为其组件并将结果存储在提供的参数中。<br/>
      提供的参数必须有足够的空间来容纳拆分组件的最大可能大小。<br/>
      如果路径名中缺少任何组件，则相应的参数将被截断为 0 长度。
    </remarks>
    <example>
      此示例将完整路径名拆分为其四个组件：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL cDrive, cDir, cFile, cExt AS STRING
        &#0009;MySplitPath("c:\develop\myprg\hello.prg", ;
        &#0009;&#0009;@cDrive, @cDir, @cFile, @cExt)
        &#0009;? cDrive&#0009;&#0009;&#0009;// C:
        &#0009;? cDir&#0009;&#0009;&#0009;// \DEVELOP\MYPRG
        &#0009;? cFile&#0009;&#0009;&#0009;// HELLO
        &#0009;? cExt &#0009;&#0009;&#0009;// .PRG
        FUNCTION MySplitPath(cPath AS STRING,&#0009;;
        &#0009;cDrive REF STRING,&#0009;&#0009;&#0009;;
        &#0009;cDir REF STRING,&#0009;&#0009;&#0009;;
        &#0009;cFile REF STRING,&#0009;&#0009;&#0009;;
        &#0009;cExt REF STRING)
        &#0009;LOCAL pszPath, pszDrive, pszDir AS PSZ
        &#0009;LOCAL pszFile, pszExt AS PSZ
        &#0009;LOCAL cb
        &#0009;pszPath := MemAlloc(cb := SLen(cPath) + 1)
        &#0009;MemCopy(pszPath, PTR(_CAST, cPath), cb)
        &#0009;pszDrive := MemAlloc(2+1)
        &#0009;pszDir   := MemAlloc(255+1)
        &#0009;pszFile  := MemAlloc(255+1)
        &#0009;pszExt   := MemAlloc(7+1)
        &#0009;SplitPath(cPath, pszDrive, pszDir,&#0009;;
        &#0009;&#0009;pszFile, pszExt)
        &#0009;cDrive := Psz2String(pszDrive)
        &#0009;cDir   := Psz2String(pszDir)
        &#0009;cFile  := Psz2String(pszFile)
        &#0009;cExt   := Psz2String(pszExt)
        &#0009;MemFree(pszDrive)
        &#0009;MemFree(pszDir)
        &#0009;MemFree(pszFile)
        &#0009;MemFree(pszExt)
        &#0009;RETURN
      </code>
      此示例显示，如果路径名中缺少相应组件，则提供的参数将被截断为 0 长度：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL cDrive, cDir, cFile, cExt AS STRING
        &#0009;MySplitPath("c:\develop\myprg\hello", ;
        &#0009;&#0009;@cDrive, @cDir, @cFile, @cExt)
        &#0009;? cDrive&#0009;&#0009;&#0009;// C:
        &#0009;? cDir&#0009;&#0009;&#0009;// \DEVELOP\MYPRG
        &#0009;? cFile&#0009;&#0009;&#0009;// HELLO
        &#0009;? SLen(cExt) &#0009;&#0009;// 0
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.FPathName'>FPathName</seealso>
  </splitpath>

  <sqrt>
    <summary>
      返回正数的平方根。
    </summary>
    <param name="nNumber">
      需要取平方根的正数。<br/>
      负数 <paramref name="nNumber" /> 返回 0。
    </param>
    <returns>
      显示的小数位数仅由 SetDecimal() 决定，而与 SetFixed() 无关。
    </returns>
    <remarks>
      SqRt() 可用于任何数值计算中以计算平方根（例如，在计算标准差的表达式中）。
    </remarks>
    <example>
      这些示例展示了 SqRt() 的各种结果：
      <code language="X#">
        SetDecimal(5)
        ? SQRT(2)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 1.41421
        ? SQRT(4)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 2.00000
        ? SQRT(4) ^ 2&#0009;&#0009;&#0009;&#0009;// 4.00000
        ? SQRT(2) ^ 2&#0009;&#0009;&#0009;&#0009;// 2.00000
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetFixed'>SetFixed</seealso>
  </sqrt>

  <stod>
    <summary>
      将 ANSI 日期字符串转换为日期格式。
    </summary>
    <param name="cDate">
      ANSI 格式的日期，形式为 yyyymmdd。<br/>
      必须指定世纪数字。<br/>
      如果 <paramref name="cDate" /> 包含超过八个字符的日期，则多余的字符将被忽略。
    </param>
    <returns>
      当前 SetDateFormat() 或 SET DATE 格式的日期。如果 <paramref name="cDate" /> 不是有效的 ANSI 日期，则返回 NULL_DATE。
    </returns>
    <remarks>
      SToD() 是一个日期函数，将由 DToS() 函数创建的 ANSI 日期转换回标准日期格式。
    </remarks>
    <example>
      此示例显示 ANSI 日期的默认日期格式：
      <code language="X#">
        ? SToD("19981028")         &#0009;// 10/28/98
        ? SToD("981028")         &#0009;// NULL_DATE
        ? SToD("19981028extra")      // 10/28/98
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CToD'>CToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.CToDAnsi'>CToDAnsi</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToS'>DToS</seealso>
  </stod>

  <str>
    <summary>
      将数值表达式转换为字符串。
    </summary>
    <param name="nNumber">要转换为字符串的数值表达式。</param>
    <param name="nLength">
      要返回的字符串长度，包括小数位、小数点和符号。<br/>
      &#0009;值为 -1 表示禁止任何右侧填充。但是，小数位仍然根据 <paramref name="nDecimals" /> 指定的数量返回。<br/>
      &#0009;如果未指定 <paramref name="nLength" />，则由 SetDigit() 和 SetDigitFixed() 决定返回的数字位数。
    </param>
    <param name="nDecimals">
      返回值中的小数位数。<br/>
      值为 -1 表示仅返回小数点右侧的有效数字（见下例）。<br/>
      返回值中的整数位数仍由 <paramref name="nLength" /> 参数决定。<br/>
      &#0009;如果未指定 <paramref name="nDecimals" />，则由 SetDecimal() 和 SetFixed() 决定返回的小数位数。<br/>
      &#0009;小数点的表示由 SetDecimalSep() 的当前设置决定。
    </param>
    <returns>
      一个字符串，具有以下例外：
      &#0009; 如果 <paramref name="nNumber" /> 是产生数值溢出的表达式，则会产生运行时错误，该错误可以通过当前安装的错误处理程序处理。错误处理程序返回 "+INF" 或 "-INF"，表示最大可能的浮点数。<br/>
      &#0009;如果 <paramref name="nLength" /> 小于 <paramref name="nNumber" /> 中的整数位数，则结果将以科学计数法返回。<br/>
      如果科学计数法的结果不适合，则返回一系列星号。
      取整由以下内容决定：
      &#0009;如果 <paramref name="nLength" /> 小于返回字符串的小数部分所需的小数位数，则返回值四舍五入到可用的小数位数。
      &#0009;如果指定了 <paramref name="nLength" />，但省略了 <paramref name="nDecimals" />（没有小数位），则返回值四舍五入为整数。
      如果未指定 <paramref name="nLength" /> 和 <paramref name="nDecimals" />，则它们将从 FLOAT 内部浮点格式中获取，或者从 SetDigit() 中获取，如果内部数字位数为 0。<br/>
      如果 SetFixed() 或 SetDigitFixed() 为 TRUE，则这些值将被 SetDecimal() 或 SetDigit() 的值覆盖。
      如果 SetScience() 为 TRUE，则返回值将以科学计数法返回。此外，如果 SetDigit() 指定的数字小于 <paramref name="nNumber" /> 的整数位数，并且 SetDigitFixed() 设置为 TRUE，则结果将以科学计数法返回。但如果科学计数法不适合，则结果是一系列星号。
    </returns>
    <remarks>
      Str() 通常用于将数字连接到字符串。因此，它对于根据数字创建项的代码（例如，部件编号）以及创建结合数值和字符数据的订单键非常有用。
      Str() 类似于 Transform()，它使用掩码而不是长度和小数规格来格式化数字为字符串。
      Str() 的逆函数是 Val()，它将格式为字符串的数字转换为数值。
    </remarks>
    <example>
      这些示例演示了 Str() 返回值范围，具体取决于指定的参数：
      <code language="X#">
        nNumber := 123.45
        ? Str(nNumber)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;//      123.45
        ? Str(nNumber, 4)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 123.
        ? Str(nNumber, 2)&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// **
        ? Str(nNumber * 10, 7, 2)&#0009;&#0009;&#0009;&#0009;&#0009;// 1234.50
        ? Str(nNumber * 10, 12, 4)&#0009;&#0009;&#0009;&#0009;//    1234.5000
        ? Str(nNumber, 10, 1)&#0009;&#0009;&#0009;&#0009;&#0009;//      123.5
        ? Str(123.45, -1)&#0009;&#0009;&#0009;&#0009;&#0009;// 123.45
        ? Str(123.45, -1, 2)&#0009;&#0009;&#0009;&#0009;&#0009;// 123.45
        ? Str(0.45000, 12, -1)&#0009;&#0009;&#0009;&#0009;&#0009;//      0.45000
      </code>
      通常两个数字显示相同的结果，但它们内部存储的值不同。因此，等式测试将失败（返回 FALSE），除非您对每一侧进行四舍五入。以下是一个示例：
      <code language="X#">
        ? nNum
        // 显示与下面的 MyFunction() 相同
        ? MyFunction()
        // 显示与上面的 nNum 相同
        // 但内部不相等
        ? nNum = MyFunction()&#0009;&#0009;&#0009;&#0009;&#0009;// FALSE
        // 在四舍五入后它们相等
        ? Round(nNum, 0) == Round(MyFunction(), 0)&#0009;// TRUE
        // Val(Str()) 也是四舍五入
        ? Val(Str(nNum)) = Val(Str(MyFunction()))&#0009;&#0009;// TRUE
      </code>
      将 SetFloatDelta() 设置为比之前更高的值也具有相同效果：
      <code language="X#">
        SetFloatDelta(0.1)
        ? nNum == MyFunction()&#0009;&#0009;&#0009;&#0009;&#0009;// TRUE
      </code>
      当 Decimals 参数 > 0 且 Decimals 参数 > Length-2 时，此函数返回一串星号。
      如果数字不适合分配的空间，也会返回一串星号。
      示例：
      <code language="X#">
        &#0009;? Str(9,6,6)&#0009;=&gt; "******"
        &#0009;? Str(9,6,5)&#0009;=&gt; "******"
        &#0009;? Str(9,6,4)&#0009;=&gt; "9.0000"
        &#0009;? Str(9,6,3)&#0009;=&gt; " 9.000"
        &#0009;? Str(10,6,6)&#0009;=&gt; "******"
        &#0009;? Str(10,6,5)&#0009;=&gt; "******"
        &#0009;? Str(10,6,4)&#0009;=&gt; "******"
        &#0009;? Str(10,6,3)&#0009;=&gt; "10.000"
      </code>
      此示例使用 Str() 创建具有复合键的订单，键由订单号和客户名称组成：
      <code language="X#">
        USE customer NEW
        INDEX ON Str(NumOrders, 9) + Custname TO custord
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.NTrim'>NTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.Round'>Round</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDecimalSep'>SetDecimalSep</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDigit'>SetDigit</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDigitFixed'>SetDigitFixed</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetScience'>SetScience</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str1'>Str1</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str2'>Str2</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str3'>Str3</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrFloat'>StrFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrInt'>StrInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrLong'>StrLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.Transform'>Transform</seealso>
    <seealso cref='O:XSharp.RT.Functions.Val'>Val</seealso>
  </str>

  <str1>
    <summary>
      将数值表达式转换为字符串。
    </summary>
    <param name="fNumber">要转换的数值表达式。</param>
    <returns>
    </returns>
    <remarks>
      Str1() 是 Str() 数值函数的类型版本。有关详细描述，请参见 Str()。
    </remarks>
    <example>
      此示例展示了如何使用 Str1() 将数字转换为字符串：
      <code language="X#">
        LOCAL fNumber AS FLOAT
        fNumber := 123.45
        ? Str1(fNumber)&#0009;&#0009; //      123.45
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str2'>Str2</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str3'>Str3</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrFloat'>StrFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrInt'>StrInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrLong'>StrLong</seealso>
  </str1>

  <str2>
    <summary>
      将数值表达式转换为指定长度的字符串。
    </summary>
    <param name="fNumber">要转换的数值表达式。</param>
    <param name="dwLength">
      返回字符串的长度，包括小数位、小数点和符号。<br/>
      如果 <paramref name="siLength" /> 不够长以容纳整个数字，则结果将以科学计数法表示。
    </param>
    <returns>
    </returns>
    <remarks>
      Str2() 是 Str() 数值函数的类型版本，其中两个参数都是必需的。有关详细描述，请参见 Str()。
    </remarks>
    <example>
      这些示例展示了如何使用 Str2() 将数字转换为字符串：
      <code language="X#">
        LOCAL fNumber AS FLOAT
        fNumber := 123.45
        ? Str2(fNumber, 4)&#0009;&#0009;// 123.
        ? Str2(fNumber, 2)&#0009;&#0009;// **
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str1'>Str1</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str3'>Str3</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrFloat'>StrFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrInt'>StrInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrLong'>StrLong</seealso>
  </str2>

  <str3>
    <summary>
      将数值表达式转换为特定长度和小数位数的字符串。
    </summary>
    <param name="fNumber">要转换的数值表达式。</param>
    <param name="dwLength">
      返回字符串的长度，包括小数位、小数点和符号。<br/>
      如果 <paramref name="dwLength" /> 不够长以容纳整个数字，则结果将以科学计数法表示。
    </param>
    <param name="dwDecimals">要返回的小数位数。</param>
    <returns>
    </returns>
    <remarks>
      Str3() 是 Str() 数值函数的类型版本，其中三个参数都是必需的。有关详细描述，请参见 Str()。
    </remarks>
    <example>
      这些示例展示了如何使用 Str3() 将数字转换为字符串：
      <code language="X#">
        LOCAL fNumber AS FLOAT
        fNumber := 123.45
        ? Str3(fNumber, 10, 1)&#0009;&#0009;&#0009;//      123.5
        ? Str3(fNumber * 10, 7, 2)&#0009;&#0009;// 1234.50
        ? Str3(fNumber * 10, 12, 4)&#0009;&#0009;//    1234.5000
      </code>
      当 Decimals 参数 &gt; 0 且 Decimals 参数 &gt; Length-2 时，此函数返回一串星号。
      当数字不适合分配的空间时，也会返回一串星号。
      示例：
      <code language="X#">
        &#0009;? Str(9,6,6)&#0009;=&gt; "******"
        &#0009;? Str(9,6,5)&#0009;=&gt; "******"
        &#0009;? Str(9,6,4)&#0009;=&gt; "9.0000"
        &#0009;? Str(9,6,3)&#0009;=&gt; " 9.000"
        &#0009;? Str(10,6,6)&#0009;=&gt; "******"
        &#0009;? Str(10,6,5)&#0009;=&gt; "******"
        &#0009;? Str(10,6,4)&#0009;=&gt; "******"
        &#0009;? Str(10,6,3)&#0009;=&gt; "10.000"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str1'>Str1</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str2'>Str2</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrFloat'>StrFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrInt'>StrInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrLong'>StrLong</seealso>
  </str3>

  <stretchbitmap>
    <summary>
      显示拉伸或缩小以适应窗口或控件的位图。
    </summary>
    <param name="hWnd">要显示位图的窗口或控件的句柄。</param>
    <param name="cFileName">要显示的位图文件。</param>
    <param name="cTitle">窗口或控件的标题。</param>
    <returns>
      如果成功则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
      此函数允许您将位图拉伸或缩小以适应当前窗口或控件的大小，然后显示该位图。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.ShowBitmap'>ShowBitmap</seealso>
  </stretchbitmap>

  <strevaluate>
    <summary>
      允许在运行时对字符串进行文本替换。
    </summary>

    <param name="cString">包含一个或多个宏变量的字符串。</param>
    <returns>
      所有宏替换完成后的新字符串。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例演示了在运行时对包含宏变量的字符串使用 StrEvaluate()：
      <code language="X#">
        MEMVAR cOne
        LOCAL cTwo AS STRING
        cOne := "世界"
        ACCEPT "输入宏字符串 " TO cTwo
        // 如果你输入 "你好 &amp;cOne"（不带引号）
        ? cTwo&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 结果: "你好 &amp;cOne"
        ? StrEvaluate(cTwo)&#0009;&#0009;&#0009;// 结果: "你好 世界"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Evaluate'>Evaluate</seealso>
    <seealso cref='O:XSharp.RT.Functions.MAssign'>MAssign</seealso>
    <seealso cref='O:XSharp.RT.Functions.MCompile'>MCompile</seealso>
    <seealso cref='O:XSharp.RT.Functions.MExec'>MExec</seealso>
  </strevaluate>

  <strfloat>
    <summary>
      将浮点表达式转换为 PSZ。
    </summary>
    <param name="flSource">要转换的数值表达式。</param>
    <param name="dwLength">
      要返回的字符串长度，包括小数位、小数点和符号。<br/>
      如果 <paramref name="dwLength" /> 不够长以容纳整个数字，<br/>
      结果将以科学计数法表示。
    </param>
    <param name="dwDecimals">要返回的小数位数。</param>
    <returns>
    </returns>
    <remarks>
      StrFloat() 是 Str() 数值函数的类型版本，除了忽略 SetDecimalSep() 之外。有关详细描述，请参见 Str()。
    </remarks>
    <example>
      这些示例演示了根据指定参数返回的 StrFloat() 值范围：
      <code language="X#">
        LOCAL fNumber AS FLOAT
        fNumber := 123.45
        ? StrFloat(fNumber * 10, 7, 2)&#0009;&#0009;&#0009;// 1234.50
        ? StrFloat(fNumber * 10, 12, 4)&#0009;&#0009;// 1234.5000
        ? StrFloat(fNumber, 10, 1)&#0009;&#0009;&#0009;// 1234.5
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str1'>Str1</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str2'>Str2</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str3'>Str3</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrInt'>StrInt</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrLong'>StrLong</seealso>
  </strfloat>

  <string2atom>
    <summary>
      将字符串转换为符号。
    </summary>
    <param name="cString">要转换的字符串。</param>
    <returns>
      一个符号，如果该符号不存在，则会添加到原子表中。
    </returns>
    <remarks>
      String2Atom() 及其对应的 Symbol2String() 允许您以更理想或方便的形式操作符号。
    </remarks>
    <example>
      此示例使用 String2Atom() 将字符串的内容分配给符号：
      <code language="X#">
        LOCAL cMyName<br/>
        AS STRING
        LOCAL symMyName AS SYMBOL
        cMyName := "乔西"
        symMyName := String2Atom(cMyName)
        ? symMyName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 乔西
      </code>
      此示例展示了 String2Atom() 和 String2Symbol() 之间的差异，后者返回大写符号：
      <code language="X#">
        ? String2Atom("你好") = String2Symbol("你好")
        &#0009;// FALSE
        ? String2Atom("HELLO") = String2Symbol("你好")
        &#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsSymbol'>AsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.String2Symbol'>String2Symbol</seealso>
  </string2atom>

  <string2psz>
    <summary>
      将强类型字符串转换为以 NULL 结尾的字符串。
    </summary>
    <param name="cString">要转换的字符串。</param>
    <returns>
      如果成功，返回非零 PSZ；否则返回 NULL_PSZ。
    </returns>
    <remarks>
      String2Psz() 对于许多需要在参数列表中使用 PSZ 的 Windows 或 DLL 函数很有用。<br/>
      它检查 <paramref name="cString" /> 是否为 NULL_STRING。<br/>
      如果是，String2Psz() 返回一个指向包含 0x00 的静态字节指针。
      否则，它将在静态内存中分配一个缓冲区，将字符串内容复制到其中，并返回指向此缓冲区的指针。<br/>
      该指针成为一个隐藏的局部变量。<br/>
      如果调用 String2Psz() 的相应函数或方法超出作用域，分配的缓冲区将自动释放。此外，该指针不再有效。
      警告！请勿使用 String2Psz() 初始化全局变量！
    </remarks>
    <example>
      以下示例使用 Win32 API 函数 GetDriveType()。<br/>
      它展示了创建所需 PSZ 参数的三种不同方法：
      <code language="X#">
        LOCAL cDrive AS STRING
        LOCAL nType&#0009;<br/>
        AS INT
        cDrive := Upper(CurDrive()) + ":"
        //&#0009;版本 1：慢，创建了 cDrive 的副本
        nType := GetDriveType( String2Psz(cDrive) )
        //&#0009;版本 2：更好，没有创建 cDrive 的副本
        nType := GetDriveType( Cast2Psz(cDrive) )
        //&#0009;版本 3：最佳性能，根本没有函数调用
        //             但：没有检查 NULL_STRING
        nType := GetDriveType( PSZ(_CAST, cDrive) )
        DO CASE
        CASE nType = DRIVE_REMOTE
        &#0009;? cDrive + " 是网络驱动器"
        CASE nType = DRIVE_CDROM
        &#0009;? cDrive + " 是 CD-ROM"
        CASE nType = DRIVE_REMOVABLE
        &#0009;? cDrive + " 是软盘或 ZIP 驱动器"
        CASE nType = DRIVE_FIXED
        &#0009;? cDrive + " 是固定驱动器"
        CASE nType = DRIVE_RAMDISK
        &#0009;? cDrive + " 是 RAM 磁盘"
        ENDCASE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Cast2Psz'>Cast2Psz</seealso>
    <seealso cref='O:XSharp.RT.Functions.Psz2String'>Psz2String</seealso>
  </string2psz>

  <string2symbol>
    <summary>
      将字符串转换为大写符号。
    </summary>
    <param name="cString">要转换的字符串。</param>
    <returns>
      大写符号。<br/>
      如果该符号不存在，则会添加到原子表中。
    </returns>
    <remarks>
      String2Symbol() 在转换之前会将参数转换为大写。<br/>
      它与使用文字符号相同。
    </remarks>
    <example>
      此示例使用 String2Symbol() 将字符串的内容分配给符号：
      <code language="X#">
        LOCAL cMyName<br/>
        AS STRING
        LOCAL symMyName AS SYMBOL
        cMyName := "乔西"
        symMyName : = String2Symbol(cMyName)
        ? symMyName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// JOSIE
      </code>
      此示例展示了 String2Symbol() 和 # 符号之间的相似性：
      <code language="X#">
        ? String2Symbol("你好") = #你好&#0009;&#0009;// TRUE
        ? String2Symbol("HELLO") = #你好&#0009;&#0009;// TRUE
      </code>
      此示例展示了 String2Symbol() 和 String2Atom() 之间的差异，后者不改变大小写：
      <code language="X#">
        ? String2Atom("你好") = String2Symbol("你好")
        &#0009;// FALSE
        ? String2Atom("HELLO") = String2Symbol("你好")
        &#0009;// TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.AsSymbol'>AsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.String2Atom'>String2Atom</seealso>
  </string2symbol>

  <stringalloc>
    <summary>
      将字符串复制到新分配的内存块并返回指向该内存的 PSZ。
    </summary>
    <param name="cString">要复制的字符串。</param>
    <returns>
      指向新分配字符串的指针。
    </returns>
    <remarks>
      StringAlloc() 创建字符串的副本。<br/>
      新副本是一个 PSZ，指向与原始字符串不同的地址。<br/>
      新分配的字符串是一个静态对象，不会被垃圾收集器移动。请注意，通过 StringAlloc() 分配的存储必须通过 MemFree() 移除。
    </remarks>
    <example>
      此示例显示两个变量的存储地址：
      <code language="X#">
        LOCAL pszString AS PSZ
        LOCAL cString AS STRING
        cString := "CAVO2x tree"
        pszString := StringAlloc(cString)
        ? @cString
        ? @pszString&#0009;&#0009;// 与 cString 的存储地址不同
        MemFree(pszString)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.MemAlloc'>MemAlloc</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemFree'>MemFree</seealso>
    <seealso cref='O:XSharp.RT.Functions.PszAlloc'>PszAlloc</seealso>
  </stringalloc>

  <strint>
    <summary>
      将整数表达式转换为 PSZ。
    </summary>
    <param name="liNumber">要转换的整数表达式。</param>
    <param name="dwLength">
      要返回的字符串长度，包括小数位、小数点和符号。<br/>
      如果 <paramref name="dwLength" /> 不够长以容纳整个数字，结果将以科学计数法表示。
    </param>
    <param name="dwDecimals">要返回的小数位数。</param>
    <returns>
    </returns>
    <remarks>
      StrInt() 是 Str() 数值函数的类型版本，除了忽略 SetDecimalSep() 之外。有关详细描述，请参见 Str()。
    </remarks>
    <example>
      这些示例演示了根据指定参数返回的 StrInt() 值范围：
      <code language="X#">
        LOCAL iNumber AS INT
        iNumber := 123
        ? StrInt(iNumber,10, 0)&#0009;&#0009;&#0009;// 123
        ? StrInt(iNumber, 4, 0)&#0009;&#0009;&#0009;// 123
        ? StrInt(iNumber, 2, 0)&#0009;&#0009;&#0009;// **
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str1'>Str1</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str2'>Str2</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str3'>Str3</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrFloat'>StrFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrLong'>StrLong</seealso>
  </strint>

  <strlong>
    <summary>
      将长整型表达式转换为 PSZ。
    </summary>
    <param name="liNumber">要转换的长整型表达式。</param>
    <param name="dwLength">
      要返回的字符串长度，包括小数位、小数点和符号。<br/>
      如果 <paramref name="dwLength" /> 不够长以容纳整个数字，结果将以科学计数法表示。
    </param>
    <param name="dwDecimals">要返回的小数位数。</param>
    <returns>
    </returns>
    <remarks>
      StrLong() 是 Str() 数值函数的类型版本，除了忽略 SetDecimalSep() 之外。有关详细描述，请参见 Str()。
    </remarks>
    <example>
      这些示例演示了根据指定参数返回的 StrLong() 值范围：
      <code language="X#">
        LOCAL liNumber AS LONGINT
        liNumber := 12345L
        ? StrLong(liNumber, 5, 0)&#0009;&#0009;&#0009;// "12345"
        ? StrLong(liNumber, 4, 0)&#0009;&#0009;&#0009;//  "****"
        ? StrLong(liNumber, 2, 10)&#0009;&#0009;// "**"
        ? StrLong(liNumber * 10, 7, 2)&#0009;&#0009;// "****.**"
        ? StrLong(liNumber * 10, 12, 4)&#0009;// " 123450.0000"
        ? StrLong(liNumber, 10, 1)&#0009;&#0009;// " 12345.0"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str1'>Str1</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str2'>Str2</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str3'>Str3</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrFloat'>StrFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrInt'>StrInt</seealso>
  </strlong>

  <strtran>
    <summary>
      在字符串中搜索和替换字符。
    </summary>
    <param name="uTarget">要搜索的字符串。</param>
    <param name="uSearch">
      要搜索的子字符串。<br/>
      默认情况下，所有 <paramref name="uSearch" /> 的出现都会被替换，除非指定了 <paramref name="uStart" /> 或 <paramref name="uCount" />。注意，StrTran() 替换子字符串，因此不考虑完整单词。
    </param>
    <param name="uReplace">
      用于替换 <paramref name="cSearch" /> 的子字符串。<br/>
      如果未指定此参数，则 <paramref name="cSearch" /> 将被替换为 NULL_STRING。
    </param>
    <param name="uStart">
      要替换的第一个出现位置。<br/>
      如果省略此参数或为 0，默认值为 1。
    </param>
    <param name="uCount">
      要替换的出现次数。<br/>
      如果未指定此参数，默认值为全部。
    </param>
    <returns>
      一个新字符串，其中指定的 <paramref name="uSearch" /> 的出现被替换为 <paramref name="uReplace" />。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 StrTran() 将一个后现代的类比转换为一个著名的引用：
      <code language="X#">
        cString := "To compute or not to compute?"
        ? StrTran(cString, "compute", "be")
        // To be or not to be?
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.HardCR'>HardCR</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemoTran'>MemoTran</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Stuff'>Stuff</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </strtran>

  <strzero>
    <summary>
      将数字表达式转换为字符串，并用前导零而非空格填充。
    </summary>
    <param name="nNumber">要转换为字符串的数字表达式。</param>
    <param name="nLength">要返回的字符串长度，包括零、小数位、小数点和符号。</param>
    <param name="nDecimals">返回值的小数位数。</param>
    <returns>
      一个字符串。
    </returns>
    <remarks>
      StrZero() 在显示数字、从数字值生成代码（如零件编号）以及创建结合数字和字符数据的订单键时非常有用。 StrZero() 类似于 Str() 函数，但填充字符是零 ("0") 而不是空格。<br/>
      有关更多信息，请参见 Str() 函数。
    </remarks>
    <example>
      此示例使用 StrZero() 将三位数字转换为五个字符的字符串：
      <code language="X#">? StrZero(987, 5, 0)&#0009;&#0009;// "00987"</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.NTrim'>NTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Val'>Val</seealso>
  </strzero>

  <stuff>
    <summary>
      删除和插入字符串中的字符。
    </summary>
    <param name="cTarget">要插入和删除字符的字符串。</param>
    <param name="dwStart">
      在 <paramref name="cTarget" /> 中插入/删除发生的位置。
    </param>
    <param name="dwDelete">要删除的字符数。</param>
    <param name="cInsert">要插入的字符串。</param>
    <returns>
      删除指定字符并插入 <paramref name="cInsert" /> 的 <paramref name="cTarget" />。
    </returns>
    <remarks>
      Stuff() 首先从 <paramref name="cTarget" /> 中删除字符，然后将字符插入到结果字符串中以形成返回字符串。 Stuff() 可以执行以下六种操作：
      &#0009;插入：<br/>
      如果 <paramref name="dwDelete" /> 为 0，则不会从 <paramref name="cTarget" /> 中删除字符。 <paramref name="cInsert" /> 然后在 <paramref name="dwStart" /> 插入，返回整个字符串。<br/>
      例如，Stuff("My dog has fleas.", 12, 0, "no ") 返回 "My dog has no fleas."
      &#0009;替换：<br/>
      如果 <paramref name="cInsert" /> 的长度与 <paramref name="dwDelete" /> 相同，则 <paramref name="cInsert" /> 将替换从 <paramref name="dwStart" /> 开始的字符。<br/>
      删除的字符数与插入的字符数相同，结果字符串的长度与原始字符串相同。<br/>
      例如，Stuff("My dog has fleas.", 12, 5, "bones") 返回 "My dog has bones."
      &#0009;删除：<br/>
      如果 <paramref name="cInsert" /> 为 NULL_STRING，则删除 <paramref name="dwDelete" /> 指定的字符数，并返回未添加任何字符的字符串。<br/>
      例如，Stuff("My dog has fleas.", 1, 3, NULL_STRING) 返回 "dog has fleas."
      &#0009;替换并插入：<br/>
      如果 <paramref name="cInsert" /> 的长度大于 <paramref name="dwDelete" />，则替换从 <paramref name="dwStart" /> 开始的所有字符并插入 <paramref name="cInsert" /> 的其余部分。由于插入的字符数多于删除的字符数，结果字符串总是比原始字符串长。<br/>
      例如，Stuff("My dog has fleas.", 8, 3, "does not have") 返回 "My dog does not have fleas."
      &#0009;替换并删除：<br/>
      如果 <paramref name="cInsert" /> 的长度小于 <paramref name="dwDelete" />，则删除的字符数多于插入的字符数。<br/>
      因此，结果字符串将比原始字符串短。<br/>
      例如，Stuff("My dog has fleas.", 8, 3, "is") 返回 "My dog is fleas."
      &#0009;替换并删除剩余部分：<br/>
      如果 <paramref name="dwDelete" /> 大于或等于 <paramref name="cTarget" /> 中从 <paramref name="dwStart" /> 开始的剩余字符数，则在插入 <paramref name="cInsert" /> 之前删除所有剩余字符。<br/>
      例如，Stuff("My dog has fleas.", 8, 10, "is.") 返回 "My dog is."
    </remarks>
    <example>
      这些示例演示了 Stuff() 的六种基本操作：
      <code language="X#">
        // 插入
        ? Stuff("ABCDEF", 2, 0, "xyz")&#0009;&#0009;&#0009;// AxyzBCDEF
        // 替换
        ? Stuff("ABCDEF", 2, 3, "xyz")&#0009;&#0009;&#0009;// AxyzEF
        // 删除
        ? Stuff("ABCDEF", 2, 2, NULL_STRING)&#0009;// ADEF
        // 替换并插入
        ? Stuff("ABCDEF", 2, 1, "xyz")&#0009;&#0009;&#0009;// AxyzCDEF
        // 替换并删除
        ? Stuff("ABCDEF", 2, 4, "xyz")&#0009;&#0009;&#0009;// AxyzF
        // 替换并删除剩余部分
        ? Stuff("ABCDEF", 2, 10, "xyz")&#0009;&#0009;// Axyz
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
    <seealso cref='O:XSharp.RT.Functions.StrTran'>StrTran</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </stuff>

  <substr>
    <summary>
      从字符串中提取子字符串。
    </summary>
    <param name="cTarget">要从中提取子字符串的字符串。</param>
    <param name="nStart">
      在 <paramref name="cTarget" /> 中的起始位置。<br/>
      如果 <paramref name="wStart" /> 为正，则相对于 <paramref name="cTarget" /> 的最左侧字符。<br/>
      如果 <paramref name="nStart" /> 为负，则相对于 <paramref name="cTarget" /> 的最右侧字符。<br/>
      如果 <paramref name="nStart" /> 为零，则返回 NULL_STRING。
    </param>
    <param name="nCount">
      要提取的字符数。<br/>
      如果省略，则子字符串从 <paramref name="nStart" /> 开始，一直到字符串末尾。<br/>
      如果 <paramref name="nCount" /> 大于从 <paramref name="nStart" /> 到 <paramref name="cTarget" /> 末尾的字符数，则多余的部分将被忽略。
    </param>
    <returns>
      子字符串。<br/>
      如果未找到子字符串，则返回 NULL_STRING。
    </returns>
    <remarks>
      Substr() 与 Left() 和 Right() 函数相关，这些函数分别提取以 <paramref name="cTarget" /> 中的最左侧和最右侧字符开始的子字符串。<br/>
      Substr()、Right() 和 Left() 函数通常与 At() 和 RAt() 函数一起使用，以定位子字符串的第一个和/或最后一个位置，然后提取它。<br/>
      他们也用于仅显示或打印字符串的一部分。
    </remarks>
    <example>
      这些示例从变量中提取名字和姓氏：
      <code language="X#">
        cName := "Biff Styvesent"
        ? Substr(cName, 1, 4)&#0009;&#0009;&#0009;&#0009;// Biff
        ? Substr(cName, 6)&#0009;&#0009;&#0009;&#0009;&#0009;// Styvesent
        ? Substr(cName, SLen(cName) + 2)
        // Null string
        ? Substr(cName, -9)&#0009;&#0009;&#0009;&#0009;&#0009;// Styvesent
        ? Substr(cName, -9, 3)&#0009;&#0009;&#0009;&#0009;// Sty
      </code>
      此示例使用 Substr() 与 At() 和 RAt() 来创建一个函数，从文件规范中提取文件名：
      <code language="X#">
        ? FileBase("c:\prg\myfile.obj")&#0009;&#0009;// myfile.obj
        FUNCTION FileBase(cFile)
        &#0009;LOCAL nPos AS DWORD
        &#0009;IF (nPos := RAt("\", cFile)) != 0
        &#0009;&#0009;cFile := Substr(cFile, nPos + 1)
        &#0009;ELSEIF (nPos := At(":", cFile)) != 0
        &#0009;&#0009;cFile := Substr(cFile, nPos + 1)
        &#0009;ENDIF
        &#0009;RETURN cFile
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.CharPos'>CharPos</seealso>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.Core.Functions.SubStr2'>Substr2</seealso>
    <seealso cref='O:XSharp.Core.Functions.SubStr3'>Substr3</seealso>
  </substr>

  <substr2>
    <summary>
      从字符串中提取子字符串，使用强类型并仅使用两个参数。
    </summary>
    <param name="cTarget">要从中提取子字符串的字符串。</param>
    <param name="dwStart">
      在 <paramref name="cTarget" /> 中的起始位置。由于此参数是一个 WORD，因此不能为负数。
    </param>
    <returns>
      子字符串。<br/>
      如果未找到子字符串，则返回 NULL_STRING。
    </returns>
    <remarks>
      Substr2() 是 Substr() 的类型版本。有关详细信息，请参见 Substr()。
    </remarks>
    <example>
      这些示例提取姓名的一部分：
      <code language="X#">
        LOCAL cName AS STRING
        cName := "Biff Styvesent"
        ? Substr2(cName, 6)&#0009;&#0009;&#0009;&#0009;&#0009;// Styvesent
        ? Substr2(cName, SLen(cName) + 2)&#0009;&#0009;// null string
      </code>
      此示例使用 Substr2() 与 At() 和 RAt() 创建一个函数，从文件规范中提取文件名：
      <code language="X#">
        ? FileBase("c:\prg\myfile.obj")&#0009;&#0009;// myfile.obj
        FUNCTION FileBase(cFile)
        &#0009;LOCAL nPos AS DWORD
        &#0009;IF (nPos := RAt("\", cFile)) != 0
        &#0009;&#0009;cFile := Substr2(cFile, nPos + 1)
        &#0009;ELSEIF (nPos := At(":", cFile)) != 0
        &#0009;&#0009;cFile := Substr2(cFile, nPos + 1)
        &#0009;ENDIF
        &#0009;RETURN cFile
      </code>
      &#0009;
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
    <seealso cref='O:XSharp.Core.Functions.SubStr3'>Substr3</seealso>
  </substr2>

  <substr3>
    <summary>
      从字符串中提取子字符串，使用强类型并需要三个参数。
    </summary>
    <param name="cTarget">要从中提取子字符串的字符串。</param>
    <param name="dwStart">
      在 <paramref name="cTarget" /> 中的起始位置。由于此参数是一个 WORD，因此不能为负数。
    </param>
    <param name="dwLen">
      要提取的字符数。<br/>
      如果省略，则子字符串从 <paramref name="dwStart" /> 开始，一直到字符串的末尾。<br/>
      如果 <paramref name="dwLen" /> 大于从 <paramref name="dwStart" /> 到 <paramref name="cTarget" /> 末尾的字符数，则多余的部分将被忽略。
    </param>
    <returns>
      子字符串。<br/>
      如果未找到子字符串，则返回 NULL_STRING。
    </returns>
    <remarks>
      Substr3() 是 Substr() 的类型版本，并需要三个参数。有关详细信息，请参见 Substr()。
    </remarks>
    <example>
      这些示例从变量中提取名字和姓氏：
      <code language="X#">
        LOCAL cName AS STRING
        cName := "Biff Styvesent"
        ? Substr3(cName, 1, 4)&#0009;&#0009;&#0009;&#0009;// Biff
        ? Substr3(cName, 6, 9)&#0009;&#0009;&#0009;&#0009;// Styvesent
        ? Substr3(cName, 6, 3)&#0009;&#0009;&#0009;&#0009;// Sty
        ? Substr3(cName, SLen(cName) + 2, 5)&#0009;// null string
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.At'>At</seealso>
    <seealso cref='O:XSharp.Core.Functions.Left'>Left</seealso>
    <seealso cref='O:XSharp.Core.Functions.RAt'>RAt</seealso>
    <seealso cref='O:XSharp.Core.Functions.Right'>Right</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
    <seealso cref='O:XSharp.Core.Functions.SubStr2'>Substr2</seealso>
  </substr3>

  <swapbyte>
    <summary>
      交换字节的左右半部分。
    </summary>
    <param name="bSwap">要交换nibbles的字节。</param>
    <returns>
      交换nibbles后的字节值。
    </returns>
    <remarks>
      SwapByte() 交换字节的右nibble和左nibble，并返回结果。<br/>
      （一个nibble是4位，是字节的一半。）
    </remarks>
    <example>
      此示例使用SwapByte()对字符"A"进行操作。<br/>
      "A"的ASCII值为65，因此其二进制表示为0100 0001。交换后得到0001 0100。<br/>
      因此，返回的ASCII值为20。
      <code language="X#">? SwapByte(Asc("A"))</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SwapDWord'>SwapDWord</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapInt'>SwapInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapLong'>SwapLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapShort'>SwapShort</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapWord'>SwapWord</seealso>
  </swapbyte>

  <swapdword>
    <summary>
      交换双字的左右半部分。
    </summary>
    <param name="dwSwap">要交换字的双字值。</param>
    <returns>
      交换后的双字。
    </returns>
    <remarks>
      SwapDWord() 交换双字的右半部分和左半部分，并返回结果。<br/>
      在交换过程中可能不保留符号。
    </remarks>
    <example>
      此示例使用SwapDWord():
      <code language="X#">
        bHex := 0x23CACE
        ? SwapDWord(bHex)&#0009;&#0009;// 返回3402498083
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SwapByte'>SwapByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapInt'>SwapInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapLong'>SwapLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapShort'>SwapShort</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapWord'>SwapWord</seealso>
  </swapdword>

  <swapint>
    <summary>
      交换整数的左右半部分。
    </summary>
    <param name="liSwap">要交换字节的整数。</param>
    <returns>
      交换后的整数。
    </returns>
    <remarks>
      SwapInt() 交换整数的右半部分和左半部分，并返回结果。<br/>
      在交换过程中可能不保留符号。
    </remarks>
    <example>
      此示例使用SwapInt():
      <code language="X#">? SwapInt(30001)&#0009;&#0009;// 1966145536</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SwapByte'>SwapByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapDWord'>SwapDWord</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapLong'>SwapLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapShort'>SwapShort</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapWord'>SwapWord</seealso>
  </swapint>

  <swaplong>
    <summary>
      交换长整数的左右半部分。
    </summary>
    <param name="liSwap">要交换字的长整数。</param>
    <returns>
      交换后的长整数。
    </returns>
    <remarks>
      SwapLong() 交换长整数的右半部分和左半部分，并返回结果。<br/>
      在交换过程中可能不保留符号。
    </remarks>
    <example>
      此示例使用SwapLong():
      <code language="X#">? SwapLong(256000000)&#0009;&#0009;// 1073745730</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SwapByte'>SwapByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapDWord'>SwapDWord</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapInt'>SwapInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapShort'>SwapShort</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapWord'>SwapWord</seealso>
  </swaplong>

  <swapshort>
    <summary>
      交换短整型的左右半部分。
    </summary>
    <param name="siSwap">要交换字节的短整型。</param>
    <returns>
      交换后的短整型。
    </returns>
    <remarks>
      SwapShort() 交换短整型的右半部分和左半部分，并返回结果。<br/>
      在交换过程中可能不保留符号。
    </remarks>
    <example>
      此示例使用SwapShort():
      <code language="X#">? SwapShort(-10000)&#0009;&#0009;&#0009;&#0009;// -3880</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SwapByte'>SwapByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapDWord'>SwapDWord</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapInt'>SwapInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapLong'>SwapLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapWord'>SwapWord</seealso>
  </swapshort>

  <swapword>
    <summary>
      交换字的左右半部分。
    </summary>
    <param name="wSwap">要交换字节的字。</param>
    <returns>
      交换后的字。
    </returns>
    <remarks>
      SwapWord() 交换字的右半部分和左半部分，并返回结果。
    </remarks>
    <example>
      此示例使用SwapWord():
      <code language="X#">
        aHex := 0xAB00
        ? SwapWord(aHex)&#0009;&#0009;&#0009;// 返回171
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.SwapByte'>SwapByte</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapDWord'>SwapDWord</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapInt'>SwapInt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapLong'>SwapLong</seealso>
    <seealso cref='O:XSharp.Core.Functions.SwapShort'>SwapShort</seealso>
  </swapword>

  <symbol2string>
    <summary>
      将符号转换为字符串。
    </summary>
    <param name="symVar">要转换的符号。</param>
    <returns>
      一个字符串。
    </returns>
    <remarks>
      由于符号的存储机制，符号可用的操作有限——您只能比较它们并操作其函数。<br/>
      使用Symbol2String()将符号转换为字符串可以使其访问所有字符串操作。
    </remarks>
    <example>
      此示例使用Symbol2String()将符号转换为字符串，以便可以进行字符串比较。由于符号是字面量符号，扫描器将其转换为大写：
      <code language="X#">
        LOCAL cMyName AS STRING
        LOCAL symMemoName AS SYMBOL
        cMyName := Symbol2String(#symMemoName)
        ? cMyName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 结果: SYMMEMONAME
        IF "MEMO" $ cMyName
        &#0009;? "符号名称包含字符串MEMO"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.String2Symbol'>String2Symbol</seealso>
  </symbol2string>

  <sysaddatom>
    <summary>
      将以空字符结尾的字符串转换为符号，并将其添加到原子表中。
    </summary>
    <param name="pszString">指向要转换的以空字符结尾的字符串的指针。</param>
    <returns>
      一个符号，如果尚未存在，则将其添加到原子表中。
    </returns>
    <remarks>
      <note type="tip">
        尽管文字符号被转换为大写字母，但使用SysAddAtom()创建的符号不会；SysAddAtom()保留函数参数中指定的字母大小写。另一方面，SysAddAtomUpperA()将其参数转换为大写，并以大写形式创建结果符号，类似于文字符号的处理方式。
      </note>
    </remarks>
    <example>
      此示例使用SysAddAtom()将名称转换为符号，并说明从MaxAtom()返回值如何随着每个字符串的转换而增加，从而增加当前使用的符号数量：(最后的转换不会增加符号数量，因为“Charly”之前已添加到符号表中)。
      <code language="X#">
        SysAddAtom("Vera")&#0009;&#0009;&#0009;// 转换Vera
        ? MaxAtom()&#0009;&#0009;&#0009;&#0009;&#0009;// 7531
        SysAddAtom("Charly")&#0009;&#0009;// 转换Charly
        ? MaxAtom()&#0009;&#0009;&#0009;&#0009;&#0009;// 7532
        SysAddAtom("Odile")&#0009;&#0009;&#0009;// 转换Odile
        ? MaxAtom()&#0009;&#0009;&#0009;&#0009;&#0009;// 7533
        SysAddAtom("Charly")&#0009;&#0009;// 转换Charly
        ? MaxAtom()&#0009;&#0009;&#0009;&#0009;&#0009;// 仍为7533
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.String2Symbol'>String2Symbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysAddAtomUpperA'>SysAddAtomUpperA</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysFindAtom'>SysFindAtom</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysGetAtomName'>SysGetAtomName</seealso>
  </sysaddatom>

  <sysaddatomuppera>
    <summary>
      将以空字符结尾的字符串转换为大写符号并添加到原子表中。
    </summary>
    <param name="pszString">要转换的以空字符结尾的字符串。</param>
    <returns>
      一个大写符号，如果尚未存在，则将其添加到原子表中。
    </returns>
    <remarks>
      SysAddAtomUpperA() 将其参数转换为大写并创建结果符号，类似于字面符号的处理方式。另一方面，SysAddAtom() 保留函数参数中指定的字母大小写。
    </remarks>
    <example>
      此示例使用 SysAddAtomUpperA：
      <code language="X#">
        LOCAL pszC := "Hello" AS PSZ
        ? SysAddAtomUpperA(pszC)&#0009;&#0009;&#0009;// HELLO
        ? pszC &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// "HELLO"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.String2Symbol'>String2Symbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysAddAtom'>SysAddAtom</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysFindAtom'>SysFindAtom</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysGetAtomName'>SysGetAtomName</seealso>
  </sysaddatomuppera>

  <sysfindatom>
    <summary>
      确定一个符号是否在原子表中。
    </summary>
    <param name="pszString">与要检查的符号对应的字符串。</param>
    <returns>
      如果找到，返回与字符串对应的符号值。<br/>
      如果未找到，返回一个对应于不存在符号的符号值，WORD(_CAST,65535)。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 SysFindAtom() 和类型转换来确定字符串 "Charly" 是否存在：
      <code language="X#">
        IF Word(_CAST, SysFindAtom("Charly")) ;
        &#0009;&#0009;&#0009;&#0009;= Word(_CAST, 65535)
        &#0009;? "未找到 Charly"
        ELSE
        &#0009;? "找到 Charly"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.SysAddAtom'>SysAddAtom</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysAddAtomUpperA'>SysAddAtomUpperA</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysGetAtomName'>SysGetAtomName</seealso>
  </sysfindatom>

  <sysgetatomname>
    <summary>
      将符号转换为以空字符结尾的字符串。
    </summary>
    <param name="symVar">要转换的符号。</param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 SysGetAtomName() 将符号转换为字符串：
      <code language="X#">
        symC := SysAddAtom("Chuck")
        ? SysGetAtomName(symC)   &#0009;&#0009;&#0009;// "Chuck"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Symbol2String'>Symbol2String</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysAddAtom'>SysAddAtom</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysAddAtomUpperA'>SysAddAtomUpperA</seealso>
    <seealso cref='O:XSharp.RT.Functions.SysFindAtom'>SysFindAtom</seealso>
  </sysgetatomname>

  <tan>
    <summary>
      计算一个数的正切值。
    </summary>
    <param name="nNum">以弧度为单位的角度。</param>
    <returns>
      指定角度的正切值。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例使用 Tan() 计算 1.38 弧度的正切值：
      <code language="X#">? Tan(1.38)&#0009;&#0009;&#0009;&#0009;// 5.18</code>
      此示例显示正切等于正弦除以余弦：
      <code language="X#">? Sin(1.38)/Cos(1.38)&#0009;&#0009;// 5.18</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ATan'>ATan</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cos'>Cos</seealso>
    <seealso cref='O:XSharp.RT.Functions.Cot'>Cot</seealso>
    <seealso cref='O:XSharp.RT.Functions.Sin'>Sin</seealso>
  </tan>

  <time>
    <summary>
      以由各种国际化设置决定的格式返回系统时间。
    </summary>
    <returns>
      返回值的格式取决于几个函数，包括SetAMPM()、SetAMExt()、SetPMExt()和SetInternational()，您可以参考这些函数获取更多信息。
    </returns>
    <remarks>
      Time()返回系统时间。Time()与Seconds()相关，后者返回表示自午夜以来秒数的整数值。
    </remarks>
    <example>
      这些示例展示了在不同情况下Time()的结果：
      <code language="X#">
        SetInternational(#Windows)
        // 假设在控制面板中设置了12小时制，带"AM"和"PM"后缀
        // 以及冒号分隔符
        ? Time()&#0009;&#0009;&#0009;&#0009;&#0009;// 02:37:17 PM
        SetInternational(#Clipper)
        ? Time()&#0009;&#0009;&#0009;&#0009;&#0009;// 14:37:19
        SetAMPM(TRUE)&#0009;&#0009;&#0009;// 12小时制
        SetPMExt(" pm")
        ? Time()&#0009;&#0009;&#0009;&#0009;&#0009;// 02:37:21 pm
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.ElapTime'>ElapTime</seealso>
    <seealso cref='O:XSharp.Core.Functions.Seconds'>Seconds</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAMExt'>SetAMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAmPm'>SetAMPM</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPMExt'>SetPMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetTimeSep'>SetTimeSep</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
    <seealso cref='O:XSharp.RT.Functions.Today'>Today</seealso>
  </time>

  <time24>
    <summary>
      以24小时格式返回系统时间。
    </summary>
    <returns>
      系统时间，格式为hh:mO:ss，其中hh为24小时制的小时，mm为分钟，ss为秒。
    </returns>
    <remarks>
      Time24()不依赖于任何其他设置来决定其输出格式。相反，它直接返回系统时间。Time()与Seconds()相关，后者返回表示自午夜以来秒数的整数值。
    </remarks>
    <example>
      这些示例展示了使用Substr()提取Time24()结果中的小时、分钟和秒：
      <code language="X#">
        ? Time24()&#0009;&#0009;&#0009;&#0009;// 10:37:17
        ? Substr3(Time24(), 1, 2)&#0009;&#0009;// 10
        ? Substr3(Time24(), 4, 2)&#0009;&#0009;// 37
        ? Substr3(Time24(), 7, 2)&#0009;&#0009;// 17
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Time'>Time</seealso>
  </time24>

  <today>
    <summary>
      将系统日期作为日期值返回。
    </summary>
    <returns>
    </returns>
    <remarks>
      此函数提供了一种将内存变量初始化为当前日期、将其他日期值与当前日期进行比较以及相对于当前日期执行日期运算的方法。
      日期的显示格式由SetDateFormat()和SET DATE命令控制。<br/>
      默认格式为mm/dd/yy。
    </remarks>
    <example>
      这些示例展示了Today()的各种用法：
      <code language="X#">
        ? Today()&#0009;&#0009;&#0009;&#0009;&#0009;// 09/09/98
        ? Today() + 30&#0009;&#0009;&#0009;&#0009;// 10/09/98
        ? Today() - 30&#0009;&#0009;&#0009;&#0009;// 08/10/98
        dDate := Today()
        ? CMonth(dDate)&#0009;&#0009;&#0009;// September
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.CToD'>CToD</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToC'>DToC</seealso>
    <seealso cref='O:XSharp.RT.Functions.DToS'>DToS</seealso>
    <seealsocmd>SET DATE</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetDateCountry'>SetDateCountry</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDateFormat'>SetDateFormat</seealso>
  </today>

  <tohira>
    <summary>
      将字符串中的单字节和双字节片假名字符转换为其双字节平假名等效字符。
    </summary>
    <param name="cMBTarget">要转换的字符串。</param>
    <returns>
      指定字符已更改的<paramref name="cMBTarget" />。
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.ToJNum'>ToJNum</seealso>
    <seealso cref='O:XSharp.VO.Functions.ToKata'>ToKata</seealso>
  </tohira>

  <tojnum>
    <summary>
      将字符串中的单字节和双字节数字转换为双字节汉字数字。
    </summary>
    <param name="cMBTarget">要转换的数字字符串。</param>
    <returns>
      指定数字已更改的<paramref name="cMBTarget" />。
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.ToHira'>ToHira</seealso>
    <seealso cref='O:XSharp.VO.Functions.ToKata'>ToKata</seealso>
  </tojnum>

  <tokata>
    <summary>
      将字符串中的单字节片假名和双字节平假名字符转换为其双字节片假名等效字符。
    </summary>
    <param name="cMBTarget">要转换的字符串。</param>
    <returns>
      指定字符已更改的<paramref name="cMBTarget" />。
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.VO.Functions.ToHira'>ToHira</seealso>
    <seealso cref='O:XSharp.VO.Functions.ToJNum'>ToJNum</seealso>
  </tokata>

  <tone>
    <summary>
      以指定的频率和持续时间发出扬声器音调。
      注意：<br/>
      Tone() 是一个兼容性函数，不再推荐使用。<br/>
      它被 Windows API 的 MessageBeep()、SndPlaySound() 和 MCI 系列函数所取代。MessageBeep() 在系统库中定义，而其他函数在 Win32 API 库中定义。要使用这些函数，您必须在应用程序的搜索路径中包含 Win32 API 库。
    </summary>
    <param name="wFrequency">要发出的音调的频率。</param>
    <param name="wDuration">
      音调的持续时间，以 1/18 秒为增量单位。<br/>
      例如，<paramref name="wDuration" /> 值为 18 表示一秒。<br/>
      &#0009;对于这两个参数，非整数值会被截断（而不是四舍五入）为其整数部分。
    </param>
    <returns>
    </returns>
    <remarks>
      Tone() 是一个声音函数，用于向用户指示各种程序状态。<br/>
      这些可以是错误状态、边界条件或耗时过程的结束。<br/>
      例如，错误状态会在向用户显示消息或交互对话框之前发出错误音。<br/>
      边界条件可能表示用户正试图在 TBrowse 对象的列中光标移动到顶部或底部之外。<br/>
      批处理过程也可能通过声音表示其完成，以提醒用户，以防用户已离开屏幕。
      Tone() 通过在指定频率下发出指定持续时间的扬声器声音来工作。<br/>
      持续时间以 1/18 秒为增量单位。<br/>
      频率以赫兹（每秒周期数）为单位。小于 20 的频率是听不见的。<br/>
      下表显示了标准音乐音符的频率。
      注意：<br/>
      Tone() 仅在 IBM PC 和 100% 兼容的计算机上工作。
      音高&#0009;频率&#0009;音高&#0009;频率&#0009;
      C&#0009;130.80&#0009;中央 C&#0009;261.70&#0009;
      C#&#0009;138.60&#0009;C#&#0009;277.20&#0009;
      D&#0009;146.80&#0009;D&#0009;293.70&#0009;
      D#&#0009;155.60&#0009;D#&#0009;311.10&#0009;
      E&#0009;164.80&#0009;E&#0009;329.60&#0009;
      F&#0009;174.60&#0009;F&#0009;349.20&#0009;
      F#&#0009;185.00&#0009;F#&#0009;370.00&#0009;
      G&#0009;196.00&#0009;G&#0009;392.00&#0009;
      G#&#0009;207.70&#0009;G#&#0009;415.30&#0009;
      A&#0009;220.00&#0009;A&#0009;440.00&#0009;
      A#&#0009;233.10&#0009;A#&#0009;466.20&#0009;
      B&#0009;246.90&#0009;B&#0009;493.90&#0009;
      &#0009;&#0009;C&#0009;523.30&#0009;
    </remarks>
    <example>
      这个例子是一个表示批处理操作已完成的蜂鸣函数：
      <code language="X#">
        FUNCTION DoneBeep()
        &#0009;Tone(300, 1)
        &#0009;Tone(100, 1)
        &#0009;Tone(300, 1)
        &#0009;Tone(100, 1)
      </code>
      这个例子是一个表示无效按键或边界条件的音调序列：
      <code language="X#">
        FUNCTION ErrorBeep()
        &#0009;Tone(100, 3)
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Chr'>Chr</seealso>
  </tone>

  <toword>
    <summary>
      将数字转换为字。
    </summary>
    <param name="nNumber">要转换为字的数字，范围在正负32,767之间（包含）。</param>
    <returns>
    </returns>
    <remarks>
      ToWord() 可用于需要字或首选字的情况，例如向DLL函数传递参数时。
      <note type="tip">
        ToWord() 与CA-Clipper中的Word()函数相同，但在X#中WORD是保留字。<br/>
        在X#中，Word()是一个转换操作符。对于不大于WORD类型数字的数字，它产生与ToWord()相同的结果，并保持与CA-Clipper的兼容性。
      </note>
    </remarks>
    <example>
      此示例使用ToWord()作为期望短整数的函数的参数：
      <code language="X#">
        LOCAL n := 30000 AS USUAL
        CProc(ToWord(n))
        FUNCTION CProc(siV AS SHORTINT)
        &#0009;? siV
      </code>
    </example>
  </toword>

  <transform>
    <summary>
      将任何值转换为格式化字符串。
    </summary>
    <param name="uValue">
      要格式化的值。<br/>
      此表达式可以是任何有效的X#数据类型，除了数组、代码块、对象和NIL。
    </param>
    <param name="cSayPicture">描述返回字符串格式的图片和模板字符串。</param>
    <returns>
      由<paramref name="cSayPicture" />定义的格式化字符串。
    </returns>
    <remarks>
      Transform()是一个转换函数，根据指定的图片字符串（包括图片函数和模板字符串的组合）格式化字符、日期、逻辑和数值。Transform()以与@...SAY命令的PICTURE子句相同的方式格式化数据以输出到屏幕或打印机。<br/>
      要将转换后的字符串转回其原始值，请使用Unformat()。
      函数字符串：<br/>
      图片函数字符串指定适用于整个Transform()返回值的格式化规则，而不是<paramref name="uValue" />中特定字符位置的规则。<br/>
      函数字符串由@字符开始，后跟一个或多个附加字符，每个字符都有特定含义（见下表）。<br/>
      如果存在函数字符串，@字符必须是图片字符串的最左侧字符，且函数字符串不得包含空格。<br/>
      函数字符串可以单独指定，也可以与模板字符串一起指定。<br/>
      如果两者都存在，函数字符串必须在模板字符串之前，两者必须用单个空格分隔。
      函数&#0009;动作&#0009;
      B&#0009;左对齐显示数字&#0009;
      C&#0009;在正数后显示CR&#0009;
      D&#0009;以SET DATE格式显示日期&#0009;
      E&#0009;以英国格式显示日期&#0009;
      R&#0009;插入非模板字符&#0009;
      X&#0009;在负数后显示DB&#0009;
      Z&#0009;将零显示为空格&#0009;
      (&#0009;将负数括在括号中&#0009;
      !&#0009;将字母字符转换为大写&#0009;
      模板字符串：<br/>
      图片模板字符串在字符基础上指定格式化规则。<br/>
      模板字符串由一系列字符组成，其中一些具有特殊含义（见下表）。<br/>
      模板字符串中的每个位置对应<paramref name="uValue" />参数值中的一个位置。由于Transform()使用模板，它可以插入格式化字符，如逗号、美元符号和括号。
      模板字符串中没有指定含义的字符会被逐字复制到返回值中。<br/>
      如果使用@R图片函数，这些字符会插入到返回值的字符之间；否则，它们会覆盖返回值中相应的字符。<br/>
      模板字符串可以单独指定，也可以与函数字符串一起指定。<br/>
      如果两者都存在，函数字符串必须在模板字符串之前，两者必须用单个空格分隔。
      模板&#0009;动作&#0009;
      A,N,X,9,#&#0009;显示任何数据类型的数字&#0009;
      L&#0009;将逻辑值显示为"T"或"F"&#0009;
      Y&#0009;将逻辑值显示为"Y"或"N"&#0009;
      !&#0009;将字母字符转换为大写&#0009;
      $&#0009;在数字的前导空格位置显示美元符号
      *&#0009;在数字的前导空格位置显示星号
      .&#0009;指定小数点位置&#0009;
      ,&#0009;指定逗号位置&#0009;
    </remarks>
    <example>
      此示例使用模板将数字格式化为货币格式：
      <code language="X#">? Transform(123456, "$999,999")&#0009;// 结果: $123,456</code>
      此示例使用函数格式化字符串：
      <code language="X#">? Transform("to upper", "@!")&#0009;&#0009;// 结果: TO UPPER</code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Lower'>Lower</seealso>
    <seealso cref='O:XSharp.RT.Functions.Pad'>Pad</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.Core.Functions.Upper'>Upper</seealso>
    <seealso cref='O:XSharp.RT.Functions.Unformat'>Unformat</seealso>
  </transform>

  <trim>
    <summary>
      删除字符串末尾的空格。
    </summary>
    <param name="cString">要修剪的字符串。</param>
    <returns>
      删除了末尾空格的<paramref name="cString" />。<br/>
      如果<paramref name="cString" />是NULL_STRING或全是空格，Trim()返回NULL_STRING。
    </returns>
    <remarks>
      Trim()用于通过删除末尾空格来格式化字符串，同时连接字符串。<br/>
      这通常发生在以固定宽度格式存储的数据库字段中。<br/>
      例如，您可以使用Trim()来连接名字和姓氏字段以形成名称字符串。
      Trim()与LTrim()（删除前导空格）和AllTrim()（删除前导和末尾空格）相关。<br/>
      AllTrim()、LTrim()和Trim()的逆操作是PadC()、PadR()和PadL()函数，它们通过用填充字符填充来使字符串居中、右对齐或左对齐。
    </remarks>
    <example>
      这是一个使用Trim()格式化城市、州和邮政编码字段用于标签或表格信件的函数：
      <code language="X#">
        FUNCTION CityState(cCity, cState, cZip)
        &#0009;RETURN Trim(cCity) + ", " ;
        &#0009;&#0009;&#0009;&#0009;+ Trim(cState) + "  " + cZip
      </code>
      为完成示例，函数CityState()显示CUSTOMER.DBF中的一条记录：
      <code language="X#">
        USE customer INDEX custname NEW
        SEEK "Kate"
        ? CityState(City, State, ZipCode)
        // Athens, GA 10066
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.AllTrim'>AllTrim</seealso>
    <seealso cref='O:XSharp.Core.Functions.LTrim'>LTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadC'>PadC</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadL'>PadL</seealso>
    <seealso cref='O:XSharp.RT.Functions.PadR'>PadR</seealso>
    <seealso cref='O:XSharp.Core.Functions.RTrim'>RTrim</seealso>
    <seealso cref='O:XSharp.RT.Functions.SubStr'>Substr</seealso>
  </trim>

  <tstring>
    <summary>
      将指定的秒数转换为时间字符串。
    </summary>
    <param name="nSeconds">要转换的秒数。</param>
    <returns>
      返回值的格式取决于几个函数，包括SetAMPM()、SetAMExt()、SetPMExt()和SetInternational()，您可以参考这些函数以获取更多信息。<br/>
      如果<paramref name="nSeconds" />大于86,400（一天的秒数），则返回超过整天数的秒数（参见下面的第二个示例）。
    </returns>
    <remarks>
      TString()将指定的秒数转换为时间字符串。Days()是一个相关函数，当<paramref name="nSeconds" />大于86,400时特别有用，因为它返回给定秒数中的完整天数。
    </remarks>
    <example>
      这个示例在小于86,400的数字上使用TString()。<br/>
      初始设置定义了12小时时间格式，上午和下午的扩展分别为" AM"和" PM"：
      <code language="X#">
        SetAMPM(TRUE)
        SetAMExt(" AM")
        SetPMExt(" PM")
        ? TString(6400)&#0009;&#0009;// 01:46:40 AM
      </code>
      这个示例将303,600传递给TString()。由于303,600秒等于3天11小时20分钟，TString()只返回超过整3天的时间。<br/>
      初始设置定义了24小时格式，没有上午或下午的扩展：
      <code language="X#">
        SetAMPM(FALSE)
        SetAMExt(NULL_STRING)
        SetPMExt(NULL_STRING)
        ? TString(303600)&#0009;&#0009;// 12:20:00
        ? Days(303600)&#0009;&#0009;&#0009;// 3
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.Days'>Days</seealso>
    <seealso cref='O:XSharp.Core.Functions.Secs'>Secs</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAMExt'>SetAMExt</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetAmPm'>SetAMPM</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetInternational'>SetInternational</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetPMExt'>SetPMExt</seealso>
  </tstring>

  <type>
    <summary>
      确定以字符串表示的表达式的数据类型。
    </summary>
    <param name="cString">
      包含要确定类型的表达式的字符串。<br/>
      它不能包含未声明的变量或不打算用于宏的函数。<br/>
      如果<paramref name="cString" />不存在，则返回"U"。
    </param>
    <returns>
      以下字符之一：
      返回值&#0009;含义&#0009;
      A&#0009;数组&#0009;
      B&#0009;代码块&#0009;
      C&#0009;字符串&#0009;
      D&#0009;日期&#0009;
      L&#0009;逻辑值&#0009;
      M&#0009;备注&#0009;
      N&#0009;数值&#0009;
      O&#0009;对象&#0009;
      U&#0009;NIL、局部变量或静态变量&#0009;
      UE&#0009;语法错误&#0009;
      UI&#0009;不确定错误&#0009;
    </returns>
    <remarks>
      Type()使用宏运算符(&amp;)来确定参数的数据类型；因此，您不能使用它来确定未声明变量或不打算用于宏的函数的数据类型。<br/>
      对于这些表达式，请使用UsualType()。
      <note type="tip">
        数组引用：对私有和公共数组的引用返回"A"。对数组元素的引用返回元素的类型。
        If()：<br/>
        要返回If()表达式的适当数据类型，Type()会评估条件，然后返回评估路径的类型。<br/>
        如果If()条件或评估路径无效，Type()返回"UE"。
        测试参数：Type()只能测试使用PARAMETERS语句接收的参数的有效性。测试作为FUNCTION或PROCEDURE声明的一部分声明的参数总是返回"U"，因为局部参数在符号表中没有符号。<br/>
        要确定参数是否被跳过或在参数列表末尾被省略，请将其与NIL比较或使用IsNil()。
      </note>
    </remarks>
    <example>
      这些示例演示了Type()调用的各种结果：
      <code language="X#">
        ? Type('Substr("Hi There", 4, 5)')&#0009;&#0009;// C
        ? Type("UdF()")&#0009;&#0009;&#0009;&#0009;&#0009;// UI
        ? Type('If(TRUE, "true", 12)')&#0009;&#0009;&#0009;// C
        PROCEDURE NilParameters()
        &#0009;PARAMETERS cParam1, nParam2, uParam3
        &#0009;IF cParam1 = NIL
        &#0009;&#0009;? "未传递第一个参数"
        &#0009;&#0009;cParam1 := "默认值"
        &#0009;ENDIF
        &#0009;IF Type("nParam2") = "U"
        &#0009;&#0009;? "未传递第二个参数"
        &#0009;ENDIF
        &#0009;IF IsNil(uParam3)
        &#0009;&#0009;? "未传递第三个参数"
        &#0009;ENDIF
        .
        . <paramref name="Statements" />
        .
      </code>
      这个示例展示了Type()、ValType()、UsualType()和UsualVal()之间的区别。注意，Type()在评估之前会宏展开字符串的内容，而UsualType()不会：
      <code language="X#">
        num := 10&#0009;&#0009;&#0009;&#0009;&#0009;// 未声明的变量
        ? Type("num + num")&#0009;&#0009;&#0009;// N
        ? ValType(num + num)&#0009;&#0009;// N
        ? UsualType("num + num")&#0009;&#0009;// 7 (代表STRING)
        ? UsualVal(num + num)&#0009;&#0009;// 20
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
  </type>

  <unformat>
    <summary>
      将转换后的字符串转回其原始值。
    </summary>
    <param name="cFormatString">要转换的字符串。</param>
    <param name="cSayPicture">原始值转换时使用的图片字符串。</param>
    <param name="cType">
      原始值的数据类型。<br/>
      可以是任何有效的 X# 数据类型，除了数组、代码块、对象和 NIL。
    </param>
    <returns>
      原始值。
    </returns>
    <remarks>
      Unformat() 是 Transform() 的逆操作。<br/>
      它使用图片字符串将通过 Transform() 函数转换成格式化字符串的值转回其原始值。<br/>
      它对于转换从包含图片字符的单行编辑框输入的数据很有用。
      <note type="tip">
        如果 Transform() 函数覆盖了原始值中的字符，被覆盖的字符将丢失，覆盖它们的字符将出现在其位置。<br/>
        此外，任何被截断的字符或数字都不会被恢复。
      </note>
    </remarks>
    <example>
      这个例子将货币格式的数字转回其原始数字格式：
      <code language="X#">
        ? Unformat("$123,456.78", "@R $999,999.99", "N")
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 结果：数值 123456.78
      </code>
      这个例子将格式化的字符串转回其未格式化状态：
      <code language="X#">
        ? Unformat("(516)555-1212", "@R (AAA)AAA-AAAA", "C")
        &#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 结果：字符串 5165551212
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Transform'>Transform</seealso>
    <seealso cref='O:XSharp.RT.Functions.Val'>Val</seealso>
  </unformat>

  <unregisteraxit>
    <summary>
      终止已通过 RegisterAxit() 注册的对象的注册。
    </summary>
    <param name="oObject">您想停止注册的对象。</param>
    <returns>
      如果成功则为 TRUE；否则为 FALSE。
    </returns>
    <remarks>
      当垃圾收集器调用 Axit() 方法时，它会在 Axit() 方法完成后自动终止对象的注册，因此只有当您在应用程序中直接或显式调用 Axit() 方法时，才需要 UnregisterAxit()。在调用 UnregisterAxit() 之前，请确保 InCollect() 为 FALSE。
    </remarks>
    <example>
      这个例子在检查 InCollect() 后调用 UnregisterAxit()：
      <code language="X#">
        IF !InCollect()
        &#0009;UnregisterAxit()
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.InCollect'>InCollect</seealso>
    <seealso cref='O:XSharp.RT.Functions.RegisterAxit'>RegisterAxit</seealso>
  </unregisteraxit>

  <unregisterkid>
    <summary>
      移除已注册到垃圾收集器的对象的注册。
    </summary>
    <param name="ptrObject">指向您想要取消注册的对象的指针。</param>
    <returns>
      如果成功则为 TRUE；否则为 FALSE。
    </returns>
    <remarks>
      UnregisterKid() 取消注册之前通过 RegisterKid() 函数注册以在垃圾收集后更新的对象。<br/>
      动态对象的指针再次受垃圾收集器的影响，可能在垃圾收集后变为无效。
    </remarks>
    <example>
      这个例子使用 UnregisterKid()：
      <code language="X#">
        STRUCTURE StrucMyStrings
        &#0009;MEMBER DIM aStr[10] AS PTR
        Function Start()
        &#0009;LOCAL wI AS DWORD
        &#0009;LOCAL strucMyArray AS StrucMyStrings
        &#0009;strucMyArray ;
        &#0009;&#0009;:= MemCAlloc(_SizeOf(StrucMyStrings), 1)
        &#0009;RegisterKid(strucMyArray, 10, FALSE)
        &#0009;FOR wI := 1 UPTO 10
        &#0009;&#0009;strucMyArray.aStr[wI] := Ptr(_CAST, STR(wI))
        &#0009;NEXT
        &#0009;CollectForced()&#0009;&#0009;&#0009;// 强制进行垃圾收集
        &#0009;UnregisterKid(strucMyArray)
        &#0009;// 收集完成：取消注册对象
        &#0009;// 对象在收集后仍然存在：
        &#0009;FOR wI := 1 UPTO 10
        &#0009;&#0009;MessageBox(0, strucMyArray.aStr[wI], ;
        &#0009;&#0009;&#0009;&#0009;Psz(wI), 0)
        &#0009;NEXT
        &#0009;MemFree(strucMyArray)
        &#0009;// 不要忘记在完成后释放分配的内存
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.RegisterAxit'>RegisterAxit</seealso>
    <seealso cref='O:XSharp.VO.Functions.RegisterKid'>RegisterKid</seealso>
  </unregisterkid>

  <unregisteroleautomati>
    <summary>
      移除先前注册为活动自动化服务器对象的X#对象的注册。
    </summary>
    <param name="oObject">注册为自动化服务器的对象。</param>
    <returns>
      如果操作成功则为TRUE；否则为FALSE。
    </returns>
    <remarks>
      UnRegisterOLEAutomationObject()取消注册先前通过调用RegisterOLEAutomationObject()注册的X#对象。
      注意：<br/>
      如果您使用AutoServer基类或GUI类中的Automated属性，则无需显式调用此函数。
      有关更多详细信息，请参阅在线帮助的"操作指南"部分中的"在Visual Objects中创建OLE服务器"。
    </remarks>
    <example>
    </example>
    <seealsocmd>CLASS AutoServer</seealsocmd>
    <seealsocmd>RegisterOLEAutomationObject</seealsocmd>
    <seealsocmd>Window:Automated</seealsocmd>
  </unregisteroleautomati>

  <upper>
    <summary>
      将字符串中的小写和混合大小写字符转换为大写。
    </summary>
    <param name="cString">要转换为大写的字符串。</param>
    <returns>
      将<paramref name="cString" />中的所有字母字符转换为大写。<br/>
      所有其他字符保持与原始字符串相同。
    </returns>
    <remarks>
      Upper()与Lower()相关，后者将大写和混合大小写字符串转换为小写。<br/>
      Upper()还与IsUpper()和IsLower()相关，它们用于确定字符串是否以大写或小写字母开头。
      Upper()通常用于格式化字符串以供显示。<br/>
      但是，它也可用于规范化字符串以进行不区分大小写的比较或索引。
      Upper()和UpperA()是与国家相关的。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.Lower'>Lower</seealso>
    <seealso cref='O:XSharp.Core.Functions.UpperA'>UpperA</seealso>
  </upper>

  <uppera>
    <summary>
      将字符串中的小写和混合大小写字符转换为大写，同时更改参数的内容和返回值。
    </summary>
    <param name="cString">要转换为大写的字符串。</param>
    <returns>
      将<paramref name="cString" />中的所有字母字符转换为大写。<br/>
      所有其他字符保持与原始字符串相同。
    </returns>
    <remarks>
      UpperA()类似于Upper()，但它同时更改参数的内容和返回值。有关详细信息，请参见Upper()。
      <note type="tip">
        您可以同时更改多个变量（请参见下面的示例）。
      </note>
    </remarks>
    <example>
      这些示例说明了UpperA()的效果。将它们与Upper()示例的结果进行比较：
      <code language="X#">
        LOCAL cName AS STRING
        cName := "noLi1"
        ? UpperA(cName)&#0009;&#0009;&#0009;&#0009;// NOLI1
        ? cName&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// NOLI1
      </code>
      此示例显示了如何同时更改多个变量：
      <code language="X#">
        a:= "i Change"
        b:= a
        UpperA(b)
        ? b // "I CHANGE"
        ? a // "I CHANGE"
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions.IsLower'>IsLower</seealso>
    <seealso cref='O:XSharp.Core.Functions.IsUpper'>IsUpper</seealso>
    <seealso cref='O:XSharp.Core.Functions.Lower'>Lower</seealso>
    <seealso cref='O:XSharp.Core.Functions.Upper'>Upper</seealso>
  </uppera>

  <used>
    <summary>
      确定数据库文件是否打开。
    </summary>
    <param name="uArea">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/uAreaValue/*" />
    </param>
    <returns>
      如果有数据库文件在使用中则为TRUE；否则为FALSE。
    </returns>
    <remarks>
      Used() 确定工作区中是否有数据库文件在使用中。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkareaParam/*" />
    </remarks>
    <example>
      此示例确定当前工作区中是否有数据库文件在使用：
      <code language="X#">
        USE customer NEW
        QOut(Used())&#0009;&#0009;&#0009;// 结果: TRUE
        CLOSE
        QOut(Used())&#0009;&#0009;&#0009;// 结果: FALSE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias'>Alias</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
    <seealsocmd>USE</seealsocmd>
  </used>

  <usualtype>
    <summary>
      确定表达式的数据类型。
    </summary>
    <param name="uValue">要返回其数据类型的表达式。</param>
    <returns>
      <paramref name="uValue" />的数据类型。<br/>
      返回值具有以下含义：
      返回值&#0009;含义&#0009;
      ARRAY&#0009;数组&#0009;
      CODEBLOCK&#0009;代码块&#0009;
      DATE&#0009;日期&#0009;
      FLOAT&#0009;浮点数, Real4, Real8&#0009;
      LOGIC&#0009;逻辑值&#0009;
      LONGINT&#0009;Byte, Word, DWord, ShortInt, Int, LongInt&#0009;
      OBJECT&#0009;对象或运行时代码块（见下面的示例）&#0009;
      VOID&#0009;NIL&#0009;
      PTR&#0009;指针&#0009;
      STRING&#0009;字符串, PSZ&#0009;
      SYMBOL&#0009;符号&#0009;
      如果<paramref name="uValue" />通过引用传递，返回值会自动加上128（见最后一个示例）。
    </returns>
    <remarks>
      UsualType() 不会宏展开字符串。<br/>
      UsualType() 比旧的ValType()函数更快，并提供更详细的信息。
    </remarks>
    <example>
      此示例根据变量的类型显示不同的结果：
      <code language="X#">
        xType := USUALTYPE(xVar)
        DO CASE
        CASE xType =STRING
        &#0009;? "字符串"
        CASE xType =LONGINT
        &#0009;? "长整型"
        CASE xType =DATE
        &#0009;? "日期"
        OTHERWISE&#0009;
        &#0009;? "其他类型之一"
        ENDCASE
      </code>
      这些示例展示了几种数据类型的数值返回值：
      <code language="X#">
        ? UsualType(1) = LONGINT&#0009;&#0009;&#0009;// TRUE
        ? UsualType("D. Lyon") = STRING&#0009;// TRUE
        ? UsualType(NIL)&#0009;= 0&#0009;&#0009;&#0009;// TRUE
        ? UsualType({"An Array"}) = ARRAY&#0009;// TRUE
        ? UsualType(block) = CODEBLOCK&#0009;&#0009;// TRUE
      </code>
      此示例展示了Type()、ValType()、UsualType()和UsualVal()之间的区别。注意，Type()在评估之前宏展开字符串的内容，而UsualType()不会：
      <code language="X#">
        num := 10&#0009;&#0009;&#0009;&#0009;&#0009;// 未声明的变量
        ? Type("num + num")&#0009;&#0009;&#0009;// N
        ? ValType(num + num)&#0009;&#0009;// N
        ? UsualType("num + num")&#0009;&#0009;// 7（代表STRING）
        ? UsualVal(num + num)&#0009;&#0009;// 20
      </code>
      此示例展示了编译时代码块和运行时代码块的UsualType()之间的区别：
      <code language="X#">
        // 硬编码的代码块在编译时可见：
        LOCAL cb := {||"编译时"}
        LOCAL ob
        // 代码块在引号内，因此编译器在编译时无法识别：
        ob := Evaluate("{||'运行时'}")
        ? UsualType(cb)&#0009;&#0009;&#0009;// CODEBLOCK
        ? UsualType(ob)&#0009;&#0009;&#0009;// OBJECT
      </code>
      此示例展示了当通过引用传递值时，返回值如何加上128：
      <code language="X#">
        FUNCTION PassRef()
        &#0009;LOCAL v AS STRING
        &#0009;v := NULL_STRING
        &#0009;AtFront(@v)
        FUNCTION AtFront(pv)
        &#0009;// @STRING
        &#0009;? UsualType(@pv)&#0009;&#0009;// 7 + 128 = 135
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IsArray'>IsArray</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsCodeBlock'>IsCodeBlock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsDate'>IsDate</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsFloat'>IsFloat</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLong'>IsLong</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsLogic'>IsLogic</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsMethodUsual'>IsMethodUsual</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNil'>IsNil</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsNumeric'>IsNumeric</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsObject'>IsObject</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsPtr'>IsPtr</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsString'>IsString</seealso>
    <seealso cref='O:XSharp.RT.Functions.IsSymbol'>IsSymbol</seealso>
    <seealso cref='O:XSharp.RT.Functions.Type'>Type</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualVal'>UsualVal</seealso>
    <seealso cref='O:XSharp.RT.Functions.ValType'>ValType</seealso>
  </usualtype>

  <usualval>
    <summary>
      <br/>
      访问地址的内容，无论它是否通过引用传递。
    </summary>
    <param name="uValue">
      任何类型的表达式。<br/>
      可以被引用或前面带有@符号。
    </param>
    <returns>
      <paramref name="uValue" />的实际内容，无论它是否被引用。
    </returns>
    <remarks>
      UsualVal()可用于检索通过引用传递或前面带有@符号的参数的内容。
    </remarks>
    <example>
      此示例展示了UsualVal()如何检索通过引用传递的参数的内容：
      <code language="X#">? UsualVal(@Var) = Var&#0009;&#0009;// TRUE</code>
      此示例展示了UsualVal()如何检索未通过引用传递的参数的内容：
      <code language="X#">? UsualVal(Var) = Var&#0009;&#0009;// TRUE</code>
      此示例展示了Type()、ValType()、UsualType()和UsualVal()之间的区别。注意，Type()在评估之前宏展开字符串的内容，而ValType()不会：
      <code language="X#">
        num := 10&#0009;&#0009;&#0009;&#0009;&#0009;// 未声明的变量
        ? Type("num + num")&#0009;&#0009;&#0009;// N
        ? ValType(num + num)&#0009;&#0009;// N
        ? UsualType("num + num")&#0009;&#0009;// 7（代表STRING）
        // 下面的参数未被引用
        ? UsualVal(num + num)&#0009;&#0009;// 20
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Type'>Type</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
    <seealso cref='O:XSharp.RT.Functions.ValType'>ValType</seealso>
  </usualval>

  <val>
    <summary>
      将包含数值的字符串转换为数值数据类型。
    </summary>
    <param name="cNumber">
      要转换的字符串。<paramref name="cNumber" /> 可以是任何编译器支持的基数格式，如二进制、十进制、十六进制或科学计数法。在科学计数法格式中，需要小数点来识别基数"E"。因此Val("1E+1")等于1，但Val("1.0E+1")等于10.0。此外，"+INF"和"-INF"（必须全部大写）分别表示正无穷和负无穷。
    </param>
    <returns>
      <paramref name="cNumber" /> 的数值。
    </returns>
    <remarks>
      如果 <paramref name="cNumber" /> 是有效的数值表达式，Val() 会处理全部内容。但是，如果 <paramref name="cNumber" /> 不完全是有效的数值表达式，但包含十进制数字，Val() 会一直评估直到遇到第二个小数点、第一个非数字字符或表达式结束。
      前导空格始终被忽略。
      所有包含 FLOAT 类型的变量都有内部的图片信息（类似模板），涉及数字和小数（参见 FloatFormat()）。<br/>
      对于 FLOAT 类型的数据库字段，这种图片信息存在于数据库头结构中，可以通过 FieldVal() 获取。
      对于 Val() 函数和文字浮点数（即在源代码中硬编码，因此在编译时已知），小数位数从硬编码的小数部分派生，而数字位数则取自 SetDigit() 或 SET DIGIT 设置。
      Str() 和 Transform() 与 Val() 密切相关，因为它们都将数值转换为字符串。
    </remarks>
    <example>
      此示例比较了 SetFixed() 为 TRUE 和 FALSE 时的结果：
      <code language="X#">
        FUNCTION Start()
        &#0009;SetDecimal(3)
        &#0009;SetFixed(FALSE)
        &#0009;? Val("12.1234")&#0009;&#0009;// 12.1234
        &#0009;SetFixed(TRUE)
        &#0009;? Val("12.1234")&#0009;&#0009;// 12.123
        &#0009;RETURN TRUE
      </code>
      这些示例展示了 SetFixed() 设置为 TRUE 且 SetDecimal() 设置为 2 时的 Val() 结果：
      <code language="X#">
        SetDecimal(2)
        SetFixed(TRUE)
        ? Val("12.1234")&#0009;&#0009;&#0009;// 12.12
        ? Val("12.1256")&#0009;&#0009;&#0009;// 12.13
        ? Val("12A12")&#0009;&#0009;&#0009;&#0009;// 12.00
        ? Val("A1212")&#0009;&#0009;&#0009;&#0009;// 0.00
        ? Val(Space(1))&#0009;&#0009;&#0009;// 0.00
        ? Val(" 12.12")&#0009;&#0009;&#0009;// 12.12
        ? Val("12 .12")&#0009;&#0009;&#0009;// 12.00
      </code>
      此示例将 Val() 应用于十六进制字符串：
      <code language="X#">? Val("0xFF")&#0009;&#0009;&#0009;&#0009;// 255</code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FloatFormat'>FloatFormat</seealso>
    <seealso cref='O:XSharp.RT.Functions.Round'>Round</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDecimal'>SetDecimal</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetFixed'>SetFixed</seealso>
    <seealso cref='O:XSharp.RT.Functions.Str'>Str</seealso>
    <seealso cref='O:XSharp.RT.Functions.Transform'>Transform</seealso>
  </val>

  <valtype>
    <summary>
      确定表达式的数据类型。
      注意：ValType() 是一个兼容性函数，不再推荐使用。<br/>
      UsualType() 和 IsNumeric() 运行更快，提供更多信息。
    </summary>
    <param name="uValue">
      要返回其数据类型的表达式。<br/>
      如果参数不存在，会发生"未定义错误"。
    </param>
    <returns>
      以下字符之一，表示 <paramref name="uValue" /> 的数据类型：
      字符&#0009;含义&#0009;
      A&#0009;数组&#0009;
      B&#0009;代码块&#0009;
      C&#0009;字符串, PSZ&#0009;
      D&#0009;日期&#0009;
      L&#0009;逻辑&#0009;
      N&#0009;LongInt, ShortInt, Byte, Word, Dword, Real4, Real8, Float, Numeric&#0009;
      O&#0009;对象&#0009;
      U&#0009;NIL&#0009;
      #&#0009;符号&#0009;
      -&#0009;PTR&#0009;
      如果 <paramref name="uValue" /> 通过引用传递，返回值前面会有一个 @ 符号（见第二个示例）。
    </returns>
    <remarks>
      ValType() 类似于 Type()，但不同之处在于它实际评估指定的参数并确定返回值的类型。<br/>
      因此，你可以确定局部变量、静态变量和函数的类型。相比之下，Type() 使用宏运算符 (&amp;) 来评估其参数的类型。
    </remarks>
    <example>
      此示例展示了 Type()、ValType()、UsualType() 和 UsualVal() 之间的区别。注意，Type() 在评估之前宏展开字符串的内容，而 ValType() 不会：
      <code language="X#">
        num := 10&#0009;&#0009;&#0009;&#0009;&#0009;// 未声明的变量
        ? Type("num + num")&#0009;&#0009;&#0009;// N
        ? ValType(num + num)&#0009;&#0009;// N
        ? UsualType("num + num")&#0009;&#0009;// 7（代表STRING）
        ? UsualVal(num + num)&#0009;&#0009;// 20
      </code>
      此示例展示了当通过引用传递值时，返回值如何加上 @：
      <code language="X#">
        FUNCTION PassRef()
        &#0009;LOCAL v AS STRING
        &#0009;AtFront(@v)
        FUNCTION AtFront(pv)
        &#0009;? ValType(@pv)&#0009;&#0009;&#0009;// @C
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Type'>Type</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualType'>UsualType</seealso>
    <seealso cref='O:XSharp.RT.Functions.UsualVal'>UsualVal</seealso>
  </valtype>

  <varget>
    <summary>
      返回字段或内存变量的内容。
    </summary>
    <param name="cVarName">字段或内存变量的名称。</param>
    <returns>
    </returns>
    <remarks>
      当字段或内存变量的名称在字符串中时，使用 VarGet() 代替宏。
    </remarks>
    <example>
      此示例使用 VarGet() 检索字段的内容：
      <code language="X#">
        LOCAL cFieldName := "Address"
        USE Customer
        // 使用以下代码替代 ? &amp;cFieldName：
        ? VarGet(cFieldName)&#0009;// 101 5th Street
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarGet'>IVarGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarGet'>MemVarGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.VarPut'>VarPut</seealso>
  </varget>

  <varput>
    <summary>
      将值分配给给定名称的字段或内存变量。
    </summary>
    <param name="cVarName">要创建的变量的名称。</param>
    <param name="uValue">要分配给变量的值。</param>
    <returns>
      分配给 (uValue) 的值。
    </returns>
    <remarks>
      如果名为 <paramref name="cVarName" /> 的字段或内存变量不存在，则会创建一个名为 <paramref name="cVarName" /> 的内存变量。<br/>
      因此，VarPut() 和 MemVarPut() 一样，可以用来创建未声明的内存变量。<br/>
      应该使用它来代替宏。
    </remarks>
    <example>
      此示例使用 VarPut() 将值存储到数据库字段中：
      <code language="X#">
        LOCAL cFieldName
        cFieldName := "Address"
        VarPut(cFieldName, "Hollywood, Room 222")
      </code>
      此示例使用 VarPut() 创建内存变量：
      <code language="X#">
        LOCAL cHasName
        cHasName := "cPrivate"
        // 使用以下代码替代 &amp;cHasName := "new"：
        VarPut(cHasName, "new")
        ? cPrivate&#0009;&#0009;&#0009;&#0009;&#0009;// new
      </code>
      此示例显示新创建的变量是 MEMVAR：
      <code language="X#">
        VarPut("cVar", "hi")
        ? _MEMVAR-&gt;cVar&#0009;&#0009;&#0009;// hi
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.IVarPut'>IVarPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.MemVarPut'>MemVarPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.VarGet'>VarGet</seealso>
  </varput>

  <verifythemestate>
    <summary>
      验证当前主题状态并设置 ThemeEnabled 标志
    </summary>
    <returns>
      该函数返回 ThemeEnabled 标志的当前值，类似于 IsThemeEnabled() 函数
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </verifythemestate>

  <version>
    <summary>
      返回您正在使用的 X# 版本。
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
  </version>

  <vodbalias>
    <summary>
      以字符串形式返回指定工作区的别名。
    </summary>

    <param name="wWorkArea">任何工作区编号。</param>
    <returns>
      如果没有使用数据库文件，VODBAlias() 返回 NULL_STRING。
    </returns>
    <remarks>
      VODBAlias() 类似于 Alias()，但具有强类型。更多信息和示例请参见 Alias()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias'>Alias</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbAliasSym'>VODBAliasSym</seealso>
  </vodbalias>

  <vodbaliassym>
    <summary>
      返回指定工作区的别名作为符号。
    </summary>
    <param name="wWorkArea">任何工作区编号。</param>
    <returns>
      指定工作区的别名作为符号。<br/>
      如果指定工作区没有使用数据库文件，VODBAlias() 返回 NULL_SYMBOL。
    </returns>
    <remarks>
    </remarks>
    <example>
      此示例打开一个文件，使用 VODBGetSelect() 函数确定当前工作区编号，然后获取与工作区关联的符号：
      <code language="X#">
        USE file1 NEW ALIAS test1
        nAlias := VODBGetSelect()
        sAlias := VODBAliasSym(nAlias)
        ? sAlias&#0009;&#0009;// 返回：test1
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Alias0Sym'>Alias0Sym</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbAlias'>VODBAlias</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbGetSelect'>VODBGetSelect</seealso>
  </vodbaliassym>

  <vodbappend>
    <summary>
      添加一条新记录。
    </summary>
    <param name="lReleaseLocks">TRUE 清除所有待处理的记录锁，然后追加下一条记录。FALSE 保持所有待处理的记录锁，将新记录添加到锁定列表的末尾。</param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBAppend() 类似于 DBAppend()，但具有强类型。<br/>
      然而，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息和示例，请参见 DBAppend()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbAppend'>DBAppend</seealso>
  </vodbappend>

  <vodbbof>
    <summary>
      确定是否遇到文件开头。
    </summary>
    <returns>
      在尝试向后跳过数据库文件中第一个逻辑记录之后，或者如果当前数据库文件不包含记录，则返回 TRUE；否则返回 FALSE。<br/>
      如果当前工作区没有打开的数据库文件，VODBBOF() 返回 TRUE。
    </returns>
    <remarks>
      VODBBOF() 与 BOF() 相同。有关更多信息和示例，请参见 BOF()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bof'>BOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbEof'>VODBEOF</seealso>
  </vodbbof>

  <vodbclearfilter>
    <summary>
      清除逻辑过滤条件。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBClearFilter() 与 DBClearFilter() 相同。<br/>
      然而，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息和示例，请参见 DBClearFilter()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearFilter'>DBClearFilter</seealso>
  </vodbclearfilter>

  <vodbclearlocate>
    <summary>
      通过删除定位代码块来清除定位条件。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBClearLocate() 通过删除定位代码块来清除定位条件。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      定位条件可以通过 DBLocate()、VODBLocate()、VODBSetLocate() 或 LOCATE 命令设置。
      请注意，此函数不调用错误处理程序，因此不会在失败时产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。
    </remarks>
    <example>
      此示例设置并检索定位代码块，针对当前记录进行评估，最后进行清理：
      <code language="X#">
        DBUseArea(TRUE, "DBFNTX", "address",;
        &#0009;&#0009;&#0009;&#0009;"Address", TRUE)
        VODBSetLocate({|| Name == "Odile"})
        // 处理过滤后的记录
        VODBClearLocate()
        // 处理未过滤的记录
        DBCloseArea()
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.VoDbSetLocate'>VODBSetLocate</seealso>
  </vodbclearlocate>

  <vodbclearrelation>
    <summary>
      清除所有活动关系。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBClearRelation() 与 DBClearRelation() 相同。<br/>
      然而，此函数不调用错误处理程序，因此不会在失败时产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息和示例，请参见 DBClearRelation()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearRelation'>DBClearRelation</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbSetRelation'>VODBSetRelation</seealso>
  </vodbclearrelation>

  <vodbclearscope>
    <summary>清除活动定位条件。</summary>
    <returns>如果成功则返回 TRUE；否则返回 FALSE。</returns>
    <remarks>
      此函数与 DBClearScope() 无关。
      那个函数清除当前索引的顶部范围和底部范围。
      <include file="CoreComments.xml" path="Comments/LastError/*" />
      <note type="tip">VoDbClearScope() 和 CoreDb.ClearScope() 是别名</note>
    </remarks>
  </vodbclearscope>

  <vodbcloseall>
    <summary>
      关闭所有工作区中的所有文件。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBCloseAll() 与 DBCloseAll() 相同。<br/>
      然而，此函数不调用错误处理程序，因此不会在失败时产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息，请参见 DBCloseAll()。
    </remarks>
    <example>
      以下示例关闭所有工作区：
      <code language="X#">
        LOCAL rddList       AS _RDDLIST
        ...
        aRdds := {"CAVODBF", "DBFNTX"}
        n       := ALen(aRdds)
        rddList := MemAlloc( (_SizeOf(DWORD)) + (n * _SizeOf(SYMBOL)) )
        rddList.uiRddCount := n
        FOR i := 1 TO n
        &#0009;rddList.atomRddName[i] := SysAddAtomUpperA(aRdds[i])
        NEXT
        VODBUseArea(TRUE, rddList, "sales", "sales", TRUE, FALSE)
        VODBOrdListAdd("Last", NIL)
        VODBUseArea(TRUE, rddList, "customer", "", TRUE, FALSE)
        MemFree(rddList)
        cLast := customer-&gt;last
        IF (Sales-&gt;(VODBSeek(cLast)))
        &#0009;IF Sales-&gt;(Deleted())
        &#0009;&#0009;IF RLock()
        &#0009;&#0009;&#0009;Sales-&gt;(VODBRecall())
        &#0009;&#0009;&#0009;? "已删除记录: ", sales;
        &#0009;&#0009;&#0009;&#0009;(Deleted())
        &#0009;&#0009;ENDIF
        &#0009;ENDIF
        ELSE
        &#0009;? "未找到"
        ENDIF
        VODBCloseAll()&#0009;&#0009;// 关闭所有工作区
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCloseAll'>DBCloseAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbCloseArea'>VODBCloseArea</seealso>
  </vodbcloseall>

  <vodbclosearea>
    <summary>
      关闭工作区中的所有文件。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBCloseArea() 与 DBCloseArea() 相同。<br/>
      然而，此函数不调用错误处理程序，因此不会在失败时产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息，请参见 DBCloseArea()。
    </remarks>
    <example>
      以下示例通过别名引用关闭文件：
      <code language="X#">
        LOCAL rddList       AS _RDDLIST
        ...
        aRdds := {"CAVODBF", "DBFNTX"}
        n       := ALen(aRdds)
        rddList := MemAlloc( (_SizeOf(DWORD)) + (n * _SizeOf(SYMBOL)) )
        rddList.uiRddCount := n
        FOR i := 1 TO n
        &#0009;rddList.atomRddName[i] := SysAddAtomUpperA(aRdds[i])
        NEXT
        cLast := "Winston"
        VODBUseArea(TRUE, rddList, "sales", "sales", TRUE, FALSE)
        VODBOrdListAdd("Last", NIL)
        MemFree(rddList)
        IF (VODBSeek(cLast))
        &#0009;IF Deleted() .AND. RLock()
        &#0009;&#0009;VODBRecall()
        &#0009;&#0009;? "已删除记录: ", Deleted()
        &#0009;ENDIF
        ELSE
        &#0009;? "未找到"
        ENDIF
        VODBCloseArea()
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCloseArea'>DBCloseArea</seealso>
  </vodbclosearea>

  <vodbcommit>
    <summary>
      刷新一个工作区中的待处理更新。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBCommit() 与 DBCommit() 相同。<br/>
      然而，此函数不调用错误处理程序，因此不会在失败时产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息和示例，请参见 DBCommit()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCommit'>DBCommit</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCommitAll'>DBCommitAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbCommitAll'>VODBCommitAll</seealso>
  </vodbcommit>

  <vodbcommitall>
    <summary>
      刷新所有工作区中的待处理更新。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBCommitAll() 与 DBCommitAll() 相同。<br/>
      然而，此函数不调用错误处理程序，因此不会在失败时产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息，请参见 DBCommitAll()。
    </remarks>
    <example>
      以下示例将所有待处理的更新写入磁盘：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL rddList       AS _RDDLIST
        &#0009;aRdds := {"CAVODBF", "DBFNTX"}
        &#0009;n       := ALen(aRdds)
        &#0009;rddList := MemAlloc( (_SizeOf(DWORD)) + (n * _SizeOf(SYMBOL)) )
        &#0009;rddList.uiRddCount := n
        &#0009;FOR i := 1 TO n
        &#0009;&#0009;rddList.atomRddName[i] := SysAddAtomUpperA(aRdds[i])
        &#0009;NEXT
        &#0009;cLast := "Winston"
        &#0009;VODBUseArea(TRUE, rddList, "sales", "sales", TRUE, FALSE)
        &#0009;VODBOrdListAdd("SaleFNam", NIL)
        &#0009;VODBOrdListAdd("SaleLNam", NIL)
        &#0009;VODBUseArea(TRUE, rddList, "colls", "colls", TRUE, FALSE)
        &#0009;VODBOrdListAdd("CollFNam", NIL)
        &#0009;VODBOrdListAdd("CollLNam", NIL)
        &#0009;MemFree(rddList)
        &#0009;DBSelectArea("sales")
        &#0009;// 选择 "sales" 工作区
        &#0009;IF (Sales-&gt;(VODBSeek(cLast)))
        &#0009;&#0009;IF Sales-&gt;(Deleted()) .AND. sales(RLock())
        &#0009;&#0009;&#0009;Sales-&gt;(VODBRecall())
        &#0009;&#0009;&#0009;? "已删除的记录已被恢复。"
        &#0009;&#0009;ENDIF
        &#0009;ELSE
        &#0009;&#0009;? "未找到"
        &#0009;ENDIF
        &#0009;// 处理完成，将更新写入磁盘并
        &#0009;// 关闭文件
        &#0009;VODBCommitAll()
        &#0009;VODBCloseAll()
        &#0009;RETURN TRUE
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCommit'>DBCommit</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCommitAll'>DBCommitAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbCommit'>VODBCommit</seealso>
  </vodbcommitall>

  <vodbcontinue>
    <summary>
      恢复挂起的定位条件。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBContinue() 与 DBContinue() 相同。<br/>
      然而，此函数不调用错误处理程序，因此不会在失败时产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息和示例，请参见 DBContinue()。
    </remarks>
    <example>
    </example>
    <seealsocmd>CONTINUE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.DbContinue'>DBContinue</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbLocate'>VODBLocate</seealso>
  </vodbcontinue>

  <vodbdelete>
    <summary>
      将当前记录标记为待删除。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBDelete() 与 DBDelete() 相同。<br/>
      然而，此函数不调用错误处理程序，因此不会在失败时产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息和示例，请参见 DBDelete()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDelete'>DBDelete</seealso>
    <seealso cref='O:XSharp.RT.Functions.Deleted'>Deleted</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbDeleted'>VODBDeleted</seealso>
  </vodbdelete>

  <vodbdeleted>
    <summary>
      返回当前记录的删除状态。
    </summary>
    <returns>
      如果当前记录被标记为删除则返回 TRUE；否则返回 FALSE。<br/>
      如果当前工作区中没有使用中的数据库文件，VODBDeleted() 返回 FALSE。
    </returns>
    <remarks>
      VODBDeleted() 与 Deleted() 相同。有关更多信息和示例，请参见 Deleted()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDelete'>DBDelete</seealso>
    <seealso cref='O:XSharp.RT.Functions.Deleted'>Deleted</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbDelete'>VODBDelete</seealso>
  </vodbdeleted>

  <vodbeof>
    <summary>
      确定是否遇到文件结束。
    </summary>
    <returns>
      当尝试将记录指针移动到数据库文件中最后一个逻辑记录之后，或者当前数据库文件不包含任何记录时，返回 TRUE；否则返回 FALSE。<br/>
      如果当前工作区中没有打开的数据库文件，VODBEOF() 返回 TRUE。
    </returns>
    <remarks>
      VODBEOF() 与 EOF() 相同。有关更多信息和示例，请参见 EOF()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Eof'>EOF</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbBof'>VODBBOF</seealso>
  </vodbeof>

  <vodbeval>
    <summary>
      对匹配指定范围和/或条件的每条记录评估代码块。
    </summary>

    <param name="cbExecute">对匹配范围和条件的每条记录执行的代码块。</param>
    <include file="VOSDK.xml" path="doc/commonblocks/scopeparams/*" />
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/recordscope/*" />
      VODBEval() 类似于 DBEval()，但具有强类型特性。<br/>
      然而，此函数不调用错误处理程序，因此不会在失败时产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息，请参见 DBEval()。
    </remarks>
    <example>
      此示例使用 VODBEval() 实现 Count() 函数，该函数计算工作区中匹配指定范围的记录数。<br/>
      范围作为数组传递给 Count()。<br/>
      一组常量定义了范围数组的元素：
      <code language="X#">
        // 范围属性常量
        DEFINE FOR_COND&#0009;&#0009;:=&#0009;1&#0009;AS SHORTINT
        DEFINE WHILE_COND&#0009;&#0009;:=&#0009;2&#0009;AS SHORTINT
        DEFINE NEXT_SCOPE&#0009;&#0009;:=&#0009;3&#0009;AS SHORTINT
        DEFINE REC_SCOPE&#0009;&#0009;:=&#0009;4&#0009;AS SHORTINT
        DEFINE REST_SCOPE&#0009;&#0009;:=&#0009;5&#0009;AS SHORTINT
        DEFINE SCOPE_ELEMENTS&#0009;:=&#0009;5&#0009;AS SHORTINT
        FUNCTION Start()
        &#0009;// 创建范围并使用它计数记录
        &#0009;LOCAL mySet[SCOPE_ELEMENTS]
        &#0009;LOCAL myCount AS LONGINT
        &#0009;USE customer NEW
        &#0009;mySet[FOR_COND] := {||customer = "Smith"}
        &#0009;mySet[WHILE_COND] := {||zip &gt; "90000"}
        &#0009;mySet[REST_SCOPE] := FALSE
        &#0009;// 每条记录（ALL）
        &#0009;myCount := Count(mySet)
        &#0009;RETURN TRUE
        FUNCTION Count(aScope) AS LONGINT
        &#0009;LOCAL nCount := 0 AS LONGINT
        &#0009;VODBEval({|| nCount++},;
        &#0009;&#0009;aScope[FOR_COND],;
        &#0009;&#0009;aScope[WHILE_COND],;
        &#0009;&#0009;aScope[NEXT_SCOPE],;
        &#0009;&#0009;aScope[REC_SCOPE],;
        &#0009;&#0009;aScope[REST_SCOPE])
        &#0009;RETURN nCount
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbEval'>DBEval</seealso>
  </vodbeval>

  <vodbfieldget>
    <summary>
      检索指定数据库字段的值。
    </summary>
    <param name="wFieldPos">当前工作区记录结构中字段的位置。</param>
    <param name="ptrRetVal">
      指向多态值的指针。<br/>
      如果函数成功，此值将接收请求的信息；否则保持不变。<br/>
      如果您只想检索信息，在调用函数之前此值必须为 NIL。<br/>
      &#0009;虽然其他 RDD 可能会扩展这个概念，但提供的 RDD 将使用非 NIL 值的情况限制在一种可以更改信息而不仅仅是检索信息的情况。对于 DBS_ALIAS <paramref name="kInfoType" />，您可以指定一个非 NIL 值，允许您指定一个字符串，随后可以用它来访问指定的字段。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBFieldGet() 类似于 FieldGet()，但具有强类型特性。有关更多信息和示例，请参见 FieldGet()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetSym'>FieldGetSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetAlias'>FieldGetAlias</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetArea'>FieldGetArea</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldPut'>VODBFieldPut</seealso>
  </vodbfieldget>

  <vodbfieldinfo>
    <summary>
      检索字段的定义信息。
    </summary>
    <param name="kInfoType">确定检索的信息类型。</param>
    <param name="wFieldPos">要获取信息的字段的位置编号。</param>
    <param name="ptrRetVal">
      指向多态值的指针。<br/>
      如果函数成功，此值将接收请求的信息；否则保持不变。<br/>
      如果您只想检索信息，在调用函数之前此值必须为 NIL。<br/>

      &#0009;虽然其他 RDD 可能会扩展这个概念，但提供的 RDD 将使用非 NIL 值的情况限制在一种可以更改信息而不仅仅是检索信息的情况。对于 DBS_ALIAS <paramref name="kInfoType" />，您可以指定一个非 NIL 值，允许您指定一个字符串，随后可以用它来访问指定的字段。
    </param>
    <param name="uNewValue">要分配给字段属性的新值。</param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBFieldInfo() 与 DBFieldInfo() 相同，除了其第三个参数的用途和它返回一个逻辑值这一事实。<br/>
      然而，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息，请参见 DBFieldInfo()。
    </remarks>
    <example>
      以下示例使用 VODBFieldInfo() 检索字段信息：
      <code language="X#">
        FUNCTION ShowFieldInfo(wField AS WORD) AS VOID
        &#0009;LOCAL uResult AS USUAL
        &#0009;uResult := NIL
        &#0009;IF VODBFieldInfo(DBS_NAME, wField, @uResult)
        &#0009;&#0009;? "FieldName(): ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;IF VODBFieldInfo(DBS_TYPE, wField, @uResult)
        &#0009;&#0009;? "字段类型: ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;IF VODBFieldInfo(DBS_LEN, wField, @uResult)
        &#0009;&#0009;? "字段长度: ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;IF VODBFieldInfo(DBS_DEC, wField, @uResult)
        &#0009;&#0009;? "小数位数: ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;RETURN
        STATIC FUNCTION DoError() AS USUAL
        &#0009;LOCAL uRetCode AS USUAL
        &#0009;LOCAL oError AS USUAL
        &#0009;oError := ErrorBuild(@strucErrInfo)
        &#0009;oError:FuncSym := #VODBFieldInfo
        &#0009;RETURN EVAL(ErrorBlock(), oError)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFieldInfo'>DBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbInfo'>VODBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbOrderInfo'>VODBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRecordInfo'>VODBRecordInfo</seealso>
  </vodbfieldinfo>

  <vodbfieldput>
    <summary>
      设置指定数据库字段的值。
    </summary>
    <param name="wFieldPos">当前数据库文件中字段的位置。</param>
    <param name="uNewValue">
      要分配给字段的值。<br/>
      此表达式的数据类型必须与指定字段变量的数据类型匹配。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBFieldPut() 类似于 FieldPut()，但具有强类型特性。有关更多信息，请参见 FieldPut()。
    </remarks>
    <example>
      此示例比较使用 VODBFieldPut() 为数据库的第一个字段分配值：
      <code language="X#">
        nField := 1
        // 使用 VODBFieldPut()
        VODBFieldPut(nField, "MyData")&#0009;// 设置字段值
        // 或：
        ? FIELDNAME(1)&#0009;// City（第一个字段的名称）
        City := "MyData"
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.FieldGet'>FieldGet</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldGetSym'>FieldGetSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPut'>FieldPut</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutSym'>FieldPutSym</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutAlias'>FieldPutAlias</seealso>
    <seealso cref='O:XSharp.RT.Functions.FieldPutArea'>FieldPutArea</seealso>
  </vodbfieldput>

  <vodbfilter>
    <summary>
      返回过滤器。
    </summary>
    <returns>
      当前工作区中定义的过滤条件。<br/>
      如果未设置过滤器，VODBFilter() 返回 NULL_STRING。
    </returns>
    <remarks>
      VODBFilter() 与 DBFilter() 相同。有关更多信息和示例，请参见 DBFilter()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbFilter'>DBFilter</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbClearFilter'>VODBClearFilter</seealso>
  </vodbfilter>

  <vodbflock>
    <summary>
      锁定已打开和共享的数据库文件。
    </summary>
    <returns>
      如果锁定成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBFLock() 与 FLock() 相同。<br/>
      然而，此函数不调用错误处理程序，因此不会在失败时产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息和示例，请参见 FLock()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Flock'>FLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRlock'>VODBRLock</seealso>
  </vodbflock>

  <vodbfound>
    <summary>
      确定上一次搜索操作是否成功。
    </summary>
    <returns>
      如果最后一个搜索命令成功则返回 TRUE；否则返回 FALSE。如果当前工作区中没有打开的数据库，VODBFound() 也将返回 FALSE。
    </returns>
    <remarks>
      VODBFound() 与 Found() 相同。有关更多信息和示例，请参见 Found()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Found'>Found</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbSeek'>VODBSeek</seealso>
  </vodbfound>

  <vodbgetselect>
    <summary>
      返回工作区编号。
    </summary>
    <returns>
      1 到 4096 之间的数字。
    </returns>
    <remarks>
      VODBGetSelect() 与 DBGetSelect() 相同。有关更多信息和示例，请参见 DBGetSelect()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbGetSelect'>DBGetSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbSelect'>VODBSelect</seealso>
  </vodbgetselect>

  <vodbgetselect1>
    <summary>
      返回某个别名的工作区编号
    </summary>
    <param name="sArea">要查找的别名名称。不区分大小写。</param>
    <returns>
      0 到 4096 之间的数字。当别名未在（当前线程中）使用时，返回值为 0。否则，它是具有此别名的区域的区域编号。
    </returns>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbGetSelect'>DBGetSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbSelect'>VODBSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.Alias'>Alias</seealso>
  </vodbgetselect1>

  <vodbgobottom>
    <summary>
      移动到最后一个逻辑记录。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBGoBottom() 与 DBGoBottom() 相同。<br/>
      然而，此函数不调用错误处理程序，因此不会在失败时产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息，请参见 DBGoBottom()。
    </remarks>
    <example>
      以下示例使用 VODBGoBottom() 将记录指针定位在最后一个逻辑记录上：
      <code language="X#">
        cLast := "Winston"
        DBUseArea(TRUE, "DBFNTX", "sales", "sales", TRUE)
        VODBOrdListAdd("lastname", NIL, NIL)
        Sales-&gt;(VODBGoBottom())
        IF (Sales-&gt;Last == "Winston")
        &#0009;IF Sales-&gt;(RLock())
        &#0009;&#0009;Sales-&gt;(VODBDelete())
        &#0009;&#0009;? "记录已删除: ", sales;
        &#0009;&#0009;&#0009;(VODBDeleted())
        &#0009;ELSE
        &#0009;&#0009;? "无法锁定记录..."
        &#0009;ENDIF
        END
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbGoBottom'>DBGoBottom</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoTop'>DBGoTop</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbGoTop'>VODBGoTop</seealso>
  </vodbgobottom>

  <vodbgoto>
    <summary>
      移动到由记录号指定的记录。
    </summary>
    <param name="uRecID">
      要移动到的记录 ID。<br/>
      如果 <paramref name="uRecID" /> 不存在，工作区将定位到 LastRec() + 1，并且 VODBEOF() 和 VODBBOF() 都返回 TRUE。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBGoTo() 类似于 DBGoTo()，但具有强类型。<br/>
      然而，此函数不调用错误处理程序，因此不会在失败时产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息和示例，请参见 DBGoTo()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbGoto'>DBGoTo</seealso>
  </vodbgoto>

  <vodbgotop>
    <summary>
      移动到第一个逻辑记录。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBGoTop() 与 DBGoTop() 相同。<br/>
      然而，此函数不调用错误处理程序，因此不会在失败时产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息和示例，请参见 DBGoTop()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbGoBottom'>DBGoBottom</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbGoTop'>DBGoTop</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbGoBottom'>VODBGoBottom</seealso>
  </vodbgotop>

  <vodbinfo>
    <summary>
      检索工作区的信息。
    </summary>
    <param name="kInfoType">确定检索的信息类型。</param>
    <param name="ptrRetVal">
      指向多态值的指针。<br/>
      如果函数成功，此值将接收请求的信息；否则保持不变。<br/>
      如果您只想检索信息，在调用函数之前此值必须为 NIL。<br/>
      &#0009;目前任何提供的 RDD 都不支持使用非 NIL 值。<br/>
      此功能保留给允许更改信息而不仅仅是检索信息的 RDD。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBInfo() 类似于 DBInfo()。<br/>
      然而，此函数不调用错误处理程序，因此不会在失败时产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息，请参见 DBInfo()。
    </remarks>
    <example>
      以下示例返回工作区信息：
      <code language="X#">
        FUNCTION ShowInfo() AS VOID
        &#0009;LOCAL uResult AS USUAL
        &#0009;uResult := NIL
        &#0009;IF VODBInfo(DBI_GETHEADERSIZE, @uResult)
        &#0009;&#0009;? "HEADER(): ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;IF VODBInfo(DBI_LASTUPDATE, @uResult)
        &#0009;&#0009;? "LUpdate(): ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;IF VODBInfo(DBI_GETRECSIZE, @uResult)
        &#0009;&#0009;? "RecSize(): ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;IF VODBInfo(DBI_FULLPATH, @uResult)
        &#0009;&#0009;? "PATHNAME: ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;RETURN
        STATIC FUNCTION DoError() AS USUAL
        &#0009;LOCAL uRetCode<br/>
        AS USUAL
        &#0009;LOCAL oError  <br/>
        AS USUAL
        &#0009;oError := ErrorBuild(@strucErrInfo)
        &#0009;oError:FuncSym := #VODBInfo
        &#0009;RETURN EVAL(ErrorBlock(), oError)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbInfo'>DBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddInfo'>RDDInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldInfo'>VODBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbOrderInfo'>VODBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRecordInfo'>VODBRecordInfo</seealso>
  </vodbinfo>

  <vodblastrec>
    <summary>
      返回数据库文件中最后一条记录的编号。
    </summary>
    <returns>
      数据库文件中的物理记录数。过滤或删除设置对返回值没有影响。如果没有正在使用的数据库文件，VODBLastRec() 返回 0。
    </returns>
    <remarks>
      VODBLastRec() 与 LastRec() 相同。有关更多信息和示例，请参见 LastRec()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.LastRec'>LastRec</seealso>
  </vodblastrec>

  <vodblocate>
    <summary>
      搜索符合指定条件和范围的第一条记录。
    </summary>
    <param name="cbForCondition">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/cbfor/*" />
    </param>
    <param name="cbWhileCondition">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/cbwhile/*" />
    </param>
    <param name="liNext">
      从当前记录开始要处理的记录数。<br/>
      要省略此参数，请指定 -1。
    </param>
    <param name="uRecord">
      要处理的记录编号。<br/>
      要省略此参数，请指定 -1。
    </param>
    <param name="lRest">TRUE 仅处理从当前记录到文件末尾的记录。FALSE 处理所有记录。</param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBLocate() 类似于 DBLocate()，但具有强类型。<br/>
      然而，此函数不调用错误处理程序，因此不会在失败时产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息，请参见 DBLocate()。
    </remarks>
    <example>
      以下示例定位过去 30 天内在洛杉矶市的第一笔销售：
      <code language="X#">
        USE sales
        VODBLocate({||City == "LA"}, {||SaleDay &gt; ;
        &#0009;TODAY()-30},-1,NIL,FALSE)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.ASort'>ASort</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbLocate'>DBLocate</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbSort'>DBSort</seealso>
  </vodblocate>

  <vodbordbagext>
    <summary>
      返回工作区的默认索引文件扩展名，由其 RDD 定义。
    </summary>
    <returns>
    </returns>
    <remarks>
      VODBOrdBagExt() 等同于调用 DBOrderInfo(DBOI_DEFBAGEXT)。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
  </vodbordbagext>

  <vodbordcondset>
    <summary>
      设置订单的条件和范围。
    </summary>
    <param name="ptrCondInfo">指向定义条件和范围信息的数据结构（_DBORDERCONDINFO）的指针。</param>
    <returns>
    </returns>
    <remarks>
      VODBOrdCondSet() 与 DBSetOrderCondition() 相同，但它是强类型的，并且条件信息是使用数据结构而不是单独的函数参数指定的。
      然而，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrderCondition'>DBSetOrderCondition</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbOrdCreate'>VODBOrdCreate</seealso>
  </vodbordcondset>

  <vodbordcreate>
    <summary>
      在索引文件中创建或替换订单。
    </summary>
    <param name="ptrCondInfo">
      指向定义条件和范围信息的数据结构（_DBORDERCONDINFO）的指针。<br/>
      &#0009;注意：有关其余参数的描述，请参见 DBCreateOrder()。
    </param>
    <returns>
    </returns>
    <remarks>
      VODBOrdCreate() 与 DBCreateOrder() 相同，但它是强类型的，<paramref name="cIndexFile" /> 和 <paramref name="cOrder" /> 参数的顺序相反，并且允许您使用数据结构指定条件信息。
      然而，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbCreateIndex'>DBCreateIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbCreateOrder'>DBCreateOrder</seealso>
  </vodbordcreate>

  <vodborddestroy>
    <summary>
      从打开的索引文件中删除订单。
    </summary>
    <returns>
    </returns>
    <remarks>
      VODBOrdDestroy() 与 DBDeleteOrder() 相同，但它是强类型的，并且参数的顺序相反。<br/>
      然而，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDeleteOrder'>DBDeleteOrder</seealso>
  </vodborddestroy>

  <vodborderinfo>
    <summary>
      返回有关索引文件及其中的订单的信息。
    </summary>
    <param name="kInfoType">确定检索的信息类型。这应该是备注部分中列出的 DBOI_ 常量之一</param>
    <param name="cIndexFile">
      打开的索引文件的名称（只需要八个字母的文件名）。<br/>
      与 <paramref name="cOrder" /> 一起使用此参数，以消除不同索引文件中存在两个或多个同名订单时的歧义。<br/>
      要省略此参数，请指定 NULL_STRING。
    </param>
    <param name="uOrder">
      &#0009;您想获取其信息的订单名称，或表示其在订单列表中位置的数字。<br/>
      要省略 <paramref name="cOrder" /> | <paramref name="nPosition" /> 参数，请指定 NIL。
    </param>
    <param name="ptrRetVal">
      指向多态值的指针。<br/>
      如果函数成功，此值将接收请求的信息，否则保持不变。<br/>
      如果您只想检索信息，在调用函数之前此值必须为 NIL。<br/>
      &#0009;目前任何提供的 RDD 都不支持使用非 NIL 值。<br/>
      此功能保留给允许更改信息而不仅仅是检索信息的 RDD。
    </param>
    <returns>
      如果成功则为 TRUE；否则为 FALSE。
    </returns>
    <remarks>
      VODBOrderInfo() 类似于 DBOrderInfo()。<br/>
      但是，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息，请参见 DBOrderInfo()。
      <include file="RTComments.xml" path="Comments/DBOI_Constants/*"  />
    </remarks>
    <example>
      以下示例返回订单访问信息：
      <code language="X#">
        FUNCTION ShowOrderInfo() AS VOID
        &#0009;LOCAL uResult AS USUAL
        &#0009;uResult := NIL
        &#0009;IF VODBOrderInfo(DBOI_EXPRESSION,"",0,@uResult)
        &#0009;&#0009;? "IndexKey(): ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;// 指定位置的记录号：
        &#0009;uResult := 100
        &#0009;IF VODBOrderInfo(DBOI_RECNO,"",0,@uResult)
        &#0009;&#0009;? "位置 100 的记录号：", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;IF VODBOrderInfo(DBOI_FULLPATH,"",0,@uResult)
        &#0009;&#0009;? "索引文件的完整路径：", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;RETURN
        STATIC FUNCTION DoError() AS USUAL
        &#0009;LOCAL uRetCode<br/>
        AS USUAL
        &#0009;LOCAL oError  <br/>
        AS USUAL
        &#0009;oError := ErrorBuild(@strucErrInfo)
        &#0009;oError:FuncSym := #VODBOrderInfo
        &#0009;RETURN EVAL(ErrorBlock(), oError)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbOrderInfo'>DBOrderInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldInfo'>VODBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbInfo'>VODBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRecordInfo'>VODBRecordInfo</seealso>
  </vodborderinfo>

  <vodbordlistadd>
    <summary>
      打开索引文件并将指定的订单添加到工作区的订单列表中。
    </summary>
    <returns>
    </returns>
    <remarks>
      VODBOrdListAdd() 与 DBSetIndex() 相同，只是它是强类型的。<br/>
      但是，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetIndex'>DBSetIndex</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbOrdCreate'>VODBOrdCreate</seealso>
  </vodbordlistadd>

  <vodbordlistclear>
    <summary>
      从工作区的订单列表中删除订单并关闭相关的索引文件。
    </summary>
    <returns>
    </returns>
    <remarks>
      VODBOrdListClear() 与 DBClearIndex() 相同，只是它是强类型的，并且参数顺序相反。<br/>
      但是，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbClearIndex'>DBClearIndex</seealso>
  </vodbordlistclear>

  <vodbordlistrebuild>
    <summary>
      重建工作区订单列表中的所有订单。
    </summary>
    <returns>
    </returns>
    <remarks>
      VODBOrdListRebuild() 与 DBReindex() 相同，只是它是强类型的。<br/>
      但是，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbReindex'>DbReindex</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbOrdCreate'>VoDbOrdCreate</seealso>
  </vodbordlistrebuild>

  <vodbordsetfocus>
    <summary>
      为工作区设置控制顺序。
    </summary>
    <returns>
      如果成功则为 TRUE；否则为 FALSE。
    </returns>
    <remarks>
      VODBOrdSetFocus() 与 DBSetOrder() 类似，但它是强类型的，并且参数顺序相反。<br/>
      此外，第三个参数 <paramref name="pszPreviousOrder" /> 指向旧的控制顺序。有关更多信息和示例，请参见 DBSetOrder()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetOrder'>DBSetOrder</seealso>
  </vodbordsetfocus>

  <vodbpack>
    <summary>
      从数据库文件中删除所有已标记为删除的记录。
    </summary>
    <returns>
      如果成功则为 TRUE；否则为 FALSE。
    </returns>
    <remarks>
      VODBPack() 与 DBPack() 相同。<br/>
      但是，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息和示例，请参见 DBPack()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbPack'>DBPack</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbDelete'>VODBDelete</seealso>
  </vodbpack>

  <vodbrddlist>
    <summary>
      获取正在使用的 RDD 列表。
    </summary>
    <param name="strucRDDList">
      _RDDLIST 类型的结构。_RDDLIST 定义如下：<br/>
      &#0009;MEMBER uiRDDCount AS DWORD<br/>
      &#0009;MEMBER DIM atomRDDName[1] AS SYMBOL<br/>
      &#0009;您必须为 <paramref name="strucRDDList" /> 分配足够的内存。<br/>
      使用 MemAlloc() 和 MemFree() 来分配和释放内存。<br/>
      内存必须足够大以容纳 uiRDDCount 成员和具有 RDDCount() 元素的 DIM 符号数组。通常，RDDCount() 的返回值被分配给 uiRDDCount。由于 uiRDDCount 成员是 WORD 类型，其大小由 _SizeOf(WORD) 给出。此外，具有 uiRDDCount (RDDCount()) 元素的 DIM 符号数组的大小等于 uiRDDCount * _SizeOf(SYMBOL)。
    </param>
    <param name="kRDDType">
      要包含在列表中的 RDD 类型。<br/>
      类型包括：
    </param>
    <param name="Constant">描述&#0009;</param>
    <param name="RDT_FULL">完全实现的 RDD&#0009;</param>
    <param name="RDT_TRANSFER">传输 RDD&#0009;</param>
    <param name="RDT_HIDDEN">特定 RDD&#0009;</param>
    <returns>
      如果成功则为 TRUE；否则为 FALSE。<br/>
      FALSE 返回值表示出错，但此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。
    </returns>
    <remarks>
    </remarks>
    <example>
      以下示例列出所有正在使用的 RDD：
      <code language="X#">
        FUNCTION QOutRDD() AS VOID PASCAL
        &#0009;LOCAL rddList AS _RDDLIST
        &#0009;LOCAL si AS SHORTINT
        &#0009;LOCAL wCount AS WORD
        &#0009;wCount := ;&#0009;RDDCount(RDT_FULL+RDT_TRANSFER+RDT_HIDDEN)
        &#0009;IF wCount &gt; 0
        &#0009;// 为一个 WORD（即 RDDlist.uiRDDCount）和
        &#0009;// 具有 wCount 元素的 DIM 符号数组分配内存
        &#0009;&#0009;RDDList := MemAlloc((_SizeOf(WORD)) +;
        &#0009;&#0009;&#0009;&#0009;(wCount * _SizeOf(SYMBOL)))
        &#0009;&#0009;RDDList.uiRDDCount := wCount
        &#0009;&#0009;IF VODBRDDList(rddList, ;
        &#0009;&#0009;&#0009;&#0009;RDT_FULL+RDT_TRANSFER+RDT_HIDDEN)
        &#0009;&#0009;&#0009;FOR si := 1 UPTO RDDList.uiRDDCount
        &#0009;&#0009;&#0009;&#0009;? RDDList.atomRDDName[si]
        &#0009;&#0009;&#0009;NEXT
        &#0009;&#0009;ENDIF
        &#0009;&#0009;MemFree(rddList)
        &#0009;ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.RddList'>RDDList</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddName'>VODBRDDName</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddSetDefault'>VODBRDDSetDefault</seealso>
  </vodbrddlist>

  <vodbrddname>
    <summary>
      返回 RDD 名称。
    </summary>
    <returns>
    </returns>
    <remarks>
      VODBRDDName() 与 RDDName() 相同。有关更多信息和示例，请参见 RDDName()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbDriver'>DBDriver</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddName'>RDDName</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddList'>VODBRDDList</seealso>
  </vodbrddname>

  <vodbrddsetdefault>
    <summary>
      返回并可选择更改应用程序的默认 RDD。
    </summary>
    <param name="cNewSetting">
      当未明确指定 RDD 时，用于激活和管理应用程序的 RDD 的名称。<br/>
      如果此 RDD 对应用程序不可用，则调用不会产生任何效果。
    </param>
    <returns>
      如果未指定 <paramref name="cNewSetting" />，VODBRDDSetDefault() 返回当前默认 RDD。<br/>
      如果指定了 <paramref name="cNewSetting" />，则返回先前的默认 RDD。
    </returns>
    <remarks>
      VODBRDDSetDefault() 类似于 RDDSetDefault()，但具有强类型。有关更多信息和示例，请参见 RDDSetDefault()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetDriver'>DBSetDriver</seealso>
    <seealso cref='O:XSharp.RT.Functions.RddSetDefault'>RDDSetDefault</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRddList'>VODBRDDList</seealso>
  </vodbrddsetdefault>

  <vodbrecall>
    <summary>
      如果当前记录被标记为删除，则恢复它。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBRecall() 与 DBRecall() 相同。<br/>
      但是，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息，请参见 DBRecall()。
    </remarks>
    <example>
      以下示例在记录被删除时恢复它，并在成功时尝试锁定记录：
      <code language="X#">
        LOCAL rddList       AS _RDDLIST
        ...
        aRdds := {"CAVODBF", "DBFNTX"}
        n       := ALen(aRdds)
        rddList := MemAlloc( (_SizeOf(DWORD)) + (n * _SizeOf(SYMBOL)) )
        rddList.uiRddCount := n
        FOR i := 1 TO n
        &#0009;rddList.atomRddName[i] := SysAddAtomUpperA(aRdds[i])
        NEXT
        cLast := "Winston"
        VODBUseArea(TRUE, rddList, "sales", "sales", TRUE, FALSE)
        VODBOrdListAdd("LastName", NIL, NIL)
        MemFree(rddList)
        IF (Sales-&gt;(VODBSeek(cLast)))
        &#0009;IF Sales-&gt;(VODBDeleted())
        &#0009;&#0009;IF Sales-&gt;(RLock())
        &#0009;&#0009;&#0009;Sales-&gt;(VODBRecall())
        &#0009;&#0009;&#0009;? "记录已恢复"
        &#0009;&#0009;ELSE
        &#0009;&#0009;&#0009;? "无法锁定记录..."
        &#0009;&#0009;ENDIF
        &#0009;ENDIF
        ELSE
        &#0009;? "未找到"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRecall'>DBRecall</seealso>
  </vodbrecall>

  <vodbrecno>
    <summary>
      返回当前记录号。
    </summary>
    <returns>
      当前记录号。<br/>
      如果工作区包含一个有 0 条记录的数据库文件，VODBRecNo() 返回 1，BOF() 和 EOF() 都返回 TRUE，LastRec() 返回 0。
      如果记录指针移动到最后一条记录之后，VODBRecNo() 返回 LastRec() + 1，EOF() 返回 TRUE。<br/>
      如果尝试移动到第一条记录之前，VODBRecNo() 返回数据库文件中第一个逻辑记录的记录号，BOF() 返回 TRUE。<br/>
      如果没有打开的数据库文件，VODBRecNo() 将返回 0。
    </returns>
    <remarks>
      VODBRecNo() 与 RecNo() 相同。有关更多信息和示例，请参见 RecNo()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.RecNo'>RecNo</seealso>
    <seealso cref='O:XSharp.RT.Functions.RecSize'>RecSize</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbRecordInfo'>VODBRecordInfo</seealso>
  </vodbrecno>

  <vodbrecordinfo>
    <summary>
      获取记录的信息。
    </summary>
    <param name="kInfoType">确定要检索的信息类型。</param>
    <param name="nRecID">
      要检索信息的记录ID。<br/>
      值为0L表示当前记录。
    </param>
    <param name="ptrRetVal">
      指向多态值的指针。<br/>
      如果函数成功，此值将接收请求的信息；否则保持不变。<br/>
      如果只想检索信息，在调用函数之前此值必须为NIL。<br/>
      &#0009;目前所提供的RDD不支持使用非NIL值。<br/>
      此功能保留给允许更改信息而不仅仅是检索信息的RDD。
    </param>
    <returns>
      如果成功则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
      VODBRecordInfo()类似于DBRecordInfo()。<br/>
      但是，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构StrucErrInfo将包含有关发生的任何错误的必要信息。有关更多信息，请参见DBRecordInfo()。
    </remarks>
    <example>
      以下示例检索记录信息：
      <code language="X#">
        FUNCTION ShowRecordInfo() AS VOID
        &#0009;LOCAL uResult AS USUAL
        &#0009;uResult := NIL
        &#0009;IF VODBRecordInfo(DBRI_LEN,0,@uResult)
        &#0009;&#0009;? "RecSize(): ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;IF VODBRecordInfo(DBRI_LOCKED,200,@uResult)
        &#0009;&#0009;? "记录200的锁定标志: ", uResult
        &#0009;ELSE
        &#0009;&#0009;DoError()
        &#0009;ENDIF
        &#0009;RETURN
        STATIC FUNCTION DoError() AS USUAL
        &#0009;LOCAL uRetCode<br/>
        AS USUAL
        &#0009;LOCAL oError  <br/>
        AS USUAL
        &#0009;oError := ErrorBuild(@strucErrInfo)
        &#0009;oError:FuncSym := #VODBRecordInfo
        &#0009;RETURN EVAL(ErrorBlock(), oError)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRecordInfo'>DBRecordInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbFieldInfo'>VODBFieldInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbInfo'>VODBInfo</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbOrderInfo'>VODBOrderInfo</seealso>
  </vodbrecordinfo>

  <vodbrelation>
    <summary>
      返回指定关系的链接表达式。
    </summary>
    <param name="wRelation">
      所需关系在当前工作区关系列表中的位置。<br/>
      关系按照使用SET RELATION定义的顺序编号。
    </param>
    <param name="pszRelation">
      所需关系在当前工作区关系列表中的位置。<br/>
      关系按照使用SET RELATION定义的顺序编号。
    </param>
    <returns>
      定义给<paramref name="wRelation" />的链接表达式。<br/>
      如果<paramref name="wRelation" />没有设置关系，VODBRelation()返回NULL_STRING。
      <br/>
      如果成功则返回TRUE；否则返回FALSE。
    </returns>
    <remarks>
      VODBSetRelation()类似于DBRelation()。有关更多信息和示例，请参见DBRelation()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRelation'>DBRelation</seealso>
  </vodbrelation>

  <vodbrlock>
    <summary>
      锁定当前记录。
    </summary>
    <param name="uRecID">
      要锁定的记录ID。<br/>
      要省略，请指定NIL。这将锁定当前记录并释放所有先前锁定的记录。
    </param>
    <returns>
      如果获得记录锁定则返回TRUE；否则返回FALSE。<br/>
      尝试锁定空数据库中的记录返回TRUE。
    </returns>
    <remarks>
      VODBRLock()类似于DBRLock()，但是强类型的。<br/>
      但是，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构StrucErrInfo将包含有关发生的任何错误的必要信息。有关更多信息和示例，请参见DBRLock()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRLock'>DBRLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.RLock'>RLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbAppend'>VODBAppend</seealso>
  </vodbrlock>

  <vodbrselect>
    <summary>
      返回关系的工作区号。
    </summary>
    <param name="wRelation">
      所需关系在当前工作区关系列表中的位置。<br/>
      关系按照关系设置定义的顺序编号。
    </param>
    <returns>
      指定关系的工作区号。<br/>
      如果<paramref name="wRelation" />没有设置关系，VODBRSelect()返回0。
    </returns>
    <remarks>
      VODBRSelect()类似于DBRSelect()，但是强类型的。有关更多信息和示例，请参见DBRSelect()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbRSelect'>DBRSelect</seealso>
  </vodbrselect>

  <vodbseek>
    <summary>
      移动到具有指定键值的记录。
    </summary>
    <param name="uKey">指定与所需记录关联的键值的任何类型的值。</param>
    <param name="lSoftSeek">确定如果未找到指定的键值，工作区如何定位：TRUE 执行软查找；FALSE 不执行。</param>
    <returns>
      VODBSeek() 始终返回 TRUE。
    </returns>
    <remarks>
      VODBSeek() 类似于 DBSeek()，但具有强类型特性。有关更多信息，请参见 DBSeek()。
    </remarks>
    <example>
      在此示例中，VODBSeek() 将指针移动到数据库 EMPLOYEE 中字段 cName 的值与输入的 cName 值匹配的记录：
      <code language="X#">
        ACCEPT "员工姓名: " TO cName
        IF (Employee-&gt;(VODBSeek(cName), FALSE))
        &#0009;Employee-&gt;(ViewRecord())
        ELSE
        &#0009;? "未找到"
        END
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSeek'>DBSeek</seealso>
  </vodbseek>

  <vodbselect>
    <summary>
      选择新的工作区并检索当前工作区。
    </summary>
    <param name="wNew">新工作区的工作区编号。</param>
    <param name="wOld">通过引用传递的变量，将包含当前工作区的编号。</param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBSelect() 类似于 DBSelect()，但具有强类型特性。<br/>
      然而，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息，请参见 DBSelect()。
    </remarks>
    <example>
      此示例展示如何保存和恢复旧环境：
      <code language="X#">
        LOCAL wOld AS DWORD
        VODBSelect(10, @wOld)
        &#0009;// 处理工作区
        VODBSelect(wOld, @wOld)
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSelect'>DBSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.Select'>Select</seealso>
  </vodbselect>

  <vodbsetfilter>
    <summary>
      设置过滤条件。
    </summary>
    <param name="cbCondition">以可执行形式表达过滤条件的代码块。</param>
    <param name="cCondition">
      以文本形式表达过滤条件的字符值。<br/>
      它必须等同于 <paramref name="cbCondition" />。<br/>
      要省略，请指定 NULL_STRING。<paramref name="cCondition" /> 是 DBFilter() 函数返回的值。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。<br/>
      如果省略 <paramref name="cCondition" />，DBSetFilter() 函数将为工作区返回一个空字符串。
    </returns>
    <remarks>
      VODBSetFilter() 类似于 DBSetFilter()，但具有强类型特性。<br/>
      然而，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息和示例，请参见 DBSetFilter()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetFilter'>DBSetFilter</seealso>
  </vodbsetfilter>

  <vodbsetfound>
    <summary>
      设置找到标志。
    </summary>
    <param name="lFound">找到标志的新设置。</param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBSetFound() 类似于 DBSetFound()，但具有强类型特性。<br/>
      然而，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息和示例，请参见 DBSetFound()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetFound'>DBSetFound</seealso>
  </vodbsetfound>

  <vodbsetlocate>
    <summary>
      指定定位条件的代码块。
    </summary>
    <param name="cbForCondition">
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/cbfor/*" /><br/>
      如果未指定范围，<paramref name="cbForCondition" /> 将默认范围更改为所有记录。<br/>
      代码块应包含逻辑表达式。<br/>
      它对应于 DBLocate() 或 VODBLocate() 的第一个参数。<br/>
      它在被下一个 VODBSetLocate() 覆盖之前一直有效。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBSetLocate() 允许您更改定位条件。一旦您发出 LOCATE 命令、DBLocate() 或 VODBLocate()，您可以继续搜索，但使用不同的条件。
      <include file="VoFunctionDocs.xml" path="Runtimefunctions/currentWorkarea/*" />
      请注意，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。
    </remarks>
    <example>
      以下示例展示了如何在两个不同且独立的条件下进行搜索：
      <code language="X#">
        FUNCTION Locators() AS LOGIC
        &#0009;LOCAL cbForCondition, cbWhileCondition, nNext, ;
        &#0009;&#0009;&#0009;uRecId, lRest
        &#0009;USE test
        &#0009;cbForCondition := {||Proper(ALLTRIM(Name)) == ;
        &#0009;&#0009;&#0009;"Charly"}
        &#0009;cbWhileCondition := {||TRUE}&#0009;// 处理到 EOF
        &#0009;nNext := -1&#0009;&#0009;&#0009;// 范围为全部
        &#0009;uRecId := NIL&#0009;&#0009;&#0009;// 保持为 NIL
        &#0009;lRest := FALSE&#0009;&#0009;// 从文件顶部开始搜索
        &#0009;// 搜索 Charly
        &#0009;DBLocate(cbForCondition, cbWhileCondition, ;
        &#0009;&#0009;nNext, uRecId, lRest)
        &#0009;? Found(), RECNO(), Name
        &#0009;// 指定第二个名字；搜索 Odile
        &#0009;VODBSetLocate({||Proper(ALLTRIM(Name))=="Odile"})
        &#0009;CONTINUE
        &#0009;? Found(), RECNO(), Name
        &#0009;DBCloseArea()
        &#0009;RETURN Found()
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbLocate'>DBLocate</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbLocate'>VODBLocate</seealso>
  </vodbsetlocate>

  <vodbsetrelation>
    <summary>
      将指定的工作区与当前工作区关联。
    </summary>
    <param name="cAlias">子工作区的别名。</param>
    <param name="cbRel">以可执行形式表达关系表达式的代码块。</param>
    <param name="cRel">
      以文本形式表达的关系表达式。<br/>
      它必须等同于 <paramref name="cbRel" />。<br/>
      要省略，请指定 NULL_STRING。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBSetRelation() 类似于 DBSetRelation()，但具有强类型特性。<br/>
      然而，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息和示例，请参见 DBSetRelation()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetRelation'>DBSetRelation</seealso>
  </vodbsetrelation>

  <vodbsetselect>
    <summary>
      选择新的工作区。
    </summary>
    <param name="siNewArea">新工作区的编号。</param>
    <returns>
      新选择的工作区。
    </returns>
    <remarks>
      VODBSetSelect() 类似于 DBSetSelect()，但具有强类型特性。有关更多信息和示例，请参见 DBSetSelect()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSetSelect'>DBSetSelect</seealso>
  </vodbsetselect>

  <vodbskip>
    <summary>
      相对于当前记录移动记录指针。
    </summary>
    <param name="liRecords">
      相对于当前记录要移动的逻辑记录数。<br/>
      正值表示向前跳过，负值表示向后跳过。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBSkip() 类似于 DBSkip()，但具有强类型特性。<br/>
      然而，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息和示例，请参见 DBSkip()。
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSkip'>DBSkip</seealso>
  </vodbskip>

  <vodbsymselect>
    <summary>
      通过指定工作区的别名作为符号来选择新的工作区，并返回当前工作区的编号。
    </summary>
    <param name="symAlias">要选择的工作区的别名。</param>
    <returns>
      当前工作区的编号。
    </returns>
    <remarks>
      VODBSymSelect() 类似于 DBSymSelect()，但具有强类型特性。有关更多信息，请参见 DBSymSelect()。
    </remarks>
    <example>
      此示例使用 VODBSymSelect() 来更改工作区：
      <code language="X#">
        FUNCTION ChangeArea() AS VOID
        &#0009;USE test
        &#0009;USE address NEW
        &#0009;? Alias()&#0009;&#0009;&#0009;// Address
        &#0009;VODBSymSelect(#Test)
        &#0009;? Alias()&#0009;&#0009;&#0009;// Test
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbSymSelect'>DBSymSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbSelect'>VODBSelect</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbUseArea'>VODBUseArea</seealso>
  </vodbsymselect>

  <vodbunlock>
    <summary>
      释放工作区的所有锁定。
    </summary>
    <param name="uRecID">
      要解锁的记录的 ID。<br/>
      若要省略，请指定 NIL。<br/>
      这将解锁所有锁定的记录或整个文件。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBUnLock() 与 DBUnLock() 相同。<br/>
      然而，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息，请参见 DBUnLock()。
    </remarks>
    <example>
      以下示例说明了 VODBUnLock() 函数的基本用法：
      <code language="X#">
        cLast := "Winston"
        USE sales SHARED NEW VIA "DBFNTX"
        VODBOrdListAdd("Lastname", NIL, NIL)
        IF (Sales-&gt;(VODBSeek(cLast)))
        &#0009;IF Sales-&gt;(VODBRLock(NIL))
        &#0009;&#0009;Sales-&gt;(VODBDelete())
        &#0009;&#0009;? "记录已删除: ", sales;
        &#0009;&#0009;&#0009;(VODBDeleted())
        &#0009;&#0009;Sales-&gt;(VODBUnLock(NIL))
        &#0009;ELSE
        &#0009;&#0009;? "无法锁定记录..."
        &#0009;ENDIF
        ELSE
        &#0009;? "未找到"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbUnLock'>DBUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLockAll'>DbUnLockAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbUnLockAll'>VODbUnLockAll</seealso>
  </vodbunlock>

  <vodbunlockall>
    <summary>
      释放所有工作区的所有锁定。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODbUnLockAll() 与 DbUnLockAll() 相同。<br/>
      然而，此函数不调用错误处理程序，因此如果失败，不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息，请参见 DbUnLockAll()。
    </remarks>
    <example>
      以下示例在 VODBRLock() 尝试成功时标记要删除的记录，然后清除所有工作区中的所有锁定：
      <code language="X#">
        cLast := "Winston"
        USE sales SHARED NEW VIA "DBFNTX"
        VODBOrdListAdd("Salefnam", NIL)
        VODBOrdListAdd("Salelnam", NIL)
        USE colls SHARED NEW VIA "DBFNTX"
        VODBOrdListAdd("Collfnam", NIL)
        VODBOrdListAdd("Colllnam", NIL)
        DBSelectArea("sales")&#0009;&#0009;// 选择 "sales" 工作区
        IF (colls-&gt;(VODBSeek(cLast)))
        &#0009;IF colls-&gt;(VODBDeleted())
        &#0009;&#0009;? "记录已删除: ", colls-&gt;;
        &#0009;&#0009;&#0009;(VODBDeleted())
        &#0009;&#0009;IF colls-&gt;(VODBRLock(NIL))
        &#0009;&#0009;&#0009;colls-&gt;(VODBRecall())
        &#0009;&#0009;&#0009;? "记录已恢复..."
        &#0009;&#0009;ENDIF
        &#0009;ENDIF
        ELSE
        &#0009;? "未找到"
        &#0009;VODbUnLockAll()&#0009;&#0009;// 移除所有工作区中的
        ENDIF&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;&#0009;// 所有锁定
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbUnLock'>DBUnLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.DbUnLockAll'>DbUnLockAll</seealso>
    <seealso cref='O:XSharp.RT.Functions.IndexHPLock'>IndexHPLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.NewIndexLock'>NewIndexLock</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbUnLock'>VODBUnLock</seealso>
  </vodbunlockall>

  <vodbusearea>
    <summary>
      打开数据库文件。
    </summary>
    <param name="lNewArea">指定是否在新工作区中打开文件。TRUE 在使用操作之前选择最低编号的未占用工作区作为当前工作区。FALSE 使用当前工作区（如果工作区已被占用，则先关闭它）。</param>
    <param name="ptrRDDList">
      指向包含 RDD 名称列表的结构 (_RDDLIST) 的指针，工作区从中获取其功能。<br/>
      如果多个 RDD（通过此参数指定）实现相同的功能，列表中最后一个 RDD 关联的函数优先。<br/>
      这允许您在不同的工作区中使用具有特殊功能（如加密或解密）的 RDD，并搭配不同的数据库驱动程序。
    </param>
    <param name="cDataFile">
      要打开的数据库文件名，包括可选的驱动器、目录和扩展名。<br/>
      如果数据库文件有对应的备注文件，也会一并打开。<br/>
      数据库和备注文件的默认扩展名由 RDD 决定。有关文件搜索和创建规则，请参见 SetDefault() 和 SetPath()。
    </param>
    <param name="cAlias">
      打开 <paramref name="cDataFile" /> 时与工作区关联的标识符名称。在单个应用程序中不允许重复的别名。
    </param>
    <param name="lShared">
      TRUE 尝试以共享方式打开 <paramref name="cDataFile" />。FALSE 尝试以独占（非共享）方式打开 <paramref name="xcDataFile" />，在数据库文件关闭之前拒绝所有其他进程的访问。
    </param>
    <param name="lReadOnly">
      TRUE 尝试以只读属性打开 <paramref name="cDataFile" />，禁止对工作区进行更新。FALSE 尝试以读写属性打开 <paramref name="cDataFile" />，允许更新。
    </param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBUseArea() 是用于实现 DBUseArea() 的强类型函数。<br/>
      此函数不调用错误处理程序，因此在失败时不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息，请参见 DBUseArea()。
    </remarks>
    <example>
      这个例子是 VODBUseArea() 函数的典型用法：
      <code language="X#">
        FUNCTION NtxUse(cDBF AS STRING) AS LOGIC PASCAL
        &#0009;LOCAL n,i           AS DWORD
        &#0009;LOCAL rddList       AS _RDDLIST
        &#0009;LOCAL aRdds         AS ARRAY
        &#0009;LOCAL lRet        <br/>
        AS LOGIC
        &#0009;aRdds := {"CAVODBF", "DBFNTX"}
        &#0009;n       := ALen(aRdds)
        &#0009;rddList := MemAlloc( (_SizeOf(DWORD)) + (n * _SizeOf(SYMBOL)) )
        &#0009;rddList.uiRddCount := n
        &#0009;FOR i := 1 TO n
        &#0009;&#0009;rddList.atomRddName[i] := SysAddAtomUpperA(aRdds[i])
        &#0009;NEXT
        &#0009;lRet := VODBUseArea(TRUE, rddList, cDBF, "", TRUE, FALSE)
        &#0009;MemFree(rddList)
        &#0009;RETURN lRet
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbUseArea'>DBUseArea</seealso>
    <seealso cref='O:XSharp.Core.Functions.NetErr'>NetErr</seealso>
  </vodbusearea>

  <vodbzap>
    <summary>
      从打开的文件中删除所有记录。
    </summary>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      VODBZap() 与 DBZap() 相同。<br/>
      然而，此函数不调用错误处理程序，因此在失败时不会产生运行时错误消息或创建错误对象。因此，检查返回值以确定函数是否成功可能很重要。<br/>
      全局结构 StrucErrInfo 将包含有关发生的任何错误的必要信息。有关更多信息，请参见 DBZap()。
    </remarks>
    <example>
      这个例子演示了一个典型的清除操作：
      <code language="X#">
        USE sales EXCLUSIVE NEW
        IF !NetErr()
        &#0009;SET INDEX TO sales, branch, salesman
        &#0009;IF VODBZap()
        &#0009;&#0009;? "清除成功"
        &#0009;ELSE
        &#0009;&#0009;? "清除过程中检测到错误"
        &#0009;ENDIF
        &#0009;CLOSE sales
        ELSE
        &#0009;? "打开文件时检测到错误"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DbZap'>DBZap</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbDelete'>VODBDelete</seealso>
    <seealso cref='O:XSharp.RT.Functions.VoDbPack'>VODBPack</seealso>
  </vodbzap>

  <vosendmessage>
    <summary>
      向指定窗口发送指定消息。
    </summary>
    <param name="hWnd">接收消息的窗口句柄。</param>
    <param name="nMsg">表示要发送到窗口的消息的 Windows API 消息常量。</param>
    <param name="wParam">第一个消息特定信息。</param>
    <param name="lParam">第二个消息特定信息。</param>
    <returns>
      LONGINT 返回值，取决于发送的消息。
    </returns>
    <remarks>
      这是 Windows API SendMessage() 函数的垃圾收集器安全版本。<br/>
      如果 Windows 消息涉及 PSZ 作为消息参数之一，并且您将常规字符串传递给 SendMessage()，则 X# 垃圾收集可能存在潜在问题。通过使用 VOSendMessage() 处理涉及动态 X# 数据类型的消息，可以避免这个问题。
      注意：有关 SendMessage() 函数、消息、参数和返回值的更多信息，请参阅 Windows API。
    </remarks>
    <example>
    </example>
  </vosendmessage>

  <w2bin>
    <summary>
      将一个字转换为包含 16 位无符号整数的字符串。
    </summary>
    <param name="wValue">要转换的值。小数值将被截断。</param>
    <returns>
    </returns>
    <remarks>
      W2Bin() 是一个转换函数，将一个字转换为 2 字节字符串。典型应用包括以原生格式读取外部文件类型，然后以压缩的二进制形式而非字符串形式保存、读取、解密和传输数值数据。<br/>
      其逆函数是 Bin2W()。
    </remarks>
    <example>
      此示例使用 W2Bin() 将当前过程行存储到调试文件中：
      <code language="X#">
        FUNCTION ErrorLines() AS LOGIC
        &#0009;LOCAL nh
        &#0009;LOCAL lSuccess := FALSE AS LOGIC
        &#0009;nh := FOpen2("data.bin", FO_READWRITE)
        &#0009;// 假设文件 debug.bin 已存在
        &#0009;IF nh != F_ERROR
        &#0009;&#0009;FWrite(nh, W2Bin(ProcLine()))
        &#0009;&#0009;FWrite(nh, W2Bin(ProcLine(1)))
        &#0009;&#0009;FClose(nh)
        &#0009;&#0009;lSuccess := TRUE
        &#0009;ELSE
        &#0009;&#0009;? "打开 debug.bin 时发生错误"
        &#0009;&#0009;FError()
        &#0009;ENDIF
        &#0009;RETURN lSuccess
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Bin2Date'>Bin2Date</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2DW'>Bin2DW</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2F'>Bin2F</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2I'>Bin2I</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2L'>Bin2L</seealso>
    <seealso cref='O:XSharp.RT.Functions.Bin2Logic'>Bin2Logic</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2Real4'>Bin2Real4</seealso>
    <seealso cref='O:XSharp.Core.Functions.Bin2W'>Bin2W</seealso>
    <seealso cref='O:XSharp.RT.Functions.Date2Bin'>Date2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.DW2Bin'>DW2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.F2Bin'>F2Bin</seealso>
    <seealso cref='O:XSharp.RT.Functions.FWrite'>FWrite</seealso>
    <seealso cref='O:XSharp.Core.Functions.I2Bin'>I2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.L2Bin'>L2Bin</seealso>
    <seealso cref='O:XSharp.Core.Functions.Real42Bin'>Real42Bin</seealso>
  </w2bin>

  <workdir>
    <summary>
      返回当前选定的工作目录。
    </summary>
    <returns>
    </returns>
    <remarks>
      工作目录是关联的 .EXE 文件所在并从中执行的位置。<br/>
      .EXE 文件可以是 CAVO2x.EXE 或您的链接应用程序的 .EXE，视情况而定。
      <br/>
      此示例使用 WorkDir() 函数在设置新目录之前获取当前目录：
      <code language="X#">
        LOCAL cWorkDir AS STRING
        cWorkDir := WorkDir()
        SetDefault(cWorkDir + "samples\debug")
      </code>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions.CurDir'>CurDir</seealso>
    <seealso cref='O:XSharp.Core.Functions.CurDrive'>CurDrive</seealso>
    <seealso cref='O:XSharp.RT.Functions.DirChange'>DirChange</seealso>
    <seealso cref='O:XSharp.Core.Functions.DiskName'>DiskName</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDefault'>SetDefault</seealso>
  </workdir>

  <year>
    <summary>
      从日期中提取年份。
    </summary>
    <param name="dDate">日期。</param>
    <returns>
      <paramref name="dDate" /> 的年份，包括世纪位，作为 4 位数字。<br/>
      返回值不受 SetDateFormat()、SetCentury()、SET DATE 或 SET CENTURY 的影响。指定 NULL_DATE 返回 0。
    </returns>
    <remarks>
      Year() 是一个日期转换函数，将日期值转换为数字年份值。<br/>
      如果未指定世纪位，世纪由 SET EPOCH 或 SetEpoch() 的规则确定。
      Year() 是返回日期值组成部分为数字的一组函数的成员。<br/>
      该组还包括 Day() 和 Month()，它们将日和月值作为数字返回。
    </remarks>
    <example>
      这些示例使用系统日期说明 Year()：
      <code language="X#">
        ? TODAY()&#0009;&#0009;&#0009;&#0009;&#0009;// 09/20/90
        ? YEAR(TODAY())&#0009;&#0009;&#0009;// 1990
        ? YEAR(TODAY()) + 11&#0009;&#0009;// 2001
        ? YEAR(05.15.64)&#0009;&#0009;&#0009;// 1964
        SetEpoch(2000)
        ? YEAR(CTOD("05.15.64"))&#0009;// 2064
      </code>
      此示例创建一个使用 Year() 的函数，将日期值格式化为月、日、年的形式：
      <code language="X#">
        ? Mdy(TODAY())&#0009;&#0009;&#0009;&#0009;// September 20, 1990
        FUNCTION Mdy(dDate)
        &#0009;RETURN CMONTH(dDate) + " " + ;
        &#0009;&#0009;&#0009;NTrim(DAY(dDate)) ;
        &#0009;&#0009;&#0009;+ "," + STR(YEAR(dDate))
      </code>
    </example>
    <seealso cref='O:XSharp.RT.Functions.Day'>Day</seealso>
    <seealso cref='O:XSharp.RT.Functions.Month'>Month</seealso>
    <seealsocmd>SET CENTURY</seealsocmd>
    <seealsocmd>SET DATE</seealsocmd>
    <seealsocmd>SET EPOCH</seealsocmd>
    <seealso cref='O:XSharp.Core.Functions.SetCentury'>SetCentury</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDateCountry'>SetDateCountry</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetDateFormat'>SetDateFormat</seealso>
    <seealso cref='O:XSharp.Core.Functions.SetEpoch'>SetEpoch</seealso>
  </year>

  <_accept>
    <summary>
      从键盘获取输入并将其分配给内存变量。
    </summary>
    <param name="uValuePrompt">输入区域前显示的可选提示。</param>
    <param name="TO idVar">
      将保存键盘输入的变量。<br/>
      如果当前例程中没有名为 <paramref name="idVar" /> 的可见变量，则会创建一个私有变量。
    </param>
    <returns>
    </returns>
    <remarks>
      执行 _Accept 时，它首先执行回车/换行，在终端窗口显示提示，然后在紧跟提示的位置开始从键盘接收字符。
      最多可输入 255 个字符。当输入达到窗口边缘（由 MaxCol() 定义）时，光标移至下一行。
      _Accept 仅支持两个编辑键：退格键和回车键（不支持 Esc）。退格键删除最后输入的字符。回车键确认输入，是唯一可以终止 _Accept 的键。<br/>
      如果只按下回车键，_Accept 会将 NULL_STRING 分配给 <paramref name="cVar" />。
    </remarks>
    <example>
      此示例使用 ACCEPT 从用户获取键盘输入：
      <code language="X#">
        LOCAL cVar AS STRING
        cVar := _Accept("输入一个值：  " )
        IF cVar = NULL_STRING
        ? "用户按下了回车键"
        ELSE
        ? "用户输入：", cVar
        ENDIF
      </code>
      <br/>
      Terminal Lite
    </example>
  </_accept>

  <_debout32>
    <summary>
      向调试终端程序写入信息
    </summary>
    <param name="pszText">写入调试终端程序的 PSZ 文本</param>
    <returns>
    </returns>
    <remarks>
      _DebOut32() 有助于调试 X# 应用程序。它使用与操作系统 OutPutDebugString() 函数相同的机制。
      要查看输出，您需要运行一个特殊程序来拦截此输出。您可以从以下网址下载这样的程序：
      http://www.sysinternals.com
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.RT.Functions.DebOut'>DebOut</seealso>
    <seealso cref='O:XSharp.Core.Functions.DebOut32'>DebOut32</seealso>
  </_debout32>

  <_dyncheck>
    <summary>
      检查动态内存的完整性。
    </summary>
    <returns>
      TRUE 表示动态内存未损坏。FALSE 表示动态内存已损坏。
    </returns>
    <remarks>
      如果您直接使用诸如 RegisterKid() 之类的函数操作动态内存，此函数会很有用。<br/>
      它可以帮助您确定应用程序中动态内存损坏发生的位置。使用此函数时必须小心。由于检测到的错误性质，某些动态内存错误可能导致应用程序立即终止。
    </remarks>
    <example>
      以下示例根据 _DynCheck() 的返回值显示一条消息：
      <code language="X#">
        IF _DynCheck()
        &#0009;? "动态内存正常。"
        ELSE
        &#0009;? "动态内存已损坏。"
        ENDIF
      </code>
    </example>
    <seealso cref='O:XSharp.VO.Functions.DynCheckError'>DynCheckError</seealso>
    <seealso cref='O:XSharp.VO.Functions.Memory'>Memory</seealso>
    <seealso cref='O:XSharp.VO.Functions.RegisterKid'>RegisterKid</seealso>
  </_dyncheck>

  <_getcmdline>
    <summary>
      返回指向用于调用应用程序的命令行的指针。
    </summary>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions._GetInst'>_GetInst</seealso>
    <seealso cref='O:XSharp.Core.Functions._GetPrevInst'>_GetPrevInst</seealso>
  </_getcmdline>

  <_getcmdshow>
    <summary>
      返回指定应用程序窗口如何显示的常量。
    </summary>
    <returns>
      以下常量之一，指示窗口的状态：
      常量&#0009;含义&#0009;
      SW_HIDE&#0009;窗口被隐藏，另一个窗口被激活&#0009;
      SW_MINIMIZE&#0009;窗口被最小化，系统列表中的顶层窗口被激活&#0009;
      SW_RESTORE&#0009;窗口被激活并显示 — 如果最小化或最大化，Windows将其恢复到原始大小和位置（与SW_SHOWNORMAL相同）。&#0009;
      SW_SHOW&#0009;窗口被激活并以当前大小和位置显示&#0009;
      SW_SHOWMAXIMIZED&#0009;窗口被激活并最大化显示&#0009;
      SW_SHOWMINIMIZED&#0009;窗口被激活并作为图标显示&#0009;
      SW_SHOWMINNOACTIVE&#0009;窗口作为图标显示，保持当前活动窗口激活&#0009;
      SW_SHOWNA&#0009;窗口以当前状态显示，保持当前活动窗口激活&#0009;
      SW_SHOWNOACTIVATE&#0009;窗口以最近的大小和位置显示，保持当前活动窗口激活&#0009;
      SW_SHOWNORMAL&#0009;窗口被激活并显示 — 如果最小化或最大化，Windows将其恢复到原始大小和位置（与SW_RESTORE相同）。&#0009;
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions._GetCmdLine'>_GetCmdLine</seealso>
    <seealso cref='O:XSharp.Core.Functions._GetInst'>_GetInst</seealso>
    <seealso cref='O:XSharp.Core.Functions._GetPrevInst'>_GetPrevInst</seealso>
  </_getcmdshow>

  <_getfirstparam>
    <summary>
      访问变参列表中的第一个参数。
    </summary>
    <param name="pptrStart">调用函数本地的匿名指针变量，将作为变参列表的地址。</param>
    <param name="ptrFirst">调用函数参数列表中固定参数变量的地址。</param>
    <param name="dwTypeFirst">指定上述固定参数的类型。</param>
    <param name="dwType">指定要访问的实际参数的类型。</param>
    <returns>
      <paramref name="dwType" />指定类型的值（USUAL）。
    </returns>
    <remarks>
      这个特殊函数与_GetNextParam()一起使用，用于访问定义为访问变参列表的函数内的可变参数。
    </remarks>
    <example>
      以下示例说明了接受可变数量参数的函数的实现：
      <code language="X#">
        FUNCTION CFunc(dummy:=1 AS INT, dwNumber AS INT, ... );
        &#0009;AS VOID STRICT
        LOCAL   xParam &#0009;AS USUAL
        LOCAL   i&#0009;&#0009;AS DWORD
        LOCAL   pParam&#0009;AS PTR
        LOCAL   cString &#0009;AS STRING
        xParam := _GetFirstParam(@pParam, @dwNumber, INT,;
        STRING)
        ? dwNumber
        ? xParam
        FOR i := 2 UPTO dwNumber&#0009;
        &#0009;xParam := _GetNextParam(@pParam, STRING)
        &#0009;? xParam
        NEXT
        RETURN&#0009;
        FUNCTION Start
        &#0009;CFunc(,1, "How")
        &#0009;CFunc(,2, "How ", "are ")
        &#0009;CFunc(,3, "How ", "are ", "you ")
      </code>
    </example>
    <seealsocmd>_GetNextParam</seealsocmd>
  </_getfirstparam>

  <_getinst>
    <summary>
      返回应用程序或 DLL 的实例句柄。
    </summary>
    <returns>
    </returns>
    <remarks>
      实例句柄是 Windows 分配给应用程序或 DLL 的，在低级 Windows 系统编程中需要使用。
    </remarks>
    <example>
      以下示例从字符串表中加载一个字符串。<br/>
      此示例要求 Win32 API 库包含在应用程序的搜索路径中：
      <code language="X#">
        FUNCTION Start()
        &#0009;LOCAL x := BUFFER(64) AS STRING
        &#0009;LOCAL cb AS WORD
        &#0009;cb := LoadString(_GetInst(), 100, x, 64)
        &#0009;x := LEFT(x, cb)
        &#0009;? x         // Hello World
      </code>
      &#0009;
      <code language="X#">
        RESOURCE StringTable
        &#0009;{
        &#0009;&#0009;100, "Hello World"
        &#0009;}
      </code>
    </example>
    <seealso cref='O:XSharp.Core.Functions._GetCmdLine'>_GetCmdLine</seealso>
    <seealso cref='O:XSharp.Core.Functions._GetCmdShow'>_GetCmdShow</seealso>
    <seealso cref='O:XSharp.Core.Functions._GetPrevInst'>_GetPrevInst</seealso>
  </_getinst>

  <_getnextparam>
    <summary>
      访问可变参数列表中的剩余参数。
    </summary>
    <param name="pptrStart">通过之前调用 _GetFirstParam() 或 _GetNextParam() 获得的匿名指针。</param>
    <param name="dwType">指定要访问的实际参数的类型。</param>
    <returns>
      <paramref name="dwType" /> 指定类型的值（USUAL）。
    </returns>
    <remarks>
      这个特殊函数与 _GetFirstParam() 一起使用，用于访问定义为访问可变参数列表的函数内的可变参数。
    </remarks>
    <example>
      请参见 _GetFirstParam() 示例。
    </example>
    <seealsocmd>_GetFirstParam</seealsocmd>
  </_getnextparam>

  <_getprevinst>
    <summary>
      注意：32 位应用程序不支持此功能。
      保留此函数是为了向后兼容，但始终返回 NULL_PTR。
      <br/>
      返回应用程序或 DLL 的前一个实例句柄。
    </summary>
    <returns>
    </returns>
    <remarks>
      <note type="tip">
        对于 Windows 3.2 应用程序或 DLL，前一个实例句柄始终为 NULL。
      </note>
    </remarks>
    <example>
    </example>
    <seealso cref='O:XSharp.Core.Functions._GetCmdLine'>_GetCmdLine</seealso>
    <seealso cref='O:XSharp.Core.Functions._GetCmdShow'>_GetCmdShow</seealso>
    <seealso cref='O:XSharp.Core.Functions._GetInst'>_GetInst</seealso>
  </_getprevinst>

  <_registerexit>
    <summary>
      注册一个在当前应用程序结束时要调用的退出例程。
    </summary>
    <param name="ptrRoutine">要注册为退出例程的函数或过程的指针。</param>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      无论应用程序是正常终止还是由于错误而终止，注册的例程都将在应用程序结束时被调用。
      最多可以注册 64 个例程作为退出例程，但应用程序无法控制执行顺序。<br/>
      退出例程可能以任何顺序执行，与您注册它们的顺序无关。
      注意：<br/>
      PROCEDURE 语句可用于声明初始化例程。
    </remarks>
    <example>
      以下示例在当前应用程序终止前显示一个消息框：
      <code language="X#">
        FUNCTION Start()
        &#0009;...
        &#0009;_RegisterExit(@MyExitFunc())
        &#0009;...
        FUNCTION MyExitFunc()
        &#0009;MessageBox(0, "应用结束", "退出", MB_OK)
      </code>
    </example>
    <seealsocmd>PROCEDURE</seealsocmd>
    <seealso cref='O:XSharp.RT.Functions.RegisterAxit'>RegisterAxit</seealso>
  </_registerexit>

  <_voloadlibrary>
    <summary>
      安全使用在 X# 中创建的 .Dll。
    </summary>
    <param name="idVariable">表示为字面标识符的变量名。</param>
    <returns>
      A
    </returns>
    <remarks>
      当在 X# 中创建 .Dll 时，它几乎总是会调用运行时库。可能您尝试加载的 .Dll 会将旧版本的运行时（CAVORT20.DLL）调入内存，这需要避免。
      使用 _VOLoadLibrary() 加载 .Dll 将允许系统检查旧运行时（CAVORT20.DLL）是否被加载到内存中，如果是，则会生成错误。
      如果检测到旧运行时，运行时将首先调用错误处理程序，然后终止应用程序，因为内存中有两个运行时会导致各种问题。
    </remarks>
    <example>
    </example>
  </_voloadlibrary>

  <_wait>
    <summary>
      在向终端窗口发送回车/换行后显示提示，然后等待按键。
      注意：WAIT 是一个兼容性命令，不再推荐使用。
    </summary>
    <param name="uValuePrompt">
      输入区域前显示的可选提示。<br/>
      如果省略，将显示"按任意键继续..."。指定 NULL_STRING 如果不想显示提示。
    </param>
    <param name="Value">
      将保存键盘输入的变量。<br/>
      如果当前例程中没有名为 <paramref name="idVar" /> 的可见变量，将创建一个私有变量。<paramref name="idVar" /> 被赋予按键的字符串值。<br/>
      如果按下 Alt 或 Ctrl 组合键，WAIT 将 Chr(0) 赋给 <paramref name="idVar" />。<br/>
      &#0009;通过按 Alt+键组合输入的非字母数字值会赋予指定的字符。<br/>
      如果字符可以显示，它将回显到屏幕上。
    </param>
    <returns>
    </returns>
    <remarks>
    </remarks>
    <example>
    </example>
    <seealsocmd>ACCEPT</seealsocmd>
  </_wait>

  <uAreaValue>
    <span>
      指定要从中检索值的表的工作区名称或编号。
    </span>
  </uAreaValue>

  <uAreaOperation>
    <span>
      指定要在其上执行操作的表的工作区名称或编号。
    </span>
  </uAreaOperation>

  <currentWorkareaParam>
    <span>
      <br/>默认情况下，此函数在当前选定的工作区上操作。
      <br/>可以通过在别名表达式中指定或调用接受工作区参数（工作区编号或别名）的重载来使其在未选定的工作区上操作。<br/>
    </span>
  </currentWorkareaParam>

  <currentWorkarea>
    <span>
      默认情况下，此函数在当前选定的工作区上操作。<br/>
      可以通过在别名表达式中指定来使其在未选定的工作区上操作。
    </span>
  </currentWorkarea>

  <cbwhile>
    <span>
      定义每条记录必须满足的另一个条件的代码块。
      一旦遇到导致条件失败的记录，操作就会终止。<br/>
      如果未指定范围，<paramref name="cbWhileCondition" /> 将默认范围更改为 <paramref name="lRest" />。<br/>
      您可以使用这三个互斥参数之一来定义范围。<br/>
      默认为所有记录。
    </span>
  </cbwhile>

  <cbfor>
    <span>
      定义范围内每条记录必须满足的条件的代码块。
    </span>
  </cbfor>

  <recordscope>
    <span>
      <note type="tip">
        <paramref name="nNext" />、<paramref name="nRecord" /> 和 <paramref name="lRest" /> 参数是互斥的。您不应同时传递这三个参数。
        如果您传递 <paramref name="cbWhile" /> 参数，那么它也会控制范围行为。
      </note>
    </span>
  </recordscope>

  <vodbsetscope>
    <summary>设置定位条件。</summary>
    <param name="scope">当前工作区的范围信息</param>
    <returns>如果成功则返回 TRUE；否则返回 FALSE。</returns>
    <remarks>请注意，此范围信息不是排序范围，而是存储有关 LOCATE 操作和其他工作区操作信息的类。</remarks>
    <seealso cref="T:XSharp.RDD.Support.DbScopeInfo"/>
  </vodbsetscope>

  <vodbgetscope>
    <summary>获取当前定位条件。</summary>
    <returns>当前工作区的范围信息。</returns>
    <remarks>请注意，此范围信息不是排序范围，而是存储有关 LOCATE 操作和其他工作区操作信息的类。</remarks>
    <seealso cref="T:XSharp.RDD.Support.DbScopeInfo"/>
  </vodbgetscope>

  <sysobject>
    <summary>
      安装系统范围的对象。请注意，这与 Visual Objects 的工作方式略有不同。
    </summary>
    <param name="oSys">
      要安装的对象。<paramref name="oSys"/> 可以是 NULL_OBJECT，在这种情况下，系统对象将被清除。
    </param>
    <returns>
      <paramref name="oSys"/> 或者，如果未指定 <paramref name="oSys"/>，则返回当前安装的对象。
    </returns>
    <remarks>
      与 VO 不同，SysObject 不用于接收发送给其他数据类型的所有消息，因为在 .Net 中，默认情况下所有类型都已接受消息。
    </remarks>
  </sysobject>

  <_run>
    <summary>执行 Windows 或 DOS 应用程序、批处理文件或 DOS 命令。</summary>
    <remarks>
      此函数使用 Windows API 中的 WinExec() 函数。那里提到的安全问题对此函数也同样适用。
      <see href='!:https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec'>WinExec()</see>
    </remarks>
    <param name="cProgram">
      要执行的应用程序的命令行（文件名加可选参数）。
      如果 lpCmdLine 参数中的可执行文件名不包含目录路径，
      系统会按以下顺序搜索可执行文件：<br/>
      1) 应用程序加载的目录。<br/>
      2) 当前目录。<br/>
      3) Windows 系统目录。GetSystemDirectory 函数检索此目录的路径。<br/>
      4) Windows 目录。GetWindowsDirectory 函数检索此目录的路径。<br/>
      5) PATH 环境变量中列出的目录。<br/>
    </param>
    <returns>
      如果函数成功，返回值大于 31。如果函数失败，返回值是以下错误值之一。
      <list>
        <listheader>
          <term>返回代码/值</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>
            0
          </term>
          <description>
            系统内存或资源不足。
          </description>
        </item>
        <item>
          <term>
            ERROR_BAD_FORMAT (1)
          </term>
          <description>.exe 文件无效。</description>
        </item>
        <item>
          <term>ERROR_FILE_NOT_FOUND (2)</term>
          <description>
            未找到指定的文件。
          </description>
        </item>
        <item>
          <term>ERROR_PATH_NOT_FOUND (3)</term>
          <description>未找到指定的路径。</description>
        </item>
      </list>
    </returns>
  </_run>

  <oclone>
    <summary>复制一个对象。</summary>
    <param name="o">要复制的变量。</param>
    <returns>引用一个与原始对象具有相同值的新对象。</returns>
  </oclone>

  <mcompilemexec>
    <span>
      <note type="tip">
        在 Visual Objects 中，MCompile() 的返回值是一个包含 PCode 标记的特殊格式字符串。
        我们在 <b>X#</b> 中改变了这一点，现在 MCompile() 的返回值是 _Codeblock 类型的代码块。<br/>
        如果在 Visual Objects 中编译的字符串形式为 "{||.....}"，那么你必须
        调用 MExec() 将字符串转换为 _Codeblock 对象。要评估代码块，你
        然后必须将 MExec() 的结果传递给 EVal() 函数。<br/>
        如果在 Visual Objects 中编译的字符串不是 "{||.....}" 的形式，
        就像本主题的示例中那样，那么对 MCompile() 的返回值调用 MExec()
        会立即评估表达式并返回结果。<br/>
        由于在 <b>X#</b> 中 MCompile() 的返回值是 _Codeblock 类型的代码块，
        你也可以使用 Eval() 函数来评估代码块。<br/>
        在 X# 中，对 MCompile() 返回的代码块调用 MExec() 将直接评估
        代码块（当原始字符串不是代码块格式时）或者当原始字符串是代码块格式时
        简单地返回相同的代码块。
      </note>
    </span>
  </mcompilemexec>

  <mcompileexamples>
    <span>
      以下示例展示了 MCompile() 和 MExec() 的典型用法：
      <code language="X#">
        LOCAL cComp AS CodeBlock        // 注意在 Visual Objects 中这必须是字符串类型
        cComp := MCompile("2+3")
        ? MExec(cComp)                  // 5
        nResult := MExec(cComp)         // 赋值
        ? MExec(cComp) = 5              // 比较
        MEMVAR Two // 声明并初始化一个私有变量
        Two := 2
        cComp := MCompile("Two+3")      // 宏引用私有变量
        ? MExec(cComp)                  // 5
        // 以下仅在 X# 中有效，因为 cComp 的结果现在是一个 CodeBlock
        ? Eval(cComp)
      </code>
    </span>
  </mcompileexamples>

  <datetime>
    <summary>
      返回当前日期和时间作为 DateTime 值，或创建一个兼容 2000 年的 DateTime 值。
    </summary>
    <param name="nYear">
      指定 DateTime 值中的年份。<paramref name="nYear" /> 可以是 100 到 9999 之间的值。
    </param>
    <param name="nMonth">
      指定 DateTime 值中的月份。<paramref name="nMonth" /> 可以是 1 到 12 之间的值。
    </param>
    <param name="nDay">
      指定 DateTime 值中的日期。<paramref name="nDay" /> 可以是 1 到 31 之间的值。
    </param>
    <param name="nHours">
      指定 DateTime 值中的小时。<paramref name="nHours" /> 可以是 0（午夜）到 23（晚上 11 点）之间的值。如果省略则默认为 0。
    </param>
    <param name="nMinutes">
      指定 DateTime 值中的分钟。<paramref name="nMinutes" /> 可以是 0 到 59 之间的值。如果省略则默认为 0。
    </param>
    <param name="nSeconds">
      指定 DateTime 值中的秒数。<paramref name="nSeconds" /> 可以是 0 到 59 之间的值。如果省略则默认为 0。
    </param>
  </datetime>
</Runtimefunctions>
