<?xml version="1.0" encoding="utf-8"?>
<Runtimefunctions>
  <abs>
    <summary>
      Returns the absolute value of the specified numeric expression.
    </summary>
    <param name="nExpression">

      Specifies the numeric expression whose absolute value ABS( ) returns.
    </param>
    <returns>
      Numeric
    </returns>
    <example>
       <code language="X#">
        ? ABS(-45)       &amp;&amp; Displays 45
        ? ABS(10-30)     &amp;&amp; Displays 20
        ? ABS(30-10)     &amp;&amp; Displays 20
        STORE 40 TO gnNumber1
        STORE 2 TO gnNumber2
        ? ABS(gnNumber2-gnNumber1)     &amp;&amp; Displays 38
      </code>
    </example>
  </abs>
  <acopy>
    <summary>
      Copies elements from one array to another array.
    </summary>
    <param name="nFirstSourceElement">

      Specifies the first element number in the source array to be copied; inclusive (element number nFirstSourceElement is included in the copying). If nFirstSourceElement isn't included, copying begins with the first element in the source array.

    </param>
    <param name="nNumberElements">

      Specifies the number of elements copied from the source array. If nNumberElements is –1, all elements of the source array beginning with element nFirstSourceElement are copied.

    </param>
    <param name="nFirstDestElement">

      Specifies the first element in the destination array to be replaced.
    </param>
    <returns>
      Numeric. <b>ACOPY( )</b> returns the number of elements copied to the destination array.
    </returns>
    <remarks>
      Copying a member array to an existing non-member array with certain dimensions using the <b>ACOPY( )</b> function might generate the error, "Subscript is outside defined range." You can avoid this error changing the dimension of the destination array to a single element before calling <b>ACOPY( )</b>. For more information, see DIMENSION Command.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'data\testdata')
        USE customer     &amp;&amp; Open customer table
        SELECT DISTINCT company ;
        FROM customer ;
        ORDER BY company ;
        WHERE country = 'Germany';
        INTO ARRAY gaCompanies
        = ACOPY(gaCompanies, gaCompaniesTemp)  &amp;&amp; Make a copy of the array
        CLEAR
        DISPLAY MEMORY LIKE gaCompaniesTemp
      </code>
    </example>
  </acopy>
  <acos>
    <summary>
      Returns the arc cosine of a specified numeric expression.
    </summary>
    <param name="nExpression">

      Specifies a numeric expression whose arc cosine ACOS( ) returns. The value of nExpression can range from –1 through +1. The value returned by ACOS( ) ranges from 0 through pi (3.141592). The number of decimal places ACOS( ) returns is determined by SET DECIMALS.
      Use RTOD( ) to convert radians to degrees.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The arc cosine is returned in radians.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? RTOD(ACOS(0))  &amp;&amp; Displays 90.00
        STORE -1 to gnArcAngle
        ? RTOD(ACOS(gnArcAngle))  &amp;&amp; Displays 180.00
        ? RTOD(ACOS(SQRT(2)/2))  &amp;&amp; Displays 45.00
      </code>
    </example>
  </acos>
  <adir>
    <summary>
      Places information about files into an array and then returns the number of files.
    </summary>
    <param name="ArrayName">

      Specifies the name of the array. If the array you include doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain all the information, X# automatically increases the size of the array to accommodate the information. If the array is larger than necessary, X# truncates the array. If the array exists and <b>ADIR( )</b> returns 0 because no matching files are found, the array remains unchanged. If the array doesn't exist and <b>ADIR( )</b> returns 0, the array isn't created.
      The following table describes the contents and data type of each column in the array:
      1
      File names
      Character
      2
      File sizes
      Numeric
      3
      Dates last modified
      4
      Times last modified
      5
      File attributes
      The last array column contains the file attributes of the matching files. Each file attribute is expressed by a letter; a file can have more than one attribute. The following table indicates the file attribute represented by each letter:
      Archive – Read/Write
      H
      Hidden
      Read-only
      System
      Directory

    </param>
    <param name="cFileSkeleton">

      Specifies a file skeleton so you can store information about files with names or extensions that match a search criterion. For example, the criterion can be all tables, all text files, all files with names that have A as their first letter, and so on. Such general searches are done by including the wildcards * and ? in cFileSkeleton. A question mark represents a single character; an asterisk represents any number of characters. You can use any number of wildcards in any position within the file skeleton.
      You can specify a drive and/or directory to search for matching file names. If you don't specify a drive and a directory, X# places information about files in the current directory into the array.

    </param>
    <param name="cAttribute">

      Specifies the inclusion of subdirectories and hidden or system files.
      cAttribute can contain any combination of D, H, and S. Including D returns subdirectory names of the current directory in addition to file names that match the file skeleton specified in cFileSkeleton. Including H returns information about hidden files that match the file skeleton specified in cFileSkeleton. Including S returns information about system files that match the file skeleton specified in cFileSkeleton.
      Include an empty string in cFileSkeleton to return just subdirectory names, hidden files or system files.
      You can include V in cAttribute to return the volume name of the current drive. Only the volume name is returned to the array if V is included with D, H, or S. The volume name is stored in the first array element and the remainder of the array is truncated.

    </param>
    <param name="nFlag">

      Specifies whether the display provides DOS naming or actual case sensitivity.
      nFlag
      0
      (Default) Display represents the full file name in uppercase
      1
      Display represents original Case in names
      2
      Display follows DOS 8+3 naming convention
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      For each file, ADIR( ) places into the array the file name, size, date last modified, time last modified, and attributes.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        SET DEFAULT TO (HOME(2) + 'Data')
        gnDbcnumber = ADIR(gaDatabase, '*.DBC')  &amp;&amp; Create array
        CLEAR
        FOR nCount = 1 TO gnDbcnumber  &amp;&amp; Loop for number of databases
        ? gaDatabase(nCount,1)  &amp;&amp; Display database names
        ENDFOR
        SET PATH TO HOME( )  &amp;&amp; Set path to X# directory
      </code>
    </example>
  </adir>
  <adlls>
    <summary>
      Returns an array containing the names of functions loaded by DECLARE DLLs.
    </summary>
    <param name="Arrayname">

      Specifies the name of the array. If the array you specify doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain all the functions loaded by DECLARE DLLS, X# automatically increases the size of the array to accommodate the information. If the array is larger than necessary, X# truncates the array. If no DLL functions have been declared, the array is not created, and an existing array is not modified.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The numeric value returned by the ADLLS function specifies the number of DLL loaded functions. If no alias is provided, the 2nd element returns the same value as the 1st element (function name).
      The array created by the ADLLS function has the following format:
      1
      Function Name
      Character
      2
      Function Alias
      Character
      3
      Library Name
      Character
      For details about how to declare functions, see DECLARE - DLL Command.
    </remarks>
  </adlls>
  <adockstate>
    <summary>
      Retrieves the dock state of any dockable form, Integrated Development Environment (IDE) window, or toolbar. For forms only, you can use the GetDockState Method. <b>ADOCKSTATE( )</b> is available in the run time.
    </summary>
    <param name="ArrayName">

      Specifies an array with one or more rows containing the dock state of dockable items.
      Both system and user-defined toolbars can appear in the array. A form appears in the array only if the form's <b>Dockable</b> property is set to a value greater than 0.
      The following table illustrates the information that the array contains.
      1
      Name of the form, IDE window, or toolbar.
      For user-defined toolbars, the first element contains the <b>Caption</b> property value for that toolbar.
      2
      Dock state:
      1 - Docked
      0 - Undocked
      3
      Dock position.
      For form and toolbar values, see DockPosition Property. For windows, see DOCK Command.
      Target object that specified object is docked with.
      This element does not apply to toolbars unless they are docked to the main X# window. For toolbars or windows docked to the main X# window, the fourth element contains the main X# window name, which you can retrieve using the _<b>VFP</b> <b>Caption</b> property. If a window or toolbar is not docked, the fourth element contains an empty string.
      If a toolbar appears between the X# desktop and a window docked to the X# desktop, the fourth element contains the name of the toolbar.
      Object reference to docking form or toolbar.
      Applies only when docking user-defined forms or toolbars; otherwise, this element contains an empty string (IDE window).
      Object reference to the target object if it is a user-defined form. If the target object is the main X# window, this element contains an object reference to the <b>_SCREEN</b> system variable. Otherwise, this element contains an empty string (IDE window).

    </param>
    <param name="nType">

      Specifies one or more items for which you want <b>ADOCKSTATE( )</b> to return dock state information.
      The following table lists the values for nType.
      0
      Return all or no windows. (Default)
      1
      Return only IDE windows.
      2
      Return only toolbars.
      3
      Return only user-defined forms.

    </param>
    <param name="nExtended">

      Specifies the number of elements to return in the array.
      The following table lists the values for nExtended.
      0
      Return a four-element array for windows and toolbars.
      1
      Return a six-element array for forms.
    </param>
    <returns>
      Numeric data type. <b>ADOCKSTATE( )</b> returns the number of rows populated or 0 if none found.
    </returns>
    <remarks>
      For tab-docked windows, the leftmost window is the anchor window and contains details about how the entire container is docked. X# traverses the windows from left to right. For link-docked windows, the upper left window in a link-docked container contains details about how the entire container is docked.
      The following rules determine docking order:
      X# traverses the link-docked container beginning with upper leftmost window.
      X# traverses windows from top to bottom, from left to right. A link-docked container might consist of multiple inner containers. Thus, the ordering of windows in the <b>ADOCKSTATE( )</b> array might appear different.
      The position contained in the third element of the array is relative to the window referenced in first element of the array.
      X# traverses all link-docked windows first and tab-docked windows second. Essentially, X# makes two passes through a linked container. X# includes only the leftmost tab-docked window in the first pass for link-docked windows.
      X# traverses a tab-docked container from left to right.
      If the third element in the array is set to -1 (not docked), the container is not docked. If the container is docked to the desktop, the third element in the array contains the position in which the container is docked to the X# desktop as referenced in the fourth element of the array.
      For example, the following code creates an array, opens and docks several windows, and produces an array as shown:
       <code language="X#">
        CLEAR ALL
        PUBLIC aa
        DIMENSION aa[1]
        ACTIVATE WINDOW Command
        ACTIVATE WINDOW Trace
        ACTIVATE WINDOW Document
        ACTIVATE WINDOW Properties
        ACTIVATE WINDOW Watch
        ACTIVATE WINDOW Locals
        SET
        DOCK WINDOW View POSITION -1
        DOCK WINDOW Command POSITION -1
        DOCK WINDOW Trace POSITION -1
        DOCK WINDOW Document POSITION -1
        DOCK WINDOW Properties POSITION -1
        DOCK WINDOW Watch POSITION -1
        DOCK WINDOW Command POSITION 1 WINDOW View
        DOCK WINDOW Trace POSITION 1 WINDOW Command
        DOCK WINDOW Document POSITION 3 WINDOW View
        DOCK WINDOW Properties POSITION 3 WINDOW Trace
        DOCK WINDOW Watch POSITION 4 WINDOW Command
        DOCK WINDOW Locals POSITION 3 WINDOW Command
        ADOCKSTATE(aa,1)
      </code>
      The resulting array appears as follows:
      1
      Trace
      1
      -1
       
      2
      Properties
      1
      3
      Trace
      3
      Watch
      1
      2
      Trace
      4
      Locals
      1
      3
      Watch
      5
      View
      1
      2
      Watch
      6
      Document View
      1
      3
      View
      7
      Command
      1
      4
      Watch
      X# displays docking information for debugger windows in the debugger. If a window is undocked, X# shows the name, dock state (0) and position (-1). If a window is docked, X# shows only the name, dock state (1), position, and window ("X# Debugger").
      Historically, in prior versions of X#, the Data Session window has always been referred to as the View window. Additionally, language used to control this window, such as <b>HIDE WINDOW</b>, <b>ACTIVATE WINDOW</b>, <b>WONTOP(</b><b> )</b>, also refers to this window as the View window. X# continues to refer to the View window for the <b>ADOCKSTATE( )</b> function.
    </remarks>
    <example>
      The following example shows the return results of <b>ADOCKSTATE( )</b> when no toolbars or windows have been previously docked, for example, after deleting the FoxUser resource files or when X# is newly installed. Make sure the Command window is open.
       <code language="X#">
        CLEAR
        dockNum = ADOCKSTATE(dockState)
        ? dockNum   &amp;&amp; Returns 2 because Standard toolbar also exists.
        ? dockState(1,1)  &amp;&amp; Outputs "COMMAND".
        ? dockState(1,4)  &amp;&amp; Outputs an empty string because the Command
        &amp;&amp; window is not docked.
        ? dockState(2,1)  &amp;&amp; Outputs "Standard".
        ? dockState(2,4)  &amp;&amp; Outputs "X#" because the
        &amp;&amp; Standard toolbar is docked to the Microsoft
        &amp;&amp; X# desktop.
      </code>
      The following example shows how to use the <b>DOCK</b> command to dock the Command window to the X# desktop window and use <b>ADOCKSTATE( )</b> to obtain the dock state of the Command window. First, make sure the Command window is open. After docking the Command window, you can see that the Standard toolbar and Command windows are docked to the X# desktop window. The position of the toolbars or windows in the array returned by <b>ADOCKSTATE( )</b> can vary depending on the order in which the toolbars or windows are docked.
       <code language="X#">
        CLEAR
        DOCK WINDOW Command POSITION 0
        dockNum = ADOCKSTATE(dockState)
        ? dockNum   &amp;&amp; Returns 2 because Standard toolbar also exists.
        ? dockState(1,1)  &amp;&amp; Outputs "Standard".
        ? dockState(1,4)  &amp;&amp; Outputs "X#".
        ? dockState(2,1)  &amp;&amp; Outputs "COMMAND".
        ? dockState(2,4)  &amp;&amp; Outputs "X#".
      </code>
    </example>
  </adockstate>
  <aerror>
    <summary>
      Creates a variable array containing information about the most recent X#, OLE, or ODBC error.
    </summary>
    <param name="ArrayName">

      Specifies the name of the array for <b>AERROR( )</b> to create.
    </param>
    <returns>
      Numeric. <b>AERROR( )</b> returns the number of rows in the array.
    </returns>
    <remarks>

      <b>AERROR( )</b> creates an array with seven columns containing information about the error. The type of error that occurred determines the number of rows in the array.
      If no error occurred, <b>AERROR( )</b> does not create the array.
      When a X# error occurs, the array contains one row. The following table describes the contents of each element.
      1
      Numeric. The number of the error. Identical to the value returned by ERROR( ).
      2
      Character. The text of the error message. Identical to the value returned by MESSAGE( ).
      3
      The null value. However, if the error has an additional error parameter, contains the text of the error parameter. Almost identical to the value returned by SYS(2018), the difference being that AERROR( ) returns mixed case but SYS(2018) returns all uppercase.
      4
      The null value. However, as appropriate, contains the number of the work area in which the error occurred.
      5
      The null value. However, if a trigger failed (error 1539), contains one of the following numeric values:1 – Insert trigger failed.2 – Update trigger failed.3 – Delete trigger failed.
      6
      The null value.
      7
      The null value.
      When OLE errors numbered 1427 or 1429 occur, the array contains one row. The following table describes the contents of each element.
      1
      Numeric. Contains 1427 or 1429.
      2
      Character. The text of the X# error message.
      3
      Character. The text of the OLE error message.
      4
      Character. The application name (for example, Microsoft Excel).
      5
      The null value or Character. Contains the name of the application's Help file where more information about the error can be found if the information is available from the application; otherwise contains the null value.
      6
      The null value or Character. Contains the Help context ID for the appropriate Help topic if the information is available from the application; otherwise contains the null value.
      7
      Numeric. An OLE 2.0 exception number.
      When an ODBC error numbered 1526 occurs, the array contains one or more rows, one row for each ODBC error. The following table describes the contents of each element.
      1
      Numeric. Contains 1526.
      2
      Character. The text of the error message.
      3
      Character. The text of the ODBC error message.
      4
      Character. The current ODBC SQL state.
      5
      Numeric. The error number from the ODBC data source.
      6
      Numeric. The ODBC connection handle.
      7
      The null value.
    </remarks>
    <example>
       <code language="X#">
        ON ERROR DO errhand     &amp;&amp; errhand is the error handler procedure
        BRWS  &amp;&amp; Causes a syntax error
        ON ERROR  &amp;&amp; Restore system error handler
        PROCEDURE errhand
        = AERROR(aErrorArray)  &amp;&amp; Data from most recent error
        CLEAR
        ? 'The error provided the following information'  &amp;&amp; Display message
        FOR n = 1 TO 7  &amp;&amp; Display all elements of the array
        ? aErrorArray(n)
        ENDFOR
      </code>
    </example>
  </aerror>
  <aevents>
    <summary>
      You can use the <b>AEVENTS( )</b> function to retrieve the number of existing event bindings.
    </summary>
    <param name="ArrayName">

      Specifies the name of the array that contains the results of <b>AEVENTS( )</b>.
      0
      Specifies that <b>AEVENTS( )</b> returns a three-element array containing an object reference to the current event source, the name of the triggered event, and how the event was triggered.
      1
      Event source
      Object reference
      2
      String
      3
      Event type, or how event was raised.
      0 - System
      1 - RAISEEVENT( ) function
      2 - Method call
      The third array element indicates how an event was triggered. If the event is a property, this value can be 1 or 2. The value is 2 if the property is set or assigned.
      1
      Specifies that <b>AEVENTS( )</b> returns a four-column array containing information about Windows Message (Win Msg) events.
      The array contains one row for each binding. Bindings are created with the BINDEVENT( ) Function.
      The following table describes the contents of each column in the array.
      hWnd
      Integer
      Window Message
      Reference of handler
      Handler delegate

    </param>
    <param name="oEventObject">

      Specifies an object reference. If you specify an object reference, <b>AEVENTS( )</b> returns a five-column array that contains the events raised and the delegate methods for oEventObject. Each row in ArrayName represents a binding. The following table describes the information in each of the five columns.
      1
      .T. if second element is the event source
      .F. if second element is the event handler
      Logical
      2
      Event source if you pass the event handler to oEventObject; otherwise, event handler if you pass the event source to oEventObject.
      Object reference
      3
      String
      4
      Delegate method
      5
      <b>BINDEVENT( )</b> flags
      Integer
      When you pass oEventObject, the number of bindings returned by <b>AEVENTS( )</b> should equal the number of unbound events returned by the <b>UNBINDEVENTS( )</b> function when passing only the oEventObject parameter.
    </param>
    <returns>
      Numeric. <b>AEVENTS( )</b> returns the number of rows in the specified array. Typically, the number represents the number of event bindings. However, if you pass zero (0), then <b>AEVENTS( )</b> returns 3.
    </returns>
    <remarks>
      If <b>AEVENTS( )</b> returns 0, and the array does not exist, X# does not create the array. X# changes or alters an existing array only if valid results are returned. The array remains unchanged under the following conditions:
      No events exist.
      You specify a value of 0 as the second parameter, and<b> AEVENTS( )</b> does not appear within an event or oEventObject has no bindings.
    </remarks>
    <example>
       <code language="X#">
        PUBLIC oHandler
        oHandler=NEWOBJECT("myhandler")
        DO (_browser)
        BINDEVENT(_SCREEN,"Resize",oHandler,"myresize")
        AEVENTS(myArray,oHandler)
        numRows=ALEN(myArray,1)
        numCols=ALEN(myArray,2)
        WAIT "Rows in array after binding: " + TRANSFORM(numRows) WINDOW AT 20,20
        WAIT "Cols in array after binding: " + TRANSFORM(numCols) WINDOW AT 20,20
        FOR count1 = 1 TO numRows
        FOR count2 = 1 TO numCols
        WAIT myArray[count1,count2] WINDOW AT 20,20
        ENDFOR
        ENDFOR
        * Comment the following line to see event binding persist.
        UNBINDEVENTS(_SCREEN,"Resize",oHandler,"myresize")
        AEVENTS(myArray,oHandler)
        * Check if AEVENTS( ) created and populated new array.
        IF VARTYPE(myArray) &lt;&gt; U
        * The following code does not execute if event is unbound because
        * AEVENT( ) does not create a new array if it returns 0. To execute
        * the following code and see the contents of the new array, uncomment
        * the UNBINDEVENTS( ) statement.
        numRows=ALEN(myArray,1)
        numCols=ALEN(myArray,2)
        WAIT "Rows in array after unbinding: " + TRANSFORM(numRows) ;
        WINDOW AT 20,20
        WAIT "Cols in array after unbinding: " + TRANSFORM(numCols) ;
        WINDOW AT 20,20
        FOR count1 = 1 TO numRows
        FOR count2 = 1 TO numCols
        WAIT myArray[count1,count2] WINDOW AT 20,20
        ENDFOR
        ENDFOR
        ENDIF
        DEFINE CLASS myhandler AS Session
        PROCEDURE myresize
        _obrowser.left = _SCREEN.Width - _obrowser.width
        RETURN
        ENDDEFINE
      </code>
    </example>
  </aevents>
  <afields>
    <summary>
      Retrieves and stores information about the structure of the table in a specified work area, specified by a table alias, or in the currently selected work area in an array and returns the number of fields in the table.
    </summary>
    <param name="ArrayName">

      Specifies an array to store information about the table structure.
      If the array you specify does not exist, X# automatically creates it. If the array exists and is not large enough to contain all the information returned by <b>AFIELDS( )</b>, the size of the array is automatically increased to accommodate the information.

    </param>
    <param name="nWorkArea">

      Specifies the work area of the table.

    </param>
    <param name="cTableAlias">

      Specifies a table alias.
      If you omit nWorkArea and cTableAlias, <b>AFIELDS( )</b> retrieves information for the table in the currently selected work area.
    </param>
    <returns>
      Numeric data type. <b>AFIELDS( )</b> returns the number of fields in the table. The array contains 18 columns and has the same number of rows as fields in the table.
      The following table describes the content of each column in the first row of the array and the data type of the information stored in each column. Values for table-specific properties in columns 10 through 16 only appear in the first row of the array. One row is created for each field in the table.
      1
      Field name
      Character
      2
      Field type:
      C = Character
      Y = Currency
      D = Date
      T = DateTime
      B = Double
      F = Float
      G = General
      I = Integer
      L = Logical
      M = Memo
      N = Numeric
      Q = Varbinary
      V = Varchar and Varchar (Binary)
      W = Blob
      Character
      3
      Field width
      Numeric
      4
      Decimal places
      Numeric
      5
      Null values allowed
      Logical
      6
      Code page translation not allowed
      Logical
      7
      Field validation expression
      Character
      8
      Field validation text
      Character
      9
      Field default value
      Character
      10
      Table validation expression
      Character
      11
      Table validation text
      Character
      12
      Long table name
      Character
      13
      Insert trigger expression
      Character
      14
      Update trigger expression
      Character
      15
      Delete trigger expression
      Character
      16
      Table comment
      Character
      17
      NextValue for autoincrementing
      Numeric
      18
      Step for autoincrementing
      Numeric
    </returns>
    <remarks>
      If the fields in the table use autoincrementing, the Step value is greater than 0.
      You can use COPY STRUCTURE EXTENDED to place similar information into a table instead of an array.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE Customer     &amp;&amp; Open Customer table.
        gnFieldcount = AFIELDS(gaMyArray)  &amp;&amp; Create array.
        CLEAR
        FOR nCount = 1 TO gnFieldcount
        ? gaMyArray(nCount,1)  &amp;&amp; Display field names.
        ENDFOR
      </code>
    </example>
  </afields>
  <afont>
    <summary>
      Places information about available fonts, such as their names, into an array.
      You can also use <b>AFONT( )</b> to determine available font sizes or if a font is scalable. To display a dialog box containing available fonts, font sizes, and styles, use the <b>GETFONT( )</b> function. For more information, see GETFONT( ) Function.
    </summary>
    <param name="ArrayName">

      Specifies the variable array into which the names of available fonts are placed. If the array is not large enough to contain all the fonts, X# automatically increases the size of the array. If you specify an existing two-dimensional array, X# changes the array to a one-dimensional array.

    </param>
    <param name="cFontName">

      Specifies a font for which information is placed into the array.
      If the font you specify supports only discrete font sizes (8-point, 10-point, ...), the font sizes are stored to the array, and <b>AFONT( )</b> returns True (.T.). If the font you specify in cFontName is scalable (supports fractional font size values), the array has a single element containing –1, and <b>AFONT( )</b> returns True (.T.).
      If the font you specify is not available, the array is not created, and <b>AFONT( )</b> returns False (.F.).

    </param>
    <param name="nFontSize">

      Specifies a size for the font specified in cFontName.
      If the font size nFontSize is available for the font specified in cFontName, the array has a single element containing a True (.T.) value, and <b>AFONT( )</b> returns True (.T.). If the font size is not available for the specified font, the array is not created, and <b>AFONT( )</b> returns False (.F.).

    </param>
    <param name="nFontCharSet">

      Specifies a character set for the font specified in cFontName. If the font character set specified is available for the font specified in cFontName, the array has a single element containing a True (.T.) value, and <b>AFONT( )</b> returns True (.T.). If the font character set is not available for the specified font, the array is not created, and <b>AFONT( )</b> returns False (.F.).

    </param>
    <param name="nFlags">

      Controls whether the third parameter passed is treated as the font size or font character set.
      The following table describes behavior for various nFlags values specified.
      Omitted or 0 for the first bit
      Third parameter is treated as a font size value.
      If third parameter is -1, array is updated with all available font sizes for the font specified in cFontName for nonproportional fonts, such as MS Sans Serif, and <b>AFONT( )</b> returns True (.T.). This behavior in X# 8.0 and later is equivalent to passing only the first two parameters.
      In versions prior to X# 8.0, if you specified any negative or positive font size for a non-proportional font, <b>AFONT( )</b> returned False (.F.).
      If the third parameter passed is 0, for nonproportional fonts, <b>AFONT( )</b> returns False (.F.) for X# 8.0 and later. However, the behavior for proportional fonts such as TrueType or OpenType (Arial) has not changed.
      Third parameter is treated as a font character set. Array is populated with character sets available for the specified font.
      If the third parameter passed is -1, array is updated with all available font character sets for the font specified in cFontName.
    </param>
    <returns>
      Logical data type. <b>AFONT( )</b> returns True (.T.) if array is successfully created. Otherwise, <b>AFONT( )</b> returns False (.F.).
    </returns>
    <remarks>
      If only ArrayName was passed in versions earlier than X# 8.0, the array populated in <b>AFONT( )</b> included extra fonts that were really part of a single font family. For example, the array might have included the following Arial fonts under X# 7.0:
      Arial
      Arial Baltic
      Arial Black
      Arial CE
      Arial CYR
      Arial Greek
      Arial Narrow
      Arial Tur
      Many of these fonts are not included in a standard Font Picker dialog box such as the <b>GETFONT( )</b> function. In this version of X#, the array in <b>AFONT( )</b> excludes these extra fonts. For example, the array only includes the following fonts:
      Arial
      Arial Baltic
      Arial Black
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        =AFONT(gaFontArray)  &amp;&amp; Array containS font names.
        gnNumFonts = ALEN(gaFontArray)  &amp;&amp; Number of fonts
        IF gnNumFonts &gt; 10
        gnNumFonts = 10  &amp;&amp; Display first 10 fonts.
        ENDIF
        FOR nCount = 1 TO gnNumFonts
        ? ALLTRIM(gaFontArray(nCount))  &amp;&amp; Display font name.
        ?? '  This is an example of ' ;
        + ALLTRIM(gaFontArray(nCount)) FONT gaFontArray(nCount), 8
        ENDFOR
      </code>
    </example>
  </afont>
  <agetclass>
    <summary>
      Displays class libraries in the <b>Open</b> dialog box and creates an array containing the name of the class library and class chosen.
    </summary>
    <param name="ArrayName">

      Specifies the name of the array in which the names of the class library and class are placed. The following table lists the contents of each element of the array created when you chose a class.
      1
      File name of the class library chosen.
      2
      Name of the class chosen.

    </param>
    <param name="cLibraryName">

      Specifies the name of the class library initially selected when the Open dialog is displayed. cLibraryName can be a visual (.vcx) or program (.prg) -based class library.
      The class library name you specify is displayed in the File name text box. An error is generated if the class library you specify doesn't exist or cLibraryName is the empty string or the null value.

    </param>
    <param name="cClassName">

      Specifies the name of the class initially selected in the Class name list when the Open dialog is displayed. If the class you specify doesn't exist, the first class in the Class name list is selected. An error is generated if you omit cLibraryName or cClassName is the null value.

    </param>
    <param name="cTitleText">

      Specifies the text displayed in the title bar of the Open dialog. By default, "Open" is the text displayed.

    </param>
    <param name="cFileNameCaption">

      Specifies the text displayed next to the File name text box. By default, "File name:" is the text displayed.

    </param>
    <param name="cButtonCaption">

      Specifies the caption for the OK button.
    </param>
    <returns>
      Logical data type. AGETCLASS( ) returns True (.T.), if you chose a class, and creates a one-dimensional array containing two elements. The first element contains the file name of the class library chosen; the second element contains the name of the class chosen. AGETCLASS returns False (.F.) if you exit the Class Library dialog box by pressing ESC, choosing Cancel, or clicking the Close button.
    </returns>
    <remarks>
      If the array you specify does not exist, X# automatically creates the array.
      If the array exists and is not large enough to contain the names of the class library and class, X# automatically increases the size of the array.
      If the array is larger than necessary, X# truncates the array. If the array exists, and AGETCLASS( ) returns False (.F.) because the Class Library dialog box was closed by pressing ESC, choosing Cancel, or clicking the Close button, the array remains unchanged.
      If the array does not exist, and AGETCLASS( ) returns false (.F.), the array is not created.
      X# 8.0 does not support AGETCLASS( ) in its run-time libraries. AGETCLASS( ) is supported in X# 9.0 run-time libraries, but the Program (*.prg) option is not available in the <b>Files of type</b> drop-down list box.
    </remarks>
    <example>
       <code language="X#">
        LOCAL aClassLib(2)  &amp;&amp; Create an array, initialized to .F.
        cCurrentDir = CURDIR( )  &amp;&amp; Save the current directory.
        CD HOME(2) + 'CLASSES'  &amp;&amp; Switch directories.
        AGETCLASS(aClassLib, 'BUTTONS.VCX', 'VCR', 'Modify Class', ;
        'Class File:', 'Modify')  &amp;&amp; Display the dialog.
        CD (cCurrentDir)  &amp;&amp; Switch to the previous directory.
        IF TYPE('aClassLib(2)') = 'C'  &amp;&amp; Class chosen?
        MODIFY CLASS (aClassLib(2)) OF (aClassLib(1))  &amp;&amp; Open to modify.
        ENDIF
      </code>
    </example>
  </agetclass>
  <ainstance>
    <summary>
      Places instances of a class into a variable array and returns the number of instances placed in the array.
    </summary>
    <param name="ArrayName">

      Specifies the name of the array into which the instances are placed. If the array you specify doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain all the instances, X# automatically increases the size of the array to accommodate the instances. If the array is larger than necessary, X# truncates the array. If the array exists and AINSTANCE( ) returns 0 because no instances are found, the array remains unchanged. If the array doesn't exist and AINSTANCE( ) returns 0, the array is not created.
      Only class instances assigned to variables and array elements with CREATEOBJECT( ) or NEWOBJECT( ) are placed into the array.

    </param>
    <param name="cClassName">

      Specifies a X# base class name or a user-defined class name. For a complete list of the X# base classes, see Base Classes in X#.
    </param>
    <returns>
      Numeric
    </returns>
    <example>
       <code language="X#">
        CLEAR ALL
        goINSTANCE1 = CREATEOBJECT('Form')
        goINSTANCE2 = CREATEOBJECT('Form')
        CLEAR
        ? AINSTANCE(gaMyArray, 'Form')  &amp;&amp; Returns 2, two form instances
        DISPLAY MEMORY LIKE gaMyArray  &amp;&amp; Displays the references
      </code>
    </example>
  </ainstance>
  <alanguage>
    <summary>
      Returns an array containing the names of all valid X# commands, functions, or base classes.
    </summary>
    <param name="ArrayName">

      Specifies the name of the array to contain the language items. If the array doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain all the data, X# automatically increases the size of the array to accommodate the information. If the array is larger than necessary, X# truncates the array.

    </param>
    <param name="nType">

      Specifies the type of language item returned, according to the following list:
      1
      Commands
      One-dimensional:    Command name
      2
      Functions
      Two-dimensional:
      Function name   [M] nParamR [- nParamT]
      The matchFlag, M, specifies that you must use the full    function name in code.nParamR specifies the number of required parameters. nParamT specifies total number of possible parameters.
      3
      Base classes
      One-dimensional:
      Base Class name
      4
      DBC Events
      DBC event name (The displayed name omits the "DBC_" prefix of the event name.)
    </param>
    <remarks>
      The ALANGUAGE( ) function returns an array of all valid X# commands and functions. To return object information, use the AMEMBERS( ) function.
      Use the ALANGUAGE( ) function to access X# functions as in the following code:
       <code language="X#">   ALANGUAGE(FuncArr,2)</code>
      The resulting array, FuncArr, will contain the following values:
       <code language="X#">   JUSTSTEM, M1</code>
      JUSTSTEM( ) cannot be abbreviated and it requires one parameter.
       <code language="X#">   KEYMATCH, 1-4</code>
      KEYMATCH( ) can be abbreviated to four characters, and has one required, and three optional parameters (total = 4).
       <code language="X#">   LASTKEY, 0</code>
      LASTKEY( ) can be abbreviated and requires no parameters.
    </remarks>
  </alanguage>
  <alias>
    <summary>
      Returns the table alias of the current or specified work area.
    </summary>
    <param name="nWorkArea">

      Specifies the work area number for which ALIAS( ) returns the table alias.

    </param>
    <param name="cTableAlias">

      Specifies the table alias for which ALIAS( ) returns the table alias.
      If you omit nWorkArea or cTableAlias, ALIAS( ) returns the alias of the table open in the current work area. An empty string is returned if a table isn't open in the current or specified work area.
    </param>
    <returns>
      Character
    </returns>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer     &amp;&amp; Open customer table
        CLEAR
        ? ALIAS( )  &amp;&amp; Display the alias
        SELECT 0
        USE customer AGAIN ALIAS MyCustomer  &amp;&amp; Different alias
        ? ALIAS( )  &amp;&amp; Display the alias
      </code>
    </example>
  </alias>
  <alltrim>
    <summary>
      Removes all leading and trailing spaces or parsing characters from the specified character expression, or all leading and trailing zero (0) bytes from the specified binary expression.
    </summary>
    <param name="Expression">

      Specifies an expression of <b>Character</b> or <b>Varbinary</b> type to remove leading and trailing spaces or 0 bytes from, respectively.

    </param>
    <param name="nFlags">

      Specifies if trimming is case-sensitive when one or more parse characters (cParseChar, cParseChar2, … are included. Trimming is case-sensitive if nFlags is zero or is omitted. Trimming is case-insensitive if nFlags 1.

      cParseChar [, cParseChar2 [, ...]]
      Specifies one or more character strings that are trimmed from the beginning and end of cExpression. If cParseChar is not included, then leading and trailing spaces or 0 bytes are removed from Expression.
      <b>Note</b>   The maximum number of strings permitted in cParseChar is 23.
    </param>
    <returns>
      Character or Varbinary. <b>ALLTRIM( )</b> returns the specified expression without leading or trailing spaces, parsing characters, or 0 bytes respectively.
    </returns>
    <remarks>
      You can use <b>ALLTRIM( )</b> to ensure that spaces or 0 bytes are removed from data entered by a user.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        =AFONT(gaFontArray)  &amp;&amp; Array containing font names
        gnNumFonts= ALEN(gaFontArray)  &amp;&amp; Number of fonts
        IF gnNumFonts &gt; 10
        gnNumFonts = 10  &amp;&amp; Display first 10 fonts
        ENDIF
        FOR nCount = 1 TO gnNumFonts
        ? ALLTRIM(gaFontArray(nCount))  &amp;&amp; Display font name
        ?? '  This is an example of ' ;
        + ALLTRIM(gaFontArray(nCount)) FONT gaFontArray(nCount), 8
        ENDFOR
      </code>
    </example>
  </alltrim>
  <amouseobj>
    <summary>
      Creates an array containing information about the mouse pointer position and the object over which the mouse pointer is positioned.
    </summary>
    <param name="ArrayName">

      Specifies the name of the array containing the mouse pointer information. If the array you specify doesn't exist, X# automatically creates a four-row array. If the array exists, X# dimensions it to four rows.
      The following table describes the contents of each row in the array:
      1
      Contains an object reference to the object over which the mouse pointer is positioned when AMOUSEOBJ( ) is executed.
      2
      Contains an object reference to the container of the object over which the mouse pointer is positioned when AMOUSEOBJ( ) is executed.
      3
      Contains the horizontal (X) coordinate in pixels of the mouse pointer, relative to the container of the object over which the mouse pointer is positioned when AMOUSEOBJ( ) is executed.
      4
      Contains the vertical (Y) coordinate in pixels of the mouse pointer, relative to the container of the object over which the mouse pointer is positioned when AMOUSEOBJ( ) is executed.
      The first and second rows in the array can contain the same values if the mouse is positioned over a generic container such as a pageframe.
      [, 1]
      This optional parameter specifies that the mouse pointer information contained in the array is relative to the current form (THISFORM). If you include this option, the second array row always contains an object reference to the current form, and the third and fourth rows contain the mouse pointer coordinates relative to the current form.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      You can also use AMOUSEOBJ( ) to determine where to position the mouse pointer during design time. The following table lists the design time element and the values contained in each row of the array:
      Form and Class Designers
      Row 1 – Object reference to the control.Row 2 – Object reference to the form.Row 3 – Mouse pointer horizontal (X) coordinate relative to the form.Row 4 – Mouse pointer vertical (Y) coordinate relative to the form.
      Project Manager
      Row 1 – Object reference to the project.Row 2 – Object reference to the project.Row 3 – Zero.Row 4 – Zero.
      X# Desktop
      Row 1 – Object reference to the desktop.Row 2 – Object reference to the desktop.Row 3 – Mouse pointer horizontal (X) coordinate relative to the desktop.Row 4 – Mouse pointer vertical (Y) coordinate relative to the desktop.
      AMOUSEOBJ( ) returns 4 (the number of rows in the array) if you position the mouse pointer over an area listed above. If you position the mouse pointer over an area other than those listed above, AMOUSEOBJ( ) returns zero. If the array you specify already exists, it remains unchanged. If the array you specify does not exist, the system does not create it.
    </remarks>
  </amouseobj>
  <ansitooem>
    <summary>
      Included for backward compatibility. Use CPCONVERT( ) Function instead.
      Converts each character of a character expression to the corresponding character in the MS-DOS (OEM) character set.
    </summary>
    <returns>
      Return value - Character
    </returns>
    <remarks>
      <br />
      ANSITOOEM() is supported in FoxPro for Windows and FoxPro for Macintosh.<br />
      <br />
      Use ANSITOOEM() to move data from FoxPro for Windows and FoxPro for Macintosh to FoxPro for MS-DOS. ANSITOOEM() converts each character in expC to the corresponding character in the MS-DOS (OEM) character set. The character expression expC should contain characters from the ANSI character set.<br />
      <br />
      If a character in expC doesn't have an MS-DOS equivalent, the character is converted to a similar MS-DOS character.<br />
      <br />

    </remarks>
  </ansitooem>
  <aprocinfo>
    <summary>
      Creates an array containing X# language elements contained in a program file.
    </summary>
    <param name="ArrayName">

      Specifies the name of the array to be created.

    </param>
    <param name="cFileName">

      Specifies the filename of the program that this function traverses.

    </param>
    <param name="nType">

      Specifies the type of information returned in cArrayName. The following table specifies valid nType values and describes the information returned by each nType value.
      0 (default
      Populates the array with all document information.
      Column1 – Doc View content
      Column2 – line
      Column3 – type
      Column4 – indentation
      Indentation is used with preprocessor directives to show nested levels of #IF type statements.
      Populates the array with only the class definitions in the document.
      Column1 – class name
      Column3 – parentclass
      Column4 - is OLEpublic
      Populates the array with only class procedure information (class definition excluded)
      Populates the array with #define and other preprocessor directives in the document.
      The following table describes the "type" values returned in Column3 for nType values of 0 and 3.
      Define
      #DEFINE preprocessor directive
      Directive
      Other preprocessor directives, such as #IF
      Class
      Class definition line
      Procedure
      Procedure, Method or Event
    </param>
    <returns>
      Numeric. APROCINFO( ) returns the number of rows added to the array.
    </returns>
    <remarks>
      X# automatically creates the array you specify if it doesn't already exist. X# automatically increases or truncates the size of the array to accommodate the returned information. This function supports program (PRG) files only.
    </remarks>
  </aprocinfo>
  <asc>
    <summary>
      Returns the ANSI value for the leftmost character in a character expression.
    </summary>
    <param name="cExpression">

      Specifies the character expression containing the character whose ANSI value ASC( ) returns. Any characters after the first character in cExpression are ignored by ASC( ).
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      ASC( ) returns the position of the character in the character table of the current code page. Every character has a unique ANSI value in the range from 0 to 255.
    </remarks>
    <example>
       <code language="X#">
        STORE 'ABCDEFGHIJ' TO gcANSI  &amp;&amp; 10 characters
        CLEAR
        FOR nCOUNT = 1 TO 10
        ? SUBSTR(gcANSI, nCount,1)  &amp;&amp; Display a character
        ?? ASC(SUBSTR(gcANSI, nCount)) &amp;&amp; Display ANSI value
        ENDFOR
      </code>
    </example>
  </asc>
  <ascan>
    <summary>
      Searches an array for an element containing the same data and data type as an expression.
    </summary>
    <param name="ArrayName">

      Specifies the name of the array to search.

    </param>
    <param name="eExpression">

      Specifies the general expression to search for.

    </param>
    <param name="nStartElement">

      Specifies the element number at which the search begins. The element number you specify is included in the search. If you omit nStartElement or if you pass negative value on its place, the entire array is searched by default.

    </param>
    <param name="nElementsSearched">

      Specifies the number of elements that are searched. If you omit nStartElement and nElementsSearched or if you pass negative value on its place, the search begins with the first array element and continues to the last array element if you do not specify nSearchColumn.
      You can refer to an element in a two-dimensional variable array in one of two ways. The first method uses two subscripts to specify the row and column position of the element in the array; the other method uses an element number. This function and others that manipulate two-dimensional arrays require element numbers (nStartElement and nElementsSearched). Use AELEMENT( ) to return the element number from row and column subscripts in a two-dimensional array.

    </param>
    <param name="nSearchColumn">

      Specifies the array column to search. This is often useful in arrays created by functions such as AFIELDS( ).
      You can use 0 or a negative number for nSearchColumn to impose a search of the entire array. If you use a value greater than 0 for nSearchColumn, ASCAN( ) treats the specified column as a one-dimensional array, using each data row as an element in the search. For instance, the following example searches only the third and fourth elements of column 2 instead of the entire array.
       <code language="X#">? ASCAN(abc,"M",3,2,2)</code>
      X# generates an error if nSearchColumn is a number larger than the number of available columns.
      <code language="X#">? ASCAN(abc,"HELLO",-1,-1,2,15) &amp;&amp; Search the whole column 2 of two-dimensional array</code>
      nFlags

      Specifies additional search criteria to apply to the scan function. Default scans are case-sensitive.
      The number you specify in nFlags provides a bit-value that determines the case sensitivity or exactness setting of a scan according to the following table:
      NFlag
      0000
      Behavior existing in X# 6 or earlier
      0001
      Case Insensitive
      0010
      Current behavior existing in the previous version of X#
      0011
      4
      0100
      Exact OFF
      0101
      Case Insensitive; Exact OFF
      0110
      Exact ON
      7
      0111
      Case Insensitive; Exact ON
      8
      1000
      Return row number
      9
      1001
      Case Insensitive; return row number
      1010
      1011
      12
      1100
      Return row number; Exact OFF
      13
      1101
      Case Insensitive; Return row number; Exact OFF
      14
      1110
      Return row number; Exact ON
      1111
      Case Insensitive; Return row number; Exact ON
      The bit values are as follows:
      Case Insensitive bit
      Exactness ON bit (Only effective if bit 2 is set)
      Override system Exact setting bit
      Return row number if 2D array
      nFlags applies only to the ASCAN( ) function and does not affect settings for SET EXACT.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      If a match is found, ASCAN( ) returns the number of the element containing the expression. If a match cannot be found, ASCAN( ) returns 0.
      The criteria for a successful match of character data are determined by the setting of the system SET EXACT if nFlag with bit 2 is not set. If SET EXACT is ON, an element must match the search expression character for character and have the same length. If SET EXACT is OFF, and an element and search expression match until the end of the expression is reached, the match is successful. For more information on match criteria for character strings, see the string comparison table in the SET EXACT Command topic.
      In X# 6.0, the nStartElement and nElementsSearched parameters are optional. The nStartElement must be &gt; 0 while nElementsSearched can be any value. In order to accommodate the nSearchColumn parameter, you will need to bypass these parameters by passing a value of -1.
      The nStartElement and nElementsSearched parameters take on special meaning if the value of nSearchColumn is greater than 0. In X# 6.0, they are always referenced to the entire array. Beginning with X# 7.0, if a positive nSearchColumn is passed, the values of nStartElement and nElementsSearched are referenced to the single one-dimensional array represented by the nSearchColumn. For example, the following would only search the third and fourth elements of column 2, and not the entire array:
       <code language="X#">? ASCAN(abc,"M",3,2,2)</code>
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer     &amp;&amp; Open customer table
        SELECT company FROM customer ;
        WHERE country = 'UK' ;
        INTO ARRAY gaCompanies
        gnCount = _TALLY
        gcName = 'Seven Seas Imports'
        CLEAR
        DISPLAY MEMORY LIKE gaCompanies*
        gnPos = ASCAN(gaCompanies, gcName) &amp;&amp; Search for company
        IF gnPos != 0
        *** Company found, remove it from the array ***
        = ADEL(gaCompanies, gnPos)
        gnCount = gnCount - 1
        ENDIF
        DISPLAY MEMORY LIKE gaCompanies
      </code>
    </example>
  </ascan>
  <aselobj>
    <summary>
      Places an object reference for the currently selected control or container that exists in the Form Designer, Class Designer, or code editing window into a specified variable array. When calling ASELOBJ( ) in a code editing window, the array also includes elements for forms (.scx), visual class libraries (.vcx), and #INCLUDE file names. You can also use ASELOBJ( ) to create control builders.
    </summary>
    <param name="ArrayName">

      Specifies the name of the array you want to use.
      1
      Creates a one-element array containing an object reference to the container for the currently active and selected control.
      For example, if the currently active and selected control is a spinner on a form, the array contains an element with the value "FORM." When calling ASELOBJ( ) in the Command window, include this argument.
      When a page frame is selected, ASELOBJ() returns the name of the current page.
      2
      Creates a one-element array containing an object reference to the DataEnvironment object for the form. The DataEnvironment object makes it possible for you to determine the data environment properties of the form.
      3
      Creates three-element array containing information in context with the currently active code editing window: object reference to a container object, the full path and name of the .scx or .vcx file, and the full path and name of the #INCLUDE file, if available.
      The following table shows the order in which these elements appear.
      Object reference to container object
      Full path and name of .scx or .vcx file
      Full path and name of #INCLUDE file, if available
      If no #INCLUDE file is available, the third element contains an empty string.
    </param>
    <returns>
      Numeric data type. ASELOBJ( ) returns the number of objects selected. The array contains three columns and a row for each selected object. .
    </returns>
    <remarks>
      If no controls are selected, and the argument, 1, is omitted, ASELOBJ( ) returns 0 and does not create the array. If no controls exist on the form, ASELOBJ( ) does not recognize the form as the selected control. If no controls are currently selected and the argument, 1, is included, ASELOBJ( ) returns 1.
      If the array does not exist, X# automatically creates the array.
      If the array exists but is too small to contain all the information, X# automatically increases the size of the array to accommodate the information. If the array is larger than needed, X# truncates the array.
      If the array exists, and ASELOBJ( ) returns 0 because no controls are selected, the array remains unchanged. If the array does not exist, and ASELOBJ( ) returns 0, the array is not created.
    </remarks>
    <example>
       <code language="X#">
        gnobjects = ASELOBJ(gaSelected)     &amp;&amp; Create array of control names
        IF gnobjects &gt; 0  &amp;&amp; 0 indicates no controls selected
        CLEAR
        DISPLAY MEMORY LIKE gaSelected     &amp;&amp; Displays selected controls
        FOR nCnt = 1 TO gnobjects
        ? gaSelected(nCnt).Caption + ' =&gt; New Caption ' ;
        + LTRIM(STR(nCnt))  &amp;&amp; Display old and new caption
        gaSelected(nCnt).Caption = 'New Caption ' ;
        + ALLTRIM(STR(nCnt))  &amp;&amp; Assign new caption
        NEXT
        ENDIF
      </code>
    </example>
  </aselobj>
  <asin>
    <summary>
      Returns in radians the arc sine of a numeric expression.
    </summary>
    <param name="nExpression">

      Specifies the numeric expression whose arc sine ASIN( ) returns. The value of nExpression can range from +1 through –1, and the value ASIN( ) returns can range from –pi/2 through +pi/2 ( –1.57079 to 1.57079). The number of decimal places in the display of the result can be specified with SET DECIMALS.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      Use RTOD( ) to convert radians to degrees.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? RTOD(ASIN(0))  &amp;&amp; Returns 0.00
        STORE 1 to gnArcAngle
        ? RTOD(ASIN(gnArcAngle))  &amp;&amp; Returns 90.00
        ? RTOD(ASIN(SQRT(2)/2))  &amp;&amp; Returns 45.00
      </code>
    </example>
  </asin>
  <asort>
    <summary>
      Sorts elements in an array in ascending or descending order.
    </summary>
    <param name="ArrayName">

      Specifies the name of the array to sort.

    </param>
    <param name="nStartElement">

      Specifies the starting element of the sort. If you omit nStartElement, the array is sorted starting with the first array element by default. If the array is one-dimensional, the sort includes nStartElement. If the array is two-dimensional, the starting element nStartElement determines both the row where the sort begins and the column that determines the sort order of the rows.
      You can refer to an element in a two-dimensional array in one of two ways. The first method uses two subscripts to specify the row and column position of the element in the array; the other method uses an element number. This function and others that manipulate two-dimensional arrays require element numbers (in ASORT() the numeric expressions nStartElement and nNumberSorted). You can use AELEMENT( ) to return the element number from row and column subscripts in a two-dimensional array.
      The following example illustrates that the starting element nStartElement determines how the rows in a two-dimensional array are sorted. A small array named codegaArray/code is created and sorted twice. The first sort begins with the first element of codegaArray/code; the rows are sorted based on the values contained in the first column of the array. The second sort begins with the fourth element of codegaArray/code; the rows are sorted based on the values contained in the second column.
      The first sort begins with the first row. The second sort begins with the second row. You can use DISPLAY MEMORY to display the contents of the array; in these examples tables are used to graphically display the results of the sorts.
      These commands create the array named codegaArray/code:
       <code language="X#">
        DIMENSION gaArray(3,2)
        gaArray(1) = 'G'
        gaArray(2) = 'A'
        gaArray(3) = 'C'
        gaArray(4) = 'Z'
        gaArray(5) = 'B'
        gaArray(6) = 'N'
      </code>
      codegaArray/code looks like this:
      Row 1
      Row 2
      Row 3
      The array is then sorted by ASORT( ) starting with the first element (1,1) in the array. The elements in the first column are placed in ascending order by rearranging the rows of the array.
       <code language="X#">=ASORT(gaArray,1)</code>
      Note the new order of the rows:
      The array is then sorted starting with the fourth element (2,2) in the array. The elements in the second column are placed in order by rearranging the array rows.
       <code language="X#">=ASORT(gaArray,4)</code>
      Note the difference in the order of the rows:

    </param>
    <param name="nNumberSorted">

      Specifies the number of elements that are sorted in a one-dimensional array, or the number of rows that are sorted in a two-dimensional array. For example, if the array is one-dimensional and nStartElement is 2, indicating that the sort starts with the second array element, and nNumberSorted is 3, indicating that the sort should include three elements, the second, third and fourth array elements are sorted. If nNumberSorted is –1 or is omitted, all array elements from the starting element nStartElement through the last element in the array are sorted.
      If the array is two-dimensional, nNumberSorted designates the number of rows to sort, beginning with the row containing the starting element nStartElement. For example, if nStartElement is 2 and nNumberSorted is 3, the row containing the second array element and the following two rows are sorted. If nNumberSorted is –1 or is omitted, all array rows beginning with the row containing the starting element nStartElement through the last array row are sorted.

    </param>
    <param name="nSort">

      Specifies the sort order (ascending or descending) for the elements in the array. By default, array elements are sorted in ascending order. If nSortOrder is 0 or is omitted, the array elements are sorted in ascending order. If nSortOrder is any positive value, the array elements are sorted in descending order.

    </param>
    <param name="nFlags">

      Specifies case-sensitive search criteria to apply to the sort function. Valid values are 0 (the default) and 1. ASORT( ) uses the current collate sequence (see SET COLLATE Command) to determine the sort order. Certain collate sequences (such as "GENERAL") are not case-sensitive, and specifying nFlags = 0 will not cause a case-sensitive sorting.
      The nFlags parameter is only useful when the current collate sequence is case-sensitive (such as "MACHINE"), and you wish to do a non-case-sensitive sort.
      The number you specify in nFlags provides a bit-value that determines the case sensitivity of a sort according to the following table:
      nFlag
      000
      Case-sensitive sort
      001
      Case insensitive sort
      If you specify nFlags, you can omit the other parameters by passing them in as -1.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      All elements included in the sort must be of the same data type. One-dimensional arrays are sorted by their elements; two-dimensional arrays are sorted by their rows. When a two-dimensional array is sorted, the order of the rows in the array is changed so that the elements in a column of the array are in ascending or descending order.
      If the sort is successful, 1 is returned; otherwise –1 is returned.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE Customer  &amp;&amp; Open customer table
        COUNT TO gnCount  &amp;&amp; Number of contacts
        DIMENSION gaContact(gnCount,1)  &amp;&amp; Create a contact array
        COPY TO ARRAY gaContact FIELD contact     &amp;&amp; Fill the array
        CLEAR
        ? 'Contact names:'
        ?
        FOR nCount = 1 TO 20
        ? gaContact(nCount)  &amp;&amp; Display first 20 contacts
        ENDFOR
        = ASORT(gaContact)     &amp;&amp; Sort the array
        ?
        ? 'Sorted Contact names:'
        ?
        FOR nCount = 1 TO 20
        ? gaContact(nCount)  &amp;&amp; Display first 20 contacts, sorted
        ENDFOR
      </code>
    </example>
  </asort>
  <atan>
    <summary>
      Returns in radians the arc tangent of a numeric expression.
    </summary>
    <param name="nExpression">

      Specifies a numeric expression whose arc tangent ATAN( ) returns. nExpression can be any value. The value returned by ATAN( ) can range from –pi/2 through +pi/2 (–1.57079 to 1.57079). The number of decimal places displayed in the value returned by ATAN( ) is determined by SET DECIMALS.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      Use RTOD( ) to convert radians to degrees.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? ATAN(0)  &amp;&amp; Displays 0.00
        STORE PI( )/2 to gnAngle
        ? ATAN(gnAngle)  &amp;&amp; Displays 1.00
        ? ATAN(PI( )/2)  &amp;&amp; Displays 1.00
        ? ATAN(DTOR(90))  &amp;&amp; Displays 1.00
      </code>
    </example>
  </atan>
  <atcline>
    <summary>
      Returns the line number of the first occurrence of a character expression or memo field within another character expression or memo field, without regard for the case (upper or lower) of the characters in either expression.
    </summary>
    <param name="cSearchExpression">

      Specifies the character expression that ATCLINE( ) searches for in cExpressionSearched.

    </param>
    <param name="cExpressionSearched">

      Specifies the character expression cSearchExpression searches for.
      Both cSearchExpression and cExpressionSearched can be memo fields of any size. Use MLINE( ) to return the line containing the matching character expression.
      ATCLINE() offers a convenient way to search memo fields.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      If the search is successful, ATCLINE( ) returns the number of the line containing the first character expression. If the search is unsuccessful, ATCLINE( ) returns 0.
      The line number that ATCLINE( ) returns is determined by the value of SET MEMOWIDTH, even if cExpressionSearched isn't a memo field. For more information, see SET MEMOWIDTH.
      Use ATLINE( ) to perform a case-sensitive search.
    </remarks>
    <example>
       <code language="X#">
        * Example 1
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE employee  &amp;&amp; Open employee table
        CLEAR
        STORE 'JAPANESE' TO gcFindString  &amp;&amp; Case insensitive
        LOCATE FOR ATCLINE(gcFindString, notes) != 0
        ? First_Name
        ?? Last_Name
        ? MLINE(notes, ATCLINE(gcFindString, notes))
        * Example 2
        STORE '1234567890ABCDEFGHIJ' TO gcString
        SET MEMOWIDTH TO 20
        ? ATCLINE('AB', gcString)  &amp;&amp; Displays 1
        SET MEMOWIDTH TO 10
        ? ATCLINE('AB', gcString)  &amp;&amp; Displays 2
      </code>
    </example>
  </atcline>
  <atline>
    <summary>
      Returns the line number of the first occurrence of a character expression or memo field within another character expression or memo field, counting from the first line.
    </summary>
    <param name="cSearchExpression">

      Specifies the character expression that X# looks for in cExpressionSearched.

    </param>
    <param name="cExpressionSearched">

      Specifies the character expression that cSearchExpression searches for.
      Both cSearchExpression and cExpressionSearched can be memo fields of any size.
      Use MLINE( ) to return the line containing the matching character expression as a character string.
      ATLINE() offers a convenient way to search memo fields.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      ATLINE( ) searches the second character expression for the occurrence of the first character expression. ATLINE( ) performs a case-sensitive search. Use ATCLINE( ) to perform a search that isn't case-sensitive.
      If the search is successful, ATLINE( ) returns the number of the line where the match occurs. If the search is unsuccessful, ATLINE( ) returns 0.
      The line number that ATLINE( ) returns is determined by the value of SET MEMOWIDTH, even if cExpressionSearched isn't a memo field. For more information, see SET MEMOWIDTH Command.
    </remarks>
    <example>
       <code language="X#">
        * Example 1
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE employee  &amp;&amp; Open employee table
        CLEAR
        STORE 'Japanese' TO gcFindString  &amp;&amp; Case sensitive
        LOCATE FOR ATLINE(gcFindString, notes) != 0
        ? First_Name
        ?? Last_Name
        ? MLINE(notes, ATLINE(gcFindString, notes))
        * Example 2
        STORE '1234567890ABCDEFGHIJ' TO gcString
        SET MEMOWIDTH TO 20
        ? ATLINE('AB', gcString)  &amp;&amp; Displays 1
        SET MEMOWIDTH TO 10
        ? ATLINE('AB', gcString)  &amp;&amp; Displays 2
      </code>
    </example>
  </atline>
  <atn2>
    <summary>
      Returns the arc tangent in all four quadrants from specified values.
    </summary>
    <param name="nYCoordinate">

      Specifies the y coordinate.

    </param>
    <param name="nXCoordinate">

      Specifies the x coordinate.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      ATN2( ) returns the angle (in radians) between the line y = 0 and the line connecting the specified coordinates and the origin (0, 0) of the coordinate system.
      ATN2( ) returns a value between – pi/2 and +pi/2.
      You can convert the value returned by ATN2( ) to degrees with RTOD( ). You can specify the number of decimal places that are displayed in the result with SET DECIMALS.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? PI( )  &amp;&amp; Displays 3.14
        ? ATN2(0,-1)  &amp;&amp; Displays 3.14
        STORE COS(PI( )) TO gnXCoord
        STORE SIN(PI( )) TO gnYCoord
        ? ATN2(gnYCoord,gnXCoord)  &amp;&amp; Displays 3.14
        ? ATN2(gnYCoord,gnXCoord)/PI( )  &amp;&amp; Displays 1.00
      </code>
    </example>
  </atn2>
  <avcxclasses>
    <summary>
      Places the information about classes in a class library into an array.
    </summary>
    <param name="ArrayName">

      Specifies the name of the array in which the class information is placed. If the array you specify doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain the class names and base classes, X# automatically increases the size of the array. If the array is larger than necessary, X# truncates the array.
      The array contains a row for each class in the class library, and each row contains 11 columns containing information about the class. The following table lists the class information in each column.
      Class name.
      OBJNAME
      2
      Base class of the class.
      BASECLASS
      3
      Parent class name of the class.
      4
      Relative path and file name of the parent class library.
      CLASSLOC
      5
      Relative path and file name of the bitmap for a custom class icon.
      RESERVED4
      6
      Relative path and file name for a custom Project Manager or Class Browser class icon.
      RESERVED5
      7
      ScaleMode of the class, Pixels or Foxels.
      RESERVED6
      8
      Description of the class.
      RESERVED7
      9
      Relative path and file name for the #INCLUDE file for the class.
      RESERVED8
      10
      User-defined information for the class.
      USER
      Logical true (.T.) if the class is OLEPUBLIC, otherwise logical false (.F.).
      RESERVED2

    </param>
    <param name="cLibraryName">

      Specifies the name of the class library for which AVCXCLASSES( ) places class information into the array specified with ArrayName. cLibraryName can contain a path to the class library. An error is generated if the class library you specify doesn't exist.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      AVCXCLASSES( ) returns the number of rows in the array (the number of classes in the class library).
    </remarks>
    <example>
       <code language="X#">
        ACTIVATE SCREEN
        CLEAR
        ? AVCXCLASSES(aClasses, '\VFP\SAMPLES\CLASSES\BUTTONS.VCX')
        *** Displays 5
        FOR nColCount = 1 TO ALEN(aClasses,2) &amp;&amp; Loop through columns
        ? aClasses(1, nColCount) &amp;&amp; Each column of the 1st class
        NEXT
        *** Displays the following:
        *
        * cmdCancel
        * commandbutton
        * cmdok
        * buttons.vcx
        * cancel.bmp
        * cancel.bmp
        * Pixels
        * Release Form or Form Set
        *
        *
        * .F.
      </code>
    </example>
  </avcxclasses>
  <bar>
    <summary>
      Returns the number of the most recently chosen item from a menu defined with DEFINE POPUP or a menu item chosen from a X# menu.
    </summary>
    <returns>
      BAR( )Return Value
      Numeric
    </returns>
    <remarks>
      Each item on a menu is assigned a number with DEFINE BAR. When a menu item is chosen from the menu, BAR( ) returns the number assigned to that item. A program can branch to other routines based on the value that BAR( ) returns.
      BAR( ) returns 0 if there is no active menu or if the user presses ESC to exit the menu.
    </remarks>
    <example>
       <code language="X#">
        *** Name this program BAR_EXAM.PRG ***
        CLEAR
        SET SYSMENU SAVE
        SET SYSMENU TO
        DEFINE PAD padConv OF _MSYSMENU ;
        PROMPT '\&lt;Conversions' COLOR SCHEME 3 ;
        KEY ALT+C, ''
        DEFINE PAD padCard OF _MSYSMENU ;
        PROMPT 'Card \&lt;Info' COLOR SCHEME 3 ;
        KEY ALT+I, ''
        ON PAD padConv OF _MSYSMENU ACTIVATE POPUP popConv
        ON PAD padCard OF _MSYSMENU ACTIVATE POPUP popCard
        DEFINE POPUP popConv MARGIN RELATIVE COLOR SCHEME 4
        DEFINE BAR 1 OF popConv PROMPT 'Ar\&lt;ea' KEY CTRL+E, '^E'
        DEFINE BAR 2 OF popConv PROMPT '\&lt;Length' ;
        KEY CTRL+L, '^L'
        DEFINE BAR 3 OF popConv PROMPT 'Ma\&lt;ss' ;
        KEY CTRL+S, '^S'
        DEFINE BAR 4 OF popConv PROMPT 'Spee\&lt;d' ;
        KEY CTRL+D, '^D'
        DEFINE BAR 5 OF popConv PROMPT '\&lt;Temperature' ;
        KEY CTRL+T, '^T'
        DEFINE BAR 6 OF popConv PROMPT 'T\&lt;ime' ;
        KEY CTRL+I, '^I'
        DEFINE BAR 7 OF popConv PROMPT 'Volu\&lt;me' ;
        KEY CTRL+M, '^M'
        *** Here is where the POPCONV menu uses the BAR( ) function
        *** to pass a bar number to the procedure called choice below.
        ON SELECTION POPUP popConv;
        DO choice IN bar_exam WITH BAR( ), POPUP( )
        DEFINE POPUP popCard MARGIN RELATIVE COLOR SCHEME 4
        DEFINE BAR 1 OF popCard PROMPT '\&lt;View Charges' ;
        KEY ALT+V, ''
        DEFINE BAR 2 OF popCard PROMPT 'View \&lt;Payments' ;
        KEY ALT+P, ''
        DEFINE BAR 3 OF popCard PROMPT 'Vie\&lt;w Users' ;
        KEY ALT+W, ''
        DEFINE BAR 4 OF popCard PROMPT '\-'
        DEFINE BAR 5 OF popCard PROMPT '\&lt;Charges ';
        KEY ALT+C
        DEFINE BAR 6 OF popCard PROMPT '\-'
        DEFINE BAR 7 OF popCard PROMPT 'E\&lt;xit ';
        KEY ALT+X
        *** Here is where the POPCARD menu uses the BAR( ) function
        *** to pass a bar number to the procedure called choice below.
        ON SELECTION POPUP popCard;
        DO choice IN bar_exam WITH BAR( ), POPUP( )
        *** The procedure choice uses the gnBar parameter
        *** to contain the value passed by the BAR( ) function.
        PROCEDURE choice
        PARAMETERS gnBar, gcPopup
        WAIT WINDOW 'You chose bar #' + LTRIM(STR(gnBar)) + ;
        ' from popup ' + gcPopup NOWAIT
        SET SYSMENU TO DEFAULT
      </code>
    </example>
  </bar>
  <barcount>
    <summary>
      Included for compatibility with dBASE.
       
    </summary>
  </barcount>
  <barprompt>
    <summary>
      Included for compatibility with dBASE.
       
    </summary>
  </barprompt>
  <between>
    <summary>
      Determines whether the value of an expression is inclusively between the values of two expressions of the same type.
    </summary>
    <param name="eTestValue">

      Specifies an expression to evaluate.

    </param>
    <param name="eLowValue">

      Specifies the lower value in the range.

    </param>
    <param name="eHighValue">

      Specifies the upper value in the range.
    </param>
    <returns>
      Logical or null. <b>BETWEEN( )</b> returns True (.T.) if the value of the specified expression is equal to one of the values or greater than the lower value and less than the higher value of the two expressions. Otherwise, <b>BETWEEN( )</b> returns False (.F.). <b>BETWEEN( )</b> returns a null value if eLowValue or eHighValue is a null value.
    </returns>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE orders  &amp;&amp; Open order table
        CLEAR
        SCAN FOR BETWEEN(order_amt,950,1000)
        ? cust_id, order_amt
        ENDSCAN
      </code>
    </example>
  </between>
  <bindevent>
    <summary>
      Provides ability to execute user code (an object method) when an event occurs.
      With the first form of the syntax below, you can use <b>BINDEVENT( )</b> to bind events, properties, or methods from native X# objects to other X# objects.
      With the second syntax variation below, you can bind to Windows Message (Win Msg) events.
      If you want to bind to events from Component Object Model (COM) objects, use the <b>EVENTHANDLER( )</b> function.
    </summary>
    <param name="oEventSource">

      Specifies the event source, which must be a valid X# object.

    </param>
    <param name="hWnd">

      Specifies the integer handle of the window that receives Windows Messages.
      If a value of 0 is passed, the specified event (nMessage) is trapped for all windows.
      You can use the hWnd Property (X#) to bind Windows Messages (events) received by _VFP, _SCREEN and instantiated form. ActiveX controls also have an hWnd property

    </param>
    <param name="cEvent">

      Specifies the name of the event, method, or property you want to bind.

    </param>
    <param name="nMessage">

      Specifies a valid Windows message that is trapped. See MSDN (the Microsoft Developer Network) for information about Windows messages.

    </param>
    <param name="oEventHandler">

      Specifies the object, which must be a valid X# object, handling the event.

    </param>
    <param name="cDelegate">

      Specifies the method, or "delegate", that handles the event for oEventHandler.
      The delegate method must have the same parameters as the event specified in cEvent. You can call the <b>AEVENTS( ) </b>function to retrieve an object reference to the event source. If the delegate method does not have enough parameters to handle those passed by the event, X# generates an error.
      When trapping for Windows Message (Win Msg) events, the cDelegate method must include a PARAMETERS statement to accept four parameters that get passed to the method. The format of the parameters is identical to the format of the Windows WindowProc function. See MSDN (the Microsoft Developer Network) for information about the Windows WindowProc function. The method must return an integer value.

    </param>
    <param name="nFlags">

      Specifies an additive bit flag you can set for the event binding operation.
      The nFlags parameter is ignored when a Windows message event binding is created.
      0
      000
      FoxPro object
      Call delegate code before event code. (Default)
      1
      001
      Call event code before delegate code.
      2
      010
      Do not trigger event (call delegate code) by simple method call.
      3
      011
      Call event code before delegate code. Do not trigger event (call delegate code) when simple method calls occur.
      4
      100
      Windows Message
      Prevents recursion of similar events while user event code is executing.
      The following table shows whether an event is raised when Bit 1 is off or on.
      Interactive
      YES
      Programmatic
      NO
      <b>RAISEEVENT( )</b>

    </param>
    <returns>
      Numeric data type. <b>BINDEVENT( )</b> returns the number of bindings for the object's event.
      BINDEVENT( ) always returns 1 when a Windows message event binding is created. No error detection is performed, so if invalid hWnd and nMessage values are specified, 1 is still returned and the binding remains in effect until it is released.
    </returns>
    <remarks>
      You can bind to any valid X# object event, property, or method, including the <b>Access</b> and <b>Assign</b> methods. However, the event and delegate methods must be public, not protected or hidden, members of the class.
      You cannot bind to an event with parameters that are passed by reference. Though calling <b>BINDEVENT( )</b> succeeds, raising the event, for example, using <b>RAISEEVENT( )</b>, fails.
      When you bind to a property, you should bind to it directly and not to the <b>Assign</b> method. If you bind directly to the <b>Assign</b> method, be aware that <b>Access</b> and <b>Assign</b> methods are marked as <b>Protected</b> and are not visible except within the class.
      If you bind to a property that has an <b>Assign</b> method, the delegate method might trigger twice. The first time is when the property assignment call is made. The second time is when the property is actually set, within the <b>Assign</b> method, to the parameter that is passed. The delegate method should be aware of this possibility.
      Normal rules of inheritance apply. If the delegate method does not contain any code, X# traverses up the parent hierarchy.
      An event handler is called when an event occurs or if it is called as a method. Calling the event as a method triggers the event unless you specify an nFlags value of 2 or 3.
      By default, X# calls the delegate method before the event. However, you can change the default behavior by using an nFlags setting.
      If you specify a property as the event you want to bind, X# binds that property to an implicit <b>Assign</b> method. When the value of that property changes, X# triggers an event.
      If an invalid parameter is passed, X# generates the error, "Function argument value, type, or count is invalid." However, if a problem occurs during the binding operation, X# does not generate an error. You can retrieve the return value of <b>BINDEVENT( )</b> to check the number of bindings.
      Certain control events such as <b>GotFocus</b>, <b>LostFocus</b>, <b>InteractiveChange</b>, and <b>ProgrammaticChange</b> do not work if the second bit of the nFlags parameter is set, for example, nFlags set to 2. These events are treated as method calls internally by X#, even though they are considered events. The same behavior applies to the <b>Refresh</b> method of an object on a form that is called when the form's <b>Refresh</b> method is called. Certain events such as <b>When</b> and <b>Valid</b> require code in the event for it to occur.

      <b>BINDEVENT( )</b> does not directly support the <b>Value</b> property because it is handled by X# in a special way. You should use the <b>InteractiveChange </b><b>ProgrammaticChange</b> events instead. Additionally, the <b>ActivePage</b> property is not supported.
      If the original event contains a <b>NODEFAULT</b> command, X# still processes the event because it is possible that the delegate method is called before the event. <b>NODEFAULT</b> applies only to native X# events.
      If you make an exact duplicate <b>BINDEVENT( )</b> call, X# disregards the call but still returns the number of bindings for the object's event. If you change the nFlags setting, you can call <b>BINDEVENT( )</b> to rebind the event.
      When binding to Windows message (Win Msg) events, only one hWnd to Windows message pairing can exist. You can pass an hWnd value of 0 if you want to bind all windows to the same Windows message event. A Windows message event binding can be released with the UNBINDEVENTS( ) Function and the CLEAR Commands. Also, if the event handler object specified with the oEventHandler parameter no longer exists, the binding is released when its Windows message occurs.
      With a Windows message event binding, your user code will execute whenever an event occurs including scenarios in which a modal dialog is displayed. This is because the Window Procedure must always process the message and return. Since it is possible for recursion to occur with an event while your user code is executing, you may want to specify an nFlags value of 4 to prevent this from happening.
      A Windows message event binding should be used with care since your user code is bound to events being triggered by the Windows operating system and these events can occur at times when you do not expect them to.
    </remarks>
    <example>
       <code language="X#">
        PUBLIC oHandler
        oHandler=NEWOBJECT("myhandler")
        DO (_browser)
        BINDEVENT(_SCREEN,"Resize",oHandler,"myresize")
        DEFINE CLASS myhandler AS Session
        PROCEDURE myresize
        IF ISNULL(_obrowser) THEN
        UNBINDEVENTS(THIS)
        ELSE
        _obrowser.left = _SCREEN.Width - _obrowser.width
        ENDIF
        RETURN
        ENDDEFINE
      </code>
    </example>
  </bindevent>
  <bof>
    <summary>
      Determines whether the record pointer is positioned at the beginning of a table.
    </summary>
    <param name="nWorkArea">

      Specifies the work area number for a table open in another work area.

    </param>
    <param name="cTableAlias">

      Specifies the table alias for a table open in another work area.
      If the table you want to test for a beginning-of-file condition is open in a work area other than the currently selected work area, use these optional arguments to specify the work area number or table alias for the table. If a table isn't open in the work area you specify, <b>BOF( )</b> returns false (.F.).
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      Use <b>BOF( )</b> to test for a beginning-of-file condition for a table. <b>BOF( )</b> returns true (.T.) if you have tried to move the record pointer to a position before the first record in the table.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        CLEAR
        OPEN DATABASE (HOME() + "samples\data\testdata")
        USE customer
        GO BOTTOM
        local recCtr, btnValue
        recCtr = 0
        btnValue = 1
        DO WHILE btnValue = 1 AND NOT BOF()
        ? "Company : " + company
        recCtr = recCtr + 1
        if (recCtr % 20) = 0 then
        btnValue =MESSAGEBOX ("Click OK to continue, Cancel to quit.",33)
        clear
        endif
        Skip -1    &amp;&amp; Move up one record
        ENDDO
        =MESSAGEBOX("Listing complete.",48)
      </code>
    </example>
  </bof>
  <cast>
    <summary>
      Converts an expression from one data type to another.
    </summary>
    <param name="eExpression">

      Specifies a data expression, usually in a SQL statement, that you want to convert to another data type. eExpression can be a field, calculated field, or other type of expression.

    </param>
    <param name="cDataType">

      Specifies the valid name of or letter representing the target data type name. cDataType can also be an expression that evaluates to a valid data type name or letter representing a valid data type.
      If you specify an expression for cDataType, you must enclose the expression you specify for cDataType with parentheses.
      Some field data types require that you specify a value for nFieldWidth, nPrecision, or both. The following table lists values for cDataType and whether nFieldWidth and nPrecision apply.
      W, Blob
      No
      C, Char, Character
      Yes
      Y, Currency
      D, Date
      T, DateTime
      B, Double
      F, Float
      Floating
      G, General
      I, Int, Integer
      L, Logical
      M, Memo
      N, Num, Numeric
      Q, Varbinary
      V, Varchar

    </param>
    <param name="nFieldWidth">

      Specifies the field width for certain data types. X# disregards nFieldWidth for the following data types: D, T, I, Y, L, M, G, and W. If nFieldWidth is not specified, default values are used, for example, as defined by the <b>CREATE TABLE</b> command.

    </param>
    <param name="nPrecision">

      Specifies the number of decimal place precision for certain data types. X# disregards nPrecision for the following data types: C, D, T, I, Y, L, M, G, V, Q, and W.
      If nPrecision is not included for the <b>Numeric</b> or <b>Float</b> data type, the default is zero (0), which is no decimal places. If nPrecision is not included for the Double data type, nPrecision defaults to the number of decimal place precision set by the <b>SET DECIMALS</b> command. If nPrecision is not specified for any other data type, default values are used, for example, as defined by the <b>CREATE TABLE</b> command.
      NULL | NOT NULL
      Specifies whether to permit null values in the field.
      If one or more fields can contain null values, the maximum number of fields the table can contain is reduced from 255 to 254.
      If <b>NULL</b> or <b>NOT NULL</b> is not specified, it is inherited from the expression.
    </param>
    <remarks>
      The following table shows conversions supported by the <b>CAST( )</b> function. The vertical axis lists the source data type, and the horizontal axis lists the target data type. The following letters describe the level of conversion supported:
      F - Full conversion without loss of data
      P - Partial conversion with possible loss of data
      N - Not supported

      <b>C</b>

      F
      P
      P
      P
      P
      P
      P
      P
      P
      F
      N
      F
      F
      F

      <b>D</b>

      F
      F
      F
      N
      N
      N
      N
      N
      N
      F
      N
      F
      N
      N

      <b>T</b>

      F
      P
      F
      N
      N
      N
      N
      N
      N
      F
      N
      F
      N
      N

      <b>N</b>

      F
      N
      N
      F
      F
      P
      F
      P
      P
      F
      N
      F
      N
      N

      <b>F</b>

      F
      N
      N
      F
      F
      P
      F
      P
      P
      F
      N
      F
      N
      N

      <b>I</b>

      F
      N
      N
      F
      F
      F
      F
      F
      P
      F
      N
      F
      N
      N

      <b>B</b>

      P
      N
      N
      P
      P
      P
      F
      P
      P
      F
      N
      P
      N
      N

      <b>Y</b>

      F
      N
      N
      P
      P
      P
      F
      F
      P
      F
      N
      F
      N
      N

      <b>L</b>

      F
      N
      N
      F
      F
      F
      F
      F
      F
      F
      N
      F
      N
      N

      <b>M</b>

      P
      P
      P
      P
      P
      P
      P
      P
      P
      F
      N
      P
      P
      F

      <b>G</b>

      N
      N
      N
      N
      N
      N
      N
      N
      N
      N
      F
      N
      N
      F

      <b>V</b>

      P
      P
      P
      P
      P
      P
      P
      P
      P
      F
      N
      F
      P
      P

      <b>Q</b>

      P
      N
      N
      N
      N
      N
      N
      N
      N
      F
      N
      P
      F
      F

      <b>W</b>

      P
      N
      N
      N
      N
      N
      N
      N
      N
      F
      F
      P
      P
      F
      If you specify decimal precision, conversions between numeric data types, for example, <b>Numeric</b>, <b>Float</b>, <b>Currency</b>, and <b>Double</b>, to <b>Integer</b> data type might result in loss of precision.
      For conversions to <b>Character</b>, <b>Varchar</b>, and <b>Varbinary</b> data types, if the specified field width is less than that of the original data, X# truncates values to fit the field width. For conversions to <b>Character</b> data type, if the specified width is greater than that of the original data, X# pads the field with spaces to the right of the value.
    </remarks>
    <example>
       <code language="X#">
        CLEAR ALL
        OPEN DATABASE HOME(2) + 'Data\Testdata.dbc'
        SELECT Product_ID, CAST(unit_Cost * in_Stock AS Numeric(8,2)) FROM Products
      </code>
    </example>
  </cast>
  <cdow>
    <summary>
      Returns the day of the week from a given Date or DateTime expression.
    </summary>
    <param name="dExpression">

      Specifies the date from which CDOW( ) returns the day.

    </param>
    <param name="tExpression">

      Specifies the datetime from which CDOW( ) returns the day.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      CDOW( ) returns the name of the day of the week as a string in proper noun format.
    </remarks>
    <example>
       <code language="X#">
        STORE {^1998-02-16} TO gdDate
        CLEAR
        ? CDOW(gdDate)  &amp;&amp; Displays Monday
      </code>
    </example>
  </cdow>
  <chr>
    <summary>
      Returns the character associated with the specified numeric ANSI code.
    </summary>
    <param name="nANSICode">

      Specifies a number between 0 and 255 whose equivalent ANSI character <b>CHR( )</b> returns.
      Use <b>ASC( )</b> to return the ANSI value for a specified character.
    </param>
    <returns>
      Character
    </returns>
    <remarks>

      <b>CHR( )</b> returns a single character corresponding to the numeric position of the character in the character table of the current code page. <b>CHR( )</b> can be used to send printer control codes to a printer.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        FOR nCOUNT = 65 TO 75
        ? nCount &amp;&amp; Display numeric value
        ?? ' ' + CHR(nCount) &amp;&amp; Display character
        ENDFOR
      </code>
    </example>
  </chr>
  <chrsaw>
    <summary>
      Determines whether or not a character is present in the keyboard buffer.
    </summary>
    <param name="nSeconds">

      Specifies the time in seconds that <b>CHRSAW( )</b> waits before checking the keyboard buffer. The keyboard buffer is checked immediately if you omit nSeconds.
      Including nSeconds lets you use <b>CHRSAW( )</b> for a variety of timed activities. For example, your program can close an application if a key hasn't been pressed for a specific number of seconds.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>

      <b>CHRSAW( )</b> returns True (.T.) if a character is present in the keyboard buffer, and False (.F.) if not. <b>CHRSAW( )</b> doesn't affect the keyboard buffer contents.
    </remarks>
    <example>
       <code language="X#">
        SET TALK OFF
        DEFINE WINDOW wEnter FROM 7,10 to 13,70 PANEL
        ACTIVATE WINDOW wEnter
        @ 1,3 SAY 'Customer: '   GET gcCustomer  DEFAULT SPACE(40)
        @ 3,3 SAY 'Address:  '   GET gcAddress  DEFAULT SPACE(40)
        WAIT WINDOW 'Waiting for input' NOWAIT
        IF NOT CHRSAW(5)
        DEACTIVATE WINDOW wEnter
        CLEAR GETS
        ELSE
        READ
        DEACTIVATE WINDOW wEnter
        ENDIF
        RELEASE WINDOW wEnter
        WAIT
        CLEAR
      </code>
    </example>
  </chrsaw>
  <clearresultset>
    <summary>
      Clears the marker from a cursor marked by <b>SETRESULTSET( )</b> in the current data session.
    </summary>
    <returns>
      CLEARRESULTSET( )Return Value
      Numeric. <b>CLEARRESULTSET( ) </b>returns the number of the work area for the previously marked cursor or zero (0) if no cursor is marked in the current data session.
    </returns>
    <remarks>

      <b>CLEARRESULTSET( ) </b>is supported in X# and the X# OLE DB Provider. You can use <b>GETRESULTSET( )</b> in a database container (DBC) stored procedure or send it to the X# OLE DB Provider, assuming that the cursor has been previously opened by the OLE DB Provider.
    </remarks>
  </clearresultset>
  <cmonth>
    <summary>
      Returns the name of the month from a given date or DateTime expression.
    </summary>
    <param name="dExpression">

      Specifies the date expression from which <b>CMONTH( )</b> returns the name of the month.

    </param>
    <param name="tExpression">

      Specifies the DateTime expression from which <b>CMONTH( )</b> returns the name of the month.
    </param>
    <returns>
      Character
    </returns>
    <remarks>

      <b>CMONTH( )</b> returns the name of the month as a string in proper noun format based on the current resource file you are using and not on the Windows locale. For more information, see Managing Files in an International Application.
    </remarks>
    <example>
       <code language="X#">
        ? <b>CMONTH(</b>DATE( )<b>)</b>
        STORE {^1998-02-16} TO gdDueDate
        ? 'Your payment was due in ', <b>CMONTH(</b>gdDueDate<b>)</b>
        STORE gdDueDate+60 TO gdFinalDate
        ? 'You must pay by ', <b>CMONTH(</b>gdFinalDate<b>)</b>
      </code>
    </example>
  </cmonth>
  <cntbar>
    <summary>
      Returns the number of menu items on a user-defined menu or the X# system menu.
    </summary>
    <param name="cMenuName">

      Specifies the name of the menu for which <b>CNTBAR( )</b> returns the number of menu items. For a list of the X# system menu names, see the System Menu Names topic.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      If a user-defined menu is created with the PROMPT option in <b>DEFINE POPUP</b>, X# evaluates the number of menu items when you issue <b>ACTIVATE POPUP</b>. For such a menu, <b>CNTBAR( )</b> returns a meaningful value only after you activate the menu. However, if the menu items in the menu are created with <b>DEFINE BAR</b>, <b>CNTBAR( )</b> can determine the number of menu items before you issue <b>ACTIVATE POPUP</b>.
    </remarks>
    <example>
       <code language="X#">
        *** You must name this program CNTBAR.PRG ***
        CLEAR
        SET TALK OFF
        DEFINE PAD padEnv OF _MSYSMENU PROMPT 'E\&lt;nvironment';
        KEY ALT+R, 'ALT+R'
        ON PAD padEnv OF _MSYSMENU ACTIVATE POPUP popEnv
        DEFINE POPUP popEnv MARGIN RELATIVE COLOR SCHEME 4
        DEFINE BAR 1 OF popEnv PROMPT '\&lt;Status Bar'
        DEFINE BAR 2 OF popEnv PROMPT '\&lt;Clock'
        DEFINE BAR 3 OF popEnv PROMPT '\&lt;Extended Video'
        DEFINE BAR 4 OF popEnv PROMPT 'St\&lt;icky'
        ON SELECTION POPUP popEnv DO enviropop IN cntbar.prg
        FOR i = 1 TO CNTBAR('popEnv')
        DO CASE
        CASE PRMBAR('popEnv', i) = 'Status Bar'
        IF _WINDOWS or _MAC
        SET MARK OF BAR i OF popEnv TO SET('STATUS BAR') = 'ON'
        ELSE
        SET MARK OF BAR i OF popEnv TO SET('STATUS') = 'ON'
        ENDIF
        CASE PRMBAR('popEnv', i) = 'Clock'
        SET MARK OF BAR i OF popEnv TO  SET('CLOCK') = 'ON'
        CASE PRMBAR('popEnv', i) = 'Extended Video'
        SET MARK OF BAR i OF popEnv TO  SROW( ) &gt; 25
        CASE PRMBAR('popEnv', i) = 'Sticky'
        SET MARK OF BAR i OF popEnv TO  SET('STICKY') = 'ON'
        ENDCASE
        ENDFOR
        PROCEDURE enviropop
        DO CASE
        CASE PROMPT() = 'Status'
        IF mrkbar('popEnv', BAR( ))
        DO CASE
        CASE _WINDOWS OR _MAC
        SET STATUS BAR OFF
        CASE _DOS
        SET STATUS OFF
        OTHERWISE
        ENDCASE
        SET MARK OF BAR BAR( ) OF popEnv TO .F.
        ELSE
        DO CASE
        CASE _WINDOWS OR _MAC
        SET STATUS BAR ON
        CASE _DOS
        SET STATUS ON
        OTHERWISE
        ENDCASE
        SET MARK OF BAR BAR( ) OF popEnv TO .T.
        ENDIF
        CASE PROMPT( ) = 'Clock'
        IF mrkbar('popEnv', BAR( ))
        SET CLOCK OFF
        SET MARK OF BAR BAR( ) OF popEnv TO .F.
        ELSE
        DO CASE
        CASE _WINDOWS OR _MAC
        SET STATUS BAR ON
        SET CLOCK STATUS
        CASE _DOS
        SET CLOCK ON
        OTHERWISE
        ENDCASE
        SET MARK OF BAR BAR( ) OF popEnv TO .T.
        ENDIF
        CASE PROMPT( ) = 'Extended Video'
        IF MRKBAR('popEnv', BAR( ))
        SET DISPLAY TO VGA25
        SET MARK OF BAR BAR( ) OF popEnv TO .F.
        ELSE
        SET DISPLAY TO VGA50
        SET MARK OF BAR BAR( ) OF popEnv TO .T.
        ENDIF
        CASE PROMPT( ) = 'Sticky'
        IF MRKBAR('popEnv', BAR( ))
        DO CASE
        CASE _WINDOWS OR _MAC
        WAIT WINDOW 'STICKY is always on in this X# version'
        CASE _DOS
        SET STICKY OFF
        OTHERWISE
        ENDCASE
        SET MARK OF BAR BAR( ) OF popEnv TO .F.
        ELSE
        DO CASE
        CASE _WINDOWS OR _MAC
        WAIT WINDOW 'STICKY is always ON in X#'
        CASE _DOS
        SET STICKY ON
        OTHERWISE
        ENDCASE
        SET MARK OF BAR BAR( ) OF popEnv TO .T.
        ENDIF
        ENDCASE
      </code>
    </example>
  </cntbar>
  <cntpad>
    <summary>
      Returns the number of menu titles on a user-defined menu bar or the X# system menu bar.
    </summary>
    <param name="cMenuBarName">

      Specifies the name of the menu bar for which <b>CNTPAD( )</b> returns the number of menu titles.
    </param>
    <returns>
      Numeric
    </returns>
    <example>
       <code language="X#">? CNTPAD('_MSYSMENU')</code>
    </example>
  </cntpad>
  <col>
    <summary>
      Included for backward compatibility. Use the CurrentX, CurrentY Properties.
       
      Returns the current column position of the cursor.
    </summary>
    <returns>
      Return value - Numeric
    </returns>
    <remarks>
      <br />
      COL() is especially useful for directing screen output to a column position relative to the current column position of the cursor.<br />
      <br />
      The special operator $ can be used in place of COL().<br />
      <br />

    </remarks>
    <example>











      <code language="X#">
        @ 5,5 SAY ''
        @ ROW(), COL()+12 SAY 'Contact person'
        @ ROW(), $+12 SAY 'Contact person'
      </code>




    </example>
  </col>
  <comarray>
    <summary>
      Specifies how to pass arrays to COM objects.
    </summary>
    <param name="oObject">

      Specifies an object reference to a COM object.

    </param>
    <param name="nNewValue">

      Specifies how to pass an array to a COM object specified with oObject.
      The following table lists the settings for nNewValue and how the to pass the array to the COM object.
      0
      The array is a zero-based array and is passed by value.
      1
      The array is a one-based array and is passed by value. Compatible with earlier versions of X#. (Default)
      10
      The array is a zero-based array and is passed by reference.
      11
      The array is a one-based array and is passed by reference.
      100
      The array is a fixed size array and cannot be redimensioned.
      1000
      Byte arrays are not converted to strings.
      To return the current setting, call <b>COMARRAY( )</b> without an argument for the nNewValue parameter.
    </param>
    <returns>
      Numeric. <b>COMARRAY( )</b> returns the current setting.
    </returns>
    <remarks>
      Use <b>COMARRAY( )</b> only when you pass arrays to COM objects using the following syntax:

      codeoComObject.Method(@MyArray)/code

      If you omit the at sign (@), only the first element of the array passes to the COM object, and <b>COMARRAY( )</b> has no effect. This behavior is the same as that in earlier versions of X#.
      When you use a byte array (VT_UI1) to communicate with a COM server, X# converts the byte array into a string. The additive nValue of 1000 retains the original proper type of the array and does not convert the result to a string.
      If a client passes a byte array by reference to a X# COM Server, the X# COM Server must also set the nValue additive to 1000. You can do this by putting the following call in the Init event of the X# COM Server:
       <code language="X#">COMARRAY(THIS,1000)</code>
      The additive nValue of 100 makes it possible for you to prevent redimensioning of an array. You should check for possible errors after calling the server in case the server attempts to redimension the array. The following example shows how to prevent redimensioning of the array. To run this example, first build the class definition into a DLL named "t1.dll".
       <code language="X#">
        LOCAL loSvr, laTest
        loSvr = NEWOBJECT("t1.arrayhandler")
        DIMENSION laTest[10]
        laTest=3
        ? COMARRAY(loSvr,11 + 100)
        * The COM server will return an error on the next line of code
        * because arrays passed to loSvr will not allow re-dimensioning.
        loSvr.RedimensionArray(@laTest,4)
        ? ALEN(laTest)
        DEFINE CLASS ARRAYHANDLER AS CUSTOM OLEPUBLIC
        PROCEDURE RedimensionArray(aArray, nRows)
        DIME aArray[nRows]
        ENDPROC
        ENDDEFINE
      </code>
    </remarks>
  </comarray>
  <comclassinfo>
    <summary>
      Returns registry information about a COM object such as a X# automation server.
    </summary>
    <param name="oObject">

      An object reference to a COM or OLE object.

    </param>
    <param name="nInfoType">

      Specifies the type of information to return. The following table lists the values for nInfoType and the information returned.
      1 (Default)
      The object's programmatic identifier (ProgID).A ProgID is a registry entry that can be associated with a CLSID.
      2
      The object's VersionIndependentProgID.The VersionIndependentProgID associates a ProgID with a CLSID. It is used to determine the latest version of an object application, refers to the application's class, and does not change from version to version.
      3
      The object's friendly name.
      4
      The object's class identifier (CLSID). A CLSID is a globally unique identifier that identifies a COM class object.
      5
      Type of object passed:    <b>Return value      Description</b>          1               X# object          2               ActiveX Control          3               COM Component          4               OLEBound object (General field)
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      COMCLASSINFO( ) returns the empty string if registry information isn't available for the object you specify. X# automation servers are COM objects, both .exe executable files and .dll dynamic link libraries you can create in the Project Manager.
      If you create an instance of an ActiveX control by using CREATEOBJECT( ) as in the following code, nInfoType returns 3 (COM Component) rather than 2.
       <code language="X#">X=CREATEOBJECT("MSComctlLib.treectrl.2")</code>
      To return 2 (ActiveX control) you must use the object as such, as in the following code:
       <code language="X#">ox.addobject("oc","olecontrol","MSComctlLib.treectrl.2")</code>
    </remarks>
  </comclassinfo>
  <comprop>
    <summary>
      Sets or returns the behavior setting of a COM object property.
    </summary>
    <param name="oComObject">

      Specifies a reference to a COM object. cProperty is not case sensitive.
      You must use the complete name of the COM object. If you do not provide eValue, COMPROP( ) returns the value of cProperty.

    </param>
    <param name="cProperty">

      Specifies the name of the COM property to set. The following table lists possible values of cProperty.
      UTF8
      Determines whether UNICODE strings returned from a COM object are converted to ANSI. Conversion is performed by default.
      PUTREF
      Determines if initial object assignment is PROPERTY_PUT (default) or PUTREF.

    </param>
    <param name="eValue">

      Specifies a value representing behavior to apply to the cProperty. The following table lists values for eValue.
      0
      Apply default behavior.
      1
      Apply nondefault behavior as described in the table for cProperty.
      For example, setting an eValue of 1 for UTF8 prevents the display of multi-byte characters as question marks. Setting an eValue of 1 for PUTREF causes X# to attempt object assignment as a PUTREF first and, only if that fails, attempt assignment as a PROPERTY_PUT. Object assignments to properties of some ActiveX controls or COM objects requires PUTREF, and X# defaults to PROPERTY_PUT.
    </param>
    <returns>
      COMPROP( ) returns the value of cProperty.
      The following example returns data from methods of an ADO recordset as UNICODE instead of allowing conversion to ANSI:
       <code language="X#">
        LOCAL oConn AS adodb.Connection, oRS AS adodb.Recordset
        LOCAL lcStr AS STRING
        oConn=CREATEOBJECT("ADODB.Connection")
        oConn.Open("DSN=Nwind;")  &amp;&amp; DSN to SQL Server
        oRS=oConn.Execute("select * from customers")
        COMPROP(oRS,'UTF8',1)
        DO WHILE NOT oRS.Eof
        lcStr = oRS.Fields(4).Value
        oRS.MoveNext
        ENDDO
        oRS.Close()
        oRS.ActiveConnection=NULL
        oRS=NULL
        oConn.Close()
        oConn=NULL
      </code>
      In the following example, an ActiveX control is made to use PUTREF rather than PROPERTY_PUT:
       <code language="X#">=COMPROP(oForm.OLECONTROL1, 'PUTREF',1)</code>
    </returns>
  </comprop>
  <comreturnerror>
    <summary>
      Populates the COM exception structure with information that Automation clients can use to determine the source of Automation errors.
    </summary>
    <param name="cExceptionSource">

      Specifies the text for the source of the exception.

    </param>
    <param name="cExceptionText">

      Specifies the text for the description of the exception.
    </param>
    <remarks>
      COMRETURNERROR( ) allows X# Automation servers to populate the COM exception structure so that Automation clients can determine the cause of an error on the Automation server.
      Executing COMRETURNERROR( ) places the specified text in the COM exception structure, aborts executing the current method, and returns control to the client. The Automation server remains in memory and the client can call more Automation server methods.
      X# clients can use AERROR( ) to view the text placed on the COM exception structure.
      (For advanced users) COMReturnErrorInfo fills in a COM exception information structure. This is used only for IDispatch (late binding calls). If you call the server via early binding and the client passes a COM exception structure to the server, there is no error mechanism to return the error info unless the client does a QueryInterface on the ISupportsErrorInfo interface.
    </remarks>
  </comreturnerror>
  <cos>
    <summary>
      Returns the cosine of a numeric expression.
    </summary>
    <param name="nExpression">

      Specifies a numeric expression whose cosine COS( ) returns. nExpression can be any value.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      COS( ) returns the cosine of nExpression in radians. Use DTOR( ) to convert an angle from degrees to radians. The number of decimal places that COS( ) returns can be specified with SET DECIMALS. The value COS( ) returns ranges between –1 and 1.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? COS(0)  &amp;&amp; Displays 1.00
        ? COS(PI( ))  &amp;&amp; Displays -1.00
        ? COS(DTOR(180))  &amp;&amp; Displays -1.00
        STORE PI( ) * 3 TO gnAngle
        ? COS(gnAngle)  &amp;&amp; Displays -1.00
      </code>
    </example>
  </cos>
  <createbinary>
    <summary>
      Converts character type data created in X# to a binary type character string you can pass to an ActiveX control or automation object.
    </summary>
    <param name="cExpression">

      Specifies the character expression for which a binary type character string is returned.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      X# character strings can contain binary data. However, an ActiveX control or automation object character string (OLE VT_BSTR type data) cannot contain binary data. An ActiveX control or automation object passes binary data to applications such as X# as an array of VT_UI1 type data.
      X# automatically converts binary data passed from an ActiveX control or automation object as an array of VT_UI1 type data to a X# character string. X# internally marks this character string as binary data passed from an ActiveX control or automation object. When the character string is passed back to an ActiveX control or automation object, X# automatically converts the character string to an array of VT_UI1 type data the ActiveX control or automation object expects.
      Use CREATEBINARY( ) to convert character type data created in X# to a binary type character string you can pass to an ActiveX control or automation object. The minimum number of characters to which CREATEBINARY( ) can be abbreviated is 7.
      For more information about ActiveX controls and automation objects, see Sharing Information and Adding OLE.
    </remarks>
  </createbinary>
  <ctod>
    <summary>
      Converts a character expression to a date expression.
    </summary>
    <param name="cExpression">

      Specifies a character expression.
    </param>
    <returns>
      Date data type. CTOD( ) returns a Date value.
    </returns>
    <remarks>
      CTOD() can create ambiguous Date values and generates a compilation error when SET STRICTDATE is set to 2. To create unambiguous Date values, use the DATE( ) function.
    </remarks>
    <example>
       <code language="X#">
        SET CENTURY ON               &amp;&amp; Shows the century value.
        cDate="01/01/2003"
        ?CTOD(cDate)               &amp;&amp; Returns 01/01/2003 as Date.
        ?GOMONTH(CTOD(cDate),12)   &amp;&amp; Returns 01/01/2004.
        ?CTOD(cDate)+100            &amp;&amp; Returns 04/11/2003.
      </code>
    </example>
  </ctod>
  <curdir>
    <summary>
      Returns the current directory.
    </summary>
    <param name="cExpression">

      Specifies the drive or volume for which CURDIR( ) returns the current directory or folder. If you omit cExpression, the current default drive or volume is assumed. The empty string is returned if the drive or volume you specify in cExpression doesn't exist. Note that this argument is only included for earlier versions of X# and FoxPro running under Window 3.1 or MS-DOS.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      CURDIR( ) returns, as a character string, the current MS-DOS directory on a specified drive.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? 'Current directory: ', CURDIR( )
        gcOldDir = SET('DEFAULT') + SYS(2003)
        SET DEFAULT TO (HOME( ))
        ? 'X# directory: ', CURDIR( )
        SET DEFAULT TO (gcOldDir)
        ? 'Current directory: ', CURDIR( )
      </code>
    </example>
  </curdir>
  <date>
    <summary>
      Returns the current system date, which is controlled by the operating system, or creates a year 2000-compliant Date value.
    </summary>
    <param name="nYear">

      Specifies the year returned in the year 2000-compliant Date value. nYear can be a value from 100 to 9999.

    </param>
    <param name="nMonth">

      Specifies the month returned in the year 2000-compliant Date value. nMonth can be a value from 1 to 12.

    </param>
    <param name="nDay">

      Specifies the day returned in the year 2000-compliant Date value. nDay can be a value from 1 to 31.
    </param>
    <returns>
      Date
    </returns>
    <remarks>
      DATE( ) returns the current system date if it is issued without the optional arguments. Include the optional arguments to return a year 2000-compliant Date value in the format set in the Regional tab of the Options dialog box. Any NULL parameter is replaced with the current system value.
      No X# commands or functions can directly change the system date.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        SET CENTURY OFF
        ? DATE( )  &amp;&amp; Displays today's date without the century
        SET CENTURY ON
        ? DATE( )  &amp;&amp; Displays today's date with the century
        ? DATE(1998, 02, 16)  &amp;&amp; Displays a year 2000-compliant Date value
      </code>
    </example>
  </date>
  <datetime>
    <summary>
      Returns the current date and time as a DateTime value, or creates a year 2000-compliant DateTime value.
    </summary>
    <param name="nYear">

      Specifies the year returned in the year 2000-compliant DateTime value. nYear can be a value from 100 to 9999.

    </param>
    <param name="nMonth">

      Specifies the month returned in the year 2000-compliant DateTime value. nMonth can be a value from 1 to 12.

    </param>
    <param name="nDay">

      Specifies the day returned in the year 2000-compliant DateTime value. nDay can be a value from 1 to 31.

    </param>
    <param name="nHours">

      Specifies the hours returned in the year 2000-compliant DateTime value. nHours can be a value from 0 (midnight) to 23 (11 P.M). Defaults to 0 if omitted.

    </param>
    <param name="nMinutes">

      Specifies the minutes returned in the year 2000-compliant DateTime value. nMinutes can be a value from 0 to 59. Defaults to 0 if omitted.

    </param>
    <param name="nSeconds">

      Specifies the seconds returned in the year 2000-compliant DateTime value. nSeconds can be a value from 0 to 59. Defaults to 0 if omitted.
    </param>
    <returns>
      DateTime
    </returns>
    <remarks>
      DATETIME( ) returns the current system DateTime if it is issued without the optional arguments. Any NULL date parameters are replaced with current system values. A NULL time parameter is replaced with 12:00:00.
      Include the optional arguments to return a year 2000-compliant DateTime value in the format specified in the Regional tab of the Options dialog box.
    </remarks>
    <example>
       <code language="X#">
        tNewyear = DATETIME(YEAR(DATE( ) ) + 1, 1, 1)  &amp;&amp; Next New Year
        tToday = DATETIME( )
        nSecondstonewyear = tNewyear - tToday
        CLEAR
        ? "There are " + ALLTRIM (STR(nSecondstonewyear)) ;
        + " seconds to the next New Year."
        CLEAR
        SET CENTURY ON
        SET DATE TO AMERICAN
        ? DATETIME(1998, 02, 16, 12, 34, 56) &amp;&amp; Displays 02/16/1998 12:34:56 PM
      </code>
    </example>
  </datetime>
  <day>
    <summary>
      Returns the numeric day of the month for a given Date or DateTime expression.
    </summary>
    <param name="dExpression">

      Specifies a date from which <b>DAY( )</b> returns a day of the month. dExpression can be a date literal, a Date-type variable, an array element, or a date field.

    </param>
    <param name="tExpression">

      Specifies a date or time from which <b>DAY( )</b> returns a day of the month. dExpression can be a DateTime literal, a DateTime-type variable, an array element, or a DateTime field.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>

      <b>DAY( )</b> returns a number from 1 through 31.
    </remarks>
    <example>
       <code language="X#">
        STORE {^1998-03-05} TO gdBDate
        CLEAR
        ? CDOW(gdBDate)  &amp;&amp; Displays Thursday
        ? DAY(gdBDate) &amp;&amp; Displays 5
        ? 'That date is ', CMONTH(gdBDate), STR(DAY(gdBDate),2)
      </code>
    </example>
  </day>
  <dbf>
    <summary>
      Returns the name of a table open in a specified work area or a table name from a table alias.
    </summary>
    <param name="cTableAlias">

      Specifies the table alias.

    </param>
    <param name="nWorkArea">

      Specifies the work area number.
      If you omit cTableAlias and nWorkArea, <b>DBF( )</b> returns the name of the table open in the current work area<b>. DBF( )</b> returns an empty string if a table isn't open in the work area you specify. If a table doesn't have the alias you specify with cTableAlias, X# generates an error message.
      For information on creating an alias for a table, see USE.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      When SET FULLPATH is ON, <b>DBF( )</b> returns the path to the table with the table name. When SET FULLPATH is OFF, <b>DBF( )</b> returns the drive on which the table resides with the table name.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer IN 2 ALIAS mycust
        CLEAR
        ? DBF(2)  &amp;&amp; Displays customer.dbf with its path
        ? DBF('mycust')  &amp;&amp; Displays customer.dbf with its path
        CLOSE DATABASES
        ? DBF( )      &amp;&amp; Displays the empty string
      </code>
    </example>
  </dbf>
  <ddeaborttrans>
    <summary>
      Ends an asynchronous dynamic data exchange (DDE) transaction.
    </summary>
    <param name="nTransactionNumber">
      Specifies the transaction number returned by <b>DDEExecute( )</b>, <b>DDEPoke( )</b>,
      or <b>DDERequest( )</b> when the transaction is sent to the server application.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      An asynchronous transaction allows X# program execution to continue without waiting for the server application to respond to a data request.<br/><br/>
      <b>DDEExecute( )</b>, <b>DDEPoke( )</b>, and <b>DDERequest( )</b> wait for the period specified by <b>DDESetOption( )</b> for a server application to respond,
      unless you specify a user-defined function to execute when the server application responds.
      Specifying a user-defined function to execute in these functions creates an asynchronous transaction.<br/>
      If <b>DDEAbortTrans( )</b> is called before the server has processed the request, the user-defined function will not be called for the transaction.<br/><br/>
      <b>DDEAbortTrans( )</b> returns true (.T.) if the asynchronous transaction is successfully ended and returns false (.F.)
      if the asynchronous transaction cannot be ended. Use <b>DDELastError( )</b> to determine why the transaction could not be ended.
    </remarks>
  </ddeaborttrans>
  <ddeadvise>
    <summary>
      Creates a notify link or an automatic link used in a dynamic data exchange (DDE).
    </summary>
    <param name="nChannelNumber">
      Specifies the channel number.
    </param>
    <param name="cItemName">
      Specifies the item name. For example, Microsoft Excel uses row and column notation to refer to cells in a worksheet.
      The item name R1C1 designates the cell in the first row and first column of the worksheet.
    </param>
    <param name="cUDFName">
      Specifies the user-defined function that is executed when a notify link or an automatic link is established and the item cItemName is modified.
      When the user-defined function is executed, it is passed the following six parameters in the order given below:
      Channel Number
      The channel number of the server application.
      Action
      ADVISE or TERMINATE.
      The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
      Data
      The new data (automatic link) or the empty string (notify link).
      Format
      The data format; for example, CF_TEXT.
      Advise Status
      The link type (0 = manual, 1 = notify, 2 = automatic).
      The user-defined function should have six parameters in its LPARAMETER or PARAMETER statement to accept the values passed from the server application. If a notify link is established, the user-defined function is executed and the empty string is passed in the Data parameter. You can issue <b>DDERequest( )</b> later to retrieve the data. If an automatic link is established, the user-defined function is executed and the data is passed in the Data parameter.
      The Action parameter contains ADVISE when the link is being updated by the server. The user-defined function is called, and the Action parameter contains TERMINATE when the link is closed by the client or server.
      Any value returned by the user-defined function is ignored.

    </param>
    <param name="nLinkType">

      Specifies the link type in the following way:
      0
      Manual
      1
      Notify
      2
      Automatic
      You can turn off notification from the server application by specifying 0 for nLinkType. If the item changes, the user-defined function is not executed.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>

      <b>DDEAdvise( )</b> is used to create a notify link or an automatic link to an item name in a server application. When a notify link is created with <b>DDEAdvise( )</b>, the server application notifies X# that the item name has been modified. If an automatic link is created, the server application notifies X# that the item name has been modified and passes the new data to X#.
      Before you can create a link, you must establish a channel to the server application with <b>DDEInitiate( )</b>.
      You can also use <b>DDEAdvise( )</b> to turn off notification from the server.
      DDEAdvise( ) returns a true value (.T.) if it executes successfully; otherwise, it returns false (.F.).
    </remarks>
    <example>
       <code language="X#">
        PUBLIC mchannum
        mchannum = DDEInitiate('Excel', 'Sheet1')
        IF mchannum != -1
        = DDEAdvise(mchannum, 'R1C1', 'newdata', 1)     &amp;&amp; Notify link
        = DDEAdvise(mchannum, 'R1C2', 'newdata', 2)     &amp;&amp; Automatic link
        WAIT WINDOW 'Enter data in first two cells in Excel.'
        ENDIF
        PROCEDURE newdata
        PARAMETERS channel, action, item, data, format, advise
        IF action = 'ADVISE'
        DO CASE
        CASE item = 'R1C1'   &amp;&amp; Notify link
        newvalue = DDERequest(channel, item)
        ? 'R1C1 notify link: ' + newvalue
        CASE item = 'R1C2'   &amp;&amp; Automatic link
        newvalue = data
        ? 'R1C2 automatic link: ' + newvalue
        ENDCASE
        ELSE
        IF action != "TERMINATE"
        = DDETerminate(mchannum)
        ENDIF
        ENDIF
      </code>
    </example>
  </ddeadvise>
  <ddeenabled>
    <summary>
      Enables or disables dynamic data exchange (DDE) processing or returns the status of DDE processing.
    </summary>
    <param name="lExpression1">

      Specify true (.T.) or false (.F.) to globally enable or disable DDE processing. <b>DDEEnabled( )</b> returns true (.T.) if DDE processing is successfully enabled or disabled; otherwise false (.F.) is returned.

    </param>
    <param name="nChannelNumber">

      Specifies the channel number for the channel whose DDE processing status <b>DDEEnabled( )</b> returns. <b>DDEEnabled( )</b> returns true (.T.) if DDE processing is enabled for the specified channel and returns false (.F.) if DDE processing is disabled.

    </param>
    <param name="lExpression2">

      To enable DDE processing for a specific channel, include the channel number (nChannelNumber) and specify true (.T.) for lExpression2. To disable DDE processing for a specific channel, include the channel number (nChannelNumber) and specify false (.F.) for lExpression2.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      Using <b>DDEEnabled( )</b>, you can globally enable or disable processing. You can also enable or disable DDE processing for specific channels.

      <b>DDEEnabled( )</b> can be used to protect critical code or disable links for short periods. When DDE processing is disabled, client requests are queued until DDE processing is enabled.
      If <b>DDEEnabled( )</b> is issued without any of its optional arguments, the global DDE processing status is returned. <b>DDEEnabled( </b>) returns true (.T.) if DDE processing has been globally enabled and false (.F.) if DDE processing has been globally disabled.
    </remarks>
  </ddeenabled>
  <ddeexecute>
    <summary>
      Sends a command to another application, using dynamic data exchange (DDE).
    </summary>
    <param name="nChannelNumber">

      Specifies the channel number.

    </param>
    <param name="cCommand">

      Specifies the command you want to send to the other application. The format of the command is determined by the application you are sending it to. Consult the application's documentation for the correct syntax.

    </param>
    <param name="cUDFName">

      Allows asynchronous command execution requests. If you omit cUDFName, a client application waits for the period specified with <b>DDESetOption( )</b>. If you specify a user-defined function with cUDFName, client program execution continues immediately after the command execution request is made.
      When the server application finishes executing the command, the user-defined function you specify with cUDFName is executed. The user-defined function is passed six parameters in the order shown in the following table.
      Channel Number
      The channel number of the server application.
      Action
      XACTCOMPLETE (successful execution).XACTFAIL (failed command execution).
      Item
      The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
      Data
      The new data (REQUEST) or data passed (POKE or EXECUTED).
      Format
      The data format; for example, CF_TEXT.
      Transaction Number
      The transaction number returned by DDEExecute( ).
      Use <b>DDEAbortTrans( )</b> to cancel an uncompleted transaction. If the transaction fails, you can use <b>DDELastError( )</b> to determine why it failed.
      When you include cUDFName, <b>DDEExecute( )</b> does not return a logical value. Instead, a transaction number is returned; if an error occurs, –1 is returned.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      The command sent with <b>DDEExecute( )</b> must be understood by the application. Before you can execute the command, you must establish a channel to the server application with <b>DDEInitiate( )</b>.
      For example, Microsoft Excel has an extensive set of macro commands, including DDE commands that let you request data from X# from within Microsoft Excel. If you establish a channel to Microsoft Excel, you can then use <b>DDEExecute( )</b> to send macro commands to Excel from within X#.
      If the receiving application successfully executes the command, <b>DDEExecute( )</b> returns true (.T.). If the receiving application cannot successfully execute the command or if the channel number you include is not valid, <b>DDEExecute( )</b> returns false (.F.). If the optional asynchronous user-defined function cUDFName is included, a transaction number is returned. If an error occurs, DDEExecute( ) returns –1.
    </remarks>
    <example>
       <code language="X#">
        gnChanNum = DDEInitiate('Excel', 'Sheet1')
        IF gnChanNum != -1
        glExecute = DDEExecute(gnChanNum, '[App.Maximize]')
        IF glExecute != .F.
        WAIT WINDOW 'EXCEL window has been zoomed out.'
        ENDIF
        = DDETerminate(gnChanNum)   &amp;&amp; Close the channel
        ENDIF
      </code>
    </example>
  </ddeexecute>
  <ddeinitiate>
    <summary>
      Establishes a dynamic data exchange (DDE) channel between X# and another Microsoft Windows-based application.
    </summary>
    <param name="cServiceName">

      Specifies the service name of the server application, which, in most cases, is the name of the executable file without its extension. The default service name for X# is X#. If you are establishing a channel to Microsoft Excel, cServiceName is Excel.

    </param>
    <param name="cTopicName">

      Specifies the topic name. The topic is application-specific and must be understood by the application. For example, one topic supplied by most DDE servers is the System topic. See the application documentation for the service and topic names supported by the application.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>

      <b>DDEInitiate( ) </b>establishes a DDE channel between X# and a DDE server application. Once a channel is established, X# can request data from the server by referring to the channel in subsequent DDE functions. X# acts as the client, requesting data from the server application through the channel.
      If the channel is successfully established, <b>DDEInitiate( )</b> returns the channel number. Channel numbers are non-negative, and the number of channels you can establish is limited only by your system resources.

      <b>DDEInitiate( )</b> returns –1 if the channel cannot be established. If the server application is not open, X# asks if you would like to open it. If you choose Yes, X# attempts to open the application. (You can use <b>DDELastError( )</b> to determine why a channel cannot be established.)
      To avoid being asked whether you want to open the application, set the <b>DDESetOption( )</b> SAFETY option. You can also use RUN with the /N option to start the application.
      A channel can be closed with <b>DDETerminate( )</b>.
    </remarks>
    <example>
       <code language="X#">
        mchannum = DDEInitiate('Excel', 'Sheet1')
        IF mchannum != -1
        * Process client actions
        = DDETerminate(mchannum)  &amp;&amp; Close the channel
        ENDIF
      </code>
    </example>
  </ddeinitiate>
  <ddelasterror>
    <summary>
      Returns an error number for the last dynamic data exchange (DDE) function.
    </summary>
    <returns>
      DDELastError( )Return Value
      Numeric
    </returns>
    <remarks>
      You can use <b>DDELastError( )</b> to help determine the cause of an error when a DDE function does not execute successfully.

      <b>DDELastError( )</b> returns 0 if the last DDE function executed successfully. It returns a nonzero value if the last DDE function was unsuccessful. The following table lists the error numbers and their descriptions.
      1
      Service busy
      2
      Topic busy
      3
      Channel busy
      4
      No such service
      5
      No such topic
      6
      Bad channel
      7
      Insufficient memory
      8
      Acknowledge timeout
      9
      Request timeout
      10
      No DDEInitiate( )
      11
      Client attempted server transaction
      12
      Execute timeout
      13
      Bad parameter
      14
      Low memory
      15
      Memory error
      16
      Connect failure
      17
      Request failure
      18
      Poke timeout
      19
      Could not display message
      20
      Multiple synchronous transactions
      21
      Server died
      22
      Internal DDE error
      23
      Advise timeout
      24
      Invalid transaction identifier
      25
      Unknown
    </remarks>
  </ddelasterror>
  <ddepoke>
    <summary>
      Sends data between client and server applications in a dynamic data exchange (DDE) conversation.
    </summary>
    <param name="nChannelNumber">

      Specifies the channel number of the application data is sent to. If the channel number is a server channel, <b>DDEPoke( )</b> sends the data in response to a request or a previously established notify or automatic link.

    </param>
    <param name="cItemName">

      Specifies the item name to which data is sent. The item name is application-specific and must be understood by the application. For example, Microsoft Excel supports R1C1 as a valid item name that refers to the first cell in a worksheet.

    </param>
    <param name="cDataSent">

      Specifies the data sent to the item name specified with cItemName.

    </param>
    <param name="cDataFormat">

      Specifies the format used to send the data. The default format is CF_TEXT. In this format, fields are delimited with tabs and records are delimited with a carriage return and a linefeed.

    </param>
    <param name="cUDFName">

      Allows asynchronous data transfer. If cUDFName is omitted, a client waits for the period specified with <b>DDESetOption( )</b>. If you specify the name of a user-defined function with cUDFName, client program execution continues immediately after the request is made.
      When the data is available from the server application, the user-defined function specified with cUDFName is executed. The user-defined function is passed six parameters in this order:
      Channel Number
      The channel number of the server application.
      Action
      XACTCOMPLETE (successful transaction).XACTFAIL (failed transaction).
      Item
      The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
      Data
      The new data (REQUEST) or data passed (POKE or EXECUTED).
      Format
      The data format; for example, CF_TEXT.
      Transaction Number
      The transaction number returned by <b>DDEPoke( )</b>.
      Use DDEAbortTrans( ) to cancel an uncompleted transaction. If the transaction fails, you can use DDELastError( ) to determine why it failed.
      When you include cUDFName, DDEPoke( ) returns a transaction number if successful or –1 if an error occurs.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>

      <b>DDEPoke( )</b> sends data as a character string to the item name in the application specified by the channel number.
      If the data is successfully sent, <b>DDEPoke( )</b> returns true (.T.). If the data cannot be sent, <b>DDEPoke( )</b> returns false (.F.). If the asynchronous user-defined function cUDFName is included, <b>DDEPoke( )</b> returns a transaction number; if an error occurs, <b>DDEPoke( )</b> returns –1.
    </remarks>
  </ddepoke>
  <dderequest>
    <summary>
      Requests data from a server application in a dynamic data exchange (DDE) conversation.
    </summary>
    <param name="nChannelNumber">

      Specifies the channel number of the server application.

    </param>
    <param name="cItemName">

      Specifies the item name. The item name is application-specific and must be understood by the application. For example, Microsoft Excel uses row and column notation to refer to cells in a worksheet. The item name R1C1 designates the cell in the first row and first column of the worksheet.

    </param>
    <param name="cDataFormat">

      Specifies a format for the data requested. The default format is CF_TEXT. In this format, fields are delimited with tabs and records are delimited with a carriage return and a line feed.

    </param>
    <param name="cUDFName">

      Allows an asynchronous data transfer. If you omit cUDFName, X# waits for the data from the server for the period specified with <b>DDESetOption( )</b>. If you specify the name of a user-defined function with cUDFName, X# continues program execution immediately after the request is made.
      When the data is available from the server application, the user-defined function specified with cUDFName is executed. The user-defined function is passed six parameters in this order:
      Channel Number
      The channel number of the server application.
      Action
      XACTCOMPLETE (successful transaction).XACTFAIL (failed transaction).
      Item
      The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
      Data
      The new data (REQUEST) or data passed (POKE or EXECUTED).
      Format
      The data format; for example, CF_TEXT.
      Transaction Number
      The transaction number returned by <b>DDERequest( )</b>.
      Use <b>DDEAbortTrans( )</b> to cancel an uncompleted transaction. If the transaction fails, you can use <b>DDELastError( )</b> to determine why it failed.
      When you include cUDFName, <b>DDERequest( )</b> returns a transaction number equal to or greater than 0 if successful, or –1 if an error occurs.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      Before you can request data using <b>DDERequest( )</b>, you must establish a channel to the server application with <b>DDEInitiate( )</b>.
      If the request for data is successful, <b>DDERequest( )</b> returns the data as a character string. If the request fails, <b>DDERequest( )</b> returns an empty string and <b>DDELastError( )</b> returns a nonzero value. If you include the asynchronous user-defined function cUDFName, DDERequest( ) returns a transaction number if successful, or –1 if an error occurs.
    </remarks>
    <example>
       <code language="X#">
        mchannum = DDEInitiate('Excel', 'Sheet1')
        IF mchannum != -1
        mrequest = DDERequest(mchannum, 'R1C1')
        IF !EMPTY(mrequest) AND DDELastError( ) = 0      &amp;&amp; Successful
        WAIT WINDOW 'R1C1 contents: ' + mrequest
        ENDIF
        = DDETerminate(mchannum)            &amp;&amp; Close the channel
        ENDIF
      </code>
    </example>
  </dderequest>
  <ddesetoption>
    <summary>
      Changes or returns dynamic data exchange (DDE) settings.
    </summary>
    <param name="cOption">

      Specifies the setting options.
      TIMEOUT
      nTimeoutValue (number of milliseconds)
      2000
      The number of milliseconds DDE functions wait for the server application to respond; the current TIMEOUT value is returned if you omit nTimeoutValue.
      SAFETY
      lExpression(true (.T.) or false (.F.))
      Specifies whether a dialog is displayed when you use <b>DDEInitiate( )</b> to establish a channel to a server application and the application does not respond; the current SAFETY setting is returned if you omit lExpression.

    </param>
    <param name="nTimeoutValue">

      Specifies the timeout value.

    </param>
    <param name="lExpression">

      Enables or disables dialog display.
    </param>
    <returns>
      Logical or Numeric
    </returns>
    <remarks>
      Use <b>DDESetOption( )</b> to change or return DDE settings. Two options, TIMEOUT and SAFETY, are available.
    </remarks>
  </ddesetoption>
  <ddesetservice>
    <summary>
      Creates, releases, or modifies DDE service names and settings.
    </summary>
    <param name="cServiceName">

      Specifies the service name to create, release, modify, or return information about.

    </param>
    <param name="cOption">

      Specifies to create, release, or modify a service name or to return information about a service name. The following table lists the options you can specify with cOption, the default values for the options and a description of each option.
      DEFINE
      –
      Creates a new service name.
      RELEASE
      Releases an existing service name.
      ADVISE
      .F.
      Enables or disables client notification of changes to item names.
      EXECUTE
      Enables or disables command execution.
      POKE
      Enables or disables client pokes to the service.
      REQUEST
      .T.
      Enables or disables requests to the service name.
      FORMATS
      CF_TEXT
      Specifies supported data formats.
      DEFINE
      Creates a new service name. For example, the following command creates the service name codemyservice/code:
       <code language="X#">glNewService = DDESetService('myservice', 'DEFINE')</code>
      RELEASE
      Releases an existing service name to free up system resources. When a service name is released, all of the service's topic names are also released.
      The following command releases the service name created in the previous example:
       <code language="X#">glRelease = DDESetService('myservice', 'RELEASE')</code>
      To release the default X# service, issue this command:
       <code language="X#">glRelFox = DDESetService('FoxPro', 'RELEASE')</code>
      ADVISE
      Specifies whether a client is notified when data changes in an item name or specifies to return the current advise status for a service name. Refer to <b>DDEAdvise( )</b> for additional information about advising clients.
      To enable client notification, specify true (.T.) for lExpression. Specifying false (.F.) for lExpression disables client notification.
      To return the current client notification status for the service name, omit lExpression. <b>DDESetService( )</b> returns true if client notification is enabled for the service name; it returns false if client notification is disabled.
      EXECUTE
      Allows you to enable or disable command execution requests to a service name or to determine the current execute status for a service name.
      To enable client requests to execute a command, specify true (.T.) for lExpression. Specifying false (.F.) for lExpression disables client requests to execute a command. .F. is the default value.
      To return the current command execution status for the service name, omit lExpression. <b>DDESetService( )</b> returns true if client command execution requests are enabled for the service name; otherwise, it returns false.
      The following commands enable command execution and disable data requests from client applications for the service name codemyservice/code. The current command execution status for codemyservice/code is then displayed:
       <code language="X#">
        glExecute = DDESetService('myservice', 'EXECUTE', .T.)
        glRequest = DDESetService('myservice', 'REQUEST', .F.)
        ? DDESetService('myservice', 'EXECUTE')
      </code>
      POKE
      Allows you to enable or disable poke requests to the service name. You can also determine the current poke status for a service name. Refer to <b>DDEPoke( )</b> for additional information about poking data to a server or a client.
      To enable client poke requests, specify true (.T.) for lExpression. Specifying false (.F.) for lExpression disables client poke requests. .F. is the default value.
      To return the current poke status for the service name, omit lExpression. <b>DDESetService( )</b> returns true if poke requests are enabled for a service name; it returns false if poke requests are disabled.
      REQUEST
      Use REQUEST to enable or disable client requests to a service name or to return the current request status for the service name.
      To enable client requests to the service name, specify true (.T.) for lExpression. Specifying false (.F.) disables client requests to the service name. True (.T.) is the default value.
      To return the current request status for a service name, omit lExpression. <b>DDESetService( )</b> returns true if client requests are enabled for the service name; it returns false if client requests are disabled.
      The following commands disable requests from client applications to the service name codemyservice/code and display the current request status for codemyservice/code:
       <code language="X#">
        glRequest = DDESetService('myservice', 'REQUEST', .F.)
        ? DDESetService('myservice', 'REQUEST')
      </code>
      FORMATS [ cDataFormat]
      Specifies the data formats supported by the service name. Server requests for formats not specified with cDataFormat are rejected. When specifying data formats, include a list of the supported formats separated by commas. For example:
       <code language="X#">=DDESetService('myservice', 'FORMATS', 'CF_TEXT, CF_SYLK')</code>
      If you omit cDataFormat, only the CF_TEXT format is supported.
    </param>
    <param name="lExpression">

      Specifies the state of the REQUEST, EXECUTE, POKE, or ADVISE options. Specify true (.T.) for lExpression to enable the option or false (.F.) to disable it.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      X# can act as a dynamic data exchange (DDE) server to send data to client Microsoft Windows-based applications. <b>DDESetService( )</b> is used to create, release, or modify service names and settings in X#. Each service name can have a set of topic names created with <b>DDESetTopic( )</b>. Client applications request data from DDE topic names.

      <b>DDESetService( )</b> returns true (.T.) if the service name is successfully created, released, or modified. If the service name cannot be created, released, or modified, <b>DDESetService( )</b> returns false (.F.).

      <b>DDESetService( )</b> can also be used to return information about a service name. X# has the default service name FoxPro. The X# service name has one topic name called System. The following table lists all the item names supported by the System topic.
      Topics
      A list of available topic names
      Formats
      A list of supported formats
      Status
      Busy or Ready
      SysItems
      A list of item names
      You can use DDESetTopic( ) to modify the FoxPro service name or to release it. For information about manipulating X# service names, see the DDESetTopic( ) options.
    </remarks>
  </ddesetservice>
  <ddesettopic>
    <summary>
      Creates or releases a topic name from a service name in a dynamic data exchange (DDE) conversation.
    </summary>
    <param name="cServiceName">

      Specifies the service name. Additional service names can be created with DDESetService( ).

    </param>
    <param name="cTopicName">

      Specifies the topic name to create or release. If you include cUDFName, <b>DDESetTopic( )</b> creates the topic name cTopicName. If you omit cUDFName, the topic name cTopicName is released. If cTopicName is an empty string, the user-defined function specified with cUDFName is executed for any topic name that is not explicitly declared.

    </param>
    <param name="cUDFName">

      Specifies the name of the user-defined function executed when a client application makes a request to the topic name. If you omit cUDFName, the topic name cTopicName is released from the service name.
      When the user-defined function is executed, it is passed the following six parameters in the order given below:
      Channel Number
      The client channel number.
      Action
      ADVISE, EXECUTE, INITIATE, POKE, REQUEST, or TERMINATE.
      Item
      The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
      Data
      Data from the client.
      Format
      The data format; for example, CF_TEXT.
      Advise Status
      The link type (0 = manual, 2 = notify or automatic).
      The values of the Item, Data, and Advise Status parameters depend on the Action parameter. The following table lists the Action parameter values and the values contained in the Item, Data, and Advise Status parameters. A dash (–) indicates that the parameter value is the empty string.
      Topic name
      Item name
      New data
      New command
      Link type
      If the user-defined function successfully handles the client request, the user-defined function should return true (.T.). If the request cannot be handled or an error occurs, the user-defined function should return false (.F.). If false is returned when the Action parameter value is INITIATE, the client topic name request is rejected. If false is returned when the value is POKE, REQUEST, or EXECUTE, the request is ignored. If false is returned when the value is ADVISE, the client request for a notify or automatic link is rejected.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      After a topic name is created, any client requests to the topic name cause X# to execute the user-defined function specified with cUDFName. The user-defined function is passed a set of parameters whose values are determined by the client request. The user-defined function return value is passed to the client with DDEPoke( ). The return value is a logical value indicating whether the topic name can provide the service requested by the client.

      <b>DDESetTopic( )</b> returns true (.T.) if it successfully creates or releases the topic name. It returns false (.F.) if the topic name cannot be created or released. Use DDELastError( ) to determine why a topic name cannot be created or released.
    </remarks>
    <example>
      The following example creates a basic sample server called codemyserver/code that supports X# command execution from a client application. The client application makes requests to codemyserver/code through the DO topic, and macro substitution is used to execute the client's command.
       <code language="X#">
        *** Set X# up as a DDE server ***
        = DDESetService('myserver', 'DEFINE')
        = DDESetService('myserver', 'EXECUTE', .T.)
        = DDESetTopic('myserver', 'DO', 'DOTOPIC')
        WAIT WINDOW 'Server portion service setup ... ' NOWAIT
        *** Use X# as a DDE client ***
        gnChannel = DDEInitiate('myserver','DO')
        =DDEExecute(gnChannel, 'WAIT WINDOW "Command Executed ... "')
        =DDETerminate(gnChannel)
        PROCEDURE dotopic
        PARAMETERS gnChannel, gcAction, gcItem, gData, gcFormat, gnAdvise
        glResult = .F.
        *** It's necessary to return .T. from an   ***
        *** INITIATE action or no connection is made ***
        IF gcAction = 'INITIATE'
        glResult = .T.
        ENDIF
        IF gcAction = 'EXECUTE'
        &amp;gData
        glResult = .T.
        ENDIF
        IF gcAction = 'TERMINATE'
        WAIT WINDOW 'Goodbye ... ' NOWAIT
        glResult = .T.
        ENDIF
        RETURN glResult
      </code>
      After running this example program, you have set up X# service, which other applications can access. If you have Microsoft Excel, you can run the following Excel macro:
       <code language="X#">
        gnMyChan = INITIATE("myserver","DO")
        =EXECUTE(MyChan,"WAIT WINDOW 'Hi, this is EXCEL speaking'")
        =RETURN( )
      </code>
    </example>
  </ddesettopic>
  <ddeterminate>
    <summary>
      Closes a dynamic data exchange (DDE) channel established with <b>DDEInitiate( )</b>.
    </summary>
    <param name="nChannelNumber">

      Specifies the channel number to close.

    </param>
    <param name="cServiceName">

      Specifies the service name to close.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      If the channel is successfully closed, <b>DDETerminate( )</b> returns true (.T.). If the channel cannot be closed, <b>DDETerminate( )</b> returns false (.F.).
      Be sure to close channels as soon as they are no longer needed to conserve system resources.
      All channels are automatically closed if you exit X# by choosing Exit from the File menu or by issuing QUIT in the Command window or from within a program.
    </remarks>
  </ddeterminate>
  <ddeadvise>
    <summary>
      Creates a notify link or an automatic link used in a dynamic data exchange (DDE).
    </summary>
    <param name="nChannelNumber">
      Specifies the channel number.
    </param>
    <param name="cItemName">
      Specifies the item name. For example, Microsoft Excel uses row and column notation to refer to cells in a worksheet.
      The item name R1C1 designates the cell in the first row and first column of the worksheet.
    </param>
    <param name="cUDFName">
      Specifies the user-defined function that is executed when a notify link or an automatic link is established and the item cItemName is modified.
      When the user-defined function is executed, it is passed the following six parameters in the order given below:
      Channel Number
      The channel number of the server application.
      Action
      ADVISE or TERMINATE.
      The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
      Data
      The new data (automatic link) or the empty string (notify link).
      Format
      The data format; for example, CF_TEXT.
      Advise Status
      The link type (0 = manual, 1 = notify, 2 = automatic).
      The user-defined function should have six parameters in its LPARAMETER or PARAMETER statement to accept the values passed from the server application. If a notify link is established, the user-defined function is executed and the empty string is passed in the Data parameter. You can issue <b>DDERequest( )</b> later to retrieve the data. If an automatic link is established, the user-defined function is executed and the data is passed in the Data parameter.
      The Action parameter contains ADVISE when the link is being updated by the server. The user-defined function is called, and the Action parameter contains TERMINATE when the link is closed by the client or server.
      Any value returned by the user-defined function is ignored.

    </param>
    <param name="nLinkType">

      Specifies the link type in the following way:
      0
      Manual
      1
      Notify
      2
      Automatic
      You can turn off notification from the server application by specifying 0 for nLinkType. If the item changes, the user-defined function is not executed.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>

      <b>DDEAdvise( )</b> is used to create a notify link or an automatic link to an item name in a server application. When a notify link is created with <b>DDEAdvise( )</b>, the server application notifies X# that the item name has been modified. If an automatic link is created, the server application notifies X# that the item name has been modified and passes the new data to X#.
      Before you can create a link, you must establish a channel to the server application with <b>DDEInitiate( )</b>.
      You can also use <b>DDEAdvise( )</b> to turn off notification from the server.
      DDEAdvise( ) returns a true value (.T.) if it executes successfully; otherwise, it returns false (.F.).
    </remarks>
    <example>
       <code language="X#">
        PUBLIC mchannum
        mchannum = DDEInitiate('Excel', 'Sheet1')
        IF mchannum != -1
        = DDEAdvise(mchannum, 'R1C1', 'newdata', 1)     &amp;&amp; Notify link
        = DDEAdvise(mchannum, 'R1C2', 'newdata', 2)     &amp;&amp; Automatic link
        WAIT WINDOW 'Enter data in first two cells in Excel.'
        ENDIF
        PROCEDURE newdata
        PARAMETERS channel, action, item, data, format, advise
        IF action = 'ADVISE'
        DO CASE
        CASE item = 'R1C1'   &amp;&amp; Notify link
        newvalue = DDERequest(channel, item)
        ? 'R1C1 notify link: ' + newvalue
        CASE item = 'R1C2'   &amp;&amp; Automatic link
        newvalue = data
        ? 'R1C2 automatic link: ' + newvalue
        ENDCASE
        ELSE
        IF action != "TERMINATE"
        = DDETerminate(mchannum)
        ENDIF
        ENDIF
      </code>
    </example>
  </ddeadvise>
  <ddeenabled>
    <summary>
      Enables or disables dynamic data exchange (DDE) processing or returns the status of DDE processing.
    </summary>
    <param name="lExpression1">

      Specify true (.T.) or false (.F.) to globally enable or disable DDE processing. <b>DDEEnabled( )</b> returns true (.T.) if DDE processing is successfully enabled or disabled; otherwise false (.F.) is returned.

    </param>
    <param name="nChannelNumber">

      Specifies the channel number for the channel whose DDE processing status <b>DDEEnabled( )</b> returns. <b>DDEEnabled( )</b> returns true (.T.) if DDE processing is enabled for the specified channel and returns false (.F.) if DDE processing is disabled.

    </param>
    <param name="lExpression2">

      To enable DDE processing for a specific channel, include the channel number (nChannelNumber) and specify true (.T.) for lExpression2. To disable DDE processing for a specific channel, include the channel number (nChannelNumber) and specify false (.F.) for lExpression2.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      Using <b>DDEEnabled( )</b>, you can globally enable or disable processing. You can also enable or disable DDE processing for specific channels.

      <b>DDEEnabled( )</b> can be used to protect critical code or disable links for short periods. When DDE processing is disabled, client requests are queued until DDE processing is enabled.
      If <b>DDEEnabled( )</b> is issued without any of its optional arguments, the global DDE processing status is returned. <b>DDEEnabled( </b>) returns true (.T.) if DDE processing has been globally enabled and false (.F.) if DDE processing has been globally disabled.
    </remarks>
  </ddeenabled>
  <ddeexecute>
    <summary>
      Sends a command to another application, using dynamic data exchange (DDE).
    </summary>
    <param name="nChannelNumber">

      Specifies the channel number.

    </param>
    <param name="cCommand">

      Specifies the command you want to send to the other application. The format of the command is determined by the application you are sending it to. Consult the application's documentation for the correct syntax.

    </param>
    <param name="cUDFName">

      Allows asynchronous command execution requests. If you omit cUDFName, a client application waits for the period specified with <b>DDESetOption( )</b>. If you specify a user-defined function with cUDFName, client program execution continues immediately after the command execution request is made.
      When the server application finishes executing the command, the user-defined function you specify with cUDFName is executed. The user-defined function is passed six parameters in the order shown in the following table.
      Channel Number
      The channel number of the server application.
      Action
      XACTCOMPLETE (successful execution).XACTFAIL (failed command execution).
      Item
      The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
      Data
      The new data (REQUEST) or data passed (POKE or EXECUTED).
      Format
      The data format; for example, CF_TEXT.
      Transaction Number
      The transaction number returned by DDEExecute( ).
      Use <b>DDEAbortTrans( )</b> to cancel an uncompleted transaction. If the transaction fails, you can use <b>DDELastError( )</b> to determine why it failed.
      When you include cUDFName, <b>DDEExecute( )</b> does not return a logical value. Instead, a transaction number is returned; if an error occurs, –1 is returned.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      The command sent with <b>DDEExecute( )</b> must be understood by the application. Before you can execute the command, you must establish a channel to the server application with <b>DDEInitiate( )</b>.
      For example, Microsoft Excel has an extensive set of macro commands, including DDE commands that let you request data from X# from within Microsoft Excel. If you establish a channel to Microsoft Excel, you can then use <b>DDEExecute( )</b> to send macro commands to Excel from within X#.
      If the receiving application successfully executes the command, <b>DDEExecute( )</b> returns true (.T.). If the receiving application cannot successfully execute the command or if the channel number you include is not valid, <b>DDEExecute( )</b> returns false (.F.). If the optional asynchronous user-defined function cUDFName is included, a transaction number is returned. If an error occurs, DDEExecute( ) returns –1.
    </remarks>
    <example>
       <code language="X#">
        gnChanNum = DDEInitiate('Excel', 'Sheet1')
        IF gnChanNum != -1
        glExecute = DDEExecute(gnChanNum, '[App.Maximize]')
        IF glExecute != .F.
        WAIT WINDOW 'EXCEL window has been zoomed out.'
        ENDIF
        = DDETerminate(gnChanNum)   &amp;&amp; Close the channel
        ENDIF
      </code>
    </example>
  </ddeexecute>
  <ddeinitiate>
    <summary>
      Establishes a dynamic data exchange (DDE) channel between X# and another Microsoft Windows-based application.
    </summary>
    <param name="cServiceName">

      Specifies the service name of the server application, which, in most cases, is the name of the executable file without its extension. The default service name for X# is X#. If you are establishing a channel to Microsoft Excel, cServiceName is Excel.

    </param>
    <param name="cTopicName">

      Specifies the topic name. The topic is application-specific and must be understood by the application. For example, one topic supplied by most DDE servers is the System topic. See the application documentation for the service and topic names supported by the application.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>

      <b>DDEInitiate( ) </b>establishes a DDE channel between X# and a DDE server application. Once a channel is established, X# can request data from the server by referring to the channel in subsequent DDE functions. X# acts as the client, requesting data from the server application through the channel.
      If the channel is successfully established, <b>DDEInitiate( )</b> returns the channel number. Channel numbers are non-negative, and the number of channels you can establish is limited only by your system resources.

      <b>DDEInitiate( )</b> returns –1 if the channel cannot be established. If the server application is not open, X# asks if you would like to open it. If you choose Yes, X# attempts to open the application. (You can use <b>DDELastError( )</b> to determine why a channel cannot be established.)
      To avoid being asked whether you want to open the application, set the <b>DDESetOption( )</b> SAFETY option. You can also use RUN with the /N option to start the application.
      A channel can be closed with <b>DDETerminate( )</b>.
    </remarks>
    <example>
       <code language="X#">
        mchannum = DDEInitiate('Excel', 'Sheet1')
        IF mchannum != -1
        * Process client actions
        = DDETerminate(mchannum)  &amp;&amp; Close the channel
        ENDIF
      </code>
    </example>
  </ddeinitiate>
  <ddelasterror>
    <summary>
      Returns an error number for the last dynamic data exchange (DDE) function.
    </summary>
    <returns>
      DDELastError( )Return Value
      Numeric
    </returns>
    <remarks>
      You can use <b>DDELastError( )</b> to help determine the cause of an error when a DDE function does not execute successfully.

      <b>DDELastError( )</b> returns 0 if the last DDE function executed successfully. It returns a nonzero value if the last DDE function was unsuccessful. The following table lists the error numbers and their descriptions.
      1
      Service busy
      2
      Topic busy
      3
      Channel busy
      4
      No such service
      5
      No such topic
      6
      Bad channel
      7
      Insufficient memory
      8
      Acknowledge timeout
      9
      Request timeout
      10
      No DDEInitiate( )
      11
      Client attempted server transaction
      12
      Execute timeout
      13
      Bad parameter
      14
      Low memory
      15
      Memory error
      16
      Connect failure
      17
      Request failure
      18
      Poke timeout
      19
      Could not display message
      20
      Multiple synchronous transactions
      21
      Server died
      22
      Internal DDE error
      23
      Advise timeout
      24
      Invalid transaction identifier
      25
      Unknown
    </remarks>
  </ddelasterror>
  <ddepoke>
    <summary>
      Sends data between client and server applications in a dynamic data exchange (DDE) conversation.
    </summary>
    <param name="nChannelNumber">

      Specifies the channel number of the application data is sent to. If the channel number is a server channel, <b>DDEPoke( )</b> sends the data in response to a request or a previously established notify or automatic link.

    </param>
    <param name="cItemName">

      Specifies the item name to which data is sent. The item name is application-specific and must be understood by the application. For example, Microsoft Excel supports R1C1 as a valid item name that refers to the first cell in a worksheet.

    </param>
    <param name="cDataSent">

      Specifies the data sent to the item name specified with cItemName.

    </param>
    <param name="cDataFormat">

      Specifies the format used to send the data. The default format is CF_TEXT. In this format, fields are delimited with tabs and records are delimited with a carriage return and a linefeed.

    </param>
    <param name="cUDFName">

      Allows asynchronous data transfer. If cUDFName is omitted, a client waits for the period specified with <b>DDESetOption( )</b>. If you specify the name of a user-defined function with cUDFName, client program execution continues immediately after the request is made.
      When the data is available from the server application, the user-defined function specified with cUDFName is executed. The user-defined function is passed six parameters in this order:
      Channel Number
      The channel number of the server application.
      Action
      XACTCOMPLETE (successful transaction).XACTFAIL (failed transaction).
      Item
      The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
      Data
      The new data (REQUEST) or data passed (POKE or EXECUTED).
      Format
      The data format; for example, CF_TEXT.
      Transaction Number
      The transaction number returned by <b>DDEPoke( )</b>.
      Use DDEAbortTrans( ) to cancel an uncompleted transaction. If the transaction fails, you can use DDELastError( ) to determine why it failed.
      When you include cUDFName, DDEPoke( ) returns a transaction number if successful or –1 if an error occurs.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>

      <b>DDEPoke( )</b> sends data as a character string to the item name in the application specified by the channel number.
      If the data is successfully sent, <b>DDEPoke( )</b> returns true (.T.). If the data cannot be sent, <b>DDEPoke( )</b> returns false (.F.). If the asynchronous user-defined function cUDFName is included, <b>DDEPoke( )</b> returns a transaction number; if an error occurs, <b>DDEPoke( )</b> returns –1.
    </remarks>
  </ddepoke>
  <dderequest>
    <summary>
      Requests data from a server application in a dynamic data exchange (DDE) conversation.
    </summary>
    <param name="nChannelNumber">

      Specifies the channel number of the server application.

    </param>
    <param name="cItemName">

      Specifies the item name. The item name is application-specific and must be understood by the application. For example, Microsoft Excel uses row and column notation to refer to cells in a worksheet. The item name R1C1 designates the cell in the first row and first column of the worksheet.

    </param>
    <param name="cDataFormat">

      Specifies a format for the data requested. The default format is CF_TEXT. In this format, fields are delimited with tabs and records are delimited with a carriage return and a line feed.

    </param>
    <param name="cUDFName">

      Allows an asynchronous data transfer. If you omit cUDFName, X# waits for the data from the server for the period specified with <b>DDESetOption( )</b>. If you specify the name of a user-defined function with cUDFName, X# continues program execution immediately after the request is made.
      When the data is available from the server application, the user-defined function specified with cUDFName is executed. The user-defined function is passed six parameters in this order:
      Channel Number
      The channel number of the server application.
      Action
      XACTCOMPLETE (successful transaction).XACTFAIL (failed transaction).
      Item
      The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
      Data
      The new data (REQUEST) or data passed (POKE or EXECUTED).
      Format
      The data format; for example, CF_TEXT.
      Transaction Number
      The transaction number returned by <b>DDERequest( )</b>.
      Use <b>DDEAbortTrans( )</b> to cancel an uncompleted transaction. If the transaction fails, you can use <b>DDELastError( )</b> to determine why it failed.
      When you include cUDFName, <b>DDERequest( )</b> returns a transaction number equal to or greater than 0 if successful, or –1 if an error occurs.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      Before you can request data using <b>DDERequest( )</b>, you must establish a channel to the server application with <b>DDEInitiate( )</b>.
      If the request for data is successful, <b>DDERequest( )</b> returns the data as a character string. If the request fails, <b>DDERequest( )</b> returns an empty string and <b>DDELastError( )</b> returns a nonzero value. If you include the asynchronous user-defined function cUDFName, DDERequest( ) returns a transaction number if successful, or –1 if an error occurs.
    </remarks>
    <example>
       <code language="X#">
        mchannum = DDEInitiate('Excel', 'Sheet1')
        IF mchannum != -1
        mrequest = DDERequest(mchannum, 'R1C1')
        IF !EMPTY(mrequest) AND DDELastError( ) = 0      &amp;&amp; Successful
        WAIT WINDOW 'R1C1 contents: ' + mrequest
        ENDIF
        = DDETerminate(mchannum)            &amp;&amp; Close the channel
        ENDIF
      </code>
    </example>
  </dderequest>
  <ddesetoption>
    <summary>
      Changes or returns dynamic data exchange (DDE) settings.
    </summary>
    <param name="cOption">

      Specifies the setting options.
      TIMEOUT
      nTimeoutValue (number of milliseconds)
      2000
      The number of milliseconds DDE functions wait for the server application to respond; the current TIMEOUT value is returned if you omit nTimeoutValue.
      SAFETY
      lExpression(true (.T.) or false (.F.))
      Specifies whether a dialog is displayed when you use <b>DDEInitiate( )</b> to establish a channel to a server application and the application does not respond; the current SAFETY setting is returned if you omit lExpression.

    </param>
    <param name="nTimeoutValue">

      Specifies the timeout value.

    </param>
    <param name="lExpression">

      Enables or disables dialog display.
    </param>
    <returns>
      Logical or Numeric
    </returns>
    <remarks>
      Use <b>DDESetOption( )</b> to change or return DDE settings. Two options, TIMEOUT and SAFETY, are available.
    </remarks>
  </ddesetoption>
  <ddesetservice>
    <summary>
      Creates, releases, or modifies DDE service names and settings.
    </summary>
    <param name="cServiceName">

      Specifies the service name to create, release, modify, or return information about.

    </param>
    <param name="cOption">

      Specifies to create, release, or modify a service name or to return information about a service name. The following table lists the options you can specify with cOption, the default values for the options and a description of each option.
      DEFINE
      –
      Creates a new service name.
      RELEASE
      Releases an existing service name.
      ADVISE
      .F.
      Enables or disables client notification of changes to item names.
      EXECUTE
      Enables or disables command execution.
      POKE
      Enables or disables client pokes to the service.
      REQUEST
      .T.
      Enables or disables requests to the service name.
      FORMATS
      CF_TEXT
      Specifies supported data formats.
      DEFINE
      Creates a new service name. For example, the following command creates the service name codemyservice/code:
       <code language="X#">glNewService = DDESetService('myservice', 'DEFINE')</code>
      RELEASE
      Releases an existing service name to free up system resources. When a service name is released, all of the service's topic names are also released.
      The following command releases the service name created in the previous example:
       <code language="X#">glRelease = DDESetService('myservice', 'RELEASE')</code>
      To release the default X# service, issue this command:
       <code language="X#">glRelFox = DDESetService('FoxPro', 'RELEASE')</code>
      ADVISE
      Specifies whether a client is notified when data changes in an item name or specifies to return the current advise status for a service name. Refer to <b>DDEAdvise( )</b> for additional information about advising clients.
      To enable client notification, specify true (.T.) for lExpression. Specifying false (.F.) for lExpression disables client notification.
      To return the current client notification status for the service name, omit lExpression. <b>DDESetService( )</b> returns true if client notification is enabled for the service name; it returns false if client notification is disabled.
      EXECUTE
      Allows you to enable or disable command execution requests to a service name or to determine the current execute status for a service name.
      To enable client requests to execute a command, specify true (.T.) for lExpression. Specifying false (.F.) for lExpression disables client requests to execute a command. .F. is the default value.
      To return the current command execution status for the service name, omit lExpression. <b>DDESetService( )</b> returns true if client command execution requests are enabled for the service name; otherwise, it returns false.
      The following commands enable command execution and disable data requests from client applications for the service name codemyservice/code. The current command execution status for codemyservice/code is then displayed:
       <code language="X#">
        glExecute = DDESetService('myservice', 'EXECUTE', .T.)
        glRequest = DDESetService('myservice', 'REQUEST', .F.)
        ? DDESetService('myservice', 'EXECUTE')
      </code>
      POKE
      Allows you to enable or disable poke requests to the service name. You can also determine the current poke status for a service name. Refer to <b>DDEPoke( )</b> for additional information about poking data to a server or a client.
      To enable client poke requests, specify true (.T.) for lExpression. Specifying false (.F.) for lExpression disables client poke requests. .F. is the default value.
      To return the current poke status for the service name, omit lExpression. <b>DDESetService( )</b> returns true if poke requests are enabled for a service name; it returns false if poke requests are disabled.
      REQUEST
      Use REQUEST to enable or disable client requests to a service name or to return the current request status for the service name.
      To enable client requests to the service name, specify true (.T.) for lExpression. Specifying false (.F.) disables client requests to the service name. True (.T.) is the default value.
      To return the current request status for a service name, omit lExpression. <b>DDESetService( )</b> returns true if client requests are enabled for the service name; it returns false if client requests are disabled.
      The following commands disable requests from client applications to the service name codemyservice/code and display the current request status for codemyservice/code:
       <code language="X#">
        glRequest = DDESetService('myservice', 'REQUEST', .F.)
        ? DDESetService('myservice', 'REQUEST')
      </code>
      FORMATS [ cDataFormat]
      Specifies the data formats supported by the service name. Server requests for formats not specified with cDataFormat are rejected. When specifying data formats, include a list of the supported formats separated by commas. For example:
       <code language="X#">=DDESetService('myservice', 'FORMATS', 'CF_TEXT, CF_SYLK')</code>
      If you omit cDataFormat, only the CF_TEXT format is supported.
    </param>
    <param name="lExpression">

      Specifies the state of the REQUEST, EXECUTE, POKE, or ADVISE options. Specify true (.T.) for lExpression to enable the option or false (.F.) to disable it.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      X# can act as a dynamic data exchange (DDE) server to send data to client Microsoft Windows-based applications. <b>DDESetService( )</b> is used to create, release, or modify service names and settings in X#. Each service name can have a set of topic names created with <b>DDESetTopic( )</b>. Client applications request data from DDE topic names.

      <b>DDESetService( )</b> returns true (.T.) if the service name is successfully created, released, or modified. If the service name cannot be created, released, or modified, <b>DDESetService( )</b> returns false (.F.).

      <b>DDESetService( )</b> can also be used to return information about a service name. X# has the default service name FoxPro. The X# service name has one topic name called System. The following table lists all the item names supported by the System topic.
      Topics
      A list of available topic names
      Formats
      A list of supported formats
      Status
      Busy or Ready
      SysItems
      A list of item names
      You can use DDESetTopic( ) to modify the FoxPro service name or to release it. For information about manipulating X# service names, see the DDESetTopic( ) options.
    </remarks>
  </ddesetservice>
  <ddesettopic>
    <summary>
      Creates or releases a topic name from a service name in a dynamic data exchange (DDE) conversation.
    </summary>
    <param name="cServiceName">

      Specifies the service name. Additional service names can be created with DDESetService( ).

    </param>
    <param name="cTopicName">

      Specifies the topic name to create or release. If you include cUDFName, <b>DDESetTopic( )</b> creates the topic name cTopicName. If you omit cUDFName, the topic name cTopicName is released. If cTopicName is an empty string, the user-defined function specified with cUDFName is executed for any topic name that is not explicitly declared.

    </param>
    <param name="cUDFName">

      Specifies the name of the user-defined function executed when a client application makes a request to the topic name. If you omit cUDFName, the topic name cTopicName is released from the service name.
      When the user-defined function is executed, it is passed the following six parameters in the order given below:
      Channel Number
      The client channel number.
      Action
      ADVISE, EXECUTE, INITIATE, POKE, REQUEST, or TERMINATE.
      Item
      The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
      Data
      Data from the client.
      Format
      The data format; for example, CF_TEXT.
      Advise Status
      The link type (0 = manual, 2 = notify or automatic).
      The values of the Item, Data, and Advise Status parameters depend on the Action parameter. The following table lists the Action parameter values and the values contained in the Item, Data, and Advise Status parameters. A dash (–) indicates that the parameter value is the empty string.
      Topic name
      Item name
      New data
      New command
      Link type
      If the user-defined function successfully handles the client request, the user-defined function should return true (.T.). If the request cannot be handled or an error occurs, the user-defined function should return false (.F.). If false is returned when the Action parameter value is INITIATE, the client topic name request is rejected. If false is returned when the value is POKE, REQUEST, or EXECUTE, the request is ignored. If false is returned when the value is ADVISE, the client request for a notify or automatic link is rejected.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      After a topic name is created, any client requests to the topic name cause X# to execute the user-defined function specified with cUDFName. The user-defined function is passed a set of parameters whose values are determined by the client request. The user-defined function return value is passed to the client with DDEPoke( ). The return value is a logical value indicating whether the topic name can provide the service requested by the client.

      <b>DDESetTopic( )</b> returns true (.T.) if it successfully creates or releases the topic name. It returns false (.F.) if the topic name cannot be created or released. Use DDELastError( ) to determine why a topic name cannot be created or released.
    </remarks>
    <example>
      The following example creates a basic sample server called codemyserver/code that supports X# command execution from a client application. The client application makes requests to codemyserver/code through the DO topic, and macro substitution is used to execute the client's command.
       <code language="X#">
        *** Set X# up as a DDE server ***
        = DDESetService('myserver', 'DEFINE')
        = DDESetService('myserver', 'EXECUTE', .T.)
        = DDESetTopic('myserver', 'DO', 'DOTOPIC')
        WAIT WINDOW 'Server portion service setup ... ' NOWAIT
        *** Use X# as a DDE client ***
        gnChannel = DDEInitiate('myserver','DO')
        =DDEExecute(gnChannel, 'WAIT WINDOW "Command Executed ... "')
        =DDETerminate(gnChannel)
        PROCEDURE dotopic
        PARAMETERS gnChannel, gcAction, gcItem, gData, gcFormat, gnAdvise
        glResult = .F.
        *** It's necessary to return .T. from an   ***
        *** INITIATE action or no connection is made ***
        IF gcAction = 'INITIATE'
        glResult = .T.
        ENDIF
        IF gcAction = 'EXECUTE'
        &amp;gData
        glResult = .T.
        ENDIF
        IF gcAction = 'TERMINATE'
        WAIT WINDOW 'Goodbye ... ' NOWAIT
        glResult = .T.
        ENDIF
        RETURN glResult
      </code>
      After running this example program, you have set up X# service, which other applications can access. If you have Microsoft Excel, you can run the following Excel macro:
       <code language="X#">
        gnMyChan = INITIATE("myserver","DO")
        =EXECUTE(MyChan,"WAIT WINDOW 'Hi, this is EXCEL speaking'")
        =RETURN( )
      </code>
    </example>
  </ddesettopic>
  <ddeterminate>
    <summary>
      Closes a dynamic data exchange (DDE) channel established with <b>DDEInitiate( )</b>.
    </summary>
    <param name="nChannelNumber">

      Specifies the channel number to close.

    </param>
    <param name="cServiceName">

      Specifies the service name to close.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      If the channel is successfully closed, <b>DDETerminate( )</b> returns true (.T.). If the channel cannot be closed, <b>DDETerminate( )</b> returns false (.F.).
      Be sure to close channels as soon as they are no longer needed to conserve system resources.
      All channels are automatically closed if you exit X# by choosing Exit from the File menu or by issuing QUIT in the Command window or from within a program.
    </remarks>
  </ddeterminate>
  <deleted>
    <summary>
      Returns a logical value that indicates whether the current record is marked for deletion.
    </summary>
    <returns>
      Logical
    </returns>
    <remarks>
      If the record is marked for deletion, DELETED( ) returns true (.T.); otherwise, DELETED( ) returns false (.F.).
      Records can be marked for deletion with DELETE and DELETE – SQL, and they can be unmarked with RECALL.
      Rushmore Query Optimization optimizes queries that test the deleted status of records if the table is indexed on DELETED( ).
      For information on using Rushmore to optimize queries, see SET OPTIMIZE and Using Rushmore Query Optimization to Speed Data Access.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer  &amp;&amp; Opens Customer table
        DELETE FROM customer WHERE country = 'USA'  &amp;&amp; Mark for deletion
        CLEAR
        LIST FIELDS company, country FOR DELETED( ) &amp;&amp; List marked records
        RECALL ALL  &amp;&amp; Unmark all records marked for deletion
      </code>
    </example>
  </deleted>
  <directory>
    <summary>
      Locates the specified directory.
    </summary>
    <param name="cDirectoryName">

      Specifies the name of the directory to locate. If you do not include an absolute path for the directory you specify, X# searches for the directory relative to the X# default directory.

    </param>
    <param name="nFlags">

      Specifies the kind of value <b>DIRECTORY( )</b> returns when the directory exists but might be marked with the <b>Hidden</b> or <b>System</b> attribute. The following table lists the values for nFlags.
      0
      <b>DIRECTORY( )</b> returns False (.F.) if the directory exists but is marked with a Hidden or System attribute. (Default)
      1
      <b>DIRECTORY( )</b> returns True (.T.) if the directory exists, regardless of its attributes. Setting nFlags to 1 allows you to check for hidden or system files.
    </param>
    <returns>
      Logical data type. <b>DIRECTORY( )</b> returns True (.T.) if the specified directory is found on the disk; otherwise, it returns False (.F.).
    </returns>
    <remarks>
      The <b>SET DEFAULT</b> command specifies the X# default directory.
      You can use the <b>ADIR( )</b> function to determine specific attributes for the directory.
      You can use the <b>CD</b> and <b>CHDIR</b> commands to switch to hidden files and directories.
    </remarks>
  </directory>
  <diskspace>
    <summary>
      Retrieves the number of bytes with the specified type that are available on the default or specified hard disk drive or volume.
    </summary>
    <param name="cVolumeName">

      Specifies the name of the hard disk drive or volume for which the available space is returned. If you omit cVolumeName, the available space is returned for the default disk drive or volume.

    </param>
    <param name="nType">

      Specifies the type of hard disk space to retrieve. The following table lists the values for nType.
      1
      Total amount of space on the hard disk drive.
      2
      Total amount of free space on the hard disk drive. (Default)
      3
      Total amount of free space available to the user associated with the calling thread.
    </param>
    <returns>
      Numeric. <b>DISKSPACE( )</b> returns the number of bytes with the type specified. If the hard disk is full, <b>DISKSPACE( )</b> returns a value of 0 or -1. If an error occurs when reading the hard disk drive or volume, <b>DISKSPACE( )</b> can also return a value of –1.
      The return value of <b>DISKSPACE( )</b> might not be accurate for large network drives on some networks. Additionally, <b>DISKSPACE( )</b> may return -1 for certain long named directories on Windows 98.
    </returns>
    <remarks>
      You can use <b>DISKSPACE( )</b> to determine if sufficient space is available to back up files or to execute commands such as <b>SORT</b> that require additional disk space for temporary work files.
      You can specify the default disk drive or volume using the <b>SET DEFAULT</b> command.
    </remarks>
    <example>
       <code language="X#">
        *** Check DISKSPACE before sort ***
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer  &amp;&amp; Opens Customer table
        *** Get size of table header ***
        gnTableHead = HEADER( )
        *** Calculate size of table ***
        gnFileSize = gnTableHead + (RECSIZE( ) * RECCOUNT( ) + 1)
        IF <b>DISKSPACE( )</b> &gt; (gnFileSize * 3)
        WAIT WINDOW 'Sufficient diskspace to sort.'
        ELSE
        WAIT WINDOW 'Insufficient diskspace. Sort cannot be done.'
        ENDIF
      </code>
    </example>
  </diskspace>
  <dodefault>
    <summary>
      Executes the parent class event or method of the same name from within a subclass.
      For example, if you place <b>DODEFAULT( )</b> in the <b>Click</b> event of a subclass, X# executes the <b>Click</b> event of the parent class. The scope resolution operator (::), unlike <b>DODEFAULT( )</b>, executes a parent class event or method of a different name.
      You can place <b>DODEFAULT( )</b> only within an event or method.
    </summary>
    <returns>
      Character, Numeric, Currency, Date, DateTime, Logical, or Memo
    </returns>
    <remarks>
      The value that <b>DODEFAULT( )</b> returns is determined by the return value of the event or method.
      In versions prior to X# 8.0, you could not call <b>DODEFAULT( )</b> in a method that did not exist in the parent class without X# generating an error, "Property name is not found (Error 1734)", returning True (.T.), and disregarding <b>DODEFAULT( )</b> and any passed parameters. However, X# now disregards this and does not generate an error, but the following results still occur:
      X# disregards any parameters that are passed because no code is executed.
      X# always returns True (.T.), which is the default behavior for any procedure without an explicit <b>RETURN</b> statement.
      This behavior affects the following scenarios:
      Custom methods that are defined in a class. For example, the line, codex.Test()/code, generated an error prior to X# 8.0 but no longer does:
       <code language="X#">
        CLEAR
        x=CREATEOBJECT("s1")
        x.ReadMethod("Init")
        x.Test()
        DEFINE CLASS s1 AS Session
        PROCEDURE Test
        DODEFAULT()
        ENDPROC
        PROCEDURE ReadMethod(cMethod)
        DODEFAULT(cMethod)
        ENDPROC
        PROCEDURE Error(nError, cMethod, nLine)
        ? "Error:", nError, cMethod, nLine
        ENDPROC
        ENDDEFINE
      </code>
      Native methods that are marked with the <b>HIDDEN</b> key word in the parent class. For example:
       <code language="X#">
        CLEAR
        x=CREATEOBJECT("s2")
        x.Test()
        DEFINE CLASS s2 AS s1
        PROCEDURE Test
        THIS.ReadMethod("Init")
        ENDPROC
        PROCEDURE ReadMethod(cMethod)
        DODEFAULT(cMethod)
        ENDPROC
        ENDDEFINE
        DEFINE CLASS s1 AS Session
        HIDDEN PROCEDURE ReadMethod(cMethod)
        DODEFAULT(cMethod)
        ENDPROC
        PROCEDURE Error(nError, cMethod, nLine)
        ? "Error:", nError, cMethod, nLine
        ENDPROC
        ENDDEFINE
      </code>
      Starting in X# 7.0, calling a native method in a base class that contains <b>DODEFAULT( )</b> does not cause an error. For example:
       <code language="X#">
        CLEAR
        x=CREATEOBJECT("s1")
        x.ReadMethod("Init")
        DEFINE CLASS s1 AS Session
        PROCEDURE ReadMethod(cMethod)
        DODEFAULT(cMethod)
        ENDPROC
        PROCEDURE Error(nError, cMethod, nLine)
        ? "Error:", nError, cMethod, nLine
        ENDPROC
        ENDDEFINE
      </code>
    </remarks>
  </dodefault>
  <dow>
    <summary>
      Returns a numeric day-of-the-week value from a Date or DateTime expression.
    </summary>
    <param name="dExpression">

      Specifies the Date expression from which DOW( ) returns the day number.

    </param>
    <param name="tExpression">

      Specifies the DateTime expression from which DOW( ) returns the day number.

    </param>
    <param name="nFirstDayOfWeek">

      Specifies the first day of the week. nFirstDayOfWeek may be one of the following values.
      0
      DOW( ) uses whatever day is currently selected in the Week Starts On list box, which appears on the Regional Tab in the Options dialog box.
      1
      Sunday. This is the default when nFirstDayOfWeek is omitted, and is the first day of the week used in earlier FoxPro versions.
      2
      Monday
      3
      Tuesday
      4
      Wednesday
      5
      Thursday
      6
      Friday
      7
      Saturday
    </param>
    <returns>
      Numeric
    </returns>
    <example>
       <code language="X#">
        STORE DATE( ) TO gdDayNum
        CLEAR
        ? DOW(gdDayNum)
        ? CDOW(gdDayNum)
      </code>
    </example>
  </dow>
  <dtoc>
    <summary>
      Returns a Character-type date from a Date or DateTime expression.
    </summary>
    <param name="dExpression">

      Specifies a Date-type variable, array element, or field for which DTOC( ) returns a Character-type date.

    </param>
    <param name="tExpression">

      Specifies a DateTime-type variable, array element, or field for which DTOC( ) returns a Character-type date.
      1
      Returns the date in a format suitable for indexing. This is particularly useful for maintaining the table records in chronological sequence.
      For example, to order table records in entry sequence, you could issue this command:
       <code language="X#">INDEX ON DTOC(gdInvDate, 1) + gnInvTime TAG Timeindx</code>
      codegdInvDate/code and codegnInvTime/code are fields containing the date and time when the data was entered in the record.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      DTOC( ) returns a character string corresponding to a Date or DateTime expression. The date format is determined by SET CENTURY and SET DATE.
    </remarks>
    <example>
       <code language="X#">
        SET STRICTDATE TO 1
        STORE CTOD('10/31/98') TO gdThisDate
        CLEAR
        ? DTOC(gdThisDate)
        STORE DTOC({^1998-10-31}+90) TO gcExpireDate
        ? 'Your 90-day warranty expires ', gcExpireDate
        ? DTOC({^1998-10-31},1)
      </code>
    </example>
  </dtoc>
  <dtor>
    <summary>
      Converts degrees to radians.
    </summary>
    <param name="nExpression">

      Specifies the numeric expression whose value you want to convert to radians. An angle expressed in a degree:minute:second format should be converted to its decimal equivalent.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      DTOR( ) converts the value of a numeric expression given in degrees to an equivalent value in radians. DTOR( ) is useful for working with the X# trigonometric functions: ACOS( ), ASIN( ), COS( ), SIN( ), TAN( ).
      Use RTOD( ) to convert radians to degrees.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? DTOR(0)  &amp;&amp; Displays 0.00
        ? DTOR(45) &amp;&amp; Displays 0.79
        ? DTOR(90) &amp;&amp; Displays 1.57
        ? DTOR(180)  &amp;&amp; Displays 3.14
        ? COS(DTOR(90))  &amp;&amp; Displays 0.00
      </code>
    </example>
  </dtor>
  <dtos>
    <summary>
      Returns a character-string date in a yyyymmdd format from a specified Date or DateTime expression.
    </summary>
    <param name="dExpression">

      Specifies the Date expression DTOS( ) converts to an eight-digit character string.

    </param>
    <param name="tExpression">

      Specifies the DateTime expression DTOS( ) converts to an eight-digit character string.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      This function is useful for indexing tables on a Date or DateTime field. It is equivalent to DTOC( ) when its optional 1 argument is included.
      The character string returned by DTOS( ) isn't affected by SET DATE or SET CENTURY.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? DTOS(DATE( ))
      </code>
    </example>
  </dtos>
  <editsource>
    <summary>
      Opens the X# editor and, optionally positions the cursor.
    </summary>
    <param name="cShortCutID">

      Specifies the valid shortcut ID.

    </param>
    <param name="cFileName">

      Specifies the name of the file to open. If the file is already open, X# activates it.

    </param>
    <param name="nLineNo">

      Specifies the line at which to position the cursor. If you use 0, the cursor is positioned at the last location saved in the resource file. If you provide an invalid or non-existent nlineno, the cursor is positioned at the beginning of the current file. A negative nlineno value will generate an error.

    </param>
    <param name="cClassName">

      Specifies the name of a class or data environment to be edited. If you open a class file (.vcx) without naming a class, the Class Designer opens instead of the editor.

    </param>
    <param name="cMethodName">

      Specifies the name of a method to be edited. Use a valid object-referenced method in the form cObject.nMethodName.

    </param>
    <param name="cProcName">

      Specifies the name of a procedure to be edited in a class type file (.vcx, .scx, .frx, .lbx).
    </param>
    <returns>
      Logical. Returns true (.T.) if the target file opens successfully, otherwise returns error codes according to the following table:
      0
      Successful file opening.
      132, 705
      File in use. Cannot be opened.
      200
      File not opened due to invalid object reference. Verify the presence of cMethodName in the object referenced by the cClassName parameter.
      901, 925
      File opened but invalid object reference in cMethodName. Check the reference in the cMethodName parameter. Use a reference such as MyForm.MyList.CLICK. Forms and classes return 925; reports return 901.
    </returns>
    <remarks>
      You can pass cShortCutID without any additional information and have the editor open at that location. The cShortCutID is the unique ID value for a shortcut record stored in the Foxtask system table (_VFP.FoxTask). The Task List application uses this table to ensure that it can get the latest line position of the shortcut. X# maintains, internally, current shortcut information, but only writes line position updates to Foxtask when a file is saved.
      The file extension determines which X# editor opens, according to the following table:
      PRG
      Text Editor
      MODIFY COMMAND
      MPR
      Text Editor
      MODIFY COMMAND
      QPR
      Text Editor
      MODIFY COMMAND
      TXT
      Text Editor
      MODIFY FILE
      SCX
      Code Editor
      MODIFY FORM
      VCX
      Code Editor
      MODIFY CLASS
      FRX
      Code Editor
      MODIFY REPORT
      LBX
      Code Editor
      MODIFY LABEL
      MNX
      Menu Editor
      MODIFY MENU
      DBC
      Stored Procedures
      MODIFY PROCEDURE
      &lt;other&gt;
      Text Editor
      MODIFY FILE
      Program (.prg), database (.dbc stored procedures) and text files support only the nLineNo parameter.
      Menu file (.mnx) are opened as text files without reference to objects or to line numbers.
    </remarks>
  </editsource>
  <empty>
    <summary>
      Determines whether an expression evaluates to empty.
    </summary>
    <param name="eExpression">

      Specifies the expression that <b>EMPTY( )</b> evaluates. You can specify an expression with <b>Character</b>, <b>Numeric</b>, <b>Date</b>, <b>Varbinary</b>, <b>Blob</b>, or <b>Logical</b> type, or the name of a <b>Memo</b> or <b>General</b> field in an open table.
    </param>
    <returns>
      Logical. <b>EMPTY( )</b> returns True (.T.) if the expression eExpression evaluates to empty; otherwise, <b>EMPTY( )</b> returns False (.F.).
      When expression types evaluate to the values in the following table, <b>EMPTY( )</b> returns True (.T.).

      <b>Blob</b>

      Empty (0h) or contains only zero bytes, for example, 0h00, 0h000000, and so on

      <b>Character</b>

      Empty string, spaces, tabs, carriage returns, linefeeds, or any combination of these

      <b>Currency</b>

      0

      <b>Date</b>

      Empty, for example, CTOD('')

      <b>DateTime</b>

      Empty, for example, CTOT('')

      <b>Double</b>

      0

      <b>Float</b>

      0

      <b>General</b>

      Empty (no OLE object)

      <b>Integer</b>

      0

      <b>Logical</b>

      False (.F.)

      <b>Memo</b>

      Empty (no contents)

      <b>Numeric</b>

      0

      <b>Varbinary</b>

      Empty (0h) or contains only zero bytes, for example, 0h00, 0h000000, and so on
    </returns>
    <remarks>
      You cannot use <b>EMPTY( )</b> to determine whether a variable object reference is empty. For example, a variable can contain an object reference for a form. If the form is closed by clicking Close from the form's pop-up menu or by issuing <b>CLEAR WINDOWS</b>, the variable contains the null value.
      The following program example demonstrates how to use <b>TYPE( )</b> and <b>ISNULL( )</b> to determine if a variable object reference is valid.
       <code language="X#">
        goMyForm = CREATEOBJECT('Form')
        WAIT WINDOW IIF(TYPE('goMyForm') = 'O' AND !ISNULL(goMyForm), ;
        'goMyForm has valid object reference',;
        'goMyForm does not have valid object reference')
      </code>
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'data\testdata')
        USE customer     &amp;&amp; Open customer table
        FOR nCount = 1 TO TAGCOUNT( )
        IF !EMPTY(TAG(nCount))  &amp;&amp; Checks for empty string
        ? TAG(nCount)  &amp;&amp; Display tag name
        ? CANDIDATE(nCount)  &amp;&amp; Display candidate status
        ELSE
        EXIT  &amp;&amp; Exit the loop when no more tags are found
        ENDIF
        ENDFOR
      </code>
    </example>
  </empty>
  <eof>
    <summary>
      Determines whether the record pointer is positioned past the last record in the current or specified table.
    </summary>
    <param name="nWorkArea">

      Specifies the work area number of the table.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table.
      EOF( ) returns false (.F.) if a table isn't open in the work area you specify.
      If you do not specify a work area or alias, the table that is open in the currently selected work area is tested for the end of the table condition.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      EOF( ) returns true (.T.) if the record pointer reaches the end of the table file (EOF). The end of the table is reached when the record pointer passes the last record in the table. For example, when a FIND, LOCATE, or SEEK is unsuccessful, X# moves the record pointer past the last record, and EOF( ) returns true (.T.). EOF( ) returns false (.F.) if the record pointer isn't at the end of the table.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        CLEAR
        OPEN DATABASE (HOME() + "samples\data\testdata")
        USE customer
        GO TOP
        local recCtr, btnValue
        recCtr = 0
        btnValue = 1
        DO WHILE btnValue = 1 AND NOT EOF()
        ? "Company : " + company
        recCtr = recCtr + 1
        if (recCtr % 20) = 0 then
        btnValue =MESSAGEBOX ("Click OK to continue, ;
        Cancel to quit.",33)
        clear
        endif
        Skip 1    &amp;&amp; Move down one record
        ENDDO
        =MESSAGEBOX("Listing complete.",48)
      </code>
    </example>
  </eof>
  <error>
    <summary>
      Returns the error number for the error that triggered an ON ERROR routine.
    </summary>
    <returns>
      ERROR( )Return Value
      Numeric
    </returns>
    <remarks>
      ERROR( ) returns the number of the most recent error. An ON ERROR routine must be active for ERROR( ) to return a value other than 0.
      When an error is trapped during program execution, the error type can be returned by ERROR( ) in an ON ERROR routine. The corresponding error message can be returned by MESSAGE( ).
      The value ERROR( ) returns is reset by RETURN or RETRY.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ON ERROR DO errhand WITH ERROR( ), MESSAGE( )
        *** The next line generates an error - there is no BRWSE command
        BRWSE
        ON ERROR
        RETURN
        *** Error handler ***
        PROCEDURE errhand
        PARAMETER errnum,message
        ? Message
        ? 'Error number: '+ ALLTRIM(STR(Errnum))
        RETURN
      </code>
    </example>
  </error>
  <evaluate>
    <summary>
      Evaluates a character expression and returns the result.
    </summary>
    <param name="cExpression">

      Specifies the expression to evaluate. cExpression can be a literal character string, or a valid X# expression, variable, array element, or field of any data type, enclosed in quotation marks. cExpression cannot exceed 255 characters.
      Whenever possible, use EVALUATE( ) or a name expression to replace macro substitution using the &amp; Command. EVALUATE and name expressions execute faster than macro substitution.
    </param>
    <returns>
      Character, Numeric, Currency, Date, DateTime, Logical, or Memo
    </returns>
    <remarks>
      EVALUATE( ) is similar to TYPE( ) but returns the result of an expression instead of the expression type. An expression containing EVALUATE( ) cannot be optimized by Rushmore Query Optimization.
      Including the EVALUATE( ) function in the WHERE clause of a SQL query can return incorrect data.
    </remarks>
    <example>
       <code language="X#">
        cMathFunc="INT(4.33)"
        nResult=EVALUATE(cMathFunc)
        ?nResult
      </code>
    </example>
  </evaluate>
  <eventhandler>
    <summary>
      Binds a COM server event to implemented interface methods on a X# object.
      For information about binding events from native X# objects, see Event Binding for X# Objects.
    </summary>
    <param name="oCOMObject">

      Specifies the object reference to the object whose events are to be bound. oCOMObject must be a valid COM object.

    </param>
    <param name="oVFPObject">

      Specifies the object reference to the X# object that contains user-defined method code, which maps to corresponding COM object events. The class must implement the events interface for the particular COM object being passed in the first parameter. For example, you must implement the RecordsetEvents interface to bind to an ADO Recordset object.

    </param>
    <param name="lUnbind">

      X# automatically releases the COM object when it goes out of scope. By passing this parameter with a value of .T., you can release the event binding while both objects remain in scope.
    </param>
    <returns>
      Logical data type. <b>EVENTHANDLER( )</b> returns True (.T.) if successful and False (.F.) if unsuccessful.
    </returns>
    <remarks>
      You can bind a single COM object to several X# objects, or you can bind several COM objects to the same X# object.
      Event handling is automatically unbound when either the X# or the COM object is released. You can explicitly call the EVENTHANDLER( ) function and pass the lUnbind parameter to unbind objects without releasing object references.
    </remarks>
    <example>
       <code language="X#">
        LOCAL oEvents
        LOCAL oRS AS adodb.recordset
        LOCAL oConn AS adodb.Connection
        oEvents = NEWOBJECT("myclass")
        oConn = NEWOBJECT("adodb.connection")
        oConn.Provider="MSDASQL"
        * Make sure to set the SourceDB property
        * below to your TESTDATA location.
        oConn.ConnectionString="DSN=X# Database;" + ;
        "SourceType=DBC; SourceDB=D:\VFP\DATA\TESTDATA.DBC"
        oConn.Open
        oRS = oConn.Execute("select * from customer")
        ? EVENTHANDLER(oRS, oEvents)
        ?
        ? PADR(oRS.Fields(0).Value,20)
        ? EVENTHANDLER (oRS, oEvents, .T.)
        oRS.MoveNext
        ? PADR(oRS.Fields(0).Value,20)
        oRS.MoveNext
        CLEAR all
        RETURN
        DEFINE CLASS myclass AS session
        IMPLEMENTS RecordsetEvents IN "adodb.recordset"
        PROCEDURE Recordsetevents_WillChangeField(cFields AS Number @, Fields AS VARIANT @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
        ? " "+program() + ' ' + TRANSFORM(DATETIME())
        PROCEDURE Recordsetevents_FieldChangeComplete(cFields AS Number @, Fields AS VARIANT @, pError AS VARIANT @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
        ? " "+program() + ' ' + TRANSFORM(DATETIME())
        PROCEDURE Recordsetevents_WillChangeRecord(adReason AS VARIANT @, cRecords AS Number @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
        ? " "+program() + ' ' + TRANSFORM(DATETIME())
        PROCEDURE Recordsetevents_RecordChangeComplete(adReason AS VARIANT @, cRecords AS Number @, pError AS VARIANT @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
        ? " "+program() + ' ' + TRANSFORM(DATETIME())
        PROCEDURE Recordsetevents_WillChangeRecordset(adReason AS VARIANT @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
        ? " "+program() + ' ' + TRANSFORM(DATETIME())
        ?adreason,adstatus,precordset.recordcount
        PROCEDURE Recordsetevents_RecordsetChangeComplete(adReason AS VARIANT @, pError AS VARIANT @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
        ? " "+program() + ' ' + TRANSFORM(DATETIME())
        PROCEDURE Recordsetevents_WillMove(adReason AS VARIANT @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
        ? " "+program() + ' ' + TRANSFORM(DATETIME())
        PROCEDURE Recordsetevents_MoveComplete(adReason AS VARIANT @, pError AS VARIANT @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
        ? " "+program() + ' ' + TRANSFORM(DATETIME())
        PROCEDURE Recordsetevents_EndOfRecordset(fMoreData AS LOGICAL @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
        ? " "+program() + ' ' + TRANSFORM(DATETIME())
        PROCEDURE Recordsetevents_FetchProgress(Progress AS Number @, MaxProgress AS Number @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
        ? " "+program() + ' ' + TRANSFORM(DATETIME())
        PROCEDURE Recordsetevents_FetchComplete(pError AS VARIANT @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
        ? " "+program() + ' ' + TRANSFORM(DATETIME())
        ENDDEFINE
      </code>
    </example>
  </eventhandler>
  <exp>
    <summary>
      Returns the value of ex where x is a specified numeric expression.
    </summary>
    <param name="nExpression">

      Specifies the exponent, ix/i, in the exponential expression ie/ix.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The value of e, the base of natural logarithms, is approximately 2.71828. The number of decimal places returned by EXP( ) is specified with SET DECIMALS.
    </remarks>
    <example>
       <code language="X#">
        ? EXP(0)  &amp;&amp; Displays 1.00
        ? EXP(1)  &amp;&amp; Displays 2.72
      </code>
    </example>
  </exp>
  <fchsize>
    <summary>
      Changes the size of a file opened with a low-level file function.
    </summary>
    <param name="nFileHandle">

      Specifies the file handle of the file whose size you wish to change. The file handle is returned by <b>FOPEN( )</b> when you open the file or by <b>FCREATE( )</b> when you create the file. If a file is opened with <b>FOPEN( )</b>, it must be opened with write or read/write privileges to be able to change its size.

    </param>
    <param name="nNewFileSize">

      Specifies the new file size in bytes. If nNewFileSize is less than the original file size, the file is truncated. If nNewFileSize is greater than the original file size, the file size is increased.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      Use <b>FCHSIZE( )</b> to increase the file's size or truncate the file after a specified byte.
      When a file's size is increased, X# allocates sectors for the file on the drive where the file is opened. Since <b>FCHSIZE( )</b> does not initialize the new file space, the space can contain previous data. Be sure to manage the new file space.
      The final size of the file in bytes is returned. X# returns –1 if <b>FCHSIZE( )</b> is unable to change the file size if, for example, an invalid file handle is specified because of insufficient disk space, or if the file is read-only.
      This function can be used to truncate a file to length 0.
    </remarks>
  </fchsize>
  <fclose>
    <summary>
      Flushes and closes a file or communication port opened with a low-level file function.
    </summary>
    <param name="nFileHandle">

      Specifies the file handle of the low-level file to close. The numeric file handle is returned when you create the file with <b>FCREATE( )</b> or open the file with <b>FOPEN( )</b>.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      If the file is successfully closed, <b>FCLOSE( )</b> returns true (.T.) and releases the file handle. If the file cannot be closed, <b>FCLOSE( )</b> returns false (.F.).
      CLOSE ALL also closes low-level files.
    </remarks>
  </fclose>
  <fcount>
    <summary>
      Returns the number of fields in a table.
    </summary>
    <param name="nWorkArea">

      Specifies the work area of the table for which <b>FCOUNT( )</b> returns the number of fields.
      <b>FCOUNT( )</b> returns 0 if a table isn't open in the work area you specify.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table for which <b>FCOUNT( )</b> returns the number of fields.
      X# generates an error message if you specify a table alias that doesn't exist.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      If you omit the optional arguments, <b>FCOUNT( )</b> returns the number of fields in the table open in the currently selected work area.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer  &amp;&amp; Opens Customer table
        SELECT 0
        USE employee  &amp;&amp; Opens employee table
        CLEAR
        ? FCOUNT('CUSTOMER')     &amp;&amp; Displays 13, # of fields in Customer
        ? FCOUNT('EMPLOYEE')  &amp;&amp; Displays 22, # of fields in Employee
      </code>
    </example>
  </fcount>
  <fcreate>
    <summary>
      Creates and opens a low-level file.
    </summary>
    <param name="cFileName">

      Specifies the name of the file to create. You can include a drive designator and path with the file name. If a drive designator or path isn't included, the file is created in the default directory.
      X# does not recognize a path name properly if a disk or directory name contains an exclamation point (!).

    </param>
    <param name="nFileAttribute">

      Specifies the attributes of the file created. The following table lists the file attributes you can specify.
      nFileAttribute
      0
      (Default) Read/write
      1
      Read-only
      2
      Hidden
      3
      Read-only/Hidden
      4
      System
      5
      Read-only/System
      6
      System/Hidden
      7
      Read-only/Hidden/System
      Note that a file created with nFileAttribute other than 0 cannot be written to with <b>FPUTS( )</b> or <b>FWRITE( )</b> until the file is closed and opened again.
      Use DISPLAY STATUS or LIST STATUS to display or print information about files created and opened with <b>FCREATE( )</b>. DISPLAY STATUS and LIST STATUS give the following information about each file opened or created with a low-level file function:
      The drive, directory, and file name
      The file handle number
      The file pointer position
      The read/write attributes
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      If a file with the name you specify already exists, it is overwritten without warning.

      <b>FCREATE( )</b> assigns a file handle number to the file, which you can use to identify the file in other X# low-level file functions. <b>FCREATE( )</b> returns the file handle number when a file is created, or returns –1 if the file cannot be created.
      Assign the file handle number to a memory variable so you can access the file by the variable in other low-level file functions.
      You cannot open a communication port with <b>FCREATE( )</b>. Use <b>FOPEN( )</b> to open a communication port.
    </remarks>
    <example>
       <code language="X#">
        IF FILE('errors.txt')  &amp;&amp; Does file exist?
        gnErrFile = FOPEN('errors.txt',12)     &amp;&amp; If so, open read/write
        ELSE
        gnErrFile = FCREATE('errors.txt')  &amp;&amp; If not create it
        ENDIF
        IF gnErrFile &lt; 0     &amp;&amp; Check for error opening file
        WAIT 'Cannot open or create output file' WINDOW NOWAIT
        ELSE  &amp;&amp; If no error, write to file
        =FWRITE(gnErrFile , 'Error information to be written here')
        ENDIF
        =FCLOSE(gnErrFile )     &amp;&amp; Close file
        IF gnErrFile &gt; 0
        MODIFY FILE errors.txt NOWAIT  &amp;&amp; Open file in edit window
        ENDIF
      </code>
    </example>
  </fcreate>
  <fdate>
    <summary>
      Returns the last modification Date or DateTime for a file.
    </summary>
    <param name="cFileName">

      Specifies the name of the file whose last modification date <b>FDATE( )</b> returns. cFileName can include a path with the file name. If a path is not included with the file name, X# searches for the file in the default directory and in any directories or folders specified with SET PATH.

    </param>
    <param name="nType">

      Specifies that <b>FDATE( )</b> returns the last modification date or DateTime of the file specified with cFileName. If nType is 0, the last modification date is returned. Including 0 is identical to omitting nType. If nType is 1, the last modification DateTime is returned.
    </param>
    <returns>
      Date
    </returns>
    <remarks>
      The Date or DateTime value that <b>FDATE( )</b> returns is assigned to the file by the operating system.
      Use LUPDATE( ) to determine the last modification date for an open table.
    </remarks>
    <example>
       <code language="X#">? FDATE('FOXUSER.DBF', 1)  &amp;&amp; Displays the last modification DateTime</code>
    </example>
  </fdate>
  <feof>
    <summary>
      Determines whether the file pointer is positioned at the end of a file.
    </summary>
    <param name="nFileHandle">

      Specifies the file handle number of the file to check for the end-of-file condition. <b>FEOF( )</b> always returns true (.T.) if you specify a file handle number of a communication port opened with <b>FOPEN( )</b>.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      This low-level file function returns true (.T.) if the file pointer is positioned at the end of a file opened with a low-level file function. <b>FEOF( )</b> returns false (.F.) if the file pointer isn't at the end of the file.
    </remarks>
    <example>
       <code language="X#">
        *** Open the file test.txt ***
        gnFileHandle = FOPEN('test.txt')
        *** Move the file pointer to BOF ***
        gnPosition = FSEEK(gnFileHandle, 0)
        *** If file pointer is at BOF and EOF, the file is empty ***
        *** Otherwise the file must have something in it ***
        IF FEOF(gnFileHandle)
        WAIT WINDOW 'This file is empty!' NOWAIT
        ELSE
        WAIT WINDOW 'This file has something in it!' NOWAIT
        ENDIF
        = FCLOSE(gnFileHandle)
      </code>
    </example>
  </feof>
  <ferror>
    <summary>
      Returns a number corresponding to the most recent low-level file function error.
    </summary>
    <returns>
      FERROR( )Return Value
      Numeric
    </returns>
    <remarks>

      <b>FERROR( )</b> returns 0 if a low-level file function executes successfully. A positive value is returned if a function doesn't execute successfully. The following table lists each error number returned by <b>FERROR( )</b> and the cause of the error.
      2
      File not found
      4
      Too many files open (out of file handles)
      5
      Access denied
      6
      Invalid file handle given
      8
      Out of memory
      25
      Seek error (can't seek before the start of a file)
      29
      Disk full
      31
      Error opening file
    </remarks>
  </ferror>
  <fflush>
    <summary>
      Flushes to disk a file opened with a low-level function.
    </summary>
    <param name="nFileHandle">

      Specifies the file handle of the file to flush to disk.

    </param>
    <param name="lForce">

      If you specify a logical true (.T.) for lForce, Windows is used to immediately flush the file to disk.
      If you specify a logical false (.F.) (the default if lForce is omitted), X# flushes the file to disk at its earliest opportunity.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>

      <b>FFLUSH( )</b> also releases the memory used by the file's buffer.
      FLUSH is different from the <b>FFLUSH( )</b> function. FLUSH doesn't operate on low-level files but rather on tables and indexes.
    </remarks>
    <example>
       <code language="X#">
        IF FILE('input.dat')
        gnTestFile = FOPEN('input.dat',2)
        ELSE
        gnTestFile = FCREATE('input.dat')
        ENDIF
        gnIOBytes = FWRITE(gnTestFile,'Test output')
        gnIOBytes = FWRITE(gnTestFile,' for low-level file I/O')
        glFlushOk = FFLUSH(gnTestFile, .T.)
        gnIOBytes = FWRITE(gnTestFile,'Test output2')
        gnIOBytes = FWRITE(gnTestFile,' for low-level file I/O')
        glFlushOk = FFLUSH(gnTestFile)
        glCloseOk = FCLOSE(gnTestFile)
        MODIFY FILE input.dat NOWAIT NOEDIT
      </code>
    </example>
  </fflush>
  <fgets>
    <summary>
      Returns a series of bytes from a file or a communication port opened with a low-level file function until it encounters a carriage return.
    </summary>
    <param name="nFileHandle">

      Specifies the numeric file handle of the file or communication port from which <b>FGETS( )</b> returns data.

    </param>
    <param name="nBytes">

      Specifies the number of bytes <b>FGETS( )</b> returns. <b>FGETS( )</b> returns nBytes bytes unless a carriage return is encountered first. <b>FGETS( )</b> returns data between the starting file-pointer position and the carriage return if a carriage return is encountered within nBytes bytes.
      <b>FGETS( )</b> returns a maximum of 8192 bytes. If you omit nBytes, <b>FGETS( )</b>returns 254 bytes by default.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      You can read a file line by line by issuing a series of <b>FGETS( )</b>.

      <b>FGETS( )</b> returns a series of bytes as a character string. Data is returned starting from the current file's pointer position and continuing until a carriage return is encountered. The file pointer is then positioned on the byte immediately following the carriage return. The carriage return is not returned as part of the string, and line feeds are discarded.
    </remarks>
    <example>
       <code language="X#">
        *** TEST.TXT must exist ***
        STORE FOPEN('test.txt') TO gnFileHandle    &amp;&amp; Open the file
        STORE FSEEK(gnFileHandle, 0, 2) TO gnEnd    &amp;&amp; Move pointer to EOF
        STORE FSEEK(gnFileHandle, 0) TO gnTop     &amp;&amp; Move pointer to BOF
        IF gnEnd &lt;= 0  &amp;&amp; Is file empty?
        WAIT WINDOW 'This file is empty!' NOWAIT
        ELSE  &amp;&amp; If not
        gcString = FGETS(gnFileHandle, gnEnd)  &amp;&amp; Store contents
        ? gcString
        ENDIF
        = FCLOSE(gnFileHandle)  &amp;&amp; Close the file
      </code>
    </example>
  </fgets>
  <file>
    <summary>
      Locates the specified file.
    </summary>
    <param name="cFileName">

      Specifies the name of the file to locate. cFileName must include the file extension. You can include a path with the file name to search for a file in a directory or on a drive other than the current directory or drive.
      If you do not include a path with the file name, X# searches in the default directory for the file. If it cannot find the file in the default directory, X# searches along the X# path, which is established with <b>SET PATH</b>.

    </param>
    <param name="nFlags">

      Specifies the kind of value <b>FILE( )</b> returns when the file exists but might be marked with the <b>Hidden</b> or <b>System</b> attribute. The following table lists the values for nFlags.
      0
      <b>FILE( )</b> returns False (.F.) if the file exists but is marked with a <b>Hidden</b> or <b>System</b> attribute. (Default)
      1
      <b>FILE( )</b> returns True (.T.) if the file exists, regardless of its file attributes. Setting nFlags to 1 allows you to check for hidden or system files.
    </param>
    <returns>
      Logical data type. <b>FILE( )</b> returns True (.T.) if the specified file is included in an application or found on a disk; otherwise, it returns False (.F.).
    </returns>
    <remarks>
      You can use the <b>ADIR( )</b> function to retrieve specific attributes for the file.
      You can use the <b>CD</b> and <b>CHDIR</b> commands to switch to hidden files and directories.
    </remarks>
    <example>
       
      <code language="X#">
        SET PATH TO HOME( )
        CLEAR
        IF FILE('foxuser.dbf')
        WAIT WINDOW 'X# resource file present'
        ELSE
        WAIT WINDOW 'X# resource file not present'
        ENDIF
      </code>
    </example>
  </file>
  <fklabel>
    <summary>
      Returns the name of the function key (F1, F2, F3 ...) from the key's corresponding function key number.
    </summary>
    <param name="nFunctionKeyNumber">

      Specifies the function key number. The value of nFunctionKeyNumber should be from 0 through the number of function keys minus 1. FKLABEL( ) returns the empty string if nFunctionKeyNumber is greater than the number of function keys minus 1. The number of function keys can be determined with FKMAX( ).
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      Function keys can be programmed with SET FUNCTION.
      The value returned by FKLABEL( ) is affected by SET COMPATIBLE. When COMPATIBLE is set to FOXPLUS (the default), FKLABEL( ) returns the function keys. When COMPATIBLE is set to DB4, FKLABEL( ) returns the function key and function key combinations (F1, CTRL+F1, SHIFT+F1, F2, CTRL+F2, SHIFT+F2, ...).
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        SET COMPATIBLE OFF
        ? 'COMPATIBLE OFF'
        ?
        FOR nCount = 1 TO FKMAX( )  &amp;&amp; Loop for # of function keys
        ? FKLABEL(nCount)  &amp;&amp; Display programmable function keys
        ENDFOR
        SET COMPATIBLE ON
        ?
        ? 'COMPATIBLE ON'
        ?
        FOR nCount = 1 TO FKMAX( )  &amp;&amp; Loop for # of function keys
        ? FKLABEL(nCount)  &amp;&amp; Display programmable function keys
        ENDFOR
      </code>
    </example>
  </fklabel>
  <fkmax>
    <summary>
      Returns the number of programmable function keys or function key combinations on your keyboard.
    </summary>
    <returns>
      FKMAX( )Return Value
      Numeric
    </returns>
    <remarks>
      The value returned by FKMAX( ) is affected by SET COMPATIBLE. When SET COMPATIBLE is set to FOXPLUS (the default), FKMAX( ) returns the number of function keys. When SET COMPATIBLE is set to DB4, FKMAX( ) returns the number of function key and function key combinations (F1, CTRL+F1, SHIFT+F1, F2, CTRL+F2, SHIFT+F2, ...).
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        SET COMPATIBLE OFF
        ? 'COMPATIBLE OFF'
        ?
        FOR nCount = 1 TO FKMAX( )  &amp;&amp; Loop for # of function keys
        ? FKLABEL(nCount)  &amp;&amp; Display programmable function keys
        ENDFOR
        SET COMPATIBLE ON
        ?
        ? 'COMPATIBLE ON'
        ?
        FOR nCount = 1 TO FKMAX( )  &amp;&amp; Loop for # of function keys
        ? FKLABEL(nCount)  &amp;&amp; Display programmable function keys
        ENDFOR
      </code>
    </example>
  </fkmax>
  <flock>
    <summary>
      Attempts to lock the current or specified table.
    </summary>
    <param name="nWorkArea">

      Specifies the work area of the table that FLOCK( ) attempts to lock. Omitting nWorkArea or cTableAlias causes FLOCK( ) to attempt locking the table that is open in the currently selected work area.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table that FLOCK( ) attempts to lock.
      X# generates an error message if you specify a table alias that does not exist.
    </param>
    <returns>
      Logical. FLOCK( ) returns True (.T.) if the table is successfully locked. Otherwise, it returns False (.F.) under the following conditions:
      The table or a record in the table is already locked by another user.
      A table is not open in the work area you specify.
      If FLOCK() fails to lock a table and returns False (.F.), FLOCK() does not generate an error. As a result, you cannot use FLOCK() to trigger an ON ERROR routine.
    </returns>
    <remarks>
      When a table is locked, the table is available for both read and write access by the user who placed the lock. Other users on the network have read-only access to the table. For information on how to lock a table and prevent access to it by other users, see SET EXCLUSIVE Command and USE Command.
      A table remains locked until it is unlocked by the user who placed the lock. The table can be unlocked by issuing UNLOCK, closing the table, or quitting X#. Tables can be closed with USE, CLEAR ALL, or CLOSE DATABASES.
      By default, FLOCK( ) attempts to lock a table once. Use SET REPROCESS to automatically retry a table lock when the first attempt fails. SET REPROCESS determines the number of lock attempts, or the length of time during which lock attempts are made when the initial lock attempt is unsuccessful. For more information, see SET REPROCESS Command.
      You can establish relations between two or more tables with SET RELATION. Placing a file lock on a table that is related to one or more tables doesn't place a file lock on the related tables. You must explicitly place and remove locks on the related tables.
      For additional information about record and file locking and sharing tables on a network, see Programming for Shared Access.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE products  &amp;&amp; Opens products table
        SET REPROCESS TO 3 SECONDS
        SELECT * FROM products INTO TABLE newprods
        IF FLOCK( )
        *** New product initialization ***
        REPLACE ALL in_stock  WITH 0.00
        REPLACE ALL on_order WITH 0.00
        WAIT 'Initialization Complete' WINDOW NOWAIT
        ELSE
        *** File is locked, warn user ***
        WAIT WINDOW 'Unable to open products file; try again later!' NOWAIT
        ENDIF
        BROWSE FIELDS in_stock, on_order &amp;&amp; Displays newprods table
        USE
        ERASE newprods.dbf
      </code>
    </example>
  </flock>
  <floor>
    <summary>
      Returns the nearest integer that is less than or equal to the specified numeric expression.
    </summary>
    <param name="nExpression">

      Specifies the numeric expression for which FLOOR( ) returns the nearest integer that is less than or equal to the numeric expression.
    </param>
    <returns>
      Numeric
    </returns>
    <example>
       <code language="X#">
        STORE  10.9 TO gnNumber1
        STORE -10.1 TO gnNumber2
        CLEAR
        ? FLOOR(gnNumber1)  &amp;&amp; Displays 10
        ? FLOOR(gnNumber2)  &amp;&amp; Displays -11
        ? FLOOR(10.0)  &amp;&amp; Displays 10
        ? FLOOR(-10.0)  &amp;&amp; Displays -10
      </code>
    </example>
  </floor>
  <fopen>
    <summary>
      Opens a file for use with low-level file functions.
    </summary>
    <param name="cFileName">

      Specifies the name of the file to open. cFileName can include a path to open files in directories, folders, drives, or volumes not in the current X# search path. If a path isn't included, X# searches for the file in the following locations:
      Default directory
      Path established with SET PATH
      X# will not recognize a path name properly if a disk or directory name contains an exclamation point (!).

    </param>
    <param name="nAttribute">

      Specifies read/write privileges or a buffering scheme for the file you open. The following table lists each number you can include in nAttribute, and the read/write file privileges and buffering scheme it establishes.
      0
      (Default) Read-only
      Buffered
      1
      Write-only
      2
      Read and Write
      10
      Unbuffered
      11
      12
      If nAttribute isn't included, or if nAttribute evaluates to 0, the file is opened as read-only and is buffered.
      X# will not recognize a path name properly if a disk or directory name contains an exclamation point (!).
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      If <b>FOPEN( )</b> successfully opens the file, the file handle number of the file is returned. <b>FOPEN( )</b> returns –1 if the file cannot be opened.
      Assign the file handle number to a memory variable so you can access the file by the memory variable in other low-level file functions.
      The following information about files opened with <b>FOPEN( )</b> can be displayed or sent to a printer with DISPLAY STATUS or LIST STATUS.
      Drive and directory or volume and folder, and file name
      File handle number
      File pointer position
      Read/write attributes
    </remarks>
    <example>
       <code language="X#">
        IF FILE('errors.txt')  &amp;&amp; Does file exist?
        gnErrFile = FOPEN('errors.txt',12)  &amp;&amp; If so, open read/write
        ELSE
        gnErrFile = FCREATE('errors.txt')  &amp;&amp; If not, create it
        ENDIF
        IF gnErrFile &lt; 0  &amp;&amp; Check for error opening file
        WAIT 'Cannot open or create output file' WINDOW NOWAIT
        ELSE  &amp;&amp; If no error, write to file
        =FWRITE(gnErrFile, 'Error information to be written here')
        ENDIF
        =FCLOSE(gnErrFile)  &amp;&amp; Close file
        MODIFY FILE errors.txt NOWAIT  &amp;&amp; Open file in edit window
      </code>
    </example>
  </fopen>
  <found>
    <summary>
      Determines whether the most recently executed <b>CONTINUE</b>, <b>FIND</b>, <b>LOCATE</b>, or <b>SEEK</b> command was successful or if the record pointer was moved in a related table.
      You can use <b>FOUND( ) </b>to determine if a child table has a record that matches the parent record.
    </summary>
    <param name="nWorkArea">

      Specifies the work area of the table that the most recent <b>CONTINUE</b>, <b>FIND</b>, <b>LOCATE</b>, or <b>SEEK</b> command was called on.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table that the most recent <b>CONTINUE</b>, <b>FIND</b>, <b>LOCATE</b>, or <b>SEEK</b> command was called on.
      If you specify a table alias that does not exist, X# generates an error message.
    </param>
    <returns>
      Logical. <b>FOUND( )</b> returns True (.T.) if the most recent <b>CONTINUE</b>, <b>FIND</b>, <b>LOCATE</b>, or <b>SEEK</b> command was successful; otherwise, it returns False (.F.). If a table is not open in the work area you specify, <b>FOUND( )</b> returns False. When <b>FOUND( )</b> encounters an end-of-file, which can be determined by the <b>EOF( )</b> function, it always returns False.
    </returns>
    <remarks>
      If you call <b>FOUND( )</b> without arguments, <b>FOUND( )</b> is called on the table open in the currently selected work area.
      The following example locates and counts all customers whose Country field in the Customer table contains "GERMANY". <b>CLOSE DATABASES</b> closes all databases, and <b>OPEN DATABASE</b> opens the sample X# database, TestData.dbc. <b>USE</b> opens the Customer table.

      <b>STORE</b> stores a value of 0 in the variable gnCount. <b>LOCATE</b> searches for the first record in which the Country field contains the value "GERMANY". The <b>DO WHILE</b> loop increments the variable gnCount by 1 and uses <b>CONTINUE</b> to perform another <b>LOCATE</b> operation. When there are no more matching records, the total number of customers is displayed.
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\TestData')
        USE Customer
        STORE 0 TO gnCount
        LOCATE FOR UPPER(Country)='GERMANY'
        DO WHILE FOUND()
        gnCount = gnCount + 1
        CONTINUE
        ENDDO
        ? "Total customers from Germany: "+LTRIM(STR(gnCount))
      </code>
    </remarks>
  </found>
  <fputs>
    <summary>
      Writes a character string, carriage return, and line feed to a file opened with a low-level file function.
    </summary>
    <param name="nFileHandle">

      Specifies the file handle number for the file to which <b>FPUTS( )</b> writes data.

    </param>
    <param name="cExpression">

      Specifies the character expression that <b>FPUTS( )</b> writes to the file.

    </param>
    <param name="nCharactersWritten">

      Specifies the number of characters in cExpression to write to the file.
      <b>FPUTS( )</b> writes the entire character expression cExpression to the file if you omit nCharactersWritten. If you include nCharactersWritten, nCharactersWritten characters are written to the file. If nCharactersWritten is less than the number of characters in cExpression, only nCharactersWritten characters are written to the file. All of cExpression is written to the file if nCharactersWritten is equal to or greater than the number of characters in cExpression.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      FPUTS( ) returns the number of bytes written to the file. Zero is returned if <b>FPUTS( )</b> cannot write to the file for any reason.
    </remarks>
  </fputs>
  <fread>
    <summary>
      Returns a specified number of bytes from a file opened with a low-level function.
    </summary>
    <param name="nFileHandle">

      Specifies the file handle number for the file from which <b>FREAD( )</b> returns data. You can obtain nFileHandle from the return value of successful FOPEN( ) or FCREATE( ) statements.

    </param>
    <param name="nByte">

      Specifies the number of bytes returned by <b>FREAD( )</b> with a limit of 65,535 bytes. <b>FREAD( )</b> returns data starting from the current file pointer position and continues until it returns nBytes bytes or until it encounters the end of the file.
    </param>
    <returns>
      Character
    </returns>
    <example>
       <code language="X#">
        Local gnFileHandle,nSize,cString
        gnFileHandle = FOPEN("test.txt")
        * Seek to end of file to determine number of bytes in the file.
        nSize =  FSEEK(gnFileHandle, 0, 2)     &amp;&amp; Move pointer to EOF
        IF nSize &lt;= 0
        * If file is empty, display an error message.
        WAIT WINDOW "This file is empty!" NOWAIT
        ELSE
        * If file is not empty, store the file's contents in memory
        * and display the text in the main X# window.
        = FSEEK(gnFileHandle, 0, 0)      &amp;&amp; Move pointer to BOF
        cString = FREAD(gnFileHandle, nSize)
        ? cString
        ENDIF
        = FCLOSE(gnFileHandle)         &amp;&amp; Close the file
      </code>
    </example>
  </fread>
  <fseek>
    <summary>
      Moves the file pointer in a file opened with a low-level file function.
    </summary>
    <param name="nFileHandle">

      Specifies the file handle for the file in which FSEEK( ) moves the file pointer. A file handle number is returned by FCREATE( ) or FOPEN( ) when the file is created or opened.

    </param>
    <param name="nBytesMoved">

      Specifies the number of bytes to move the file pointer. The file pointer is moved toward the end of the file if nBytesMoved is positive. The file pointer is moved toward the beginning of the file if nBytesMoved is negative.

    </param>
    <param name="nRelativePosition">

      Moves the file pointer to a relative position in the file. By default, the file pointer is moved relative to the beginning of the file. You can also move the file pointer relative to the current file pointer or the end of the file by including nRelativePosition. The following table lists values for nRelativePosition and from where the file pointer is moved.
      0
      (Default) The beginning of the file.
      1
      The current file pointer position.
      2
      The end of the file.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      After moving the file pointer, FSEEK( ) returns the number of bytes the file pointer is positioned from the beginning of the file. The file pointer can also be moved with FREAD( ) and FWRITE( ).
    </remarks>
    <example>
       <code language="X#">
        FUNCTION fsize2
        PARAMETERS gcFileName  &amp;&amp; File to be checked
        PRIVATE pnHandle,pnSize
        IF PARAMETERS( ) = 0
        RETURN -2  &amp;&amp; Return -2 if no parameter passed
        ELSE
        IF !FILE(gcFileName)
        RETURN -1  &amp;&amp; Return -1 if file does not exist
        ENDIF
        ENDIF
        pnHandle = FOPEN(gcFileName)   &amp;&amp; Open file
        pnSize = FSEEK(pnHandle,0,2)   &amp;&amp; Determine file size, assign to pnSize
        =FCLOSE(pnHandle)  &amp;&amp; Close file
        RETURN pnSize  &amp;&amp; Return value
      </code>
    </example>
  </fseek>
  <fsize>
    <summary>
      Returns the size in bytes of a specified field or file.
    </summary>
    <param name="cFieldName">

      Specifies the name of the field.

    </param>
    <param name="nWorkArea">

      Specifies the work area of the table for which FSIZE( ) returns a field size.
      FSIZE( ) returns 0 if a table isn't open in the work area you specify.

    </param>
    <param name="cTableAlias">

      Specifies the alias of the table for which FSIZE( ) returns a field size.
      X# generates an error message if you specify a table alias that doesn't exist.

    </param>
    <param name="cFileName">

      Specifies a file for which FSIZE( ) returns the size in bytes.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The current setting of SET COMPATIBLE determines if FSIZE( ) returns the size of a field or a file. If SET COMPATIBLE is set to OFF or FOXPLUS (the default), FSIZE( ) returns the size of a field. If SET COMPATIBLE is set to ON or DB4, FSIZE( ) returns the size of a file.
      The following table shows the default size (in bytes) for each fixed-length field type.
      Currency
      8
      Date
      8
      DateTime
      8
      Double
      8
      Integer
      4
      Logical
      1
      Memo
      4
      General
      4
      The size of a field can be displayed with DISPLAY STRUCTURE and LIST STRUCTURE.
      If you omit the optional nWorkArea and cTableAlias arguments, FSIZE( ) returns the field size for a field in the current table and work area.
    </remarks>
    <example>
       <code language="X#">
        SET COMPATIBLE OFF
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer  &amp;&amp; Open Customer table
        CLEAR
        ? FSIZE('contact')  &amp;&amp; Displays 30
        ? FSIZE('cust_id')  &amp;&amp; Displays 6
      </code>
    </example>
  </fsize>
  <ftime>
    <summary>
      Returns the last modification time for a file.
    </summary>
    <param name="cFileName">

      Specifies the name of the file whose last modification time FTIME( ) returns. cFileName can include a path with the file name. If a path is not included with the file name, X# searches for the file in the default directory and in any directories or folders specified with SET PATH.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      The time that FTIME( ) returns is assigned to the file by the operating system.
    </remarks>
    <example>
       <code language="X#">? FTIME('FOXUSER.DBF')  &amp;&amp; Displays the last modification time</code>
    </example>
  </ftime>
  <fwrite>
    <summary>
      Writes a character string to a file opened with a low-level file function.
    </summary>
    <param name="nFileHandle">

      Specifies the file handle number for the file to which FWRITE( ) writes.

    </param>
    <param name="cExpression">

      Specifies the character expression that FWRITE( ) writes to the file specified with nFileHandle.

    </param>
    <param name="nCharactersWritten">

      FWRITE( ) writes the entire character expression to the file unless you include nCharactersWritten. When you include nCharactersWritten, nCharactersWritten characters are written to the file. If nCharactersWritten is less than the number of characters in cExpression, only nCharactersWritten characters are written to the file. All of the characters in cExpression are written to the file if nCharactersWritten is equal to or greater than the number of characters in cExpression.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      Unlike FPUTS( ), FWRITE( ) doesn't place a carriage return and a line feed at the end of the character string.
      FWRITE( ) returns the number of bytes written to the file. If FWRITE( ) can't write to the file for any reason, 0 is returned.
    </remarks>
  </fwrite>
  <getbar>
    <summary>
      Returns the number of an item on a menu defined with DEFINE POPUP or the X# system menu.
    </summary>
    <param name="MenuItemName">
      Specifies the menu item.
    </param>
    <param name="nMenuPosition">
      Specifies a position on the menu. nMenuPosition can range from 1 through the number of items within the menu.
      1 corresponds to the first item on the menu, 2 to the second item, and so on.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      Use GETBAR( ) to determine which item occupies a specific position on a menu. This function is useful when items on a menu are added, removed, or rearranged. Use DEFINE BAR to add an item to a menu or RELEASE BAR to remove an item. The position of items in a menu can be changed if MOVER is included when the menu is created with DEFINE POPUP.
    </remarks>
    <example>
       <code language="X#">
        Clear
        ON KEY LABEL CTRL+Z DO showorder
        WAIT WINDOW "Press CTRL+Z to refresh." NOWAIT
        DEFINE POPUP popDemo MOVER From 2,2
        DEFINE BAR 1 OF popDemo PROMPT 'One'
        DEFINE BAR 2 OF popDemo PROMPT 'Two'
        DEFINE BAR 3 OF popDemo PROMPT 'Three'
        DEFINE BAR 4 OF popDemo PROMPT 'Four'
        DO showorder
        ACTIVATE POPUP popDemo
        PROCEDURE showorder
        Clear
        @ 3,12 SAY  '1 ' + PRMBAR('popDemo', GETBAR('popDemo',1))
        @ 4,12 SAY  '2 ' + PRMBAR('popDemo', GETBAR('popDemo',2))
        @ 5,12 SAY  '3 ' + PRMBAR('popDemo', GETBAR('popDemo',3))
        @ 6,12 SAY  '4 ' + PRMBAR('popDemo', GETBAR('popDemo',4))
        RETURN
      </code>
    </example>
  </getbar>
  <getenv>
    <summary>
      Returns the contents of the specified MS-DOS environment variable.
    </summary>
    <param name="cVariableName">

      Specifies the name of the environment variable. The empty string is returned if the environment variable you specify doesn't exist.
      You can locate the Windows directory with the WINDIR environmental variable, which Windows sets when it starts.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      Two environment variables are always available: COMSPEC and PATH. You can create your own environment variables with the command shell SET command.
      For additional information on creating environment variables, see the Windows product documentation.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? GETENV('PATH')  &amp;&amp; Displays the search path
      </code>
    </example>
  </getenv>
  <getinterface>
    <summary>
      Provides access to COM object properties, methods, and events through early binding.
    </summary>
    <param name="oObject">

      Specifies the target COM object.

    </param>
    <param name="cIID">

      Specifies the GUID of the target interface of oObject. cIID can be an interface such as "IContextState" or it can be a GUID, such as "{94631BEC-EE81-479A-AE64-A6CFC37B4799}". If it's "IDispatch", then GetInterface() returns an IDispatch (late-bound) reference to the object. If cIID is not specified, then GetInterface() will return the early binding interface for the object.

    </param>
    <param name="cInterface">

      Specifies the interface name.

    </param>
    <param name="cTypelib">

      Specifies the name of the type library containing the oObject class.

    </param>
    <param name="cProgID">

      Specifies the name of the program to be used to lookup the type library.
      COM Object Interface reference
    </param>
    <remarks>
      GetInterface( ) applies only to COM objects. If you use native X# objects, GetInterface( ) generates an error. GetInterface( ) returns an early-bound Object reference.
      When a DLL is built on a Windows 95, Windows 98, or Windows Me platform, X# does not include the type library inside the DLL. When you use GETINTERFACE( ) and refer to a DLL built on one of these platforms, you must use the Type Library name instead of the DLL name as in the following code:
       <code language="X#">oX = GETINTERFACE(x, "Imyclass", "myclass1.TLB")</code>
      You can use the following code for a DLL built on Windows XP, Windows 2000, or Windows NT:
       <code language="X#">oX = GETINTERFACE(x, "Imyclass", "myclass1.DLL")</code>
    </remarks>
    <example>
       <code language="X#">
        LOCAL oMTX, oContext, oContextState
        LOCAL lTxnState, lGetTxnState, lDone, lGetDone
        lGetDone = .F.     &amp;&amp; initialize setting
        lGetTxnState = 0  &amp;&amp; initialize setting
        oMTX = CREATEOBJECT("MTXAS.APPSERVER.1")
        oContext = oMTX.GetObjectContext()
        oContextState = GetInterface(oContext,"IContextState")
        * Handle activation setting (Doneness)
        * Values: .T. - Deactivate, .F. - Leave activated
        lDone = .T.
        oContextState.SetDeactivateOnReturn(lDone)
        oContextState.GetDeactivateOnReturn(@lGetDone)

        * Handle transaction setting (Consistency)
        * Values: 0 - commit, 1 - abort
        lTxnState = 1
        oContextState.SetMyTransactionVote(lTxnState)
        oContextState.GetMyTransactionVote(@lGetTxnState)
      </code>
    </example>
  </getinterface>
  <getpad>
    <summary>
      Returns the menu title for a given position on the menu bar.
    </summary>
    <param name="cMenuBarName">

      Specifies the menu bar name.

    </param>
    <param name="nMenuBarPosition">

      Specifies a position on the menu bar. nMenuPosition can range from 1 (the leftmost menu title on the menu bar) through the number of menu titles on the menu bar.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      Menu names on a titles bar can be added, removed, or rearranged. Use DEFINE PAD to add a menu name to a title bar or RELEASE PAD to remove a menu title.
    </remarks>
    <example>
       <code language="X#">
        FOR gnCount = 1 TO CNTPAD('_msysmenu')      &amp;&amp; Number of pads
        IF PRMPAD('_msysmenu', GETPAD('_msysmenu', gnCount)) = 'Edit'
        RELEASE PAD (GETPAD('_msysmenu', gnCount)) OF _msysmenu
        EXIT
        ENDIF
        ENDFOR
      </code>
    </example>
  </getpad>
  <getpem>
    <summary>
      Returns the current value for a property or program code for an event or method at design time.
    </summary>
    <param name="oObjectName">

      Specifies the object for which a property value or event or method program code is returned. oObjectName can be any expression that evaluates to an object, such as an object reference, an object memory variable, or an object array element.

    </param>
    <param name="cClassName">

      Specifies the class for which a property value or event or method program code is returned.

    </param>
    <param name="cProperty">

      Specifies the property whose value is returned.

    </param>
    <param name="cEvent">

      Specifies the event for which program code is returned.

    </param>
    <param name="cMethod">

      Specifies the method for which program code is returned.
    </param>
    <returns>
      Character, Currency, Date, DateTime, Numeric, or Logical
    </returns>
    <remarks>
      In X# 6.0 and later, using <b>GETPEM( )</b> to return method code is supported only during an interactive X# session. You can, however, obtain method code from an object by using its Class property, as in the following code:
       <code language="X#">
        LOCAL oObject, lcCode
        oObject = NEWOBJECT("_form", HOME()+"ffc\_base.vcx")
        lcCode = GETPEM(oObject.class, "Release")
      </code>
    </remarks>
  </getpem>
  <header>
    <summary>
      Returns the number of bytes in the header of the current or specified table file.
    </summary>
    <returns>
      Numeric
    </returns>
    <remarks>
      A table header contains information about the table itself, such as the field names and sizes and the presence of a memo file or structural index.
    </remarks>
  </header>
  <home>
    <summary>
      Returns the names of the X# and Visual Studio directories.
    </summary>
    <param name="nLocation">

      Specifies that <b>HOME( )</b> returns the name of a specific X# or Visual Studio directory. Omitting nLocation is identical to HOME(0).
      The following table lists the values for nLocation and the directory that <b>HOME( )</b> returns. The directories listed below assume that you chose the default installation directory when you installed X# or Visual Studio.
      0 or omitted
      The directory from which X# was started
      1
      The directory in which X# is installed
      2
      The directory containing the X# samples. This directory is identical to the samples directory in the _SAMPLES system variable.
      Visual Studio Common directory
      X# Graphics directory
      5
      Visual Studio MSDN directory
      Visual Studio Tools directory
      7
      X# subdirectory in the user's X# Application Data directory
      X# Projects subdirectory in the user's X# My Documents directory. This directory is the default location for new projects and files created by X#.
    </param>
    <returns>
      Character data type. <b>HOME( )</b> returns the names of specific X# and Visual Studio directories.
    </returns>
    <example>
       <code language="X#">
        CLEAR
        ? 'X# startup directory:           ', HOME( )
        ? 'X# installation directory:      ', HOME(1)
        ? 'X# samples directory:           ', HOME(2)
        ? 'Visual Studio common directory:            ', HOME(3)
        ? 'X# graphics directory:          ', HOME(4)
        ? 'MSDN samples directory:                    ', HOME(5)
        ? 'Visual Studio tools directory:             ', HOME(6)
        ? 'X# user app data subdirectory:  ', HOME(7)
        ? 'X# user documents subdirectory: ', HOME(8)
      </code>
    </example>
  </home>
  <iif>
    <summary>
      Returns one of two values depending on the value of a logical expression.
    </summary>
    <param name="lExpression">

      Specifies the logical expression that <b>IIF( )</b> evaluates.

      eExpression1, eExpression2
      If lExpression evaluates to True (.T.), eExpression1 is returned and eExpression2 is not evaluated. If lExpression evaluates to False (.F.) or null (.NULL.), eExpression2 is returned and eExpression1 is not evaluated.
    </param>
    <returns>
      Character, Numeric, Currency, Date, or DateTime
    </returns>
    <remarks>
      This function, also known as Immediate <b>IF</b>, evaluates a logical expression and then returns one of two expressions. If the logical expression evaluates to True (.T.), <b>IIF( )</b> returns the first expression. If the logical expression evaluates to False (.F.) or null (.NULL.), <b>IIF( )</b> returns the second expression.
      This function can be used in place of <b>IF ... ENDIF</b> for simple conditional expressions, and is especially useful in report and label expressions that conditionally specify field contents. The <b>IIF( )</b> function also executes faster than an equivalent <b>IF ... ENDIF</b>.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE employee  &amp;&amp; Open Employee table
        CLEAR
        SCAN
        ? IIF(EMPTY(notes), 'No notes', notes)    &amp;&amp; Empty memo field?
        ENDSCAN
      </code>
    </example>
  </iif>
  <inkey>
    <summary>
      Returns a number corresponding to the first mouse click or key press in the type-ahead buffer.
    </summary>
    <param name="nSeconds">

      Specifies the number of seconds to wait for a keystroke. If you do not specify a value for nSeconds, <b>INKEY( )</b> returns a value for a keystroke immediately. If nSeconds is 0, <b>INKEY( )</b> waits indefinitely for a keystroke.

    </param>
    <param name="cHideCursor">

      Shows or hides the cursor, or checks for a mouse click.
      The following table lists values for cHideCursor.
      Show cursor.
      Hide cursor.
      M
      Check for a mouse click.
      E
      Expand the keyboard macro if a keyboard macro is assigned to a key or key combination. To return successive values for each keystroke in a macro, execute <b>INKEY( )</b> repeatedly with E included.
      If both S and H are included in cHideCursor, the latter character specified takes precedence. You can combine values for cHideCursor, for example, to check for a mouse click and show the cursor, include M and S. To check for a mouse click and hide the cursor, include H and M. <b>INKEY( )</b> disregards characters other than S, H, M, and E in cHideCursor.
    </param>
    <returns>
      Numeric. <b>INKEY( )</b> returns 0 if a key has not been pressed. If several keys are present in the type-ahead buffer, <b>INKEY( )</b> returns the value of the first key entered in the buffer. <b>INKEY( )</b> also returns the following values according to certain conditions:
      If M is included for cHideCursor, <b>INKEY( )</b> returns the value 151.
      If E is included, <b>INKEY( )</b> returns a value corresponding to the first keystroke assigned to the keyboard macro. If you omit E, <b>INKEY( )</b> returns the value for the key or key combination that triggers the keyboard macro.
      For single keys and key combinations using the SHIFT, CTRL, and ALT keys, the following table lists the return values for <b>INKEY( )</b>. A dash (–) indicates that the key combination returns no value.
      F1
      28
      84
      94
      104
      F2
      –1
      85
      95
      105
      F3
      –2
      86
      96
      106
      F4
      –3
      87
      97
      107
      F5
      –4
      88
      98
      108
      F6
      –5
      89
      99
      109
      F7
      –6
      90
      100
      110
      F8
      –7
      91
      101
      111
      F9
      –8
      92
      102
      112
      F10
      –9
      93
      103
      113
      F11
      133
      135
      137
      139
      F12
      134
      136
      138
      140
      1
      49
      33
      –
      120
      2
      50
      64
      –
      121
      3
      51
      35
      –
      122
      4
      52
      36
      –
      123
      5
      53
      37
      –
      124
      6
      54
      94
      –
      125
      7
      55
      38
      –
      126
      8
      56
      42
      –
      127
      9
      57
      40
      –
      128
      0
      48
      41
      –
      19
      a
      97
      65
      1
      30
      b
      98
      66
      2
      48
      c
      99
      67
      3
      46
      d
      100
      68
      4
      32
      e
      101
      69
      5
      18
      f
      102
      70
      6
      33
      g
      103
      71
      7
      34
      h
      104
      72
      127
      35
      I
      105
      73
      9
      23
      j
      106
      74
      10
      36
      k
      107
      75
      11
      37
      l
      108
      76
      12
      38
      m
      109
      77
      13
      50
      n
      110
      78
      14
      49
      o
      111
      79
      15
      24
      p
      112
      80
      16
      25
      q
      113
      81
      17
      16
      r
      114
      82
      18
      19
      s
      115
      83
      19
      31
      t
      116
      84
      20
      20
      u
      117
      85
      21
      22
      v
      118
      86
      22
      47
      w
      119
      87
      23
      17
      x
      120
      88
      24
      45
      y
      121
      89
      25
      21
      z
      122
      90
      26
      44
      INS
      22
      22
      146
      162
      HOME
      1
      55
      29
      151
      DEL
      7
      7
      147
      163
      END
      6
      49
      23
      159
      PAGE UP
      18
      57
      31
      153
      PAGE DOWN
      3
      51
      30
      161
      UP ARROW
      5
      56
      141
      152
      DOWN ARROW
      24
      50
      145
      160
      RIGHT ARROW
      4
      54
      2
      157
      LEFT ARROW
      19
      52
      26
      155
      ESC
      27
      –/27
      –*/27
      –*/1
      ENTER
      13
      13
      10
      –/166
      BACKSPACE
      127
      127
      127
      14
      TAB
      9
      15
      148/*
      *
      SPACEBAR
      32
      32
      32/–
      57
      ` or ~
      96
      126
       
      41
      - or _
      45
      95
       
       
      = or +
      61
      43
       
      13
      [ or {
      91
      123
      27
      26
      ] or }
      93
      125
      29
      27
      \ or |
      92
      124
      28
      43
      ; or :
      59
      58
       
      39
      ' or "
      39
      34
       
      40
      , or &lt;
      44
      60
       
      51
      . or &gt;
      46
      62
       
      52
      / or ?
      47
      63
       
      53
      * Keystroke reserved by Windows.
    </returns>
  </inkey>
  <inlist>
    <summary>
      Determines whether an expression matches another expression in a set of expressions.
    </summary>
    <param name="eExpression1">

      Specifies the expression INLIST( ) searches for in the set of expressions.

      eExpression2[, eExpression3...]
      Specifies the set of expressions to search. You must include at least one expression (eExpression2), and can include up to 25 expressions (eExpression2, eExpression3, and so on).
      All the expressions in the set of expressions must be of the same data type.
    </param>
    <returns>
      Logical or null value
    </returns>
    <remarks>
      INLIST( ) returns true (.T.) if it finds the expression in the set of expressions; otherwise INLIST( ) returns false (.F.). The null value is returned if eExpression1 is the null value. The null value is also returned if eExpression1 is not the null value, eExpression1 does not match another expression, and at least one of the other expressions is the null value.
    </remarks>
    <example>
       <code language="X#">
        SET TALK ON
        STORE CMONTH(DATE( )) TO gcMonth
        DO CASE
        CASE INLIST(gcMonth,'January','February','March')
        STORE 'First Quarter' TO gcReporTitle
        CASE INLIST(gcMonth,'April','May','June')
        STORE 'Second Quarter' TO gcReporTitle
        CASE INLIST(gcMonth,'July','August','September')
        STORE 'Third Quarter' TO gcReporTitle
        OTHERWISE
        STORE 'Fourth Quarter' TO gcReporTitle
        ENDCASE
        WAIT WINDOW gcReporTitle
      </code>
    </example>
  </inlist>
  <int>
    <summary>
      Evaluates a numeric expression and returns the integer portion of the expression.
    </summary>
    <param name="nExpression">

      Specifies the numeric expression for which INT( ) returns the integer portion.
    </param>
    <returns>
      Numeric
    </returns>
    <example>
       <code language="X#">
        CLEAR
        ? INT(12.5)  &amp;&amp; Displays 12
        ? INT(6.25 * 2)  &amp;&amp; Displays 12
        ? INT(-12.5)  &amp;&amp; Displays -12
        STORE -12.5 TO gnNumber
        ? INT(gnNumber)  &amp;&amp; Displays -12
      </code>
    </example>
  </int>
  <isalpha>
    <summary>
      Determines whether the leftmost character in a character expression is alphabetic.
    </summary>
    <param name="cExpression">

      Specifies the character expression that ISALPHA( ) evaluates. Any characters after the first character in cExpression are ignored.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      ISALPHA( ) returns true (.T.) if the leftmost character in the specified character expression is an alphabetic character; otherwise ISALPHA( ) returns false (.F.).
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE Customer     &amp;&amp; Open customer table
        CLEAR
        DISPLAY contact
        ? ISALPHA(contact)  &amp;&amp; Displays .T.
        DISPLAY maxordamt
        ? ISALPHA(cust_id)  &amp;&amp; Displays .F.
      </code>
    </example>
  </isalpha>
  <isdigit>
    <summary>
      Determines whether the leftmost character of the specified character expression is a digit (0 through 9).
    </summary>
    <param name="cExpression">

      Specifies the character expression that ISDIGIT( ) tests. Any characters after the first character in cExpression are ignored.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      ISDIGIT( ) returns true (.T.) if the leftmost character of the specified character expression is a digit (0 through 9); otherwise, ISDIGIT( ) returns false (.F.).
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE orders  &amp;&amp; Open Orders table
        CLEAR
        DISPLAY cust_id
        ? ISDIGIT(cust_id)  &amp;&amp; Displays .F.
        DISPLAY order_dsc
        ? ISDIGIT(ALLTRIM(STR(order_dsc)))  &amp;&amp; Displays .T.
      </code>
    </example>
  </isdigit>
  <isleadbyte>
    <summary>
      Returns true (.T.) if the first byte of the first character in a character expression is the lead byte of a double-byte character.
    </summary>
    <param name="cExpression">

      Specifies the character expression that ISLEADBYTE( ) evaluates. Any bytes after the first byte in the first character in cExpression are ignored.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      ISLEADBYTE( ) returns true (.T.) if the first byte of the first character in a character expression is the lead byte in a double-byte character. If ISLEADBYTE( ) returns false (.F.), the character being tested is a single-byte character.
      This function is useful for manipulating double-byte character sets for languages such as Hiragana and Katakana.
    </remarks>
  </isleadbyte>
  <islower>
    <summary>
      Determines whether the leftmost character of the specified character expression is a lowercase alphabetic character.
    </summary>
    <param name="cExpression">

      Specifies the character expression that ISLOWER( ) tests. ISLOWER( ) ignores any characters after the first character in cExpression.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      ISLOWER( ) returns true (.T.) if the leftmost character in the specified character expression is a lowercase alphabetic character; otherwise, ISLOWER( ) returns false (.F.).
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? ISLOWER('redmond')  &amp;&amp; Displays .T.
        ? ISLOWER('Redmond')  &amp;&amp; Displays .F.
      </code>
    </example>
  </islower>
  <lastkey>
    <summary>
      Returns an integer corresponding to the last key pressed.
    </summary>
    <returns>
      LASTKEY( )Return Value
      Numeric
    </returns>
    <remarks>
      The values returned by <b>LASTKEY( )</b> are the same as the values returned by <b>INKEY( )</b>. See INKEY( ) for a list of keys and their return values.

      <b>LASTKEY( )</b> is updated when you move between controls.
    </remarks>
  </lastkey>
  <left>
    <summary>
      Returns a specified number of characters from a character expression, starting with the leftmost character.
    </summary>
    <param name="cExpression">

      Specifies the character expression that <b>LEFT( )</b> returns characters from.

    </param>
    <param name="nExpression">

      Specifies the number of characters returned from the character expression. If nExpression is greater than the length of cExpression, all of the character expression is returned. If nExpression is negative or 0, <b>LEFT( )</b> returns an empty string.
      <b>LEFT( )</b> uses a starting position of 1 and is identical to <b>SUBSTR( )</b>.
    </param>
    <returns>
      Character. <b>LEFT( )</b> returns a character string.
    </returns>
    <example>
       <code language="X#">
        ? LEFT('Redmond, WA', 4)          &amp;&amp; Displays the string, Redm.
        myString = LEFT('Redmond, WA', 4) &amp;&amp; Stores result in myString.
        ? myString                        &amp;&amp; Displays result in myString.
      </code>
    </example>
  </left>
  <len>
    <summary>
      Determines the number of characters in a character expression, indicating the length of the expression.
    </summary>
    <param name="cExpression">

      Specifies the character expression for which <b>LEN( )</b> returns the number of characters.
    </param>
    <returns>
      Numeric. <b>LEN( )</b> returns the number of characters in a character expression.
    </returns>
    <example>
       <code language="X#">
        CLEAR
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE Customer
        ? 'Width of contact field: '
        ?? LEN(contact)
        ? 'Width of cust_id field: '
        ?? LEN(cust_id)
      </code>
    </example>
  </len>
  <like>
    <summary>
      Determines if a character expression matches another character expression.
    </summary>
    <param name="cExpression1">

      Specifies the character expression that <b>LIKE( )</b> compares with cExpression2. cExpression1 can contain the wildcards such as * and ?. The question mark (?) matches any single character in cExpression2 and the asterisk (*) matches any number of characters. You can mix any number of wildcards in any combination in cExpression1.

    </param>
    <param name="cExpression2">

      Specifies the character expression <b>LIKE( )</b> compares with cExpression1. cExpression2 must match cExpression1 letter for letter in order for <b>LIKE( )</b> to return true (.T.).
    </param>
    <returns>
      Logical
    </returns>
    <remarks>

      <b>LIKE( )</b> returns true (.T.) if cExpression1 matches cExpression2; otherwise, it returns false (.F.).

      <b>SET COMPATIBLE</b> determines how <b>LIKE( )</b> evaluates cExpression1 and cExpression2. If <b>SET COMPATIBLE</b> is set to ON or DB4, cExpression1 and cExpression2 have all trailing blanks removed before they are compared. If <b>SET COMPATIBLE</b> is set to OFF or FOXPLUS, any trailing blanks in cExpression1 and cExpression2 are used in the comparison.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE products  &amp;&amp; Open Products table
        CLEAR
        ? 'All product names with first two letters Ch:'
        ?
        SCAN FOR LIKE('Ch*', prod_name)
        ? prod_name
        ENDSCAN
        USE
      </code>
    </example>
  </like>
  <log>
    <summary>
      Returns the natural logarithm (base e) of the specified numeric expression.
    </summary>
    <param name="nExpression">

      Specifies the numeric expression for which LOG( ) returns the value of x in the equation e^x = nExpression. nExpression must be greater than 0.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The base for the natural logarithm is the constant e. The number of decimal places returned in the result is specified with SET DECIMALS.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? LOG(1)  &amp;&amp; Displays 0.00
        STORE EXP(2) TO gneSquare
        ? LOG(gneSquare)  &amp;&amp; Displays 2.00
      </code>
    </example>
  </log>
  <log10>
    <summary>
      Returns the common logarithm (base 10) of the specified numeric expression.
    </summary>
    <param name="nExpression">

      Specifies the numeric expression for which LOG10( ) returns the value of x in the equation 10^x = nExpression. nExpression must be greater than 0.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The base for the common logarithm is 10. The number of decimal places returned in the result is specified with SET DECIMALS.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? LOG10(10)  &amp;&amp; Displays 1.00
        STORE 100 TO gnBaseTen
        ? LOG10(gnBaseTen)  &amp;&amp; Displays 2.00
        ? LOG10(gnBaseTen^2)  &amp;&amp; Displays 4.00
      </code>
    </example>
  </log10>
  <lower>
    <summary>
      Returns a specified character expression in lowercase letters.
    </summary>
    <param name="cExpression">

      Specifies the character expression LOWER( ) converts.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      LOWER( ) converts all uppercase letters (A – Z) in the character expression to lowercase (a – z). All other characters in the character expression remain unchanged.
    </remarks>
    <example>
       <code language="X#">
        STORE 'FOX' TO gcName
        CLEAR
        ? LOWER(gcName)  &amp;&amp; Displays fox
      </code>
    </example>
  </lower>
  <ltrim>
    <summary>
      Removes all leading spaces or parsing characters from the specified character expression, or all leading zero (0) bytes from the specified binary expression.
    </summary>
    <param name="Expression">

      Specifies an expression of <b>Character</b> or <b>Varbinary</b> type to remove leading spaces or 0 bytes from, respectively.

    </param>
    <param name="nFlags">

      Specifies if trimming is case-sensitive when one or more parse characters (cParseChar, cParseChar2, … are included. Trimming is case-sensitive if nFlags is zero or is omitted. Trimming is case-insensitive if nFlags 1.

      cParseChar [, cParseChar2 [, ...]]
      Specifies one or more character strings that are trimmed from the beginning of cExpression. If cParseChar isn't included, then leading spaces or 0 bytes are removed from Expression.
      <b>Note</b>   The maximum number of strings permitted in cParseChar is 23.
    </param>
    <returns>
      Character or Varbinary. <b>LTRIM( ) </b>returns the specified expression without leading spaces or parsing characters, or 0 bytes.
    </returns>
    <remarks>

      <b>LTRIM( ) </b>is particularly useful for removing the leading spaces that are inserted when you use the <b>STR( )</b> function to convert a <b>Numeric</b> value to a <b>Character</b> string.
    </remarks>
    <example>
       <code language="X#">
        STORE 'Redmond' TO gcCity
        STORE '   Washington' TO gcState
        CLEAR
        ? gcCity, gcState  &amp;&amp; Displays Redmond   Washington
        ? gcCity, LTRIM(gcState)  &amp;&amp; Displays Redmond Washington
      </code>
    </example>
  </ltrim>
  <lupdate>
    <summary>
      Returns the date on which a table was last updated.
    </summary>
    <returns>
      Date
    </returns>
    <remarks>
      This function is useful in update procedures.
      LUPDATE( ) queries Windows to determine the date a table was last updated. However, the last two digits of the year the table was last updated are stored the table header.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'data\testdata')
        USE customer  &amp;&amp; Open Customer table
        CLEAR
        ? LUPDATE( )  &amp;&amp; Displays date of last update
      </code>
    </example>
  </lupdate>
  <max>
    <summary>
      Evaluates a set of expressions and returns the expression with the maximum value.
    </summary>
    <returns>
      Character, Numeric, Currency, Double, Float, Date, or DateTime
    </returns>
    <example>
       <code language="X#">
        CLOSE DATABASES
        CREATE TABLE Random (cValue N(3))
        FOR nItem = 1 TO 10  &amp;&amp; Append 10 records,
        APPEND BLANK
        REPLACE cValue WITH 1 + 100 * RAND( )  &amp;&amp; Insert random values
        ENDFOR
        CLEAR
        LIST  &amp;&amp; Display the values
        gnMaximum = 1  &amp;&amp; Initialize minimum value
        gnMinimum = 100  &amp;&amp; Initialize maximum value
        SCAN
        gnMinimum = MIN(gnMinimum, cValue)
        gnMaximum = MAX(gnMaximum, cValue)
        ENDSCAN
        ? 'The minimum value is: ', gnMinimum  &amp;&amp; Display minimum value
        ? 'The maximum value is: ', gnMaximum  &amp;&amp; Display maximum value
      </code>
    </example>
  </max>
  <mcol>
    <summary>
      Returns the column position of the mouse pointer in the main X# window or a user-defined window or form.
    </summary>
    <param name="cWindowName">

      Specifies the name of the window or form whose mouse-pointer column position <b>MCOL( )</b> returns.

    </param>
    <param name="0">

      Specifies that the column position of the mouse pointer is returned for the currently active window or form.

    </param>
    <param name="nScaleMode">

      Specifies the unit of measurement for the value <b>MCOL( )</b> returns. The following table lists the settings for nScaleMode.
      0
      Foxels. A foxel is equivalent to the average height and width of a character based on the current font of the form in which an object is contained. (Default)
      3
      Pixels. A pixel is the smallest element that can be displayed on a screen or printer. Pixels are screen-dependent.
    </param>
    <returns>
      Numeric. <b>MCOL( )</b> returns the column position of the mouse pointer in the main X# window, user-defined window, or form.
      If you omit cWindowName, and there is no active user-defined window or form, <b>MCOL( )</b> returns the mouse pointer's column position in the main X# window. If you omit cWindowName, and there is an active user-defined window or form, <b>MCOL( )</b> returns the mouse pointer's column position in the active user-defined window or form. <b>MCOL(</b> <b>)</b> returns –1 if the mouse pointer is positioned outside the user-defined window or form, if no mouse driver is loaded, or there is no output window.
    </returns>
    <remarks>
      Using the <b>MCOL( )</b> function without the optional argument 0 may affect the behavior of code on forms when the <b>Form</b> <b>AllowOutput</b> property IS set to false (.F.). For example, the placement of a shortcut menu that is defined in the <b>RightClick</b> event may not display in the proper location if you use the <b>MCOL( )</b> and <b>MROW( )</b> functions to determine where the menu is displayed. In this case, be sure to include 0 in the <b>MCOL( )</b> and <b>MROW( )</b> functions.
    </remarks>
  </mcol>
  <mdown>
    <summary>
      Included for backward compatibility. Use the Click, MouseDown, MouseUp, and RightClick events instead.
       
      Determines whether or not the mouse button is pressed.
    </summary>
    <returns>
      Return value - Logical
    </returns>
    <remarks>
      <br />
      MDOWN() returns a true (.T.) or false (.F.) value depending on whether or not the mouse button is pressed. <br />
      <br />
      In FoxPro for MS-DOS and FoxPro for Windows, MDOWN() returns values for just the left mouse button.<br />
      <br />
      If the mouse button is depressed when MDOWN() is executed, true (.T.) is returned. If the mouse button isn't depressed when MDOWN() is executed, false (.F.) is returned.<br />
      <br />

    </remarks>
  </mdown>
  <memlines>
    <summary>
      Returns the number of lines in a memo field.
    </summary>
    <param name="MemoFieldName">

      Specifies the name of the memo field. If the memo field is in a table that isn't open in the current work area, preface the memo field name with the table alias and a period.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The number of lines in a memo field is determined by the current value of SET MEMOWIDTH.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        CLEAR
        SET TALK OFF
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE employee  &amp;&amp; Open Employee table
        SET MEMOWIDTH TO 65
        gnLine = 1
        GOTO 2
        SCAN NEXT 3
        gnMemoSize = MEMLINES(notes)
        IF gnMemoSize = 0
        STORE .T. TO glNoMemo
        STORE 1 TO gnMemoSize
        ELSE
        STORE .F. TO glNoMemo
        ENDIF
        IF gnLine + gnMemoSize &gt; 65
        EJECT
        gnLine = 1
        ENDIF
        @ gnLine,2 SAY 'Last Name: '+ last_name
        gnLine = gnLine +1
        @ gnLine ,2 SAY 'Notes: '
        ?? IIF(glNoMemo, 'No notes ',notes)
        gnLine = gnLine + gnMemoSize + 2
        IF gnLine &gt; 24
        gnLine = 1
        CLEAR
        ENDIF
        ENDSCAN
      </code>
    </example>
  </memlines>
  <memory>
    <summary>
      Returns the amount of memory available to run an external program.
    </summary>
    <returns>
      MEMORY( )Return Value
      Numeric
    </returns>
    <remarks>
      In X#, MEMORY( ) always returns 640.
      MEMORY( ) is similar to SYS(12), with two exceptions:

      MEMORY( ) returns the amount of available memory in kilobytes; SYS(12) returns the amount of memory in bytes.
      MEMORY( ) returns a numeric expression. SYS(12) returns its value as a character string.
    </remarks>
  </memory>
  <menu>
    <summary>
      Returns the name of the active menu bar as an uppercase character string.
    </summary>
    <returns>
      MENU( )Return Value
      Character
    </returns>
    <remarks>
      MENU( ) returns an empty string if no menu is active. Use the Menu Designer to create a menu and activate it.
    </remarks>
    <example>
       <code language="X#">
        *** Save this program as MENUEXAM.PRG in the default VFP directory.***
        CLEAR
        SET SYSMENU SAVE
        SET SYSMENU TO
        DEFINE PAD padSys OF _MSYSMENU PROMPT '\&lt;System' COLOR SCHEME 3 ;
        KEY ALT+S, ''
        DEFINE PAD padEdit OF _MSYSMENU PROMPT '\&lt;Edit' COLOR SCHEME 3 ;
        KEY ALT+E, ''
        DEFINE PAD padRecord OF _MSYSMENU PROMPT '\&lt;Record' COLOR SCHEME 3 ;
        KEY ALT+R, ''
        DEFINE PAD padWindow OF _MSYSMENU PROMPT '\&lt;Window' COLOR SCHEME 3 ;
        KEY ALT+W, ''
        DEFINE PAD padReport OF _MSYSMENU PROMPT 'Re\&lt;ports' COLOR SCHEME 3 KEY ALT+P, ''
        DEFINE PAD padExit OF _MSYSMENU PROMPT 'E\&lt;xit' COLOR SCHEME 3 ;
        KEY ALT+X, ''
        ON SELECTION MENU _MSYSMENU ;
        DO choice IN menuexam WITH PAD(), MENU()
        PROCEDURE choice
        PARAMETER gcPad, gcMenu
        WAIT WINDOW 'You chose ' + gcPad + ;
        ' from menu ' + gcMenu NOWAIT
        IF gcPad = 'PADEXIT'
        SET SYSMENU TO DEFAULT
        ENDIF
      </code>
    </example>
  </menu>
  <message>
    <summary>
      Returns the current error message or the program line that caused the error.
    </summary>
    <returns>
      Character. <b>MESSAGE( )</b> returns the current error message as a character string or the contents of the program line causing the error.
    </returns>
    <remarks>
      Unlike <b>ERROR( )</b>, <b>MESSAGE( )</b> is not reset by <b>RETURN</b> or <b>RETRY</b>.
    </remarks>
    <example>
       <code language="X#">
        ON ERROR DO Errhand
        *** The next line should generate an error ***
        USE Nodatabase
        ON ERROR     &amp;&amp; Restore system error handler.
        PROCEDURE Errhand
        ? 'Line of code with error: ' + MESSAGE(1)
        ? 'Error number: ' + STR(ERROR( ))
        ? 'Error message: ' + MESSAGE( )
      </code>
    </example>
  </message>
  <min>
    <summary>
      Evaluates a set of expressions and returns the expression with the minimum value.
    </summary>
    <returns>
      Character, Numeric, Currency, Double, Float, Date, or DateTime
    </returns>
    <example>
       <code language="X#">
        CLOSE DATABASES
        CREATE TABLE Random (cValue N(3))
        FOR nItem = 1 TO 10  &amp;&amp; Append 10 records,
        APPEND BLANK
        REPLACE cValue WITH 1 + 100 * RAND( )  &amp;&amp; Insert random values
        ENDFOR
        CLEAR
        LIST  &amp;&amp; Display the values
        gnMaximum = 1  &amp;&amp; Initialize minimum value
        gnMinimum = 100  &amp;&amp; Initialize maximum value
        SCAN
        gnMinimum = MIN(gnMinimum, cValue)
        gnMaximum = MAX(gnMaximum, cValue)
        ENDSCAN
        ? 'The minimum value is: ', gnMinimum  &amp;&amp; Display minimum value
        ? 'The maximum value is: ', gnMaximum  &amp;&amp; Display maximum value
      </code>
    </example>
  </min>
  <mline>
    <summary>
      Returns a specific line from a <b>Memo</b> field as a character string.
      <b>MLINE( )</b> is primarily a text processing function; therefore, the results from processing binary values might not be as expected. For example, <b>MLINE( )</b> might return different results depending on the <b>SET MEMOWIDTH</b> setting. <b>MLINE( )</b> might interpret binary values as line breaks or truncate binary values unexpectedly. It is recommended that you use the <b>ALINES( )</b> function instead to manipulate binary values.
    </summary>
    <param name="MemoFieldName">

      Specifies the name of the memo field from which <b>MLINE( )</b> returns a line. If the memo field is in a table open in a non-current work area, preface the memo field name with a period and the table alias.

    </param>
    <param name="nLineNumber">

      Specifies the number of the line to return from the memo field. If nLineNumber is negative, 0, or greater than the number of lines in the memo field, <b>MLINE( )</b> returns an empty string.
      <b>MLINE( )</b> trims any trailing spaces from the line specified with nLineNumber.

    </param>
    <param name="nNumberOfCharacters">

      Specifies the number of characters from the beginning of the memo field after which <b>MLINE( )</b> returns the specified line.
      The <b>_MLINE </b>system variable is typically used for nNumberOfCharacters. <b>_MLINE</b> is automatically adjusted each time <b>MLINE( )</b> is called. In recursive procedures that return lines from large memo fields, you can obtain the best performance by including <b>_MLINE</b> as nNumberOfCharacters. For more information, see _MLINE System Variable.
    </param>
    <returns>

      <b>Character</b> or <b>Varbinary</b>. <b>MLINE( )</b> returns a character string from a specific line in a <b>Memo</b> field. When using <b>MLINE( )</b> with binary values, such as <b>Varbinary</b> and <b>Blob</b>, the return value has type <b>Varbinary</b>.
    </returns>
    <remarks>
      The length and number of the lines in a memo field are determined by the current value of <b>SET MEMOWIDTH</b> (the default line length is 50 characters). If a carriage return is encountered, no additional characters are returned. The current _WRAP setting determines how the memo field line is displayed.
      When searching a memo field for a character string, you can use <b>ATLINE( )</b> or <b>ATCLINE( )</b> to return the line number of the line in which the character string is found. Use this line number in <b>MLINE( )</b> to return the contents of the line from the memo field.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        SET TALK OFF
        SET MEMOWIDTH TO 50
        CLOSE DATABASES
        CREATE TABLE tmemo (name c(10), notes m)
        APPEND BLANK                  &amp;&amp; Add a record
        WAIT WINDOW 'Filling memo field - takes several seconds' NOWAIT
        *** Fill the memo field  ***
        FOR gnOuterLoop = 1 TO 5         &amp;&amp; loop 5 times
        FOR gnAlphabet = 65 TO 75   &amp;&amp; letters A to H
        REPLACE notes WITH REPLICATE(CHR(gnAlphabet), 10) ;
        + CHR(13) ADDITIVE
        NEXT
        NEXT
        *** Display all lines from the memo field ***
        STORE MEMLINES(notes) TO gnNumLines   &amp;&amp; Number of lines in memo field
        STORE SECONDS( ) TO gnBegin      &amp;&amp; Beginning time
        FOR gnCount = 1 TO gnNumLines   &amp;&amp; Loop for # of lines in memo field
        ? <b>MLINE(</b>notes, gnCount<b>)</b>      &amp;&amp; Display each line
        NEXT
        ? STR(SECONDS( ) - gnBegin, 4, 2) + ' seconds'   &amp;&amp; Total time
        *** Preferable method using _MLINE in MLINE( ) ***
        *** Display all lines from the memo field ***
        WAIT 'Press a key to see the preferred method' WINDOW
        CLEAR
        STORE 0 TO _MLINE             &amp;&amp; Reset _MLINE to zero
        STORE SECONDS( ) TO gnBegin      &amp;&amp; Beginning time
        FOR count = 1 TO gnNumLines      &amp;&amp; Loop for # of lines in memo field
        ? <b>MLINE(</b>notes, 1, _MLINE<b>)</b>      &amp;&amp; Display each line
        NEXT
        ? STR(SECONDS( ) - gnBegin, 4, 2) + ' seconds'   &amp;&amp; Total time
        SET TALK ON
        CLOSE DATABASES
        ERASE tmemo.dbf
        ERASE tmemo.fpt
      </code>
    </example>
  </mline>
  <mod>
    <summary>
      Divides one numeric expression by another numeric expression and returns the remainder.
    </summary>
    <param name="nDividend">

      Specifies the dividend. The number of decimal places in nDividend determines the number of decimal places in the return value.

    </param>
    <param name="nDivisor">

      Specifies the divisor. A positive number is returned if nDivisor is positive, and a negative number is returned if nDivisor is negative.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The modulus function MOD( ) and the % operator return identical results.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? MOD(36,10)  &amp;&amp; Displays 6
        ? MOD((4*9), (90/9))  &amp;&amp; Displays 6
        ? MOD(25.250,5.0)  &amp;&amp; Displays 0.250
        ? IIF(MOD(YEAR(DATE( )), 4) = 0, 'Summer Olympics this year';
        , 'No Summer Olympics this year')
      </code>
    </example>
  </mod>
  <month>
    <summary>
      Returns the number of the month for a given Date or DateTime expression.
    </summary>
    <param name="dExpression">

      Specifies the Date expression for which you want MONTH( ) to return the month number.

    </param>
    <param name="tExpression">

      Specifies the DateTime expression for which you want MONTH( ) to return the month number.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      MONTH( ) returns a number from 1 through 12. January is month 1, and December is month 12.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? DATE( )  &amp;&amp; Displays today's date
        ? MONTH(DATE( ))  &amp;&amp; Displays the month number
        STORE {^1998-05-03} TO gdBuy
        STORE MONTH(gdBuy + 31) TO gdMonth
        ? gdMonth  &amp;&amp; Displays 6
      </code>
    </example>
  </month>
  <mrkbar>
    <summary>
      Determines whether a menu item on a user-defined or X# system menu is marked.
    </summary>
    <param name="cMenuName">

      Specifies the name of the menu containing the menu item. The menu can be a X# system menu (such as _MFILE, MEDIT, or _MDATA).

    </param>
    <param name="nMenuItemNumber">

      Specifies the number of a menu item in a user-defined menu. A menu item's number is specified when the menu item is created with DEFINE BAR.

    </param>
    <param name="cSystemMenuItemName">

      Specifies the name of a X# system menu item. For example, the following command displays a logical value specifying if the New menu item on the File menu is marked.
       <code language="X#">? MRKBAR('_MFILE', _MFI_NEW)</code>
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      Use SET MARK OF to mark or unmark a menu item.
      If the specified menu item is marked, MRKBAR( ) returns true (.T.); otherwise, MRKBAR( ) returns false (.F.).
      For an example of using MRKBAR( ), see CNTBAR( ).
    </remarks>
  </mrkbar>
  <mrkpad>
    <summary>
      Determines whether a menu title on a user-defined menu bar or on the X# system menu bar is marked.
    </summary>
    <param name="cMenuBarName">

      Specifies the name of the menu bar containing the menu title.

    </param>
    <param name="cMenuTitleName">

      Specifies the name of the menu title.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      Use SET MARK OF to mark or unmark a menu title.
      If the specified menu title is marked, MRKPAD( ) returns true (.T.); otherwise, MRKPAD( ) returns false (.F.).
    </remarks>
    <example>
       <code language="X#">
        *** Name this program MARKPAD.PRG ***
        CLEAR
        SET SYSMENU SAVE
        SET SYSMENU TO
        SET MARK OF MENU _MSYSMENU TO CHR(4)
        PUBLIC glMarkPad
        glMarkPad = .T.
        DEFINE PAD padSys OF _MSYSMENU PROMPT '\&lt;System'  COLOR SCHEME 3 ;
        KEY ALT+S, ''
        DEFINE PAD padEdit OF _MSYSMENU PROMPT '\&lt;Edit'  COLOR SCHEME 3 ;
        KEY ALT+E, ''
        DEFINE PAD padRecord OF _MSYSMENU PROMPT '\&lt;Record'  COLOR SCHEME 3 ;
        KEY ALT+R, ''
        DEFINE PAD padWindow OF _MSYSMENU PROMPT '\&lt;Window'  COLOR SCHEME 3 KEY ALT+W, ''
        DEFINE PAD padReport OF _MSYSMENU PROMPT 'Re\&lt;ports' COLOR SCHEME 3 ;
        KEY ALT+P, ''
        DEFINE PAD padExit OF _MSYSMENU PROMPT 'E\&lt;xit'  COLOR SCHEME 3 ;
        KEY ALT+X, ''
        ON SELECTION MENU _MSYSMENU ;
        DO choice IN markpad WITH PAD( ), MENU( )
        PROCEDURE choice
        PARAMETER gcPad, gcMenu
        WAIT WINDOW 'You chose ' + gcPad + ;
        ' from menu ' + gcMenu NOWAIT
        SET MARK OF PAD (gcPad) OF _MSYSMENU TO ;
        ! MRKPAD('_MSYSMENU', gcPad)
        glMarkPad= ! glMarkPad
        IF gcPad = 'PADEXIT'
        SET SYSMENU TO DEFAULT
        ENDIF
      </code>
    </example>
  </mrkpad>
  <mrow>
    <summary>
      Returns the row position of the mouse pointer in the main X# window or in a user-defined window or form.
    </summary>
    <param name="cWindowName">

      Specifies the name of a window whose mouse-pointer row position <b>MROW( )</b><b> </b>returns.

    </param>
    <param name="0">

      Specifies that the row position of the mouse pointer is returned for the currently active window or form.

    </param>
    <param name="nScaleMode">

      Specifies the unit of measurement for the value <b>MROW( )</b> returns. The settings for nScaleMode are:
      0
      Foxels. (Default)
      A foxel is equivalent to the average height and width of a character based on the current font of the form in which an object is contained.
      3
      Pixels.
      A pixel is the smallest element that can be displayed on a screen or printer. Pixels are screen-dependent.
    </param>
    <returns>
      Numeric. <b>MROW( )</b> returns the following under specific conditions:
      If there is no active user-defined window, and you omit the optional argument, <b>MROW( )</b> returns the main X# window row position of the mouse pointer.
      If there is an active user-defined window, and you omit the optional argument, <b>MROW( )</b> returns the mouse-pointer row coordinate relative to the active user-defined window.
      If the mouse pointer is positioned outside the user-defined window or if no mouse driver is loaded and there is no output window, <b>MROW( )</b> returns a value of -1.
    </returns>
    <remarks>
      Using the <b>MROW( )</b> function without the optional argument 0 may affect the behavior of code on forms when the <b>Form</b> <b>AllowOutput</b> property IS set to false (.F.). For example, the placement of a shortcut menu that is defined in the <b>RightClick</b> event may not display in the proper location if you use the <b>MROW( )</b> and <b>MCOL( )</b> functions to determine where the menu is displayed. In this case, be sure to include 0 in the <b>MROW( )</b> and <b>MCOL( )</b> functions.
    </remarks>
  </mrow>
  <mwindow>
    <summary>
      Returns the name of the window over which the mouse pointer is positioned.
    </summary>
    <param name="cWindowName">

      Specifies a window name. If the mouse pointer is positioned over the specified window, MWINDOW( ) returns true (.T.); otherwise, MWINDOW( ) returns false (.F.).
    </param>
    <returns>
      Character, Logical
    </returns>
    <remarks>
      If you omit the optional window name, MWINDOW( ) returns the name of the window over which the mouse pointer is positioned, or an empty string if the mouse pointer is positioned over the main X# window or over any other window that is not part of X#.
    </remarks>
  </mwindow>
  <objnum>
    <summary>
      Included for backward compatibility. Use the TabIndex Property for controls instead.
      Returns the object number of an @ ... GET control.
    </summary>
    <returns>
      Return value - Numeric
    </returns>
    <remarks>
      <br />
      You can use @ ... GET and @ ...EDIT to create controls, sometimes called objects. These controls are fields, check boxes, lists, popups; invisible, push, and radio buttons; spinners and text-editing regions. OBJNUM() returns a number that corresponds to a control's creation order in a set of controls.<br />
      <br />

    </remarks>
    <example>
      The following example creates a window and places radio buttons in the window so you can move the record pointer through an open table. If a table isn't open, the Open dialog is displayed so you can select a table to open.<br />
      <br />











      <code language="X#">
        SET TALK OFF
        DEFINE WINDOW gotodialog FROM 9, 17 TO 19,61 ;
        FLOAT NOCLOSE SHADOW DOUBLE COLOR SCHEME 5
        PRIVATE file,lastobj,enter,tab,shifttab,up,down,left,right
        *** Assign lastkey values ***
        enter		= 13
        tab			= 9
        shifttab	= 15
        up			= 5
        down		= 24
        right		= 4
        left		= 19
        lastobj	= 1
        *** Open a table ***
        IF EMPTY(DBF())
        file = GETFILE('DBF','Pick a table')
        IF EMPTY(FILE)
        WAIT WINDOW 'Cancelled' NOWAIT
        RETURN
        ENDIF
        USE (file)
        ENDIF
        *** Draw the fields ***
        ACTIVATE WINDOW gotodialog
        @ 0,1 TO 8,25
        @ 1,3 GET radio PICTURE '@*RVN \Top;\Bottom;\Record;\Skip' ;
        SIZE 1,10,1 DEFAULT 1 WHEN radwhen() VALID radvalid()
        @ 5,15 GET recordnum SIZE 1,8 DEFAULT 0 ;
        FUNCTION 'Z' WHEN recwhen() VALID recvalid() DISABLE
        @ 7,15 GET skipnum SIZE 1,8 DEFAULT 0 ;
        FUNCTION 'Z' WHEN skipwhen() DISABLE
        @ 3,29 GET okcancel PICTURE '@*VT \!\Goto;\?\Cancel' ;
        SIZE 1,10,2 DEFAULT 0 WHEN okwhen() VALID okvalid()
        READ CYCLE
        RELEASE WINDOW gotodialog
        *** Place cursor in recordnum field if it is enabled ***
        *** and the last object selected was the radio button ***
        *** record. Do this only if Enter, Tab, Down Arrow or ***
        *** Right Arrow is pressed to exit the record radio button. ***
        FUNCTION radwhen
        IF _CUROBJ = OBJNUM(radio)+3 AND radio = OBJNUM(radio)+2 ;
        AND lastobj = OBJNUM(radio)+2 ;
        AND (LASTKEY() = enter OR LASTKEY() = tab ;
        OR LASTKEY() = down OR LASTKEY() = right)
        _CUROBJ = OBJNUM(recordnum)
        lastobj = OBJNUM(recordnum)
        RETURN
        ENDIF
        *** Place cursor in recordnum field if it is enabled ***
        *** and the last object selected was the radio button ***
        *** skip. Do this only if Shift+Tab, Up Arrow or ***
        *** Left Arrow is pressed to exit the skip radio button. ***
        IF _CUROBJ = OBJNUM(radio)+2 AND radio = OBJNUM(radio)+2 ;
        AND lastobj = OBJNUM(radio)+3 AND (LASTKEY() = shifttab ;
        OR LASTKEY() = left OR LASTKEY() = up)
        lastobj = _CUROBJ
        _CUROBJ = OBJNUM(recordnum)
        RETURN
        ENDIF
        lastobj = _CUROBJ
        *** Enable and disable appropriate get fields when ***
        *** a radio button is selected. ***
        FUNCTION radvalid
        DO CASE
        CASE radio = 1 or radio = 2
        STORE 0 TO recordnum,skipnum
        SHOW GET recordnum DISABLED
        SHOW GET skipnum DISABLED
        CASE radio = 3
        STORE 0 TO skipnum
        SHOW GET recordnum ENABLED
        SHOW GET skipnum DISABLED
        _CUROBJ = OBJNUM(recordnum)
        CASE radio = 4
        STORE 0 TO recordnum
        SHOW GET recordnum DISABLED
        SHOW GET skipnum ENABLED
        _CUROBJ = OBJNUM(skipnum)
        ENDCASE
        *** Routine to bypass the recno field and move to the goto button. ***
        *** Put cursor on goto push button if the last object selected ***
        *** was the radio button skip. Do this only if Tab, Down Arrow ***
        *** or Right Arrow is pressed to exit the skip radio button. ***
        FUNCTION recwhen
        IF lastobj = OBJNUM(radio)+3 AND (LASTKEY() = tab ;
        OR LASTKEY() = down OR LASTKEY() = right)
        _CUROBJ = OBJNUM(okcancel)
        RETURN
        ENDIF
        *** Routine to bypass the recno field and move to the skip button. ***
        *** Place cursor on skip radio button if the last object selected ***
        *** was the goto push button. Do this only if Shift+Tab, Up Arrow ***
        *** or Left Arrow is pressed to exit the goto push button. ***
        IF lastobj = OBJNUM(okcancel) AND (LASTKEY() = shifttab ;
        OR LASTKEY() = up OR LASTKEY() = left)
        _CUROBJ = OBJNUM(radio)+3
        RETURN
        ENDIF
        lastobj = _CUROBJ
        FUNCTION recvalid
        IF !MDOWN() AND (LASTKEY() = enter OR LASTKEY() = tab ;
        OR LASTKEY() = down OR LASTKEY() = right)
        _CUROBJ = OBJNUM(radio)+3
        RETURN
        ENDIF
        IF !MDOWN() AND (LASTKEY()= shifttab ;
        OR LASTKEY() = up OR LASTKEY() = left)
        _CUROBJ = OBJNUM(radio)+2
        ENDIF
        FUNCTION skipwhen
        lastobj = _CUROBJ
        FUNCTION okwhen
        lastobj = _CUROBJ
        *** Routine to process the button choice ***
        FUNCTION okvalid
        IF okcancel = 1
        DO CASE
        CASE radio = 1
        GO TOP
        CASE radio = 2
        GO BOTTOM
        CASE radio = 3
        IF recordnum > RECCOUNT()
        WAIT WINDOW 'Record out of range' NOWAIT
        ELSE
        GO recordnum
        ENDIF
        CASE radio = 4
        IF skipnum+RECNO()  RECCOUNT() OR skipnum + RECNO()  0
        WAIT WINDOW 'Record out of range' NOWAIT
        ELSE
        SKIP skipnum
        ENDIF
        ENDCASE
        ENDIF
      </code>




    </example>
  </objnum>
  <objtoclient>
    <summary>
      Returns a position or dimension of a control or object relative to its form.
    </summary>
    <param name="ObjectName">

      Specifies the name of the control or object for which the form position is returned.

    </param>
    <param name="nPosition">

      Specifies which form position or dimension of the control or object is returned. The following table lists the values for nPosition and the corresponding position or dimension returned.
      1
      Top
      2
      Left
      3
      Width
      4
      Height
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>

      <b>OBJTOCLIENT( )</b> returns the position or dimension of a control or object relative to the client area of the form on which it resides. For example, a control or object can be placed on a page in a page frame, and the page frame is placed on a form. The <b>Top</b>, <b>Left</b>, <b>Width</b>, and <b>Height</b> properties return the position or dimension of a control or object relative to the page on which it is placed. However, you can use <b>OBJTOCLIENT( )</b> to determine the position or dimension of a control or object relative to the form on which the page is placed.
      The value returned by <b>OBJTOCLIENT( )</b> is in pixels.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        STORE _DBLCLICK TO gnDblClick  &amp;&amp; Save double-click value
        STORE 0.05 TO _DBLCLICK  &amp;&amp; Make double-click unlikely
        frmMyForm = CREATEOBJECT('Form')  &amp;&amp; Create a form
        frmMyForm.Closable = .f.  &amp;&amp; Disable the window pop-up menu

        frmMyForm.Move(150,10)  &amp;&amp; Move the form
        frmMyForm.AddObject('cmbCommand1','cmdMyCmdBtn')  &amp;&amp; Add Command button
        frmMyForm.AddObject('pgfPageFrame1','pgfMyPageFrame')  &amp;&amp; Add PageFrame
        frmMyForm.pgfPageFrame1.Page1.AddObject('chkCheckBox1','chkMyCheckBox1')
        frmMyForm.pgfPageFrame1.Page2.AddObject('chkCheckBox2','chkMyCheckBox2')
        frmMyForm.cmbCommand1.Visible =.T.  &amp;&amp; "Quit" Command button visible
        frmMyForm.pgfPageFrame1.Visible =.T.  &amp;&amp; PageFrame visible
        frmMyForm.pgfPageFrame1.Page1.chkCheckBox1.Visible =.T.
        frmMyForm.pgfPageFrame1.Page2.chkCheckBox2.Visible =.T.
        frmMyForm.SHOW  &amp;&amp; Display the form
        READ EVENTS  &amp;&amp; Start event processing
        DEFINE CLASS cmdMyCmdBtn AS CommandButton  &amp;&amp; Create Command button
        Caption = '\&lt;Quit'  &amp;&amp; Caption on the Command button
        Cancel = .T.  &amp;&amp; Default Cancel Command button (Esc)
        Left = 125  &amp;&amp; Command button column
        Top = 210  &amp;&amp; Command button row
        Height = 25  &amp;&amp; Command button height
        PROCEDURE Click
        CLEAR EVENTS  &amp;&amp; Stop event processing, close Form
        CLEAR  &amp;&amp; Clear main X# window
        STORE gnDblClick TO _DBLCLICK  &amp;&amp; Restore double-click value
        ENDDEFINE
        DEFINE CLASS pgfMyPageFrame AS PageFrame  &amp;&amp; Create PageFrame
        Left = 10  &amp;&amp; PageFrame  column
        Top = 10  &amp;&amp; PageFrame  row
        Height = 175  &amp;&amp; PageFrame  height
        Width = 350  &amp;&amp; PageFrame  height
        PageCount = 2  &amp;&amp; 2 Pages on the PageFrame
        Tabs = .T.  &amp;&amp; Tabs visible
        ENDDEFINE
        DEFINE CLASS chkMyCheckBox1 AS CheckBox  &amp;&amp; Create first Check Box
        Top = 0
        Width = 200
        Caption = 'Display Position'
        PROCEDURE Click
        DO CASE
        CASE ThisForm.pgfPageFrame1.Page1.chkCheckBox1.Value = 0
        ACTIVATE SCREEN
        CLEAR
        CASE ThisForm.pgfPageFrame1.Page1.chkCheckBox1.Value = 1
        ACTIVATE SCREEN
        CLEAR
        ? 'Positions relative'
        ? 'to PageFrame:'
        ?
        ? 'Top: '
        ?? ALLTRIM(STR;
        (ThisForm.pgfPageFrame1.Page1.chkCheckBox1.Top))
        ? 'Left: '
        ?? ALLTRIM(STR;
        (ThisForm.pgfPageFrame1.Page1.chkCheckBox1.Left))
        ? 'Width: '
        ?? ALLTRIM(STR;
        (ThisForm.pgfPageFrame1.Page1.chkCheckBox1.Width))
        ? 'Height: '
        ?? ALLTRIM(STR;
        (ThisForm.pgfPageFrame1.Page1.chkCheckBox1.Height))
        ?
        ? 'Positions relative'
        ? 'to Form:'
        ?
        ? 'Top: '
        ?? ALLTRIM(STR(OBJTOCLIENT;
        (ThisForm.pgfPageFrame1.Page1.chkCheckBox1,1)))
        ? 'Left: '
        ?? ALLTRIM(STR(OBJTOCLIENT;
        (ThisForm.pgfPageFrame1.Page1.chkCheckBox1,2)))
        ? 'Width: '
        ?? ALLTRIM(STR(OBJTOCLIENT;
        (ThisForm.pgfPageFrame1.Page1.chkCheckBox1,3)))
        ? 'Height: '
        ?? ALLTRIM(STR(OBJTOCLIENT(ThisForm.pgfPageFrame1.Page1.chkCheckBox1,4)))
        ENDCASE
        ENDDEFINE
        DEFINE CLASS chkMyCheckBox2 AS CheckBox  &amp;&amp; Create second Check Box
        Top = 30
        Left = 175
        Width = 200
        Caption = 'Display Position'
        PROCEDURE CLICK
        DO CASE
        CASE ThisForm.pgfPageFrame1.Page2.chkCheckBox2.Value = 0
        ACTIVATE SCREEN
        CLEAR
        CASE ThisForm.pgfPageFrame1.Page2.chkCheckBox2.Value = 1
        ACTIVATE SCREEN
        CLEAR
        ? 'Positions relative'
        ? 'to PageFrame:'
        ?
        ? 'Top: '
        ?? ALLTRIM(STR(ThisForm.pgfPageFrame1.Page2.chkCheckBox2.Top))
        ? 'Left: '
        ?? ALLTRIM(STR;
        (ThisForm.pgfPageFrame1.Page2.chkCheckBox2.Left))
        ? 'Width: '
        ?? ALLTRIM(STR;
        (ThisForm.pgfPageFrame1.Page2.chkCheckBox2.Width))
        ? 'Height: '
        ?? ALLTRIM(STR;
        (ThisForm.pgfPageFrame1.Page2.chkCheckBox2.Height))

        ?
        ? 'Positions relative'
        ? 'to Form:'
        ?
        ? 'Top: '
        ?? ALLTRIM(STR(OBJTOCLIENT;
        (ThisForm.pgfPageFrame1.Page2.chkCheckBox2,1)))
        ? 'Left: '
        ?? ALLTRIM(STR(OBJTOCLIENT;
        (ThisForm.pgfPageFrame1.Page2.chkCheckBox2,2)))
        ? 'Width: '
        ?? ALLTRIM(STR(OBJTOCLIENT;
        (ThisForm.pgfPageFrame1.Page2.chkCheckBox2,3)))
        ? 'Height: '
        ?? ALLTRIM(STR(OBJTOCLIENT;
        (ThisForm.pgfPageFrame1.Page2.chkCheckBox2,4)))
        ENDCASE
        ENDDEFINE
      </code>
    </example>
  </objtoclient>
  <objvar>
    <summary>
      Included for backward compatibility. Use the Name Property (X#) for controls instead.
       
      Returns the name of the memory variable, array element or field associated with an object.
    </summary>
    <returns>
      Returns - Character
    </returns>
    <remarks>
      <br />
      You can use @ ... GET and @ ... EDIT to create controls which are also called objects. Controls that are considered objects are fields, check boxes, lists, popups, invisible, push, and radio buttons, spinners and text editing regions. OBJVAR() returns the name of the memory variable, array element or field in which one of these stores a value. <br />
      <br />
      Memory variable and array element names returned by OBJVAR() are prefaced with M and a period (M.). Field names returned by OBJVAR() are prefaced by the table alias and a period.<br />
      <br />
      <br />

    </remarks>
  </objvar>
  <occurs>
    <summary>
      Returns the number of times a character expression occurs within another character expression.
    </summary>
    <param name="cSearchExpression">

      Specifies a character expression that <b>OCCURS( )</b> searches for within cExpressionSearched.

    </param>
    <param name="cExpressionSearched">

      Specifies the character expression <b>OCCURS( )</b> searches for cSearchExpression.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>

      <b>OCCURS( )</b> returns 0 (zero) if cSearchExpression isn't found within cExpressionSearched.
    </remarks>
    <example>
       <code language="X#">
        STORE 'abracadabra' TO gcstring
        CLEAR
        ? OCCURS('a', gcstring)  &amp;&amp; Displays 5
        ? OCCURS('b', gcstring)  &amp;&amp; Displays 2
        ? OCCURS('c', gcstring)  &amp;&amp; Displays 1
        ? OCCURS('e', gcstring)  &amp;&amp; Displays 0
      </code>
    </example>
  </occurs>
  <oemtoansi>
    <summary>
      Included for backward compatibility. Use the CPCONVERT( ) Function instead.
       
      Converts each character in a character expression to the corresponding character in the ANSI character set.
    </summary>
    <returns>
      Return value - Character
    </returns>
    <remarks>
      <br />
      OEMTOANSI() is supported in FoxPro for Windows and FoxPro for Macintosh.<br />
      <br />
      Use OEMTOANSI() to move data from FoxPro for MS-DOS to FoxPro for Windows and FoxPro for Macintosh. <br />
      <br />

    </remarks>
  </oemtoansi>
  <on>
    <summary>
      Returns the command assigned to each of these event-handling commands: <b>ON ERROR</b>, <b>ON ESCAPE</b>, <b>ON KEY LABEL</b>, or <b>ON PAGE</b>.
    </summary>
    <param name="cONCommand">

      Specifies one of the event-handling commands. Here are the commands and corresponding character expressions to use with <b>ON( )</b>:
      cONCommand
      ON ERROR
      ON ESCAPE
      ON KEY LABEL
      ON PAGE
      For example, to return the command currently assigned to ON ERROR, use the following:
       <code language="X#">? ON('ERROR')</code>

    </param>
    <param name="KeyLabelName">

      Used in <b>ON KEY LABEL</b> to specify a key or key combination to which the command is assigned. Specify KEY in cONCommand and the key label name of the key or key combination in KeyLabelName. For a complete list of key label names, see ON KEY LABEL.
      For example, to return the command currently assigned to the F7 function key with <b>ON KEY LABEL</b>, use the following:
       <code language="X#">? ON('KEY', 'F7')</code>
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      When an event occurs that is trapped by one of the event-handling commands, the command assigned by the event-handling command executes. <b>ON( )</b> returns the command you assigned to an event-handling command. <b>ON( )</b> returns an empty string if a command isn't currently assigned to the event-handling command you specify.
    </remarks>
    <example>
       <code language="X#">
        ON ERROR DO errorhand
        ON KEY LABEL CTRL+F2 WAIT WINDOW 'You pressed ^F2'
        ON KEY LABEL ALT+Z DISPLAY MEMORY
        CLEAR
        ? ON('ERROR')  &amp;&amp; Displays DO errorhand
        ? ON('KEY', 'CTRL+F2')  &amp;&amp; Displays WAIT WINDOW 'You pressed ^F2'
        ? ON('KEY', 'ALT+Z')  &amp;&amp; Displays DISPLAY MEMORY
        ON ERROR
        ON KEY LABEL CTRL+F2
        ON KEY LABEL ALT+Z
      </code>
    </example>
  </on>
  <os>
    <summary>
      Returns the name and version number of the operating system under which X# is running.
    </summary>
    <param name="nValue">

      Specifies the item to return, according to the following table.
      <b>nValues</b>

      1
      Specifies that the name and version number of the operating system is returned.
      2
      DBCS Support. If DBCS (double-byte character sets) are supported, "DBCS" is returned. Otherwise, an empty string is returned
      3
      Identifies the major version number of the operating system. For example, for Windows 2000, the major version number is 5.
      4
      Identifies the minor version number of the operating system. For example, for Windows 2000, the minor version number is 0.
      Identifies the build number of the operating system.
      6
      Identifies the operating system platform.
      7
      Contains a string, such as "Service Pack 3", that indicates the latest Service Pack installed on the system. If no Service Pack has been installed, the string is empty.
      8
      Identifies the major version number of the latest Service Pack installed on the system. For example, for Service Pack 3, the major version number is 3. If no Service Pack has been installed, the value is zero.
      9
      Identifies the minor version number of the latest Service Pack installed on the system. For example, for Service Pack 3, the minor version number is 0.
      10
      A set of bit flags that identify the product suites available on the system. See Product Suite bit flag table below for values.
      11
      Indicates additional information about the system. See Product Type settings table below for values.
      Microsoft Small Business Server is installed.
      Windows 2000 Advanced Server or Windows Server 2003, Enterprise Edition, is installed.
      Microsoft BackOffice components are installed.
      16
      Terminal Services are installed.
      32
      Microsoft Small Business Server is installed with the restrictive client license in force.
      64
      Windows Embedded NT is installed
      128
      Windows 2000 or Windows Server 2003, Datacenter Edition, is installed.
      256
      Terminal Services is installed, but only one interactive session is supported.
      512
      Windows XP Home Edition is installed.
      1024
      Windows Server 2003, Web Edition, is installed.
      The system is running Windows NT 4.0 Workstation, Windows 2000 Professional, Windows XP Home Edition, or Windows XP Professional.
      The system is a domain controller.
      The system is a server.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      If you omit the optional argument, this function returns the underlying operating system name and its version number.
      Some nValues are not applicable to some operating systems. In such cases, the OS( ) function returns "0" or "", an empty string.
    </remarks>
    <example>
       <code language="X#">
        ? OS( )
        ? OS(1)
        ? OS(2)
      </code>
    </example>
  </os>
  <pad>
    <summary>
      Returns as an uppercase character string the menu title most recently chosen from a menu bar, or returns a logical value indicating if a menu title is defined for an active menu bar.
    </summary>
    <param name="cMenuTitle">

      Specifies the name of a menu title in a menu bar. Include this argument to test if the menu title is defined for an active menu bar. A logical true (.T.) is returned if the menu title is defined; otherwise a logical false (.F.) is returned.

    </param>
    <param name="cMenuBarName">

      Specifies the name of the menu bar containing the menu title cMenuTitle. If cMenuBarName is omitted, the menu title is assumed to be in the currently active menu bar.
    </param>
    <returns>
      Character or Logical
    </returns>
    <remarks>
      A menu bar must be defined and active for PAD( ) to return a menu title. Menu bars are created and activated with DEFINE MENU and ACTIVATE MENU.
      You can also use <b>PAD( )</b> with the X# system menu bar.
      PAD( ) (issued without any of its optional arguments) returns an empty string if a menu bar isn't defined and active or you issue <b>PAD( )</b> from the Command window.
    </remarks>
    <example>
       <code language="X#">
        *** Name this program PADEXAM.PRG ***
        CLEAR
        SET SYSMENU SAVE
        SET SYSMENU TO
        DEFINE PAD padSys OF _MSYSMENU PROMPT '\&lt;System' COLOR SCHEME 3 ;
        KEY ALT+S, ''
        DEFINE PAD padEdit OF _MSYSMENU PROMPT '\&lt;Edit' COLOR SCHEME 3 ;
        KEY ALT+E, ''
        DEFINE PAD padRecord OF _MSYSMENU PROMPT '\&lt;Record' COLOR SCHEME 3 ;
        KEY ALT+R, ''
        DEFINE PAD padWindow OF _MSYSMENU PROMPT '\&lt;Window' COLOR SCHEME 3 ;
        KEY ALT+W, ''
        DEFINE PAD padReport OF _MSYSMENU PROMPT 'Re\&lt;ports' COLOR SCHEME 3 KEY ALT+P, ''
        DEFINE PAD padExit OF _MSYSMENU PROMPT 'E\&lt;xit' COLOR SCHEME 3 ;
        KEY ALT+X, ''
        ON SELECTION MENU _MSYSMENU ;
        DO choice IN padexam WITH PAD( ), MENU( )
        PROCEDURE choice
        PARAMETERS gcPad, gcMenu
        WAIT WINDOW 'You chose ' + gcPad + ;
        ' from menu ' + gcMenu NOWAIT
        IF gcPad = 'PADEXIT'
        SET SYSMENU TO DEFAULT
        ENDIF
      </code>
    </example>
  </pad>
  <padprompt>
    <summary>
      Returns the text of a menu title.
    </summary>
    <returns>
      Character.
    </returns>
    <remarks>

      Specifies the menu title (pad) name or internal system menu title name.

      Specifies the name of the menu bar containing the menu title or internal system menu bar name.
      When cMenuBarName is omitted the currenctly active menu bar is used as the second parameter.
      When no menu bar is active and cMenuBarName is omitted an error is generated.
      Menu bars are created with DEFINE MENU, which creates the menu bar, and DEFINE PAD, which creates the menu titles in the menu bar.
      PADPROMPT( ) also works with the X# menu system. A menu bar doesn't have to be active for PADPROMPT( ) to return the text for a menu title.
      br
      If a menu title was created using the backslash and less-than characters (\&lt;) to create an access key, or a backslash (\) to disable the menu title,
      PADPROMPT( ) returns only the text of the menu title; it doesn't include the special characters.
    </remarks>
    <example>

      <code language="X#">
        ? "System menu titles: "
        FOR lnI = 1 TO CNTPAD("_msysmenu")
        ?? PADPROMPT( GETPAD( "_msysmenu", lnI), "_msysmenu") + " "
        NEXT
      </code>
    </example>
  </padprompt>
  <parameters>
    <summary>
      Returns the number of parameters passed to the most recently called program, procedure, or user-defined function.
    </summary>
    <returns>
      PARAMETERS( )Return Value
      Numeric
    </returns>
    <remarks>
      PARAMETERS( ) is useful for determining how many parameters are passed to a program, procedure, or user-defined function.
      The value returned by PARAMETERS() is reset every time a program, procedure, or user-defined function is called or when ON KEY LABEL is executed. Unlike PARAMETERS(), the PCOUNT() function does not get reset, so PCOUNT() may be preferable in most programming situations.
      Example 1 calls a procedure and displays in a wait window the number of parameters passed.
      Example 2 uses a procedure to display the average of 4 values.
       <code language="X#">
        * Example 1
        DO testpar WITH 1,2,3
        PROCEDURE testpar
        PARAMETERS gn1,gn2,gn3
        gcMessage = 'PARAMETERS( ) ='+ALLTRIM(STR(PARAMETERS( )))
        WAIT WINDOW (gcMessage)
        RETURN
        * Example 2
        SET TALK OFF
        gnVal1 = 10
        gnVal2 = 20
        gnVal3 = 30
        gnVal4 = 15
        gnMin = getavg(gnVal1, gnVal2, gnVal3, gnVal4)
        ? 'Average value is '
        ?? gnMin
        * This user-defined function permits up to 9 parameters to be passed.
        * It uses the PARAMETERS( ) function to determine how many
        * were passed and returns the average value.
        FUNCTION getavg
        PARAMETERS gnPara1,gnPara2,gnPara3,gnPara4,gnPara5, ;
        gnPara6,gnPara7,gnPara8,gnPara9
        IF PARAMETERS( ) = 0
        RETURN 0
        ENDIF
        gnResult = 0
        FOR gnCount = 1 to PARAMETERS( )
        gcCompare = 'gnPara' +(STR(gnCount,1))
        gnResult = gnResult + EVAL(gcCompare)
        ENDFOR
        gnResult = gnResult / (gnCount - 1)
        RETURN gnResult
      </code>
    </remarks>
  </parameters>
  <pcount>
    <summary>
      Returns the number of parameters passed to the current program, procedure, or user-defined function.
    </summary>
    <returns>
      PCOUNT( )Return Value
      Numeric
    </returns>
    <remarks>

      <b>PCOUNT( )</b> is useful for determining how many parameters are passed to the current program, procedure, or user-defined function.
      Example 1 calls a procedure and displays in a wait window the number of parameters passed.
      Example 2 uses a procedure to display the average of 4 values.
       <code language="X#">
        DO testpar WITH 1,2,3
        PROCEDURE testpar
        PARAMETERS gn1,gn2,gn3
        gcMessage = 'PCOUNT( ) ='+ALLTRIM(STR(PCOUNT( )))
        WAIT WINDOW (gcMessage)
        RETURN
      </code>
       <code language="X#">
        SET TALK OFF
        gnVal1 = 10
        gnVal2 = 20
        gnVal3 = 30
        gnVal4 = 15
        gnMin = getavg(gnVal1, gnVal2, gnVal3, gnVal4)
        ? 'Average value is '
        ?? gnMin
        * This user-defined function permits up to 9 parameters to be passed.
        * It uses the PCOUNT( ) function to determine how many
        * were passed and returns the average value.
        FUNCTION getavg
        PARAMETERS gnPara1,gnPara2,gnPara3,gnPara4,gnPara5, ;
        gnPara6,gnPara7,gnPara8,gnPara9
        IF PCOUNT( ) = 0
        RETURN 0
        ENDIF
        gnResult = 0
        FOR gnCount = 1 to PARAMETERS( )
        gcCompare = 'gnPara' +(STR(gnCount,1))
        gnResult = gnResult + EVAL(gcCompare)
        ENDFOR
        gnResult = gnResult / (gnCount - 1)
        RETURN gnResult
      </code>
    </remarks>
  </pcount>
  <pemstatus>
    <summary>
      Retrieves an attribute for a property, event, method, or object.
    </summary>
    <param name="oObjectName">

      Specifies the object for which the property, event, method, or object attribute to return. oObjectName can be any expression that evaluates to an object, such as an object reference, an object memory variable, or an object array element.
      If oObjectName is a container object such as a form, you can determine attributes for objects in the container object.

    </param>
    <param name="cClassName">

      Specifies the class for which the property, event, or method attribute to return.

    </param>
    <param name="cProperty">

      Specifies the property for which the attribute to return.

    </param>
    <param name="cEvent">

      Specifies the event for which the attribute to return.

    </param>
    <param name="cMethod">

      Specifies the method for which the attribute to return.

    </param>
    <param name="cObject">

      Specifies the object for which the attribute to return.
      For example, you can use the <b>AddObject</b> method to add an object to a container object, and then use <b>PEMSTATUS( )</b> to return information about the object added to the container object.

    </param>
    <param name="nAttribute">

      Specifies a numeric value that determines the property, event, or method attribute to return.
      The following table lists the values for nAttribute and the corresponding property, event, or method attribute returned.
      0
      Changed.
      If the property value, method, or event has changed, <b>PEMSTATUS( )</b> returns a logical True (.T.). Otherwise, <b>PEMSTATUS( )</b> returns logical False (.F.).
      1
      Read-only (properties only).
      If the property is read-only, <b>PEMSTATUS( )</b> returns a logical True (.T.). Otherwise, <b>PEMSTATUS( )</b> returns a logical False (.F.).
      2
      Protected.
      If the property, event, or method is protected, <b>PEMSTATUS( )</b> returns a logical True (.T.). Otherwise, <b>PEMSTATUS( )</b> returns a logical False (.F.).
      3
      Type.
      <b>PEMSTATUS( )</b> returns a character string, for example, Property, Event, Method, or Object, indicating whether cProperty, cEvent, cMethod or cObject is a property, event, method or object.
      4
      User-defined.
      If the property, event, or method is a user-defined property, event, or method, <b>PEMSTATUS( )</b> returns a logical True (.T.). Otherwise, <b>PEMSTATUS( )</b> returns a logical False (.F.).
      5
      Defined property, event, method, or object.
      If the property, event, method, or object exists for oObjectName or cClassName, <b>PEMSTATUS( )</b> returns a logical True (.T.). Otherwise, or for hidden native properties, <b>PEMSTATUS( )</b> returns a logical False (.F.).
      6
      Inherited property, event, method, or object.
      If the property, event, method, or object for oObjectName or cClassName was inherited from another object or class, <b>PEMSTATUS( )</b> returns logical True (.T.). Otherwise, <b>PEMSTATUS( )</b> returns a logical False (.F.).
    </param>
    <returns>
      Character or Logical. <b>PEMSTATUS( )</b> returns a character string or logical value for the attribute specified.
    </returns>
    <remarks>

      <b>PEMSTATUS( )</b> does not detect for changes in specific array elements if the array is passed.
    </remarks>
  </pemstatus>
  <pi>
    <summary>
      Returns the numeric constant pi.
    </summary>
    <returns>
      PI( )Return Value
      Numeric
    </returns>
    <remarks>
      The numeric constant pi (3.141592) is the ratio of the circumference of a circle to its diameter.
      The number of decimal places displayed in the value returned by <b>PI( )</b> is determined by SET DECIMALS.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? PI( ) &amp;&amp; Displays 3.14
        STORE 2.30 TO gnRadius
        STORE PI( ) * gnRadius^2 TO gnArea
        ? gnArea  &amp;&amp; Displays 16.6190
      </code>
    </example>
  </pi>
  <popup>
    <summary>
      Returns as a string the name of the active menu, or a logical value indicating if a menu has been defined.
    </summary>
    <param name="cMenuName">

      Returns a logical value indicating if cMenuName has been defined. POPUP( ) returns true (.T.) if the menu you specify has been defined; otherwise POPUP( ) returns false (.F.).
    </param>
    <returns>
      Character or Logical
    </returns>
    <remarks>
      POPUP( ) returns the name of the active menu as a character string if you omit the optional cMenuName argument. A menu must be defined and active for POPUP( ) to return its name. Menus are created and activated with DEFINE POPUP and ACTIVATE POPUP. The menu can also be a X# system menu. POPUP( ) returns an empty string if a menu isn't defined and active or you issue POPUP( ) from the Command window.
    </remarks>
  </popup>
  <printstatus>
    <summary>
      Returns the status of the printer. Included for backward compatibility.
    </summary>
    <returns>
      PRINTSTATUS( )Return Value
      Logical value. For versions of X# running on Windows, PRINTSTATUS( ) always returns True (.T.) if the printer is connected through the Windows Control Panel.
      In prior versions, if the printer or print device is online, PRINTSTATUS( ) returns True (.T.); otherwise, it returns False (.F.).
    </returns>
    <remarks>
      PRINTSTATUS( ) functions similarly to SYS(13). For more information, see SYS(13) - Printer Status.
    </remarks>
    <example>
       <code language="X#">
        ? PRINTSTATUS( )
        *** Program Example ***
        STORE PRINTSTATUS( ) TO glReady
        IF NOT glReady
        WAIT 'Make sure printer is attached and turned on!' WINDOW
        ELSE
        WAIT 'Printer is ready!' WINDOW
        ENDIF
      </code>
    </example>
  </printstatus>
  <prmbar>
    <summary>
      Returns the text of a menu item.
    </summary>
    <param name="cMenuName">

      Specifies the menu name.

    </param>
    <param name="nMenuItemNumber">

      Specifies the number of the menu item whose text PRMBAR( ) returns. For example, if nMenuItemNumber is 1, the text of the first menu item is returned; if nMenuItemNumber is 2, the text of the second menu item is returned, and so on. The expression must be at least 1 and no greater than the number of menu items in the menu.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      Menus are created with DEFINE POPUP, which creates the menu, and DEFINE BAR, which creates the menu items in the menu. PRMBAR( ) also works with a X# system menu. PRMBAR( ) returns the text that appears on the menu item. The menu doesn't have to be active.
      If a menu item was created using the backslash and less-than characters (\&lt;) to create an access key, or a backslash (\) to disable the menu item, PRMBAR( ) returns only the menu item text; it doesn't include these special characters. PRMBAR( ) returns an empty string when a menu item is a separator created with the backslash and dash (\-) characters.
    </remarks>
  </prmbar>
  <prmpad>
    <summary>
      Returns the text of a menu title.
    </summary>
    <param name="MenuBarName">

      Specifies the name of the menu bar containing the menu title.

    </param>
    <param name="MenuTitleName">

      Specifies the menu title.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      Menu bars are created with DEFINE MENU, which creates the menu bar, and DEFINE PAD, which creates the menu titles in the menu bar. PRMPAD( ) also works with the X# menu system. A menu bar doesn't have to be active for PRMPAD( ) to return the text for a menu title.
      If a menu title was created using the backslash and less-than characters (\&lt;) to create an access key, or a backslash (\) to disable the menu title, PRMPAD( ) returns only the text of the menu title; it doesn't include the special characters.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        SET TALK OFF
        STORE 'mnuExample' TO gcPopName
        DEFINE MENU mnuExample BAR AT LINE 1
        DEFINE PAD titleOne OF mnuExample PROMPT 'This will be returned'
        DEFINE PAD titleTwo OF mnuExample PROMPT '\&lt;As will this'
        DEFINE PAD titleThree OF mnuExample PROMPT '\And this, too'
        =messagebox( PRMPAD('mnuExample', 'titleOne') )
        =messagebox( PRMPAD('mnuExample', 'titleTwo') )
        =messagebox( PRMPAD(gcPopName, 'titleThree') )
        ACTIVATE MENU mnuExample
        DEACTIVATE MENU mnuExample
        RELEASE MENU mnuExample
      </code>
    </example>
  </prmpad>
  <prompt>
    <summary>
      Returns the text for a menu title chosen from a menu bar or for a menu item chosen from a menu.
    </summary>
    <returns>
      PROMPT( )Return Value
      Character
    </returns>
    <remarks>

      <b>PROMPT( )</b> returns the text of the menu title last chosen from a menu bar or the menu item last chosen from a menu. The menu bar or menu can be user-defined or a X# system menu bar or menu. If a menu bar or menu isn't active or you press ESC to exit a menu bar or menu, <b>PROMPT( )</b> returns an empty string.
      A menu bar is created with <b>DEFINE MENU</b>, and each menu title in the menu bar is created with <b>DEFINE PAD</b>. A menu is created with <b>DEFINE POPUP</b>, and the menu items in the menu are created with <b>DEFINE BAR</b>.

      <b>MENU( )</b> and <b>POPUP( )</b> can be used to return the name of the menu bar or menu from which the menu title or menu item is chosen.
    </remarks>
  </prompt>
  <proper>
    <summary>
      Returns from a character expression a string capitalized as appropriate for proper names.
    </summary>
    <param name="cExpression">

      Specifies the character expression from which <b>PROPER( )</b> returns a capitalized character string.
    </param>
    <returns>
      Character
    </returns>
    <example>
       <code language="X#">
        STORE 'X#' TO gcExpr1
        CLEAR
        ? PROPER(gcExpr1)  &amp;&amp; Displays "X#"
        STORE 'X#' TO gcExpr2
        ? PROPER(gcExpr2)  &amp;&amp; Displays "X#"
      </code>
    </example>
  </proper>
  <rand>
    <summary>
      Returns a random number between 0 and 1.
    </summary>
    <param name="nSeedValue">

      Specifies the seed value that determines the sequence of values RAND( ) returns.
      RAND( ) returns the same sequence of random numbers if you use the same seed value for nSeedValue the first time you issue RAND( ) followed by subsequent RAND( ) function calls without nSeedValue.
      If nSeedValue is negative the first time you issued RAND( ), a seed value from the system clock is used. To achieve the most random sequence of numbers, issue RAND( ) initially with a negative argument and then issue RAND( ) without an argument.
      If you omit nSeedValue, RAND( ) uses a default seed value of 100,001.
    </param>
    <returns>
      Numeric
    </returns>
    <example>
       <code language="X#">
        CLOSE DATABASES
        CREATE TABLE Random (cValue N(3))
        FOR nItem = 1 TO 10  &amp;&amp; Append 10 records,
        APPEND BLANK
        REPLACE cValue WITH 1 + 100 * RAND( )  &amp;&amp; Insert random values
        ENDFOR
        CLEAR
        LIST  &amp;&amp; Display the values
        gnMaximum = 1  &amp;&amp; Initialize minimum value
        gnMinimum = 100  &amp;&amp; Initialize maximum value
        SCAN
        gnMinimum = MIN(gnMinimum, cValue)
        gnMaximum = MAX(gnMaximum, cValue)
        ENDSCAN
        ? 'The minimum value is: ', gnMinimum  &amp;&amp; Display minimum value
        ? 'The maximum value is: ', gnMaximum  &amp;&amp; Display maximum value
        CLEAR
        gnLower = 1
        gnUpper = 10
        ? INT((gnUpper - gnLower + 1) * RAND( ) + gnLower)
      </code>
    </example>
  </rand>
  <rat>
    <summary>
      Returns the numeric position of the last (rightmost) occurrence of a character string within another character string.
    </summary>
    <param name="cSearchExpression">

      Specifies the character expression that RAT( ) looks for in cExpressionSearched. The character expression can refer to a memo field of any size.

    </param>
    <param name="cExpressionSearched">

      Specifies the character expression that RAT( ) searches. The character expression can refer to a memo field of any size.

    </param>
    <param name="nOccurrence">

      Specifies which occurrence, starting from the right and moving left, of cSearchExpression RAT( ) searches for in cExpressionSearched. By default, RAT( ) searches for the last occurrence of cSearchExpression (nOccurrence = 1). If nOccurrence is 2, RAT( ) searches for the next to last occurrence, and so on.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      RAT( ), the reverse of the AT( ) function, searches the character expression in cExpressionSearched starting from the right and moving left, looking for the last occurrence of the string specified in cSearchExpression.
      RAT( ) returns an integer indicating the position of the first character in cSearchExpression in cExpressionSearched. RAT( ) returns 0 if cSearchExpression isn't found in cExpressionSearched, or if nOccurrence is greater than the number of times cSearchExpression occurs in cExpressionSearched.
      The search performed by RAT( ) is case-sensitive.
    </remarks>
    <example>
       <code language="X#">
        STORE 'abracadabra' TO string
        STORE 'a' TO find_str
        CLEAR
        ? RAT(find_str,string)  &amp;&amp; Displays 11
        ? RAT(find_str,string,3)  &amp;&amp; Displays 6
      </code>
    </example>
  </rat>
  <ratline>
    <summary>
      Returns the line number of the last occurrence of a character expression within another character expression or memo field, counting from the last line.
    </summary>
    <param name="cSearchExpression">

      Specifies the character expression that RATLINE( ) looks for in cExpressionSearched.

    </param>
    <param name="cExpressionSearched">

      Specifies the character expression that RATLINE( ) searches. The character expressions cSearchExpression and cExpressionSearched can be memo fields of any size.
      Use MLINE( ) to return the line containing cSearchExpression.
      RATLINE() offers a convenient way to search memo fields.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      RATLINE( ), the reverse of the ATLINE( ) function, searches a character expression cExpressionSearched, starting with the last character in cExpressionSearched, for the occurrence of cSearchExpression.
      If the search is successful, RATLINE( ) returns the number of the line where the match occurs. If the search is unsuccessful, RATLINE( ) returns 0.
      The search performed by RATLINE( ) is case-sensitive.
      The line number that RATLINE() returns is determined by the value of SET MEMOWIDTH, even if cExpressionSearched isn't a memo field. For more information, see SET MEMOWIDTH.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'data\testdata')
        USE employee  &amp;&amp; Opens Employee table
        STORE 'graduated' TO gcString
        STORE MLINE(notes, RATLINE(gcString, notes)) TO gnFileLine
        ? gnFileLine
      </code>
    </example>
  </ratline>
  <rdlevel>
    <summary>
      Included for backward compatibility. Use the Form Designer instead of READ.
       
      Returns the current READ level.
    </summary>
    <returns>
      Return value - Numeric
    </returns>
    <remarks>
      <br />
      Nested READs are created by issuing @ ... GETS and a READ in a routine that's executed during an active READ. READs can be nested to five levels. <br />
      <br />
      Use RDLEVEL() to return the level of the current READ command. RDLEVEL() returns a value of 0, 1, 2, 3, 4 or 5, depending on how deep the current READ is nested. RDLEVEL() returns 0 if no READ is executing.<br />
      <br />

    </remarks>
    <example>
      In the following example, pressing CTRL+Z at any time displays the current READ level using RDLEVEL(). You can advance to the next READ level by pressing Enter or you can move back a READ level by pressing Esc. Note the use of the VALID clause with @ ... GET and a UDF to create nested READs.<br />
      <br />











      <code language="X#">
        ON KEY LABEL CTRL+Z DO saylevel
        CLEAR
        DO saylevel
        @ 4,2 GET level1 VALID(proc1()) DEFAULT 1
        READ				&amp;&amp; READ Level 1
        ON KEY LABEL CTRL+Z
        RETURN
        PROCEDURE proc1
        @ 6,2 GET level2 VALID(proc2()) DEFAULT 2
        READ				&amp;&amp; READ Level 2
        RETURN ''
        PROCEDURE proc2
        @ 8,2 GET level3 VALID(proc3()) DEFAULT 3
        READ				&amp;&amp; READ Level 3
        RETURN ''
        PROCEDURE proc3
        @ 10,2 GET level4 DEFAULT 4
        READ				&amp;&amp; READ Level 4
        RETURN ''
        PROCEDURE saylevel
        @ 2,2 SAY 'Read level: ' + STR(RDLEVEL())
        RETURN ''
      </code>




    </example>
  </rdlevel>
  <readkey>
    <summary>
      Included for backward compatibility with READ. Use the Form Designer instead of READ.
       
      Returns a value corresponding to the key pressed to exit certain editing commands, or a value indicating how the last READ was terminated.
    </summary>
    <returns>
      Return value - Numeric
    </returns>
    <remarks>
      <br />
      If READKEY() is issued without the optional numeric expression expN, the value returned represents the key pressed to exit from these editing commands: APPEND, BROWSE, CHANGE, CREATE, EDIT, INSERT, MODIFY and READ.<br />
      <br />
      An integer between 0 and 36, or between 256 and 292, is returned. The value returned is between 0 and 36 if the data was not modified. The value returned is between 256 and 292 if the data was modified.<br />
      <br />
      Values Returned by READKEY<br />
      <br />
      Key(s)&amp;nbsp;No Update&amp;nbsp;Update&amp;nbsp;Meaning<br />
      &amp;nbsp;&amp;nbsp;Code&amp;nbsp;&amp;nbsp;Code<br />
      ------&amp;nbsp;---------&amp;nbsp;------&amp;nbsp;-------<br />
      <br />
      Backspace<br />
      Left Arrow   0      256     Back 1<br />
      Ctrl+H &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;char.<br />
      Ctrl+S&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br />

    </remarks>
  </readkey>
  <reccount>
    <summary>
      Returns the number of records in the current or specified table.
    </summary>
    <param name="nWorkArea">

      Specifies the work area number for a table open in another work area.
      RECCOUNT( ) returns 0 if a table isn't open in the work area you specify.

    </param>
    <param name="cTableAlias">

      Specifies the table alias for a table open in another work area.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The value RECCOUNT( ) returns isn't affected by SET DELETED and SET FILTER.
      RECCOUNT( ) without the optional arguments nWorkArea or cTableAlias returns the number of records in the table in the currently selected work area.
    </remarks>
    <example>
       <code language="X#">
        *** Check DISKSPACE before a SORT ***
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer  &amp;&amp; Opens Customer table
        *** Get size of table header ***
        gnTableHead = HEADER( )
        *** Calculate size of table ***
        gnFileSize = gnTableHead + (RECSIZE( ) * RECCOUNT( ) + 1)
        IF DISKSPACE( ) &gt; (gnFileSize * 3)
        WAIT WINDOW 'Sufficient diskspace to sort.'
        ELSE
        WAIT WINDOW 'Insufficient diskspace. Sort cannot be done.'
        ENDIF
      </code>
    </example>
  </reccount>
  <recno>
    <summary>
      Returns the current record number in the current or specified table.
    </summary>
    <param name="nWorkArea">

      Specifies the work area number for a table open in another work area. RECNO( ) returns 0 if a table isn't open in the work area you specify.

    </param>
    <param name="cTableAlias">

      Specifies the table alias for a table open in another work area.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The current record is the record on which the record pointer is positioned.
      RECNO( ) returns negative numbers for records appended in a table buffer.
      RECNO( ) returns a value that is one greater than the number of records in the table if the record pointer is positioned beyond the last record in the table. RECNO( ) returns 1 if the record pointer is positioned before the first record in the table or the table has no records. If a table has no records, EOF( ) always returns true (.T.).
      RECNO( ) issued without the optional arguments nWorkArea or cTableAlias returns the current record number for the table in the currently selected work area.
      If you have issued SEEK unsuccessfully in an indexed table, you can specify 0 for nWorkArea to use "soft seek" logic to return the record number of the closest matching record. RECNO(0) returns 0 if a close match cannot be found. X# generates an error message if you issue GO RECNO(0) when a close match isn't found.
      Avoid using RECNO( ) in the index expression for a table buffered cursor. Because RECNO( ) changes for new records when they are committed by TABLEUPDATE( ), index corruption could occur.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'data\testdata')
        USE customer  &amp;&amp; Opens Customer table
        SET ORDER TO company
        SEEK 'Ernst'
        IF FOUND( )
        DISPLAY company, contact
        ELSE
        GOTO RECNO(0)
        CLEAR
        ? 'Closest matching company is ' + company
        ? 'Record number: ' + ALLTRIM(STR(RECNO( )))
        ENDIF
      </code>
    </example>
  </recno>
  <recsize>
    <summary>
      Returns the size (width) of a table record.
    </summary>
    <param name="nWorkArea">

      Specifies the work area number for a table open in another work area. <b>RECSIZE( )</b> returns 0 if a table isn't open in the work area you specify.

    </param>
    <param name="cTableAlias">

      Specifies the table alias for a table open in another work area.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>

      <b>RECSIZE( )</b> issued without the optional arguments nWorkArea or cTableAlias returns the record size for the table in the currently selected work area.
    </remarks>
    <example>
       <code language="X#">
        *** Check DISKSPACE before a SORT ***
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer  &amp;&amp; Opens Customer table
        *** Get size of table header ***
        gnTableHead = HEADER( )
        *** Calculate size of table ***
        gnFileSize = gnTableHead + (RECSIZE( ) * RECCOUNT( ) + 1)
        IF DISKSPACE( ) &gt; (gnFileSize * 3)
        WAIT WINDOW 'Sufficient diskspace to sort.'
        ELSE
        WAIT WINDOW 'Insufficient diskspace. Sort cannot be done.'
        ENDIF
      </code>
    </example>
  </recsize>
  <replicate>
    <summary>
      Returns a character string that contains a specified character expression repeated a specified number of times.
    </summary>
    <param name="cExpression">

      Specifies the character expression that is replicated.

    </param>
    <param name="nTimes">

      Specifies the number of times the character expression is replicated.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      In X#, the maximum length of the resulting character string is restricted by the amount of available memory.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? REPLICATE('HELLO ',4) &amp;&amp; Displays HELLO HELLO HELLO HELLO
      </code>
    </example>
  </replicate>
  <rgb>
    <summary>
      Returns a single color value from a set of red, green, and blue color components.
    </summary>
    <param name="nRedValue">

      Specifies the intensity of the red color component. nRedValue can range from 0 to 255. Zero is the minimum color intensity; 255 is the maximum color intensity.

    </param>
    <param name="nGreenValue">

      Specifies the intensity of the green color component. nGreenValue can range from 0 to 255.

    </param>
    <param name="nBlueValue">

      Specifies the intensity of the blue color component. nBlueValue can range from 0 to 255.
    </param>
    <remarks>
      The value returned by RGB( ) can be used to set color properties such as BackColor and ForeColor.
    </remarks>
    <example>
       <code language="X#">
        goMyForm = CREATEOBJECT('FORM')  &amp;&amp; Create a form
        goMyForm.Show  &amp;&amp; Display the form
        WAIT WINDOW 'Press a key to change the form color'
        goMyForm.BackColor=RGB(0,0,255)  &amp;&amp; Change the form background color
        WAIT WINDOW 'Press a key to release the form'
        RELEASE goMyForm  &amp;&amp; Release the form from memory
      </code>
    </example>
  </rgb>
  <right>
    <summary>
      Returns the specified number of rightmost characters from a character string.
    </summary>
    <param name="cExpression">

      Specifies the character expression whose rightmost characters are returned.

    </param>
    <param name="nCharacters">

      Specifies the number of characters returned from the character expression. RIGHT( ) returns the entire character expression if nCharacters is greater than the length of cExpression. RIGHT( ) returns an empty string if nCharacters is negative or 0.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      Characters are returned beginning with the last character on the right and continuing for a specified number of characters.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? RIGHT('Redmond, WA', 2)  &amp;&amp; Displays WA
      </code>
    </example>
  </right>
  <rlock>
    <summary>
      Attempts to lock a table record or records.
    </summary>
    <param name="cRecordNumberList">

      Specifies that RLOCK( ) attempts to lock multiple records. The character expression cRecordNumberList specifies one or more record numbers, separated by commas, that RLOCK( ) attempts to lock. For example, to attempt record locks on the first four records in a table, cRecordNumberList should contain 1, 2, 3, 4.
      To lock multiple records, you must have SET MULTILOCKS on and you must include the work area number (nWorkArea) or alias (cTableAlias) of the table in which you attempt to lock multiple records.
      You can also lock multiple records by moving the record pointer to the record you would like to lock, issuing RLOCK( ) or LOCK( ) and then repeating this process for additional records.
      In X#, you can specify 0 as a record number. Specifying 0 lets you attempt to lock the table header.
      Keep the table header locked for as short a time as possible because other users cannot add records to the table when the table header is locked.
      Release the table header lock with UNLOCK RECORD 0, UNLOCK, or UNLOCK ALL.
      If all the records specified in cRecordNumberList are successfully locked, RLOCK( ) returns true (.T.). If one or more of the records specified in cRecordNumberList cannot be locked, RLOCK( ) returns false (.F.) and locks none of the records. In either case, existing record locks remain in place. Multiple record locking is an additive process — placing additional record locks doesn't release existing record locks.
      From a performance perspective, it is always faster to lock the entire table than to lock even a small number of records.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      RLOCK( ) is identical to LOCK( ).
      Changes to explicitly locked records aren't saved until the record is unlocked or the record pointer is moved.
      If the lock or locks are successfully placed, RLOCK( ) returns true (.T.). Locked records are available for both read and write access by the user who placed the locks and for read-only access to all other users on the network.
      Executing RLOCK( ) doesn't guarantee that the attempted record lock or locks are successfully placed. A record lock cannot be placed on a record already locked by another user or in a table locked by another user. If the record lock or locks cannot be placed for any reason, RLOCK( ) returns false (.F.).
      By default, RLOCK( ) makes one attempt to lock a record. Use SET REPROCESS to automatically retry a record lock when the first attempt fails. SET REPROCESS controls the number of lock attempts or the length of time lock attempts are made when the initial lock attempt is unsuccessful. For more information about SET REPROCESS and table locking, see SET REPROCESS.
      SET MULTILOCKS determines whether you can lock multiple records in a table. If SET MULTILOCKS is off (the default), you can lock only a single record in a table. If SET MULTILOCKS is on, you can lock multiple records in a table. For more information, see SET MULTILOCKS.
      A table record can be unlocked only by the user who placed the lock. Record locks can be released by issuing UNLOCK, closing the table, or exiting X#.
      UNLOCK can be used to release record locks in the current work area, a specific work area or in all work areas. For more information, see UNLOCK.
      Switching SET MULTILOCKS from ON to OFF or from OFF to ON implicitly performs UNLOCK ALL. All record locks in all work areas are released.
      To close tables, use USE, CLEAR ALL, or CLOSE DATABASES.
      For more information about record and file locking and sharing tables on a network, see Programming for Shared Access.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        SET REPROCESS TO 3 AUTOMATIC
        STORE '1,2,3,4' TO gcRecList
        gcOldExc = SET('EXCLUSIVE')
        SET EXCLUSIVE OFF
        SELECT 0
        USE employee  &amp;&amp; Open Employee table
        SELECT 0
        USE customer  &amp;&amp; Open Customer table
        ? LOCK('1,2,3,4', 'customer')  &amp;&amp; Lock 1st 4 records in customer
        ? RLOCK(gcRecList, 'employee')  &amp;&amp; Lock 1st 4 records in employee
        UNLOCK IN customer
        UNLOCK IN employee
        SET EXCLUSIVE &amp;gcOldExc
      </code>
    </example>
  </rlock>
  <round>
    <summary>
      Returns a numeric expression rounded to a specified number of decimal places.
    </summary>
    <param name="nExpression">

      Specifies the numeric expression whose value is to be rounded.

    </param>
    <param name="nDecimalPlaces">

      Specifies the number of decimal places nExpression is rounded to.
      If nDecimalPlaces is negative, <b>ROUND( )</b> returns a whole number containing zeros equal in number to nDecimalPlaces to the left of the decimal point. For example, if nDecimalPlaces is –2, the first and second digits to the left of the decimal point in the value are 0.
    </param>
    <returns>
      Numeric data type. <b>ROUND( )</b> returns a value rounded to the nearest decimal position as specified by nDecimalPlaces.
    </returns>
    <remarks>

      <b>ROUND( )</b> disregards the number of decimal places specified by the <b>SET DECIMALS</b> command. To display a larger number of decimal places than specified by nDecimalPlaces in <b>ROUND( )</b>, use <b>SET FIXED ON</b> with <b>SET DECIMALS</b>.
    </remarks>
    <example>
       <code language="X#">
        SET DECIMALS TO 4
        SET FIXED ON
        CLEAR
        ? ROUND(1234.1962, 3) &amp;&amp; Displays 1234.1960
        ? ROUND(1234.1962, 2) &amp;&amp; Displays 1234.2000
        ? ROUND(1234.1962, 0) &amp;&amp; Displays 1234.0000
        ? ROUND(1234.1962, -1)  &amp;&amp; Displays 1230.0000
        ? ROUND(1234.1962, -2)  &amp;&amp; Displays 1200.0000
        ? ROUND(1234.1962, -3)  &amp;&amp; Displays 1000.0000
        SET FIXED OFF
        SET DECIMALS TO 2
      </code>
    </example>
  </round>
  <row>
    <summary>
      Included for backward compatibility. Use the CurrentX, CurrentY Properties.
       
      Returns the current row position of the cursor.
    </summary>
    <returns>
      Return value - Numeric
    </returns>
    <remarks>
      <br />
      ROW() is especially useful for directing screen output to a position relative to the current row position of the cursor.<br />
      <br />
      The special operator $ can be used in place of the ROW() function.<br />
      <br />

    </remarks>
    <example>











      <code language="X#">
        @ 5,5 SAY ' '
        @ ROW() + 6, COL() SAY 'Contact person'
        @ $ + 6, COL() SAY 'Contact person'
      </code>




    </example>
  </row>
  <rtod>
    <summary>
      Converts radians to its equivalent in degrees.
      You can use RTOD( ) when working with the X# trigonometric functions COS( ), SIN( ), and TAN( ).
    </summary>
    <param name="nExpression">

      Specifies a numeric expression representing a radian value.
    </param>
    <returns>
      Numeric data type. RTOD( ) returns the number of degrees converted from the number of radians.
    </returns>
    <remarks>
      To convert degrees to radians, use the DTOR( ) function.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? RTOD(ACOS(0))  &amp;&amp; Displays 90.00
        STORE -1 to gnArcAngle
        ? RTOD(ACOS(gnArcAngle))  &amp;&amp; Displays 180.00
        ? RTOD(ACOS(SQRT(2)/2)) &amp;&amp; Displays 45.00
      </code>
    </example>
  </rtod>
  <rtrim>
    <summary>
      Removes all trailing spaces or parsing characters from the specified character expression, or all trailing zero (0) bytes from the specified binary expression.
    </summary>
    <param name="cExpression">

      Specifies an expression of <b>Character</b> or <b>Varbinary</b> type to remove all trailing spaces or 0 bytes from, respectively.

    </param>
    <param name="nFlags">

      Specifies if trimming is case-sensitive when one or more parse characters (cParseChar, cParseChar2, … are included. Trimming is case-sensitive if nFlags is zero or is omitted. Trimming is case-insensitive if nFlags 1.

      cParseChar [, cParseChar2 [, ...]]
      Specifies one or more character strings that are trimmed from the end of cExpression. If cParseChar isn't included, then trailing spaces or 0 bytes are removed from Expression.
      <b>Note</b>   The maximum number of strings permitted in cParseChar is 23.
    </param>
    <returns>
      Character or Varbinary. <b>RTRIM( )</b> returns the specified expression without trailing spaces or parsing characters, or 0 bytes.
    </returns>
    <remarks>
      You can use <b>RTRIM( )</b> to ensure that trailing spaces or leading and trailing zero (0) bytes are removed from data entered by a user. <b>RTRIM( )</b> is identical to <b>TRIM( )</b>.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer  &amp;&amp; Opens Customer table
        CLEAR
        ? 'The contact for '+ RTRIM(company) + ' is ' + contact
      </code>
    </example>
  </rtrim>
  <scols>
    <summary>
      Returns the number of columns available in the main X# window.
    </summary>
    <returns>
      SCOLS( )Return Value
      Numeric
    </returns>
    <remarks>
      The value returned by SCOLS( ) depends on the current display mode. Display modes can be changed with SET DISPLAY.
    </remarks>
  </scols>
  <set>
    <summary>
      Returns the status of various <b>SET</b> commands.
    </summary>
    <param name="cSETCommand">

      Specifies a character expression of the <b>SET</b> command for which you want to return information. The current setting of the specified command is returned as a character or numeric string.
      1 | cExpression| 2 | 3 | 4
      Specifies additional information to return about a <b>SET</b> command. The values 1 and cExpression are identical. cExpression can be any expression that evaluates to a character type value.
      Including an argument does not return additional information for all <b>SET</b> commands. Only those that specify values of 1, 2, 3, or 4 in the following table return additional information.
      ALTERNATE
      ON or OFF
      ALTERNATE, 1
    </param>
    <param name="FileName">

    </param>
    <param name="FileName">

      ANSI
      ON or OFF
      ASSERTS
      AUTOINCERROR
      AUTOSAVE
      BELL, 1
    </param>
    <param name="cWAVFileName">

    </param>
    <param name="cWAVFileName">

      BLOCKSIZE
    </param>
    <param name="nBlockSize">

    </param>
    <param name="nBlockSize">

      BROWSEIME
      ON or OFF
      CARRY
      CENTURY
      CENTURY, 1
    </param>
    <param name="nCentury">

    </param>
    <param name="nCentury">

      CENTURY, 2
      ROLLOVER nYear
      CENTURY, 3
      System Regional Calendar setting
      CLASSLIB
    </param>
    <param name="cClassLibName">

    </param>
    <param name="cClassLibName">

      CLOCK
      ON or OFF
      CLOCK, 1
    </param>
    <param name="nRow and nColumn">

    </param>
    <param name="nRow and nColumn">
      COLLATE
      ON or OFF
      COLOR OF SCHEME
    </param>
    <param name="cR, cG, cB">

    </param>
    <param name="cR, cG, cB">

      COLOR SET
    </param>
    <param name="cNameOfColorSet">

    </param>
    <param name="cNameOfColorSet">

      COMPATIBLE
      ON or OFF
      COMPATIBLE, 1
      PROMPT or NOPROMPT
      CONFIRM
      CONSOLE
      COVERAGE
      COVERAGE, 1
    </param>
    <param name="FileName">

    </param>
    <param name="FileName">

      CPCOMPILE
    </param>
    <param name="nCodePage">

    </param>
    <param name="nCodePage">

      CPDIALOG
      ON or OFF
      CURRENCY
      LEFT or RIGHT
      CURRENCY, 1
    </param>
    <param name="cCurrencySymbol">

    </param>
    <param name="cCurrencySymbol">

      CURSOR
      ON or OFF
      DATABASE
    </param>
    <param name="cDatabase">

    </param>
    <param name="cDatabase">

      DATASESSION
    </param>
    <param name="nDataSession">

    </param>
    <param name="nDataSession">

      DATE
      AMERICAN, ANSI, BRITISH/FRENCH, GERMAN, ITALIAN, JAPAN, USA, MDY, DMY, or YMD
      DATE, 1
      Date Ordering:0 – MDY1 – DMY2 – YMD
      DEBUG
      ON or OFF
      DEBUGOUT
    </param>
    <param name="cFileName">

    </param>
    <param name="cFileName">

      DECIMALS
    </param>
    <param name="nDecimals">

    </param>
    <param name="nDecimals">

      DEFAULT
    </param>
    <param name="cDirectory">

    </param>
    <param name="cDirectory">

      DELETED
      ON or OFF
      DELIMITERS
      DELIMITERS, 1
    </param>
    <param name="cDelimiters">

    </param>
    <param name="cDelimiters">

      DEVELOPMENT
      ON or OFF
      DEVICE
      SCREEN, PRINTER, or FILE
      DEVICE, 1
    </param>
    <param name="cFileName">

    </param>
    <param name="cFileName">

      DIRECTORY
    </param>
    <param name="cDirectory">

    </param>
    <param name="cDirectory">

      DOHISTORY
      ON or OFF
      ENGINEBEHAVIOR
    </param>
    <param name="nVersionNumber">

    </param>
    <param name="nVersionNumber">

      ESCAPE
      ON or OFF
      EVENTLIST
      comma delimited list of events
      EVENTTRACKING
      EVENTTRACKING, 1
    </param>
    <param name="FileName">

    </param>
    <param name="FileName">

      EXACT
      ON or OFF
      EXCLUSIVE
      FDOW
    </param>
    <param name="nDayofWeek">

    </param>
    <param name="nDayofWeek">

      FIELDS
      ON or OFF
      FIELDS, 1
    </param>
    <param name="FieldName1, FieldName2, ...">

    </param>
    <param name="FieldName1, FieldName2, ...">
      FIELDS, 2
      LOCAL or GLOBAL
      FILTER
    </param>
    <param name="cFilterExpression">

    </param>
    <param name="cFilterExpression">

      FIXED
      ON or OFF
      FULLPATH
      FWEEK
    </param>
    <param name="nWeekNumber">

    </param>
    <param name="nWeekNumber">

      HEADINGS
      ON or OFF
      HELP
      HELP, 1
    </param>
    <param name="cFileName">

    </param>
    <param name="cFileName">

      HELP, 2
    </param>
    <param name="cCollectionURL">

    </param>
    <param name="cCollectionURL">

      HELP, 3
    </param>
    <param name="SYSTEM">

    </param>
    <param name="SYSTEM">

      HOURS
      12 or 24
      INDEX
    </param>
    <param name="cIndexExpression">

    </param>
    <param name="cIndexExpression">

      KEY
    </param>
    <param name="eExpression2, eExpression3">

    </param>
    <param name="eExpression2, eExpression3">
      KEY, 1
    </param>
    <param name="eExpression2">

    </param>
    <param name="eExpression2">

      KEY, 2
    </param>
    <param name="eExpression3">

    </param>
    <param name="eExpression3">

      KEYCOMP
      DOS or WINDOWS
      LIBRARY
    </param>
    <param name="cNameOfLibrary">

    </param>
    <param name="cNameOfLibrary">

      LOCK
      ON or OFF
      LOGERRORS
      MACKEY
    </param>
    <param name="cKey">

    </param>
    <param name="cKey">

      MARGIN
    </param>
    <param name="nMargin">

    </param>
    <param name="nMargin">

      MEMOWIDTH
    </param>
    <param name="nWidth">

    </param>
    <param name="nWidth">

      MESSAGE
    </param>
    <param name="nRow">

    </param>
    <param name="nRow">

      MESSAGE, 1
    </param>
    <param name="cMessageText">

    </param>
    <param name="cMessageText">

      MOUSE
      ON or OFF
      MOUSE, 1
    </param>
    <param name="nSensitivity">

    </param>
    <param name="nSensitivity">

      MULTILOCKS
      ON or OFF
      NEAR
      NOCPTRANS
      comma delimited list of fields
      NOTIFY
      NOTIFY, 1
      NULL
      NULLDISPLAY
    </param>
    <param name="cDisplayString">

    </param>
    <param name="cDisplayString">

      ODOMETER
    </param>
    <param name="nNumberOfRecords">

    </param>
    <param name="nNumberOfRecords">

      OLEOBJECT
      ON or OFF
      OPTIMIZE
      ORDER
      TAG TagName OF CDXFileName, IDXFileName, or blank
      PALETTE
      PATH
    </param>
    <param name="cPath">

    </param>
    <param name="cPath">

      PDSETUP
    </param>
    <param name="cPrinterDriverName">

    </param>
    <param name="cPrinterDriverName">

      POINT
    </param>
    <param name="cDecimalPtChar">

    </param>
    <param name="cDecimalPtChar">

      PRINTER
      ON or OFF
      PRINTER, 1
    </param>
    <param name="FileName or PortName">

    </param>
    <param name="FileName or PortName">
      PRINTER, 2
      Default Windows printer name
      PRINTER, 3
      Default X# printer name(specified in the X# Print or Print Setup dialog boxes)
      PROCEDURE
    </param>
    <param name="cPathAndName">

    </param>
    <param name="cPathAndName">

      READBORDER
      ON or OFF
      REFRESH
    </param>
    <param name="nSeconds1">

    </param>
    <param name="nSeconds1">

      REFRESH, 1
    </param>
    <param name="nseconds2">

    </param>
    <param name="nseconds2">

      REPORTBEHAVIOR
    </param>
    <param name="nVersionNumber">

    </param>
    <param name="nVersionNumber">

      REPROCESS
      Current session setting
      REPROCESS, 1
      System session setting
      REPROCESS, 2
      Current session setting type
      0 is returned if REPROCESS is set to attempts.
      1 is returned if REPROCESS is set to seconds.
      REPROCESS, 3
      System session setting type
      RESOURCE
      ON or OFF
      RESOURCE, 1
    </param>
    <param name="FileName">

    </param>
    <param name="FileName">

      SAFETY
      ON or OFF
      SECONDS
      SEPARATOR
    </param>
    <param name="cSeparatorChar">

    </param>
    <param name="cSeparatorChar">

      SPACE
      ON or OFF
      SQLBUFFERING
      STATUS
      STATUS BAR
      STRICTDATE
      SYSFORMATS
      SYSMENU
      ON, OFF, or AUTOMATIC
      TABLEPROMPT
      TABLEVALIDATE
    </param>
    <param name="nLevel">

    </param>
    <param name="nLevel">

      TALK
      ON or OFF
      TALK, 1
      WINDOW, NOWINDOW or WindowName
      TEXTMERGE
      TEXTMERGE, 1
    </param>
    <param name="cLeftDelimiter and cRightDelimiter">

    </param>
    <param name="cLeftDelimiter and cRightDelimiter">
      TEXTMERGE, 2
    </param>
    <param name="cFileName">

    </param>
    <param name="cFileName">

      TEXTMERGE, 3
      SHOW/NOSHOW
      TEXTMERGE, 4
      Evaluate source of TEXT ... ENDTEXT call and return TEXTMERGE nesting level.
      TOPIC
    </param>
    <param name="cHelpTopicName | lExpression">

    </param>
    <param name="cHelpTopicName | lExpression">
      TOPIC, 1
    </param>
    <param name="NContextID">

    </param>
    <param name="NContextID">

      UDFPARMS
      VALUE or REFERENCE
      UNIQUE
      ON or OFF
    </param>
    <returns>
      Character or Numeric data type. <b>SET( )</b> returns the value of a <b>SET</b> command.
    </returns>
    <remarks>

      <b>SET( )</b> recognizes the 4-character abbreviation for all X# <b>SET</b> keywords, with the exception of <b>HELPFILTER</b>, which can be abbreviated to 5 characters. For example, you can use <b>STAT</b> and <b>PRIN</b> for <b>SET STATUS </b><b>SET PRINTER</b>, respectively.
      The <b>SET( )</b> function is identical to <b>SYS(2001)</b>.
    </remarks>
  </set>
  <sin>
    <summary>
      Returns the sine of an angle.
    </summary>
    <param name="nExpression">

      Specifies an angle whose sine SIN( ) returns. nExpression can assume any value and the value returned by SIN( ) ranges between –1 and 1.
      nExpression is specified in radians. Use DTOR( ) to convert an angle from degrees to radians. The number of decimal places displayed by SIN( ) can be specified with SET DECIMALS.
    </param>
    <returns>
      Numeric
    </returns>
    <example>
       <code language="X#">
        CLEAR
        ? SIN(0)  &amp;&amp; Displays 0.00
        ? SIN(PI( )/2)  &amp;&amp; Displays 1.00
        ? SIN(DTOR(90))  &amp;&amp; Displays 1.00
      </code>
    </example>
  </sin>
  <skpbar>
    <summary>
      Determines if a menu item is enabled or disabled with SET SKIP OF.
    </summary>
    <param name="cMenuName">

      Specifies the name of the menu that contains the item.

    </param>
    <param name="MenuItemNumber">

      Specifies the number of the menu item whose status (enabled or disabled) SKPBAR( ) returns. The menu item number is assigned when the menu item is created with DEFINE BAR.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      SKPBAR( ) returns true (.T.) if the menu item is disabled, and false (.F.) if the menu item is enabled.
    </remarks>
  </skpbar>
  <skppad>
    <summary>
      Determines whether a menu title is enabled or disabled with SET SKIP OF.
    </summary>
    <param name="cMenuBarName">

      Specifies the name of the menu bar that contains the menu title.

    </param>
    <param name="cMenuTitleName">

      Specifies the name of the menu title whose status (enabled or disabled) SKPPAD( ) returns.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      SKPPAD( ) returns true (.T.) if the menu title is disabled, and false (.F.) if the menu title is enabled.
    </remarks>
  </skppad>
  <soundex>
    <summary>
      Returns a phonetic representation of the specified character expression.
    </summary>
    <param name="cExpression">

      Specifies the character expression SOUNDEX( ) evaluates.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      SOUNDEX( ) returns a four-character string. By comparing the results SOUNDEX( ) returns for two character expressions, you can determine if the two expressions are phonetically similar, indicating that they sound alike. This can be useful when searching for duplicate records in a table.
      SOUNDEX( ) isn't case sensitive and generally disregards vowels.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? SOUNDEX('Smith') = SOUNDEX('Smyth')  &amp;&amp; Displays .T.
        ? SOUNDEX('Computer')  &amp;&amp; Displays C513
      </code>
    </example>
  </soundex>
  <space>
    <summary>
      Returns a character string composed of a specified number of spaces.
    </summary>
    <param name="nSpaces">

      Specifies the number of spaces that SPACE( ) returns. The maximum value of nSpaces is limited only by memory in X#.
    </param>
    <returns>
      Character
    </returns>
  </space>
  <sqrt>
    <summary>
      Returns the square root of the specified numeric expression.
    </summary>
    <param name="nExpression">

      Specifies the numeric expression SQRT( ) evaluates. nExpression cannot be negative.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The number of decimal places in the value returned by SQRT( ) is the larger of the current decimal place setting and the number of decimal places contained in nExpression. The current decimal place setting is specified with SET DECIMALS.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? SQRT(4)  &amp;&amp; Displays 2.00
        ? SQRT(2*SQRT(2))  &amp;&amp; Displays 1.68
      </code>
    </example>
  </sqrt>
  <srows>
    <summary>
      Returns the number of rows available in the main X# window.
    </summary>
    <returns>
      SROWS( )Return Value
      Numeric
    </returns>
    <remarks>
      In X# for Windows, the value returned by SROWS( ) depends on the current display mode. The display mode can be changed with SET DISPLAY.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? SROWS( )
      </code>
    </example>
  </srows>
  <str>
    <summary>
      Returns the character equivalent of a numeric expression.
    </summary>
    <param name="nExpression">

      Specifies the numeric expression to evaluate.

    </param>
    <param name="nLength">

      Specifies the length of the character string returned. If nLength is omitted, nLength defaults to 10 characters.
      If the expression contains a decimal point, the length includes one character for the decimal point and one character for each digit in the character string.

    </param>
    <param name="nDecimalPlaces">

      Specifies the number of decimal places in the character string returned. To specify the number of decimal places using nDecimalPlaces, you must include nLength. If nDecimalPlaces is omitted, the number of decimal places defaults to zero (0).
      X# contains a limit of 16 digits of precision in numeric calculations. For more information about numeric precision in X#, see X# System Capacities.
    </param>
    <returns>
      Character data type. <b>STR( )</b> returns a character string equivalent to the specified numeric expression.
      Depending on certain conditions, <b>STR( )</b> can return the following:
      If you specify fewer decimal places than exist in nExpression, the return value is rounded up. To round results to the nearest decimal place instead of upward, include the <b>ROUND( )</b> function. For more information, see ROUND( ) Function.
      If nExpression is an integer, and nLength is less than the number of digits in nExpression, <b>STR( )</b> returns a string of asterisks, indicating numeric overflow.
      If nExpression contains a decimal point, and nLength is equal to or less than the number of digits to the left of the decimal point, <b>STR( )</b> returns a string of asterisks, indicating numeric overflow.
      If nLength is greater than the length of the value evaluated by nExpression, <b>STR( )</b> returns a character string padded with leading spaces.
      If nExpression has <b>Numeric</b> or <b>Float</b> type, and nLength is less than the number of digits in nExpression, and , <b>STR( )</b> returns a value using scientific notation.
      In the following example, <b>STR( )</b> evaluates 1.154994 as a character expression, specifies a length of 8 characters and the same number of decimal places that the specified expression contains, and displays 1.154994 using the <b>?</b> command.
       <code language="X#">? STR(1.154995,8,6)</code>
      In the following example, <b>STR( )</b> evaluates 1.154994 as a character expression and specifies a length of 8 characters and 2 decimal places, four fewer decimal places than the specified expression contains. <b>STR( )</b> displays 1.16 using the <b>?</b> command, which represents 1.154994 rounded upward.
       <code language="X#">? STR(1.154995,8,2)</code>
      In the following example, <b>STR( )</b> includes the <b>ROUND( )</b> function, evaluates 1.154994 as a character expression, and specifies a length of 8 characters 2 decimal places, four fewer decimal places than the specified expression contains. <b>STR( )</b> displays 1.15 using the <b>?</b> command, which represents 1.154994, rounded to the nearest significant digit.
       <code language="X#">? STR(ROUND(1.154995,2),8,2)</code>
    </returns>
  </str>
  <strtran>
    <summary>
      Searches a character expression or memo field for a second character expression or memo field and replaces each occurrence with a third character expression or memo field. You can specify where the replacement begins and how many replacements are made.
    </summary>
    <param name="cSearched">

      Specifies the character expression to search. cSearched can be a memo field, a blob field, or a varbinary expression.

    </param>
    <param name="cExpressionSought">

      Specifies the character expression to search for in cSearched. The search is case-sensitive. cExpressionSought can be a memo field, a blob field, or a varbinary expression.
      cReplacement
      Specifies the character expression to replace every occurrence of cExpressionSought in cSearched. Omitting cReplacement replaces every occurrence of cExpressionSought with an empty string. cReplacement can also be a memo field, a blob field, or a varbinary expression.
      nStartOccurrence
      Specifies which occurrence of cExpressionSought to replace first.
      For example, if nStartOccurrence is 4, replacement begins with the fourth occurrence of cExpressionSought in cSearched and the first three occurrences of cExpressionSought remain unchanged. Omitting nStartOccurrence defaults the occurrence where replacement begins to the first occurrence of cExpressionSought.
      nNumberOfOccurrences
      Specifies the number of occurrences of cExpressionSought to replace. Omitting nNumberOfOccurrences replaces all occurrences of cExpressionSought, starting with the occurrence specified with nStartOccurrence.
      If you need to specify only the nFlags setting along with the required parameters, specify empty string for the cReplacement and –1 for the optional numeric parameters you want disregarded.
      nFlags
      Specifies the case-sensitivity of a search according to the following values.
      The following table lists the values for nFlags:
    </param>
    <param name="nFlags">
      0
      Search is case-sensitive and replacement is performed with exact cReplacement text. (Default)
      This setting specifies the original behavior for <b>STRTRAN( )</b> in versions prior to X# 7.0.br
      You can also specify default behavior by passing –1 as the nFlags value.
      &amp;nbsp;
      Search is case-insensitive and replacement is performed with exact cReplacement text.
      2
      Search is case-sensitive and replacement is performed with the case of cReplacement changed to match the case of the string found.
      3
      Search is case-insensitive and replacement is performed with the case of cReplacement changed to match the case of the string found.
      The case of cReplacement changes only if the string found is all uppercase, lowercase, or proper case.
    </param>
    <returns>
      Character or Varbinary.br
      <b>STRTRAN( )</b> returns the resulting character or varbinary string. The Result data type is derived by the first parameter data type.
    </returns>
    <example>
       
      <code language="X#">
        STORE 'abracadabra' TO gcString
        ? STRTRAN(gcString, 'a', 'z')
        ? STRTRAN(gcString, 'a', 'q', 2, 3)
      </code>
       
      <code language="X#">
        ? STRTRAN(gcString, 0h61, 0h7A)
        ? STRTRAN(0h + gcString, 'a', 0h7A)         &amp;&amp; This command shows parameters data type variability and returns varbinary string
        ? STRTRAN(0h1234567890, 0h5678, 0h876543)   &amp;&amp; Returns 0h123487654390
      </code>
    </example>
  </strtran>
  <stuff>
    <summary>
      Returns a character string created by replacing a specified number of characters in a character expression with another character expression.
    </summary>
    <param name="cExpression">

      Specify the character expression in which the replacement occurs.

    </param>
    <param name="nStartReplacement">

      Specifies the position in cExpression where the replacement begins.

    </param>
    <param name="nCharactersReplaced">

      Specifies the number of characters to be replaced. If nCharactersReplaced is 0, the replacement string cReplacement is inserted into cExpression.

    </param>
    <param name="cReplacement">

      Specifies the replacement character expression. If cReplacement is the empty string, the number of characters specified by nCharactersReplaced are removed from cExpression.
    </param>
    <returns>
      Character
    </returns>
    <example>
       <code language="X#">
        STORE 'abcdefghijklm' TO gcString1
        STORE '12345' TO gcString2
        CLEAR
        ? STUFF(gcString1, 4, 0, gcString2)     &amp;&amp; insert
        ? STUFF(gcString1, 4, 3, gcString2)     &amp;&amp; replace
        ? STUFF(gcString1, 4, 6, '')     &amp;&amp; delete
        ? STUFF(gcString1, 4, 1, gcString2)     &amp;&amp; replace and insert
        ? STUFF(gcString1, 4, 4, gcString2)     &amp;&amp; replace and delete
        ? STUFF(gcString1, 4, LEN(gcString1), gcString2)   &amp;&amp; replace, delete rest
      </code>
    </example>
  </stuff>
  <substr>
    <summary>
      Returns a character string from the given character expression or memo field, starting at a specified position in the character expression or memo field and continuing for a specified number of characters.
    </summary>
    <param name="cExpression">

      Specifies the character expression or memo field from which the character string is returned.

    </param>
    <param name="nStartPosition">

      Specifies the position in the character expression or memo field cExpression from where the character string is returned. The first character of cExpression is position 1.
      If nStartPosition is greater than the number of characters in cExpression, <b>SUBSTR( )</b><b> </b>returns an empty string ("").

    </param>
    <param name="nCharactersReturned">

      Specifies the number of characters to return from cExpression. If you omit nCharactersReturned, characters are returned until the end of the character expression is reached.
    </param>
    <returns>
      Character. <b>SUBSTR( )</b> returns a character string.
      <b>SUBSTR( )</b> will not return a value for a memo field when issued in the Debug window. To return a value in the Debug window, place the memo field name within <b>ALLTRIM( )</b>, and place <b>ALLTRIM( )</b> within <b>SUBSTR( )</b>.
    </returns>
    <remarks>
      When using <b>SUBSTR( )</b> with memo fields in a SQL <b>SELECT</b> command, include the <b>PADR( )</b> function in <b>SUBSTR( )</b> so that empty or variable length memo fields produce consistent results when converted to character strings.
    </remarks>
    <example>
       <code language="X#">
        STORE 'abcdefghijklm' TO myString
        CLEAR
        ? SUBSTR(myString, 1, 5)
        ? SUBSTR(myString, 6)
      </code>
    </example>
  </substr>
  <tan>
    <summary>
      This trigonometric function returns the tangent of an angle.
    </summary>
    <param name="nExpression">

      Specifies the angle in radians for which TAN( ) returns the tangent. To convert an angle from degrees to radians, use DTOR( ). The number of decimal places returned by TAN( ) can be specified with SET DECIMALS.
    </param>
    <returns>
      Numeric
    </returns>
    <example>
       <code language="X#">
        CLEAR
        ? TAN(0)  &amp;&amp; Displays 0.00
        ? TAN(PI( )/4)  &amp;&amp; Displays 1.00
        ? TAN(PI( )*3/4)  &amp;&amp; Displays -1.00
      </code>
    </example>
  </tan>
  <time>
    <summary>
      Returns the current system time in 24-hour, eight-character string (hh:mm:ss) format.
    </summary>
    <param name="nExpression">

      The time returned includes hundredths of a second if nExpression is included. The numeric expression nExpression can be any value. However, the actual maximum resolution is about 1/18 second. Use SECONDS( ) for greater resolution.
    </param>
    <returns>
      Character
    </returns>
  </time>
  <transform>
    <summary>
      Returns a character string from an expression in a format determined by a format code.
      Using <b>TRANSFORM( )</b> with a large negative number that contains a decimal might result in numeric overflow when that number is passed in as a memory variable. You should use the <b>STR( )</b> function instead with such numbers.
    </summary>
    <param name="eExpression">

      Specifies the expression to format.

    </param>
    <param name="cFormatCodes">

      Specifies one or more format codes that determine how to format the expression.
      The following table lists the available format codes for cFormatCodes.
      @B
      Left-justifies <b>Numeric</b> data within the display region.
      @C
      Appends a CR to positive <b>Currency</b> or <b>Numeric</b> values to indicate a credit.
      @D
      Converts <b>Date</b> and <b>DateTime</b> values to the current <b>SET DATE</b> format.
      @E
      Converts <b>Date</b> and <b>DateTime</b> values to a BRITISH date format.
      @L
      Pads numeric data with leading zeroes.
      @R
      The transformation uses a format mask. The mask characters are not stored to the transformed value. Use only with character or numeric data. Mask characters include:
      9 or #   Represents a character or number.
      !   Converts lower-case letters to uppercase letters.
      X# does not display specified mask characters that exceed the converted string length of the passed expression.
      @T
      Trims leading and trailing spaces from character values.
      @X
      Appends DB to negative currency or numeric values to indicate a debit.
      @YL
      Use Long Date system setting.
      @YS
      Use Short Date system setting.
      @Z
      If 0, converts currency or numeric values to spaces.
      @(
      Encloses negative currency or numeric values in parentheses.
      @^
      Converts currency or numeric values to scientific notation.
      @0
      Converts numeric or currency values to their hexadecimal equivalents. The numeric or currency value must be positive and less than 4,294,967,296.
      @!
      Converts an entire character string to uppercase.
      @$
      Adds the current currency symbol specified by <b>SET</b><b> </b><b>CURRENCY</b> to currency and numeric values. By default, the symbol is placed immediately before or after the value. However, the currency symbol and its placement (specified with <b>SET CURRENCY</b>), the separator character (specified with <b>SET SEPARATOR</b>) and the decimal character (specified with <b>SET POINT</b>) can all be changed.
      Specifies the width of character values. For example, if cFormatCodes is 'XX', 2 characters are returned.
      Converts logical True (.T.) and False (.F.) values to Y and N, respectively.
      Converts a lowercase character to uppercase in the corresponding position in a character string.
      Specifies the decimal point position in currency and numeric values.
      Separates digits to the left of the decimal point in currency and numeric values.
      Specifies width of numeric values.
      For example, if cFormatCodes is '999.99', the numeric characters are formatted with three characters to the left of the decimal point, and two characters to the right.
      When specifying cFormatCodes for numeric values, the format code must be at least the size of the value you want to display.
      The following example shows the results when the format code is missing, less than, and equal to the size of the value you want to display.
       <code language="X#">
        CREATE CURSOR myCursor (col1 n(5,2))
        INSERT INTO myCursor VALUES (-555.5)
        * No format code and returns **.**
        ? TRANSFORM(myCursor.col1 )
        * A format code 1 less than value returns ***.**
        ? TRANSFORM(myCursor.col1,'999.99' )
        * A format code same size as value returns -556.00
        ? TRANSFORM(myCursor.col1,'9999.99' )
      </code>
      When the expression value is longer than the width of the numeric field, X# forces the value to fit by performing the following steps:
      Truncate decimal places and round the remaining decimal portion of the field.
      If the value does not fit, store the field contents using scientific notation.
      If the value still does not fit, replace the field contents with asterisks.
      For more information about format codes, see InputMask Property and Format Property.
      If you omit cFormatCodes, X# performs a default transformation on eExpression. The following table describes the transformation performed for each data type eExpression can assume.
      <b>Blob</b>

      Outputs character string representation of the binary value without the hexadecimal prefix. For example, the following line of code outputs the character string "FEOAF2":
       <code language="X#">TRANSFORM(0hFE0AF2)</code>
      For binary values, <b>TRANSFORM(</b> <b>)</b> disregards format codes except for those that restrict width. For example, the following lines of code output "FE0A":
       <code language="X#">
        TRANSFORM(0hFE0AF2, "XXXX")
        TRANSFORM(0hFE0AF2, "9999")
        TRANSFORM(0hFE0AF2, "####")
      </code>
      For those format codes that restrict width, the maximum output length is 255 characters.
      <b>Character</b>
      Performs no transformation.
      Transformation is determined by the settings specified in the Regional tab of the Options dialog box.
      Performs a <b>DTOC( )</b> transformation on the date.
      Performs a <b>TTOC( )</b> transformation on the date time.
      <b>General</b>
      Returns "Gen" if the <b>General</b> field contains an object or "gen" if the <b>General</b> field does not contain an object.
      <b>Logical</b>
      Transforms logical True (.T.) and False (.F.) values to the character strings ".T." and ".F." respectively.
      <b>Memo</b>
      <b>Numeric</b> (includes <b>Double</b>, <b>Float</b>, or <b>Integer</b> data types)
      Removes trailing zeros from the decimal portion of a numeric value when all the numbers following the decimal point are zeros.
      If the numeric value is a whole number, a decimal point is not included in the transformed value, for example, 4.0 is transformed to 4.
      If the numeric value is less than one but greater than negative one, zero is included before the decimal point, for example, .4 is transformed to 0.4.
      Object
      Returns the character string "(Object)".
      <b>Varbinary</b>
      For binary values, <b>TRANSFORM( )</b> disregards format codes except for those that restrict width. For example, the following lines of code output "FE0A":
    </param>
    <returns>
      Character data type. <b>TRANSFORM( )</b> returns character string from an expression in a format determined by a format code.
    </returns>
    <example>
       <code language="X#">
        STORE 12.34 TO gnPrice
        CLEAR
        ? TRANSFORM(gnPrice, '$$$$.99')  &amp;&amp; Displays $12.34
        ? TRANSFORM(_SCREEN)   &amp;&amp; Displays (Object)
      </code>
    </example>
  </transform>
  <trim>
    <summary>
      Removes all trailing spaces or parsing characters from the specified character expression, or all trailing zero (0) bytes from the specified binary expression.
    </summary>
    <param name="cExpression">

      Specifies an expression of <b>Character</b> or <b>Varbinary</b> type to remove all trailing spaces or 0 bytes from, respectively.

    </param>
    <param name="nFlags">

      Specifies if trimming is case-sensitive when one or more parse characters (cParseChar, cParseChar2, … are included. Trimming is case-sensitive if nFlags is zero or is omitted. Trimming is case-insensitive if nFlags 1.

      cParseChar [, cParseChar2 [, ...]]
      Specifies one or more character strings that are trimmed from the end of cExpression. If cParseChar isn't included, then trailing spaces or 0 bytes are removed from Expression.
      <b>Note</b>   The maximum number of strings permitted in cParseChar is 23.
    </param>
    <returns>
      Character or Varbinary. <b>TRIM( )</b> returns the specified expression without trailing spaces or parsing characters, or 0 bytes.
    </returns>
    <remarks>

      <b>TRIM( )</b> is identical to <b>RTRIM( )</b>.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer  &amp;&amp; Opens Customer table
        CLEAR
        ? 'The contact for '+ TRIM(company) + ' is ' + contact
      </code>
    </example>
  </trim>
  <type>
    <summary>
      Returns the data type of an expression.
      <b>VARTYPE( )</b> is similar to the <b>TYPE( )</b> function, but <b>VARTYPE( )</b> is faster and does not require quotation marks ("") to enclose the specified expression.
    </summary>
    <param name="cExpression">

      Specifies the expression, which can be a variable, array, field, memo field, or other expression, for which  the data type is returned.
      You must pass the expression as a character string by enclosing the expression with quotation marks (""). If you do not enclose the expression with quotation marks, <b>TYPE( )</b> evaluates the contents of the expression.

    </param>
    <param name="1">

      Include the optional parameter 1 to determine if cExpression is an array or a Collection Class. COM objects are not supported with the 1 parameter.
    </param>
    <returns>
      Character. <b>TYPE( )</b> returns a character representing the data type of the specified expression.
      The following table lists the character values that <b>TYPE( )</b> returns and their corresponding data types.
      A

      <b>Array (only returned when the optional 1 parameter is included)</b>

      C

      <b>Character</b>, <b>Varchar</b>, <b>Varchar</b> (Binary)
      If the optional 1 parameter is included, a return value of C indicates that the data type is a collection.
      D

      <b>Date</b>

      G

      <b>General</b>

      L

      <b>Logical</b>

      M

      <b>Memo</b>

      N

      <b>Numeric</b>, <b>Float</b>, <b>Double</b>, or <b>Integer</b>
      O
      Object
      Q

      <b>Varbinary</b>

      S
      Screen
      The Screen type is created when using the <b>SAVE SCREEN</b> command. For more information, see SAVE SCREEN Command.
      T

      <b>DateTime</b>

      U
      Undefined type of expression or cannot evaluate expression.
      If the optional 1 parameter is included, a return value of U indicates that the data type is not an array.
      W

      <b>Blob</b>

      Y

      <b>Currency</b>

    </returns>
    <remarks>
      If you pass an array as a parameter to <b>TYPE( )</b>, the data type returned corresponds to the first element in the array. If you want to check the data type for a specific array element, you must specify that element in the parameter. For example:
       <code language="X#">? TYPE("myarray[3]")</code>
      You can also use the <b>TYPE( )</b> function to check if a memory variable is an array. For example:
       <code language="X#">? TYPE("myarray[1]")#"U"</code>
      <b>TYPE( )</b> cannot be used to evaluate UDFs (user-defined functions).
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        USE customer  &amp;&amp; Opens Customer table
        nTest = 1.01
        cTest = "String"
        CLEAR
        ? TYPE('customer.contact')  &amp;&amp; Displays C
        ? TYPE('(12 * 3) + 4')  &amp;&amp; Displays N
        ? TYPE('DATE( )')  &amp;&amp; Displays D
        ? TYPE('.F. OR .T.')  &amp;&amp; Displays L
        ? TYPE('ANSWER=42')  &amp;&amp; Displays U
        ? TYPE('$19.99')  &amp;&amp; Displays Y
        ? TYPE('nTest')  &amp;&amp; Displays N
        ? TYPE('cTest')  &amp;&amp; Displays C
      </code>
    </example>
  </type>
  <unbindevents>
    <summary>
      You can use <b>UNBINDEVENTS( )</b> to unbind, or detach, an event that was originally bound to a X# object using <b>BINDEVENT( )</b>. To detach events from Component Object Model (COM) objects, use the <b>EVENTHANDLER( ) </b>function. There are three versions of the syntax.
    </summary>
    <param name="oEventSource">

      Specifies the event source, which must be a valid X# object.

    </param>
    <param name="oEventObject">

      Specifies an object reference, which can be used as the event source or event handler.

    </param>
    <param name="cEvent">

      Specifies the name of the event, method, or property you want to unbind.

    </param>
    <param name="oEventHandler">

      Specifies the object that is handling the event.

    </param>
    <param name="cDelegate">

      Specifies the delegate method handling the event for oEventHandler.

    </param>
    <param name="hWnd">

      Specifies the integer handle of the window for which events are unbound.
      If hWnd is 0, all hWnds are unbound.
      If the nMessage parameter isn't included, then all Windows message bindings for the window handle hWnd are unbound.

    </param>
    <param name="nMessage">

      Specifies a valid Windows message (Win Msg) that is unbound. See MSDN (the Microsoft Developer Network) for information about Windows messages.
    </param>
    <returns>
      Numeric data type.<b> UNBINDEVENTS( )</b> returns the number of events that are unbound if unbinding succeeds. <b>UNBINDEVENTS( )</b> returns a value of 0 if no events exist for unbinding. X# generates an error if <b>UNBINDEVENTS( )</b> fails to unbind events that are available for unbinding.
    </returns>
    <remarks>
      The following table describes the ways you can use <b>UNBINDEVENTS( )</b>.

      codeUNBINDEVENTS(oEventSource, cEvent, oEventHandler, cDelegate)/code

      Unbinds a specific event from an event handler.

      codeUNBINDEVENTS(oEventObject)/code

      Unbinds all events associated with this object. This includes events that are bound to it as an event source and its delegate methods that serve as event handlers.

      codeUNBINDEVENTS(hWnd [, nMessage])/code

      Unbinds all or specific Windows Message (Win Msg) events.
      If an event is occurring, and <b>UNBINDEVENTS( )</b> or the delegate method handling the event is called, the event and its delegate method finish running before <b>UNBINDEVENTS( )</b> unbinds the event.
      You can call the <b>AEVENTS( )</b> function retrieve information about all the events and delegate methods attached to a particular object.
    </remarks>
    <example>
       <code language="X#">
        PUBLIC oHandler
        oHandler=NEWOBJECT("myhandler")
        DO (_browser)
        BINDEVENT(_SCREEN,"Resize",oHandler,"myresize")
        UNBINDEVENTS(_SCREEN,"Resize",oHandler,"myresize")
        DEFINE CLASS myhandler AS Session
        PROCEDURE myresize
        _obrowser.left = _SCREEN.Width - _obrowser.width
        RETURN
        ENDDEFINE
      </code>
    </example>
  </unbindevents>
  <updated>
    <summary>
      Included for backward compatibility. Use the InteractiveChange Event or ProgrammaticChange Event instead.
       
      Returns true (.T.) if you changed any data during the most recent READ.
    </summary>
    <returns>
      Return value - Logical
    </returns>
    <remarks>
      <br />
      UPDATED() returns true if the data in a field, spinner or text editing region was changed or if a choice was made from a check box; an invisible, push or radio button; a list; or a popup.  <br />
      <br />
      UPDATED() returns false (.F.) if the data in a field, spinner or text-editing region wasn't changed or no choices were made from a check box, an invisible, push or radio button, a list, or a popup during the most recent READ. UPDATED() returns false if a control was updated from within a program (for example, with REPLACE or SHOW GETS).<br />
      <br />

    </remarks>
  </updated>
  <upper>
    <summary>
      Returns the specified character expression in uppercase.
    </summary>
    <param name="cExpression">

      Specifies the character expression UPPER( ) converts to uppercase.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      Each lowercase letter (a – z) in the character expression is converted to uppercase (A – Z) in the returned string. This is true for high-ASCII characters as well, even if the current font does not display them as lowercase accented characters.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? UPPER('abcdefgh')  &amp;&amp; Displays ABCDEFGH
      </code>
    </example>
  </upper>
  <used>
    <summary>
      Determines if an alias is in use or a table is open in a specific work area.
    </summary>
    <returns>
      Logical
    </returns>
    <remarks>
      USED( ) can determine if an alias is in use or if a table is open in a specific work area.
    </remarks>
    <example>
       <code language="X#">
        CLOSE DATABASES
        OPEN DATABASE (HOME(2) + 'Data\testdata')
        SELECT A
        USE customer  &amp;&amp; Opens Customer table
        SELECT B
        USE orders  &amp;&amp; Opens Orders table
        SELECT C
        USE employee  &amp;&amp; Opens Employee table
        ? USED('A')  &amp;&amp; Displays .T.
        ? USED('B')  &amp;&amp; Displays .T.
        ? USED(4)  &amp;&amp; Displays .F.
      </code>
    </example>
  </used>
  <val>
    <summary>
      Returns a numeric or currency value from a character expression composed of numbers. You can use <b>VAL( )</b> to convert the character strings returned by the X# <b>SYS( )</b> functions to numeric values.
    </summary>
    <param name="cExpression">

      Specifies a character expression composed of up to 16 numbers. Rounding occurs if more than 16 numbers are included in cExpression.
      If the first character of cExpression is a dollar sign ($),<b>VAL( ) </b>returns a currency value. In all other situations <b>VAL( )</b> returns a numeric value.
    </param>
    <returns>
      Numeric or Currency data type. <b>VAL( )</b> returns the numbers in the character expression from left to right until a non-numeric character is encountered. Leading blanks are ignored. <b>VAL( )</b> returns 0 if the first character of the character expression is not a number, a dollar sign ($), a plus sign (+), or minus sign (-). You can control the result of VAL( ) by issuing the SET DECIMALS command before using the VAL( ) function.
    </returns>
    <example>
       <code language="X#">
        CLEAR
        STORE '12' TO A
        STORE '13' TO B
        ? VAL(A) + VAL(B)  &amp;&amp; Displays 25.00
        STORE '1.25E3' TO C
        ? 2 * VAL(C)  &amp;&amp; Displays 2500.00
      </code>
    </example>
  </val>
  <varread>
    <summary>
      Included for backward compatibility in X#. Use the ControlSource Property or Name Property (X#) instead.
       
      Returns in uppercase the name of the memory variable, array element, or field used to create the current @ ... GET field or control.
    </summary>
    <returns>
      Return value - Character
    </returns>
    <remarks>
      <br />
      Controls include check boxes, fields, invisible, push or radio buttons, lists, popups, spinners, and text-editing regions.<br />
      <br />
      If a Browse, Change or Edit window is active, the name of the current field is returned with the first letter of the field name capitalized.<br />
      <br />
      VARREAD() is identical to SYS(18). Both can be used to pass the current field or control name to a procedure that in turn can provide context-sensitive help, as in the following example.<br />
      <br />

    </remarks>
    <example>











      <code language="X#">
        SET TALK OFF
        CLOSE DATABASES
        ON KEY LABEL F1 DO Help WITH VARREAD()
        USE customer
        SCATTER TO temp
        DEFINE WINDOW input FROM 6,10 to 18,70 PANEL
        ACTIVATE WINDOW input
        @ 1,3  SAY 'Customer: ' GET company
        @ 3,3  SAY 'Address: '  GET address
        @ 5,3  SAY 'City: '     GET city
        @ 7,3  SAY 'State: '    GET state
        @ 7,18 SAY 'Zip: '      GET zip
        @ 9,7  SAY 'Press Esc to cancel or F1 for help'
        READ
        GATHER FROM temp
        DEACTIVATE WINDOW input
        RELEASE WINDOW input
        ON KEY LABEL F1
        RETURN
        *** Help Procedure ***
        PROCEDURE Help
        PARAMETERS fieldname
        DO CASE
        CASE fieldname = 'COMPANY'
        WAIT WINDOW 'Enter the company name' NOWAIT
        CASE fieldname = 'ADDRESS'
        WAIT WINDOW 'Enter the street address' NOWAIT
        CASE fieldname = 'CITY'
        WAIT WINDOW 'Enter the city name' NOWAIT
        CASE fieldname = 'STATE'
        WAIT WINDOW 'Enter a two-character state abbreviation' NOWAIT
        CASE fieldname = 'ZIP'
        WAIT WINDOW 'Enter the five-digit Zip code' NOWAIT
        ENDCASE
        RETURN
      </code>




    </example>
  </varread>
  <version>
    <summary>
      Returns information about the X# version you are using.
    </summary>
    <param name="nExpression">

      Specifies that <b>VERSION( )</b> returns additional information about X#. If you omit nExpression, <b>VERSION( )</b> returns the X# version number.
      The following table lists values for nExpression and the additional X# information returned.
      1
      X# date and serial number.
      2
      X# version type:
      0 - Run time version
      1 - Standard Edition (earlier versions)
      2 - Professional Edition (earlier versions)
      3
      Localized X# language. The following two character values indicate the language for which X# is localized:
      00 - English
      07 - Russian
      33 - French
      34 - Spanish
      39 - Czech
      48 - German
      55 - Korean&amp;nbsp; 42 - Czechbr49 - Germanbr82 - Korean
      86 - Simplified Chinese
      88 - Traditional Chinese
      The X# version number in a standard, easily parsed format.
      For versions prior to X# 8.0, the standard format is "MM.mm.0000.DDDD" where MM is the major release number, mm is the incremental minor revision number, 0000 is a fixed placeholder, and DDDD is the four digit product date for the day the version was created.
      For X# 8.0, the formula for calculating the product date, DDDD, is 8000 + number of days since the beginning of 1998. For example, 8397 corresponds to February 1, 1999.
      For X# 9.0, the formula for calculating the product date, DDDD, is number of months since January 1, 2003 concatenated with the day of the current month. For example, 2215 corresponds to October 15, 2004.
      The format for X# 8.0 and 9.0 is "MM.mm.0000.NNNN" where MM is the major release number, mm is the incremental minor revision number, 0000 is a fixed placeholder, and NNNN is the build number.
      The X# release version in the format Mmm where M is the major release number and mm is the incremental minor revision number. For example, VERSION(5) returns 700 in X# 7.0.
    </param>
    <returns>
      Character, Numeric
    </returns>
    <remarks>
      Use <b>VERSION( )</b> to conditionally execute version-specific portions of code.
      VERSION( ), VERSION(1), VERSION(3), and VERSION(4) return character strings; VERSION(2) and VERSION(5) return numeric values.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? <b>VERSION( )</b>
        ? <b>VERSION(</b>1<b>)</b>
        ? <b>VERSION(</b>2<b>)</b>
        ? <b>VERSION(</b>3<b>)</b>
        ? <b>VERSION(</b>4<b>)</b>
        ? <b>VERSION(</b>5<b>)</b>
      </code>
    </example>
  </version>
  <wborder>
    <summary>
      Determines whether the active or specified window has a border.
    </summary>
    <param name="WindowName">

      Specifies the name of the window for which WBORDER( ) returns a logical value.
      WBORDER( ) returns a logical value for the active output window if you omit a window name.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      WBORDER( ) returns true (.T.) if the specified window has a border; otherwise WBORDER( ) returns false (.F.). By default, windows have borders. Include the NONE clause in DEFINE WINDOW to create a window without a border.
    </remarks>
  </wborder>
  <wchild>
    <summary>
      Returns either the number of child windows in a parent window or the names of the child windows in the order in which they are stacked in the parent window.
    </summary>
    <param name="WindowName">

      Specifies a window other than the active output window for which WCHILD( ) returns the number of child windows. The number of child windows in the specified window is returned if you include just a window name without the numeric expression nChildWindow.
      If you include both WindowName and nChildWindow, WCHILD( ) returns the names of the child windows in the specified window. If you include both WindowName and nChildWindow, separate WindowName and nChildWindow with a comma.
      You can also include the empty string in WindowName to specify the main X# window.

    </param>
    <param name="nChildWindow">

      Specifies a numeric expression included to return the names of child windows in the active output window when you omit WindowName.
      The numeric expression nChildWindow can be 0 or any positive value. The name of the child window at the bottom of the stack of child windows in the current output window is returned if nChildWindow is 0.
      If nChildWindow is a positive number, WCHILD( ) returns the name of the next child window in the window stack. The name of next child window in the stack is returned if you issue WCHILD( ) again with a positive number, and so on. The empty string is returned if WCHILD( ) is called more times than the number of child windows in the parent window. For more information on window stacking, see ACTIVATE WINDOW.
      In X# for Windows, if the main X# window is active, all windows are children of the main X# window. In X#, toolbars that are not docked in the border of the main X# window are children of the main X# window. Issuing a series of WCHILD() functions with positive numbers returns the names of the active windows and toolbars.
      If you include both WindowName and nChildWindow, separate WindowName and nChildWindow with a comma.
    </param>
    <returns>
      Character or Numeric
    </returns>
    <remarks>
      You can create a window (the parent window) and place other windows (child windows) inside. Including the IN or IN WINDOW clause in DEFINE WINDOW creates a child window inside the parent window. A child window created and activated inside a parent window cannot be moved outside the parent window. If the parent window is moved, the child window moves with it.
      The number of child windows in the active output window is returned if you issue WCHILD( ) without any arguments.
    </remarks>
  </wchild>
  <wcols>
    <summary>
      Returns the number of columns within the active or specified window.
    </summary>
    <param name="WindowName">

      Specifies the window for which WCOLS( ) returns the number of columns. In X#, you can also specify the name of a toolbar. If you do not specify a window, the number of columns in the active output window is returned. If no window is active, WCOLS( ) returns the number of columns in the main X# window.
      You can specify the name of a system window (the Command window, the Data Session window, a Browse window, and so on) in WCOLS( ) if the system window has been activated and is visible or hidden. In X#, you can specify the name of a toolbar (the Standard toolbar, the Color Palette toolbar, and so on) in WCOLS( ) if the toolbar has been activated and is visible or hidden. If you specify the name of a system window or toolbar that has not been activated, X# generates an error message. The Debug window is an exception. Once the Debug window has been opened, its name can be included in WCOLS( ) if it is visible, hidden or closed.
      You can also include the empty string as the window name to return the number of columns in the main X# window.
      The empty string can be used to specify the main X# window in functions such as WLCOL( ), WLROW( ), and WROWS( ), which return window locations or sizes.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      In X#, the value returned by WCOLS( ) depends on the font specified for the window. Many fonts can be displayed in a wide variety of sizes, and some are proportionally spaced. A column corresponds to the average width of a letter in the current font. For more information, see the Fonts Overview topic.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        DO SendMesg WITH 'Message', WCOLS( ), WROWS( ) –1
        *** SendMesg ***
        PROCEDURE SendMesg
        PARAMETERS gcMsg, gnCol, gnRow
        STORE (gnCol – LEN(gcMsg))/2 TO gnCol
        @ gnRow, gnCol SAY gcMsg
        RETURN
      </code>
    </example>
  </wcols>
  <wdockable>
    <summary>
      Returns the dockable state of the specified window
    </summary>
    <param name="cWindowName">

      Specifies the name of the window to evaluate.

    </param>
    <param name="lEnable">

      Specifies the dockable state for the window specified with the cWindowName parameter. If the specified window does not support docking, then X# ignores the lEnable parameter.
    </param>
    <returns>
      Logical data type. Returns the current dockable state for the specified window.
    </returns>
    <remarks>
      The <b>WDOCKABLE( )</b> function always returns False (.F.) for undockable windows. Use the <b>WDOCKABLE( )</b> function on X# windows that support docking. For a list of dockable X# windows, see How to: Dock Windows.
    </remarks>
  </wdockable>
  <wexist>
    <summary>
      Determines whether the specified user-defined window exists.
    </summary>
    <param name="WindowName">

      Specifies the name of the user-defined window.
      You can also specify the name of a X# system window (the Command window, the Data Session window, a Browse window, and so on), and in X#, the name of a toolbar. WEXIST( ) returns true (.T.) if the system window or toolbar you specify is visible or hidden. WEXIST( ) returns false (.F.) if the specified system window or toolbar is closed.
      Two exceptions are the Command and Debug windows. Including the Command window's name in WEXIST( ) always returns a true value. If the Debug window has been opened, WEXIST( ) returns true, even if the Debug window is closed.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      WEXIST( ) returns true (.T.) if the user-defined window you specify has been created with DEFINE WINDOW; otherwise WEXIST( ) returns false (.F.). The specified window does not have to be active or visible for WEXIST( ) to return true (.T.), but it must exist.
    </remarks>
    <example>
       <code language="X#">
        DEFINE WINDOW wScreen1 FROM 10,10 TO 20,69
        DEFINE WINDOW wScreen2 FROM 1,0 TO 19,79
        CLEAR
        ? WEXIST('wScreen1')  &amp;&amp; Displays .T.
        STORE 'wScreen2' TO gcWinName
        ? WEXIST('win_name')  &amp;&amp; Displays .F.
        ? WEXIST(gcWinName)  &amp;&amp; Displays .T.
        RELEASE WINDOWS wScreen1, wScreen2
      </code>
    </example>
  </wexist>
  <wfont>
    <summary>
      Returns the name, size, or style of the current font for a window in X# for Windows.
    </summary>
    <param name="nFontAttribute">

      Specifies the font attribute you want to return.
      If nFontAttribute is 1, WFONT( ) returns the name of the current font for the active or specified window.
      If nFontAttribute is 2, WFONT( ) returns the font size.
      If nFontAttribute is 3, WFONT( ) returns a code that identifies the font style.
      The font style code is a character or set of characters that correspond to the current font style. For example, the current font style is Bold Italic if WFONT(3) returns BI.
      The following table lists the codes for each font style:
      Normal
      Outline
      Q
      Opaque
      Shadow
      –
      StrikeThru
      Transparent
      U
      Underline

    </param>
    <param name="WindowName">

      Specifies the name of the window for which you want to determine the current font, font size, or font style. In X#, you can also include the name of a toolbar. Include the empty string to return the current font, font size, or font style for the main X# window.
      WindowName can be the name of a user-defined window created with DEFINE WINDOW or a text- or memo-editing window.
      You can also include the name of a system window (View, Trace, Debug, and so on). WFONT( ) can return font attributes only for a system window that has been opened and is currently visible or hidden. If the system window you specify is closed, X# generates an error message.
      WFONT( ) returns the current font, font size or font style for the active output window if you omit WindowName.
    </param>
    <returns>
      Character and Numeric
    </returns>
    <example>
       <code language="X#">
        CLEAR
        DEFINE WINDOW wFontChar ;
        FROM 1,1 TO 3,35 ;
        FONT 'MS SANS SERIF',8 ;
        STYLE 'BI'  &amp;&amp; Define window with font and style
        ACTIVATE WINDOW wFontChar
        ? WFONT(1), WFONT(2), WFONT(3)  &amp;&amp; wFontChar window
        ACTIVATE SCREEN
        ?
        ?
        ?
        ? 'Font characteristics for the window wFontChar'
        ?
        ?
        ? WFONT(1,''), WFONT(2,''), WFONT(3,'')  &amp;&amp; Main X# window
        ?
        ? 'Font characteristics for the main X# window'
        WAIT WINDOW
        RELEASE WINDOW wFontChar
        CLEAR
      </code>
    </example>
  </wfont>
  <window>
    <summary>
      Determines the active output window.
    </summary>
    <returns>
      Character.
    </returns>
    <remarks>
      <b>WINDOW( )</b> returns the name of the window to which output is currently directed./Pbr
      <b>WINDOW( )</b> returns the empty string if output is being directed to the main X# window.
      This function is included for backward compatibility. You may use the WOUTPUT( ) function instead.
    </remarks>
    <example>

      <code language="X#">
        PUBLIC oForm
        oForm = CREATEOBJECT('Form')
        oForm.AllowOutput = INT(SECONDS()) % 2 = 0
        oForm.Caption = IIF(oForm.AllowOutput, "This form accepts output", ;
        "This form does not accept output")
        oForm.Show()
        ? "Default output window name is " + ;
        IIF( EMPTY( WINDOW()), "None", WINDOW())
        WAIT WINDOW "The default output window name should appear " + ;
        IIF( EMPTY( WINDOW()), "nowhere", "in the form " + WINDOW())
      </code>
    </example>
  </window>
  <wlast>
    <summary>
      Returns the name of the window that was active prior to the current window or determines whether the specified window was active prior to the current window.
    </summary>
    <param name="WindowName">

      Specifies a window that WLAST( ) evaluates. In X#, you can also specify the name of a toolbar. WLAST( ) returns true (.T.) if the specified window was active prior to the current window; otherwise false (.F.) is returned. False (.F.) is also returned if the window you specify doesn't exist.
      The name of the window that was active prior to the current window is returned if you omit WindowName.
    </param>
    <returns>
      Character or Logical
    </returns>
    <remarks>
      WLAST( ) returns the empty string if the window that was active prior to the current window is the Debug, Trace, or Command window. Program execution isn't affected by bringing these windows forward when you are debugging a program that uses WLAST( ).
    </remarks>
  </wlast>
  <wlcol>
    <summary>
      Returns the column coordinate of the upper-left corner of the active or specified window.
    </summary>
    <param name="WindowName">

      Specifies the window for which WLCOL( ) returns the column coordinate. In X#, you can also specify the name of a toolbar. If you omit WindowName, WLCOLS( ) returns the column coordinate of the active output window. You can also use the empty string for WindowName to specify the main X# window.
      In X#, if no window is active, WLCOLS( ) returns the column coordinate of the main X# window relative to the Windows desktop.
      If a system window (the Command window, the Data Session window, a Browse window, and so on) has been opened and is visible or hidden (its name appears on the Window menu), you can include its name in WLCOL( ). If you specify the name of a system window that is closed, X# generates an error message. The Debug window is an exception. Once the Debug window has been opened, its name can be included in WLCOL( ) if it is visible, hidden, or closed.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The value returned by WLCOL( ) depends on the current video display mode, and is relative to the main X# window. The display mode can be changed with SET DISPLAY.
      Windows can be positioned outside the main X# window. If the specified window is to the left of the main X# window, WCOL( ) returns a negative value. If the window's left border is to the right of the main X# window, WCOL( ) returns a positive value greater than the width of the main X# window.
    </remarks>
  </wlcol>
  <wlrow>
    <summary>
      Returns the row coordinate of the upper-left corner of the active or specified window.
    </summary>
    <param name="WindowName">

      Specifies the window for which WLROW( ) returns the row coordinate. In X#, you can also specify the name of a toolbar. If you omit WindowName, WLROW( ) returns the row coordinate of the active output window. You can also use the empty string for WindowName to specify the main X# window.
      In X#, if no window is active, WLROW( ) returns the row coordinate of the main X# window relative to the Windows desktop.
      If a system window (the Command window, the Data Session window, a Browse window, and so on) has been opened and is visible or hidden (its name appears on the Window menu), you can include its name in WLROW( ). If you specify the name of a system window that is closed, X# generates an error message. The Debug window is an exception. Once the Debug window has been opened, its name can be included in WLROW( ) if it is visible, hidden, or closed.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      The value returned by WLROW( ) depends on the current video display mode, and the row coordinate is relative to the main X# window. The display mode can be changed with SET DISPLAY.
      Windows can be positioned off the main X# window. If the top of the window is above the main X# window, WLROW( ) returns a negative value. If the top of the window is below the bottom of the main X# window, WLROW( ) returns a positive value greater than the height of the main X# window.
    </remarks>
  </wlrow>
  <wmaximum>
    <summary>
      Determines whether the active or specified window is maximized.
    </summary>
    <param name="WindowName">

      Specifies the name of the window WMAXIMUM( ) evaluates. You can specify the name of a X# system window (the Command window, the Data Session window, a Browse window, and so on).
      If you omit WindowName, WMAXIMUM( ) returns a logical value for the active window. You can also use the empty string for WindowName to specify the main X# window.
    </param>
    <remarks>
      Windows can be enlarged to fill the window that contains them. In X# for Windows, the default container window is the main window.
      A user-defined window created with DEFINE WINDOW can be maximized only if the ZOOM keyword is included in its definition.
      WMAXIMUM( ) returns true (.T.) if the current or specified window is maximized; otherwise WMAXIMUM( ) returns false (.F.). In X#, you can include the name of a toolbar. However, WMAXIMUM( ) always returns false (.F.) for a toolbar because toolbars cannot be maximized.
    </remarks>
  </wmaximum>
  <wminimum>
    <summary>
      Determines whether the active or specified window is minimized.
    </summary>
    <param name="WindowName">

      Specifies the name of the window WMINIMUM( ) evaluates. You can specify the name of a X# system window (the Command window, the Data Session window, a Browse window, and so on).
      If you omit WindowName, WMINIMUM( ) returns a logical value for the active window. You can also include the empty string in WindowName to specify the main X# window.
    </param>
    <returns>
      Logical
    </returns>
    <remarks>
      In X# for Windows, windows can be reduced to an icon.
      A user-defined window created with DEFINE WINDOW can be minimized only if the MINIMIZE keyword is included in its definition.
      WMINIMUM( ) returns true (.T.) if the current or specified window is minimized; otherwise it returns false (.F.). In X#, you can include the name of a toolbar. However, WMINIMUM( ) always returns false (.F.) for a toolbar because toolbars cannot be minimized.
    </remarks>
  </wminimum>
  <wontop>
    <summary>
      Determines whether the active or specified window is in front of all other windows.
    </summary>
    <param name="WindowName">

      Specifies the name of the window WONTOP( ) evaluates. You can specify the name of a user-defined window created with DEFINE WINDOW or a system window (the Command window, the Data Session window, a Browse window, and so on). If you omit WindowName, WONTOP( ) returns the name of the "frontmost" or active window. You can also include the empty string in WindowName to specify the main X# window.
      If the Debug, Trace, or Command window is active and you don't specify a window name, WONTOP( ) returns the name of the window most recently in front. When you are debugging a program that uses WONTOP( ), program execution isn't affected by bringing these windows forward.
    </param>
    <returns>
      Character or Logical
    </returns>
    <remarks>
      WONTOP( ) returns true (.T.) if the specified window is active. It returns false (.F.) if the window isn't active or doesn't exist.
      Historically in prior versions of X#, the Data Session window has always been referred to as the View window. Additionally, language used to control this window, such as <b>HIDE WINDOW</b>, <b>ACTIVATE WINDOW</b>, <b>WONTOP( )</b>, also refers to this window as the View window. X# continues to refer to the View window for the <b>WONTOP( ) </b>function.
    </remarks>
    <example>
       <code language="X#">
        IF NOT EMPTY(WONTOP( ))
        WAIT WINDOW 'Frontmost window: ' + WONTOP( )
        ELSE
        WAIT WINDOW 'No windows are open'
        ENDIF
      </code>
    </example>
  </wontop>
  <woutput>
    <summary>
      Determines whether output is being directed to the active or specified window.
    </summary>
    <param name="WindowName">

      Specifies the window WOUTPUT( ) evaluates for output. Output cannot be directed to a system window or toolbar. If you omit WindowName, WOUTPUT( ) returns the name of the window to which output is currently directed. You can also include the empty string in WindowName to specify the main X# window.
      WOUTPUT( ) returns the empty string if output is being directed to the main X# window.
    </param>
    <returns>
      Logical and Character
    </returns>
    <remarks>
      WOUTPUT( ) returns true (.T.) if the specified user-defined window is the active output window. WOUTPUT( ) returns false (.F.) if the window you specify doesn't exist or is a system window. The last user-defined window activated with ACTIVATE WINDOW is the active output window.
    </remarks>
    <example>
       <code language="X#">
        DEFINE WINDOW wOutput1 FROM 2,2 TO 12,32 TITLE 'Output Window'
        ACTIVATE WINDOW wOutput1
        WAIT WINDOW 'wOutput1 window: ' + WOUTPUT( )
        RELEASE WINDOW wOutput1
        IF EMPTY(WOUTPUT( ))
        WAIT WINDOW 'Output being directed to the main X# window'
        ELSE
        WAIT WINDOW 'Output window: ' + WOUTPUT( )
        ENDIF
      </code>
    </example>
  </woutput>
  <wparent>
    <summary>
      Returns the name of the parent window of the active or specified window.
    </summary>
    <param name="WindowName">

      Specifies a window whose parent window name WPARENT( ) returns. WPARENT( ) returns the empty string if the specified window doesn't have a parent window. If you omit WindowName, WPARENT( ) returns the name of the parent window of the active output window. WPARENT( ) returns the empty string if the active output window doesn't have a parent window.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      You can use DEFINE WINDOW to create a window and place it in a parent window. The child window becomes integrated with its parent window. For example, a child window defined and activated inside a parent window can't be moved outside the parent window. If the parent window is moved, the child window moves with it.
    </remarks>
    <example>
       <code language="X#">
        CLEAR ALL
        CLEAR
        DEFINE WINDOW wParent ;
        FROM 1,1 TO 20,20 ;
        TITLE 'wParent'     &amp;&amp; Parent window
        ACTIVATE WINDOW wParent
        DEFINE WINDOW wChild ;
        FROM 1,1 TO 10,10 ;
        TITLE 'wChild' ;
        IN WINDOW wParent  &amp;&amp; Child window
        ACTIVATE WINDOW wChild
        WAIT WINDOW 'The parent window is ' + WPARENT( )
        RELEASE WINDOW wParent, wChild
      </code>
    </example>
  </wparent>
  <wread>
    <summary>
       
      Included for backward compatibility. Use the Form Designer instead.
      Determines whether or not the current or specified window is involved in the current READ.
    </summary>
    <returns>
      Return value - Logical
    </returns>
    <remarks>
      <br />
      WREAD() returns true (.T.) if the specified window is participating in the current READ; false (.F.) is returned if the specified window isn't involved in the current READ or doesn't exist.<br />
      <br />
      You can have a window participate in a READ by:<br />
      <br />
      ulliIncluding the window's title in the READ WITH clause. Windows that typically aren't involved in a READ can participate in this way. Browse windows, memo- and text-editing windows, FoxPro system windows, and so on can participate in a READ./li
      liCreating a control in the window. A READ can span multiple windows if you create controls in multiple windows and then issue READ. /li/ul

    </remarks>
  </wread>
  <wrows>
    <summary>
      Returns the number of rows within the active or specified window.
    </summary>
    <param name="WindowName">

      Specifies the window for which WROWS( ) returns the number of rows. In X#, you can also specify the name of a toolbar.
      In X#, the value returned by WROWS( ) depends on the font specified for the window. Most fonts can be displayed in a wide variety of sizes, and some are proportionally spaced. A row corresponds to the height of the current font. For more information, see the Fonts Overview topic.
      You can specify the name of a system window (the Command window, the Data Session window, a Browse window, and so on) in WROWS( ) if the system window has been opened and is visible or hidden. If you specify the name of a system window that is closed, FoxPro generates an error message. The Debug window is an exception. Once the Debug window has been opened, its name can be included in WROWS( ) if it is visible, hidden, or closed.
      You can also include the empty string in WindowName to return the number of rows in the main X# window.
      The empty string can be used to specify the main X# window in functions such as WLCOL( ), WLROW( ), and WCOLS( ), which return window locations or sizes.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      If you don't specify a window name, the number of rows in the active output window is returned. If no window is active, the number of rows in the main X# window is returned.
    </remarks>
  </wrows>
  <wtitle>
    <summary>
      Returns the title assigned to the active or specified window.
    </summary>
    <param name="WindowName">

      Specifies a window whose title WTITLE( ) returns. The title assigned to the window with the TITLE clause is returned if you include the name of a user-defined window created with DEFINE WINDOW.
      When you issue BROWSE WINDOW to open a Browse window in a user-defined window, WTITLE( ) returns the title of the user-defined window if the Browse window doesn't have a title. WTITLE( ) returns the title of the Browse window if the Browse window does have a title.
      You can also use the empty string for WindowName to specify the main X# window.
    </param>
    <returns>
      Character
    </returns>
    <remarks>
      WTITLE( ) can be used to return a window's title, which appears in the top border of the window. The title is returned for the active window if you omit WindowName. WTITLE( ) returns the empty string if the Debug, Trace or Command window is active or output is being directed to the main X# window.

      <b>Window Names and Titles</b>   Names are assigned to user-defined windows, system windows, toolbars (in X#), and Browse windows in the following manner:
      User-defined windows are assigned names when they are created with DEFINE WINDOW. There is a distinction between user-defined window names and titles. By default, user-defined windows don't have titles. If the TITLE clause is included when the window is created, the specified title appears in the top border of the window, but isn't the name of the window.
      By default, each system window, which is part of the X# interface, derives its name from the title of the window. Examples of system windows include the Command window, the Data Session window, and the Trace window. In X#, each toolbar derives its name from the title of the toolbar.
      Program and editing windows and the Label and Report Designer windows derive their names from the name of the file being created or modified.
      A Browse window derives its name from the title of the window. The name and title of the Browse window is assigned in one of three ways: either by the default title assignment of the table alias, or by the window title (if any exists), or by the Browse title (if any exists).
      By default, the Browse window name is the table alias.
      To specify a system window and toolbar names in commands and functions, enclose the entire system window or toolbar name in quotation marks. For example, to hide the Report Controls toolbar in X#, issue the following command:
       <code language="X#">HIDE WINDOW "Report Controls"</code>

      <b>Additional Notes on Window Names</b>   If you are unsure of the name assigned to a window, check the Window menu. All window names are listed at the bottom of the Window menu.
      Two windows exist if you issue BROWSE WINDOW WindowName. The Browse window is a separate window and takes on the attributes of the specified user-defined window. If a window is active when you issue BROWSE and you don't include the WINDOW clause, the Browse window takes on the attributes of the active window. You can override this behavior by including NORMAL in BROWSE.
      You can include window names that contain spaces in commands and functions that accept window names, such as MOVE WINDOW, DEACTIVATE WINDOW, and WONTOP( ), by specifying the part of the window name that begins with the first non-space character and continuing until the last non-space character is encountered.
      For example, a Browse window with the name Invoice Entry can be moved with this command:
       <code language="X#">MOVE WINDOW invoice BY 1,1</code>
      The names of user-defined windows cannot contain spaces, but the names of Browse and system windows can.
    </remarks>
  </wtitle>
  <year>
    <summary>
      Returns the year from the specified date or datetime expression.
    </summary>
    <param name="dExpression">

      Specifies a date expression from which YEAR( ) returns the year. dExpression can be a function that returns a date, or a Date-type memory variable, array element, or field. It can also be a literal date string, such as {^1998-06-06}.

    </param>
    <param name="tExpression">

      Specifies a datetime expression from which YEAR( ) returns the year.
    </param>
    <returns>
      Numeric
    </returns>
    <remarks>
      YEAR( ) always returns the year with the century. The CENTURY setting (ON or OFF) doesn't affect the returned value.
    </remarks>
    <example>
       <code language="X#">
        CLEAR
        ? YEAR(DATE( ))
      </code>
    </example>
  </year>
</Runtimefunctions>
