<?xml version="1.0" encoding="utf-8"?>
<doc>
  <members>
    <member name="T:VO.__DDImp">
      <exclude />
    </member>
    <member name="T:VO.__DocApp">
      <exclude />
    </member>
    <member name="T:VO.__ExplorerLV">
      <exclude />
    </member>
    <member name="T:VO.__ExplorerTV">
      <exclude />
    </member>
    <member name="T:VO.__ForeignWindow">
      <exclude />
    </member>
    <member name="T:VO.__FormattedString">
      <exclude />
    </member>
    <member name="T:VO.__FormDialogWindow">
      <exclude />
    </member>
    <member name="T:VO.__FormFrame">
      <exclude />
    </member>
    <member name="T:VO.__SplitView">
      <exclude />
    </member>
    <member name="T:VO.__VOToolBarUpdate">
      <exclude />
    </member>
    <member name="T:VO.__WindApp">
      <exclude />
    </member>
    <member name="T:VO._CodeBlock">
      <summary>
        Provide a class to be used by the runtime system to implement runtime-compiled code blocks.  A runtime-compiled code block becomes an instance of this class.
      </summary>
      <example>
        Create a runtime-compiled code block; since it is an object, the class name can be displayed:
        <code language="X#">
          LOCAL cb
          cb := &amp;("{|x|x * x}")
          ? ClassName(cb)			// _CodeBlock
        </code></example>
    </member>
    <member name="M:VO._CodeBlock.#ctor">
      <summary>
        Create a _CodeBlock object.
      </summary>
      <param name="nParamCount">The number of parameters the runtime code block expects.</param>
      <param name="cCode">The binary string representing the code that makes up the code block.</param>
      <remarks>
        This method is only to be called by the X# macro system.
      </remarks>
    </member>
    <member name="F:VO._CodeBlock._Code">
      <summary>
        A binary string representing the code that makes up the code block.
      </summary>
      <value>A binary string representing the code that makes up the code block.</value>
      <remarks>
        <note type="tip">This variable is only intended for use by the X# macro system.</note>
      </remarks>
    </member>
    <member name="M:VO._CodeBlock.Eval">
      <summary>
        Evaluate a runtime-compiled code block.
      </summary>
      <returns>
        A value whose data type depends on the value(s) passed to the code block, as well as the particular code block.
      </returns>
      <remarks>
        This method is called if the Eval() function is used to evaluate a runtime-compiled code block.
      </remarks>
      <example>
        Create a runtime-compiled code block and evaluate it using the _CodeBlock:Eval() method and the Eval() function:
        <code language="X#">
          LOCAL cb
          cb := &amp;("{|x| x * x}"}
          ? cb:EVAL(5)	// 25
          ? EVAL(cb,5)	// 25
        </code></example>
    </member>
    <member name="F:VO._CodeBlock.NParamCount">
      <summary>
        A numeric value representing the number of parameters the runtime code block expects.
      </summary>
      <value>A numeric value representing the number of parameters the runtime code block expects.</value>
    </member>
    <member name="T:VO.Accelerator">
      <summary>
        Create an accelerator table.
      </summary>
      <remarks>
        Many applications use accelerators as keyboard equivalents for menu selections.  An accelerator is a keystroke sequence that is associated with a particular menu command — the accelerator is used to execute the menu command without requiring the application user to first display the menu and then choose the command.
        For example, if the File New command had an accelerator of Ctrl+N, you could simply press this key combination to open a new document, rather than having to choose the File menu and then the New command.
        Each window can be given its own accelerator using the Window:Accelerator property.  An accelerator generates events as though its associated menu command was actually selected.  Note that an accelerator's menu command does not even have to be visible on any menu — thus an accelerator can be seen as a direct keystroke sequence for generating a command event.
      </remarks>
      <example>
        The following example demonstrates the use of the Accelerator class:
        <code language="X#">
          METHOD Init() CLASS MyTopAppWindow
          SUPER:Init()
          SELF:Show()
          SELF:Accelerator := Accelerator{IDA_HOTKEYS}
        </code>

        In Windows, an accelerator object is created using the ACCELERATORS statement in the resource entity.  For example, the following defines three accelerator keys:  "^X" for the Exit menu command, "Ctrl+Insert" for the Copy menu command, and "Shift+Insert" for the Paste menu command.
        <code language="X#">
          RESOURCE IDA_HOTKEYS ACCELERATORS
          BEGIN
          ^X, IDMI_EXIT
          VK_INSERT, IDMI_COPY, VIRTKEY, CONTROL
          VK_INSERT, IDMI_PASTE, VIRTKEY, SHIFT
          END
        </code></example>
    </member>
    <member name="M:VO.Accelerator.#ctor(XSharp.__Usual)">
      <summary>
        Load an accelerator table from a resource entity.
      </summary>
      <param name="xResourceID">The resource ID of the accelerator table, or another accelerator object, whose accelerators are copied.</param>
      <remarks>
        When no parameter is passed, X# will create a dynamic accelerator. If another accelerator is passed in  X# will copy its table of accelerator keys.
        The creation of the actual Windows accelerator is delayed until the Accelerator is first used.
      </remarks>
    </member>
    <member name="M:VO.Accelerator.AddAccelerator(XSharp.__Usual)">
      <summary>
        Adds all accelerator keys of one accelerator object to another
      </summary>
      <param name="oAccelerator">Existing Accelerator objects, whose accelerator keys are copied. </param>
      <returns>
        TRUE when successful, FALSE when not, for example because the object not dynamic anymore
      </returns>
      <remarks>
        This method copies the accelerator keys from one accelerator object to another.
        <note type="tip">
          After the first use of a dynamic accelerator object, no more accelerators can be added.
        </note></remarks>
    </member>
    <member name="M:VO.Accelerator.AddKey(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Adds a new accelerator key to the accelerator table
      </summary>
      <param name="nMenuItemId">the accelerator ID which is sent with a MenuComandEvent{} when the accelerator key is pressed.</param>
      <param name="xKeyId">can be a numeric VO key-code, which is identical to the windows virtual-key code, or a string with one character which specifies the character-code.</param>
      <param name="lCtrl">When TRUE, the CTRL key must be held down when the accelerator key is pressed.</param>
      <param name="lAlt">When TRUE, the ALT key must be held down when the accelerator key is pressed.</param>
      <param name="lShift">When TRUE, the SHIFT key must be held down when the accelerator key is pressed.</param>
      <returns>
        TRUE when successful, FALSE when not, for example because the object not dynamic anymore
      </returns>
      <remarks>
        <note type="tip">
          After the first use of a dynamic accelerator object, no more accelerators can be added..
        </note>
      </remarks>
    </member>
    <member name="M:VO.Accelerator.Create">
      <summary>
        <para>Creates the underlying windows accelerator.</para>
      </summary>
      <returns>
        <para>The handle of the accelerator, if successful. A null handle (NULL_PTR) is returned if the control creation failed.</para>
      </returns>
    </member>
    <member name="M:VO.Accelerator.Destroy">
      <summary>
        Provide a method to de-instantiate an Accelerator object.
      </summary>
      <remarks>
        This method can be used when an Accelerator object is no longer needed.  Accelerator:Destroy() de-instantiates the Accelerator object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
      <returns>
        NIL
      </returns>
    </member>
    <member name="P:VO.Accelerator.Empty">
      <summary>
        Returns TRUE when the accelerator table contains no keys.
      </summary>
      <value>TRUE when the accelerator table contains no keys.</value>
    </member>
    <member name="M:VO.Accelerator.Handle">
      <summary>
        Return the handle for an accelerator.
      </summary>
      <returns>
        A handle describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
        When the Accelerator objects is 'dynamic' this will create the actual Windows GDI Object and no more accelerators can be added to the accelerator
      </remarks>
    </member>
    <member name="T:VO.ActiveXControl">
      <summary>
        Base class for ActiveX control objects.
      </summary>
      <remarks>
        The ActiveXControl class serves as the base class for ActiveX controls developed in X#.  The main class representing the ActiveX control has to be derived from this class.
        <note type="tip">When creating ActiveX controls in the IDE, the class derived from ActiveXControl has to be specified in the OCX Base edit control on the OLE Server tab page in the Application Options dialog box.</note></remarks>
    </member>
    <member name="M:VO.ActiveXControl.#ctor">
      <summary>
        Instantiate an ActiveXControl object.
        Init()is automatically called by the ActiveX container. Normally, it should not be called from your application code.
      </summary>
      <param name="hObject">A handle (pointer) representing the object.</param>
      <remarks>
        This method instantiates an ActiveXControl object.  Unlike other Init() methods, ActiveXControl:Init() should never be called from  X#application code directly.  Instead, it is called by the ActiveX container, which creates the ActiveX object.
        For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
      </remarks>
    </member>
    <member name="P:VO.ActiveXControl.AutoServer">
      <summary>
        The object representing the automation server interface of the ActiveX control.
      </summary>
      <value>The object representing the automation server interface of the ActiveX control.</value>
      <remarks>
        <note type="tip">When creating OLE Automation servers in the IDE, the class of the automation server has to be specified in the Automation edit control on the OLE Server tab page in the Application Options dialog box.</note>
      </remarks>
    </member>
    <member name="M:VO.ActiveXControl.Create">
      <summary>
        Create an ActiveX control.
        Create()is automatically called by the ActiveX container. Normally, it should not be called from your application code.
      </summary>
      <param name="hParent">The window handle of the parent (container) window.</param>
      <remarks>
        The Create() method is called after the ActiveXControl object is instantiated.  Note that the both methods are called from the ActiveX container application: they should never be called directly from your code.
        Inside Create(), you should:
        1.	Instantiate a control or window object representing the user interface of the ActiveX control.  This object should be assigned to OCXWindow.
        2.	Instantiate an object representing the automation interface of the ActiveX control and assign it to AutoServer.
        3.	Instantiate an object representing the event interface of the ActiveX control and assign it to Events — this step is optional.
        4.	Perform other initializations tasks.
        For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
      </remarks>
      <example>
        This is the Create() method from the Calendar ActiveX sample that is accessible from the Samples tab page of the Application Gallery:
        <code language="X#">
          METHOD Create(hParent) CLASS CalOCX
          LOCAL oCal AS CalendarControl
        </code><code language="X#">
          SUPER:Create(hParent)
          SELF:Events     := CalendarEvents{}
          oCal := CalendarControl{hParent, 100,;
           Point{0,0}, DIMension{100,100}, ,SELF}
          SELF:OCXWindow  := oCal
          SELF:AutoServer := oCal
          oCal:CurrentDate := curDate
          oCal:Show()
          RETURN oCal:Handle()
        </code></example>
    </member>
    <member name="P:VO.ActiveXControl.DesignMode">
      <summary>
        A logical value returning TRUE if the ActiveX control is in design mode, i.e., used inside a development environment.
      </summary>
      <value>A logical value returning TRUE if the ActiveX control is in design mode, i.e., used inside a development environment.</value>
    </member>
    <member name="M:VO.ActiveXControl.Destroy">
      <summary>
        Provide a method to de-instantiate an ActiveX object.
      </summary>
      <remarks>
        This method can be used when an ActiveXControl object is no longer needed.  ActiveXControl:Destroy() de-instantiates the ActiveXControl object, and allows you to close and free any resources that were opened or created by the object without waiting for the garbage collector.
      </remarks>
      <returns>
        NIL
      </returns>
    </member>
    <member name="P:VO.ActiveXControl.Events">
      <summary>
        The object representing the event interface of the ActiveX control.
      </summary>
      <value>The object representing the event interface of the ActiveX control.</value>
      <remarks>
        <note type="tip">When creating ActiveX controls in the IDE, the class of the event object has to be specified in the Events edit control on the OLE Server tab page in the Application Options dialog box.</note>
        For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.

      </remarks>
    </member>
    <member name="P:VO.ActiveXControl.OCXWindow">
      <summary>
        The object representing the user interface of the ActiveX control. This can be any X# control or window object.
        For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
      </summary>
      <value>
        The object representing the user interface of the ActiveX control. This can be any X# control or window object.
        For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
      </value>
    </member>
    <member name="M:VO.ActiveXControl.SetExtent">
      <summary>
        Called by the container for resizing the ActiveX control.
      </summary>
      <param name="nX">The requested width of the ActiveXControl.</param>
      <param name="nY">The requested height of the ActiveXControl.</param>
      <remarks>
        SetExtend() is a callback method called by the container whenever the ActiveXControl is to be resized.  The default behavior is to resize the user interface object.  You may override this method in your derived ActiveX class in order to change the default behavior.
        For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
      </remarks>
    </member>
    <member name="M:VO.ActiveXControl.ShowPropPages">
      <summary>
        Callback method called by the ActiveX container whenever the ActiveX control should display its Property Pages dialog box.
      </summary>
      <remarks>
        ShowPropPages() is a callback method called by the ActiveX container whenever the ActiveX control should display its Property Pages dialog box.  The default implementation displays a message box stating that the property pages are not implemented.  In derived classes, this callback method should be overridden to display a dialog box that allows the user to change properties of the ActiveX control.
        For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
      </remarks>
    </member>
    <member name="M:VO.ActiveXControl.StreamIn">
      <summary>
        Callback method used to load persistent data.
      </summary>
      <param name="oStream">A Stream object representing the input stream.</param>
      <remarks>
        For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
      </remarks>
      <example>
        This is the StreamIn() method from the Calendar ActiveX sample that is accessible from the Samples tab page of the Application Gallery:
        <code language="X#">
          METHOD StreamIn(oStream) CLASS CalOCX
          LOCAL u AS USUAL
          u := oStream:Read()
          IF IsDate(u)
           curDate := u
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.ActiveXControl.StreamOut">
      <summary>
        Callback method used to save persistent data.
      </summary>
      <param name="oStream">A Stream object representing the input stream.</param>
      <remarks>
        For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
      </remarks>
      <example>
        This is the StreamOut() method from the Calendar ActiveX sample that is accessible from the Samples tab page of the Application Gallery:
        <code language="X#">
          METHOD StreamOut(oStream) CLASS CalOCX
          oStream:Write(oOCXWindow:CurrentDate)
          RETURN
        </code></example>
    </member>
    <member name="T:VO.ActiveXEvents">
      <summary>
        Base class for classes implementing the event interface of ActiveX server applications.
      </summary>
      <remarks>
        ActiveXEvents serves as a base class for classes implementing the event interface of ActiveX server applications.  The class implementing the application's event interface should be derived from ActiveXEvents, and it has to be specified on the OLE Server tab page in the Application Options dialog box when specifying your application's options.
        The methods of the event class are included in the server's type library and, at the same time, can be used by the server to fire an event by calling the FIREEVENT macro.
      </remarks>
    </member>
    <member name="M:VO.ActiveXEvents.FireEvent">
      <summary>
        FireEvent() should never be called directly.  Use the FIREEVENT UDC instead.
      </summary>
      <param name="iEventID">The event ID.</param>
      <param name="nPCount">The number of parameters.</param>
      <param name="pStack">A stack pointer.</param>
      <remarks>
        The FireEvent() method should never be called directly.  Instead, the FIREEVENT macro (contained in OCX.UDC ) should be used to call this method with the correct parameters.
        Usually the methods of an event class are empty except for a FIREEVENT call.  This way, the methods are used both to set up the server's type library and for firing the event in the server code.
      </remarks>
    </member>
    <member name="T:VO.AdsSQLServer">
      <summary>Special Dbserver class that passes the string as SQL Query to the Advantage RDD.</summary>
    </member>
    <member name="M:VO.AdsSQLServer.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
      <summary>Construct a AdsSQLServer object.</summary>
      <param name="oFile">The SQL Query that is executed.</param>
    </member>
    <member name="T:VO.AnimationControl">
      <summary>
        Create an animation control.
      </summary>
      <remarks>
        An animation control displays a silent Audio Video Interleaved (AVI) clip.
        A silent AVI clip is a series of bitmap frames like a movie.  Although AVI clips can have sound, only silent AVI clips can be used with the animation control.
      </remarks>
    </member>
    <member name="M:VO.AnimationControl.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct an animation control.
      </summary>
      <param name="oOwner">The window that owns the animation control.</param>
      <param name="xID">The unique ID of the animation control (between 1 and 8000).</param>
      <param name="nResourceID">The resource ID of the animation control.</param>
      <param name="oPoint">The origin of the animation control in canvas coordinates.</param>
      <param name="oDimension">The dimension of the animation control in canvas coordinates.</param>
      <param name="oFileSpec">The FileSpec object that describes the associated AVI file.</param>
      <param name="cFileName">The file name that describes the associated AVI file.</param>
      <param name="kStyle">The style of the animation control.</param>
      <param name="hInst">The instance handle to be passed to the window when creating the control.</param>
    </member>
    <member name="M:VO.AnimationControl.Create">
      <summary>
        Creates the underlying window control for a X# animation control object.
      </summary>
      <returns>
        The window handle of the control, if  successful.  A null handle (NULL_PTR) is returned if the control creation failed.
      </returns>
      <remarks>
        The Create() method creates the underlying window control for controls not loaded from a resource (i.e., designed with the Window Editor) but created at runtime.  Normally, it is not necessary to call Create() directly — CA-X# will create the object internally as soon as a window handle is needed.
      </remarks>
      <example>
        <code language="X#">
          METHOD CreateAnimationControl() CLASS MyDataWindow
           LOCAL oAC AS AnimationControl
          // Init creates the X# AnimationControl Object
           oAC := AnimationControl{SELF, 100, Point{10,10}, Dimension{100,20}}
          // Calling Create forces the Windows control to be created
           oAC:Create()
        </code>
      </example>
    </member>
    <member name="P:VO.AnimationControl.FileSpec">
      <summary>
        The FileSpec object that describes the associated AVI file.
      </summary>
      <value>The FileSpec object that describes the associated AVI file.</value>
    </member>
    <member name="M:VO.AnimationControl.Open">
      <summary>
        Open the AVI file and display its first frame in the animation control.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.AnimationControl.OpenResource(XSharp.__Usual)">
      <summary>
        Open the AVI resource and display its first frame in the animation control.
      </summary>
      <param name="xID">The unique ID for the animation resource (between 1 and 8000), or a ResourceID object identifying the AVI resource.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.AnimationControl.Play(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Play the AVI file in the animation control.
      </summary>
      <param name="nFrom">The initial frame number.  If omitted, playback begins from the first frame.</param>
      <param name="nTo">The final frame number.  If omitted, playback continues to the last frame.</param>
      <param name="nRepeatCount">The number of times to play the AVI file.  If omitted, playback is repeated indefinitely.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.AnimationControl.Seek(XSharp.__Usual)">
      <summary>
        Direct the animation control to display a particular frame in the AVI file.
      </summary>
      <param name="nFrame">The frame number to display.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.AnimationControl.Stop">
      <summary>
        Direct the animation control to stop the display of the AVI file.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="T:VO.App">
      <summary>
        Create an entity that represents the overall application. Please note that you have to create a subclass of App in your code and add a Start() method to this class. You can't add a Start() method to the App() class inside GUI Classes like you can in VO.
      </summary>
      <remarks>
        The App class starts, runs, and stops the application. However, nearly all the code in an application executes in event handlers.
        Once you invoke the method App:Exec(), the system starts sending you events.
        While the term application is consistent in both the windowing and non-windowing worlds, the event-driven nature of a windowing application is designed to handle user-driven events (such as a mouse click or the resizing of a window).  As a result, the function of the windowing application is relegated to an event scheduling loop.
        In this class, the Start() method is analogous to the entry point START() function in CA-Clipper.  It is where the main elements of your application are constructed.  The objects declared within App:Start() should be those which have "application wide" scope.
        Within the App:Start() method you must call App:Exec().  Doing so invokes the message processing loop of your underlying windowing system and begins the system event handling mechanism by activating the system dispatcher.
        The App:Exec() method can be thought of as a layered service with a typical "get-translate-dispatch-message" mechanism driven by your underlying windowing system and a "filter-translate-dispatch-event" mechanism being directed through the system framework by the system dispatcher.
        The App:Quit() method provides a way of breaking out of the application's Exec() loop to terminate the application.  It is analogous to the QUIT() function in CA-Clipper.
      </remarks>
      <example>
        The following example demonstrates an entire application, using the various methods of the App class:
        <code language="X#">
          DEFINE IDM_MYMENU := "MyMenu"
          DEFINE IDM_MYMENU_CLOCK_ID := 1000
          DEFINE IDM_MYMENU_GETHANDLE_ID := 1001
          DEFINE IDM_MYMENU_QUIT_ID := 1002
          FUNCTION Start as VOID
          LOCAL oApp as XApp
          oApp := XApp{}
          oApp:Start()
          RETURN

          CLASS XApp INHERIT APP
          METHOD Start()
            LOCAL oWin AS Window
          oWin := MyTopAppWin{SELF}
            oWin:Show()
            SELF:Exec()
          RETURN NIL

          END CLASS

          CLASS MyTopAppWin INHERIT TopAppWindow

          CONSTRUCTOR(oOwnerApp)
          LOCAL lRetVal AS LONG
             SUPER(oOwnerApp)
             SELF:Menu := MyMenu{SELF}
             lRetVal := oOwnerApp:Run("Clock")
             SELF:Caption := "My Top App Window Application"
             SELF:WarningMessage("The return value of running CLOCK is :" +AsString(lRetVal))
          RETURN

          METHOD GetClock()
            SELF:Owner:Run("Clock")
          RETURN NIL

          METHOD GetHandle()
            SELF:WarningMessage("The handle of this app is :"+AsString(SELF:Handle()))
          RETURN NIL

          METHOD GoQuit()
            SELF:Owner:Quit()
          RETURN NIL
          END CLASS

          CLASS MyMenu INHERIT Menu
          CONSTRUCTOR(oOwner)
            SUPER(ResourceID{IDM_MYMENU})
            SELF:RegisterItem(IDM_MYMENU_CLOCK_ID, HyperLabel{#GetClock,,,})
            SELF:RegisterItem(IDM_MYMENU_GETHANDLE_ID, HyperLabel{#GetHandle,,,})
            SELF:RegisterItem(IDM_MYMENU_QUIT_ID, HyperLabel{#GoQuit,,,})
          END CLASS
          RESOURCE IDM_MYMENU MENU
          BEGIN
            POPUP "&amp;Menu1"
            BEGIN
               MENUITEM "&amp;Clock", IDM_MYMENU_CLOCK_ID
               MENUITEM "&amp;Get App Handle", IDM_MYMENU_GETHANDLE_ID
               MENUITEM SEPARATOR
               MENUITEM "&amp;QUIT", IDM_MYMENU_QUIT_ID
            END
          END
        </code></example>
    </member>
    <member name="M:VO.App.#ctor(XSharp.__Usual)">
      <summary>
        Construct an application.
      </summary>
      <remarks>
        <br />Important!  X# instantiates this object.
      </remarks>
      <param name="oOwner">The window that owns the application.</param>
    </member>
    <member name="M:VO.App.AfterDispatch">
      <summary>
        Low-level handler used with App:BeforeDispatch() for intercepting any message posted to an application's message queue.
      </summary>
      <param name="hWnd">The window handle for which the message is meant.</param>
      <param name="uMsg">The message constant.</param>
      <param name="wParam">The DWORD parameter.</param>
      <param name="lParam">The LONG parameter.</param>
      <remarks>
        The BeforeDispatch() and AfterDispatch() methods are low-level handlers that intercept any message posted to the application's message queue.  BeforeDispatch() is called before the message is dispatched to the Dispatch() method of the corresponding window, whereas AfterDispatch() is called afterwards.
        <note type="tip">These methods are not implemented as part of the GUI classes.  Rather, they should be implemented by the programmer if general, application-wide message intercepting and handling are wanted.  BeforeDispatch() and AfterDispatch() are called from within App:Exec() if they exist.</note></remarks>
      <example>
        See the App:BeforeDispatch() example.
      </example>
    </member>
    <member name="M:VO.App.BeforeDispatch">
      <summary>
        Low-level handler used with App:AfterDispatch() for intercepting any message posted to an application's message queue.
      </summary>
      <param name="hWnd">The window handle for which the message is meant.</param>
      <param name="uMsg">The message constant.</param>
      <param name="wParam">The DWORD parameter.</param>
      <param name="lParam">The LONG parameter.</param>
      <returns>
        TRUE if the message should be further processed; otherwise, FALSE.
      </returns>
      <remarks>
        The BeforeDispatch() and AfterDispatch() methods are low-level handlers that intercept any message posted to the
        application's message queue.  BeforeDispatch() is called before the message is dispatched to the Dispatch() method
        of the corresponding window, whereas AfterDispatch() is called afterwards.
        <note type="tip">
          These methods are not implemented as part of the GUI classes.  Rather, they should be implemented by
          the programmer if general, application-wide message intercepting and handling are wanted.  BeforeDispatch() and
          AfterDispatch() are called from within App:Exec() if they exist.
        </note></remarks>
      <example>
        This example disables single left-button clicks application-wide:
        <code language="X#">
          METHOD BeforeDispatch(hWnd, uMsg, wParam, lParam) CLASS App
          IF uMsg == WM_LBUTTONDOWN
           RETURN FALSE
          ENDIF
          RETURN TRUE
        </code></example>
    </member>
    <member name="M:VO.App.Exec(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Start the event handling loop for the application.
      </summary>
      <param name="kExecType">
        The type of event handling loop to start, specified as one of the following constants
        <pre>
          Constant			  Description
          EXECNORMAL		  Tells the system to continue to execute the application until either the user closes it
          (by selecting the Close menu command or using the standard Windows accelerator Alt+F4)
          or the application decides to close by deliberately invoking the App:Quit() method.
          When the application terminates, the thread of control exits from App:Exec() to the
          next statement in your code.  This is the default.
          EXECWHILEEVENT	Tells the system to continue to execute the application only while there are still events queued.  
          Once the system has dispatched the last event in the queue, the thread of control exits from App:Exec().
          This gives you the opportunity to do some processing and then start another event loop by invoking
          App:Exec() again.  You should use this mechanism when you want to do some background processing
          while the application is idle.
        </pre></param>
      <param name="oObject">** missing parameter documentation **</param>
      <returns>
        A value of 0 indicates normal termination (no errors).  A non-zero value indicates abnormal termination.
      </returns>
      <remarks>
        Normally, the event handling loop for the application continues looping until there are no more EventContext objects.  It can also terminate upon calling App:Quit().
        <note type="tip">Make sure that you show at least one window object before calling App:Exec().</note></remarks>
    </member>
    <member name="M:VO.App.GetAccel">
      <summary>This method returns the handle for the current active Accelerator Table.</summary>
      <returns>The handle for the current active Accelerator Table.</returns>
      <remarks>This handle gets set in the Activate event of the window class.</remarks>
    </member>
    <member name="M:VO.App.GetAccelWindow">
      <summary>This method gets the handle to the window for which accelerators must be translated.</summary>
      <returns>The window for which accelerators must be translated.</returns>
      <remarks>This handle gets set in the Activate event of the window class.</remarks>
    </member>
    <member name="M:VO.App.GetDialogWindow">
      <summary>This method gets the handle active Dialog window for which Dialog keys must be handled</summary>
      <returns>The handle to the active Dialog window.Please note that the surface of a DataWindow is also a DialogWindow.</returns>
      <remarks>This handle gets set in the Activate() method and event handler of the DialogWindow class.</remarks>
    </member>
    <member name="M:VO.App.GetMdiClientWindow">
      <summary>This method gets the handle to the MDI Clientwindow on the active ShellWindow.</summary>
      <returns>The handle to the MDI Client window.</returns>
      <remarks>This handle gets set in the constructor of the ShellWindow.</remarks>
    </member>
    <member name="M:VO.App.Handle">
      <summary>
        Return the handle for an application.
      </summary>
      <param name="nHandleType">The type of handle required.  0 is the only supported option, and it is the default if &lt;nHandleType&gt; is omitted.</param>
      <returns>
        A handle describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
      </remarks>
    </member>
    <member name="M:VO.App.Quit">
      <summary>
        Terminate the application by instructing the application to close itself.
      </summary>
      <remarks>
        This method is normally invoked when an Exit menu command is selected.
      </remarks>
    </member>
    <member name="M:VO.App.Run(XSharp.__Usual)">
      <summary>
        Invoke and execute a specified command.
      </summary>
      <param name="sCommand">The command to be executed (including any required arguments).</param>
      <returns>
        A long integer value indicating successful completion or an error.  The numbers 0-32 correspond to a specific error type in Windows (e.g., 0 means "out of memory," 2 means "file not found," etc.); any other number indicates successful completion.
      </returns>
    </member>
    <member name="M:VO.App.SetAccel(XSharp.__Usual)">
      <summary>This method sets the handle for the current active Accelerator Table (belonging to the active menu).</summary>
      <param name="hNewAccel">The handle to the Accelerator table that has to become active</param>
      <returns>NIL</returns>
      <remarks>This handle gets set in the Activate event of the window class.</remarks>
    </member>
    <member name="M:VO.App.SetAccelWindow(XSharp.__Usual)">
      <summary>This method sets the window for which accelerators must be translated.</summary>
      <param name="hNewAccelWnd">The handle for the window for which accelerators (labels that start with an ampersand) must be translated.</param>
      <returns>NIL</returns>
      <remarks>This handle gets set in the Activate event of the window class.</remarks>
    </member>
    <member name="M:VO.App.SetDialogWindow(XSharp.__Usual)">
      <summary>This method sets the handle active Dialog window for which Dialog keys must be handled</summary>
      <param name="hNewDialogWnd">The handle for active Dialog window. Please note that the surface of a DataWindow is also a DialogWindow.</param>
      <returns>NIL</returns>
      <remarks>This handle gets set in the Activate() method and event handler of the DialogWindow class.</remarks>
    </member>
    <member name="M:VO.App.SetMdiClientWindow(XSharp.__Usual)">
      <summary>This method sets the handle to the MDI Clientwindow on the active ShellWindow.</summary>
      <param name="hNewMdiClientWnd">The handle for the MDI Clientwindow.</param>
      <returns>NIL</returns>
      <remarks>This handle gets set in the constructor of the ShellWindow.</remarks>
    </member>
    <member name="M:VO.App.Start">
      <summary>
        Provide the entry point for an application.
      </summary>
      <remarks>
        In the App:Start() method, the main elements of your application are constructed.  The objects declared within App:Start() should be those which have "application wide" scope.  Within the App:Start() method you must call App:Exec(), invoking the message processing loop of your underlying windowing system and beginning the system event handling mechanism by activating the system dispatcher.
      </remarks>
    </member>
    <member name="T:VO.AppCommandEvent">
      <summary>
        Provide information about an AppCommand event, which is launched by the extra keys on an extended keyboard or mouse.
      </summary>
      <remarks>
        The AppCommandEvent class is created by X# in responce to the activation of a key on an Extended keyboard or mouse.
      </remarks>
    </member>
    <member name="M:VO.AppCommandEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.AppCommandEvent.Command">
      <summary>
        The command associated with this event.
      </summary>
      <value>The command associated with this event.</value>
      <remarks>
        <a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/wm-appcommand">See the Ms docs website for a list of possible commands</a>
      </remarks>
    </member>
    <member name="P:VO.AppCommandEvent.IsControl">
      <summary>
        Returns TRUE if the Control Key is down; otherwise, FALSE.
      </summary>
      <value>TRUE if the Control Key is down; otherwise, FALSE.</value>
    </member>
    <member name="P:VO.AppCommandEvent.IsDeviceKey">
      <summary>
        Returns TRUE if the device that issued the command was a keyboard; otherwise, FALSE.
      </summary>
      <value>TRUE if the device that issued the command was a keyboard; otherwise, FALSE.</value>
    </member>
    <member name="P:VO.AppCommandEvent.IsDeviceMouse">
      <summary>
        Returns TRUE if the device that issued the command was a mouse; otherwise, FALSE.
      </summary>
      <value>TRUE if the device that issued the command was a mouse; otherwise, FALSE.</value>
    </member>
    <member name="P:VO.AppCommandEvent.IsDeviceOEM">
      <summary>
        Returns TRUE if the device that issued the command was an OEM device; otherwise, FALSE.
      </summary>
      <value>TRUE if the device that issued the command was an OEM device; otherwise, FALSE.</value>
    </member>
    <member name="P:VO.AppCommandEvent.IsLeftButton">
      <summary>
        Returns TRUE if the Left mouse button is down; otherwise, FALSE.
      </summary>
      <value>TRUE if the Left mouse button is down; otherwise, FALSE.</value>
    </member>
    <member name="P:VO.AppCommandEvent.IsMiddleButton">
      <summary>
        Returns TRUE if the Middle mouse button is down; otherwise, FALSE.
      </summary>
      <value>TRUE if the Middle mouse button is down; otherwise, FALSE.</value>
    </member>
    <member name="P:VO.AppCommandEvent.IsRightButton">
      <summary>
        Returns TRUE if the Right mouse button is down; otherwise, FALSE.
      </summary>
      <value>TRUE if the Right mouse button is down; otherwise, FALSE.</value>
    </member>
    <member name="P:VO.AppCommandEvent.IsShift">
      <summary>
        Returns TRUE if the Shift Key is down; otherwise, FALSE.
      </summary>
      <value>TRUE if the Shift Key is down; otherwise, FALSE.</value>
    </member>
    <member name="P:VO.AppCommandEvent.IsXButton1">
      <summary>
        Returns TRUE if the first X mouse button is down; otherwise, FALSE.
      </summary>
      <value>TRUE if the first X mouse button is down; otherwise, FALSE.</value>
    </member>
    <member name="P:VO.AppCommandEvent.IsXButton2">
      <summary>
        Returns TRUE if the second X mouse button is down; otherwise, FALSE.
      </summary>
      <value>TRUE if the second X mouse button is down; otherwise, FALSE.</value>
    </member>
    <member name="P:VO.AppCommandEvent.oTarget">
      <summary>
        Returns the target of the command.
        If it is a Key event the target is focused control or window. If it is a Mouse event the target is the control or window that is under the mouse pointer.
      </summary>
      <value>
        the target of the command.
        If it is a Key event the target is focused control or window. If it is a Mouse event the target is the control or window that is under the mouse pointer.
      </value>
    </member>
    <member name="T:VO.AppWindow">
      <summary>
        Provide the base class from which all X# application windows are subclassed.
      </summary>
      <remarks>
        Use the methods of the AppWindow class to customize the appearance of top, shell, and child application windows (for example, the display of border styles, the system menu, or icons).
      </remarks>
    </member>
    <member name="M:VO.AppWindow.#ctor(XSharp.__Usual)">
      <summary>
        Construct an application window.
      </summary>
      <param name="oOwner">The window that owns the application window.</param>
    </member>
    <member name="M:VO.AppWindow.Default(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.AppWindow.Destroy">
      <summary>
        Provide a method to free memory resources allocated for an AppWindow object and its derived objects.
      </summary>
      <remarks>
        This method immediately frees resources for AppWindow objects created explicitly in your application.  AppWindow:Destroy() also takes care of resources allocated to derived classes and deallocates them in the necessary order (e.g., child windows are destroyed before the parent window; dialog windows and MDI shell windows are also looked after).
      </remarks>
    </member>
    <member name="M:VO.AppWindow.Dispatch(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.AppWindow.EnableBorder(XSharp.__Usual)">
      <summary>
        Set the border style for an application window.
      </summary>
      <param name="kBorderStyle">The display style of the application window's border, specified as one of the following constantsn</param>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>WINDOWNOBORDER</term>
            <description>No border.</description>
          </item>
          <item>
            <term>WINDOWNONSIZINGBORDER</term>
            <description>A nonsizable, captioned border.</description>
          </item>
          <item>
            <term>WINDOWSIZINGBORDER</term>
            <description>
              A resizable, captioned border.  This is the <b>default</b>.
            </description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:VO.AppWindow.EnableHorizontalScroll(XSharp.__Usual)">
      <summary>
        Enable/disable a window horizontal scroll bar in an application window.
      </summary>
      <param name="lEnable">TRUE enables the horizontal scroll bar; FALSE disables it.  The default is TRUE.</param>
      <returns>
        If the scroll bar is enabled, a WindowHorizontalScrollBar object is returned; if disabled, NULL_OBJECT is returned.
      </returns>
      <remarks>
        <note type="tip">This is the only valid way to create a window horizontal scroll bar.</note>
        A WindowHorizontalScrollBar object is a special type of scroll bar that appears aligned along the bottom of a window's canvas area.  It resizes itself according to the size of the window that owns it.
        After creating a window horizontal scroll bar, it should then be shown and its range set.
      </remarks>
      <example>
        This example enables a WindowHorizontalScrollBar object and sets its range to 1-80, with a block size of 8:
        <code language="X#">
          METHOD Init() CLASS MyAppWindow
            owhs := SELF:EnableHorizontalScroll(TRUE)
            owhs:Show()
            owhs:Range := Range{1,80}  
            owhs:BlockSize := 8
        </code></example>
    </member>
    <member name="M:VO.AppWindow.EnableMaxBox(XSharp.__Usual)">
      <summary>
        Enable/disable a maximize box in an application window.
      </summary>
      <param name="lEnable">TRUE enables the maximize box; FALSE disables it.  The default is TRUE.</param>
    </member>
    <member name="M:VO.AppWindow.EnableMinBox(XSharp.__Usual)">
      <summary>
        Enable/disable a minimize box in an application window.
      </summary>
      <param name="lEnable">TRUE enables the minimize box; FALSE disables it.  The default is TRUE.</param>
    </member>
    <member name="M:VO.AppWindow.EnableOleDropTarget(XSharp.__Usual)">
      <summary>
        Register the window as an OLE drop target.
      </summary>
      <param name="lEnable">A logical value specifying whether to enable (TRUE) or disable (FALSE) the window as a drop target.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        A window that is registered as an OLE drop target using AppWindow:EnableOLEDropTarget() can handle OLE drag and drop events and create new OLE objects in response to such events.  In the associated handlers, an OLEDragEvent object is passed as a parameter that can be used to create a new OLE object by calling OLEObject:CreateFromOLEDragEvent().
      </remarks>
      <example>
        The following code enables a data window as a drop target and creates a new OLE object inside its OLEDrop handler.  It also checks the name of the OLE object to allow only WordPad documents:
        <code language="X#">
          METHOD EnableOLEDropTarget CLASS DropTargetDataWindow
            SELF:EnableOLEDropTarget(TRUE)
          METHOD OLEDrop(oOLEDragEvent) CLASS MyChild
            LOCAL oOLE AS OLEObject
            LOCAL lRet AS LOGIC
            IF oOLEDragEvent:ObjectName == "WordPad Document"
               oOLE := OLEObject{SELF}
               oOLE:AllowInPlace := TRUE
               oOLE:AllowResize := TRUE
               IF oOLE:CreateFromOLEDragEvent(oOLEDragEvent)
                  oOLE:Origin := oOLEDragEvent:Position
                  oOLE:Show()
                  oOLE:SetFocus()
               ENDIF
            ENDIF
        </code></example>
    </member>
    <member name="M:VO.AppWindow.EnableStatusBar(XSharp.__Usual)">
      <summary>
        Enable/disable a status bar in an application window.
      </summary>
      <param name="lEnable">TRUE enables the status bar; FALSE disables it.  The default is TRUE.</param>
      <returns>
        The status bar object.
      </returns>
      <remarks>
        Any status information sent to the application appears on its status bar.
      </remarks>
    </member>
    <member name="M:VO.AppWindow.EnableSystemMenu(XSharp.__Usual)">
      <summary>
        Enable/disable a system menu in an application window.
      </summary>
      <param name="lEnable">TRUE enables the system menu; FALSE disables it.  The default is TRUE.</param>
      <returns>
        If the system menu is enabled, a system menu is returned; if disabled, NIL is returned.
      </returns>
      <example>
        The following example enables a system menu in an application window:
        <code language="X#">oSysMenu := oAppWindow:EnableSystemMenu(TRUE)</code></example>
    </member>
    <member name="M:VO.AppWindow.EnableToolBar(XSharp.__Usual)">
      <summary>
        Enable/disable a toolbar in an application window.
      </summary>
      <param name="lEnable">TRUE enables the toolbar; FALSE disables it.  The default is TRUE.</param>
      <returns>
        The toolbar object.
      </returns>
    </member>
    <member name="M:VO.AppWindow.EnableVerticalScroll(XSharp.__Usual)">
      <summary>
        Enable/disable a window vertical scroll bar in an application window.
      </summary>
      <param name="lEnable">TRUE enables the WindowVerticalScrollBar object; FALSE disables it.  The default is TRUE.</param>
      <returns>
        If the scroll bar is enabled, a WindowVerticalScrollBar object is returned; if disabled, NULL_OBJECT is returned.
      </returns>
      <remarks>
        <note type="tip">This is the only valid way to create a window vertical scroll bar.</note>
        A WindowVerticalScrollBar object is a special type of scroll bar that is aligned along the right side of a window's canvas area.  It resizes itself according to the size of the window that owns it.
        After creating a WindowVerticalScrollBar object, it should then be shown and its range set.
      </remarks>
      <example>
        This example enables a WindowVerticalScrollBar object and sets its range to be 1-200, with a block size of 25:
        <code language="X#">
          METHOD Init() CLASS TopAppWindow
          pwvs := SELF:EnableVerticalScroll()
          pwvs:Show()
          pwvs:Range := Range{1,200}
          pwvs:BlockSize := 25
        </code></example>
    </member>
    <member name="M:VO.AppWindow.EndWindow(XSharp.__Usual)">
      <summary>
        Remove this application window from view (passing control back to the routine which created the application window).
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <param name="lSendMsg">
        A logical value that indicates if the class should use the SendMessage() function to close the window
        (which works immediately) or the PostMessage() function (which adds the message at the message event queue)
      </param>
    </member>
    <member name="M:VO.AppWindow.ErrorMessage(XSharp.__Usual)">
      <summary>
        Display a message in an error box.
      </summary>
      <param name="oHyperLabel">The hyperlabel object containing the description (HyperLabel:Description) to be displayed in the error box.</param>
      <param name="uText">The description to be displayed in the error box.</param>
    </member>
    <member name="M:VO.AppWindow.OLEDragEnter(XSharp.__Usual)">
      <summary>
        Called whenever the mouse enters the window's client area during a drag and drop operation.
      </summary>
      <param name="oOleDragEvent">The specified OLEDragEvent object.</param>
      <remarks>
        The OLE runtime engine calls the following event handlers after an AppWindow object has been registered as an OLE drag and drop target:  OLEDragEnter(), OLEDragOver(), OLEDragLeave(), and OLEDrop().  By investigating the passed OLEDragEvent object (for example, a specific server), you can allow or disallow a drag and drop action by returning TRUE or FALSE.  This also affects the appearance of the drag and drop cursor.  By default OLEDragEnter() returns TRUE.
        <note type="tip">In derived classes you can implement your own OLEDragEnter handlers to customize the default behavior.</note><note type="tip">This method is only available when you include the OLE library in the application's search path.</note></remarks>
    </member>
    <member name="M:VO.AppWindow.OLEDragLeave(XSharp.__Usual)">
      <summary>
        Called whenever the mouse leaves the window's client area during a drag and drop operation.
      </summary>
      <param name="oOleDragEvent">The specified OLEDragEvent object.</param>
      <remarks>
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
        The OLE runtime engine calls the following event handlers after an AppWindow object has been registered as an OLE drag and drop target:  OLEDragEnter(), OLEDragOver(), OLEDragLeave(), and OLEDrop().  By investigating the passed OLEDragEvent object (for example, a specific server), you can allow or disallow a drag and drop action by returning TRUE or FALSE.  This also affects the appearance of the drag and drop cursor.  By default OLEDragLeave() returns TRUE.
        <note type="tip">In derived classes you can implement your own OLEDragLeave handlers to customize the default behavior.</note><note type="tip">This method is only available when you include the OLE library in the application's search path.</note></remarks>
    </member>
    <member name="M:VO.AppWindow.OLEDragOver(XSharp.__Usual)">
      <summary>
        Called whenever the mouse moves within the window's client area during a drag and drop operation.
      </summary>
      <param name="oOleDragEvent">The specified OLEDragEvent object.</param>
      <remarks>
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
        The OLE runtime engine calls the following event handlers after an AppWindow object has been registered as an OLE drag and drop target:  OLEDragEnter(), OLEDragOver(), OLEDragLeave(), and OLEDrop().  By investigating the passed OLEDragEvent object (for example, a specific server), you can allow or disallow a drag and drop action by returning TRUE or FALSE.  This also affects the appearance of the drag and drop cursor.  By default OLEDragOver() returns TRUE.
        <note type="tip">In derived classes you can implement your own OLEDragOver handlers to customize the default behavior.</note><note type="tip">This method is only available when you include the OLE library in the application's search path.</note></remarks>
    </member>
    <member name="M:VO.AppWindow.OLEDrop(XSharp.__Usual)">
      <summary>
        Called whenever the mouse is released within the window's client area during a drag and drop operation.
      </summary>
      <param name="oOleDragEvent">The specified OLEDragEvent object.</param>
      <remarks>
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
        The OLE runtime engine calls the following event handlers after an AppWindow object has been registered as an OLE drag and drop target:  OLEDragEnter(), OLEDragOver(), OLEDragLeave(), and OLEDrop().  By investigating the passed OLEDragEvent object (for example, a specific server), you can allow or disallow a drag and drop action by returning TRUE or FALSE.  This also affects the appearance of the drag and drop cursor.
        By default OLEDrop() returns TRUE.  The typical response to the OLEDrop() event is to create a new OLE object by using the CreateFromOLEDragEvent() method.
        <note type="tip">In derived classes you can implement your own OLEDrop handlers to customize the default behavior.</note><note type="tip">This method is only available when you include the OLE library in the application's search path.</note></remarks>
      <example>
        The following example is from the OLE Container application in ...\SAMPLES\OLE\CONT:
        <code language="X#">
          METHOD OleDrop(oOleDragEvent) CLASS Container
           LOCAL oOle AS OleObject
           LOCAL p AS point
           LOCAL lRet := FALSE AS LOGIC
           oOle := DraggableOLEObject{SELF}
           oOle:AllowInPlace     := TRUE
           oOle:AllowResize      := TRUE
           oOle:AutoSizeOnCreate := TRUE
           IF (oOle:CreateFromOleDragEvent(oOleDragEvent))
             p := oOleDragEvent:Position
             SELF:SetupOLEObject(oOle, p)
             lRet := TRUE
           ENDIF
        </code><code language="X#"> RETURN lRet</code></example>
    </member>
    <member name="M:VO.AppWindow.OLEInPlaceActivate">
      <summary>
        Called whenever a child OLE object is about to be "inplace" activated.
      </summary>
      <example>
        The following example is from the OLE Container application in ...\SAMPLES\OLE\CONT:
        <code language="X#">
          METHOD OLEInPlaceActivate() CLASS Container
            SELF:Owner:ToolBar:Hide()
            //self:Owner:StatusBar:Hide()
            RETURN SUPER:OLEInPlaceActivate()
        </code></example>
    </member>
    <member name="M:VO.AppWindow.OLEInPlaceDeactivate">
      <summary>
        Called whenever a child OLE object is about to be "inplace" deactivated.
      </summary>
      <example>
        The following example is from the OLE Container application in ...\SAMPLES\OLE\CONT:
        <code language="X#">
          METHOD OLEInPlaceDeactivate() CLASS Container
            SELF:Owner:ToolBar:Show()
            //self:Owner:StatusBar:Show()
            RETURN SUPER:OLEInPlaceDeactivate()
        </code></example>
    </member>
    <member name="P:VO.AppWindow.QuitOnClose">
      <summary>
        A logical value.  If set to TRUE, quits the application when this (main) window is closed.  The default value is FALSE.
      </summary>
      <value>A logical value.  If set to TRUE, quits the application when this (main) window is closed.  The default value is FALSE.</value>
    </member>
    <member name="M:VO.AppWindow.ReportException(XSharp.__Usual)">
      <summary>This is a compatibility method that is no longer used or needed.</summary>
      <param name="oRQ">The ReportQueue object that reports an exception.</param>
    </member>
    <member name="M:VO.AppWindow.ReportNotification(XSharp.__Usual)">
      <summary>
        Called by ReportQueue when it has a message for the owner window.
      </summary>
      <param name="oRQ">The ReportQueue object to be checked for pending commands.</param>
      <returns>
        TRUE if there are any pending reporting commands waiting to be executed; otherwise, FALSE.
      </returns>
      <remarks>
        This method provides a mechanism to determine if a report queue that this application window owns has any pending reporting commands.  See ReportQueue:EventType access for different event codes.
        To implement different behavior, recode this method for your class that derives ultimately from AppWindow.  Polymorphism ensures that the event is dispatched to your ReportNotification() handler, rather than AppWindow's.
      </remarks>
      <example>
        This example optionally reacts to a report server closing event and ignores other events:
        <code language="X#">
          METHOD ReportNotification(oRQ) CLASS AppWindow
            LOCAL oTB
            LOCAL Reply
            IF (oRQ:EventType == REPORTSERVERCLOSEEVENT)
               oTB := TextBox{SELF,"You closed";
                  + oRQ:ReportServer,;
                  "Should pending reports be attempted?"}
               oTB:TYPE := BUTTONYESNO + ;
                  BOXICONQUESTIONMARK
               Reply := oTB:Show()
               oTB:Axit()
               IF (Reply == BOXREPLYNO)
                  RETURN FALSE
               ENDIF         // Reply was BOXREPLYYES
            ENDIF
            RETURN TRUE      // De-queue any pending
                           // commands which can cause
                           // restart prompt
        </code></example>
    </member>
    <member name="M:VO.AppWindow.Show(XSharp.__Usual)">
      <summary>
        Display a window.
      </summary>
      <returns>NIL</returns>
      <param name="nShowState">The state in which the window area should be displayed.</param>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>SHOWICONIZED</term>
            <description>Shows the window initially as an icon.  The user must click on the icon to begin to operate the window</description>
          </item>
          <item>
            <term>SHOWNORMAL</term>
            <description>
              Shows the window on its owner, in a size chosen by the owner.  
              If the owner is the desktop, the window appears quite large, but not filling the whole desktop.  
              You can control the window's size precisely, if you wish, by assigning to its Size and Origin variables.  
              The user can always re-size the window to their own requirements.  This is the <b>default</b>.
            </description>
          </item>
          <item>
            <term>SHOWZOOMED</term>
            <description>Shows the window at the maximum size allowed by its owner.  If the owner is the desktop, the window occupies the whole desktop.</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:VO.AppWindow.StatusBar">
      <summary>
        The status bar currently associated with an application window.
        If none is associated, the status bar of the owner window is returned.  If there is no status bar in the ownership hierarchy, NIL is returned.
      </summary>
      <value>
        The status bar currently associated with an application window.
        If none is associated, the status bar of the owner window is returned.  If there is no status bar in the ownership hierarchy, NIL is returned.
      </value>
    </member>
    <member name="M:VO.AppWindow.StatusMessage(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Display a message in an application window's status bar.
      </summary>
      <returns>NIL</returns>
      <param name="oHL">The hyperlabel containing a description (HyperLabel:Description) for the status message or the status message as a string.</param>
      <param name="nType">
        The constant value indicating the type and priority of the message to be displayed on the status bar.  
        The highest priority message (MESSAGEMENU) always takes precedence over and replaces lower priority messages. See table in the remarks section for more info.
      </param>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>MESSAGEMENU</term>
            <description>Priority 4 (Highest priority):  A message associated with a menu selection.</description>
          </item>
          <item>
            <term>MESSAGEERROR</term>
            <description>Priority 3:  An error message.</description>
          </item>
          <item>
            <term>MESSAGECONTROL</term>
            <description>Priority 2:  A message associated with a control.</description>
          </item>
          <item>
            <term>MESSAGEPERMANENT</term>
            <description>
              Priority 1 (Lowest priority):  The default message displayed on the status bar; stored whenever a higher
              priority message takes precedence and redisplayed when no other messages take priority.  This is the <b>default</b>.
            </description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:VO.AppWindow.SystemMenu">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.AppWindow.ToolBar">
      <summary>
        The toolbar that corresponds to the application window.  (If a value of NIL is returned, there was no previously selected toolbar.)
      </summary>
      <value>The toolbar that corresponds to the application window.  (If a value of NIL is returned, there was no previously selected toolbar.)</value>
    </member>
    <member name="M:VO.AppWindow.WarningMessage(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Display a message in an warning box.
      </summary>
      <param name="aPlace1">The hyperlabel containing the caption and description (HyperLabel:Caption and HyperLabel:Description) for the warning box, or the caption to be displayed in the warning box.</param>
      <param name="aPlace2">The description to be displayed in the warning box.</param>
      <returns>The return value of the WarningBox:Show() call</returns>
    </member>
    <member name="T:VO.ASPAppAbstract">
      <summary>
        Define the common protocol for OLE server applications.
        This in an abstract class and should not be used directly — instead, use one of its subclasses.
      </summary>
      <remarks>
        This abstract class defines the common protocol — properties and behavior — used by the various X# HTTP server applications.
      </remarks>
    </member>
    <member name="M:VO.ASPAppAbstract.Exec">
      <summary>
        Start the event handling loop for the non-GUI application.
      </summary>
      <remarks>
        Normally, the event handling loop for the application continues looping until there are no more EventContext objects.  It can also terminate upon calling ASPAppAbstract:Quit().
      </remarks>
      <example>
        The following code shows the framework for an out-of-process ASP component application:
        <code language="X#">
          CLASS ASPComponent INHERIT IScriptingContext
          GLOBAL oLogFile AS LogFile
          FUNC Start()
          LOCAL oServer AS ASPComponent
          LOCAL oAspApp AS AspApp
          #IFDEF __DEBUG__
          oLogFile := LogFile{}
          oLogFile:DebugMsg("ASP Component started ...")
          #ENDIF
          oAspApp := ASPApp{}
          oServer := ASPComponent{}
          oServer:ASPApp := oAspApp
          oAspApp:Exec()
        </code></example>
    </member>
    <member name="M:VO.ASPAppAbstract.Quit">
      <summary>
        Terminate a non-GUI application by instructing the application to close itself.
      </summary>
      <remarks>
        This method is normally invoked when an Exit menu command is selected.
      </remarks>
    </member>
    <member name="T:VO.AutoServer">
      <summary>
        Base class for implementing an OLE automation server.
      </summary>
      <remarks>
        The AutoServer class can be used as the base class for implementing OLE automation servers.  You can use any X# class as the automation interface; however, if you decide to let your automation server inherit from AutoServer, you do not have to perform the registration calls, RegisterOLEAutomationObject() and UnregisterOLEAutomationObject().
        For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
      </remarks>
    </member>
    <member name="M:VO.AutoServer.#ctor">
      <summary>
        Instantiate a new AutoServer object.
      </summary>
      <param name="oOwnerWnd">The owner of the automation server.</param>
      <param name="sProgramID">The program ID of the automation server.  The program ID is a string that uniquely identifies the automation server.</param>
      <param name="iResID">The resource ID of the automation server's type library.  The default is 1.</param>
      <param name="lASP">A flag specifying if the automation server is to be used as an ASP component.  The default is TRUE, if &lt;oOwnerWnd&gt; is a descendant of the ASPAppAbstract class; otherwise, FALSE.</param>
      <remarks>
        The Init() method instantiates a new automation Server object.
        <note type="tip">When creating OLE automation server applications in the IDE, you have to set the application properties on the OLE Server tab page in the Application Options dialog box to match the ProgID and class of your automation server.</note></remarks>
    </member>
    <member name="M:VO.AutoServer.CloseServer">
      <summary>
        Close the server application.
      </summary>
      <remarks>
        If a X# class representing an Automation Server implements a CloseServer() method, this method is called whenever the reference count of the server reaches 0, i.e., when the last client closes the connection to the server.  The default implementation in the AutoServer class is to terminate the server application.
      </remarks>
    </member>
    <member name="M:VO.AutoServer.Destroy">
      <summary>
        Provide a method to de-instantiate an AutoServer object.
      </summary>
      <remarks>
        This method can be used when an AutoServer object is no longer needed.
      </remarks>
    </member>
    <member name="M:VO.AutoServer.HelpAbout">
      <summary>
        Displays a "help about" message box.
      </summary>
      <remarks>
        An automation server usually offers a HelpAbout() method.  In this base class, the HelpAbout() method displays a simple message box.  In derived classes, however, you will probably want to override the method for specialized automation servers.
      </remarks>
    </member>
    <member name="P:VO.AutoServer.Owner">
      <summary>
        The owner — window, control, or application — of the automation server.
      </summary>
      <value>The owner — window, control, or application — of the automation server.</value>
    </member>
    <member name="T:VO.BaseListBox">
      <summary>
        Provide the base class from which all X# list boxes are subclassed.
      </summary>
      <remarks>
        List boxes display a list of strings (or items) to the user.  You can use the methods of BaseListBox to add, arrange, remove, and interrogate the items in a list box.  You can also specify how the items in a list box should be sorted.
        When an item in a list box is single- or double-clicked, the event handlers Window:ListBoxClick() and Window:ListBoxSelect() are triggered in the list box's owner window, respectively.
      </remarks>
    </member>
    <member name="M:VO.BaseListBox.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a list box.
      </summary>
      <param name="oOwner">The window that owns the list box.</param>
      <param name="xID">The unique ID of the list box (between 1 and 8000).</param>
      <param name="oPoint">The origin of the list box in canvas coordinates.</param>
      <param name="oDimension">The dimension of the list box in canvas coordinates.</param>
      <param name="kStyle">The style of the list box, specified as one of the following constants:</param>
      <param name="lDataAware">A logical value specifying whether the list box is data aware.</param>
      <param name="nResourceID">The resource ID of the list box.</param>
      <remarks>
        <pre>
          Constant                  Windows API Constant
          LBOXDISABLENOSCROLL       LBS_DISABLENOSCROLL
          LBOXEXTENDEDSEL           LBS_EXTENDEDSEL
          LBOXHASSTRINGS            LBS_HASSTRINGS
          LBOXMULTICOLUMN           LBS_MULTICOLUMN
          LBOXMULTIPLESEL           LBS_MULTIPLESEL
          LBOXNOINTEGRALHEIGHT      LBS_NOINTEGRALHEIGHT
          LBOXNOREDRAW              LBS_NOREDRAW
          LBOXNOTIFY                LBS_NOTIFY
          LBOXOWNERDRAWFIXED        LBS_OWNERDRAWFIXED
          LBOXOWNERDRAWVARIABLE     LBS_OWNERDRAWVARIABLE
          LBOXSORT                  LBS_SORT
          LBOXSTANDARD              LBS_STANDARD
          LBOXUSETABSTOPS           LBS_USETABSTOPS
          LBOXWANTKEYBOARDINPUT     LBS_WANTKEYBOARDINPUT
        </pre>
      </remarks>
    </member>
    <member name="M:VO.BaseListBox.AddItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Add a new item to a list box at a specified position.
      </summary>
      <param name="cItem">The item to be inserted.</param>
      <param name="nItemNumber">The position in the list box at which to insert the new item.  Specify one of the following values:</param>
      <param name="Value">Position</param>
      <param name="0">In an unsorted list box, adds the new item at the end of the list; if sorted, inserts the new item at a position determined by the list box.  This is the default.</param>
      <param name="1">The first position in the list box.</param>
      <param name="n">The nth position in the list box.</param>
      <returns>
        If the item was added, its position in the list box is returned (a value of 1 refers to the first position in the list box).  If the item could not be added, 0 is returned.
      </returns>
    </member>
    <member name="M:VO.BaseListBox.Clear">
      <summary>
        Clear a list box of all items.
      </summary>
    </member>
    <member name="P:VO.BaseListBox.CurrentItem">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.BaseListBox.CurrentItemNo">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.BaseListBox.CurrentText">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.BaseListBox.DeleteItem(XSharp.__Usual)">
      <summary>
        Remove an item from a list box.
      </summary>
      <param name="nItemNumber">The number of the item to be deleted.  Specify one of the following values:</param>
      <param name="Value">Position</param>
      <param name="0">The currently selected item.  This is the default.</param>
      <param name="1">The first item.</param>
      <param name="n">The nth item.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.BaseListBox.Destroy">
      <summary>
        Provide a method to de-instantiate a BaseListBox object.
      </summary>
      <remarks>
        This method can be used when a BaseListBox object is no longer needed.  BaseListBox:Destroy() de-instantiates the BaseListBox object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
      <returns>
        NIL
      </returns>
    </member>
    <member name="M:VO.BaseListBox.FindItem(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Search a list box for a specified string, and return the location of the first item in the list box that matches it.
      </summary>
      <param name="cItem">The text to search for.</param>
      <param name="lWholeItem">Indicates how the search is to be performed.  TRUE matches an exact &lt;cItem&gt; string to a 'whole' list box item (for example, a 'can' string does not match 'scan').  FALSE finds a match for any list box prefixed by &lt;cItem&gt; (for example, the string 'cat' would match 'catalog' in the list box).  The default is TRUE.</param>
      <param name="nStart">Specifies the one-based index of the item before the first item to be searched. When the search reaches the bottom of the list box, it continues searching from the top of the list box back to the item specified by the nStart parameter. If nStart is 0, the entire list box is searched from the beginning. </param>
      <returns>
        The position of the first item that contains the matching text, if a match is found (a value of 1 refers to the first position in the list box); if no match is found, 0 is returned.
        For example, if &lt;cItem&gt; matched the fifth string in the list box, the return value would be 5.  This means that no earlier string in the list box matched it.
      </returns>
    </member>
    <member name="M:VO.BaseListBox.GetItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Retrieve the text of a specified list box item.
      </summary>
      <param name="nItemNumber">
        The number of the desired item.  Specify one of the following values:
        <pre>
          Value   Position
          0       The currently selected item.
          1       The first item.
          n       The nth item.
        </pre></param>
      <param name="nLength">Optional numeric value that indicates how long the returned string should be.</param>
      <returns>
        The text of the specified item.
      </returns>
    </member>
    <member name="P:VO.BaseListBox.ItemCount">
      <summary>
        A numeric value representing the number of items in the list box.
      </summary>
      <value>A numeric value representing the number of items in the list box.</value>
    </member>
    <member name="M:VO.BaseListBox.SetTop(XSharp.__Usual)">
      <summary>
        Move a specified item to the top of the list box.
      </summary>
      <param name="nItemNumber">The number of the item to be moved.  Specify one of the following values:</param>
      <param name="Value">Position</param>
      <param name="0">The currently selected item.</param>
      <param name="1">The first item.</param>
      <param name="n">The nth item.</param>
    </member>
    <member name="T:VO.Bitmap">
      <summary>
        Create a bitmap, which is a bit pattern entity — that is, a two-dimensional array of pixels, each pixel having color attributes (monochrome or color).
      </summary>
      <remarks>
        In X#, bitmaps are created from resource entities, and can be used to create brushes and icons.
      </remarks>
    </member>
    <member name="M:VO.Bitmap.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Load a bitmap from the resource entity.
      </summary>
      <param name="xResourceID">The ResourceID object of the bitmap or the  numeric resource ID of the bitmap.</param>
      <param name="kLoadOption">The optional constant representing the load option. The default is LR_DEFAULTCOLOR.</param>
      <param name="iWidth">The optional width of the bitmap. The default is the width of the bitmap.</param>
      <param name="iHeight">The optional height of the bitmap. The default is the height of the bitmap.</param>
    </member>
    <member name="M:VO.Bitmap.Destroy">
      <summary>
        Provide a method to de-instantiate a Bitmap object.
      </summary>
      <remarks>
        This method can be used when a Bitmap object is no longer needed.  Bitmap:Destroy() de-instantiates the Bitmap object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
      <returns>
        NIL
      </returns>
    </member>
    <member name="M:VO.Bitmap.Handle">
      <summary>
        Return the handle for a bitmap.
      </summary>
      <param name="nHandleType">The type of handle required.  0 is the only supported option and is the default if &lt;nHandleType&gt; is omitted.</param>
      <returns>
        A handle describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
      </remarks>
    </member>
    <member name="P:VO.Bitmap.Size">
      <summary>
        A Dimension object representing the size of the bitmap.
      </summary>
      <value>A Dimension object representing the size of the bitmap.</value>
    </member>
    <member name="T:VO.BitmapObject">
      <summary>
        Create a Bitmap object; this type of entity is part of the DrawObject hierarchy, which provides a means of displaying and manipulating various objects.
      </summary>
    </member>
    <member name="M:VO.BitmapObject.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a BitmapObject object.
      </summary>
      <param name="oPoint">The origin of the BitmapObject object, in canvas coordinates.</param>
      <param name="oDimension">The dimension of the BitmapObject object, in canvas coordinates.</param>
      <param name="oBitmap">The bitmap to be used.</param>
    </member>
    <member name="P:VO.BitmapObject.BoundingBox">
      <summary>
        A bounding box representing the smallest rectangle that completely encloses the BitmapObject object.
      </summary>
      <value>A bounding box representing the smallest rectangle that completely encloses the BitmapObject object.</value>
    </member>
    <member name="M:VO.BitmapObject.Draw">
      <summary>
        Draw the BitmapObject object on the window.
      </summary>
    </member>
    <member name="P:VO.BitmapObject.Size">
      <summary>
        A Dimension object representing the size of a BitmapObject object.
      </summary>
      <value>A Dimension object representing the size of a BitmapObject object.</value>
    </member>
    <member name="T:VO.BoundingBox">
      <summary>
        Create a bounding box, which is a set of four numbers that represent the bottom-left and top-right corners of a rectangle.  
      </summary>
      <example>
        The following returns the smallest rectangle that encloses an EllipseObject object, in canvas coordinates:
        <code language="X#">LOCAL oBB := oEllipse:BoundingBox()</code></example>
      <remarks>
        Typically, the rectangle is the smallest one that encloses both the overall size and position of another object (for example, a drawing or an area of a window that needs repainting).
        <note type="tip">A bounding box has no graphical representation — it is just four numbers encapsulated in a class.</note></remarks>
    </member>
    <member name="M:VO.BoundingBox.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a bounding box.
      </summary>
      <param name="oPoint">The origin of the bounding box, in canvas coordinates.</param>
      <param name="xPoint">
        The dimension of the bounding box. This may be a <see cref="T:VO.Dimension">Dimension object</see>or a <see cref="T:VO.Dimension">Point object</see>.
      </param>
    </member>
    <member name="P:VO.BoundingBox.Bottom">
      <summary>
        A numeric value representing the Y coordinate of the bottom side of a bounding box, in canvas coordinates.
      </summary>
      <value>A numeric value representing the Y coordinate of the bottom side of a bounding box, in canvas coordinates.</value>
    </member>
    <member name="M:VO.BoundingBox.ConvertToScreen(XSharp.__Usual)">
      <summary>
        Convert a bounding box to screen coordinates for a given window.
      </summary>
      <param name="oWindow">
        The <see cref="T:VO.Window">window object</see>to use for the conversion.
      </param>
      <returns>
        TRUE.
      </returns>
    </member>
    <member name="P:VO.BoundingBox.Extent">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.BoundingBox.Height">
      <summary>
        A numeric value representing the height of the bounding box, measured in canvas coordinates.
      </summary>
      <value>A numeric value representing the height of the bounding box, measured in canvas coordinates.</value>
    </member>
    <member name="P:VO.BoundingBox.Left">
      <summary>
        A numeric value representing the X coordinate of the left side of a bounding box, in canvas coordinates.
      </summary>
      <value>A numeric value representing the X coordinate of the left side of a bounding box, in canvas coordinates.</value>
    </member>
    <member name="P:VO.BoundingBox.Origin">
      <summary>
        A point representing the location of a bounding box, in canvas coordinates.
      </summary>
      <value>A point representing the location of a bounding box, in canvas coordinates.</value>
    </member>
    <member name="M:VO.BoundingBox.PointInside(XSharp.__Usual)">
      <summary>
        Test whether a given point is within the bounds of a bounding box.
      </summary>
      <param name="oPoint">The point to be tested.</param>
      <returns>
        TRUE if the point is in the bounding box; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.BoundingBox.Right">
      <summary>
        A numeric value representing the X coordinate of the right side of a bounding box, in canvas coordinates.
      </summary>
      <value>A numeric value representing the X coordinate of the right side of a bounding box, in canvas coordinates.</value>
    </member>
    <member name="P:VO.BoundingBox.Size">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.BoundingBox.Top">
      <summary>
        A numeric value representing the Y coordinate of the top side of a bounding box, in canvas coordinates.
      </summary>
      <value>A numeric value representing the Y coordinate of the top side of a bounding box, in canvas coordinates.</value>
    </member>
    <member name="M:VO.BoundingBox.Union_(XSharp.__Usual)">
      <summary>
        Return a new bounding box that represents the minimum area required to contain both this bounding box and the bounding box specified by &lt;oBoundingBox&gt;.
      </summary>
      <param name="oBB">The bounding box to be joined with this bounding box.</param>
    </member>
    <member name="P:VO.BoundingBox.Width">
      <summary>
        A numeric value representing the width of the bounding box, in canvas coordinates.
      </summary>
      <value>A numeric value representing the width of the bounding box, in canvas coordinates.</value>
    </member>
    <member name="T:VO.Brush">
      <summary>
        Create a brush, which can be used by the Window:PaintBoundingBox() method and the DrawObject hierarchy.
      </summary>
      <remarks>
        You can create a brush by specifying a color and pattern combination.  (The specified pattern can either be one of the default, predefined patterns or a user-supplied bitmap.)
      </remarks>
      <example>
        This example changes the background of the window to white and paints a yellow, cross-hatched rectangle:
        <code language="X#">
          oWindow:Background := Brush{BRUSHWHITE}
          oBYellow := Brush{Color{COLORYELLOW},HATCHORTHOGONALCROSS}
          oBPrevious := oWindow:Foreground
          oWindow:Foreground := oBYellow
          oWindow:PaintBoundingBox(Point{0,0}, Dimension{100,100})
          oWindow:Foreground := oBPrevious
        </code></example>
    </member>
    <member name="M:VO.Brush.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a brush.
      </summary>
      <param name="oParent">** missing parameter documentation **</param>
      <param name="xColor">
        The new brush's color object.  (Refer to the Color:Init() method for details on specifying a color object.) or
        the standard brush to create, specified as one of constants below.
      </param>
      <param name="kHatchStyle">The new brush's pattern (also called a hatching style or meshed line pattern).  Specify one of the constants below.</param>
      <remarks>
        xColor constants
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>BRUSHBLACK</term><description>Black</description></item><item><term>BRUSHCLEAR</term><description>Clear (transparent)</description></item><item><term>BRUSHDARK</term><description>Dark gray</description></item><item><term>BRUSHHOLLOW</term><description>Clear (transparent)</description></item><item><term>BRUSHLIGHT</term><description>Light gray</description></item><item><term>BRUSHMEDIUM</term><description>Gray</description></item><item><term>BRUSHWHITE</term><description>White</description></item></list>
        kHatchStyle constants:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>0</term><description>Prepares a brush.</description></item><item><term>HATCHDIAGONAL135</term><description>A pattern of 135-degree angle parallel lines.</description></item><item><term>HATCHDIAGONAL45</term><description>A pattern of 45-degree angle parallel lines.</description></item><item><term>HATCHDIAGONALCROSS</term><description>A combination of HATCHDIAGONAL45 and HATCHDIAGONAL135.</description></item><item><term>HATCHHORIZONTAL</term><description>A pattern of horizontal parallel lines.</description></item><item><term>HATCHORTHOGONALCROSS</term><description>A combination of HATCHHORIZONTAL and HATCHVERTICAL.</description></item><item><term>HATCHSOLID</term><description>A solid blocking pattern.  This is the default.</description></item><item><term>HATCHVERTICAL</term><description>A pattern of vertical parallel lines.</description></item></list></remarks>
    </member>
    <member name="M:VO.Brush.CreateNew(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="xColor">** missing parameter documentation **</param>
      <param name="kHatchStyle">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.Brush.Destroy">
      <summary>
        Provide a method to de-instantiate a Brush object.
      </summary>
      <remarks>
        This method can be used when a Brush object is no longer needed.  Brush:Destroy() de-instantiates the Brush object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.Brush.Handle">
      <summary>
        Return the handle for a brush.
      </summary>
      <param name="nHandleType">The type of handle required.  0 is the only supported option and is the default if &lt;nHandleType&gt; is omitted.</param>
      <returns>
        A handle describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
      </remarks>
    </member>
    <member name="T:VO.Button">
      <summary>
        Provide the base class from which all X# buttons are subclassed.
      </summary>
      <remarks>
        You can also use the ControlWindow class to create buttons with behaviors and/or appearances that differ from standard buttons.  Using ControlWindow permits controls to trap events.  Typical uses might include customizing the appearance of controls (like changing the background and foreground colors) or modifying the key handling.
      </remarks>
    </member>
    <member name="M:VO.Button.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a button.
      </summary>
      <param name="oOwner">The window that owns the button.</param>
      <param name="xID">The unique ID of the button (between 1 and 8000).</param>
      <param name="oPoint">The origin of the button in canvas coordinates.</param>
      <param name="oDimension">The dimension of the button in canvas coordinates.</param>
      <param name="cText">The informational text to be printed in the button.  By default, it is a NULL_STRING.</param>
      <param name="kStyle">
        The style of the button, specified by a Windows API style constant.  
        <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular Windows API style constant.</note></param>
      <param name="lDataAware">A logical value specifying whether the button is data aware. If omitted, defaults to FALSE.</param>
      <param name="nResourceID">The resource ID of the button.</param>
    </member>
    <member name="M:VO.Button.AsString">
      <summary>
        Return an identifying label for the button.
      </summary>
      <remarks>
        Button:AsString() presents the button control as a recognizable string of the form &lt;ClassName&gt; - &lt;Caption&gt;.
      </remarks>
    </member>
    <member name="P:VO.Button.Caption">
      <summary>
        A string representing the text that is displayed adjacent to a check box or radio button, or on top of a push button.  The Button:Caption assign also changes Button:CurrentText for the button.
      </summary>
      <value>A string representing the text that is displayed adjacent to a check box or radio button, or on top of a push button.  The Button:Caption assign also changes Button:CurrentText for the button.</value>
    </member>
    <member name="P:VO.Button.CurrentText">
      <summary>
        For check boxes, push buttons, and radio buttons, Button:CurrentText contains NULL_STRING.
      </summary>
      <value>For check boxes, push buttons, and radio buttons, Button:CurrentText contains NULL_STRING.</value>
    </member>
    <member name="P:VO.Button.Image">
      <summary>
        An image object representing the icon or bitmap image that is displayed on a button.
      </summary>
      <value>An image object representing the icon or bitmap image that is displayed on a button.</value>
    </member>
    <member name="P:VO.Button.ImageList">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Button.Modified">
      <summary>
        A logical value that is set to TRUE when the user clicks on a button, and reset to FALSE when the mouse button is released.
      </summary>
      <value>A logical value that is set to TRUE when the user clicks on a button, and reset to FALSE when the mouse button is released.</value>
    </member>
    <member name="M:VO.Button.SetStyle(XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="T:VO.ButtonImageList">
      <summary>
        Create an image list for use with buttons.
      </summary>
      <remarks>
        Images used on buttons are automatically put into a ButtonImageList as part of the WinXP support.
      </remarks>
    </member>
    <member name="M:VO.ButtonImageList.#ctor(XSharp.__Usual)">
      <summary>
        Constructs an image list object that is used by the button class for WinXP support.
      </summary>
      <param name="oImage">The image object to be put into the image list.</param>
    </member>
    <member name="P:VO.ButtonImageList.Image">
      <summary>
        The current image object in the ButtonImageList.
      </summary>
      <value>The current image object in the ButtonImageList.</value>
    </member>
    <member name="T:VO.CEmail">
      <summary>
        Provide a class to store and decode all data for an e-mail.
      </summary>
      <remarks>
        This class provides all necessary methods and properties for checking and receiving e-mail from an Internet POP Server. The class decodes email text string passed into its header components only. HTML and attachment components are decoded as required.
      </remarks>
      <example>
        <code language="X#">
          FUNCTION SMTPSendMail       (cServerIP      AS STRING,;
               cMailSubject   AS STRING,;
               xDestUser      AS USUAL,;
               xCCUser        AS USUAL,;
               cBody          AS STRING,;
               cFromAddress   AS STRING,;
               xAttachFile    AS USUAL,;
               cFromName      AS STRING,;
               xBCCUser       AS USUAL,;
               cCargo         AS STRING)   AS LOGIC PASCAL
            LOCAL oSmtp    AS CSMTP
            LOCAL lRet     AS LOGIC
            LOCAL oEmail   AS CEmail
            oEMail := CEmail{}
            oEmail:FromAddress   := cFromAddress
            oEmail:FromName      := cFromName
            oEmail:Cargo         := cCargo
            oEmail:Subject       := cMailSubject
            oEmail:DestList      := xDestUser
            oEmail:CCList        := xCCUser
            oEmail:BCCList       := xBCCUser
            oEmail:MailBody        := cBody
            IF !IsNil(xAttachFile)
               oEmail:AttachmentFileList := xAttachFile
            ENDIF
            oSmtp := CSmtp{oEmail}
            oSMtp:RemoteHost  := cServerIP
            oSmtp:TimeOut := 5000
            lRet := oSmtp:SendMail()
            RETURN lRet
        </code>
        See Also
        CLASS CPop, CLASS CSmtp, Class CStorage
      </example>
    </member>
    <member name="M:VO.CEmail.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a CEmail object.
      </summary>
      <param name="cRawMail">** missing parameter documentation **</param>
      <param name="uStorage">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CEmail.AddAttachment(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Adds an attachment to the email.
      </summary>
      <param name="cFullPath">The file to attach to the email</param>
      <param name="cContentType">The content type to use. The default is 'application/octet-stream'</param>
      <param name="dwEncodeType">The Encoding to use. The default is </param>
      <param name="cContentID">** missing parameter documentation **</param>
      <param name="cFilename">The filename to use in the message body. The default is the name of the file itself.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.CEmail.AttachmentFileList">
      <summary>
        Array containing the names of the attached files.
      </summary>
      <value>Array containing the names of the attached files.</value>
    </member>
    <member name="P:VO.CEmail.AttachmentInfo">
      <summary>
        Returns or sets the information about all attachments as a single string.
        For each attachment there is a separate line.
        Each line contains: The Fully qualified filename, Content Type, Encoding, ID, Size, ContentId
      </summary>
      <value>
        or sets the information about all attachments as a single string.
        For each attachment there is a separate line.
        Each line contains: The Fully qualified filename, Content Type, Encoding, ID, Size, ContentId
      </value>
    </member>
    <member name="P:VO.CEmail.AttachmentList">
      <summary>
        Array of strings containing the encoded contents of the attached files.
      </summary>
      <value>Array of strings containing the encoded contents of the attached files.</value>
    </member>
    <member name="P:VO.CEmail.BCCList">
      <summary>
        Array of strings containing the e-mails of all blind carbon copy (BCC) recipients.
      </summary>
      <value>Array of strings containing the e-mails of all blind carbon copy (BCC) recipients.</value>
    </member>
    <member name="P:VO.CEmail.Boundary">
      <summary>
        String value used as boundary for different e-mail parts.
      </summary>
      <value>String value used as boundary for different e-mail parts.</value>
    </member>
    <member name="P:VO.CEmail.Cargo">
      <summary>
        String value for additional user-defined header information.
      </summary>
      <value>String value for additional user-defined header information.</value>
    </member>
    <member name="P:VO.CEmail.CCList">
      <summary>
        Array of strings containing the e-mails of all carbon copy (CC) recipients.
      </summary>
      <value>Array of strings containing the e-mails of all carbon copy (CC) recipients.</value>
    </member>
    <member name="M:VO.CEmail.CloneAttachments">
      <summary>
        Clones the internal Attachment array.
      </summary>
      <returns>
        Nothing
      </returns>
    </member>
    <member name="M:VO.CEmail.CreateHtml(System.String)">
      <summary>
        Creates a HTML body based on the text body of the email message.
      </summary>
      <param name="cText">The text to encode</param>
      <returns>
        cHTML	a HTML copy of cText.
      </returns>
    </member>
    <member name="M:VO.CEmail.CreateReplyBody(System.Boolean)">
      <summary>
        Prepares a default text response.
      </summary>
      <param name="lReFormat">** missing parameter documentation **</param>
      <remarks>
        This method prepares a default reply text and places it in the cText instance variable of the Class. It incorporates a From Address, destination list and datetime stamp. The existing text lines are prefixed with an "&gt; " and any HTML text is cleaned out.
      </remarks>
    </member>
    <member name="P:VO.CEmail.DateTimeStamp">
      <summary>
        A string containing the fully qualified date and time of the email.
      </summary>
      <value>A string containing the fully qualified date and time of the email.</value>
    </member>
    <member name="M:VO.CEmail.Decode(XSharp.__Usual)">
      <summary>
        Extract all information from the various parts of an e-mail.
      </summary>
      <param name="cMail">The mail message to decode.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method knocks down all of the different parts of the raw e-mail stream and assigns them to appropriate properties.
      </remarks>
    </member>
    <member name="M:VO.CEmail.DeleteAttachment(System.UInt32)">
      <summary>
        Adds an attachment to the email.
      </summary>
      <param name="dwIndex">The index of the attachment to delete</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.CEmail.DestList">
      <summary>
        Array of strings containing the e-mail addresses of all recipients.
      </summary>
      <value>Array of strings containing the e-mail addresses of all recipients.</value>
    </member>
    <member name="P:VO.CEmail.DispositionNotification">
      <summary>
        A string containing the email address of a party to be notified that the email was received. This is sometimes replaced with a Return Receipt by some email clients.
      </summary>
      <value>A string containing the email address of a party to be notified that the email was received. This is sometimes replaced with a Return Receipt by some email clients.</value>
    </member>
    <member name="M:VO.CEmail.EncodeAttachment">
      <summary>
        Provide a method to encode the provided file and provide the mail section header to properly define the attachment to the email.
      </summary>
      <param name="cFilename">The full path name to the file to be attached.</param>
      <returns>
        STRING containing error information. The string will be empty if the encoding was successful.
      </returns>
      <remarks>
        This method encodes the presented filename with Base64 Encoding and formats the full text for an attachment section and adds it to the email.
      </remarks>
    </member>
    <member name="P:VO.CEmail.Error">
      <summary>
        Numeric value representing the last error code that occurred.
      </summary>
      <value>Numeric value representing the last error code that occurred.</value>
    </member>
    <member name="P:VO.CEmail.ErrorMsg">
      <summary>
        A string representing the error description.
      </summary>
      <value>A string representing the error description.</value>
    </member>
    <member name="M:VO.CEmail.FindBoundary">
      <summary>
        Locate a boundary within an email section
      </summary>
      <param name="cSection">The email section text in which the search is to take place.</param>
      <returns>
        STRING containing the found boundary.
      </returns>
      <remarks>
        This method can be used to find the main boundary of the email body or a sub boundary.
      </remarks>
    </member>
    <member name="P:VO.CEmail.FromAddress">
      <summary>
        String containing the sender's e-mail.
      </summary>
      <value>String containing the sender's e-mail.</value>
    </member>
    <member name="P:VO.CEmail.FromName">
      <summary>
        String representing the sender's name.
      </summary>
      <value>String representing the sender's name.</value>
    </member>
    <member name="P:VO.CEmail.FullFromAddress">
      <summary>
        The From Address as specified in the email header.
      </summary>
      <value>The From Address as specified in the email header.</value>
    </member>
    <member name="M:VO.CEmail.GetAttachmentInfo(System.UInt32,System.UInt32)">
      <summary>
        Method to decode all header elements of an email
      </summary>
      <param name="dwIndex">** missing parameter documentation **</param>
      <param name="dwType">** missing parameter documentation **</param>
      <remarks>
        This method reads the current raw email data and decodes all header elements into their respective ivars. The process also decodes and separates all addressees and resolves names, datetime stamps, priority and receipt requirements.
      </remarks>
    </member>
    <member name="M:VO.CEmail.GetHeaderInfo">
      <summary>
        Method to decode all header elements of an email
      </summary>
      <remarks>
        This method reads the current raw email data and decodes all header elements into their respective ivars. The process also decodes and separates all addressees and resolves names, datetime stamps, priority and receipt requirements.
      </remarks>
    </member>
    <member name="P:VO.CEmail.HTMLText">
      <summary>
        A properly formed HTML text string suitable for display in a web browser pane. If the email did not contain an HTM component, one is formed from the Text component by wrapping it in appropriate tags.
        If the email did contain HTML and had embedded images (marked with src="cid:) then these references will be replaced with references to the actual files names of these images.
      </summary>
      <value>
        A properly formed HTML text string suitable for display in a web browser pane. If the email did not contain an HTM component, one is formed from the Text component by wrapping it in appropriate tags.
        If the email did contain HTML and had embedded images (marked with src="cid:) then these references will be replaced with references to the actual files names of these images.
      </value>
    </member>
    <member name="P:VO.CEmail.MailBody">
      <summary>
        String containing the mail text.
      </summary>
      <value>String containing the mail text.</value>
    </member>
    <member name="P:VO.CEmail.MailDate">
      <summary>
        Date value representing the e-mail's received (sent) data.
      </summary>
      <value>Date value representing the e-mail's received (sent) data.</value>
    </member>
    <member name="P:VO.CEmail.MailHeader">
      <summary>
        String containing the mail's header text.
      </summary>
      <value>String containing the mail's header text.</value>
    </member>
    <member name="P:VO.CEmail.MailPriority">
      <summary>
        Numeric value representing the e-mail priority.
      </summary>
      <value>Numeric value representing the e-mail priority.</value>
    </member>
    <member name="P:VO.CEmail.MailTime">
      <summary>
        Time string representing the e-mail's sent time.
      </summary>
      <value>Time string representing the e-mail's sent time.</value>
    </member>
    <member name="M:VO.CEmail.MimeEncode(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Method to encode a string using a specific encoding or the default encoding of an email
      </summary>
      <param name="c">Optional String to encode. The default is to encode the body</param>
      <param name="nCode">
        Optional encoding type to use. VO supports the following two encodings:
        CODING_TYPE_PRINTABLE (the default)
        CODING_TYPE_BASE64
      </param>
      <returns>
        The encoded string.
      </returns>
    </member>
    <member name="M:VO.CEmail.MimeHeader(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Method to encode an MIME Attachment header
      </summary>
      <param name="nCode">
        Optional encoding type to use. VO supports the following two encodings:
        CODING_TYPE_PRINTABLE (the default)
        CODING_TYPE_BASE64
      </param>
      <param name="xContentType">
        Content type to use when encoding. The default is the content type of the message. When one of the following is used VO will assume that the file is part of the body:
        If another type is used, VO will assume that the file is not part of the message body but an attachment
      </param>
      <param name="cFile">File name to use for the encoded header. This name is not used for the three content types mentioned above.</param>
      <param name="cCID">** missing parameter documentation **</param>
      <returns>
        The encoded string.
      </returns>
      <remarks>
        The MimeHeader() method is called by the CEMail:StreamOut() method during the streaming of the message.
      </remarks>
    </member>
    <member name="P:VO.CEmail.Priority">
      <summary>
        A numeric value representing the priority of the email (normal = 3).
      </summary>
      <value>A numeric value representing the priority of the email (normal = 3).</value>
    </member>
    <member name="P:VO.CEmail.ReplyTo">
      <summary>
        String value containing the e-mail to which a reply is being sent.
      </summary>
      <value>String value containing the e-mail to which a reply is being sent.</value>
    </member>
    <member name="P:VO.CEmail.ReturnReceipt">
      <summary>
        A string containing the email address of a party to be sent a receipt advice. Some email clients may use this to contain a return receipt and others may use Disposition Notification instead.
      </summary>
      <value>A string containing the email address of a party to be sent a receipt advice. Some email clients may use this to contain a return receipt and others may use Disposition Notification instead.</value>
    </member>
    <member name="M:VO.CEmail.SaveAs(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Decode and save the specified encoded attachment of an e-mail as a local file.
      </summary>
      <param name="cPath">The directory in which the file is to be saved.  If not specified, the attachment will be saved within the current directory.</param>
      <param name="cFile">String containing a new file name for the attachment being saved.  If not specified, the attachment will be saved under the file name contained in the attachment e-mail header.</param>
      <param name="n">Number specifying which of the multiple attachments should be decoded and saved as a file.  If not specified, the first attachment will be saved.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method decodes the specified encoded attachment and saves it either under the specified or default file name.
      </remarks>
    </member>
    <member name="M:VO.CEmail.SetAttachmentInfo(System.UInt32,System.UInt32,XSharp.__Usual)">
      <summary>
        This method allows you to replace elements of the internal attachment array of the email object.
      </summary>
      <param name="dwIndex">The element in the attachment array that needs to be replaced</param>
      <param name="dwType">
        The type of information that needs to be replaced. This can be one of:
        ATTACH_STOREID (1)
        ATTACH_CONTENTID (2)
        ATTACH_FILESIZE (3)
        ATTACH_FILENAME (4)
        ATTACH_CONTENTTYPE (5)
        ATTACH_TRANSFERENCODING (6)
        ATTACH_FULLPATH (7)
        ATTACH_SIZE (8)
      </param>
      <param name="uNewValue">New value for the type.</param>
      <returns>
        The old value for the attachment array element
      </returns>
    </member>
    <member name="M:VO.CEmail.SetHeaderInfo">
      <summary>
        Method to encode all header elements of an email
      </summary>
      <remarks>
        This method reads the properties of the Email object and creates a header from these properties. It also assigns the header to the Header property of the email.
        This method is called from CEmail:StreamOut during the streaming of the email message.
      </remarks>
    </member>
    <member name="M:VO.CEmail.SetMailTime">
      <summary>
        Create an ANSI Date/Time based on current date and time.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method creates a string containing the date and time in a format that can be understood by all Internet servers.  The resulting string can be used via the TimeStamp access.
      </remarks>
    </member>
    <member name="P:VO.CEmail.Size">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CEmail.StreamIn(System.String)">
      <summary>
        This method gets called when an email messages is received. It calls into the Storage object to decode and store attachments.
      </summary>
      <param name="cData">The string that was received and needs to be decoded</param>
      <remarks>
        There is usually no need to call this method yourself. It gets called from the CPop class when receiving emails. It also gets called from the CEMail:Decode() message when decoding a raw message.
        <note type="tip">
          Visual Objects tries to avoid building large emails completely in memory. Therefore it reads or writes them in chunks. The StreamIn() and StreamOut() methods on the CEmail class handle these chunks.
        </note></remarks>
    </member>
    <member name="M:VO.CEmail.StreamOut">
      <summary>
        Generate message contents
      </summary>
      <remarks>
        There is usually no need to call this message directly. It is called repeatedly from CSmtp:SendMail() when sending emails.
        <note type="tip">
          Visual Objects tries to avoid building large emails completely in memory. Therefore it reads or writes them in chunks. The StreamIn() and StreamOut() methods on the CEmail class handle these chunks.
        </note></remarks>
    </member>
    <member name="M:VO.CEmail.StreamStart">
      <summary>
        Initialize the Stream Status of an email message.
      </summary>
      <remarks>
        There is usually no need to call this message directly. It is called repeatedly from CSmtp:SendMail() when sending emails, from CPop when receiving mails and from CEmail:Decode when decoding mails
        <note type="tip">
          Visual Objects tries to avoid building large emails completely in memory. Therefore it reads or writes them in chunks. The StreamIn() and StreamOut() methods on the CEmail class handle these chunks.
        </note></remarks>
    </member>
    <member name="P:VO.CEmail.Subject">
      <summary>
        String value containing the e-mail subject.
      </summary>
      <value>String value containing the e-mail subject.</value>
    </member>
    <member name="P:VO.CEmail.TimeStamp">
      <summary>
        String value containing the date and time that the e-mail was sent.
      </summary>
      <value>String value containing the date and time that the e-mail was sent.</value>
    </member>
    <member name="T:VO.CFtp">
      <summary>
        Wrapper class for high-level File Transfer Protocol (FTP) functions provided by Microsoft in Wininet.dll.
      </summary>
      <remarks>
        This class provides all necessary methods and properties for file transfer and exchange using File Transfer Protocol.
      </remarks>
    </member>
    <member name="M:VO.CFtp.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a CFtp object instance.
      </summary>
      <param name="cCaption">Name of the application or entity calling subsequent methods.  The default is 'VO Ftp Client'.</param>
      <param name="n">Port number.  The default FTP port number is 21.</param>
      <param name="lStat">Logical value specifying whether the CFtp:InternetStatus() method should be called for status callback notifications.  The default is TRUE.</param>
    </member>
    <member name="P:VO.CFtp.AccessType">
      <summary>
        Numeric value representing the required access.
        The application can select one of these type values:
        INTERNET_OPEN_TYPE_DIRECT
        Resolve all host names locally.
        INTERNET_OPEN_TYPE_PROXY
        Pass requests to the proxy specified by CFtp:Proxy unless a proxy bypass list is supplied by CFtp:ProxyBypass and the name to be resolved bypasses the proxy. In this case, the function proceeds as for INTERNET_OPEN_TYPE_DIRECT.
        INTERNET_OPEN_TYPE_PRECONFIG
        Retrieve the proxy or direct configuration from the registry.
      </summary>
      <value>Numeric value representing the required access.</value>
    </member>
    <member name="M:VO.CFtp.Append(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="cLocalFile">** missing parameter documentation **</param>
      <param name="nFlags">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CFtp.CloseFile(XSharp.__Usual)">
      <summary>
        Close a remote file.
      </summary>
      <param name="ptrHandle">Handle of a previously opened remote file.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method should be used to close the handle returned from the OpenFile() method.
      </remarks>
    </member>
    <member name="M:VO.CFtp.CloseRemote">
      <summary>
        Shut down the current Internet FTP connection.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method can be used to close the connection made for the CFtp object instance.  If not specified, the connection will be automatically closed if the appropriate object instance goes out of scope.
      </remarks>
      <example>
        See the CFtp:ConnectRemote() example.
      </example>
    </member>
    <member name="P:VO.CFtp.Connected">
      <summary>
        Logical value representing the connection status.
      </summary>
      <value>Logical value representing the connection status.</value>
    </member>
    <member name="M:VO.CFtp.ConnectRemote(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Connect an application to a remote FTP server.
      </summary>
      <param name="cIP">String containing the host name of an Internet server.  Alternately, the string can contain the IP number of the site in ASCII dotted-decimal format (for example, 11.22.3.45).  </param>
      <param name="cID">String that contains the name of the user to log on.  If this parameter is NULL, the function uses the appropriate default ('anonymous').  For the FTP protocol, the default is anonymous.</param>
      <param name="cPw">User's password as a string.  For anonymous login users, the user's e-mail name can be used as password.</param>
      <param name="lBypass">** missing parameter documentation **</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method establishes a connection to a remote FTP server.
      </remarks>
      <example>
        The following example creates a list of all files and directories of the X# download section at ftp.cai.com:
        <code language="X#">
          FUNC ListVOFiles()
          LOCAL oFTP AS CFtp
          LOCAL lRet AS LOGIC
          LOCAL aRet AS ARRAY
          LOCAL i    AS INT
          oFTP := CFtp{"VO Sample FTP Agent"}
          IF oFTP:ConnectRemote("ftp.cai.com", ;
                               "anonymous",   ;
                               "Darth.Vader@starwars.com")
          oFTP:SetCurDir("/pub/vo")
          ? "Contents of Directory " + oFTP:GetCurDir()
          aRet := oFTP:Directory("*.*")
          FOR i := 1 UPTO ALen(aRet)
          ?  aRet[i, F_NAME]
          ?? ", Size: " + NTrim(aRet[i, F_SIZE])
          ?? ", Date/Time: " + DToC(aRet[i, F_DATE]) + ;
          "/" + aRet[i, F_TIME]
          ?? ", Attribute(s): ", aRet[i, F_ATTR]
          NEXT
          ENDIF
          oFTP:CloseRemote()
        </code><code language="X#">RETURN lRet</code></example>
    </member>
    <member name="M:VO.CFtp.CreateDir(XSharp.__Usual)">
      <summary>
        Create a new directory on the FTP server.
      </summary>
      <param name="cRemoteDir">String that contains the name of the directory that is to be created.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method creates a new directory on the remote FTP server.
      </remarks>
    </member>
    <member name="M:VO.CFtp.DeleteFile(XSharp.__Usual)">
      <summary>
        Delete a file stored on the FTP server.
      </summary>
      <param name="cRemoteFile">String that contains the name of the file to be deleted on the remote FTP server.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method removes a file from a remote FTP server.
      </remarks>
    </member>
    <member name="M:VO.CFtp.Directory(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Create an array of directory and file information about the remote FTP server.
      </summary>
      <param name="cFile">The file specification for the search.  Besides a file name, this specification can include an optional drive, directory, and extension. 
      The file name and extension can include the standard wildcard characters (* and ?).  
      If you do not specify a drive and directory, the Windows defaults are used.  If you do not specify any file name, '*.*' is assumed.</param>
      <param name="nFlags">** missing parameter documentation **</param>
      <returns>
        An array of subarrays, with each subarray containing information about each file matching &lt;cFileSpec&gt;.  The subarray elements are referenced as shown in the example under the CFtp:ConnectRemote() Method section.
      </returns>
      <remarks>
        This method returns information about files in the current or specified directory.  You can use it to perform actions on groups of files.
      </remarks>
    </member>
    <member name="P:VO.CFtp.Error">
      <summary>
        Numeric value representing the last occurring error code.
      </summary>
      <value>Numeric value representing the last occurring error code.</value>
    </member>
    <member name="P:VO.CFtp.ErrorMsg">
      <summary>
        A string representing the error description.
      </summary>
      <value>A string representing the error description.</value>
    </member>
    <member name="M:VO.CFtp.GetCurDir">
      <summary>
        Get the name of the current directory on the remote FTP server for the current process.
      </summary>
      <returns>
        Name of the current directory, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        This method retrieves the directory name on the remote FTP server for the current process.
      </remarks>
    </member>
    <member name="M:VO.CFtp.GetFile(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Receive a file from the FTP server.
      </summary>
      <param name="cRemoteFile">Name of the remote file that has to be received.  </param>
      <param name="cNewFile">String that contains the name of the file to create on the local system.  If not specified, &lt;cRemoteFile&gt; automatically becomes the name of the local file.</param>
      <param name="lFailIfExists">Logical value indicating whether the method should proceed if a local file of the specified name already exists.  If &lt;lFailIfExists&gt; is TRUE and the local file exists, the GetFile() method fails.</param>
      <param name="nFlags">
        Flags that control how the function will handle the file download.  The first set of flag values indicates the conditions under which the transfer occurs.  These transfer type flags can be used in combination with the second set of flags that control caching.
        The application can select one of these transfer type values:
        The following flags handle how the caching of this file will be handled.  Any combination of the following flags can be used with the transfer type flag.
        The possible values are:
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method retrieves a file from an FTP server and stores it under the specified name as a local file.
      </remarks>
      <example>
        The following receives the comprehensive list (00index.txt) of all files contained in the X# download section at ftp.cai.com:
        <code language="X#">
          FUNC TestGetFile()
          LOCAL oFTP  AS CFtp
          LOCAL cFile AS STRING
          oFTP := CFtp{"VO Sample FTP Agent"}
          IF oFTP:ConnectRemote("ftp.cai.com", ;
                               "anonymous",   ;
                               "Darth.Vader@starwars.com")
          cFile := "00index.txt"
          IF oFTP:SetCurDir("/pub/vo")
          IF oFTP:GetFile(cFile)
          IF File(cFile)
          ? "File received: " + FPathName()
          ENDIF
          ELSE
          __RaiseFTPError(oFTP)
          ENDIF
          ELSE
          __RaiseFTPError(oFTP)
          ENDIF
          ENDIF
          oFTP:CloseRemote()
          RETURN
          STATIC FUNC __RaiseFTPError (oFTP AS CFtp) AS INT ;
          PASCAL
          LOCAL cError    AS STRING
          LOCAL nRet      AS INT
          nRet := oFTP:Error
          IF nRet &gt; 0
          cError := oFTP:ErrorMsg
          IF SLen(cError) &gt; 0
          MessageBox(0, cError, "FTP Error", MB_OK)
          ENDIF
          ENDIF
          RETURN nRet
        </code></example>
    </member>
    <member name="M:VO.CFtp.InternetStatus(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Method InternetStatus() is a callback placeholder to receive current status information for an FTP session.  It should be overloaded by subclasses to implement the desired behavior.
      </summary>
      <param name="nContext">Application-defined context value associated with the current class.</param>
      <param name="nStatus">Status code that indicates the reason for calling.  It can be one of the following values: </param>
      <param name="pStatusInfo">Address of a buffer that contains information pertinent to this call to the callback function.  </param>
      <param name="nStatusLength">Size of the &lt;pStatusInfo&gt; buffer.  </param>
      <remarks>
        The InternetStatus() method can be used to receive different status information at any stage of an FTP transfer between the FTP client and server.
      </remarks>
      <example>
        The following example demonstrates using the InternetStatus() method to notify every status change to the owner window:
        <code language="X#">
          CLASS MyFTP INHERIT CFtp
            PROTECT oOwner   AS OBJECT
          METHOD Init(oParent, cCaption, n, lStat)CLASS MyFtp
            SUPER:Init(cCaption, n, lStat)
            SELF:oOwner := oParent
            RETURN SELF
          METHOD InternetStatus( nContext, nStatus, ; pStatusInfo, nStatusLength ) CLASS MyFTP
          //
          // This method receives all Low Level FTP
          // notification. Please keep all parameters if you
          // want to overwrite it for your own purpose
          //
          LOCAL cMsg AS STRING
          DO CASE
          CASE nStatus == INTERNET_STATUS_RESOLVING_NAME
            cMsg := "Resolving Name ... "
          CASE nStatus == INTERNET_STATUS_NAME_RESOLVED
            cMsg := "Name resolved"
          CASE nStatus == INTERNET_STATUS_CONNECTING_TO_SERVER
            cMsg := "Connecting to Server ... "
          CASE nStatus == INTERNET_STATUS_CONNECTED_TO_SERVER
            cMsg := "Connected to Server"
          CASE nStatus == INTERNET_STATUS_SENDING_REQUEST
            cMsg := "Sending Request ... "
          CASE nStatus == INTERNET_STATUS_REQUEST_SENT
            cMsg := "Request sent"
          CASE nStatus == INTERNET_STATUS_RECEIVING_RESPONSE
            cMsg := "Receiving response ..."
          CASE nStatus == INTERNET_STATUS_RESPONSE_RECEIVED
            cMsg := "Response received"
          CASE nStatus == INTERNET_STATUS_CTL_RESPONSE_RECEIVED
            cMsg := "CTL Response received"
          CASE nStatus == INTERNET_STATUS_PREFETCH
            cMsg := "Prefetch"
          CASE nStatus == INTERNET_STATUS_CLOSING_CONNECTION
            cMsg := "Closing Connection ..."
          CASE nStatus == INTERNET_STATUS_CONNECTION_CLOSED
            cMsg := "Connection closed"
          CASE nStatus == INTERNET_STATUS_HANDLE_CREATED
            cMsg := "Handle created"
            //      _DebOut32( "FTP Status : " + cMsg )
            RETURN
          CASE nStatus == INTERNET_STATUS_HANDLE_CLOSING
            cMsg := "Closing handle ..."
          CASE nStatus == INTERNET_STATUS_REQUEST_COMPLETE
            cMsg := "Request complete"
          CASE nStatus == INTERNET_STATUS_REDIRECT
            cMsg := "Redirect"
          OTHERWISE
            cMsg := "Unkown FTP Status"
          ENDCASE
          SELF:oOwner:FTPStatus := cMsg
          RETURN NIL
        </code></example>
    </member>
    <member name="M:VO.CFtp.Open(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Initialize an application's use of the Win32 Internet functions.
      </summary>
      <param name="nFlags">
        Flag that indicates various options affecting the behavior of the methods.  It can be a combination of these values:
        INTERNET_FLAG_OFFLINE
        Satisfy download operations on this handle through the persistent cache only.  If the item does not exist in the cache, the method returns an appropriate error code.
        INTERNET_FLAG_ASYNC
        Future operations on this handle may fail with ERROR_IO_PENDING.
      </param>
      <param name="xProxy">String containing the name of the proxy server to use if proxy access was specified.  If this parameter is NIL, the function reads proxy information from the registry.</param>
      <param name="aProxyByPass">
        Array with host names or IP addresses, or both, that are known locally.  Requests to these names are not routed through the proxy.  The strings can contain wildcards, such as {'157.55.*', '*int*'}, meaning any IP address starting with 157.55, or any name containing the substring 'int', will bypass the proxy.
        If this array contains the '&lt;local&gt;' string as the only entry, the function bypasses any host name that does not contain a period.  For example, 'www.cai.com' would be routed to the proxy, whereas 'internet' would not.  If this parameter is NIL, the function reads the bypass list from the registry.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method initializes internal data structures and prepares for future calls to CFtp methods.  It does not have to be called explicitly, because the CFtp:ConnectRemote() method internally calls this method, if necessary.
      </remarks>
    </member>
    <member name="M:VO.CFtp.OpenFile(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Open a remote file for writing or reading.
      </summary>
      <param name="cRemoteFile">String containing the name of the file that has to be accessed on the remote system.</param>
      <param name="nAccess">Numeric value determining the type of file access (GENERIC_READ or GENERIC_WRITE — not both).  The default is GENERIC_READ.</param>
      <param name="nFlags">
        Conditions for operation with the specified file.  The application should select one transfer type and any of the flags that control how the caching of the file will be controlled.
        The transfer type can be any one of the following values:
        The application can use one or more of the following values to control the caching of the file:
      </param>
      <returns>
        File handle, if successful; otherwise, NULL_PTR.
      </returns>
      <remarks>
        The OpenFile() method initializes a remote file handle for subsequent file operations.  The handle remains open until calling the CloseFile() method, and it can be used to call functions like InternetReadFile() or InternetWriteFile(), InternetCloseHandle(), or FtpFindFirstFile().
      </remarks>
    </member>
    <member name="P:VO.CFtp.PassWord">
      <summary>
        A string representing the password for the FTP session.
      </summary>
      <value>A string representing the password for the FTP session.</value>
    </member>
    <member name="P:VO.CFtp.Proxy">
      <summary>
        A string containing the name of the proxy server (or servers) to use for Internet connections.
      </summary>
      <value>A string containing the name of the proxy server (or servers) to use for Internet connections.</value>
    </member>
    <member name="P:VO.CFtp.ProxyBypass">
      <summary>
        A string containing an optional list of host names or IP addresses, or both, that are known locally. Requests to these names are not routed through the proxy. The list can contain wildcards, such as "130.126.*.* *dev*", meaning that any IP address starting with 130.126 or any name containing the substring "dev" will bypass the proxy.
      </summary>
      <value>A string containing an optional list of host names or IP addresses, or both, that are known locally. Requests to these names are not routed through the proxy. The list can contain wildcards, such as "130.126.*.* *dev*", meaning that any IP address starting with 130.126 or any name containing the substring "dev" will bypass the proxy.</value>
    </member>
    <member name="M:VO.CFtp.PutFile(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Store a file on the FTP server.
      </summary>
      <param name="cLocalFile">Name of the local file that is to be sent to the remote FTP server.  </param>
      <param name="cRemoteFile">String that contains the name of the file to create on the remote FTP server.  If not specified, &lt;cLocalFile&gt; automatically becomes the name of the remote file.</param>
      <param name="lFailIfExists">Logical value indicating whether the method should proceed if a remote file of the specified name already exists.  If &lt;lFailIfExists&gt; is TRUE and the remote file exists, method PutFile() fails.</param>
      <param name="nFlags">
        Flags that control how the function will handle the file upload and the conditions under which the transfers occur.  The application should select one transfer type and any of the flags that control how the caching of the file will be controlled.
        The transfer type can be any one of the following values:
        The application can use one or more of the following values to control the caching of the file:
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method handles all of the necessary processes associated with reading a file locally and storing it on an FTP server.
      </remarks>
      <example>
        The following receives the comprehensive list (00index.txt) of all files contained in the X# download section at ftp.cai.com:
        <code language="X#">
          FUNC TestGetFile()
            LOCAL oFTP  AS CFtp
            LOCAL cFile AS STRING
            oFTP := CFtp{"VO Sample FTP Agent"}
            IF oFTP:ConnectRemote("ftp.cai.com", ;
                                 "anonymous",   ;
                                 "Darth.Vader@starwars.com")
            cFile := "00index.txt"
            IF oFTP:SetCurDir("/pub/vo")
              IF oFTP:GetFile(cFile)
                IF File(cFile)
                ? "File received: " + FPathName()
                ENDIF
                ELSE
              __RaiseFTPError(oFTP)
              ENDIF
            ELSE
             __RaiseFTPError(oFTP)
            ENDIF
            oFTP:CloseRemote()
          RETURN
          STATIC FUNC __RaiseFTPError (oFTP AS CFtp) AS INT PASCAL
            LOCAL cError    AS STRING
            LOCAL nRet      AS INT
            nRet := oFTP:Error
            IF nRet &gt; 0
              cError := oFTP:ErrorMsg
              IF SLen(cError) &gt; 0
                MessageBox(0, cError, "FTP Error", MB_OK)
              ENDIF
            ENDIF
            RETURN nRet
        </code></example>
    </member>
    <member name="P:VO.CFtp.RemoteHost">
      <summary>
        A string representing the name of the FTP server to which you want to connect.
      </summary>
      <value>A string representing the name of the FTP server to which you want to connect.</value>
    </member>
    <member name="M:VO.CFtp.RemoveDir(XSharp.__Usual)">
      <summary>
        Delete a directory from the remote FTP server.
      </summary>
      <param name="cRemoteDir">String that contains the name of the directory that is to be removed.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method removes a directory from the remote FTP server.
      </remarks>
    </member>
    <member name="M:VO.CFtp.RenameFile(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Rename a file stored on the FTP server.
      </summary>
      <param name="cRemoteFile">String that contains the name of the file to be renamed on the remote FTP server.</param>
      <param name="cNewName">The new name to give to the file.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        The RenameFile() method renames a file on the remote FTP server.
      </remarks>
    </member>
    <member name="M:VO.CFtp.SetCurDir(XSharp.__Usual)">
      <summary>
        Change the current directory on the remote FTP server for the current process.
      </summary>
      <param name="cRemoteDir">String that contains the path of the directory to change to.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        The SetCurDir() method changes the directory on the remote FTP server for the current process.
      </remarks>
    </member>
    <member name="P:VO.CFtp.UserName">
      <summary>
        A string for identifying the user for the FTP connection.
      </summary>
      <value>A string for identifying the user for the FTP connection.</value>
    </member>
    <member name="T:VO.CheckBox">
      <summary>
        Create check boxes, which are controls that can be toggled on or off by a user (or for 3-state check boxes, to a third state).
      </summary>
      <remarks>
        A check box allows the user to choose between 2 or 3 states.  
        A 2-state check box allows a choice between a checked (ON) and unchecked (OFF) state.  
        The choice is reflected in CheckBox:Value access, which may be TRUE or FALSE.  
        A 3-state check box adds a third (UNDETERMINED) state, in which the box is dimmed.  
        The third state is indicated by CheckBox:Value being TRUE and by CheckBox:ValueChanged (which is normally TRUE) being FALSE.
        A check box may be bound to a logical field in a server.  
        Because of this, you can not directly bind a 3-state check box to a server; instead you must create a 
        numeric or character field to store the 3-state information,  and update it based on the status of 
        the CheckBox:Value and CheckBox:ValueChanged accesses.

        The Window:ButtonClick() event handler responds to events in the check box.  The default behavior of the event handler is to toggle the state of the check box.  Typically, you would implement your own ButtonClick() event handler in which you first call the default handler to set the state of the buttons.  For example:
        <code language="X#">
          METHOD ButtonClick(oControlEvent) CLASS MyWind
          SUPER:ButtonClick(oControlEvent)
          // Do something else
        </code></remarks>
      <example>
        This example creates a check box on a dialog window and then checks it:
        <code language="X#">
          CLASS MyDialog INHERIT DialogWindow
          HIDDEN oCBNew AS OBJECT
          METHOD Init(oWindow,nResourceID) CLASS MyDialog
          SUPER:Init(oWindow,nResourceID)
          oCBNew := CheckBox{SELF,IDB_CHECKBOX}
          oCBNew:Checked := TRUE
          SELF:Show()
        </code>

        In Windows, check boxes are equivalent to a button with the BS_CHECKBOX style.  The style BS_AUTOCHECKBOX is useful because the button is automatically checked and unchecked without any code being written in the system.  They are normally specified in the resource entity like this:
        <code language="X#">
          RESOURCE IDD_ABOUT DIALOG 20,20,160,120
          STYLE WS_POPUP | WS_DLGFRAME
          BEGIN
          CHECKBOX "&amp;Color"  IDB_COLOR,10,20,40,12
          CHECKBOX "&amp;Filled" IDB_FILLED,10,35,40,12
          CONTROL "&amp;Auto",IDB_AUTO,"button", BS_AUTOCHECKBOX,10,65,40,12
          DEFPUSHBUTTON "OK"  IDB_OK,64,80,32,14, WS_GROUP
          END
        </code></example>
    </member>
    <member name="M:VO.CheckBox.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a check box.
      </summary>
      <param name="oOwner">The window that owns the check box.</param>
      <param name="xID">The unique ID of the check box (between 1 and 8000).</param>
      <param name="oPoint">The origin of the check box in canvas coordinates.</param>
      <param name="oDimension">The dimension of the check box in canvas coordinates.</param>
      <param name="cText">The text to be associated with the check box.  If no text is specified, it is inherited from TextControl:TextValue.</param>
      <param name="kStyle">
        Constant representing the style of the check box, specified by a Windows API style constant.  The default is BS_AUTOCHECKBOX.
        Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular Windows API style constant.
      </param>
      <param name="nResourceID">The resource ID of the check box.</param>
    </member>
    <member name="P:VO.CheckBox.Checked">
      <summary>
        A logical value representing the current state of a check box.  It is TRUE if the box is checked (or for 3-state check boxes, if it is in the third UNDETERMINED state), otherwise it is FALSE.   The CheckBox:Checked assign also changes CheckBox:Value and CheckBox:TextValue.  Also, if the CheckBox:Value is changed, CheckBox:ValueChanged is set to TRUE.
      </summary>
      <value>A logical value representing the current state of a check box.  It is TRUE if the box is checked (or for 3-state check boxes, if it is in the third UNDETERMINED state), otherwise it is FALSE.   The CheckBox:Checked assign also changes CheckBox:Value and CheckBox:TextValue.  Also, if the CheckBox:Value is changed, CheckBox:ValueChanged is set to TRUE.</value>
    </member>
    <member name="M:VO.CheckBox.Destroy">
      <summary>
        Provide a method to de-instantiate a CheckBox object.
      </summary>
      <remarks>
        This method can be used when a CheckBox object is no longer needed.  CheckBox:Destroy() de-instantiates the CheckBox object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="P:VO.CheckBox.Image">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CheckBox.TextValue">
      <summary>
        CheckBox:TextValue is initialized to FALSE on data windows, since the control contains no text.
      </summary>
      <value>CheckBox:TextValue is initialized to FALSE on data windows, since the control contains no text.</value>
    </member>
    <member name="P:VO.CheckBox.Value">
      <summary>
        CheckBox:Value contains TRUE if the check box is in the checked (ON) state or for 3-state check boxes, in the third UNDETERMINED state.  It contains FALSE if it is in the unchecked state (OFF).
      </summary>
      <value>CheckBox:Value contains TRUE if the check box is in the checked (ON) state or for 3-state check boxes, in the third UNDETERMINED state.  It contains FALSE if it is in the unchecked state (OFF).</value>
    </member>
    <member name="P:VO.CheckBox.ValueChanged">
      <summary>
        CheckBox:ValueChanged contains TRUE or FALSE, depending on the state of the check box.  For 2-state check boxes, it is always TRUE.  If a 3-state check box is in the third UNDETERMINED state, CheckBox:ValueChanged is FALSE.
      </summary>
      <value>CheckBox:ValueChanged contains TRUE or FALSE, depending on the state of the check box.  For 2-state check boxes, it is always TRUE.  If a 3-state check box is in the third UNDETERMINED state, CheckBox:ValueChanged is FALSE.</value>
    </member>
    <member name="T:VO.ChildAppWindow">
      <summary>
        Create child application windows.
      </summary>
      <remarks>
        A child application window is an application window that "belongs to" another window (its owner).  Because a child application window is not independent of the owner window, it is always destroyed, hidden, or iconized when its owner window is destroyed, hidden, or iconized.  Also note that child application windows are clipped against the owner window.
        Child application windows do not have a default size and position on their owner window.  They must be given an origin and size before they are shown.

        In Windows, a child application window never displays a menu (except for the system menu).  However, it can own a menu.  If the child window is used as an MDI child under a shell window, its menu is displayed in the shell.
        This is very useful: when different child windows present different types of data, they often need different menus.  The system automatically switches the owner shell window's menu according to which child window has focus.
      </remarks>
      <example>
        The following example displays a child window:
        <code language="X#">
          CLASS MyTopAppWindow INHERIT TopAppWindow
          HIDDEN oCAWNew AS OBJECT
          METHOD Init() CLASS MyTopAppWindow
          SUPER:Init()
          oCAWNew := ChildAppWindow{SELF,FALSE}
          SELF:Caption := "Top App Window"
          oCAWNew:Origin := Point{10,10}
          oCAWNew:Size := Dimension{100,60}
          SELF:Show()
          oCAWNew:Caption := "Child App Window"
          oCAWNew:Show()
        </code></example>
    </member>
    <member name="M:VO.ChildAppWindow.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a child application window.
      </summary>
      <param name="oOwner">The window that owns the child application window.</param>
      <param name="lManaged">Indicates how to manage the child application window.  If TRUE, the child window is managed by its owner as an MDI client. 
      If FALSE (the default), the child window does not take its default style and menu from the MDI shell.  In this case, you must explicitly provide code to control its behavior.</param>
      <param name="lImpl">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.ChildAppWindow.ContextMenu">
      <summary>
        A menu object representing the local pop-up menu for a window or window control.
      </summary>
      <value>A menu object representing the local pop-up menu for a window or window control.</value>
    </member>
    <member name="M:VO.ChildAppWindow.Default(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.ChildAppWindow.Destroy">
      <summary>
        Provide a method to free memory resources allocated for a ChildAppWindow object and its derived objects.
      </summary>
      <remarks>
        This method immediately frees resources for ChildAppWindow objects created explicitly in your application.  ChildAppWindow:Destroy() also takes care of resources allocated to derived classes and deallocates them in the necessary order.
      </remarks>
      <returns>
        NIL
      </returns>
    </member>
    <member name="M:VO.ChildAppWindow.EnableBorder(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.ChildAppWindow.EnableHorizontalScroll(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.ChildAppWindow.EnableOleDropTarget(XSharp.__Usual)">
      <summary>
        Register the window as an OLE drop target.
      </summary>
      <param name="lEnable">A logical value specifying whether to enable (TRUE) or disable (FALSE) the window as a drop target.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        A window that is registered as an OLE drop target using ChildAppWindow:EnableOLEDropTarget() can handle OLE drag and drop events and create new OLE objects in response to such events.  In the associated handlers, an OLEDragEvent object is passed as a parameter that can be used to create a new OLE object by calling OLEObject:CreateFromOLEDragEvent().
      </remarks>
      <example>
        The following code enables a data window as a drop target and creates a new OLE object inside its OLEDrop handler.  It also checks the name of the OLE object to allow only WordPad documents:
        <code language="X#">
          METHOD EnableOLEDropTarget CLASS DropTargetDataWindow
          SUPER:EnableOLEDropTarget(TRUE)
          METHOD OLEDrop(oOLEDragEvent) CLASS MyChild
            LOCAL oOLE AS OLEObject
            LOCAL lRet AS LOGIC
            IF oOLEDragEvent:ObjectName == "WordPad Document"
               oOLE := OLEObject{SELF}
               oOLE:AllowInPlace := TRUE
               oOLE:AllowResize := TRUE
               IF oOLE:CreateFromOLEDragEvent(oOLEDragEvent)
                  oOLE:Origin := oOLEDragEvent:Position
                  oOLE:Show()
                  oOLE:SetFocus()
               ENDIF
            ENDIF
        </code></example>
    </member>
    <member name="M:VO.ChildAppWindow.EnableStatusBar(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.ChildAppWindow.EnableVerticalScroll(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.ChildAppWindow.Show(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ChildAppWindow.StatusBar">
      <inheritdoc />
    </member>
    <member name="P:VO.ChildAppWindow.ToolBar">
      <inheritdoc />
    </member>
    <member name="T:VO.CHttp">
      <summary>
        Wrapper class for an Http (Hypertext transfer protocol) session.
      </summary>
      <remarks>
        This class provides all necessary methods and properties for an HyperText Transfer Protocol session.
      </remarks>
    </member>
    <member name="M:VO.CHttp.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Instantiates a new Http wrapper object.
      </summary>
      <param name="cCaption">An optional caption as a string.</param>
      <param name="n">The HTTP port address ( the default is 80 ).</param>
      <param name="lStat">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CHttp.AddRequestHeaders(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Adds additional headers to the current request.
      </summary>
      <param name="cHeaders">Contains the headers to append to the request. Each header must be terminated by a CR/LF (carriage return/line feed) pair.</param>
      <param name="nModifiers">Contains values used to modify the semantics of this function (see HttpAddRequestHeaders in the Win32 Internet API help for possible values).</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.CHttp.CloseRemote">
      <summary>
        Closes the http connection.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.CHttp.CloseRequest">
      <summary>
        Closes an http request.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.CHttp.ConnectRemote(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Opens the http connection.
      </summary>
      <param name="cIP">The host name or IP address of the remote server.</param>
      <param name="cID">User ID ( Optional )</param>
      <param name="cPw">Password ( Optional )</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.CHttp.Directory">
      <summary>
        If an ftp server is accessed via http, this method returns an array of the files of the current directory.
      </summary>
      <returns>
        An array of the files in the current directory on the ftp server.
      </returns>
    </member>
    <member name="P:VO.CHttp.FtpRequest">
      <summary>
        Indicates that the http connection is being used to access an ftp server.
      </summary>
      <value>Indicates that the http connection is being used to access an ftp server.</value>
    </member>
    <member name="M:VO.CHttp.GetCurDir">
      <summary>
        Gets the name of the current directory on the remote server.
      </summary>
      <returns>
        The directory name as a string.
      </returns>
    </member>
    <member name="M:VO.CHttp.GetDocumentByURL(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Retrieves a document from the server.
      </summary>
      <param name="cURL">The URL of the document to retrieve.</param>
      <param name="nFlags">** missing parameter documentation **</param>
      <returns>
        The document as a string.
      </returns>
    </member>
    <member name="M:VO.CHttp.GetDocumentFromServer(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Retrieves a document from the server.
      </summary>
      <param name="cServer">The server to retrieve the file from.</param>
      <param name="cDocument">The document to retrrieve.</param>
      <param name="cID">Optional user ID.</param>
      <param name="cPw">Optional password.</param>
      <returns>
        The document as a string.
      </returns>
    </member>
    <member name="M:VO.CHttp.GetFile(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Retrieves the remote file cRemoteFile to the (local) file cNewFile.
      </summary>
      <param name="cRemoteFile">The name of the file on the remote server to retrieve.</param>
      <param name="cNewFile">The name to use when saving the file on the local drive.</param>
      <param name="lFailIfExists">IF lFailIfExists is set to TRUE the method will fail if the file exists on the local disk. If it is set to FALSE an existing file will be over written.</param>
      <returns>
        TRUE if the file is saved, otherwise FALSE.
      </returns>
    </member>
    <member name="M:VO.CHttp.GetResponse">
      <summary>
        Gets the response for the current request.
      </summary>
      <returns>
        The response for the current request as a string.
      </returns>
    </member>
    <member name="M:VO.CHttp.GetResponseHeader">
      <summary>
        Gets the response header for the current request.
      </summary>
      <returns>
        The response header for the current request as a string.
      </returns>
    </member>
    <member name="M:VO.CHttp.Open(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Opens the http connection.
      </summary>
      <param name="nFlags">Contains flags used in the internal InternetConnect call (see Win32 Internet API help for possible values).</param>
      <param name="xProxy">Name of a proxy server (optional).</param>
      <param name="aProxyByPass">Array of server names that should not be accessed through the proxy (optional).</param>
      <returns>
        TRUE if the connection was opened, otherwise FALSE.
      </returns>
    </member>
    <member name="M:VO.CHttp.OpenFile(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Opens a remote file.
      </summary>
      <param name="cRemoteFile">The file name as a string.</param>
      <param name="nAccess">**Missing parameter documentation **</param>
      <param name="nFlags">Contains flags used in the internal call (see Win32 Internet API help for possible values).</param>
      <returns>
        The handle of the requested file.
      </returns>
    </member>
    <member name="M:VO.CHttp.OpenRequest(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Opens a new request.
      </summary>
      <param name="cMethod">The request verb (e.g. GET).</param>
      <param name="cDocument">The name of the target document to open.</param>
      <param name="nFlags">Contains flags used in the internal HttpOpenRequest call (see Win32 Internet API help for possible values).</param>
      <returns>
        TRUE if the document was opened, otherwise FALSE.
      </returns>
    </member>
    <member name="P:VO.CHttp.Response">
      <summary>
        Use this to get the response.
      </summary>
      <value>Use this to get the response.</value>
    </member>
    <member name="P:VO.CHttp.ResponseHeader">
      <summary>
        Use this to get the response header.
      </summary>
      <value>Use this to get the response header.</value>
    </member>
    <member name="M:VO.CHttp.SendRequest(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Sends a request to the server.
      </summary>
      <param name="cHeaders">Additional headers (optional).</param>
      <param name="pData">Pointer to data of size &lt;nDataSize&gt; (optional).</param>
      <param name="nDataSize">The size of the data in &lt;pData&gt; (optional but must be provided if &lt;pData&gt; is used).</param>
      <returns>
        TRUE if the request is successful, otherwise FALSE.
      </returns>
    </member>
    <member name="M:VO.CHttp.SetCurDir(XSharp.__Usual)">
      <summary>
        Changes the current directory on the remote server for the current process.
      </summary>
      <param name="cRemoteDir">The path of the directory to change to.</param>
      <returns>
        The new directory name as a string.
      </returns>
    </member>
    <member name="T:VO.CIMap">
      <summary>Class to read a mailbox using the IMAP protocol.</summary>
    </member>
    <member name="M:VO.CImap.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="cServer">** missing parameter documentation **</param>
      <param name="cUid">** missing parameter documentation **</param>
      <param name="cPwd">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CImap.CheckReply">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CImap.ClientCommand(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="cBuffer">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CImap.DeleteMail(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="nMail">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CImap.Disconnect">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CImap.GetMail(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="nMail">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CImap.GetPrefix">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CImap.GetStatus">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CImap.LogOn(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="cUID">** missing parameter documentation **</param>
      <param name="cPwd">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.CImap.MailBox">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CImap.SendRemote(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="cData">** missing parameter documentation **</param>
    </member>
    <member name="T:VO.CInetDial">
      <summary>
        Class for establishing dial up connections
      </summary>
      <remarks>
        This class wraps functionality to manage Dialup Connections
      </remarks>
    </member>
    <member name="M:VO.CINetDial.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="dwDialFlag">** missing parameter documentation **</param>
      <param name="oOwner">** missing parameter documentation **</param>
      <param name="symNotifyMethod">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CINetDial.AutoDial(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="dwDialFlag">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CINetDial.Dial(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="cConnectionName">** missing parameter documentation **</param>
      <param name="dwDialFlag">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.CINetDial.DialFlag">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CINetDial.Error">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CINetDial.ErrorDescription">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CINetDial.GetConnectedState">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CINetDial.GetConnections">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CINetDial.GetDialUpEntries">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CINetDial.HangUp(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="lAllModems">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.CINetDial.IsConfigured">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CINetDial.IsConnected">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CINetDial.IsLan">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CINetDial.IsModem">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CINetDial.IsOffline">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CINetDial.IsProxy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CINetDial.SetOwner(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oOwner">** missing parameter documentation **</param>
      <param name="symNotifyMethod">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CINetDial.SetSystemOffline(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="lEnable">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CINetDial.VerifyConnection(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="dwDialFlag">** missing parameter documentation **</param>
      <param name="cConnectionName">** missing parameter documentation **</param>
    </member>
    <member name="T:VO.Class Reference">
      <summary>
        Alphabetical Listing
        By Category
      </summary>
    </member>
    <member name="T:VO.ClipBoard">
      <summary>
        Create an object to refer to the Windows clipboard, which allows the sharing of text and bitmaps between different applications.  
      </summary>
      <remarks>
        Unlike DDE, the data transfer is almost always user-initiated, such as when the user of an application selects the Paste menu command.
      </remarks>
    </member>
    <member name="M:VO.Clipboard.#ctor">
      <summary>
        Construct a clipboard.
      </summary>
    </member>
    <member name="M:VO.Clipboard.Clear">
      <summary>
        Clear the contents of the clipboard.
      </summary>
      <returns>SELF</returns>
    </member>
    <member name="P:VO.Clipboard.FileCount">
      <summary>
        Used to determine how many files were dropped.
      </summary>
      <value>Used to determine how many files were dropped.</value>
    </member>
    <member name="M:VO.Clipboard.GetItemSize(XSharp.__Usual)">
      <summary>
        Retrieve the size of the item in the clipboard, specifying either a string or a bitmap object.
      </summary>
      <param name="kFormat">
        The type of item to retrieve, specified as one of the following constants:
        <pre>
          Constant        Description
          BITMAPFORMAT    The item is a bitmap object.
          STRINGFORMAT    The item is a string.
        </pre></param>
    </member>
    <member name="M:VO.Clipboard.Insert(XSharp.__Usual)">
      <summary>
        Insert text or a bitmap into the clipboard.
      </summary>
      <param name="xType">The text or bitmap to insert in the clipboard.</param>
      <remarks>
        If you insert text, any text already in the clipboard is overwritten.  However, text and bitmaps in the clipboard do not share the same space.  If you insert a bitmap, no existing text is deleted; if you insert text, no existing bitmap is deleted.
      </remarks>
      <returns>SELF</returns>
    </member>
    <member name="M:VO.Clipboard.InsertRTF(XSharp.__Usual)">
      <summary>
        Insert an RTF string into the clipboard.
      </summary>
      <param name="cText">The RTF text to insert in the clipboard.</param>
      <remarks>
        Used to insert RTF text into the clipboard, overwriting any previous RTF text that may have been there.
      </remarks>
      <returns>SELF</returns>
    </member>
    <member name="M:VO.Clipboard.RetrieveBitmap(XSharp.__Usual)">
      <summary>
        Retrieves a Bitmap object from the clipboard.
      </summary>
      <param name="oBitmap">An empty Bitmap object in which the retrieved bitmap is stored.</param>
      <returns>
        TRUE if a Bitmap object is retrieved; otherwise, FALSE.
      </returns>
      <remarks>
        The Clipboard:RetrieveBitmap() method changes the value of the Bitmap object argument that is passed to it.
      </remarks>
    </member>
    <member name="M:VO.Clipboard.RetrieveFiles(XSharp.__Usual)">
      <summary>
        Retrieves an array of file names.
      </summary>
      <param name="lMustExist">If this is set to TRUE, the file must actually exist to appear in the array.</param>
      <returns>
        An array of file names.
      </returns>
      <remarks>
        The Clipboard:RetrieveFiles() method is used to retrieve an array of file names.
      </remarks>
    </member>
    <member name="M:VO.Clipboard.RetrieveRTF(XSharp.__Usual)">
      <summary>
        Retrieve an RTF string from the clipboard.
      </summary>
      <param name="nStringLength">The length of the RTF text to retrieve from the clipboard. If it is left empty or set to 0, the full text is retrieved.</param>
      <remarks>
        Used to retrieve the RTF text from the clipboard.
      </remarks>
      <returns>
        The RTF string from the clipboard or NULL_STRING, if there is no string in the clipboard.
      </returns>
    </member>
    <member name="M:VO.Clipboard.RetrieveString(XSharp.__Usual)">
      <summary>
        Retrieves a string from the clipboard.
      </summary>
      <param name="nStringLength">The length of the string to be retrieved.  If &lt;nStringLength&gt; is zero or not specified, the complete clipboard contents is assumed.</param>
      <returns>
        The string from the clipboard or NULL_STRING, if there is no string in the clipboard.
      </returns>
    </member>
    <member name="T:VO.CMailAbstract">
      <summary>
        Base class for CPop, CSmtp and CNNTP classes.
      </summary>
      <remarks>
        <br />Important!  CMailAbstract is an abstract class and should not be used directly — instead, use one of its subclasses.
        This abstract class defines the common protocol — properties and behavior — used by the e-mail classes, CPop, CSmtp and CNNTP.
      </remarks>
    </member>
    <member name="M:VO.CMailAbstract.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a CMailAbstract object.
      </summary>
      <param name="nPort">Port number at &lt;cHostNameOrIP&gt;.  The default value is IPPORT_SMTP (25).</param>
      <param name="cServer">String containing the local name of an Internet server.  Alternately, the string can contain the IP number of the site in ASCII dotted-decimal format (for example, 11.22.3.45).  If NULL_STRING is specified, the local host name is assumed.</param>
    </member>
    <member name="M:VO.CMailAbstract.Close">
      <summary>
        De-initialize all internal values of an Internet session.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method closes down an Internet session by closing and destroying the appropriate CSocket object instance.
      </remarks>
    </member>
    <member name="M:VO.CMailAbstract.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CMailAbstract.DomainName">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CMailAbstract.Email">
      <summary>
        CEmail object instance representing e-mail to be sent.
      </summary>
      <value>CEmail object instance representing e-mail to be sent.</value>
    </member>
    <member name="P:VO.CMailAbstract.Error">
      <summary>
        Numeric value representing the last occurring error code.
      </summary>
      <value>Numeric value representing the last occurring error code.</value>
    </member>
    <member name="P:VO.CMailAbstract.ErrorMsg">
      <summary>
        A string representing the error description.
      </summary>
      <value>A string representing the error description.</value>
    </member>
    <member name="M:VO.CMailAbstract.InternetStatus(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="nContext">** missing parameter documentation **</param>
      <param name="nStatus">** missing parameter documentation **</param>
      <param name="xStatus">** missing parameter documentation **</param>
      <param name="nStatusLength">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CMailAbstract.Open">
      <summary>
        Initialize all internal startup values for an Internet session.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method initializes an Internet session by creating a CSocket object that will be used later on.
      </remarks>
    </member>
    <member name="F:VO.CMailAbstract.oSocket">
      <exclude />
    </member>
    <member name="P:VO.CMailAbstract.PassWord">
      <summary>
        A string representing the password to be used.
      </summary>
      <value>A string representing the password to be used.</value>
    </member>
    <member name="M:VO.CMailAbstract.RecvRemote">
      <summary>
        Receive data from a remote host.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        The RecvRemote() method receives data from a connected remote host.  Received data are stored to instance variable, SELF:cReply.
      </remarks>
    </member>
    <member name="P:VO.CMailAbstract.RemoteHost">
      <summary>
        String representing the address of the mail server.
      </summary>
      <value>String representing the address of the mail server.</value>
    </member>
    <member name="P:VO.CMailAbstract.RemotePort">
      <summary>
        Numeric value representing the port number.
      </summary>
      <value>Numeric value representing the port number.</value>
    </member>
    <member name="P:VO.CMailAbstract.ReplyCode">
      <summary>
        Numeric value representing the server's reply code.
      </summary>
      <value>Numeric value representing the server's reply code.</value>
    </member>
    <member name="P:VO.CMailAbstract.ReplyString">
      <summary>
        String representing the server's reply.
      </summary>
      <value>String representing the server's reply.</value>
    </member>
    <member name="M:VO.CMailAbstract.SendData(XSharp.__Usual)">
      <summary>
        Send data to a remote host.
      </summary>
      <param name="cData">Data to be sent to a remote host.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sends data via a socket to the remote host after adding trailing CRLF to the data stream.
      </remarks>
    </member>
    <member name="M:VO.CMailAbstract.SendRaw(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="cData">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CMailAbstract.SendRemote(XSharp.__Usual)">
      <summary>
        Send any data to a remote host.
      </summary>
      <param name="cData">Data to be sent to the remote host.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sends data via a socket to the remote host.
      </remarks>
    </member>
    <member name="P:VO.CMailAbstract.Socket">
      <summary>
        CSocket object instance representing the used socket.
      </summary>
      <value>CSocket object instance representing the used socket.</value>
    </member>
    <member name="P:VO.CMailAbstract.Timeout">
      <summary>
        Numeric value representing the time-out in milliseconds.
      </summary>
      <value>Numeric value representing the time-out in milliseconds.</value>
    </member>
    <member name="P:VO.CMailAbstract.TimeoutRetries">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CMailAbstract.UserName">
      <summary>
        A string containing the user name to be used.
      </summary>
      <value>A string containing the user name to be used.</value>
    </member>
    <member name="T:VO.CMessage">
      <summary>
        Base class for CEmail class.
      </summary>
      <remarks>
        <br />Important!  CMessage is an abstract class and should not be used directly — instead, use one of its subclasses.
        This abstract class defines the common protocol — properties and behaviour — used by the e-mail classes, CEmail.
      </remarks>
    </member>
    <member name="M:VO.CMessage.#ctor">
      <summary>
        Construct a new CMessage object.
      </summary>
    </member>
    <member name="P:VO.CMessage.AttachmentCount">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CMessage.AttachmentFileList">
      <summary>
        An array of filenames for attachments. (Used only by CNews.)
      </summary>
      <value>An array of filenames for attachments. (Used only by CNews.)</value>
    </member>
    <member name="P:VO.CMessage.AttachmentList">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CMessage.Body">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CMessage.BodyExtract(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="c">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.CMessage.BodyHtml">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CMessage.Boundary">
      <summary>
        A string representing the main boundary for the email.
      </summary>
      <value>A string representing the main boundary for the email.</value>
    </member>
    <member name="P:VO.CMessage.Cargo">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CMessage.ContentType">
      <summary>
        A string representing the content type for that section.
      </summary>
      <value>A string representing the content type for that section.</value>
    </member>
    <member name="M:VO.CMessage.Decode(XSharp.__Usual)">
      <summary>
        Decodes a raw message string into its parts.
      </summary>
      <param name="cMail">The raw string to be decoded.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.CMessage.DecodeAndSaveAs(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        This is an abstract method called by CMessage:SaveAs() If the code type is unknown.
        This method can be provided by the developer to implement unsupported code types.
      </summary>
      <remarks>
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </remarks>
      <param name="cPath">The path to use when saving the file.</param>
      <param name="cFile">The file name to use.</param>
      <param name="cMail">The raw string to be decoded.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.CMessage.Error">
      <summary>
        A number representing the error most recently occurring.
      </summary>
      <value>A number representing the error most recently occurring.</value>
    </member>
    <member name="P:VO.CMessage.ErrorMsg">
      <summary>
        A string representing the details of the last error.
      </summary>
      <value>A string representing the details of the last error.</value>
    </member>
    <member name="M:VO.CMessage.FakeAttachmentList">
      <summary>
        Gets the original file names of the attachment(s).
      </summary>
      <returns>
        Returns a string with the original file names of the attachment(s).
      </returns>
    </member>
    <member name="P:VO.CMessage.FromAddress">
      <summary>
        A string representing the email address of the sender.
      </summary>
      <value>A string representing the email address of the sender.</value>
    </member>
    <member name="P:VO.CMessage.FromName">
      <summary>
        A string representing the name of the sender.
      </summary>
      <value>A string representing the name of the sender.</value>
    </member>
    <member name="M:VO.CMessage.GetAttachInfo(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Retrieves information about attachment(s).
      </summary>
      <param name="c">The optional attachment string.</param>
      <param name="lNewsGroupMessage">A logical flag indicating whether &lt;c&gt; is a news group message.</param>
    </member>
    <member name="M:VO.CMessage.GetHeaderInfo">
      <summary>
        Extracts all the header information and stores that information into the appropriate properties.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.CMessage.HEADER">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CMessage.MailBody">
      <summary>
        A string representing the entire contents of the body of the email. This will include all attachments and multi-part extensions.
      </summary>
      <value>A string representing the entire contents of the body of the email. This will include all attachments and multi-part extensions.</value>
    </member>
    <member name="P:VO.CMessage.MailDate">
      <summary>
        Returns the creation date of the message.
      </summary>
      <value>The creation date of the message.</value>
    </member>
    <member name="P:VO.CMessage.MailHeader">
      <summary>
        A string representing the entire header contents for the email.
      </summary>
      <value>A string representing the entire header contents for the email.</value>
    </member>
    <member name="P:VO.CMessage.MailTime">
      <summary>
        Returns the creation time of the message as a string.
      </summary>
      <value>The creation time of the message as a string.</value>
    </member>
    <member name="P:VO.CMessage.MessageID">
      <summary>
        A string representing the ID of the email.
      </summary>
      <value>A string representing the ID of the email.</value>
    </member>
    <member name="P:VO.CMessage.Priority">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CMessage.References">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CMessage.ReplyTo">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CMessage.SaveAs(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Decode and save the attachment.
      </summary>
      <param name="cPath">The optional directory in which the file will be saved.</param>
      <param name="cFile">The optional file name to save the attachment as.</param>
      <param name="n">Which attachment to save.  If not specified, the first attachment will be saved.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.CMessage.SetMailTime">
      <summary>
        Converts the current time and date into an Internet timestamp string for the current message object.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.CMessage.SubBoundary">
      <summary>
        A string representing the sub boundary for the multi-part alternate email. This is one which carries both text and html components.
      </summary>
      <value>A string representing the sub boundary for the multi-part alternate email. This is one which carries both text and html components.</value>
    </member>
    <member name="P:VO.CMessage.Subject">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CMessage.TimeStamp">
      <summary>
        Returns the creation date and time of the message as a Time-stamp string.
      </summary>
      <value>The creation date and time of the message as a Time-stamp string.</value>
    </member>
    <member name="P:VO.CMessage.TransferEncoding">
      <summary>
        A string representing the Transfer encoding type for the current section.
      </summary>
      <value>A string representing the Transfer encoding type for the current section.</value>
    </member>
    <member name="T:VO.CNews">
      <summary>
        To encapsulate Internet news messages.
      </summary>
      <remarks>
        This class is used to retrieve messages from a news group.
      </remarks>
    </member>
    <member name="M:VO.CNews.#ctor(XSharp.__Usual)">
      <summary>
        Construct a new CNews object.
      </summary>
      <param name="xData">The optional raw news message, which will be decoded into its individual parts.</param>
    </member>
    <member name="P:VO.CNews.FollowUpTo">
      <summary>
        Returns a string representing the FollowUpTo field of the news message header.
      </summary>
      <value>A string representing the FollowUpTo field of the news message header.</value>
    </member>
    <member name="M:VO.CNews.GetAttachInfo(XSharp.__Usual)">
      <summary>
        Returns information about any attachments.
      </summary>
      <param name="c">The optional attachment string.</param>
    </member>
    <member name="M:VO.CNews.GetHeaderInfo">
      <summary>
        Extracts all the header information and stores that information into the appropriate properties.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.CNews.NewsGroups">
      <summary>
        Returns a string representing the NewsGroups field of the news message header.
      </summary>
      <value>A string representing the NewsGroups field of the news message header.</value>
    </member>
    <member name="P:VO.CNews.Organization">
      <summary>
        Returns a string representing the Organization field of the news message header.
      </summary>
      <value>A string representing the Organization field of the news message header.</value>
    </member>
    <member name="P:VO.CNews.Path">
      <summary>
        Returns a string representing the Path field of the news message header.
      </summary>
      <value>A string representing the Path field of the news message header.</value>
    </member>
    <member name="P:VO.CNews.Sender">
      <summary>
        Returns a string representing the Sender field of the news message header.
      </summary>
      <value>A string representing the Sender field of the news message header.</value>
    </member>
    <member name="P:VO.CNews.Size">
      <summary>
        Returns a string representing the size of the news message.
      </summary>
      <value>A string representing the size of the news message.</value>
    </member>
    <member name="T:VO.CNNTP">
      <summary>
        Create an Internet News Server based on NNTP (Network News Transport Protocol).
      </summary>
      <remarks>
        Encapsulates an Internet session to an Internet News Server based on NNTP (Network News Transport Protocol).
      </remarks>
    </member>
    <member name="M:VO.CNNTP.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a new NNTP object.
      </summary>
      <param name="cServer">The local name of the Internet News Server.</param>
      <param name="cUid">The optional user ID as a string.</param>
      <param name="cPwd">The optional password as a string.</param>
    </member>
    <member name="M:VO.CNNTP.Authenticate">
      <summary>
        Authenticates the user to a NNTP Server.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">
          The user ID and password should be specified when initializing the CNNTP object.
        </note>
      </remarks>
    </member>
    <member name="M:VO.CNNTP.CheckReply">
      <summary>
        Determines if the reply from the server has been successful.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.CNNTP.connect(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Establishes a connection to an Internet Mail Server.
      </summary>
      <param name="cIP">The optional string containing the local name of an Internet server. The default is the local host name.</param>
      <param name="n">The optional port number to use at cIP.  The default is IPPORT_SMTP (25).</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.CNNTP.CurrentNews">
      <summary>
        The current CNews object of the CNNTP class.
      </summary>
      <value>The current CNews object of the CNNTP class.</value>
    </member>
    <member name="M:VO.CNNTP.Disconnect">
      <summary>
        Disconnect from the news server.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.CNNTP.GetArticle(XSharp.__Usual)">
      <summary>
        Retrieves a specified message from the selected group.
      </summary>
      <param name="xMsg">This can be a numeric ID or a string containing a unique identifier. If xMsg is not specified, the current message is assumed.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.CNNTP.GetBody(XSharp.__Usual)">
      <summary>
        Retrieves a specified message body from the selected group.
      </summary>
      <param name="xMsg">This can be a numeric ID or a string containing a unique identifier. If xMsg is not specified, the current message is assumed.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.CNNTP.GetHeader(XSharp.__Usual)">
      <summary>
        Retrieves a specified message header from the selected group.
      </summary>
      <param name="xMsg">This can be a numeric ID or a string containing a unique identifier. If xMsg is not specified, the current message is assumed.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.CNNTP.GetList(XSharp.__Usual)">
      <summary>
        Returns a list of all groups from an NTTP Server containing cSearch in their names.
      </summary>
      <param name="cSearch">The string to search for. If cSearch is not specified, the resulting list contains all groups.</param>
      <returns>
        An array of groups.
      </returns>
    </member>
    <member name="M:VO.CNNTP.GetNewGroups(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Returns a list of all newly created groups from an NTTP Server.
      </summary>
      <param name="cSearch">The optional string to search for. If cSearch is not specified, the resulting list contains all groups.</param>
      <param name="dDate">The optional date that is the oldes creation date to accept.</param>
      <param name="cTime">The optional time as a string that is the oldes creation time to accept.</param>
      <param name="lGmt">An optional logical value that determines whether GMT time should be used.</param>
      <returns>
        An array of groups.
      </returns>
    </member>
    <member name="M:VO.CNNTP.GetNewNews(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Returns a list of all newly created messages for a specific group or list of groups from an NTTP Server.
      </summary>
      <param name="cGroups">The group (i.e. 'comp.lang.clipper.visual-objects) or list of groups (i.e. 'comp.lang.clipper.*') to query.</param>
      <param name="dDate">The optional date that is the oldes creation date of the message to accept.</param>
      <param name="cTime">The optional time as a string that is the oldes creation time of the message to accept.</param>
      <param name="lGmt">An optional logical value that determines whether GMT time should be used.</param>
      <returns>
        An array of newly created messages.
      </returns>
    </member>
    <member name="M:VO.CNNTP.GetStatus(XSharp.__Usual)">
      <summary>
        Retrieves a specified message status from the selected group.
      </summary>
      <param name="xMsg">This can be a numeric ID or a string containing a unique identifier. If xMsg is not specified, the current message is assumed.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.CNNTP.GroupName">
      <summary>
        Returns a string representing the name of the currently selected group.
      </summary>
      <value>A string representing the name of the currently selected group.</value>
    </member>
    <member name="P:VO.CNNTP.Message">
      <summary>
        Returns the numeric ID of the message currently being processed.
      </summary>
      <value>The numeric ID of the message currently being processed.</value>
    </member>
    <member name="P:VO.CNNTP.MessageCount">
      <summary>
        Returns the number of messages in the currently selected group.
      </summary>
      <value>The number of messages in the currently selected group.</value>
    </member>
    <member name="P:VO.CNNTP.MessageFirst">
      <summary>
        Returns the numeric ID of the first available message in the currently selected group.
      </summary>
      <value>The numeric ID of the first available message in the currently selected group.</value>
    </member>
    <member name="P:VO.CNNTP.MessageID">
      <summary>
        Returns a string representing the unique message ID of the message currently being processed.
      </summary>
      <value>A string representing the unique message ID of the message currently being processed.</value>
    </member>
    <member name="P:VO.CNNTP.MessageLast">
      <summary>
        Returns the numeric ID of the last available message in the currently selected group.
      </summary>
      <value>The numeric ID of the last available message in the currently selected group.</value>
    </member>
    <member name="M:VO.CNNTP.Post(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oMsg">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CNNTP.PrepareCommand(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="cCommand">** missing parameter documentation **</param>
      <param name="xMsg">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CNNTP.RecvData(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="cCommand">** missing parameter documentation **</param>
      <param name="nRetCode">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CNNTP.RecvRemote">
      <summary>
        Retrieves data from the news server via socket.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">
          The data that is retrieved wil be terminated by a CRLF.
        </note>
      </remarks>
    </member>
    <member name="P:VO.CNNTP.ReplyString">
      <summary>
        Returns a string with the latest reply from the NNTP Server.
      </summary>
      <value>A string with the latest reply from the NNTP Server.</value>
    </member>
    <member name="M:VO.CNNTP.SendHeader">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CNNTP.SendMailBody">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CNNTP.SetNewsGroup(XSharp.__Usual)">
      <summary>
        Selects a newsgroup from a NTTP Server for further processing.
      </summary>
      <param name="cGroup">The name of the group to select as a string.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.CNNTP.SetReadMode">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CNNTP.SkipNext">
      <summary>
        Sets the internal message pointer to the next available message of the current group.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.CNNTP.SkipPrev">
      <summary>
        Sets the internal message pointer to the previous available message of the current group.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="T:VO.cOleMethod">
      <summary>
        Provide a helper class to store the descriptions of the properties and methods supported by an OleAutomation server.
      </summary>
      <remarks>
        <br />Important!  This class is used for internal implementation only and is not intended to be used directly.
        Objects of this class are also used in the generated code by the Automation Server Class generator in the X# IDE.
        <code language="X#">
          CLASS cOleMethod
            EXPORT symName	AS SYMBOL
            EXPORT iMemberid	AS LONGINT
            EXPORT iFuncKind	AS LONGINT
            EXPORT wInvokeKind 	AS WORD
            EXPORT nParams	AS LONGINT
            EXPORT nOptParams	AS LONGINT
            EXPORT lNamedArgs	AS LOGIC
            EXPORT cParamTypes	AS STRING
            EXPORT bRetType	AS BYTE
        </code>

        (No ancestor)

        (No descendants)

        OLE
      </remarks>
    </member>
    <member name="T:VO.Color">
      <summary>
        Select or create a color, which can be used by a Brush, Pen, or DrawObject object.
      </summary>
      <remarks>
        X# provides eight predefined colors or you can also create a color by specifying a weighted combination of red, green, and blue (RGB) values.  (Values can range from 0 (lowest intensity) to 255 (highest intensity).)
      </remarks>
      <example>
        This example darkens a color:
        <code language="X#">
          METHOD Darken(oColor) CLASS MyWindow
          RETURN Color{oColor:Red - 9, oColor:Green - 9, ;
          oColor:Blue - 9}
        </code></example>
    </member>
    <member name="M:VO.Color.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a color using an RGB triplet.
      </summary>
      <param name="nRed">
        The amount of red to be used to create the color.  This can be a value between 0 (lowest intensity) and 255 (highest intensity).  The default value is 0.
      </param>
      <param name="nGreen">
        The amount of green to be used to create the color.  This can be a value between 0 (lowest intensity) and 255 (highest intensity).  The default value is 0.
      </param>
      <param name="nBlue">
        The amount of blue to be used to create the color.  This can be a value between 0 (lowest intensity) and 255 (highest intensity).  The default value is 0.
      </param>
      <remarks>
        If the first and second argument are both numeric and the second argument is -1, VO will treat the first number as the colorref of the color object.
        In that case the first number indicates the standard color to create, specified as one of the following constants:
        <pre>
          Constant      Color
          COLORBLACK    Black
          COLORBLUE     Blue
          COLORCYAN     Cyan
          COLORGREEN    Green
          COLORMAGENTA  Magenta
          COLORRED      Red
          COLORWHITE    White
          COLORYELLOW   Yellow
        </pre></remarks>
      <example>
        The following example defines some colors:
        <code language="X#">
          oRed                 := Color{COLORRED}
          oWhite               := Color{ 255, 255, 255}
          oMediumAquamarine    := Color{  50, 204, 153}
          oBlack               := Color{   0,   0,   0}
          oBlue                := Color{   0,   0, 255}
          oCadetBlue           := Color{  95, 159, 159}
          oCornflowerBlue      := Color{  66,  66, 111}
          oDarkSlateBlue       := Color{ 107,  35, 142}
        </code></example>
    </member>
    <member name="P:VO.Color.Blue">
      <summary>
        A numeric value between 0 (lowest intensity) and 255 (highest intensity) representing the amount of blue in a color.
      </summary>
      <value>A numeric value between 0 (lowest intensity) and 255 (highest intensity) representing the amount of blue in a color.</value>
    </member>
    <member name="P:VO.Color.ColorRef">
      <summary>
        A numeric value between 0 and 0xFFFFFF with the combined colors in RGB format.
      </summary>
      <value>A numeric value between 0 and 0xFFFFFF with the combined colors in RGB format.</value>
    </member>
    <member name="M:VO.Color.Destroy">
      <summary>
        Provide a method to de-instantiate a Color object.
      </summary>
      <remarks>
        This method can be used when a Color object is no longer needed.  Color:Destroy() de-instantiates the Color object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="P:VO.Color.Green">
      <summary>
        A numeric value between 0 (lowest intensity) and 255 (highest intensity) representing the amount of green in a color.
      </summary>
      <value>A numeric value between 0 (lowest intensity) and 255 (highest intensity) representing the amount of green in a color.</value>
    </member>
    <member name="P:VO.Color.Red">
      <summary>
        A numeric value between 0 (lowest intensity) and 255 (highest intensity) representing the amount of red in a color.
      </summary>
      <value>A numeric value between 0 (lowest intensity) and 255 (highest intensity) representing the amount of red in a color.</value>
    </member>
    <member name="T:VO.ComboBox">
      <summary>
        Create a combo box, which is used when you need to provide the user with both a list of choices and an edit control (to optionally allow them to type in their own choice).
      </summary>
      <remarks>
        A combo box (also known as a combination box) is a control that combines the abilities of an edit control and a list box.  There are three types of combo boxes — simple, drop-down, and drop-down list.
        A combo box displays a list of items or choices to the user, as well as allowing text to be entered directly into an edit area.  The combo box methods will allow you to add, arrange, remove, and interrogate the list of  items.
        When one of the items is selected, ComboBox:CurrentItem, ComboBox:CurrentItemNo, ComboBox:TextValue, and ComboBox:Value are updated.  Either a one-dimensional or two-dimensional array is specified in the FillUsing() method, with a row for each of the items available for selection.  With a two-dimensional array, the first element is called the display value, and the second element is called the return value.  When an item is selected, the ComboBox:TextValue contains the first element (the display value), and ComboBox:Value contains the second element (the return value).  When text is directly entered, ComboBox:CurrentItemNo is set to 0 and the new text is stored in ComboBox:TextValue and ComboBox:Value.
        A combo box may be bound to a field (character, date, logical, numeric, or memo) in a server.  The field's data value is stored in ComboBox:Value.  The combo box compares the data value to the second element values specified in the FillUsing() array, and if a match is found, the first element (the display value) is stored in ComboBox:TextValue.  In a "no-match" situation, the combo box shows no item selected, ComboBox:CurrentItem is NULL_STRING, ComboBox:CurrentItemNo is set to 0, and ComboBox:TextValue and ComboBox:Value reflect the field contents.  If an item is selected, ComboBox:CurrentItemNo is set to a number between 1 and ComboBox:ItemCount, and the corresponding second element is stored as ComboBox:Value and as the field's data value.  If text is directly entered, it will also be stored as the field's data value.

        Use the Window:ListBoxSelect() event handler to respond to selections, and the Window:ListBoxClick() event handler to respond to choices.
        A combo box is primarily a selection device, so there is no special support for the functionality available in the Edit class.  However, the contents of the edit component can be changed or obtained using the inherited CurrentText access/assign methods.
        The combo box also generates EditFocusChangeEvents when its edit control loses or receives the focus.
      </remarks>
      <example>
        This example creates a combo box and fills it with a list of animals:
        <code language="X#">
          CLASS MyWindow INHERIT TopAppWindow
          HIDDEN oCB AS OBJECT
          METHOD Init() CLASS MyWindow
          SUPER:Init()
          oCB := ComboBox{SELF,42,Point{10,10},;
          Dimension{100,40},BOXDROPDOWN}
          oCB:AddItem("Pig")
          oCB:AddItem("Cow")
          oCB:AddItem("Horse")
          oCB:Show()
        </code>
        This example creates a combo box with different currencies, showing an explicit representation to the user but using a different representation internally:
        <code language="X#">
          METHOD Init(...) CLASS OrderWindow
          ...
          oCBCurrency := ComboBox{SELF,CBCURRENCY_ID}
          oCBCurrency:FillUsing({;
                                {"U.S. Dollars","USD"},;
                                {"Can. Dollars","CDN"},;
                                {"Mexican Pesos","MEX"},;
                                {"Yen","YEN"},;
                                {"British Pounds","UK"},;
                                {"German Marks","DM"};
                                })
           oCBCurrency:Show()
        </code>
        This example creates a combo box that shows the products available in the product table:
        <code language="X#">
          METHOD Init(...) CLASS OrderWindow
          ...
          oCBProducts := ComboBox{SELF,CBPRODUCTS_ID}
          oCBProducts:FillUsing(oDBProducts,#ProdName,#ProdNo)
          oCBProducts:Show()
        </code></example>
    </member>
    <member name="M:VO.ComboBox.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a combo box.
      </summary>
      <param name="oOwner">The window that owns the combo box.</param>
      <param name="xID">The unique ID of the combo box (between 1 and 8000).</param>
      <param name="oPoint">The origin of the combo box in canvas coordinates.</param>
      <param name="oDimension">The dimension of the combo box in canvas coordinates.</param>
      <param name="kComboType">
        The type of combo box to create, specified as one of the constants that are listed in the remarks section

      </param>
      <param name="kStyle">The style of the combo box, specified as one of the Windows API constants listed below:</param>
      <param name="nResourceID">The resource ID of the combo box.</param>
      <remarks>
        <list>
          <listheader>
            <term>Constant</term>
            <description>Creates</description>
          </listheader>
          <item>
            <term>BOXDROPDOWN</term>
            <description>
              An extended combo box with both an edit control and a drop-down icon beside it.  The user can enter/edit text in the edit control, or choose items from the list box.  (The list box appears only if the user selects the drop-down icon; if the user then selects the icon again, the list box is hidden.)  This is the default.
            </description>
          </item>
          <item>
            <term>BOXDROPDOWNLIST</term>
            <description>
              Same as BOXDROPDOWN, except that the user can only choose items from the list box.  Text cannot be entered or edited in the edit control.
            </description>
          </item>
          <item>
            <term>BOXSIMPLE</term>
            <description>
              A extended combo box with both an edit control and a list box that are visible at all times.  The user can enter/edit text in the edit control, or choose items from the list box.  
            </description>
          </item>
        </list>
        Possible values for kStyle are:
        <pre>
          CBS_AUTOHSCROLL
          CBS_DISABLENOSCROLL
          CBS_DROPDOWN
          CBS_DROPDOWNLIST
          CBS_HASSTRINGS
          CBS_LOWERCASE
          CBS_NOINTEGRALHEIGHT
          CBS_OEMCONVERT
          CBS_OWNERDRAWFIXED
          CBS_OWNERDRAWVARIABLE
          CBS_SIMPLE
          CBS_SORT
          CBS_UPPERCASE
        </pre></remarks>
    </member>
    <member name="P:VO.ComboBox.CurrentItem">
      <summary>
        A string representing the displayed combo box item selected.  The ComboBox:CurrentItem access also changes ComboBox:CurrentItemNo, ComboBox:CurrentText, ComboBox:TextValue, and ComboBox:Value, if there is a match with the available display items.
      </summary>
      <value>A string representing the displayed combo box item selected.  The ComboBox:CurrentItem access also changes ComboBox:CurrentItemNo, ComboBox:CurrentText, ComboBox:TextValue, and ComboBox:Value, if there is a match with the available display items.</value>
    </member>
    <member name="P:VO.ComboBox.CurrentItemNo">
      <summary>
        A numeric value, between 1 and the ComboBox:ItemCount, indicating which item has most recently had focus.  If no item is selected it is 0.  The ComboBox:CurrentItemNo assign also changes ComboBox:CurrentItem, ComboBox:TextValue, and ComboBox:Value.  If the ComboBox:CurrentItemNo assign represents a change, then ComboBox:ValueChanged will be set to TRUE.
      </summary>
      <value>A numeric value, between 1 and the ComboBox:ItemCount, indicating which item has most recently had focus.  If no item is selected it is 0.  The ComboBox:CurrentItemNo assign also changes ComboBox:CurrentItem, ComboBox:TextValue, and ComboBox:Value.  If the ComboBox:CurrentItemNo assign represents a change, then ComboBox:ValueChanged will be set to TRUE.</value>
    </member>
    <member name="P:VO.ComboBox.CurrentText">
      <summary>
        ComboBox:CurrentText contains the text currently appearing in the edit box area of the combo box.  The CurrentText assign also changes TextValue and Value.  If the assigned CurrentText does not match one of the displayed items, then CurrentItemNo is set to 0.  If the assigned value represents a change, then ValueChanged will be set to TRUE.
      </summary>
      <value>ComboBox:CurrentText contains the text currently appearing in the edit box area of the combo box.  The CurrentText assign also changes TextValue and Value.  If the assigned CurrentText does not match one of the displayed items, then CurrentItemNo is set to 0.  If the assigned value represents a change, then ValueChanged will be set to TRUE.</value>
    </member>
    <member name="M:VO.ComboBox.Destroy">
      <summary>
        Provide a method to de-instantiate a ComboBox object.
      </summary>
      <remarks>
        This method can be used when a ComboBox object is no longer needed.  ComboBox:Destroy() de-instantiates the ComboBox object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="P:VO.ComboBox.EditHandle">
      <summary>
        The handle to the edit portion of a ComboBox control.
      </summary>
      <value>The handle to the edit portion of a ComboBox control.</value>
    </member>
    <member name="P:VO.ComboBox.EditHeight">
      <summary>
        Integer value specifying the height of the embedded edit control.
      </summary>
      <value>Integer value specifying the height of the embedded edit control.</value>
    </member>
    <member name="M:VO.ComboBox.EnableAutoComplete(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="dwFlags">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.ComboBox.Font(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oNewFont">** missing parameter documentation **</param>
      <param name="lRescal">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.ComboBox.Modified">
      <summary>
        A logical value indicating whether an editable combo box is in the process of being modified.  While you are typing in new text, or moving the highlighted selection, it is set to TRUE.  When the focus shifts away from the combo box, ComboBox:Modified is reset to FALSE.
      </summary>
      <value>A logical value indicating whether an editable combo box is in the process of being modified.  While you are typing in new text, or moving the highlighted selection, it is set to TRUE.  When the focus shifts away from the combo box, ComboBox:Modified is reset to FALSE.</value>
    </member>
    <member name="P:VO.ComboBox.ReadOnly">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.ComboBox.RemoveEditBalloonTip">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.ComboBox.SetCueBanner(XSharp.__Usual)">
      <summary>
        Add a cue banner to the Edit portion of the ComboBox control.
      </summary>
      <param name="cTitle">The text displayed as the cue.</param>
      <remarks>
        A cue banner is text displayed in an edit control, usually indicating the purpose of the control or prompting for the type of input required. When the control gets focus or has text in it the cue is no longer displayed.
      </remarks>
    </member>
    <member name="M:VO.ComboBox.ShowEditBalloonTip(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="cTitle">** missing parameter documentation **</param>
      <param name="cText">** missing parameter documentation **</param>
      <param name="dwIcon">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.ComboBox.TextValue">
      <summary>
        A string representing the display value (first array element) for the currently selected item, if any, or any text which has been directly entered.  The string is formatted according to the picture clause of the field specification attached to the list box (or combo box).  For example the ComboBoxTextValue can be "Jones", "01/15/95", or "8".
        The ComboBoxTextValue assign also changes ComboBox:CurrentItem, ComboBox:CurrentItemNo, ComboBox:Modified, ComboBox:Value, and ComboBox:ValueChanged.  If the assign does not match one of the display items, then ComboBox:TextValue and ComboBox:Value are set to the text that could not be matched, and ComboBox:CurrentItemNo is set to 0.  If the control is bound to a field in a server and the field data value does not match one of the array's second elements, ComboBox:TextValue and ComboBox:Value contain the field's data value.
      </summary>
      <value>
        A string representing the display value (first array element) for the currently selected item, if any, or any text which has been directly entered.  The string is formatted according to the picture clause of the field specification attached to the list box (or combo box).  For example the ComboBoxTextValue can be "Jones", "01/15/95", or "8".
        The ComboBoxTextValue assign also changes ComboBox:CurrentItem, ComboBox:CurrentItemNo, ComboBox:Modified, ComboBox:Value, and ComboBox:ValueChanged.  If the assign does not match one of the display items, then ComboBox:TextValue and ComboBox:Value are set to the text that could not be matched, and ComboBox:CurrentItemNo is set to 0.  If the control is bound to a field in a server and the field data value does not match one of the array's second elements, ComboBox:TextValue and ComboBox:Value contain the field's data value.
      </value>
    </member>
    <member name="P:VO.ComboBox.Value">
      <summary>
        A string representing the return value (second element in the FillUsing() array) for the currently selected item, if any, or any text which has been directly entered.  The string is formatted according to the picture clause of the field specification attached to the list box (or combo box).  For example the ComboBox:TextValue can be "Jones", "01/15/95", or "8".
      </summary>
      <value>A string representing the return value (second element in the FillUsing() array) for the currently selected item, if any, or any text which has been directly entered.  The string is formatted according to the picture clause of the field specification attached to the list box (or combo box).  For example the ComboBox:TextValue can be "Jones", "01/15/95", or "8".</value>
      <remrks>
        <note type="tip">ComboBox:Value may not always be consistent with what the state of the control, as indicated to the end-user.  For example, if the data value for the field is not one of the allowed choices for a list box return value, the control will be in a "no-match" situation.  In this case the list box will revert to its initial unselected state with CurrentItemNo set to 0.</note>
        If there is no selected item and the combo box is not bound to a field in a server, the ComboBox:Value is set to NIL.  If there is a match, the ComboBox:Value assign also changes ComboBox:CurrentItem, ComboBox:CurrentItemNo, ComboBox:TextValue, and ComboBox:ValueChanged.  If the assigned text does not match one of the return value choices, ComboBox:CurrentItemNo is set to 0, and TextValue and Value are set to the assigned text.  In a list box, the ComboBox:Value is generally one of the return values, unless the control is bound to a field where the actual contents is not one of the allowable choices; in this case, ComboBox:TextValue and ComboBox:Value contain the field's data value.
        The data type for ComboBox:Value is determined by the field specification of the list box; in turn, controls linked to a data server inherit the field specification — and hence data type — from the field of the server.  When the control is made data-aware, by setting its name to the name of a field in the server attached to the data window, ComboBox:Value is able to automatically read from and write to this field.

      </remrks>
    </member>
    <member name="P:VO.ComboBox.ValueChanged">
      <summary>
        A logical value representing whether the combo box Value has been changed from the previously selected item during the selection process.  TRUE indicates that it has been changed from the prior choice, while FALSE indicates it has been not changed from the prior choice.  The combo box Value may be changed by clicking on a different item, via the ComboBox:TextValue or ComboBox:Value assigns, or by directly entering text.
      </summary>
      <value>A logical value representing whether the combo box Value has been changed from the previously selected item during the selection process.  TRUE indicates that it has been changed from the prior choice, while FALSE indicates it has been not changed from the prior choice.  The combo box Value may be changed by clicking on a different item, via the ComboBox:TextValue or ComboBox:Value assigns, or by directly entering text.</value>
    </member>
    <member name="T:VO.ComboBoxEx">
      <summary>
        Encapsulate a ComboBoxEx control.
      </summary>
      <remarks>
        A ComboBoxEx control is a ComboBox control with two extensions.
        Firstly, each item in the list is able to display an image beside it. This is achieved with the use of an ImageList object that is assigned to the control. It is also able to overlay a second image when the item is selected. Both images are specified when the item is added to the control.
        Secondly, unlike the normal ComboBox control, a ComboBoxEx control is not restricted inside of the frame of its owner but, can pass over the frame and into the surrounding area so as to display its list of entries in the drop-down box.
      </remarks>
    </member>
    <member name="M:VO.ComboBoxEx.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Instantiate a new ComboBoxEx object.
      </summary>
      <param name="oOwner">The window that owns the extended combo box.</param>
      <param name="xID">The unique ID of the extended combo box (between 1 and 8000).</param>
      <param name="oPoint">The origin of the extended combo box in canvas coordinates.</param>
      <param name="oDimension">The dimension of the extended combo box in canvas coordinates.</param>
      <param name="kComboType">
        The type of extended combo box to create, specified as one of the constants in the table in the remarks section.
      </param>
      <param name="kStyle">The style of the extended combo box, specified as one of the API constants in the remarks section</param>
      <param name="nResourceID">The resource ID of the extended combo box.</param>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Creates</description>
          </listheader>
          <item>
            <term>BOXDROPDOWN</term>
            <description>
              An extended combo box with both an edit control and a drop-down icon beside it.  The user can enter/edit text in the edit control, or choose items from the list box.  (The list box appears only if the user selects the drop-down icon; if the user then selects the icon again, the list box is hidden.)  This is the default.
            </description>
          </item>
          <item>
            <term>BOXDROPDOWNLIST</term>
            <description>
              Same as BOXDROPDOWN, except that the user can only choose items from the list box.  Text cannot be entered or edited in the edit control.
            </description>
          </item>
          <item>
            <term>BOXSIMPLE</term>
            <description>
              A extended combo box with both an edit control and a list box that are visible at all times.  The user can enter/edit text in the edit control, or choose items from the list box.  
            </description>
          </item>
        </list>
        Possible kStyle values are:
        <pre>
          CBS_AUTOHSCROLL
          CBS_DISABLENOSCROLL
          CBS_DROPDOWN
          CBS_DROPDOWNLIST
          CBS_HASSTRINGS
          CBS_LOWERCASE
          CBS_NOINTEGRALHEIGHT
          CBS_OEMCONVERT
          CBS_OWNERDRAWFIXED
          CBS_OWNERDRAWVARIABLE
          CBS_SIMPLE
          CBS_SORT
          CBS_UPPERCASE
        </pre><note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular style constant.</note></remarks>
    </member>
    <member name="M:VO.ComboBoxEx.AddItem(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Add a new item to the ComboBoxEx object.
      </summary>
      <param name="cItem">The item text as string.</param>
      <param name="nItemNumber">The position where to insert the new item.  The default placement is at the end of the list (-1).  Note that the index into the combo box is zero-based.</param>
      <param name="uRetValue">The value associated with the specified item.  The default is &lt;cItem&gt;.</param>
      <param name="iImageIdx">The index of the image associated with this item.</param>
      <param name="iSelectedIdx">The image index to display when the item is selected.</param>
      <param name="iOverlayIdx">The image index of on overlay image in the image list.</param>
      <param name="iIndent">The indentation level of the item.</param>
      <returns>
        The position of the newly inserted item.
      </returns>
      <remarks>
        This method inserts a new item into the ComboBoxEx control.  In addition to the parameters known from the parent classes, ComboBoxEx also expects indexes into the associated image list that specify the image(s) to be displayed together with the item text.
      </remarks>
    </member>
    <member name="M:VO.ComboBoxEx.DeleteItem(XSharp.__Usual)">
      <summary>
        Remove an item from the ComboBox object.
      </summary>
      <param name="nItemNumber">The number of the item to be deleted.  If omitted, defaults to the current item.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Overrides the DeleteItem() method of its parent class to implement the same behavior for ComboBoxEx objects.
      </remarks>
    </member>
    <member name="M:VO.ComboBoxEx.Dispatch(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ComboBoxEx.EditHandle">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.ComboBoxEx.GetExCBStyle(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="kExStyle">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.ComboBoxEx.GetItemAttributes(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="uItemNumber">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.ComboBoxEx.ImageList">
      <summary>
        The ImageList object containing the images for the items in the ComboBoxEx object.
      </summary>
      <value>The ImageList object containing the images for the items in the ComboBoxEx object.</value>
    </member>
    <member name="M:VO.ComboBoxEx.InsertItem(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="uComboBoxExItem">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.ComboBoxEx.Length">
      <summary>
        The length of the current text.  Overrides the Length property of its parent class to provide the same functionality in this specialized class.
      </summary>
      <value>The length of the current text.  Overrides the Length property of its parent class to provide the same functionality in this specialized class.</value>
    </member>
    <member name="M:VO.ComboBoxEx.SetExCBStyle(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="kExStyle">** missing parameter documentation **</param>
      <param name="lEnable">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.ComboBoxEx.SetItemAttributes(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="uComboBoxExItem">** missing parameter documentation **</param>
    </member>
    <member name="T:VO.ComboBoxExEndEditEvent">
      <summary>
        Provide information about a ComboBoxEx EndEdit event
      </summary>
      <remarks>
        ComboBoxExEndEditEvent events are generated when the user has concluded an operation within the edit box or has selected an item from the control's drop-down list.

      </remarks>
    </member>
    <member name="M:VO.ComboBoxExEndEditEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ComboBoxExEndEditEvent.IsChanged">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.ComboBoxExEndEditEvent.NewSelection">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.ComboBoxExEndEditEvent.TextValue">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.ComboBoxExEndEditEvent.Why">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.ComboBoxExItem">
      <summary>
        This class contains all properties of a ComboBoxEx item.
        It is used with the ComboBoxEx methods
        ComboBoxEx:SetItemAttributes()
        ComboBoxEx:GetItemAttributes()
        ComboBoxEx:InsertItem()
      </summary>
    </member>
    <member name="M:VO.ComboBoxExItem.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Instantiate a new ComboBoxExItem object.
      </summary>
      <param name="cItem">The item text as string.</param>
      <param name="nItemNumber">The position where to insert the new item.  The default placement is at the end of the list (-1).  Note that the index into the combo box is zero-based.</param>
      <param name="uRetValue">The value associated with the specified item.  The default is &lt;cItem&gt;.</param>
      <param name="iImageIdx">The index of the image associated with this item.</param>
      <param name="iSelectedIdx">The image index to display when the item is selected.</param>
      <param name="iOverlayIdx">The image index of on overlay image in the image list.</param>
      <param name="iIndent">The indentation level of the item.</param>
    </member>
    <member name="F:VO.ComboBoxExItem.ImageIndex">
      <exclude />
    </member>
    <member name="P:VO.ComboBoxExItem.ImageIndex">
      <summary>The index of the image associated with this item.</summary>
      <value>The index of the image associated with this item.</value>
    </member>
    <member name="F:VO.ComboBoxExItem.Indent">
      <exclude />
    </member>
    <member name="P:VO.ComboBoxExItem.Indent">
      <summary>The indentation level of the item.</summary>
      <value>The indentation level of the item.</value>
    </member>
    <member name="F:VO.ComboBoxExItem.ItemIndex">
      <exclude />
    </member>
    <member name="P:VO.ComboBoxExItem.ItemIndex">
      <summary>The position of the item in the combobox.</summary>
      <value>The position of the item in the combobox.</value>
    </member>
    <member name="F:VO.ComboBoxExItem.OverlayImageIndex">
      <exclude />
    </member>
    <member name="P:VO.ComboBoxExItem.OverlayImageIndex">
      <summary>The image index of on overlay image in the image list.</summary>
      <value>The image index of on overlay image in the image list.</value>
    </member>
    <member name="F:VO.ComboBoxExItem.SelectedImageIndex">
      <exclude />
    </member>
    <member name="P:VO.ComboBoxExItem.SelectedImageIndex">
      <summary>The image index to display when the item is selected.</summary>
      <value>The image index to display when the item is selected.</value>
    </member>
    <member name="F:VO.ComboBoxExItem.TextValue">
      <exclude />
    </member>
    <member name="P:VO.ComboBoxExItem.TextValue">
      <summary>The item text as string.</summary>
      <value>The item text as string.</value>
    </member>
    <member name="F:VO.ComboBoxExItem.Value">
      <exclude />
    </member>
    <member name="P:VO.ComboBoxExItem.Value">
      <summary>The value associated with the specified item.</summary>
      <value>The value associated with the specified item.</value>
    </member>
    <member name="T:VO.Console">
      <summary>
        Encapsulate a Win32 console application.
      </summary>
      <remarks>
        A noticeable difference between the implementation of the two libraries can be seen when starting an application from the command line.  A Terminal Lite application will get a new window allocated, while a Console Classes application runs in the same window in which it was started.  Depending on the command line setting, a Console Classes application can also run full screen, while a Terminal Lite application cannot.  Also, using the Console Classes does not require an additional runtime DLL to be distributed with your application.
        <note type="tip">The application type has to be set to Console in the Application Options dialog box in order to run the application within the Win32 console.  Otherwise, a separate console window is created.  You can also use the Console class to create a separate console window in a regular Windows application, e.g., to output some debug information.</note></remarks>
    </member>
    <member name="M:VO.Console.#ctor">
      <summary>
        Instantiate a new Console object.
      </summary>
      <param name="lNew">A logical value forcing the allocation of a new console window, if set to TRUE.  The default is FALSE.</param>
      <remarks>
        The Init() method allocates a new console window.  By default, or if the &lt;lNew&gt; parameter is set to FALSE, X# first tries to use an already open console window, e.g., if the application was started from the command line.  If this fails, or if &lt;lNew&gt; was set to TRUE, Console:Init() allocates and opens a new console window.
      </remarks>
      <example>
        This code snippet creates and clear a new console window:
        <code language="X#">
          FUNCTION Start()
          LOCAL oCon AS Console
          oCon := Console{}
          oCon:Clear()
        </code></example>
    </member>
    <member name="M:VO.Console.Clear">
      <summary>
        Clear the console window.
      </summary>
      <example>
        This code snippet creates and clear a new console window:
        <code language="X#">
          FUNCTION Start()
          LOCAL oCon AS Console
          oCon := Console{}
          oCon:Clear()
        </code></example>
    </member>
    <member name="P:VO.Console.CursorPos">
      <summary>
        The current cursor position as a ConsoleCoord object.
      </summary>
      <value>The current cursor position as a ConsoleCoord object.</value>
    </member>
    <member name="P:VO.Console.CursorSize">
      <summary>
        An integer specifying the current cursor size.
      </summary>
      <value>An integer specifying the current cursor size.</value>
    </member>
    <member name="P:VO.Console.CursorVisible">
      <summary>
        A logic controlling the cursor's visibility.
      </summary>
      <value>A logic controlling the cursor's visibility.</value>
    </member>
    <member name="M:VO.Console.Destroy">
      <summary>
        Provide a method to de-instantiate a.
      </summary>
      <remarks>
        This method can be used when a Console object is no longer needed.  Console:Destroy() de-instantiates the Console object, and allows you to close and free any resources that were opened or created by the object without waiting for the garbage collector.
      </remarks>
      <returns>
        NIL
      </returns>
    </member>
    <member name="M:VO.Console.Read">
      <summary>
        Use this to read the console input buffer.
      </summary>
      <returns>
        A string containing the input characters.
      </returns>
      <remarks>
        The Console:Read() method reads up to 256 characters of console input buffer.
      </remarks>
      <example>
        The following lines wait for, read, and echo console input.
        <code language="X#">
          FUNCTION Start(p)
          LOCAL oCon AS Console
          LOCAL sInput AS STRING
          oCon := Console{}
          oCon:Clear()
          oCon:Write("Enter text: ")
          sInput := oCon:Read()
          oCon:Write("You entered : " + sInput)
        </code></example>
    </member>
    <member name="P:VO.Console.Size">
      <summary>
        The size of the console as a ConsoleCoord object.
      </summary>
      <value>The size of the console as a ConsoleCoord object.</value>
    </member>
    <member name="P:VO.Console.TextAttribute">
      <summary>
        A word specifying the current text attributes.
      </summary>
      <value>A word specifying the current text attributes.</value>
      <remarks>
        <para>Any combination of the following constants can be used using _Or():</para>
        <list type="table">
          <item>
            <term>FOREGROUND_BLUE</term>
          </item>
          <item>
            <term>FOREGROUND_GREEN</term>
          </item>
          <item>
            <term>FOREGROUND_RED</term>
          </item>
          <item>
            <term>FOREGROUND_INTENSITY</term>
          </item>
          <item>
            <term>BACKGROUND_BLUE</term>
          </item>
          <item>
            <term>BACKGROUND_GREEN</term>
          </item>
          <item>
            <term>BACKGROUND_RED</term>
          </item>
          <item>
            <term>BACKGROUND_INTENSITY</term>
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:VO.Console.Title">
      <summary>
        A string specifying the console application's caption.
      </summary>
      <value>A string specifying the console application's caption.</value>
    </member>
    <member name="M:VO.Console.Wait">
      <summary>
        Waits for a key press or mouse click on the console window.
      </summary>
      <returns>
        A character representation of the key pressed or mouse button clicked. In general this return value should not be used.
      </returns>
      <remarks>
        This method waits for a key press or mouse click on the console.
      </remarks>
      <example>
        The following lines display the current date and then wait for a keypress
        <code language="X#">
          FUNCTION Start(p)
          LOCAL oCon AS Console
          LOCAL sInput AS STRING
          oCon := Console{}
          oCon:Clear()
          oCon:Write("The date: " + DTOC(TODAY())
          oCon:WriteLine("Press any key to continue")
          sInput := oCon:Wait()
        </code></example>
    </member>
    <member name="M:VO.Console.Write(XSharp.__Usual)">
      <summary>
        Write a string to the console window.
      </summary>
      <param name="sMsg">The string to be written to the console.</param>
      <remarks>
        This method writes a string to the console.  The string is written at the current cursor position.
      </remarks>
      <example>
        The following lines wait for, read, and echo console input.
        <code language="X#">
          FUNCTION Start(p)
          LOCAL oCon AS Console
          LOCAL sInput AS STRING
          oCon := Console{}
          oCon:Clear()
          oCon:Write("Enter text: ")
          sInput := oCon:Read()
          oCon:Write("You entered : " + sInput)
        </code></example>
    </member>
    <member name="M:VO.Console.WriteError(XSharp.__Usual)">
      <summary>
        Write an error message string to the StdErr handle.
      </summary>
      <param name="sMsg">The string to be written to the StdErr handle.</param>
    </member>
    <member name="M:VO.Console.WriteLine(XSharp.__Usual)">
      <summary>
        Write a string to the console window and start a new line.
      </summary>
      <param name="sMsg">The string to be written to the console.</param>
    </member>
    <member name="T:VO.ConsoleCoord">
      <summary>
        A helper class encapsulating a console window's coordinates.
      </summary>
      <remarks>
        The ConsoleCoord class encapsulates x and y values used for Console:Size and Console:CursorPos properties.
      </remarks>
    </member>
    <member name="M:VO.ConsoleCoord.#ctor(System.Int32,System.Int32)">
      <summary>
        Instantiate a ConsoleCoord object.
      </summary>
      <param name="nX">An integer value specifying the x-axis position or width.</param>
      <param name="nY">An integer value specifying the y-axis position or height.</param>
      <remarks>
        ConsoleCoord:Init() instantiates a new ConsoleCoord object, which can be used for the Console:Size and Console:CursorPos properties.
      </remarks>
    </member>
    <member name="T:VO.Control">
      <summary>
        Provide the base class from which all X# controls are subclassed.
      </summary>
      <remarks>
        Control is the base class for a major system class hierarchy.  Controls provide an easy mechanism for user I/O.  They are self-contained and notify their respective owners when the user takes some action (such as pressing a button or entering text).
        Controls on dialog windows created from resource entity templates are shown automatically when the dialog window is shown.  However, if the application wishes to manipulate a control, it must register the control by creating a system object of the appropriate type.
        Controls must appear in an owner window.  They also need to know where to appear.  There are two basic ways you can specify where; one is by placing the control using the Window Editor.  In this case, X# generates a resource to represent the control.  When you construct the control in your program, you pass to the constructor the ID of the resource as its second argument.  The other way is to place the controls dynamically, in which case, you pass the position and size of the control as the third and fourth arguments (the first argument is always the owner and the second argument is always the resource ID).  Even when you place the control dynamically, you pass in a unique ID as the second argument.
      </remarks>
    </member>
    <member name="M:VO.Control.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a control.
      </summary>
      <param name="oOwner">The window that owns the control.</param>
      <param name="xID">The unique ID of the control (between 1 and 8000).</param>
      <param name="oPoint">The origin of the control in canvas coordinates.</param>
      <param name="oDimension">The dimension of the control in canvas coordinates.</param>
      <param name="cRegClass">String representing the control class (for example, 'Edit', 'ListBox', etc.)</param>
      <param name="kStyle">
        Constant representing the style of the control, specified either by a X# style constant or a Windows API style constant.  
        Styles can be combined using the _Or() operator.
      </param>
      <param name="lDataAware">Logical value indicating whether the control is data-aware (TRUE) or not (FALSE).  The default is FALSE.</param>
      <param name="nResourceID">The resource ID of the control.</param>
      <remarks>
        <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular Windows API constant.</note>
        Controls are created in one of two ways: dynamically or from a compiled dialog resource.  Dynamic creation, which requires that size and position be specified as instantiation parameters, can be used on any type of window.  A compiled dialog resource (which specifies both size and location of the control) can be used only with data windows and dialog windows.
        Additionally, the default state when a control is created depends on the way you placed the control:
        With dynamic creation, the control remains invisible until you invoke Control:Show().
        This allows the program to set up the control correctly (with the correct size, position, and any other parameters), while avoiding the "visual noise" of changing controls.
        With resource-bound instantiation, the control is automatically shown, without requiring a call to Control:Show().
      </remarks>
    </member>
    <member name="M:VO.Control.Activate(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the control has focus and a window is activated.<br /><br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oEvent">The event that describes which window was activated.</param>
      <seealso cref="T:VO.Event" />
      <remarks>
        The Activate() event occurs at the start of the control's lifetime or when the control is activated after it has been deactivated (for example, by clicking on it with the mouse).  The newly active control receives the input focus.

        You should create and show cursors (if needed) in this event handler method.
        Any subclass with its own Activate() and Deactivate() event handlers should always call its owner's handlers.  This ensures that the caption bars get highlighted or dimmed accordingly.
      </remarks>
    </member>
    <member name="M:VO.Control.AsString">
      <summary>
        Return the contents of the control (or its identifying label).
      </summary>
      <remarks>
        For controls that have values, such as edit controls and check boxes, this method returns the same as Control:TextValue.  For controls that do not have values, such as push buttons, it returns the same as Control:Caption.  In either case, Control:AsString() presents the control as a recognizable string.
      </remarks>
    </member>
    <member name="P:VO.Control.Background">
      <summary>
        The brush used for painting the background of the control.  For example, in a single line edit control, the background is the color behind the text in the edit control.
      </summary>
      <value>The brush used for painting the background of the control.  For example, in a single line edit control, the background is the color behind the text in the edit control.</value>
      <note type="tip"> This method has no effect if three-dimensional controls have been enabled (via a call to the Enable3DControls() function).</note>
    </member>
    <member name="P:VO.Control.Caption">
      <summary>
        A string representing the caption of the control (i.e., the static text identifying the control)
      </summary>
      <value>A string representing the caption of the control (i.e., the static text identifying the control)</value>
      <remarks>
        A string representing the caption of the control (i.e., the static text identifying the control).  Examples include the label on the face of a button, the text written next to a check box or radio button, or the text on the border of a radio button group or group box.
        Note that not all controls have a visible caption.  For example, the ordinary edit control (MultiLineEdit class) does not have a visible caption — the text commonly displayed next to the edit is actually a separate control, placed there by the Window Editor.  Thus, assigning a new value to the caption of this type of control does not change anything on the screen.
      </remarks>
    </member>
    <member name="P:VO.Control.ContextMenu">
      <summary>
        A menu object representing the local pop-up menu for a control.
      </summary>
      <value>A menu object representing the local pop-up menu for a control.</value>
    </member>
    <member name="P:VO.Control.ControlID">
      <summary>
        A number between 1 and 8000 representing the unique ID of a control
      </summary>
      <value>A number between 1 and 8000 representing the unique ID of a control</value>
      <remarks>
        A number between 1 and 8000 representing the unique ID of a control.  Every control has its own unique ID to distinguish it from other controls (enabling the owner window to determine which control generated an event).
      </remarks>
    </member>
    <member name="M:VO.Control.Create">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Control.DataField">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.Control.Deactivate(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the control has focus and a window is deactivated.<br /><br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oEvent">An empty event required to maintain the protocol that all event handlers have exactly one event as their argument.</param>
      <remarks>
        This event handler is normally invoked when another application, window or control becomes activated.
      </remarks>
      <seealso cref="T:VO.Event" />
    </member>
    <member name="M:VO.Control.Default(XSharp.__Usual)">
      <summary>Call the default windows procedure for a control and set the EventReturnValue.</summary>
      <param name="oEvent">The event that occurred for the control.</param>
      <returns>Nothing</returns>
      <seealso cref="T:VO.Event" />
    </member>
    <member name="M:VO.Control.Destroy">
      <summary>
        Provide a method to de-instantiate any Control object.
      </summary>
      <remarks>
        This method can be used when a Control object is no longer needed.  Control:Destroy() de-instantiates the Control object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.Control.Disable">
      <summary>
        Disable a control (until a subsequent call to Control:Enable()).
      </summary>
      <remarks>
        Disabled controls are not active (for example, push buttons cannot be clicked and data controls cannot be modified) and, therefore, they do not send events to their owner windows.  Note that under Windows, a disabled control is dimmed.
      </remarks>
    </member>
    <member name="M:VO.Control.DisableTheme">
      <summary>
        Disable the WinXP theme for a control.
      </summary>
    </member>
    <member name="M:VO.Control.Dispatch(XSharp.__Usual)">
      <summary>
        Provide the prototype dispatcher for events within the system when the control has focus;  routing various events to their appropriate event handlers.<br /><br />Important!  This is a callback method used by X#.
      </summary>
      <param name="oEvent">The event to be handled.</param>
      <seealso cref="T:VO.Event" />
      <returns>
        A numeric value representing the event handler to handle the event.
      </returns>
      <remarks>
        Controls receive events from the user and the system all of the time.  Each control receives only the events that are relevant to it.  For each event that is generated, two things happen:
        1.	The event is converted to a particular Event object (an ExposeEvent or a MouseEvent, for example) according to the action that triggered the event.
        2.	The appropriate event handler is called, and this typed Event object is passed to it.
        <note type="tip">
          If you want to set a specific return value for the underlying window procedure, you have to change the EventReturnValue variable for the control object.
          If you want to handle other events (for example, timer events), you need to write your own Dispatch() method.
          The following guidelines should be followed when writing a customized Dispatch() method:
          1.	Subclass an event type appropriate to the type of operation for which it is being used.
          2.	Add an event handler function to your derived object.  (This event handler should be called with the event when the event is received.)
          3.	In general, the implementation of this event handler should call Default().  This keeps the same behavior as the base class, but it also allows other classes to provide useful event handlers for your new type of event, allowing you to provide a framework for other classes to use.
          The base class Dispatch() method should be called in those cases where the received event is not handled by the customized dispatcher.  For example:
          <code language="X#">RETURN SUPER:Dispatch(&lt;oEvent&gt;)</code></note></remarks>
    </member>
    <member name="M:VO.Control.Drop(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oDragEvent">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.Control.Enable">
      <summary>
        Enable a control that was previously disabled.
      </summary>
      <remarks>
        Enabling a control allows it to generate events and to send the events to its owner window when the user manipulates the control.  The dimming of disabled controls is removed, and the control is restored to its normal appearance.
        By default, controls are enabled until disabled, so there is no need to call this Enable() method unless Control:Disable() was previously called.
      </remarks>
    </member>
    <member name="F:VO.Control.EventReturnValue">
      <exclude />
    </member>
    <member name="M:VO.Control.Expose(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the control has focus and whenever part of the window needs repainting.<br /><br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oExposeEvent">The ExposeEvent object that describes which control of the window needs repainting.</param>
      <remarks>
        This is one of the most important event handlers.  A control requires repainting when the control:
        <list type="bullet"><item>Is partially uncovered by another window</item><item>Is first shown</item><item>Increases in size</item><item>Is being restored after being iconized</item><item>The control should retain enough information to redraw the screen as it was (or as it should be).</item></list>
        An ExposeEvent is also triggered by calling Repaint() or Update(); you should not call Repaint() or Update() during the Expose().
      </remarks>
    </member>
    <member name="P:VO.Control.FieldSpec">
      <summary>
        The field specification connected to the control.
      </summary>
      <value>The field specification connected to the control.</value>
      <remarks>
        From the field specification, you can retrieve additional information about the control — for example:
        <code language="X#">
          cPicture := oControl:FieldSpec:Picture
          IF !oControl:FieldSpec:Validate(x)
          oHLStatus := oControl:FieldSpec:Status
          ENDIF
        </code></remarks>
    </member>
    <member name="M:VO.Control.FocusChange(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the control has focus and the input focus changes from the current control to another (or vice versa).<br /><br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oFocusChangeEvent">The FocusChangeEvent object that identifies whether the focus is being gained or lost.</param>
    </member>
    <member name="M:VO.Control.GetExStyle">
      <summary>
        Retrieve the Ex styles for the control.
      </summary>
      <returns>
        Numeric value representing the X# style constants or Windows API style constants enabled for the window.
      </returns>
    </member>
    <member name="M:VO.Control.GetStyle">
      <summary>
        Retrieve the styles for the control.
      </summary>
      <returns>
        Numeric value representing the X# style constants or Windows API style constants enabled for the window.
      </returns>
    </member>
    <member name="M:VO.Control.Handle(XSharp.__Usual)">
      <summary>
        Return the handle for a control.
      </summary>
      <param name="uType">The type of handle required.  Zero (0) is the only supported option, and it is the default if &lt;nHandleType&gt; is omitted.</param>
      <returns>
        A handle to the "window" (control), describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the window, which can then be used by Windows API calls.
      </remarks>
    </member>
    <member name="M:VO.Control.HandleAsDword">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.Control.HasBorder">
      <summary>Check if a border  has been set for the control</summary>
      <returns>TRUE when the border is set. Otherwise FALSE.</returns>
    </member>
    <member name="M:VO.Control.HasStyle(System.Int32)">
      <summary>Check if a style value has been set for the control</summary>
      <param name="kStyle">The style to check for</param>
      <returns>TRUE when the style is set. Otherwise FALSE.</returns>
    </member>
    <member name="M:VO.Control.Hide">
      <summary>
        Hide a control so it is not visible (until a subsequent call to Control:Show()).
      </summary>
    </member>
    <member name="M:VO.Control.HorizontalScroll(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the control has focus and a horizontal scroll bar is scrolled.<br /><br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oScrollEvent">The ScrollEvent object that describes the scroll type and new position.</param>
      <remarks>
        The default behavior for this event handler is to update the thumb position; this can be changed using your own implementation of the handler.  This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects.  If the application has vertical scroll bars, use a WindowVerticalScrollBar event handler.
      </remarks>
    </member>
    <member name="P:VO.Control.HyperLabel">
      <summary>
        The hyperlabel connected to the control.
      </summary>
      <value>The hyperlabel connected to the control.</value>
      <remarks>
        From the hyperlabel, you can retrieve additional information about the control — for example:
        <code language="X#">
          cCaption := oControl:HyperLabel:Caption
          cDescription := oControl:HyperLabel:Description
          cHelpContext := oControl:HyperLabel:HelpContext
        </code></remarks>
    </member>
    <member name="P:VO.Control.IsDestroyed">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Control.IsDisabled">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Control.IsEditable">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.Control.IsEnabled">
      <summary>
        Report if this control is currently enabled.
      </summary>
      <returns>
        TRUE if the control is enabled; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.Control.IsExStyle(System.Int32)">
      <summary>Check if a exstyle value has been set for the control</summary>
      <param name="nStyle">The exstyle to check for</param>
      <returns>TRUE when the exstyle is set. Otherwise FALSE.</returns>
    </member>
    <member name="M:VO.Control.IsReadOnly">
      <summary>
        Report if this control is currently readonly.
      </summary>
      <returns>
        TRUE if the control is readonly; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.Control.IsStyle(System.Int32)">
      <summary>Check if a style value has been set for the control</summary>
      <param name="nStyle">The style to check for</param>
      <returns>TRUE when the style is set. Otherwise FALSE.</returns>
    </member>
    <member name="M:VO.Control.IsVisible">
      <summary>
        Report if this control is visible (completely or partially) or hidden.
      </summary>
      <returns>
        TRUE if the control is visible; otherwise, FALSE.
      </returns>
      <remarks>
        This style is set in the Windows Editor.
      </remarks>
    </member>
    <member name="M:VO.Control.KeyDown(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the control has focus and a key on the keyboard is pressed.<br /><br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oKeyEvent">The KeyEvent object that describes what key was pressed.</param>
      <remarks>
        This event handler is called only if the control has the input focus.
      </remarks>
    </member>
    <member name="M:VO.Control.KeyUp(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the control has focus and a key on the keyboard is released.<br /><br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oKeyEvent">The KeyEvent object that describes what key was released.</param>
      <remarks>
        This event handler is called only if the control has the input focus.
      </remarks>
    </member>
    <member name="M:VO.Control.LinkDF(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Connect a control to a data field in a data server.
      </summary>
      <param name="oDS">The server that the field is to be linked to.  Ordinarily, this is the common server that the entire window is linked to, but it is possible to link individual fields to other servers. </param>
      <param name="siDF">The number of the data field within the server.</param>
      <remarks>
        Control:LinkDF() should ordinarily not be called directly by the application.  It is called by the DataWindow:Use() method; Use() connects an entire client to an entire server. You can use Control:LinkDF() to link a control to a data field explicitly, perhaps if the control's name doesn't match the data field's name so the automatic linkage of the Use() method doesn't work.
        It is even possible to use Control:LinkDF() to link individual controls to different servers; however, this is not recommended, because none of the automatic behavior of the data window and none of its cooperation with the data server applies to more than one server.  Notifications are not to be received for servers other than the main server that the window is registered with, and actions such as DataWindow:Delete() and DataWindow:Append() apply to the main server.  To link a window to more than one database, use the techniques described in the "GUI Classes" chapter of the Programmer's Guide.
      </remarks>
    </member>
    <member name="M:VO.Control.MenuInit(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a pop-up menu owned by the control is about to pop up.
      </summary>
      <param name="oMenuInitEvent">The MenuInitEvent object that describes which menu is about to pop up.</param>
    </member>
    <member name="M:VO.Control.MenuSelect(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when an item on a menu owned by the control is highlighted.
      </summary>
      <param name="oMenuSelectEvent">The MenuSelectEvent object that describes which menu and menu command (via the item's ID) generated the event.</param>
    </member>
    <member name="P:VO.Control.Modified">
      <summary>
        A logical value that is set to TRUE when a standard edit control or editable combo box is in the process of being modified.
      </summary>
      <value>A logical value that is set to TRUE when a standard edit control or editable combo box is in the process of being modified.</value>
      <remarks>
        A logical value that is set to TRUE when a standard edit control or editable combo box is in the process of being modified.  When the editing is completed and focus shifts to another control, Control:Modified is reset to FALSE.  Control:Modified is initialized to FALSE when the control is created.
      </remarks>
    </member>
    <member name="M:VO.Control.MouseButtonDoubleClick(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the control has focus, the mouse pointer is positioned over the window, and a mouse button is double-clicked.<br /><br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oMouseEvent">The MouseEvent object that contains information about the state of the mouse when the button was double-clicked.</param>
      <remarks>
        MouseButtonDoubleClick() often occurs between MouseButtonDown() and MouseButtonUp() event handlers.
      </remarks>
    </member>
    <member name="M:VO.Control.MouseButtonDown(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the control has focus, the mouse pointer is positioned over the window, and a mouse button is clicked.<br /><br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oMouseEvent">The MouseEvent object that contains information about the state of the mouse when the button was clicked.</param>
    </member>
    <member name="M:VO.Control.MouseButtonUp(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the control has focus, the mouse pointer is positioned over the window, and a mouse button is released.<br /><br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oMouseEvent">The MouseEvent object that contains information about the state of the mouse when the button was released.</param>
      <remarks>
        Do not assume Control:MouseButtonUp() is called immediately after Control:MouseButtonDown().  Other MouseEvents can be generated during this time.
        In some cases, there may be no Control:MouseButtonUp() events directed to the window for a corresponding Control:MouseButtonDown().  This can occur if the mouse button is clicked while over the window, but released after the mouse has moved off the window.
      </remarks>
    </member>
    <member name="M:VO.Control.MouseDrag(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the control has focus and a mouse with one or more buttons clicked is moved in the window.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oMouseEvent">The MouseEvent object containing information on the location and state of the buttons when the mouse was dragged.</param>
    </member>
    <member name="M:VO.Control.MouseMove(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the control has focus and the mouse is moved in the control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oMouseEvent">The MouseEvent object containing information on the location of the mouse when it was moved.</param>
      <remarks>
        This event occurs when the mouse is moved with no mouse buttons clicked.
      </remarks>
    </member>
    <member name="M:VO.Control.Move(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the control has focus and the control is moved (either by the user or by the application).
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oMoveEvent">The MoveEvent object that describes the window movement.</param>
    </member>
    <member name="P:VO.Control.Name">
      <summary>
        A string representing the name of the control.
      </summary>
      <value>A string representing the name of the control.</value>
      <remarks>
        A string representing the name of the control.  Do not confuse the name with the caption: the name is a programmer's ID and is never seen by the user.
        The name is important in steering the built-in processing of the system.  For example, the name of a push button is the name of the method that is invoked when the button is clicked, and the name of a control is the database field to which it is linked when a data window is linked to a data server.
      </remarks>
    </member>
    <member name="P:VO.Control.NameSym">
      <summary>
        A symbol representing the name of the control.
      </summary>
      <value>A symbol representing the name of the control.</value>
      <remarks>
        A symbol representing the name of the control.  Do not confuse the name with the caption: the name is a programmer's ID and is never seen by the user.
        The name is important in steering the built-in processing of the system.  For example, the name of a push button is the name of the method that is invoked when the button is clicked, and the name of a control is the database field to which it is linked when a data window is linked to a data server.
      </remarks>
    </member>
    <member name="P:VO.Control.Origin">
      <summary>
        A point representing the location of a control on its owner window, in canvas coordinates.
      </summary>
      <value>A point representing the location of a control on its owner window, in canvas coordinates.</value>
    </member>
    <member name="M:VO.Control.OverRide(XSharp.__Usual)">
      <summary>This is a compatibility method that is no longer used or needed.</summary>
      <param name="lEnable"></param>
    </member>
    <member name="P:VO.Control.Owner">
      <summary>
        The owner window of a control.
      </summary>
      <value>The owner window of a control.</value>
    </member>
    <member name="P:VO.Control.OwnerAlignment">
      <summary>
        Constant representing how the window will be aligned within its owner window.

      </summary>
      <value>Constant representing how the window will be aligned within its owner window.</value>
      <remarks>
        <para>If a value has been set for this property, any resizing of the owner</para>
        <para>window will cause the window to be automatically realigned, resized, and/or moved accordingly.</para>
        <para>
          <b>Note:</b>By default (or by setting OwnerAlignment to &lt;Auto&gt; in the Window Editor), a control will appear where it was placed by the programmer and
          will not be realigned, resized, and/or moved when its owner window is resized.
        </para>
        <para>There are two assigns that aid owner alignment:</para>
        <list type="bullet">
          <item>
            Control:OwnerAlignment  for controls
          </item>
          <item>
            Window:OwnerAlignment  for windows
          </item>
        </list>
        <para>
          Whenever one of these assigns is called, the current size and position of the control or window is saved to an internal array. The assign can be called as
          often as is required without any difficulty and it will simply over right the old values.
        </para>
        <para>Starting with build 2824 this property can take two different forms:</para>
        <list type="bullet">
          <item>proportional mode</item>
          <item>linear mode</item>
        </list>
        <h2>Proportional OwnerAlignment</h2>
        <para>
          With <b>proportional mode</b> you use the OA_ defines to specify how the position and size of the controls should change
          when the size of the window changes. For example:
        </para>
        <para>
          With linear mode you do not use predefines OA_ defines but you specify the amount of change for each of the 4 properties of a control in code:
        </para>
        <list type="bullet">
          <item>The X position</item>
          <item>The Y position</item>
          <item>The Width</item>
          <item>The Height</item>
        </list>
      </remarks>
    </member>
    <member name="M:VO.Control.PerformValidations">
      <summary>
        Perform all the validations defined to this control's field specification (for example, required, maximum and minimum digits, maximum and minimum value, validation rule) and return the result of the test.
      </summary>
      <returns>
        If any of the validations fail, this method sets the status of the control appropriately and returns FALSE.  Otherwise, it returns TRUE.
      </returns>
    </member>
    <member name="P:VO.Control.ReadOnly">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.Control.RegisterTimer(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Register a timer method to be invoked for the control.
      </summary>
      <param name="nInterval">Time interval, in seconds, between calls to the Timer() method of the control.</param>
      <param name="lOneTime">
        Logical value indicating if the timer is called just once (TRUE), or multiple times (FALSE).  
        If omitted, the default is FALSE.
      </param>
    </member>
    <member name="M:VO.Control.RePaint">
      <summary>
        Send an ExposeEvent to repaint the control
      </summary>
    </member>
    <member name="M:VO.Control.Resize(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the control has focus and the control changes size.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oResizeEvent">The ResizeEvent object that describes the new dimensions of the control.</param>
      <remarks>
        In the Control:Resize() event handler, calling Window:Size should be used with caution to avoid entering an infinite loop.
      </remarks>
    </member>
    <member name="M:VO.Control.RestoreUpdate">
      <summary>
        Resume all drawing updates for a control (after Control:SuspendUpdate() is called).
      </summary>
      <remarks>
        This method resumes all drawing updates for a control (after Control:SuspendUpdate() is called).
      </remarks>
    </member>
    <member name="P:VO.Control.Server">
      <summary>
        The server object that currently connected to this control.  If no server is connected, the value is NIL.
      </summary>
      <value>The server object that currently connected to this control.  If no server is connected, the value is NIL.</value>
    </member>
    <member name="M:VO.Control.SetExStyle(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the exstyle for the control.
      </summary>
      <param name="kExStyle">The exstyle of the control, specified by a either a X# style constant or a Windows API style constant.</param>
      <param name="lEnable">TRUE enables the specified style; FALSE disables it.  If omitted, the default is TRUE.</param>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Control.SetFocus">
      <summary>
        Pass input focus to a control, thereby directing all mouse and keyboard input to the control.
      </summary>
    </member>
    <member name="M:VO.Control.SetParent(System.Void*)">
      <summary>
        Change the parent handle for the control.
      </summary>
      <param name="hWndNewParent">The new parent handle for the control.</param>
    </member>
    <member name="M:VO.Control.SetStyle(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the style for the control.
      </summary>
      <param name="kStyle">The style of the control, specified by a either a X# style constant or a Windows API style constant.</param>
      <param name="lEnable">TRUE enables the specified style; FALSE disables it.  If omitted, the default is TRUE.</param>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Control.Show">
      <summary>
        Display a control so it is visible.
      </summary>
      <remarks>
        The default state when a control is created depends on the way you placed the control:
        With dynamic creation, the control remains invisible until you invoke Control:Show().
        This allows the program to set up the control correctly (with the correct size, position,
        and any other parameters), while avoiding the "visual noise" of changing controls.
        With resource-bound instantiation, the control is automatically shown, without requiring a call to Control:Show().
        Control:Show() is also usually called to redisplay a control that was hidden with the Control:Hide() method.
      </remarks>
    </member>
    <member name="P:VO.Control.Size">
      <summary>
        A dimension representing the size of a control.
      </summary>
      <value>A dimension representing the size of a control.</value>
    </member>
    <member name="P:VO.Control.Status">
      <summary>
        A hyperlabel indicating the status of the control after a validation attempt or other action.
      </summary>
      <value>A hyperlabel indicating the status of the control after a validation attempt or other action.</value>
      <remarks>
        If the validation passed or the operation was successful, this value is NULL_OBJECT; if not, it contains information about the failure, which can be retrieved and displayed — for example:
        <code language="X#">
          IF !oControl:FieldSpec:Validate(x)
          WarningBox{SELF, oControl:Status:Caption,;
          oControl:Status:Description}:Show()
          ENDIF
        </code>
        Hyperlabels are commonly used in the system, and in this case, the warning box is capable of accepting a hyperlabel and extracting the relevant information from it.  Thus, this example can be simplified even further:
        <code language="X#">
          IF !oControl:FieldSpec:Validate(x)
          WarningBox{SELF,oControl:Status}:Show()
          ENDIF
        </code></remarks>
    </member>
    <member name="P:VO.Control.Style">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.Control.SuspendUpdate">
      <summary>
        Temporarily suspend all drawing updates for a control; drawing resumes with a call to Control:RestoreUpdate().
      </summary>
      <remarks>
        This method suspends all drawing updates for a control.  It is especially useful for TreeView and ListView controls, where you typically want to suspend drawing while the ListView or TreeView control is filled.
      </remarks>
    </member>
    <member name="P:VO.Control.TextValue">
      <summary>
        A string representing the value held in the control.
      </summary>
      <value>A string representing the value held in the control.</value>
      <remarks>
        For example, in a standard edit control, the value can be "Jones" or "$14,683.00".  In a check box, the value can be "TRUE" or "FALSE".  For push buttons, Control:TextValue is set to NULL_STRING.  In a list box or combo box, Control:TextValue holds the display value text.  In a radio button group, Control:TextValue holds the caption text of the radio button that is currently selected.
        Note that the string is formatted according to the picture clause held in the field specification of the control; in turn, controls linked to a data server inherit the field specification - and hence picture clause - from the field of the server.
      </remarks>
      <example>
        The following examples demonstrate the use of the Control:TextValue property:
        <code language="X#">
          // Prints "C" for character string
          ?ValType(oDCAmountControl:TextValue)
          // Access the control (string value)
          cAmount := oDCAmountControl:TextValue
          // Assign "5" to the control
          oDCAmountControl:TextValue := "5"
        </code></example>
    </member>
    <member name="M:VO.Control.Timer">
      <summary>
        Provide a method to be invoked at specific intervals defined when the timer is registered though the RegisterTimer() method.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
    </member>
    <member name="P:VO.Control.ToolTipText">
      <summary>
        String value representing the tooltip text used when the user moves the mouse pointer over the control.
      </summary>
      <value>String value representing the tooltip text used when the user moves the mouse pointer over the control.</value>
      <remarks>
        String value representing the tooltip text used when the user moves the mouse pointer over the control.
        <note type="tip">Tooltips are not supported for static controls, such as fixed text, group boxes, etc.</note></remarks>
    </member>
    <member name="P:VO.Control.UseHLForToolTip">
      <summary>
        Logical value determining whether the descriptive text of a control's Hyperlabel should be used as the tooltip text.
      </summary>
      <value>Logical value determining whether the descriptive text of a control's Hyperlabel should be used as the tooltip text.</value>
      <remarks>
        Logical value determining whether the descriptive text of a control's Hyperlabel should be used as the tooltip text.
        <note type="tip">Any ToolTipText setting will override UseHLForToolTip.</note></remarks>
    </member>
    <member name="M:VO.Control.ValidateControl">
      <summary>This method validates if the control has been created and when not then it triggers the control creation</summary>
      <returns>TRUE when the controls was succesfully created. Otherwise FALSE.</returns>
    </member>
    <member name="P:VO.Control.Value">
      <summary>
        The value held in the control, in whatever data type the control holds.
      </summary>
      <value>The value held in the control, in whatever data type the control holds.</value>
      <remarks>
        The value held in the control, in whatever data type the control holds.  Control:Value is thus of the usual data type.  For example, in a regular edit control, the value can be the string "Jones" or the number 14683.  In a check box, Control:Value can be TRUE or FALSE.  In a list box or combo box, the Control:Value is generally one of the return values (unless the control is bound to a field where the actual contents is not one of the allowable choices).  In a radio button group, Control:Value holds the group value (specified in the Window Editor) of the radio button that is currently selected;  if none is selected, Control:Value is set to NIL.
        The data type of the control's Value is determined by its field specification; in turn, controls linked to a data server inherit the field specification — and hence data type — from the field of the server.  When the control is made data-aware, by setting its name to the name of a field in the server attached to the data window, Control:Value is able to automatically read from and write to this field.
        <note type="tip">Value may not always be consistent with the state of the control, as indicated to the end-user.  For example, if the data value for the field is not one of the allowed choices for a list box or combo box return value, or among the group value settings for the radio buttons in a radio button group, the control will be in a "no-match" situation.  In this case the control will revert to its initial unselected state.</note></remarks>
      <example>
        The following examples demonstrate the use of the Control:Value property:
        <code language="X#">
          // Prints "N" for numeric
          ?ValType(oDCAmountControl:Value)
          // Access the control (numeric value)
          nAmount := oDCAmountControl:Value
          // Assign 5 to the control
          oDCAmountControl:Value := 5
        </code></example>
    </member>
    <member name="P:VO.Control.ValueChanged">
      <summary>
        A logical value representing whether the control's Value has been changed from its prior setting.
      </summary>
      <value>A logical value representing whether the control's Value has been changed from its prior setting.</value>
      <remarks>
        A logical value representing whether the control's Value has been changed from its prior setting.  TRUE indicates that it has been changed from its prior setting, while FALSE indicates it has not.  The Control:ValueChanged access is especially useful when the control is bound to a field in a server, since it is reset to FALSE each time you move to a new record.  It is set to TRUE if you have changed from the original data value.
      </remarks>
    </member>
    <member name="M:VO.Control.VerticalScroll(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the control has focus and a vertical scroll bar is scrolled.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oScrollEvent">The ScrollEvent object that describes the scroll type and new position.</param>
      <remarks>
        The default behavior for this event handler is to update the thumb position; this can be changed using your own implementation of the handler.  This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects.  If the application has horizontal scroll bars, use a HorizontalScrollBar event handler.
      </remarks>
    </member>
    <member name="T:VO.ControlEvent">
      <summary>
        Provide information about a control that generated a control event.
      </summary>
      <remarks>
        ControlEvent events are generated when the user operates the Button, Edit, and ListBox (and their respective subclasses) types of controls.

      </remarks>
    </member>
    <member name="M:VO.ControlEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ControlEvent.Control">
      <summary>
        The control that generated this control event.
      </summary>
      <value>The control that generated this control event.</value>
      <remarks>
        The control that generated this control event.
        <note type="tip">If the control that generated the control event was not created as a system control, this value is NIL.  This can happen if a dialog window was specified in the resource entity, but was not registered in the system (that is, the window is not part of the DialogWindow class).</note></remarks>
    </member>
    <member name="P:VO.ControlEvent.ControlID">
      <summary>
        A number between 1 and 8000 representing the unique ID of the control that generated this control event.
      </summary>
      <value>A number between 1 and 8000 representing the unique ID of the control that generated this control event.</value>
      <remarks>
        A number between 1 and 8000 representing the unique ID of the control that generated this control event.  Every control has its own unique ID to distinguish it from other controls (enabling the owner window to determine which control generated an event).
      </remarks>
    </member>
    <member name="P:VO.ControlEvent.Description">
      <summary>
        A string representing the description of the control that generated this control event.
      </summary>
      <value>A string representing the description of the control that generated this control event.</value>
      <remarks>
        A string representing the description of the control that generated this control event.  The description is contained in the control's hyperlabel.  This value is a NULL_STRING if the control has no description.
      </remarks>
    </member>
    <member name="P:VO.ControlEvent.HelpContext">
      <summary>
        A string representing the help context ID of the control that generated this control event.
      </summary>
      <value>A string representing the help context ID of the control that generated this control event.</value>
      <remarks>
        A string representing the help context ID of the control that generated this control event.  This ID is contained in the control's hyperlabel.
        <note type="tip">A help context ID indicates the place in the hypertext system where the system looks for help concerning this control.</note></remarks>
    </member>
    <member name="P:VO.ControlEvent.HyperLabel">
      <summary>
        The hyperlabel connected to the control event.
      </summary>
      <value>The hyperlabel connected to the control event.</value>
      <remarks>
        The hyperlabel connected to the control event.  From the hyperlabel, you can retrieve additional information about the control event — for example:
        <code language="X#">
          cCaption := oControlEvent:HyperLabel:Caption
          cDescription := oControlEvent:HyperLabel:Description
          cHelpContext := oControlEvent:HyperLabel:HelpContext
        </code></remarks>
    </member>
    <member name="P:VO.ControlEvent.Name">
      <summary>
        A string representing the name of the control that generated the event.
      </summary>
      <value>A string representing the name of the control that generated the event.</value>
      <remarks>
        A string representing the name of the control that generated the event.  Do not confuse the name with the caption: the name is a programmer's ID and is never seen by the user.
      </remarks>
    </member>
    <member name="P:VO.ControlEvent.NameSym">
      <summary>
        A symbol representing the name of the control that generated the event.
      </summary>
      <value>A symbol representing the name of the control that generated the event.</value>
      <remarks>
        A symbol representing the name of the control that generated the event.  Do not confuse the name with the caption: the name is a programmer's ID and is never seen by the user.
      </remarks>
    </member>
    <member name="T:VO.ControlFocusChangeEvent">
      <summary>
        Provide information about an ControlFocusChangeEvent, generated when a control gains or loses the keyboard focus.
      </summary>
    </member>
    <member name="M:VO.ControlFocusChangeEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ControlFocusChangeEvent.Control">
      <summary>
        The control that generated this control event.
      </summary>
      <value>The control that generated this control event.</value>
      <remarks>
        The control that generated this control event.
        <note type="tip">If the control that generated the control event was not created as a system control, this value is NIL.  This can happen if a dialog window was specified in the resource entity, but was not registered in the system (that is, the window is not part of the DialogWindow class).</note></remarks>
    </member>
    <member name="T:VO.ControlNotifyEvent">
      <summary>
        Provide information about a control notification event, which is generated when a control is required to notify its parent window of an event.
      </summary>
      <remarks>
        Many controls generate notification events, which are sent to their parent window so that the parent window can take some action.  The notification is sent to the parent in the form of the ControlNotify event handler.  This event is often subclassed so that a control can send an event object that is specific to the control and the notification.  In this case, a more specific event handler in the parent is called as well.

      </remarks>
    </member>
    <member name="M:VO.ControlNotifyEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ControlNotifyEvent.Control">
      <summary>
        The Control object that generated this event.
      </summary>
      <value>The Control object that generated this event.</value>
    </member>
    <member name="P:VO.ControlNotifyEvent.NotifyCode">
      <summary>
        The notification code for this event as defined by the Windows API.
      </summary>
      <value>The notification code for this event as defined by the Windows API.</value>
      <remarks>
        The notification code for this event as defined by the Windows API.  The value of the notification code depends on the type of control and the event.  Refer to your Microsoft Win32 Software Development Kit documentation for more details.
        <note type="tip">
          The ControlNotifyEvent:NotifyCode access returns a DWORD variable.
          NotifyCode Values in the Windows SDK are usually defines as:
          <code language="X#">
            DEFINE TVN_KEYDOWN             := (TVN_FIRST-12)
            DEFINE TVN_FIRST               := (0U-400U)
          </code>
          In prior versions of X# TVN_KEYDOWN compiled to a LONG with value -412. Most other development environments treat defines like these as DWORD (unsigned) because the TVN_FIRST has one or more unsigned constants in its definition.
          Unfortunately there is a small problem in X#:
          USUAL variables can only contain LONG or FLOAT numerics and not DWORDS.
          This means that if you call ControlNotifyEvent:NotifyCode late bound you will receive a USUAL and therefore a LONG.
          So in case the NotifyCode is TVN_KEYDOWN, then the USUAL will have a LONG value of -412.
          We therefore strongly advise to store Event objects in a type local. This ensures that you will get the correct numeric type:
          <code language="X#">
            METHOD ControlNotify(oControlNotifyEvent) CLASS HelpAbout
              LOCAL oControl AS Control
              LOCAL oCNEvent AS ControlNotifyEvent
              oCNEvent := oControlNotifyEvent
              oControl := IIF(oCNEvent == NULL_OBJECT, NULL_OBJECT, oCNEvent:Control)
              SUPER:ControlNotify(oControlEvent)
              IF oCNEvent:NotifyCode == TVN_KEYDOWN
                 // Do what you want to do
              ENDIF
              RETURN NIL
          </code></note></remarks>
    </member>
    <member name="T:VO.ControlWindow">
      <summary>
        Create a control as part of the Window hierarchy, thereby allowing the behavior of the control to be customized using event handlers.
      </summary>
      <remarks>
        When a control is created as part of the Window hierarchy, it can trap events.  For example, you might want to customize the appearance of controls (like changing the background and foreground colors) or modify their default key handling.
        Manipulating a control via the ControlWindow class requires more overhead than those created by the subclasses of Control.  Therefore, it is recommended that control windows be used only where special handling is needed (for example, to override the handling of certain events or call some window method on a control).
      </remarks>
    </member>
    <member name="M:VO.ControlWindow.#ctor(XSharp.__Usual)">
      <summary>
        Construct a control window from an existing control.
      </summary>
      <param name="oControl">The control that should be used to initialize the control window.  It should be an instance of any subclass of Control.</param>
      <remarks>
        The control used to initialize the control window is automatically destroyed when the control window is destroyed.
      </remarks>
      <example>
        The following example constructs a control window with the same properties as a push button:
        <code language="X#">
          CLASS PbWindow INHERIT ControlWindow
          METHOD Init(oWOwner,nResourceID) CLASS PbWindow
            LOCAL oPB AS OBJECT
            oPB := PushButton{oOwner,nResourceID}
            SUPER:Init(oPB)
        </code></example>
    </member>
    <member name="P:VO.ControlWindow.Control">
      <summary>
        The control on which the control window is based.
      </summary>
      <value>The control on which the control window is based.</value>
      <remarks>
        The control on which the control window is based.  This information allows you to use the control window's inherited methods, so that you can use its built-in services.
      </remarks>
    </member>
    <member name="P:VO.ControlWindow.ControlID">
      <summary>
        A number between 1 and 8000 representing the unique ID of the control on which the control window is based.
      </summary>
      <value>A number between 1 and 8000 representing the unique ID of the control on which the control window is based.</value>
      <remarks>
        A number between 1 and 8000 representing the unique ID of the control on which the control window is based.  Every control has its own unique ID to distinguish it from other controls (enabling the owner window to determine which control generated an event).
      </remarks>
    </member>
    <member name="M:VO.ControlWindow.Default(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.ControlWindow.Destroy">
      <summary>
        Free memory resources allocated for a ControlWindow object and its derived objects.
      </summary>
      <remarks>
        This method immediately frees resources for ControlWindow objects created explicitly in your application.  ControlWindow:Destroy() also takes care of resources allocated to derived classes and deallocates them in the necessary order.
      </remarks>
    </member>
    <member name="M:VO.ControlWindow.Disable">
      <summary>
        Disable a control window, including its associated control (until a subsequent call to ControlWindow:Enable()).
      </summary>
      <remarks>
        Disabled controls are not active (for example, push buttons cannot be clicked and data controls cannot be modified) and, therefore, they do not send events to their owner windows.  Note that under Windows, a disabled control is dimmed.
      </remarks>
    </member>
    <member name="M:VO.ControlWindow.Dispatch(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.ControlWindow.Enable">
      <summary>
        Enable a control window that was previously disabled.
      </summary>
      <remarks>
        Enabling a control window allows it to generate events and to send the events to its owner window when the user manipulates the control window.  The dimming of disabled control windows is removed, and the control window is restored to its normal appearance.
        By default, control windows are enabled until disabled, so there is no need to call this Enable() method unless ControlWindow:Disable() was previously called.
      </remarks>
    </member>
    <member name="M:VO.ControlWindow.Hide">
      <summary>
        Hide a control window and its associated control so it is not visible (until a subsequent call to ControlWindow:Show()).
      </summary>
    </member>
    <member name="P:VO.ControlWindow.HyperLabel">
      <summary>
        The hyperlabel connected to the control on which the control window is based.
      </summary>
      <value>The hyperlabel connected to the control on which the control window is based.</value>
      <remarks>
        The hyperlabel connected to the control on which the control window is based.  From the hyperlabel, you can retrieve additional information about the control:
      </remarks>
      <example>
        <code language="X#">
          cCaption := oControlWindow:HyperLabel:Caption
          cDescription := oControlWindow:HyperLabel:Description
          cHelpContext := oControlWindow:HyperLabel:HelpContext
        </code>
      </example>
    </member>
    <member name="P:VO.ControlWindow.Modified">
      <summary>
        A logical value indicating whether the control on which the control window is based has been changed by the user since it was last set.
      </summary>
      <value>A logical value indicating whether the control on which the control window is based has been changed by the user since it was last set.</value>
      <remarks>
        A logical value indicating whether the control on which the control window is based has been changed by the user since it was last set.  TRUE indicates that the control has changed (even if it has not yet been validated or has failed validation); FALSE indicates that it has not.
      </remarks>
    </member>
    <member name="P:VO.ControlWindow.Origin">
      <summary>
        A point representing the position of a control window on its owner window, in canvas coordinates.
      </summary>
      <value>A point representing the position of a control window on its owner window, in canvas coordinates.</value>
    </member>
    <member name="M:VO.ControlWindow.Override">
      <summary>This is a compatibility method that is no longer used or needed.</summary>
    </member>
    <member name="M:VO.ControlWindow.SetFocus">
      <summary>
        Pass input focus to a control window, thereby directing all mouse and keyboard input to its associated control.
      </summary>
    </member>
    <member name="P:VO.ControlWindow.Size">
      <summary>
        A dimension representing the size of a control window.
      </summary>
      <value>A dimension representing the size of a control window.</value>
    </member>
    <member name="T:VO.CPop">
      <summary>
        Provide a class for Internet Post Office Protocol (POP).
      </summary>
      <remarks>
        This class provides all necessary methods and properties for checking and receiving e-mail from an Internet POP Server.
      </remarks>
    </member>
    <member name="M:VO.CPop.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a CPop object.
      </summary>
      <param name="cServer">String containing the host name of a valid POP server.  Alternately, the string can contain the IP number of the POP server in ASCII dotted-decimal format (for example, 11.22.3.45).</param>
      <param name="cUserName">The user ID.</param>
      <param name="cPassword">The user's password.</param>
      <param name="nPort">** missing parameter documentation **</param>
      <param name="oEMailStorage">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CPop.CheckReply">
      <summary>
        Check the response from a POP server for error codes.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method checks the response string from the POP server for error codes, and sets the ReplyCode, ReplyString and Error properties.
      </remarks>
    </member>
    <member name="M:VO.CPop.connect(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Establish a connection to the remote POP server.
      </summary>
      <param name="cIP">String containing the host name of an Internet server.  Alternately, the string can contain the IP number of the POP server in ASCII dotted-decimal format (for example, 11.22.3.45).</param>
      <param name="n">Port number at &lt;cHostNameOrIP&gt;.  If not specified, the connection will be established to port SELF:RemotePort.  The default value is IPPORT_POP (110).</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method establishes a connection to the specified remote mail server at port &lt;nPort&gt; or SELF:RemotePort.
      </remarks>
    </member>
    <member name="M:VO.CPop.DeleteMail(XSharp.__Usual)">
      <summary>
        Delete specified mail from a remote POP server.
      </summary>
      <param name="nMail">The number of the e-mail message to be deleted from the queue.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method removes the specified e-mail message from a remote POP server.
      </remarks>
      <example>
        The following function collects all waiting e-mail messages and deletes them from the remote POP server:
        <code language="X#">
          FUNC POPGetMails (cServerIP  AS STRING,;
          cUser      AS STRING,;
          cPassW     AS STRING,;
          lDelete    AS LOGIC ) AS ARRAY ;
          PASCAL
          LOCAL oPop  AS CPop
          LOCAL aRet  AS ARRAY
          LOCAL i,n   AS INT
          oPop := CPop{cServerIP}
          IF oPop:Logon(cUser, cPassW)
          oPop:GetStatus()
          n    := oPop:MailCount
          aRet := oPop:ListMail()
          IF lDelete
          // Deleting all messages
          FOR i := 1 TO n
          oPop:DeleteMail(i)
          NEXT
          ENDIF
          ENDIF
          oPop:Disconnect()
          RETURN aRet
        </code></example>
    </member>
    <member name="M:VO.CPop.Disconnect">
      <summary>
        Shut down the current POP connection.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method can be used to close the connection to a POP3 Server.
      </remarks>
      <example>
        See the CPop:DeleteMail() example.
      </example>
    </member>
    <member name="P:VO.CPop.Email">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CPop.GetList(XSharp.__Usual)">
      <summary>
        Method to return an array of information regarding a particular email waiting on the server.
      </summary>
      <param name="nMail">The number of the email being investigated</param>
      <returns>
        ARRAY of strings representing the date, time, sender name and subject for that email.
        {cDate, cTime, cSender, cSubject}
      </returns>
      <remarks>
        This method consults the server and returns information about emails waiting to be downloaded. The user can then make decisions about which mails to download or delete.
      </remarks>
    </member>
    <member name="M:VO.CPop.GetListIDs(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="nMail">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CPop.GetMail(XSharp.__Usual)">
      <summary>
        Read specified mail from a remote POP server.
      </summary>
      <param name="nMail">The number of the e-mail message to be read from the queue.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method reads the specified e-mail message from a remote POP server and decodes it into its MailHeader, MailBody, and Attachment parts.
      </remarks>
      <example>
        The following function reads the specified e-mail messages from a remote POP server:
        <code language="X#">
          FUNC POPReadMail (cServerIP  AS STRING,;
          cUser      AS STRING,;
          cPassW     AS STRING,;
          nMail      AS INT ) AS ARRAY ;
          PASCAL
          LOCAL oPop  AS CPop
          LOCAL aRet  AS ARRAY
          LOCAL n     AS INT
          oPop := CPop{cServerIP}
          IF oPop:Logon(cUser, cPassW)
          oPop:GetStatus()
          n    := oPop:MailCount
          IF nMail &lt;= n
          IF oPop:GetMail(nMail)
          aRet := ArrayCreate(3)
          aRet[1] := oPop:MailHeader
          aRet[2] := oPop:MailBody
          aRet[3] := oPop:Attachment
          ENDIF
          ENDIF
          ENDIF
          oPop:Disconnect()
          RETURN aRet
        </code></example>
    </member>
    <member name="M:VO.CPop.GetMailTop(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="nMail">** missing parameter documentation **</param>
      <param name="nBodyLines">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CPop.GetStatus">
      <summary>
        Retrieve the mail status for the current active user from a remote POP server.
      </summary>
      <returns>
        A string containing the current status.
      </returns>
      <remarks>
        This method asks for the status for the current active user, who must be logged on, and saves the results to the MailHeader, MailCount, and TotalBytes properties.
      </remarks>
      <example>
        See the CPop:DeleteMail() example.
      </example>
    </member>
    <member name="M:VO.CPop.ListMail">
      <summary>
        Read all e-mails from a remote POP server.
      </summary>
      <returns>
        Array with all e-mails, if successful; otherwise, an empty array.
      </returns>
      <remarks>
        This method reads all e-mails from a remote POP server and puts them into an array as raw strings containing each header, body, and attachment.
      </remarks>
      <example>
        See the CPop:DeleteMail() example.
      </example>
    </member>
    <member name="M:VO.CPop.ListMailIDs">
      <summary>
        Method to return an array of mail IDs of emails waiting on the server for download.
      </summary>
      <returns>
        ARRAY of mail IDs with the following format.
        {{nNum, cID}, …}
      </returns>
      <remarks>
        This method consults the server and returns a list of mail numbers and their corresponding ID. This information can be used to prevent duplicated downloads where headers are inspected or mails downloaded but not deleted from the server.
      </remarks>
    </member>
    <member name="M:VO.CPop.LogOn(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Log a user onto a connected POP server.
      </summary>
      <param name="cUID">The user ID.</param>
      <param name="cPwd">The user's password.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <example>
        See the CPop:DeleteMail() example.
      </example>
    </member>
    <member name="P:VO.CPop.MailboxInfo">
      <summary>
        An array of parameters representing information about emails waiting on the server to be downloaded. The format of the array, one for each mail, is as follows:
        {{cDate, cTime, cSender, cSubject}, …}
        Each element of the array is a string.
      </summary>
      <value>
        An array of parameters representing information about emails waiting on the server to be downloaded. The format of the array, one for each mail, is as follows:
        {{cDate, cTime, cSender, cSubject}, …}
        Each element of the array is a string.
      </value>
    </member>
    <member name="P:VO.CPop.MailCount">
      <summary>
        Numeric value representing the number of e-mails for the specific user.
      </summary>
      <value>Numeric value representing the number of e-mails for the specific user.</value>
    </member>
    <member name="P:VO.CPop.PassWord">
      <summary>
        String representing the user's password.
      </summary>
      <value>String representing the user's password.</value>
    </member>
    <member name="P:VO.CPop.ReceiveBytes">
      <summary>
        Numeric value representing the number of bytes received.
      </summary>
      <value>Numeric value representing the number of bytes received.</value>
    </member>
    <member name="M:VO.CPop.RecvRemote">
      <summary>
        Receive response data from a remote mail server.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method receives data from the connected remote POP server.  Received data is stored to the ReplyString property.
      </remarks>
    </member>
    <member name="P:VO.CPop.TotalBytes">
      <summary>
        Total size of all e-mails for the specific user.
      </summary>
      <value>Total size of all e-mails for the specific user.</value>
    </member>
    <member name="P:VO.CPop.UserName">
      <summary>
        String representing the user's name.
      </summary>
      <value>String representing the user's name.</value>
    </member>
    <member name="T:VO.CSession">
      <summary>
        Abstract class for wrapping an Internet session.
      </summary>
      <remarks>
        This class provides all necessary methods and properties as a base for sending and receiving files via Ftp and Http.
      </remarks>
    </member>
    <member name="M:VO.CSession.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a CSession object.
      </summary>
      <param name="cCaption">The optional caption as a string.</param>
      <param name="n">The optional port number. If not provided the defaults is 0.</param>
      <param name="lStat">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.CSession.AccessType">
      <summary>
        The type of Internet session.
        The default type is INTERNET_OPEN_TYPE_DIRECT.
        The alternate type is INTERNET_OPEN_TYPE_PROXY.
      </summary>
      <value>
        The type of Internet session.
        The default type is INTERNET_OPEN_TYPE_DIRECT.
        The alternate type is INTERNET_OPEN_TYPE_PROXY.
      </value>
    </member>
    <member name="M:VO.CSession.CloseFile(XSharp.__Usual)">
      <summary>
        Closes a remote file.
      </summary>
      <param name="hFile">The handle of the file to close.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.CSession.CloseRemote">
      <summary>
        Closes the Internet connection.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.CSession.Connected">
      <summary>
        A logical value indicating the status of the connection.
      </summary>
      <value>A logical value indicating the status of the connection.</value>
    </member>
    <member name="P:VO.CSession.ConnectHandle">
      <summary>
        Internet connection handle.
      </summary>
      <value>Internet connection handle.</value>
    </member>
    <member name="M:VO.CSession.ConnectRemote(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Opens a connection to the Internet server.
      </summary>
      <param name="cIP">The host name or IP address of the remote server.</param>
      <param name="nService">A constant representing the type of service to access.</param>
      <param name="nFlags">The flags to use in the internal InternetConnect call.</param>
      <param name="nContext">An identifier for the application context of the returned connection handle.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.CSession.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CSession.Error">
      <summary>
        The number of the last error code received.
      </summary>
      <value>The number of the last error code received.</value>
    </member>
    <member name="P:VO.CSession.ErrorMsg">
      <summary>
        A string representing the last error message received.
      </summary>
      <value>A string representing the last error message received.</value>
    </member>
    <member name="P:VO.CSession.Handle">
      <summary>
        The Internet session handle.
      </summary>
      <value>The Internet session handle.</value>
    </member>
    <member name="M:VO.CSession.InternetStatus(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="nContext">** missing parameter documentation **</param>
      <param name="nStatus">** missing parameter documentation **</param>
      <param name="pStatusInfo">** missing parameter documentation **</param>
      <param name="nStatusLength">** missing parameter documentation **</param>
    </member>
    <member name="F:VO.CSession.ogStatus">
      <exclude />
    </member>
    <member name="F:VO.CSession.oLock">
      <exclude />
    </member>
    <member name="M:VO.CSession.Open(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Opens a connection to the Internet server.
      </summary>
      <param name="nFlags">The flags to use in the internal InternetConnect call.</param>
      <param name="xProxy">The optional name of a proxy server.</param>
      <param name="aProxyByPass">An optional array of server names that should not be accessed through the proxy.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.CSession.OpenFlags">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CSession.PassWord">
      <summary>
        The password necessary to establish the remote connection.
      </summary>
      <value>The password necessary to establish the remote connection.</value>
    </member>
    <member name="P:VO.CSession.Port">
      <summary>
        The Port number of the current session communication.
      </summary>
      <value>The Port number of the current session communication.</value>
    </member>
    <member name="P:VO.CSession.Proxy">
      <summary>
        A string representing the proxy for the remote connection.
      </summary>
      <value>A string representing the proxy for the remote connection.</value>
    </member>
    <member name="P:VO.CSession.ProxyBypass">
      <summary>
        A string representing the proxies to bypass when establishing the remote connection.
      </summary>
      <value>A string representing the proxies to bypass when establishing the remote connection.</value>
    </member>
    <member name="P:VO.CSession.RemoteHost">
      <summary>
        A string representing the Host name or IP address of the remote server.
      </summary>
      <value>A string representing the Host name or IP address of the remote server.</value>
    </member>
    <member name="M:VO.CSession.SetResponseStatus">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CSession.UserName">
      <summary>
        A string representing the User ID necessary to establish the remote connection.
      </summary>
      <value>A string representing the User ID necessary to establish the remote connection.</value>
    </member>
    <member name="T:VO.CSmtp">
      <summary>
        Provide a class for Internet Protocol SMTP.
      </summary>
      <remarks>
        This class provides all necessary methods and properties for sending e-mail to a Simple Message Transfer Protocol (SMTP) server.
      </remarks>
      <example>
        <code language="X#">
          FUNCTION SMTPSendMail       (cServerIP      AS STRING,;
               cMailSubject   AS STRING,;
               xDestUser      AS USUAL,;
               xCCUser        AS USUAL,;
               cBody          AS STRING,;
               cFromAddress   AS STRING,;
               xAttachFile    AS USUAL,;
               cFromName      AS STRING,;
               xBCCUser       AS USUAL,;
               cCargo         AS STRING)   AS LOGIC PASCAL
            LOCAL oSmtp    AS CSMTP
            LOCAL lRet     AS LOGIC
            LOCAL oEmail   AS CEmail
            oEMail := CEmail{}
            oEmail:FromAddress   := cFromAddress
            oEmail:FromName      := cFromName
            oEmail:Cargo         := cCargo
            oEmail:Subject       := cMailSubject
            oEmail:DestList      := xDestUser
            oEmail:CCList        := xCCUser
            oEmail:BCCList       := xBCCUser
            oEmail:MailBody        := cBody
            IF !IsNil(xAttachFile)
               oEmail:AttachmentFileList := xAttachFile
            ENDIF
            oSmtp := CSmtp{oEmail}
            oSMtp:RemoteHost  := cServerIP
            oSmtp:TimeOut := 5000
            lRet := oSmtp:SendMail()
            RETURN lRet
        </code>
      </example>
    </member>
    <member name="M:VO.CSmtp.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a CSmtp object.
      </summary>
      <param name="oMail">A CEmail object.  If omitted, a generic (empty) CEmail object is created.</param>
      <param name="cServer">Name of the remote host that the class should connect to</param>
      <param name="nPort">Email port of the remote host that the class should connect to. Defaults to 25</param>
    </member>
    <member name="M:VO.CSmtp.CheckReply">
      <summary>
        Check the response from a mail server for error codes.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method checks for a response string from a mail server for error codes and sets the properties, ReplyCode, ReplyString, and Error.
      </remarks>
      <example>
        The following example checks the connection to Computer Associates mail server:
        <code language="X#">
          FUNC SmtpTest()
          LOCAL oSmtp AS CSMTP
          oSmtp   := CSMTP{"ServerCheck", "", "", "Check "}
          oSmtp:Timeout := 1000
          oSmtp:Connect("mail2.cai.com")
          oSmtp:CheckReply()
          ? oSmtp:ReplyString
          ? oSmtp:ReplyCode
          ? oSmtp:Error
          oSmtp:Disconnect()
        </code></example>
    </member>
    <member name="M:VO.CSmtp.connect(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Establish a connection to a remote SMTP server.
      </summary>
      <param name="cIP">String containing the host name of an Internet server.  Alternately, the string can contain the IP number of the site in ASCII dotted-decimal format (for example, 11.22.3.45). </param>
      <param name="nPort">Port number at &lt;cHostNameOrIP&gt;.  If not specified, the connection will be established to port SELF:RemotePort.  The default value is IPPORT_SMTP (25).</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method establishes a connection to the specified remote mail server at port &lt;nPort&gt; or SELF:RemotePort.
      </remarks>
      <example>
        See the CSmtp:CheckReply() example.
      </example>
    </member>
    <member name="M:VO.CSmtp.Disconnect">
      <summary>
        Shut down the current SMTP connection.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method can be used to close the connection to the SMTP server.
      </remarks>
      <example>
        See the CSmtp:CheckReply() example.
      </example>
    </member>
    <member name="P:VO.CSmtp.Email">
      <summary>
        An instance of the CEmail class.
      </summary>
      <value>An instance of the CEmail class.</value>
    </member>
    <member name="P:VO.CSmtp.EmailFormat">
      <summary>
        The format of the email.
      </summary>
      <value>The format of the email.</value>
    </member>
    <member name="M:VO.CSmtp.Logon">
      <summary>
        Logs on to the remote host with the user name and password of the smtp class
      </summary>
      <returns>
        Logic indicating if the Login was succesful
      </returns>
    </member>
    <member name="P:VO.CSmtp.MailApplication">
      <summary>
        A string that holds the name that is used when connection to mail servers
      </summary>
      <value>A string that holds the name that is used when connection to mail servers</value>
    </member>
    <member name="M:VO.CSmtp.RecvRemote">
      <summary>
        Receive response data from a remote mail server.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method receives data from the connected remote mail server.  Received data is stored to the ReplyString property.
      </remarks>
    </member>
    <member name="P:VO.CSmtp.SecureSMTP">
      <summary>
        A logic indicating if the CSmtp class should use Secure SMTP
      </summary>
      <value>A logic indicating if the CSmtp class should use Secure SMTP</value>
    </member>
    <member name="M:VO.CSmtp.SendAttachedFile">
      <summary>
        Send an attached file as part of an e-mail to a remote SMTP server.
      </summary>
      <param name="cFile">The file, optionally including the drive letter and path, to be sent.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        SendAttachedFile() is called from the SendMail() method to encode and send the file specified by SELF:AttachmentFile to the remote SMTP Server.
      </remarks>
    </member>
    <member name="M:VO.CSmtp.SendHeaderInfo">
      <summary>
        Create a mail header and send it as part of an e-mail to a remote SMTP server.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        SendHeaderInfo() is called from the SendMail() method to prepare and send the appropriate header to the remote SMTP server. The method does not take any parameters. The values for the FROM, TO, CC and BCC are read from the Email property of the cSMTP class.
      </remarks>
    </member>
    <member name="M:VO.CSmtp.SendMail">
      <summary>
        Send a complete e-mail to a remote SMTP server.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sends the complete e-mail to the remote SMTP Server.  Based on the SELF:MailBody, SELF:AttachmentFile, SELF:DestList, SELF:CCList, SELF:FromAddress and SELF:RemoteHost values, the SendMail()method prepares all necessary data including header and control sequences, and calls the SELF:SendHeaderInfo(), SendMailBody() and SELF:SendAttachedFile() methods at different stages of that transaction.
      </remarks>
    </member>
    <member name="M:VO.CSmtp.SendMailBody">
      <summary>
        This method is no longer available in &lt;%APPVER%&gt;
      </summary>
    </member>
    <member name="P:VO.CSmtp.TextEncoding">
      <summary>
        The text encoding type of the email.
      </summary>
      <value>The text encoding type of the email.</value>
    </member>
    <member name="T:VO.CSocket">
      <summary>
        Provide a class for low-level TCP/IP programming.
      </summary>
      <remarks>
        This class provides low-level socket functionality that can be used to implement different Internet protocols.
      </remarks>
    </member>
    <member name="M:VO.CSocket.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a CSocket object.
      </summary>
      <param name="nType">The type of the newly created socket.  Valid values are:</param>
      <param name="xSocket">The socket number.</param>
      <param name="xSocketStatus">The socket status.</param>
    </member>
    <member name="M:VO.CSocket.accept">
      <summary>
        Accept a new connection on a socket.
      </summary>
      <returns>
        A new CSocket object instance, if successful; otherwise, NULL_OBJECT.
      </returns>
      <remarks>
        This method can be used to make Internet server applications wait for a client's connection.
      </remarks>
      <example>
        The following example implements a simple socket server function listening for first connections at port 7:
        <code language="X#">
          FUNCTION ServerTest()
          LOCAL oSocket   AS CSocket
          LOCAL oSockMsg  AS CSocket
          LOCAL cData     AS STRING
          LOCAL cFrom     AS STRING
          LOCAL nPort     AS INT
          LOCAL lRet      AS LOGIC
          oSocket  := CSocket{SOCK_STREAM}
          IF oSocket:bind(7, NULL_STRING, AF_INET)
          oSocket:listen(1)
          lRet := .F.
          oSockMsg := oSocket:accept()
          IF oSockMsg != NULL_OBJECT
          cData := oSockMsg:GetLine()
          oSockMsg:getpeername(@cFrom, @nPort)
          ? "Connection accepted from ", cFrom, ;
          , client port: , NTrim(nPort)
          ? "Received data: ", cData
          lRet := .T.
          ENDIF
          oSockMsg:Close()
          ENDIF
          oSocket:Close()
          RETURN lRet
        </code></example>
    </member>
    <member name="M:VO.CSocket.bind(System.UInt16,System.String,System.Int16)">
      <summary>
        Associate a local address with a socket.
      </summary>
      <param name="nPort">Port number at &lt;cHostNameOrIP&gt;.</param>
      <param name="cIP">String containing the local name of an Internet server. Alternately, the string can contain the IP number of the site in ASCII dotted-decimal format (for example, 11.22.3.45).  If NULL_STRING is specified, the local host name is assumed.</param>
      <param name="nFamily">SHORTINT number specifying the Address Family. </param>
    </member>
    <member name="M:VO.CSocket.Close">
      <summary>
        Disconnects the socket and closes it.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method disconnects a connection and then closes it.
        If a socket is not closed in code, it will be automatically closed if the appropriate object instance goes out of scope.
      </remarks>
      <example>
        See the CSocket:Connect() example.
      </example>
    </member>
    <member name="M:VO.CSocket.connect(System.String,System.UInt16)">
      <summary>
        Establish a connection of the socket instance to a peer.
      </summary>
      <param name="cIP">String containing the host name of an Internet server.  Alternately, the string can contain the IP number of the site in ASCII dotted-decimal format (for example, 11.22.3.45).</param>
      <param name="nPort">Port number at &lt;cHostNameOrIP&gt;.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method establishes a connection to the specified remote address at port &lt;nPort&gt;.
      </remarks>
      <example>
        The following example checks whether a remote SMTP server is currently available:
        <code language="X#">
          FUNCTION Start
          IF CheckRemote("mail2.cai.com", IPPORT_SMTP, 1000)
          ? "CA's mail server is available"
          ELSE
          ? "Mail server currently not accessible"
          ENDIF
          FUNCTION CheckRemote (cServer AS STRING, nPort AS INT, ;
          nTimeout AS INT); AS LOGIC  PASCAL
          LOCAL oSocket   AS CSocket
          LOCAL lRet      AS LOGIC
          oSocket := CSocket{SOCK_STREAM}
          oSocket:TimeOut := nTimeout
          lRet := oSocket:connect(cServer, nPort)
          oSocket:Close()
          RETURN lRet
        </code></example>
    </member>
    <member name="M:VO.CSocket.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CSocket.DisConnect">
      <summary>
        Shut down the current socket connection.
        This disables sending/receiving on the socket, but does NOT close the socket.
        Note that this function does NOT close the connection like it did in Visual Objects 2.5!
        To close a socket you need to call cSocket:Close()!
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Disconnect() can be used to close the connection made for the CSocket object instance.  If not specified, the connection will automatically be closed if the appropriate object instance goes out of scope.
      </remarks>
      <example>
        See the CSocket:Connect() example.
      </example>
    </member>
    <member name="M:VO.CSocket.DisplayError">
      <summary>
        Display error messages.
      </summary>
      <remarks>
        Displays the error message.
      </remarks>
    </member>
    <member name="P:VO.CSocket.Error">
      <summary>
        Numeric value representing the error code.
      </summary>
      <value>Numeric value representing the error code.</value>
    </member>
    <member name="P:VO.CSocket.ErrorMsg">
      <summary>
        String with error information.
      </summary>
      <value>String with error information.</value>
    </member>
    <member name="M:VO.CSocket.GetLine">
      <summary>
        Extract the first line from the socket data received via the current connection.
      </summary>
      <returns>
        String containing the received line of data, if successful; otherwise, NULL_STRING
      </returns>
      <remarks>
        This method extracts the first line from input data.
        <note type="tip">GetLine() can be used for TCP sockets only, because it assumes that a connection is already established.</note></remarks>
      <example>
        See the CSocket:Accept() example.
      </example>
    </member>
    <member name="M:VO.CSocket.GetLineFrom(System.String@,System.UInt32@)">
      <summary>
        Wait for connection and extract first line from incoming data.
      </summary>
      <param name="cIP">Reference to a string to receive the client's IP address.</param>
      <param name="nRemPort">Reference to a DWORD value to receive the client's port number.</param>
      <returns>
        String containing the received line, if successful; otherwise, NULL_STRING
      </returns>
      <remarks>
        This method waits for data packages and extracts the first line from input data.  Besides this, GetLineFrom() extracts the IP address and port number associated with the received Data.  This method can be used by UDP sockets to retrieve datagram packages sent via the Internet.
      </remarks>
      <example>
        The following example implements a simple socket server function listening for the first datagram package at port 7:
        <code language="X#">
          FUNCTION ServerTest2()   AS VOID PASCAL
          LOCAL oSocket   AS CSocket
          LOCAL cData     AS STRING
          LOCAL cFrom     AS STRING
          LOCAL nPort     AS INT
          oSocket  := CSocket{SOCK_DGRAM}
          IF oSocket:bind(7, NULL_STRING, AF_INET)
          oSocket:TimeOut := 10000
          cData := oSocket:GetLineFrom(@cFrom, @nPort)
          IF cFrom == NULL_STRING
          ? "Timeout expired, no data received :-("
          ELSE
          ? "Data received from ", cFrom, ;
          , "Client port: ", NTrim(nPort)
          ? "Received data:" , cData
          ENDIF
          ENDIF
          oSocket:Close()
          RETURN
        </code></example>
    </member>
    <member name="M:VO.CSocket.GetLines(XSharp.__Array)">
      <summary>**Missing documentation **</summary>
      <param name="aSearch">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CSocket.getpeername(System.String@,System.Int32@)">
      <summary>
        Get the address of the peer to which the socket is connected.
      </summary>
      <param name="cName">Reference to a string to receive the peer's IP address.</param>
      <param name="nPort">Reference to a DWORD value to receive the peer's port number.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method gets the address and port number of the peer to which the socket is connected.
      </remarks>
      <example>
        See the CSocket:Accept() example.
      </example>
    </member>
    <member name="M:VO.CSocket.GetRaw">
      <summary>
        Receive all available data from a socket.
      </summary>
      <returns>
        String containing the received data, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        This method stores input data to a string.
        <note type="tip">GetRaw() can be used for TCP sockets only, because it assumes that a connection is already established.</note></remarks>
      <example>
        The following example implements a simple socket server function waiting for connection at port 7 and receiving all data from the client:
        <code language="X#">
          FUNCTION ServerTest3()   AS VOID PASCAL
          LOCAL oSocket   AS CSocket
          LOCAL oSockMsg  AS CSocket
          LOCAL cData     AS STRING
          LOCAL cFrom     AS STRING
          LOCAL nPort     AS INT
          oSocket  := CSocket{SOCK_STREAM}
          IF oSocket:bind(7, NULL_STRING, AF_INET)
            oSocket:listen(1)
            oSockMsg := oSocket:accept()
            IF oSockMsg != NULL_OBJECT
            	   cData := oSockMsg:GetRaw()
            oSockMsg:GetPeerName(@cFrom, @nPort)
            ? "Data received from ", cFrom, ;
            ", Client 	port: ", NTrim(nPort)
            ? "Received data: ", cData
            ENDIF
            oSockMsg:Close()
          ENDIF
          oSocket:Close()
          RETURN
        </code></example>
    </member>
    <member name="M:VO.CSocket.GetRawText(System.Boolean,System.Boolean,System.UInt32)">
      <summary>
        Receive all available data from a socket.
      </summary>
      <param name="lLineMode">** missing parameter documentation **</param>
      <param name="lNext">** missing parameter documentation **</param>
      <param name="dwByteCount">** missing parameter documentation **</param>
      <returns>
        String containing the received data, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        This method stores input data to a string.
        <note type="tip">GetRaw() can be used for TCP sockets only, because it assumes that a connection is already established.</note></remarks>
      <example>
        The following example implements a simple socket server function waiting for connection at port 7 and receiving all data from the client:
        <code language="X#">
          FUNCTION ServerTest3()   AS VOID PASCAL
          LOCAL oSocket   AS CSocket
          LOCAL oSockMsg  AS CSocket
          LOCAL cData     AS STRING
          LOCAL cFrom     AS STRING
          LOCAL nPort     AS INT
          oSocket  := CSocket{SOCK_STREAM}
          IF oSocket:bind(7, NULL_STRING, AF_INET)
            oSocket:listen(1)
            oSockMsg := oSocket:accept()
            IF oSockMsg != NULL_OBJECT
            	   cData := oSockMsg:GetRaw()
            oSockMsg:GetPeerName(@cFrom, @nPort)
            ? "Data received from ", cFrom, ;
            ", Client 	port: ", NTrim(nPort)
            ? "Received data: ", cData
            ENDIF
            oSockMsg:Close()
          ENDIF
          oSocket:Close()
          RETURN
        </code></example>
    </member>
    <member name="M:VO.CSocket.getsockname(System.String@,System.Int32@)">
      <summary>
        Get the local name for a socket.
      </summary>
      <param name="cName">Reference to a string which is to receive the peer's IP address.</param>
      <param name="nPort">Reference to a DWORD value to receive the peer's port number</param>
      <returns>
        TRUE if successful; otherwise, FALSE
      </returns>
      <remarks>
        This method gets the local address and port number of the socket.
      </remarks>
      <example>
        The following example demonstrates the use of this method:
        <code language="X#">
          FUNCTION SimpleTest()   AS VOID PASCAL
          LOCAL oSocket   AS CSocket
          LOCAL cIP       AS STRING
          LOCAL nPort     AS INT
          oSocket  := CSocket{SOCK_STREAM}
          IF oSocket:bind(7, NULL_STRING, AF_INET)
          oSocket:GetSockName(@cIP, @nPort)
          ? "Local IP ", cIP, ", port: ", NTrim(nPort)
          ENDIF    
          oSocket:Close()
          RETURN
        </code></example>
    </member>
    <member name="M:VO.CSocket.InternetStatus(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="nContext">** missing parameter documentation **</param>
      <param name="nStatus">** missing parameter documentation **</param>
      <param name="xStatus">** missing parameter documentation **</param>
      <param name="nStatusLength">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CSocket.listen(System.Int32)">
      <summary>
        Establish a socket to listen for an incoming connection.
      </summary>
      <param name="nBackLog">The maximum length to which the queue of pending connections can grow.</param>
      <returns>
        TRUE if successful; otherwise, FALSE
      </returns>
      <remarks>
        This method establishes a socket to listen for an incoming connection.
      </remarks>
      <example>
        See the CSocket:Accept() example.
      </example>
    </member>
    <member name="P:VO.CSocket.RcvBufSize">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CSocket.SendLine(System.String)">
      <summary>
        Send data terminated by CRLF to the connected socket.
      </summary>
      <param name="cData">Data to be sent via the socket.</param>
      <returns>
        Number of data sent, if successful; otherwise, 0 (zero).
      </returns>
      <remarks>
        Method SendLine() sends a line to the connected socket.
        <note type="tip">This method can be used for TCP sockets only, because it assumes that a connection is already established.</note></remarks>
      <example>
        The following example demonstrates this method:
        <code language="X#">
          FUNCTION ClientTest()   AS LOGIC PASCAL
          LOCAL oSocket   AS CSocket
          LOCAL cTo       AS STRING
          LOCAL nPort     AS INT
          oSocket  := CSocket{SOCK_STREAM}
          IF oSocket:connect( HostName(), 7)
          IF oSocket:SendLine("Hello world") &gt; 0
          oSocket:GetPeerName(@cTo, @nPort)
          ? "Data sent to ", cTo, ", port: ", NTrim(nPort)
          ENDIF
          oSocket:Close()
          ENDIF
          RETURN
        </code></example>
    </member>
    <member name="M:VO.CSocket.SendLineTo(System.String,System.String,System.UInt16)">
      <summary>
        Send data terminated by CRLF to a specific destination.
      </summary>
      <param name="cData">Data to be sent via the socket.</param>
      <param name="cDest">String containing the host name of an Internet server.  Alternately, the string can contain the IP number of the site in ASCII dotted-decimal format (for example, 11.22.3.45). </param>
      <param name="nRemPort">Port number at &lt;cHostNameOrIP&gt;.</param>
      <returns>
        Number of data sent, if successful; otherwise, 0 (zero).
      </returns>
      <remarks>
        This method sends a line to a destination without establishing a connection.  SendLine() can be used for UDP sockets to send datagram packages via the Internet.
      </remarks>
      <example>
        The following example demonstrates the use of this method:
        <code language="X#">
          FUNCTION ClientTest1()   AS LOGIC PASCAL
          LOCAL oSocket   AS CSocket
          LOCAL cTo       AS STRING
          LOCAL nPort     AS INT
          oSocket  := CSocket{SOCK_DGRAM}
          IF oSocket:SendLineTo("Hello world", HostName(), 7)
          ? "Datagram package sent ... "
          ENDIF
          oSocket:Close()
          RETURN
        </code></example>
    </member>
    <member name="M:VO.CSocket.SendRaw(System.Void*,System.UInt32)">
      <summary>
        Send any data to the connected socket.
      </summary>
      <param name="pData">Pointer to the data to be sent via the socket.</param>
      <param name="nSize">Length of the data to be sent.</param>
      <returns>
        TRUE if successful; otherwise, FALSE
      </returns>
      <remarks>
        SendRaw() sends raw data to the connected socket.
        <note type="tip">This method can be used for TCP sockets only, because it assumes that a connection is already established.</note></remarks>
      <example>
        The following example demonstrates the use of this method:
        <code language="X#">
          FUNCTION ClientTest2()  AS LOGIC PASCAL
          LOCAL oSocket   AS CSocket
          LOCAL cTo       AS STRING
          LOCAL cData     AS STRING
          LOCAL nSize     AS INT
          LOCAL nPort     AS INT
          CLS
          oSocket  := CSocket{SOCK_STREAM}
          IF oSocket:connect( HostName(), 7)
            cData := MemoRead("Test.txt")
            nSize := SLen(cData)
            IF oSocket:SendRaw(PTR(_CAST, cData), nSize)
            oSocket:GetPeerName(@cTo, @nPort)
            	   ? "Data sent to ", cTo, ", port: ", ;
            		NTrim(nPort)
            ENDIF
          ENDIF
          oSocket:Close()
          RETURN
        </code></example>
    </member>
    <member name="M:VO.CSocket.SendRawText(System.String)">
      <summary>
        Send any data to the connected socket.
      </summary>
      <param name="cData">Pointer to the data to be sent via the socket.</param>
      <param name="nDataLen">Length of the data to be sent.</param>
      <returns>
        TRUE if successful; otherwise, FALSE
      </returns>
      <remarks>
        SendRaw() sends raw data to the connected socket.
        <note type="tip">This method can be used for TCP sockets only, because it assumes that a connection is already established.</note></remarks>
      <example>
        The following example demonstrates the use of this method:
        <code language="X#">
          FUNCTION ClientTest2()  AS LOGIC PASCAL
          LOCAL oSocket   AS CSocket
          LOCAL cTo       AS STRING
          LOCAL cData     AS STRING
          LOCAL nSize     AS INT
          LOCAL nPort     AS INT
          CLS
          oSocket  := CSocket{SOCK_STREAM}
          IF oSocket:connect( HostName(), 7)
            cData := MemoRead("Test.txt")
            nSize := SLen(cData)
            IF oSocket:SendRaw(PTR(_CAST, cData), nSize)
            oSocket:GetPeerName(@cTo, @nPort)
            	   ? "Data sent to ", cTo, ", port: ", ;
            		NTrim(nPort)
            ENDIF
          ENDIF
          oSocket:Close()
          RETURN
        </code></example>
    </member>
    <member name="P:VO.CSocket.SndBufSize">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.CSocket.Status">
      <summary>
        Numeric value with the current status representing one of the following states:
      </summary>
      <value>Numeric value with the current status representing one of the following states:</value>
      <remarks>
        <list type="table">
          <item>
            <term>SSTAT_UNINITIALIZED</term>
          </item>
          <item>
            <term>SSTAT_DISCONNECTED</term>
          </item>
          <item>
            <term>SSTAT_CONNECTING</term>
          </item>
          <item>
            <term>SSTAT_LISTENING</term>
          </item>
          <item>
            <term>SSTAT_DISCONNECTING</term>
          </item>
          <item>
            <term>SSTAT_CONNECTED</term>
          </item>
          <item>
            <term>SSTAT_ERRORSTATE</term>
          </item>
          <item>
            <term>SSTAT_TIMEDOUT</term>
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:VO.CSocket.TimeOut">
      <summary>
        Numeric value representing the time-out in milliseconds.
      </summary>
      <value>Numeric value representing the time-out in milliseconds.</value>
    </member>
    <member name="P:VO.CSocket.TimeOutRetries">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.CStorage">
      <summary>
        Provide an interface to handle large Email Messages and attachments
      </summary>
      <remarks>
        This class is used Exclusively by the CEMail Class to read and write attachments.
        The class reads/writes attachments in a disk folder.
        If you want to store attachments on another location (for example a SQL Database) then you should subclass this class and override the implementation of the methods.
        CStorage also gives you an interface to store the raw data of received emails. During reception of an email the following three methods are called:
        RawNew()
        RawWrite()
        RawClose()
        You can use these methods to implement your own mechanism to save the raw email contents.

        This class provides an interface that is used to handle streaming of inbound and outbound messages
      </remarks>
    </member>
    <member name="M:VO.CStorage.#ctor(XSharp.__Usual)">
      <summary>
        Enter topic text here.
      </summary>
      <param name="cPath">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.CStorage.AttachmentAdd(System.String,System.UInt32)">
      <summary>
        This method is called when an email is received to initialize the saving of a new attachment.
        The implementation in CStorage generates a unique ID and creates the (empty) file.
      </summary>
      <param name="cFile">Contains the file name of the attachment.</param>
      <param name="dwCode">
        The Coding type. Can be one of the following values:
        <pre>
          CODING_TYPE_7BIT
          CODING_TYPE_8BIT
          CODING_TYPE_BASE64
          CODING_TYPE_NONE
          CODING_TYPE_PRINTABLE
          CODING_TYPE_UNKNOWN
          CODING_TYPE_UUENCODE
        </pre>
        In most cases it is CODING_TYPE_BASE64 and only this type is implemented in the CStorage class.
      </param>
      <returns>
        &lt;cID&gt;	STRING The unique ID. If AttachmentAdd() fails it returns a NULL_STRING.
      </returns>
    </member>
    <member name="M:VO.CStorage.AttachmentClose">
      <summary>
        This method is called after receiving of an attachment or after reading of an attachment from the storage during sending.
        The implementation in CStorage closes an open file.
      </summary>
    </member>
    <member name="M:VO.CStorage.AttachmentDelete(System.String)">
      <summary>
        This method returns the full path of an attachment file addressed through cAttachID.
      </summary>
      <param name="cID">Contains the ID or the full path of the attachment.</param>
      <returns>
        LOGIC	TRUE when the attachment could be deleted.
      </returns>
    </member>
    <member name="M:VO.CStorage.AttachmentFullPath(System.String)">
      <summary>
        This method returns the full path of an attachment file addressed through cAttachID.
      </summary>
      <param name="cAttachID">Contains the ID or the full path of the attachment.If it is a full path the first character of cAttachID is ATTACHID_PATHFLAG (&gt;)</param>
      <returns>
        &lt;cID&gt;	STRING The full path of an attachment file
      </returns>
    </member>
    <member name="M:VO.CStorage.AttachmentOpen(System.String,System.UInt32)">
      <summary>
        This method is called during sending of an email, if an attachment have to be sent. It prepares the loading process from the storage. In our case it addresses the attachment file and opens it.
      </summary>
      <param name="cAttachID">Contains the ID or the full path of the attachment.</param>
      <param name="dwCode">
        Contains the coding type. It can be one of the following values:
        <list type="bullet"><item>CODING_TYPE_7BIT</item><item>CODING_TYPE_8BIT</item><item>CODING_TYPE_BASE64</item><item>CODING_TYPE_NONE</item><item>CODING_TYPE_PRINTABLE</item><item>CODING_TYPE_UNKNOWN</item><item>CODING_TYPE_UUENCODE</item></list>
        In most cases it is CODING_TYPE_BASE64 and only this type is implemented in the CStorage class.
      </param>
      <returns>
        LOGIC	TRUE when the attachment could be opened successfully.
      </returns>
    </member>
    <member name="M:VO.CStorage.AttachmentRead">
      <summary>
        This method is called during sending of an attachment. It reads a data block from the attachment file. In our implementation it reads 1536 bytes. The result string is the encoded value of this data block.
      </summary>
      <returns>
        STRING	The encoded value of this data block.
      </returns>
    </member>
    <member name="M:VO.CStorage.AttachmentSave(System.String,System.String)">
      <summary>
        Stores the attachment with the ID cAttachID to the file cToFile.
        cToFile must be a full path name. This method is called from CEMail:SaveAs().
      </summary>
      <param name="cAttachID">Contains the ID or the full path of the attachment.</param>
      <param name="cToFile">Contains the full path name of the target file.</param>
      <returns>
        &lt;cID&gt;	STRING The unique ID. If AttachmentAdd() fails it returns a NULL_STRING.
      </returns>
    </member>
    <member name="P:VO.CStorage.AttachmentSize">
      <summary>
        Returns the file size of a currently stored or an opened attachment file. This access is called during receiving an email.
      </summary>
      <value>The file size of a currently stored or an opened attachment file. This access is called during receiving an email.</value>
    </member>
    <member name="M:VO.CStorage.AttachmentWrite(System.String)">
      <summary>
        This method is called multiple times per attachment during the receive process.
      </summary>
      <param name="cData">Contains the encoded attachment data. For BASE64 encoded data the length of cData is mostly 78 characters.The default implementation decodes cData and writes it into the file.</param>
      <returns>
        NOTHING
      </returns>
    </member>
    <member name="M:VO.CStorage.CreateNewEMail">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.CStorage.CreateNewMail">
      <summary>
        This method returns a new empty CEMail object.
      </summary>
      <returns>
        &lt;oMail&gt;	A new empty CEmail object.
      </returns>
    </member>
    <member name="M:VO.CStorage.LoadEMail(System.String)">
      <summary>
        This method returns a CEMail object filled with all data addressed through the cID.
        You have to implement this method and the meaning of cID.
        THIS METHOD IS NOT IMPLEMENTED IN CSTORAGE AND NOT CALLED BY THE INTERNET CLASSES
      </summary>
      <param name="cId">Contains a unique identifier that describes the Email</param>
      <returns>
        &lt;oEmail&gt;
      </returns>
      <remarks>
        <note type="tip">
          The following shows a logical template of this method:
          <code language="X#">
            METHOD LoadEMail(cId AS STRING) CLASS MyCStorage
            //You should do the following:
            LOCAL oEMail AS CEMail
            oEMail := SELF:CreateNewEmail()
            // 1.) assign oEMail:MailHeader
            // 2.) Call oEMail:GetHeaderInfo()
            // 3.) assign oEMail:Body
            // 4.) assign oEMail:Html
            // 5.) assign oEMail:AttachmentInfo

            RETURN oEMail
          </code></note>
      </remarks>
    </member>
    <member name="P:VO.CStorage.NoSave">
      <summary>
        You can use this assign to suppress the storing of the attachments into the storage. This makes sense, if you want to store only raw email files.
      </summary>
      <value>You can use this assign to suppress the storing of the attachments into the storage. This makes sense, if you want to store only raw email files.</value>
      <param name="LOGIC">TRUE suppresses saving of attachments. In that case you need to implement the Raw..() methods in your CStorage subclass to save the raw emails.</param>
    </member>
    <member name="M:VO.CStorage.RawClose">
      <summary>
        This method is called when an email was received completely.
      </summary>
      <param name="cFile">Contains the file name of the attachment.</param>
      <returns>
        NOTHING
      </returns>
      <remarks>
        <note type="tip">
          It is not recommended to decode raw emails in memory as one single string.
          The preferred mechanism is to stream them to disk or to a database. "streaming" instead.
          Look into the method EmailWindowMain:ImportMail() of the email sample to see how easy this works.
          If you want to see how to send an email into a raw email file look into the method EmailStore:SendMailAsFile() of the email sample.
        </note>
      </remarks>
    </member>
    <member name="M:VO.CStorage.RawNew(VO.CEmail)">
      <summary>
        This method is called at the beginning before any data is received.
        You have to implement how you want to store and address the raw data here.
      </summary>
      <param name="oEMail">Email object for the mail that is received. Note that almost all of the properties of this object will be empty.</param>
      <returns>
        NOTHING
      </returns>
      <remarks>
        <note type="tip">
          It is not recommended to decode raw emails in memory as one single string.
          The preferred mechanism is to stream them to disk or to a database. "streaming" instead.
          Look into the method EmailWindowMain:ImportMail() of the email sample to see how easy this works.
          If you want to see how to send an email into a raw email file look into the method EmailStore:SendMailAsFile() of the email sample.
        </note>
      </remarks>
    </member>
    <member name="M:VO.CStorage.RawWrite(System.String)">
      <summary>
        Now this method is called multiple times until the complete email including all attachments is received. You have to implement how you want to store each data block.
      </summary>
      <param name="cData">Contains the file name of the attachment.</param>
      <returns>
        &lt;cID&gt;	STRING The unique ID. If AttachmentAdd() fails it returns a NULL_STRING.
      </returns>
      <remarks>
        <note type="tip">
          It is not recommended to decode raw emails in memory as one single string.
          The preferred mechanism is to stream them to disk or to a database. "streaming" instead.
          Look into the method EmailWindowMain:ImportMail() of the email sample to see how easy this works.
          If you want to see how to send an email into a raw email file look into the method EmailStore:SendMailAsFile() of the email sample.
        </note>
      </remarks>
    </member>
    <member name="M:VO.CStorage.SaveAttachments(VO.CEmail,System.Boolean)">
      <summary>
        This method stores all attachments of an email into the storage.
      </summary>
      <param name="oEMail">The Email from which the attachments need to be saved to the storage.</param>
      <param name="lClone">If lClone is TRUE and oEMail was loaded from the storage new copies of the attachments are stored into the storage.</param>
      <returns>
        &lt;cID&gt;	STRING The unique ID. If AttachmentAdd() fails it returns a NULL_STRING.
      </returns>
    </member>
    <member name="M:VO.CStorage.SaveEMail(System.String,VO.CEmail)">
      <summary>
        This method stores a CEMail object including all data under the address of the cID.
        You have to implement this method and the meaning of cID.
        THIS METHOD IS NOT IMPLEMENTED IN CSTORAGE AND NOT CALLED BY THE INTERNET CLASSES
      </summary>
      <param name="cId">Unique Identifier for the Email</param>
      <param name="oEMail">Object that contains the email</param>
      <returns>
        LOGIC	TRUE when the email was saved succesfully
      </returns>
      <remarks>
        <note type="tip">
          The following shows a logical template of this method:
          <code language="X#">
            METHOD SaveEMail(cId AS STRING, oEMail AS CEMail) AS LOGIC PASCAL CLASS MyCStorage
            //Save oEMail with the current ID
            //You should save the following
            // 1.) oEMail:MailHeader for received mails, not for sent mails
            //     call oEMail:SetHeaderInfo() to create the MailHeader
            // 2.) oEMail:Body
            // 3.) oEMail:Html
            // 4.) Call Self:SaveAttachments(oEMail)
            // 5.) Save oEMail:AttachmentInfo
            RETURN TRUE
          </code></note>
      </remarks>
    </member>
    <member name="T:VO.CurHand">
      <exclude />
    </member>
    <member name="M:VO.CurHand.#ctor">
      <exclude />
    </member>
    <member name="T:VO.Cursor">
      <summary>
        Create a text cursor, which is used to visually represent the position in a window where the next piece of text appears.
      </summary>
      <remarks>
        The default cursor is an I-beam, although you can also create cursors using bitmaps.
        Note that a window can have only one cursor at a time.  The system automatically manages the cursor between windows.
        <note type="tip">
          Not applicable for DialogWindows or DataWindows.
          Tip:  In X#, the Cursor class corresponds to a text cursor; use class Pointer to create mouse cursors.
        </note></remarks>
      <example>
        This example creates a cursor during a focus change:
        <code language="X#">
          METHOD FocusChange(oEvent) CLASS MyWindow
          IF oEvent:GotFocus
          oCursorText := Cursor{SELF,Dimension{20,20}}
          oCursorText:Position := Point{40,40}
          oCursorText:Show()
          ...
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.Cursor.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a cursor.
      </summary>
      <param name="oOwner">The window that owns the cursor.</param>
      <param name="oObject">Either the dimension of the cursor, in canvas coordinates, or the bitmap used to depict the cursor.</param>
      <param name="lDimmed">TRUE creates the cursor as semi-transparent (dim); FALSE creates the cursor as black.  The default is TRUE.</param>
    </member>
    <member name="M:VO.Cursor.Destroy">
      <summary>
        Provide a method to de-instantiate a Cursor object.
      </summary>
      <remarks>
        This method can be used when a Cursor object is no longer needed.  Cursor:Destroy() de-instantiates the Cursor object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.Cursor.Handle(XSharp.__Usual)">
      <summary>
        Return the handle for a cursor.
      </summary>
      <param name="nHandleType">The type of handle required.  0 is the only supported option and is the default if &lt;nHandleType&gt; is omitted.</param>
      <returns>
        A handle describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
      </remarks>
    </member>
    <member name="M:VO.Cursor.Hide">
      <summary>
        Hide a cursor so it is not visible (until a subsequent call to Cursor:Show()).
      </summary>
    </member>
    <member name="P:VO.Cursor.Position">
      <summary>
        A point — in owner window canvas coordinates — representing the current position of the cursor.
      </summary>
      <value>A point — in owner window canvas coordinates — representing the current position of the cursor.</value>
    </member>
    <member name="M:VO.Cursor.Show">
      <summary>
        Display a cursor so it is visible.
      </summary>
      <remarks>
        You must always Show() cursors explicitly.  Cursor:Show() is also usually called to redisplay a cursor that was hidden with the Cursor:Hide() method.
      </remarks>
    </member>
    <member name="T:VO.CustomControl">
      <summary>
        Provide a base custom control class from which to derive specialized custom controls.
      </summary>
      <remarks>
        The CustomControl class registers its own Window class and can be used as a base for custom and owner-drawn controls.  The CustomControl class is available via the Window Editor's tool palette.
        A custom control is an empty child window that can be used as a control on any window surface.  The plain custom control does not have any built-in functionality, so you usually want to derive your own custom control class and implement specific behavior.
        Also, since a custom control only implements an empty child window, you should implement your own Expose() handler to support the owner-drawn surface of the control.
      </remarks>
    </member>
    <member name="M:VO.CustomControl.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a custom control.
      </summary>
      <param name="oOwner">The window that owns the custom control.</param>
      <param name="xID">The unique ID of the custom control (between 1 and 8000).</param>
      <param name="oPoint">The origin of the custom control in canvas coordinates.</param>
      <param name="oDimension">The dimension of the custom control in canvas coordinates.</param>
      <param name="kStyle">Constant representing the style of the custom control, specified either by a X# style constant or a Windows API style constant.  Styles can be combined using the _Or() operator.</param>
      <param name="lDataAware">Logical value indicating whether the custom control is data-aware (TRUE) or not (FALSE).  The default is FALSE.</param>
      <param name="nResourceID">The resource ID of the custom control.</param>
      <remarks>
        <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular Windows API constant.</note>
      </remarks>
    </member>
    <member name="T:VO.DataBrowser">
      <summary>
        Create a data browser, which is a spreadsheet-like table for displaying information from a data server.
      </summary>
      <remarks>
        A data browser is a control, like a check box or edit field.  However, it should ordinarily not be created as an independent control; the easiest way to use a data browser is to switch a data window to browse view.  This creates the DataBrowser object; it may be referenced through the data window's Browser property.
        The data browser is data-aware, like a window, and may be connected to a data server as a client.  It exhibits much of the same behavior as a data window:  it propagates data down to the server and it responds to all the notification messages that a server sends to its clients.
        The easiest way to place a browser on a window as a control together with other controls is to place another data window as a nested subform; see the DataWindow class for a description.  This is easily done in the Window Editor using the Edit Insert menu commands or the Auto Layout feature.  See "Using the Window Editor" in your IDE User Guide for details.
        <note type="tip">Static dependencies to the CATO3*.DLL files, which contain the DataBrowser and SplitWindow functionality, have been removed in this version of X#.  Applications not using a data browser and/or split window no longer need these .DLLs.  This leads to a smaller memory footprint, faster application startup, and smaller installations.</note>

        Data browsers present information in a spreadsheet-like table, with rows and columns.
        The columns are DataColumn objects.  Data columns correspond to fields in a data server — each data column is linked to a server field (just like data controls on a data window).
        The rows correspond to records in the server.  Unlike a regular data window, which displays only one record — the "current" record — at a time, the browser displays several records as rows in the table.  It always maintains one row as the "current" row, which is the record the server is positioned on.  References to the data and action methods that manipulate the data always refer to the "current" record, just like in a regular data window.  The only difference, therefore, is visual, in that the browser shows records other than the current one.

        The user and the developer have a great deal of flexibility in the visual layout of data browsers.  Columns can be resized and rearranged on the fly, by the user with the mouse (unless the developer disables these options) or under program control.
        To retain meaningful control of a column's contents after it has been rearranged, columns are identified by their name.  If there is a need to use numbers for reference (as in a generic utility program that knows nothing of the meaning of its data), the columns can be referenced by their original positional number in the browser, which may or may not be the same as their visual position.
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a data browser.
      </summary>
      <param name="oOwner">The window that owns the data browser.</param>
      <param name="xID">The unique ID of the data browser (between 1 and 8000).</param>
      <param name="oPoint">The origin of the data browser in canvas coordinates.  If not specified, (0,0) is used.</param>
      <param name="oDimension">The dimension of the data browser in canvas coordinates.  If not specified, the size of &lt;oOwner&gt; is used.</param>
      <param name="nResourceID">The resource ID of the data browser.</param>
      <remarks>
        When the owner window is a DataWindow object, the data browser occupies the full size of the data window frame window and changes size as the data window size changes.
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.AddColumn(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Add one or more columns to a data browser.
      </summary>
      <param name="oGColumn">The data column to be added or the array of data columns to be added.</param>
      <param name="nIndex">The column after which the new column or columns will be inserted.  This value can be a string or symbol representing the name of the column, a number representing its column number, or an oDataColumn object identifying the column.  If you specify a number, you should note that column numbering begins at 1 (which refers to the first column in the logical sequence, not necessarily the leftmost column from the visual viewpoint).  If omitted, new columns are added after the last column.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        When columns are inserted in the middle of the sequence, the reference numbers for any trailing columns are incremented.  This is one reason why columns should be referenced by name, rather than number.  Also, note that while columns can be repositioned from a visual viewpoint, they retain their logical position in the browser.
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.AsString">
      <summary>
        Return an identifying label for the data browser.
      </summary>
    </member>
    <member name="P:VO.DataBrowser.Background">
      <summary>
        The brush used for painting the background of this data browser.
      </summary>
      <value>The brush used for painting the background of this data browser.</value>
    </member>
    <member name="M:VO.DataBrowser.CanUndo">
      <summary>
        Determine if the most recent changes to a data browser column can be undone (using DataBrowser:Undo()).
      </summary>
      <returns>
        TRUE if the operation can be undone; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.DataBrowser.Caption">
      <summary>
        A string representing the caption of the data browser for use in its title bar.
      </summary>
      <value>A string representing the caption of the data browser for use in its title bar.</value>
      <remarks>
        A string representing the caption of the data browser for use in its title bar.  By default, the data browser uses the caption defined in its hyperlabel.
        Assigning a blank caption (" ") causes the title bar to be displayed with no text.  Assigning a NULL_STRING causes the title bar to be hidden.  Note that by embedding newline (Chr(10)) characters in the caption string, the title bar changes height to accommodate multiple lines.
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.CellDoubleClick">
      <summary>
        Provide an event handler, called when the user double-clicks in a cell in the data browser.
      </summary>
      <remarks>
        As with all event handlers, this method is called automatically by the system.  The developer can override this method to customize the response to this event:  the standard response is to switch the cell into editing mode with the entire contents selected.  In addition, the cells allow editing immediately, accepting the first keystroke as the new cell contents.
      </remarks>
    </member>
    <member name="P:VO.DataBrowser.CellEdit">
      <summary>
        Returns the edit control for the current cell when the DataBrowser is in edit mode. Otherwise a NULL_OBJECT is returned.
      </summary>
      <value>The edit control for the current cell when the DataBrowser is in edit mode. Otherwise a NULL_OBJECT is returned.</value>
    </member>
    <member name="M:VO.DataBrowser.ChangeBackground(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a new background brush for this data browser.
      </summary>
      <param name="oBrush">The new background brush to be used.</param>
      <param name="kWhere">
        Indicates what part of the browser should be repainted, specified as one of the following constants:
      </param>
      <remarks>
        Indicates what part of the browser should be repainted, specified as one of the following constants:
        <pre>
          Constant      Description
          GBLCOLCAPTION The column caption area.
          GBLHITEXT     Highlighted (selected) text in the data area.
          GBLTEXT       Text in the data display area.
        </pre>
        The background color can be set for different parts of the data browser as a whole, but not for individual columns.  To set the background brush for individual columns, use DataColumn:ChangeBackground().
        As a rule, initial settings are picked up from the standard settings of the environment — under Windows, colors are set in the Control Panel.  Note that while it is possible to alter the color of the caption and column caption areas, this is not recommended when a 3-dimensional, sculpted, "button look" is used — end users can be confused if buttons don't look like buttons.
      </remarks>
      <example>
        To set the background of the text area to yellow and highlighted text to blue:
        <code language="X#">
          oDataBrowser:ChangeBackground(Brush{Color{COLORYELLOW}},GBLTEXT)
          oDataBrowser:ChangeBackground(Brush{Color{COLORBLUE}},GBLHITEXT)
        </code></example>
    </member>
    <member name="M:VO.DataBrowser.ChangeFont(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a new font in a particular area of the data browser.
      </summary>
      <param name="oFont">The new font to be used.</param>
      <param name="kWhere">
        Indicates what part of the browser should be changed, specified as one of the following constants:
        <pre>
          Constant        Description
          GBLCOLCAPTION   The column caption area.
          GBLTEXT         Text in the data display area.  This is the default.
        </pre></param>
      <returns>
        The font previously assigned to the changed area.
      </returns>
      <remarks>
        The font can be set for different parts of the data browser as a whole, but not for individual columns.  Initially, the default font is extracted from the browser's owner window.
      </remarks>
      <example>
        To use a Helvetica-type font in the text area and a bold version of the same font in the column caption area:
        <code language="X#">
          oDataBrowser:ChangeFont(Font{FONTSWISS8},GBLTEXT)
          oDataBrowser:ChangeFont(Font{FONTROMAN14},GBLCOLCAPTION)
        </code></example>
    </member>
    <member name="M:VO.DataBrowser.ChangeTextColor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a new pen in a particular area of the data browser.
      </summary>
      <param name="oColor">The new color to be used.</param>
      <param name="kColor">The standard color to be used, specified as one of the following constants in the table below</param>
      <param name="kWhere">Indicates what part of the browser should be changed, specified as one of constants in the table below</param>
      <returns>
        The pen previously assigned to the changed area.
      </returns>
      <remarks>
        Values for kColor
        <pre>
          Constant      Color
          COLORBLACK    Black
          COLORBLUE     Blue
          COLORCYAN     Cyan
          COLORGREEN    Green
          COLORMAGENTA  Magenta
          COLORRED      Red
          COLORWHITE    White
          COLORYELLOW   Yellow
        </pre>
        Values for kWhere
        <pre>
          Constant      Description
          GBLCOLCAPTION The column caption area.
          GBLHITEXT     Highlighted (selected) text in the data area.
          GBLTEXT       Text in the data display area.  This is the default.
        </pre>
        The text color can be set for different parts of the data browser as a whole, but not for individual columns.  To set the color for individual columns, use DataColumn:ChangeTextColor().
        As a rule, initial settings are picked up from the standard settings of the environment — under Windows, colors are set in the Control Panel.
      </remarks>
      <example>
        To set the text color in the main area to blue and highlighted text to red:
        <code language="X#">
          oDataBrowser:ChangeTextColor (Color{COLORBLUE},GBLTEXT)
          oDataBrowser:ChangeTextColor (Color{COLORRED},GBLHITEXT)
        </code></example>
    </member>
    <member name="M:VO.DataBrowser.Clear">
      <summary>
        If one or more cells in the data browser are selected, clear their contents; if only some characters in a cell are selected, remove only those characters.
      </summary>
      <remarks>
        The current selection can be a few characters in a cell, an entire cell's contents, several cells, several records, or nothing at all.
        <note type="tip">Clear() is not allowed if more than one record is selected.</note>
        Note that this method changes the fields to which this data browser's cells are linked and, therefore, the changes are subject to validation.  The operation leaves the cells blank, but required fields or other validation rules can mark the record as invalid.
        The operation performed by this method is the same action as is normally performed in standard GUI applications by the Edit Clear menu command (note that under Windows, this menu command is typically linked to the Delete key).  This standard behavior is automatically provided by X# and, therefore, there is no need to provide a special method for this (in fact, the Delete key works even if there is no menu command).  Systems like spreadsheets (which provide both clear and delete operations) link the Delete key to the Edit Clear menu command, not to the Edit Delete menu command.
        <note type="tip">Do not confuse clearing with deleting.  Clearing a structure (such as a cell or field) removes its contents.  Deleting a structure, on the other hand, removes the actual structure.</note></remarks>
    </member>
    <member name="M:VO.DataBrowser.ColPos">
      <summary>
        Return the position of the currently focused column.
      </summary>
    </member>
    <member name="P:VO.DataBrowser.ColumnCount">
      <summary>
        A numeric value indicating the number of columns in the data browser.
      </summary>
      <value>A numeric value indicating the number of columns in the data browser.</value>
    </member>
    <member name="M:VO.DataBrowser.ColumnFocusChange(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the column focus is changed.

      </summary>
      <param name="oDataColumn">The column that is gaining or losing focus.</param>
      <param name="lHasFocus">TRUE indicates the column is gaining focus; FALSE indicates the column is losing focus.</param>
      <remarks>
        When column focus is changed (i.e., the user moves from one column to another), typically there will be two events generated, thus ColumnFocusChange() will be called twice.  The first event will be for the previous column losing focus and the second event will be for the new column gaining focus.  You can trap either event by checking the value of &lt;lHasFocus&gt;.
      </remarks>
      <example>
        The following code demonstrates how the ColumnFocusChange handler can be used:
        <code language="X#">
          CLASS MyDataBrowser INHERIT DATABROWSER
          METHOD ColumnFocusChange(oDataColumn, lHasFocus) CLASS MyDataBrowser
          SUPER:FocusChange(oDataColumn, lHasFocus)
          IF lHasFocus
          TextBox{ SELF, oDataColumn:Name, "Gaining Focus"}:Show()
          ELSE
          TextBox{ SELF, oDataColumn:Name, "Losing Focus"}:Show()
          ENDIF
          RETURN SELF
        </code></example>
    </member>
    <member name="M:VO.DataBrowser.ColumnMoved(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a column is moved.

      </summary>
      <param name="oColumn">The column which was moved.</param>
    </member>
    <member name="M:VO.DataBrowser.ColumnReSize(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a column is resized.

      </summary>
      <param name="oColumn">The column which was resized.</param>
    </member>
    <member name="M:VO.DataBrowser.Copy">
      <summary>
        Copy the current selection in the data browser to the clipboard.
      </summary>
      <remarks>
        The current selection can be a few characters in a cell, an entire cell's contents, several cells, several records, or nothing at all.  If several cells are selected, they are copied to the clipboard in the standard tab-separated format accepted by spreadsheet and word processor products.
        The operation performed by this method is the same action as is normally performed in standard GUI applications by the Edit Copy menu command (note that under Windows, this menu command is typically linked to the Ctrl+C and/or Ctrl+Insert accelerators).  This standard behavior is automatically provided by X# and, therefore, there is no need to provide a special method for this (in fact, the accelerators work even if there is no menu command).
      </remarks>
    </member>
    <member name="P:VO.DataBrowser.CurrentColumn">
      <summary>
        The current data column in the data browser (i.e., the one that contains the cursor).
      </summary>
      <value>The current data column in the data browser (i.e., the one that contains the cursor).</value>
    </member>
    <member name="M:VO.DataBrowser.Cut">
      <summary>
        Cut the current selection in the data browser to the clipboard.
      </summary>
      <remarks>
        The current selection can be a few characters in a cell, an entire cell's contents, several cells, several records, or nothing at all.  If several cells are selected, they are cut to the clipboard in the standard tab-separated format accepted by spreadsheet and word processor products.
        <note type="tip">Cut() is not allowed if more than one record is selected.</note>
        Note that this method changes the fields to which this data browser's cells are linked and, therefore, the changes are subject to validation.  The operation leaves the cells blank, but required fields or other validation rules can mark the record as invalid.
        The operation performed by this method is the same action as is normally performed in standard GUI applications by the Edit Cut menu command (note that under Windows, this menu command is typically linked to the Ctrl+X and/or Shift+Insert accelerators).  This standard behavior is automatically provided by X# and, therefore, there is no need to provide a special method for this (in fact, the accelerators work even if there is no menu command).
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.Default(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DataBrowser.Destroy">
      <summary>
        Provide a method to de-instantiate a DataBrowser object.
      </summary>
      <remarks>
        This method can be used when a DataBrowser object is no longer needed.  DataBrowser:Destroy() de-instantiates the DataBrowser object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.Disable">
      <summary>
        Disable a data browser (until a subsequent call to DataBrowser:Enable()).
      </summary>
      <remarks>
        Disabled data browsers are not active and, therefore, they do not send events to their owner windows or receive input focus.  Note that a disabled data browser is dimmed.
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.Dispatch(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.DataBrowser.EditFont">
      <summary>
        Returns the edit font for the DataBrowser. This font can be changed with the ChangeFont() method.
      </summary>
      <value>The edit font for the DataBrowser. This font can be changed with the ChangeFont() method.</value>
    </member>
    <member name="M:VO.DataBrowser.Enable">
      <summary>
        Enable a data browser that was previously disabled.
      </summary>
      <remarks>
        Enabling a data browser allows it to generate events and to send the events to its owner window when the user manipulates the data browser.  It also allows the data browser to receive input focus.  The dimming of disabled data browsers is removed, and the data browser is restored to its normal appearance.
        By default, data browsers are enabled until disabled, so there is no need to call this Enable() method unless DataBrowser:Disable() was previously called.
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.EnableBorder(XSharp.__Usual)">
      <summary>
        Specify the border style of the data browser.
      </summary>
      <param name="kBorderType">
        The display style of the data browser window's border, specified as one of the constants in the table below
      </param>
      <remarks>
        <code>
          Values for kBorderType
          Constant	Description
          BTNOBORDER	No border.
          BTNONSIZINGBORDER	A single-line border that does not allow resizing.
          BTSIZINGBORDER	A border that allows resizing.  This is the default.
        </code>
        When autosizing is enabled for a data browser acting as a browse view for a data window, the data browser should not have a border because the window provides a sizing border.  When a data browser is acting as a regular control, a non-sizing border is most commonly used.
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.EnableColumnMove(XSharp.__Usual)">
      <summary>
        Enable/disable whether the user can move (rearrange) columns in the data browser with the mouse.  If this method is not called, the ability to move columns is enabled, by default.
      </summary>
      <param name="lAllowMove">TRUE allows column movement; FALSE disables it.  The default is TRUE.</param>
      <remarks>
        The user can rearrange the columns by simply dragging a column's caption area with the mouse.  For the purpose of reference from the program, the columns retain their original numbering, regardless of the visual position.
        Column movement is enabled/disabled at two levels:  the DataBrowser class level and the DataColumn class level.  If column movement is set at the browser level, DataBrowser:EnableColumnMove() can be used to enable/disable movement.  However, if column movement is enabled at the column level, this method can no longer be used.
        DataColumn:EnableColumnMove() must be used to change the setting.
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.EnableColumnReSize(XSharp.__Usual)">
      <summary>
        Enable/disable whether the user can resize columns in the data browser with the mouse.  If this method is not called, the ability to resize columns is enabled, by default.
      </summary>
      <param name="lAllowResize">TRUE allows column resizing; FALSE disables it.  The default is TRUE.</param>
      <remarks>
        The user can resize the columns by dragging on the boundary between the column caption areas with the mouse.
        Column movement is enabled/disabled at two levels:  the DataBrowser class level and the DataColumn class level.
        If column resizing is set at the browser level, DataBrowser:EnableColumnResize() can be used to enable/disable resizing.  However, if column resizing is enabled at the column level, this method can no longer be used.  DataColumn:EnableColumnResize() must be used to change the setting.
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.EnableColumnTitles(XSharp.__Usual)">
      <summary>
        Turn column titles on or off for the entire browser.
      </summary>
      <param name="lEnable">TRUE shows column titles; FALSE hides them. The default is TRUE. </param>
      <returns>
        A logical value indicating whether or not the operation was successful.
      </returns>
      <remarks>
        This method has been introduced to replace the functionality of calling DataColumn:SetCaption with a NIL argument, which is documented as removing the caption area from the column.  Since column caption areas cannot be removed from single columns, it must be done globally for the entire browser.
      </remarks>
      <example>
        The following example illustrates how DataBrowser:EnableColumnTitles may be used to suppress the display of column titles in a subform browser created via Window Editor-generated source code:
        <code language="X#">
          METHOD Init( oOwner ) CLASS DW_Detail_DataBrowser
          SUPER:Init( oOwner )
          SELF:EnableColumnTitles( FALSE )
          RETURN SELF
        </code></example>
    </member>
    <member name="M:VO.DataBrowser.EnableGrid(XSharp.__Usual)">
      <summary>
        Enable/disable the display of a grid.  If this method is not called, the grid is enabled, by default.
      </summary>
      <param name="lShowGrid">TRUE shows the grid; FALSE hides it.  The default is TRUE.</param>
    </member>
    <member name="M:VO.DataBrowser.EnableHorizontalScroll(XSharp.__Usual)">
      <summary>
        Enable/disable horizontal scrolling of a data browser.  If this method is not called, horizontal scrolling is enabled, by default.
      </summary>
      <param name="lAllowScroll">TRUE allows scrolling by displaying a horizontal scroll bar along the bottom edge of the data browser;  FALSE disables the scroll bar.  The default is TRUE.</param>
    </member>
    <member name="M:VO.DataBrowser.EnableHorizontalSplit(XSharp.__Usual)">
      <summary>
        Enable/disable a horizontal splitbar in the data browser.
      </summary>
      <param name="lShowSplit">
        TRUE enables (and shows) the splitbar; FALSE disables (and hides) it.  The default is TRUE.
        If this method is not called for a data browser, FALSE is the default.
      </param>
    </member>
    <member name="M:VO.DataBrowser.EnableVerticalScroll(XSharp.__Usual)">
      <summary>
        Enable/disable vertical scrolling of a data browser.  If this method is not called, vertical scrolling is enabled, by default.
      </summary>
      <param name="lAllowScroll">TRUE allows scrolling by displaying a vertical scroll bar along the right edge of the data browser;  FALSE disables the scroll bar.  The default is TRUE.</param>
    </member>
    <member name="M:VO.DataBrowser.EnableVerticalSplit(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Enable/disable a vertical splitbar in the data browser.
      </summary>
      <param name="lShowSplit">
        TRUE enables (and shows) the splitbar; FALSE disables (and hides) it.  The default is TRUE.
        If this method is not called for a data browser, FALSE is the default.
      </param>
      <param name="nMode">
        Initial splitbar positioning, specified as one of the following constants:
        If not specified, the initial splitbar position defaults to GBSSBMIDDLE.
      </param>
      <remarks>
        <pre>
          Constant      Description
          GBSSBLEFT     Places the splitbar at the left-edge of the browser.
          GBSSBMIDDLE   Places the splitbar in the middle of the browser.
          GBSSBRIGHT    Places the splitbar at the right-edge of the browser.
        </pre>
        A vertical splitbar allows the left and right parts of a window to be independently scrollable sideways.  The position of the splitbar in the window is also adjustable with the mouse.
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.Error(XSharp.__Usual)">
      <summary>
        Provide a method for handling error conditions raised during data browser processing.
        <note type="tip">This is an event handler and is automatically called by other methods; the developer does not normally need to call the DataBrowser:Error() method, but might want to override it.</note></summary>
      <param name="oErrorObj">An Error object describing the error condition.</param>
    </member>
    <member name="P:VO.DataBrowser.Font">
      <summary>
        The font to be used for the text area of the data browser.
      </summary>
      <value>The font to be used for the text area of the data browser.</value>
    </member>
    <member name="M:VO.DataBrowser.GetColumn(XSharp.__Usual)">
      <summary>
        Retrieve a specified column in this data browser.
      </summary>
      <param name="xColumnID">The name, number, or symbol of the column to be retrieved.</param>
      <returns>
        The specified data column or NIL if it could not be found.
      </returns>
    </member>
    <member name="M:VO.DataBrowser.Handle(XSharp.__Usual)">
      <summary>
        Return the handle for a data browser.
      </summary>
      <returns>
        A handle to the data browser, describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the data browser, which can then be used by Windows API calls.
      </remarks>
    </member>
    <member name="P:VO.DataBrowser.HiBackground">
      <summary>
        Returns the background brush for the Highlighted rows and cells in the Databrowser. This can be changed with the ChangeBackground() method.
      </summary>
      <value>The background brush for the Highlighted rows and cells in the Databrowser. This can be changed with the ChangeBackground() method.</value>
    </member>
    <member name="M:VO.DataBrowser.Hide">
      <summary>
        Hide a data browser so it is not visible.
      </summary>
      <remarks>
        The data browser remains hidden from display until the DataBrowser:Show() method is called.
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.NewRow">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DataBrowser.Notify(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        An event handler that reflects events that have occurred in the server connected to this data browser.

      </summary>
      <param name="kNotification">Identifies the event, specified as one of the following constants:</param>
      <param name="uDescription">Used only with some notification types.</param>
      <returns>
        NIL except if NOTIFYINTENTTOMOVE is specified for &lt;kNotifyName&gt;.  In this case, the return value is TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <include file="VOSDK_Classes.xml" path="doc/commonblocks/notify/*" />
      </remarks>
    </member>
    <member name="P:VO.DataBrowser.Origin">
      <summary>
        A point representing the location of the data browser on its owner window, in canvas coordinates.
      </summary>
      <value>A point representing the location of the data browser on its owner window, in canvas coordinates.</value>
    </member>
    <member name="P:VO.DataBrowser.Owner">
      <summary>
        The owner window of the data browser.
      </summary>
      <value>The owner window of the data browser.</value>
    </member>
    <member name="M:VO.DataBrowser.Paste">
      <summary>
        Paste the current contents of the clipboard into the current data browser cell.
      </summary>
      <remarks>
        How clipboard data is pasted into the data browser depends on the following:
        The current selection

        The current selection can be a few characters in a cell, an entire cell's contents, several cells, several records, or nothing at all.

        If a few characters or an entire cell is selected, the selected characters are overwritten with the pasted data.  Note that in this case, the standard tab-separated format accepted by spreadsheet and word processor products is used, as long as the shape of the selection matches.

        If nothing is selected, the clipboard data is inserted into the current cell (i.e., the one containing the cursor).  Note that the data is inserted before the cursor.

        <note type="tip">Paste() is not allowed if more than one record is selected.</note>

        The Insert key
        Note that this method changes the fields to which this data browser's cells are linked and, therefore, the changes are subject to validation.  The operation leaves the cells blank, but required fields or other validation rules can mark the record as invalid.
        The operation performed by this method is the same action as is normally performed in standard GUI applications by the Edit Paste menu command (note that under Windows, this menu command is typically linked to the Ctrl+V and/or Shift+Insert accelerators).  This standard behavior is automatically provided by X# and, therefore, there is no need to provide a special method for this (in fact, the accelerators work even if there is no menu command).
      </remarks>
    </member>
    <member name="P:VO.DataBrowser.Pointer">
      <summary>
        The Pointer object to be used in the text area of the data browser.
      </summary>
      <value>The Pointer object to be used in the text area of the data browser.</value>
    </member>
    <member name="F:VO.DataBrowser.ptrControlDefaultProc">
      <exclude />
    </member>
    <member name="M:VO.DataBrowser.Refresh">
      <summary>
        Forces the contents of the data browser to be updated from the data server.
      </summary>
    </member>
    <member name="M:VO.DataBrowser.RemoveColumn(XSharp.__Usual)">
      <summary>
        Remove a column from this data browser.
      </summary>
      <param name="uColumnOrIndex">The name, number, or symbol representing the column to be removed.</param>
      <returns>
        The removed data column, if successful; otherwise, NULL_OBJECT.
      </returns>
      <remarks>
        When a column is deleted, the reference numbers for any trailing columns are decremented.  This is one reason why columns should be referenced by name, rather than number.
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.RestoreUpdate">
      <summary>
        Update this data browser visually and restore standard operation (after DataBrowser:SuspendUpdate() is called).
      </summary>
      <remarks>
        DataBrowser:SuspendUpdate() is used to reduce "visual noise" during a multi-record update of the data browser from its data server.  When the updating is complete, use the DataBrowser:RestoreUpdate() method to refresh the display and reactivate standard behavior.
        Note that DataBrowser:SuspendUpdate() stacks its invocations.  Therefore, for each call to DataBrowser:SuspendUpdate(), there needs to be a corresponding call DataBrowser:RestoreUpdate().
      </remarks>
    </member>
    <member name="P:VO.DataBrowser.RowCount">
      <summary>
        A numeric value indicating the number of rows in the data browser.
      </summary>
      <value>A numeric value indicating the number of rows in the data browser.</value>
    </member>
    <member name="M:VO.DataBrowser.SetCaption(XSharp.__Usual)">
      <summary>
        Set the caption for the data browser title bar.
      </summary>
      <param name="cText">The text to be used as the caption. </param>
      <param name="symText">The symbol to be used as the caption.</param>
      <remarks>
        Setting a blank caption ("") causes the title bar to be displayed with no caption.  Setting a null caption causes the title bar to be hidden.
        By embedding newline characters in the caption string, the title bar changes height to accommodate multiple lines.
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.SetColumn(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Replace an existing column in the data browser with another column.
      </summary>
      <param name="oDataColumn">The new data column.</param>
      <param name="nColumnNumber">The column to be replaced.  The number must be within the range of columns in the data browser; this method does not append a column at the end.</param>
      <returns>
        The replaced data column, if successful; otherwise, NULL_OBJECT.
      </returns>
    </member>
    <member name="M:VO.DataBrowser.SetColumnFocus(XSharp.__Usual)">
      <summary>
        Set the column focus to a specified data column.
      </summary>
      <param name="oColumn">The column that the focus will be set to.  If omitted, the default is NULL_OBJECT; the focus will not be changed.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.DataBrowser.SetPointer(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a new pointer to be used when the mouse moves over a particular area of the data browser.
      </summary>
      <param name="oPointer">The new pointer to be used.  If not specified, the default pointer is POINTERARROW.</param>
      <param name="kWhere">Indicates what part of the browser should be changed, specified as one of the following constants</param>
      <param name="Constant">Description</param>
      <param name="GBLCAPTION">The browser caption area.  This is only visible if you first set a Browser caption.</param>
      <param name="GBLCOLCAPTION">The column caption area.</param>
      <param name="GBLTEXT">Text in the data display area.  This is the default.</param>
    </member>
    <member name="M:VO.DataBrowser.SetStandardStyle(XSharp.__Usual)">
      <summary>
        Set the appearance of the data browser's caption areas.
      </summary>
      <param name="kStyle">The style to set, specified as one of the following constants:</param>
      <remarks>
        <note type="tip">The DataBrowser:SetStandardStyle() method can be overridden by DataColumn:SetStandardStyle() for individual columns.</note>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>GBSCONTROL2D</term>
            <description>No sculpting, text on a flat rectangle.</description>
          </item>
          <item>
            <term>GBSCONTROL3D</term>
            <description>Sculpted three-dimensional buttons.</description>
          </item>
          <item>
            <term>GBSEDIT</term>
            <description>Make browser "editable" (turn off read-only style).</description>
          </item>
          <item>
            <term>GBSREADONLY</term>
            <description>Make browser read-only (text cannot be changed).</description>
          </item>
        </list>
        If not specified, the default style is sculpted, three-dimensional, and "editable."
        Tip:  To specify more than one style parameter, simply make more than one call.
        <note type="tip">The DataBrowserSetStandardStyle() can be overridden by the DataColumn:SetStandardStyle() for individual columns.</note></remarks>
    </member>
    <member name="M:VO.DataBrowser.Show">
      <summary>
        Show this data browser.
      </summary>
      <remarks>
        When a data browser is first shown, its connected data server can be traversed to build up its buffer of records.  When the data browser traverses the server, it uses the current server cursor location to get its first record.  It is up to the application to position the server prior to using it with a data browser.
      </remarks>
    </member>
    <member name="P:VO.DataBrowser.Size">
      <summary>
        A dimension representing the size of the data browser.
      </summary>
      <value>A dimension representing the size of the data browser.</value>
    </member>
    <member name="M:VO.DataBrowser.SuspendUpdate">
      <summary>
        Temporarily disable repainting of the data browser while data is being altered; painting resumes with a call to DataBrowser:RestoreUpdate().
      </summary>
      <remarks>
        This method is used to reduce "visual noise" during a multi-record update of the data browser from its data server.  For example, when reading a full screen of data, the appearance of the window is more pleasing if the screen updates occur all together.  When the updating is complete, use the DataBrowser:RestoreUpdate() method to refresh the display and reactivate standard behavior.
        Note that DataBrowser:SuspendUpdate() stacks its invocations.  Therefore, for each call to DataBrowser:SuspendUpdate(), there needs to be a corresponding call DataBrowser:RestoreUpdate().
      </remarks>
    </member>
    <member name="P:VO.DataBrowser.TextColor">
      <summary>
        The text color to be used for the text area of the data browser.
      </summary>
      <value>The text color to be used for the text area of the data browser.</value>
    </member>
    <member name="M:VO.DataBrowser.Undo">
      <summary>
        Undo recent changes to a row in the data browser.
      </summary>
      <remarks>
        There is normally little need to call this method, since it is automatically called from the data window.  The keyboard interface for a regular undo operation is automatically provided, but menu commands and toolbar items should also be provided on the window.
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.Use(XSharp.__Usual)">
      <summary>
        Connect the data browser to a data server in a client-server relationship.
      </summary>
      <param name="oServer">The data server to which this data browser should be connected.  If the data browser is already connected to a server, it is disconnected first.  If omitted, the data browser is disconnected from the data server.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">If the browser is used as a browse view of a data window, there is no reason to use this method; the browser is automatically connected to the server of the window it belongs to.</note>
        The DataBrowser:Use() method connects browser columns with fields of the data server based on matching names.  Any column that does not have an explicitly provided field specification and hyperlabel inherits the FieldSpec and HyperLabel objects from its data server field.
        If the data browser does not have any columns, the DataBrowser:Use() method automatically creates a layout with columns for all the fields in the server.
        DataBrowser:Use() also registers the data browser as a client of the server with the DataServer:RegisterClient() method.
      </remarks>
    </member>
    <member name="M:VO.DataBrowser.Validate">
      <summary>
        Determine whether the currently focused record is valid.
      </summary>
      <returns>
        TRUE if the record is valid; otherwise, FALSE.
      </returns>
    </member>
    <member name="T:VO.DataColumn">
      <summary>
        Create columns for use in a data browser.
      </summary>
      <remarks>
        A data column is not a control; it is a component of a data browser.  From a data management viewpoint, however, a data column is analogous to a control on a data window:  when the browser is connected to a server, each column is linked to a data field.
      </remarks>
    </member>
    <member name="M:VO.DataColumn.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a data column.
      </summary>
      <param name="nWidth">The initial width in which to display the column, in characters, or the FieldSpec object from which the width is extracted.  If not specified, the default is 16.</param>
      <param name="xColumnID">The name or symbolic name of the column or hyperlabel containing the name of the column and any optional annotation.</param>
    </member>
    <member name="P:VO.DataColumn.Alignment">
      <summary>
        One of the following constants representing the alignment of this data column:
      </summary>
      <value>One of the following constants representing the alignment of this data column:</value>
      <remarks>
        One of the following constants representing the alignment of this data column:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>GBAALIGNCENTER</term><description>Center aligned</description></item><item><term>GBAALIGNLEFT</term><description>
              Left aligned  (This is the <b>default</b> for text.)
            </description></item><item><term>GBAALIGNRIGHT</term><description>
              Right aligned   (This is the <b>default</b> for numeric data.)
            </description></item></list></remarks>
    </member>
    <member name="M:VO.DataColumn.AsString(XSharp.__Usual)">
      <summary>
        Return the current value in the current row of this data column as a formatted string.
      </summary>
      <param name="uParam">The value held in the current row of this data column.  </param>
      <remarks>
        This method returns the same as DataColumn:TextValue.  AsString() is the standard method provided by all objects, for returning some reasonable text when needed.
        Note that this string is formatted according to the picture clause held in the FieldSpec object inherited from the associated server field.
      </remarks>
    </member>
    <member name="P:VO.DataColumn.Background">
      <summary>
        The brush used for painting the background of this data column.
      </summary>
      <value>The brush used for painting the background of this data column.</value>
    </member>
    <member name="P:VO.DataColumn.Block">
      <summary>
        A code block associated with the data column.  If set, it is used to filter the data in/out of the data column.
      </summary>
      <value>A code block associated with the data column.  If set, it is used to filter the data in/out of the data column.</value>
      <example>
        This example sets the code block for a calculated Wages column where HoursWorked and HourlyRate are fields in your database.  These lines would appear inside your DataBrowser:Init() method:
        <code language="X#">
          oMyColumn:BlockOwner := SELF:Server	// The server object attached to the browser
          oMyColumn:Block := { | oVar | oVar:HoursWorked * oVar:HourlyRate }
          //where oVar is the BlockOwner
        </code></example>
    </member>
    <member name="P:VO.DataColumn.BlockOwner">
      <summary>
        The owner of the code block associated with the data column.  If a code block is assigned, this object will be called when the code block is evaluated.  For an example, see DataColumn:Block.
      </summary>
      <value>The owner of the code block associated with the data column.  If a code block is assigned, this object will be called when the code block is evaluated.  For an example, see DataColumn:Block.</value>
    </member>
    <member name="P:VO.DataColumn.Caption">
      <summary>
        A string representing the caption of this data column for use in its caption area.
      </summary>
      <value>A string representing the caption of this data column for use in its caption area.</value>
      <remarks>
        A string representing the caption of this data column for use in its caption area.  By default, the data column uses the caption defined in its hyperlabel.
        You can specify a caption in a manner similar to the DataBrowser:Caption property (for example, assigning a blank caption ("") causes the caption area to be displayed with no text).  Note that the height of the caption area is automatically made large enough to accommodate the captions of all columns in the owning data browser.
      </remarks>
    </member>
    <member name="P:VO.DataColumn.CellBackground">
      <summary>
        The Brush object used to paint the background of a cell if DataColumn:EnableCellDraw has been called.
      </summary>
      <value>The Brush object used to paint the background of a cell if DataColumn:EnableCellDraw has been called.</value>
      <remarks>
        The Brush object used to paint the background of a cell if DataColumn:EnableCellDraw has been called.  This object should not be a local variable of the cell-painting method supplied to DataColumn:EnableCellDraw.
      </remarks>
    </member>
    <member name="P:VO.DataColumn.CellTextColor">
      <summary>
        The Color object used to paint the text in a cell if DataColumn:EnableCellDraw has been called.
      </summary>
      <value>The Color object used to paint the text in a cell if DataColumn:EnableCellDraw has been called.</value>
      <remarks>
        The Color object used to paint the text in a cell if DataColumn:EnableCellDraw has been called.  This object should not be a local variable of the cell-painting method supplied to DataColumn:EnableCellDraw.
      </remarks>
    </member>
    <member name="M:VO.DataColumn.ChangeBackground(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a new background brush for this data column.
      </summary>
      <param name="oBrush">The new background brush to be used.</param>
      <param name="kWhere">
        Indicates what part of the data column should be repainted, specified as one of the following constants:
        <pre>
          Constant        Description
          GBLCOLCAPTION   The column caption area.
          GBLTEXT         Text in the data display area.  This is the default.
        </pre></param>
      <returns>
        The brush previously assigned to the changed area.
      </returns>
      <remarks>
        The setting specified here supersedes, for this data column, the setting set in this data column's owner data browser.  Although the button and caption area can be specified, the method refers only to this column.
        As a rule, initial settings are picked up from the standard settings of the environment — under Windows, colors are set in the Control Panel.  Note that while it is possible to alter the color of the caption and column caption areas, this is not recommended when a 3-dimensional, sculpted, "button look" is used — end users can be confused if buttons don't look like buttons.
      </remarks>
      <example>
        To set the background of the text area yellow and column caption blue:
        <code language="X#">
          oDataColumn:ChangeBackground(Brush{Color{COLORYELLOW}},	GBLTEXT)
          oDataColumn:ChangeBackground(Brush{Color{COLORBLUE}},GBLCOLCAPTION)
        </code></example>
    </member>
    <member name="M:VO.DataColumn.ChangeTextColor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a new pen in a particular area of this data column.
      </summary>
      <param name="oColor">The new color to be used.</param>
      <param name="kColor">
        Indicates the standard color to be used, specified as one of the following constants:
      </param>
      <param name="kWhere">
        Indicates what part of the data column should be changed, specified as one of the following constants.
      </param>
      <returns>
        The pen previously assigned to the changed area.
      </returns>
      <remarks>
        Possible values for kColor
        <pre>
          Constant      Color
          COLORBLACK    Black
          COLORBLUE     Blue
          COLORCYAN     Cyan
          COLORGREEN    Green
          COLORMAGENTA  Magenta
          COLORRED      Red
          COLORWHITE    White
          COLORYELLOW   Yellow
        </pre>
        Possible values for kWhere
        <pre>
          Constant        Description
          GBLCOLCAPTION   The column caption area.
          GBLTEXT         Text in the data display area.  This is the default.
        </pre>
        As a rule, initial settings are picked up from the standard settings of the environment — under Windows, colors are set in the Control Panel.
        The default is picked up from the standard settings of the environment; for example, under Windows the text color of buttons is set with the Control Panel.  Although the button and caption area can be specified, the method refers only to this column.
      </remarks>
      <example>
        To set the text color in the main area blue and caption text red:
        <code language="X#">
          oDataColumn:ChangeTextColor(Color{COLORBLUE},GBLTEXT)
          oDataColumn:ChangeTextColor(Color{COLORRED},GBLCOLCAPTION)
        </code></example>
    </member>
    <member name="M:VO.DataColumn.ClearStatus">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.DataColumn.DataField">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DataColumn.Destroy">
      <summary>
        Provide a method to de-instantiate a DataColumn object.
      </summary>
      <remarks>
        This method can be used when a DataColumn object is no longer needed.  DataColumn:Destroy() de-instantiates the DataColumn object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.DataColumn.DisableCellDraw">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DataColumn.DrawCellData(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="uValue">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.DataColumn.EnableCellDraw(XSharp.__Usual)">
      <summary>
        Enable the painting of individual cells by registering a cell-painting method.
      </summary>
      <param name="symMethodName">The symbolic name of the method that will be used to paint the cells in  this column.</param>
      <remarks>
        Enables the cells in this column to be painted according to a method supplied by the developer.  The method provided will be called whenever the cell is about to be painted.  The cell's usual value is passed to the method, and can be used to determine what text color and background brush should be used in painting, by assigning new values to DataColumn:CellTextColor and DataColumn:CellBackground, respectively.
      </remarks>
      <example>
        The following example shows how DataColumn:EnableCellDraw may be used to highlight past due accounts in the data browser:
        <code language="X#">
          CLASS ColorColumn INHERIT DataColumn
          PROTECT oValidTextColor	AS Color
          PROTECT oValidBackground	AS Brush
          PROTECT oInvalidTextColor	AS Color
          PROTECT oInvalidBackground AS Brush
          METHOD Init( oFieldSpec ) CLASS ColorColumn
          SUPER:Init( oFieldSpec )
          oValidTextColor := Color{ COLORWHITE }
          oValidBackground := Brush{ Color{ COLORBLUE } }
          oInvalidTextColor := Color{ COLORYELLOW }
          oInvalidBackground := Brush{ Color{ COLORRED } }
          RETURN SELF
          METHOD Init( oWindow, iCtlID, oServer ) CLASS ColorSubForm
          // some initialization code
          SELF:Browser := ColorSubForm_Browser{ SELF }
          oDBDUE_DATE := ColorColumn{ ACCOUNTS_DUE_DATE{} }
          oDBDUE_DATE:Width := 12
          oDBDUE_DATE:HyperLabel := oDCDUE_DATE:HyperLabel
          oDBDUE_DATE:Caption := "DueDate"
          SELF:Browser:AddColumn( oDBDUE_DATE )
          oDBDUE_DATE:EnableCellDraw( #ValidDateDraw )
          // more initialization code
          RETURN SELF
          METHOD ValidDateDraw( uValue ) CLASS ColorColumn
          IF uValue &lt; GetPastDueDate()
          SELF:CellTextColor := oValidTextColor
          SELF:CellBackground := oValidBackground
          ELSE
          SELF:CellTextColor := oInvalidTextColor
          SELF:CellBackground := oInvalidBackground
          ENDIF
          RETURN NIL
        </code></example>
    </member>
    <member name="M:VO.DataColumn.EnableColumnMove(XSharp.__Usual)">
      <summary>
        Enable/disable whether the user can move (rearrange) this data column with the mouse.  If the method is not called, the default behavior is determined by the data browser that owns this column.
      </summary>
      <param name="lAllowMove">TRUE allows column movement; FALSE disables it.  The default is TRUE.</param>
      <remarks>
        The user can rearrange the columns by simply dragging a column's caption area with the mouse.  For the purpose of reference from the program, the columns retain their original numbering, regardless of the visual position.
      </remarks>
    </member>
    <member name="M:VO.DataColumn.EnableColumnReSize(XSharp.__Usual)">
      <summary>
        Enable/disable whether the user can resize this data column with the mouse.  If this method is not called, the default behavior is determined by the data browser that owns this column.
      </summary>
      <param name="lAllowResize">TRUE allows column resizing; FALSE disables it.  The default is TRUE.</param>
      <remarks>
        The user can resize a column by dragging on the boundary between the column caption areas with the mouse.
      </remarks>
    </member>
    <member name="P:VO.DataColumn.FieldSpec">
      <summary>
        The FieldSpec object connected to this data column.
      </summary>
      <value>The FieldSpec object connected to this data column.</value>
      <remarks>
        The FieldSpec object connected to this data column.  This is used for validation purposes, as well as calculating default widths and alignment characteristics.
      </remarks>
    </member>
    <member name="M:VO.DataColumn.GetCaption">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DataColumn.GetEditObject(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oOwner">** missing parameter documentation **</param>
      <param name="iID">** missing parameter documentation **</param>
      <param name="oPoint">** missing parameter documentation **</param>
      <param name="oDim">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.DataColumn.GetModified">
      <summary>
        Determine whether the value in column has been modified.
      </summary>
      <returns>
        TRUE if the value in the column has been modified; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.DataColumn.GetValue">
      <summary>
        Get the value of the current data column.
      </summary>
    </member>
    <member name="P:VO.DataColumn.HyperLabel">
      <summary>
        The hyperlabel connected to this data column.
      </summary>
      <value>The hyperlabel connected to this data column.</value>
      <remarks>
        The hyperlabel connected to this data column.  From the hyperlabel, you can retrieve additional information about the data column — for example:
        <code language="X#">
          cCaption := oDataColumn:HyperLabel:Caption
          cDescription := oDataColumn:HyperLabel:Description
          cHelpContext := oDataColumn:HyperLabel:HelpContext
        </code></remarks>
    </member>
    <member name="M:VO.DataColumn.LinkDF(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Connect a column to a field in a data server.
      </summary>
      <param name="oDataServer">The server that the column is to be linked to.  Ordinarily, this is the common server that the entire window is linked to, but it is possible to link individual columns to other servers.</param>
      <param name="nFieldData">The number of the field within the server.</param>
      <remarks>
        DataColumn:LinkDF() should ordinarily not be called directly by the application. It is called by DataBrowser:Use(); Use() connects an entire client to an entire server.  You can use DataColumn:LinkDF() to link a column to a data field explicitly, perhaps if the column's name doesn't match the data field's name so the automatic linkage of DataBrowser:Use() doesn't work.
        It is even possible to use DataColumn:LinkDF() to link individual columns to different servers; however, this is not recommended, because none of the automatic behavior of the data window and none of its cooperation with the data server applies to more than one server.  Notifications will not be received for servers other than the main server that the window is registered with, and actions such as DataWindow:Delete() and DataWindow:Append() apply to the main server.  To link a window to more than one database, use the techniques described in the "GUI Classes" chapter of the Programmer's Guide.
      </remarks>
    </member>
    <member name="P:VO.DataColumn.Modified">
      <summary>
        A logical value indicating whether the contents of the current row of this data column has been changed by the user since it was last set.  TRUE indicates that it has changed (even if it has not yet been validated or has failed validation); FALSE indicates that it has not.
      </summary>
      <value>A logical value indicating whether the contents of the current row of this data column has been changed by the user since it was last set.  TRUE indicates that it has changed (even if it has not yet been validated or has failed validation); FALSE indicates that it has not.</value>
    </member>
    <member name="P:VO.DataColumn.Name">
      <summary>
        A string representing the name of this data column.
      </summary>
      <value>A string representing the name of this data column.</value>
    </member>
    <member name="P:VO.DataColumn.NameSym">
      <summary>
        A symbol representing the name of this data column.
      </summary>
      <value>A symbol representing the name of this data column.</value>
    </member>
    <member name="P:VO.DataColumn.Owner">
      <summary>
        The data browser that owns this data column.
      </summary>
      <value>The data browser that owns this data column.</value>
    </member>
    <member name="M:VO.DataColumn.PerformValidations">
      <summary>
        Perform all the validations defined to this data column's field specification (for example, required, maximum and minimum digits, maximum and minimum value, validation rule) and return the result of the test.
      </summary>
      <returns>
        If any of the validations fail, this method sets the status of the data column appropriately and returns FALSE.  Otherwise, it returns TRUE.
      </returns>
    </member>
    <member name="P:VO.DataColumn.PixelWidth">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.DataColumn.Server">
      <summary>
        The data server to which this data column is currently connected, if any.
      </summary>
      <value>The data server to which this data column is currently connected, if any.</value>
    </member>
    <member name="M:VO.DataColumn.SetCaption(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the caption for the data column.
      </summary>
      <param name="cText">The text to be used as the caption.  If omitted, the data browser uses the caption in the hyperlabel.</param>
      <param name="kAlignment">
        One of the following constants representing the alignment of the caption for the data column:
      </param>
      <remarks>
        <pre>
          Constant        Description
          GBAALIGNCENTER  Center aligned  (This is the default.)
          GBAALIGNLEFT    Left aligned
          GBAALIGNRIGHT   Right aligned

        </pre>
        Setting a blank caption ("") causes the caption of the data column to be displayed with no caption.  Setting a null caption causes the caption to be hidden.
        By embedding newline characters in the caption string, the caption field changes height to accommodate multiple lines.
      </remarks>
    </member>
    <member name="M:VO.DataColumn.SetModified(XSharp.__Usual)">
      <summary>
        Mark the current data column, signifying that it has been modified.
      </summary>
      <param name="lModified">Specify TRUE to mark the data column as modified; otherwise, FALSE.</param>
    </member>
    <member name="M:VO.DataColumn.SetStandardStyle(XSharp.__Usual)">
      <summary>
        Set the appearance of this data column's caption area.
      </summary>
      <param name="kStyle">
        The style to set, specified as one of the  constants below
      </param>
      <remarks>
        Constant	Description
        GBSCONTROL2D	No sculpting, text on a flat rectangle.
        GBSCONTROL3D	Sculpted three-dimensional buttons.
        GBSEDIT	Make browser 'editable' (turn off read-only style).
        GBSREADONLY	Make browser read-only (text cannot be changed).
        Tip:  To specify more than one style parameter, simply make more than one call
        <note type="tip">DataColumn:SetStandardStyle() can override the DataBrowser:SetStandardStyle() method for individual columns.</note></remarks>
    </member>
    <member name="M:VO.DataColumn.SetValue(XSharp.__Usual)">
      <summary>
        Set the value of the current data column.
      </summary>
      <param name="cNewValue">The new value to be assigned to the data column specified as a string.</param>
      <returns>
        A string representing the current value of the data column.
      </returns>
    </member>
    <member name="P:VO.DataColumn.Status">
      <summary>
        A hyperlabel that indicates the results of validations or recent actions to this data column.
      </summary>
      <value>A hyperlabel that indicates the results of validations or recent actions to this data column.</value>
      <remarks>
        A hyperlabel that indicates the results of validations or recent actions to this data column.
        If the validation passed or the operation was successful, this value is NULL_OBJECT; if not, it contains information about the cause of the error.
      </remarks>
    </member>
    <member name="P:VO.DataColumn.TextColor">
      <summary>
        The text color to be used for the text area of this data column.
      </summary>
      <value>The text color to be used for the text area of this data column.</value>
    </member>
    <member name="P:VO.DataColumn.TextValue">
      <summary>
        A string representing the value held in the current row of this data column.  Note that this string is formatted according to the picture clause held in the FieldSpec object inherited from the associated server field.
      </summary>
      <value>A string representing the value held in the current row of this data column.  Note that this string is formatted according to the picture clause held in the FieldSpec object inherited from the associated server field.</value>
    </member>
    <member name="P:VO.DataColumn.Value">
      <summary>
        The value held in the current row of this data column, in whatever data type is held in the FieldSpec object inherited from the associated server field.
      </summary>
      <value>The value held in the current row of this data column, in whatever data type is held in the FieldSpec object inherited from the associated server field.</value>
    </member>
    <member name="P:VO.DataColumn.ValueChanged">
      <summary>
        A logical value indicating whether the data column value has been changed to a "valid" value, since it was last set.
      </summary>
      <value>A logical value indicating whether the data column value has been changed to a "valid" value, since it was last set.</value>
      <remarks>
        A logical value indicating whether the data column value has been changed to a "valid" value, since it was last set.  TRUE indicates that it has been changed to a valid value; FALSE indicates that it has not.
      </remarks>
    </member>
    <member name="P:VO.DataColumn.VisualPos">
      <summary>
        Returns the number of the data column with respect to its visual position within a data browser from left to right.
      </summary>
      <value>The number of the data column with respect to its visual position within a data browser from left to right.</value>
      <example>
        The following example shows how DataColumn:VisualPos may be used to save the current layout of a browser to an .INI file:
        <code language="X#">
          METHOD SaveLayout() CLASS MySubForm
          LOCAL wCount AS DWORD
          LOCAL aColumnInfo := {} AS ARRAY
          LOCAL oDataColumn AS DataColumn
          FOR wCount := 1 UPTO SELF:Browser:ColumnCount
          oDataColumn := SELF:Browser:GetColumn( wCount )
          AADD( aColumnInfo, {oDataColumn:NameSym, oDataColumn:VisualPos} )
          NEXT wCount
          SaveSettings( aColumnInfo )
          RETURN NIL
        </code></example>
    </member>
    <member name="P:VO.DataColumn.Width">
      <summary>
        The width of this data column in canvas coordinates.
      </summary>
      <value>The width of this data column in canvas coordinates.</value>
    </member>
    <member name="T:VO.DataDialog">
      <summary>
        Create a data window that behaves like a modal dialog window (also commonly referred to as a dialog box).
      </summary>
      <remarks>
        Whereas a regular data window is an MDI child window, a data dialog window behaves like a modal dialog window.  This means that the user must respond to the window and close it before continuing with the application and that the data dialog window is not resizable.
        The main purpose of this class is to provide a way to create a window for small data entry tasks, such as password entry.
        Note that because the DataDialog class uses DialogWindow (rather than a ChildAppWindow) internally, AppWindow:EnableVerticalScroll() and AppWindow:EnableHorizontalScroll() are just stubs — they do not do anything.
      </remarks>
    </member>
    <member name="M:VO.DataDialog.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a data dialog window.
      </summary>
      <param name="oOwner">The window that owns the data dialog window.  The following window types can be owners:  App, ShellWindow, TopAppWindow, ChildAppWindow, DialogWindow, or DataWindow.</param>
      <param name="oSource">The ID of the resource that defines the layout of the data dialog window.  If not specified, the window automatically lays itself out when attached to a data server.</param>
      <param name="nResourceID">The resource ID that specifies the location and size of the sub-data window.  Specifying this argument creates the new data dialog window as a sub-data window on its owner data window (only data window owners can have sub-data windows).  It should refer to a control defined in the resource entity of the owner data window.</param>
      <param name="nDialogStyle">The style for the DataDialog border. Defaults to WS_DLGFRAME.</param>
    </member>
    <member name="T:VO.DataField">
      <summary>
        Create a field, which is an object that holds information that defines a particular field in a data server (for example, the field's data type and length).
      </summary>
      <remarks>
        A DataField object is a specific item in a database record.  This is in contrast to a FieldSpec object, which is a description of the properties that some field might have.
        For example, assume you want to create a FieldSpec object that defines an employee number and you have an EMPLOYEE database that has two different fields: EMPNO, which the employee's number (the employee whose record this is), and MGRNO, which is the number of that employee's manager.  Thus, you might define the FieldSpec object as follows:
        <code language="X#">
          CLASS EmployeeNumber INHERIT FieldSpec
          ...
        </code>
        and then in the database define two different fields as:
        <code language="X#">
          DataField{HyperLabel{#EmpNo, "Employee Number"}, ;
          EmployeeNumber{}}
          DataField{HyperLabel{#MgrNo, "Manager Number"}, ;
          EmployeeNumber{}}
        </code>
        Note that some of the field properties can appear redundant given the available FieldSpec properties.  For example, the field contains a hyperlabel, but the field's FieldSpec object also contains a hyperlabel.  Furthermore, the field's hyperlabel contains a symbolic name, and the FieldSpec's hyperlabel contains a symbolic name.
        However, this apparent redundancy serves a useful purpose.  A FieldSpec's hyperlabel identifies the general class of data (called #EmpNo in this example).  This name is often used as the standard name of fields of this type, but it does not have to be, because each particular field has a specific name — in the example above, #EmpNo and #MgrNo.
        A field, therefore, holds two "groups" of properties:
        General label information, like its name, caption, description, and help context ID
        Data type information, stored as a FieldSpec object, that includes data type, length, decimals, validation rules, error messages, diagnostics, and formatting rules
        In any case, all data-oriented objects in the system have a name and a hyperlabel, which are often shipped around the system for annotation and help purposes.
        <br />Important!  There is rarely a need for the developer to consider the fields directly as they are typically created through the code generated by the various data server editors.
      </remarks>
    </member>
    <member name="M:VO.DataField.#ctor(System.String,XSharp.VO.FieldSpec)">
      <summary>
        Construct a data field.
      </summary>
      <param name="oHLName">The name or symbol representing the field.</param>
      <param name="oFS">The FieldSpec object that defines the field's properties.  At a minimum, it must contain the data type and length of the field.</param>
    </member>
    <member name="M:VO.DataField.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a data field.
      </summary>
      <param name="oHLName">The hyperlabel containing the name of the field and any optional annotation.</param>
      <param name="oFS">The FieldSpec object that defines the field's properties.  At a minimum, it must contain the data type and length of the field.</param>
    </member>
    <member name="M:VO.DataField.AsString">
      <summary>
        Return the descriptive label defined for this field.
      </summary>
      <returns>
        The caption from this field's hyperlabel, if it contains one; otherwise, the field's name is returned.
      </returns>
    </member>
    <member name="P:VO.DataField.FieldSpec">
      <summary>
        The FieldSpec object connected to this field.
      </summary>
      <value>The FieldSpec object connected to this field.</value>
      <remarks>
        The FieldSpec object connected to this field.  From the FieldSpec object, you can, in turn, access its various properties that control the field's behavior and presentation.
        For example, the following invokes several FieldSpec access/assign methods of a field:
        <code language="X#">
          oDataField:FieldSpec:Type
          oDataField:FieldSpec:Length
          oDataField:FieldSpec:Decimals
          oDataField:FieldSpec:Validate(&lt;uValue&gt;)
        </code></remarks>
    </member>
    <member name="P:VO.DataField.HyperLabel">
      <summary>
        The hyperlabel connected to this field.
      </summary>
      <value>The hyperlabel connected to this field.</value>
      <remarks>
        The hyperlabel connected to this field.  From the hyperlabel, you can retrieve additional information about the field — for example:
        <code language="X#">
          cCaption := oDataField:HyperLabel:Caption
          cDescription := oDataField:HyperLabel:Description
          cHelpContext := oDataField:HyperLabel:HelpContext
        </code></remarks>
    </member>
    <member name="P:VO.DataField.Name">
      <summary>
        A string representing the name of the field.
      </summary>
      <value>A string representing the name of the field.</value>
      <remarks>
        A string representing the name of the field.  Note that the hyperlabel also contains a name; these two names are the same in the code generated by the DBServer Editor.
      </remarks>
    </member>
    <member name="P:VO.DataField.NameSym">
      <summary>
        A symbol representing the name of the field.
      </summary>
      <value>A symbol representing the name of the field.</value>
      <remarks>
        A symbol representing the name of the field.  Note that the field's hyperlabel also contains a symbolic name; these two names are the same in the code generated by the DBServer Editor.
      </remarks>
    </member>
    <member name="T:VO.DataListView">
      <summary>
        Create a data list view as a faster, read-only, standalone control and an alternative to a data browser.
      </summary>
      <remarks>
        A data list view is a "data-ware" list view control which serves as a fast, read-only alternative to a data browser.  Together with the list view column control, a data list view can be used inside the Window Editor to "paint" the browse view portion of a data window.  It can also be used as a standalone control.
        The DataListView control uses internally a virtual list view, which means that its speed is independent of the total number of records in your database.  Additionally, the scrollbar size and position always represents the position in the database correctly.
        The DataListView control relies on the OrderKeyCount(), OrderKeyGoto(), and OrderKeyNo() methods of the associated server.  If there is no active order, the DataListView control uses RecCount(), GoTo(), and RecNo() instead.  Additionally, the DataListView control has some limitations, depending on the currently active RDD:
        SetFilter is supported for NTX and CDX drivers only.
        SetDeleted(TRUE) is not supported for all RDDs.
        If you want to hide all deleted records, you should use SetDeleted(FALSE) and specify a data server filter condition like:
        <code language="X#">	SetFilter({|| !Deleted()}, "!Deleted()")</code>
        OrderScopes are supported for NTX and CDX drivers only.
        If you want to use a DataListView control as a replacement for a DataBrowser control, set the Browser Inherits From property in the Window Editor to DataListView.  The generated code will then reference DataListView.
        <note type="tip">Choosing a DataListView control as a replacement for a DataBrowser control has an additional advantage:  your applications will not need the CATO3xxx.DLL support DLLs.</note>
        The DataListView control can also be used as a standalone control that can be placed on any window or dialog.  In this case, you have to explicitly assign a data server to the DataListView:Server property.
      </remarks>
    </member>
    <member name="M:VO.DataListView.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a data list view.
      </summary>
      <param name="oOwner">The window that owns the data list view.</param>
      <param name="xID">The unique ID for the data list view (between 1 and 8000).</param>
      <param name="nResourceID">The resource ID of the data list view.</param>
      <param name="oPoint">The origin of the data list view in canvas coordinates.</param>
      <param name="oDimension">The dimension of the data list view in canvas coordinates.</param>
      <param name="kStyle">The style of the data list view.</param>
    </member>
    <member name="M:VO.DataListView.DeleteAll">
      <summary>
        Delete all items in a data list view.
      </summary>
      <returns>
        TRUE if all items were deleted successfully; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.DataListView.Destroy">
      <summary>
        Provide a method to de-instantiate a DataListView object.
      </summary>
      <remarks>
        This method can be used when a DataListView object is no longer needed.  DataListView:Destroy() de-instantiates the DataListView object, and allows you to close and free any resources that were opened or created by the object without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.DataListView.FIELDGET(XSharp.__Usual)">
      <summary>
        Return the contents of a specified field of the data server associated with the data list view.
      </summary>
      <param name="nFieldPos">The name, number, or symbol representing the desired field.</param>
      <returns>
        The field's contents.  The data type of the return value depends on the data type of the field.
      </returns>
      <remarks>
        By default, the FieldGet() method of the associated server is called.  By subclassing DataListView, this functionality can be changed or enhanced.  This is the recommended way of creating calculated (virtual) columns with a DataListView control
      </remarks>
    </member>
    <member name="M:VO.DataListView.Notify(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Provide an event handler that reflects events that have occurred in the server connected to this data list view.

      </summary>
      <param name="kNotification">Identifies the event, specified as one of the following constants:</param>
      <param name="uDescription">Used only with some notification types, as described above.</param>
      <returns>
        NIL, except if NOTIFYINTENTTOMOVE is specified for &lt;kNotifyName&gt;.  In this case, the return value is TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <include file="VOSDK_Classes.xml" path="doc/commonblocks/notify/*" />
      </remarks>
    </member>
    <member name="P:VO.DataListView.Owner">
      <summary>
        The owner of this DataListView control.
      </summary>
      <value>The owner of this DataListView control.</value>
    </member>
    <member name="M:VO.DataListView.Refresh">
      <summary>
        Force the contents of the data list view to be updated from the data server.
      </summary>
    </member>
    <member name="P:VO.DataListView.Server">
      <summary>
        The data server associated with the data list view.
      </summary>
      <value>The data server associated with the data list view.</value>
    </member>
    <member name="M:VO.DataListView.Use(XSharp.__Usual)">
      <summary>
        Associate a data server with the data list view.
      </summary>
      <param name="oNewServer">The data server to be associated with the data list view.</param>
      <returns>
        TRUE, if the server could be assigned successfully; otherwise, FALSE.
      </returns>
      <remarks>
        This method is equivalent to the DataListView:Server assign, which associates a data server with the data list view.
      </remarks>
    </member>
    <member name="T:VO.DataServer">
      <summary>
        Provide the base class from which all X# data servers are subclassed.
      </summary>
      <remarks>
        <br />Important!  DataServer is an abstract class and should not be used directly — instead, use one of its subclasses, which include DBServer and SQLSelect.  The documentation in this class is provided for the purposes of creating a DataServer subclass and details the data server entities that should be implemented for a consistent interface to other X# components (for example, a data window).
        This abstract class defines the common protocol — properties and behavior — used by the various X# data servers.  These data servers provide an object-oriented interface to databases in many contexts, but they are particularly useful as drivers for the DataWindow class.  For example, any class that derives from DataServer can be connected as a server to a data window or data browser.
      </remarks>
    </member>
    <member name="M:VO.DataServer.#ctor">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DataServer.Append">
      <summary>
        Append a blank record to the end of this data server (the new record becomes the current position and is ready for assignment of data values).
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">The details of the implementation of this method, as well as how it interacts with other operations (such as unique indexes and concurrency control), depend on the particular data server subclass.</note>
      </remarks>
    </member>
    <member name="M:VO.DataServer.AsString">
      <summary>
        Return the descriptive label defined for this data server.
      </summary>
      <returns>
        The caption from this data server's hyperlabel, if it contains one; otherwise, the data server's name is returned.
      </returns>
    </member>
    <member name="P:VO.DataServer.BoF">
      <summary>
        A logical value indicating whether this data server is positioned at the beginning of the file, on the first record (TRUE if yes, FALSE if no).
      </summary>
      <value>A logical value indicating whether this data server is positioned at the beginning of the file, on the first record (TRUE if yes, FALSE if no).</value>
    </member>
    <member name="P:VO.DataServer.Clients">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.DataServer.Close">
      <summary>
        Close down the server in a manner specific to the database used.
      </summary>
      <returns>
        TRUE if the operation was successful; FALSE if not. (How can closing down a server be unsuccessful?  If you are accessing a database over a network, and the network goes down before the server is closed, the DataServer:Close() operation may be the first one to fail, but it is still important to respond to this failure since it may indicate that database changes are not committed.)
      </returns>
    </member>
    <member name="M:VO.DataServer.Commit">
      <summary>
        Force all pending updates to this data server to be permanently written to disk.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        DataServer:Commit() can fail for many reasons, ranging from a lack of capability in the server to lock conflicts and technical problems, such as network crashes.  Use the DataServer:Status property to determine the exact cause of the failure.
        The exact implications of this action depend on the type of the data server.  With some database management systems, the method commits all servers using the same connection; with others, it commits only this server; and with yet others, the method does nothing.  In addition, some SQL servers have other implications of a commit operation (they can close cursors, for example).
        <note type="tip">You should carefully study the documentation for your database management system.</note></remarks>
    </member>
    <member name="P:VO.DataServer.ConcurrencyControl">
      <summary>
        A constant, identifying the mode of automatic concurrency control for this data server, determining when and how records are locked and released:
      </summary>
      <value>A constant, identifying the mode of automatic concurrency control for this data server, determining when and how records are locked and released:</value>
      <remarks>
        One of the following constants, identifying the mode of automatic concurrency control for this data server, determining when and how records are locked and released:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>CCNONE</term><description>The data server provides no automatic record locking; the application is required to do all locking explicitly. </description></item><item><term>CCOPTIMISTIC</term><description>
              No locks are maintained continuously except when appending — the record just appended is locked,
              and the lock is only released when moving off the record or explicitly calling the DataServer or DBServer Unlock() method.
              For all other records, the record is reread from disk before any update is done.  This is the <b>default</b>.
            </description></item><item><term>CCSTABLE</term><description>The record that the server is sitting on is always kept locked.</description></item><item><term>CCREPEATABLE</term><description>All records that have been read are maintained locked.  The user is guaranteed that when moving back among previously viewed data, they are unchanged.</description></item><item><term>CCFILE</term><description>All the records in the entire set provided by the server are locked throughout.  This is not very practical for windows associated with all the records of the server.  It is intended to be used in conjunction with method DataServer:SetSelectiveRelation(). </description></item></list></remarks>
    </member>
    <member name="M:VO.DataServer.DataField(XSharp.__Usual)">
      <summary>
        Retrieve the DataField object at a specified field position.
      </summary>
      <param name="nFieldPosition">The name, number, or symbol representing the desired field.</param>
    </member>
    <member name="P:VO.DataServer.DBStruct">
      <summary>
        An array containing the structure of this data server.
      </summary>
      <value>An array containing the structure of this data server.</value>
      <remarks>
        An array containing the structure of this data server.
        The structure of the data server is represented in an array, whose length (that is, number of elements) is equal to the number of fields in the server.  Each subarray is comprised of five elements, which contain the following information, in this order:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>DBS_NAME</term><description>cName</description></item><item><term>DBS_TYPE</term><description>cType</description></item><item><term>DBS_LEN</term><description>nLength</description></item><item><term>DBS_DEC</term><description>nDecimals</description></item><item><term>DBS_ALIAS</term><description>cAlias</description></item></list></remarks>
    </member>
    <member name="M:VO.DataServer.Delete">
      <summary>
        Delete the current record in this data server.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        When executed successfully, this method sends a NotifyDelete message to this data server's clients.
        <note type="tip">The details of the implementation of this method, and its requirements on concurrency control, depend on the particular data server subclass.</note></remarks>
    </member>
    <member name="P:VO.DataServer.EoF">
      <summary>
        A logical value indicating whether this data server is positioned at the end of the file, on the last record after an attempt to move beyond the last record (TRUE if yes, FALSE if no).
      </summary>
      <value>A logical value indicating whether this data server is positioned at the end of the file, on the last record after an attempt to move beyond the last record (TRUE if yes, FALSE if no).</value>
    </member>
    <member name="P:VO.DataServer.FCount">
      <summary>
        The number of fields in this data server.
      </summary>
      <value>The number of fields in this data server.</value>
    </member>
    <member name="M:VO.DataServer.FIELDGET(XSharp.__Usual)">
      <summary>
        Return the contents of a specified field in this data server.
      </summary>
      <param name="nFieldPosition">The name, number, or symbol representing the desired field.</param>
      <returns>
        The field's contents.  The data type of the return value depends on the data type of the field.
      </returns>
    </member>
    <member name="M:VO.DataServer.FieldGetFormatted(XSharp.__Usual)">
      <summary>
        Return the contents of a specified field in this data server, according to the formatting specifications of its FieldSpec.
      </summary>
      <param name="nFieldPosition">The name, number, or symbol representing the desired field.</param>
      <returns>
        The field's contents.
      </returns>
    </member>
    <member name="M:VO.DataServer.FieldHyperLabel(XSharp.__Usual)">
      <summary>
        Return the hyperlabel defined for a field in this data server.
      </summary>
      <param name="nFieldPosition">The name, number, or symbol representing the desired field.</param>
      <remarks>
        By accessing a field's hyperlabel, you can, in turn, access its various properties which annotate the field.  For example:
        <code language="X#">
          oDataServer:FieldHyperLabel(#LastName):Caption
          oDataServer:FieldHyperLabel(#LastName):Description
          oDataServer:FieldHyperLabel(#LastName):HelpContext
        </code></remarks>
    </member>
    <member name="M:VO.DataServer.FieldName(XSharp.__Usual)">
      <summary>
        Return the name of a field in this data server.
      </summary>
      <param name="nFieldPosition">The number of the desired field.</param>
    </member>
    <member name="M:VO.DataServer.FieldPos(XSharp.__Usual)">
      <summary>
        Return the position of a field in this data server.
      </summary>
      <param name="nFieldPosition">The name of the desired field.</param>
    </member>
    <member name="M:VO.DataServer.FIELDPUT(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Assign a value to a field in this data server.
      </summary>
      <param name="nFieldPosition">The name, number, or symbol representing the desired field.</param>
      <param name="uValue">The value to be assigned to the field.  The data type of this value must match the data type of the field.</param>
      <returns>
        The newly assigned value if the operation was successful; otherwise, NIL.
      </returns>
    </member>
    <member name="M:VO.DataServer.FieldSpec(XSharp.__Usual)">
      <summary>
        Return the FieldSpec object for a field in this data server.
      </summary>
      <param name="nFieldPosition">The number representing the desired field.</param>
      <remarks>
        By referencing the attributes of a field's FieldSpec object, the individual properties and methods of the field can be accessed.  For example:
        <code language="X#">oDataServer:FieldSpec(1):Description</code>
        For more information on FieldSpecs, refer to "Defining Data Servers and FieldSpecs" in the IDE User Guide and "Data Server Classes" in the Programmer's Guide.
      </remarks>
    </member>
    <member name="M:VO.DataServer.FieldStatus(XSharp.__Usual)">
      <summary>
        Determine the status of a field in this data server after the last operation.
      </summary>
      <param name="nFieldPosition">The name, number, or symbol representing the desired field.</param>
      <returns>
        A HyperLabel object if any error condition had occurred or if a validation has failed, NIL if everything is OK, if the validation passed, or if there has been no validation attempt.
      </returns>
      <remarks>
        In particular, DataServer:FieldStatus() can be used to find out more about a validation failure.  By accessing the properties of this hyperlabel, you can retrieve not only a description of the condition that was raised, but also context-sensitive help on it.  For example:
        <code language="X#">
          oDataServer:FieldStatus(#LastName):Caption
          oDataServer:FieldStatus(#LastName):Description
          oDataServer:FieldStatus(#LastName):HelpContext
        </code></remarks>
    </member>
    <member name="M:VO.DataServer.FieldSym(XSharp.__Usual)">
      <summary>
        Return the symbolic name of a field in this data server.
      </summary>
      <param name="nFieldPosition">The name, number, or symbol representing the desired field.</param>
    </member>
    <member name="M:VO.DataServer.FieldValidate(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Perform all the validations defined to the FieldSpec of a field in this data server (for example, required, maximum and minimum digits, maximum and minimum value, validation rule) and return the result of the test.
      </summary>
      <param name="nFieldPosition">The name, number, or symbol representing the desired field.</param>
      <param name="uValue">The value that is to be validated.  Its data type should be compatible with the data type of the specified field.  If the type cannot be converted to the appropriate data type, it is considered to have failed validation.</param>
      <returns>
        FALSE if any of the validations fail; otherwise, TRUE.
      </returns>
    </member>
    <member name="M:VO.DataServer.FLOCK">
      <summary>
        Lock this entire data server for exclusive access.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.DataServer.GoBottom">
      <summary>
        Position this data server at the last record.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        When executed successfully, this method sends a NotifyGoBottom message to this data server's clients.
      </remarks>
    </member>
    <member name="M:VO.DataServer.GoTo(XSharp.__Usual)">
      <summary>
        Position this data server on a specified record number.
      </summary>
      <param name="nPosition">The record number to which the server should be positioned.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        When executed successfully, this method sends a NotifyRecordChange message to this data server's clients.
        <note type="tip">Some types of data servers cannot support movement by record number.</note></remarks>
    </member>
    <member name="M:VO.DataServer.GoTop">
      <summary>
        Position this data server at the first record.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        When executed successfully, this method sends a NotifyGoTop message to this data server's clients.
      </remarks>
    </member>
    <member name="P:VO.DataServer.HLStatus">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="P:VO.DataServer.HyperLabel">
      <summary>
        The hyperlabel connected to this data server.  From the hyperlabel, you can retrieve additional information about the data server
      </summary>
      <value>The hyperlabel connected to this data server.  From the hyperlabel, you can retrieve additional information about the data server</value>
      <example>
        <code language="X#">
          cCaption := oDataServer:HyperLabel:Caption
          cDescription := oDataServer:HyperLabel:Description
          cHelpContext := oDataServer:HyperLabel:HelpContext
        </code>
        This property can also be used to assign a HyperLabel object to a data server, although this is most commonly done during instantiation of the data server.
      </example>
    </member>
    <member name="P:VO.DataServer.Name">
      <summary>
        A string representing the name of this data server.
      </summary>
      <value>A string representing the name of this data server.</value>
    </member>
    <member name="P:VO.DataServer.NameSym">
      <summary>
        A symbol representing the name of this data server.
      </summary>
      <value>A symbol representing the name of this data server.</value>
    </member>
    <member name="M:VO.DataServer.NoIVarGet(XSharp.__Usual)">
      <summary>
        Provide a general error interception that is automatically called (in any class) whenever an access reference is made to a non-existent exported instance variable.  In the DataServer class, it is used to implement the virtual field variable.
        <br />Important!  NoIVarGet() should not be called directly; it is called by the system for handling invalid references.
      </summary>
      <param name="symFieldName">The symbolic name of the variable that was referenced.  In the standard usage of the method with the DataServer class, this is a field name.</param>
      <remarks>
        For DataServer, this method is used to intercept references to field names as exported variables, which ordinarily would not be allowed.  If the field name is valid, it calls DataServer:FieldGet() for the corresponding field name, in effect turning database fields into access methods of each DBServer object.  See "Objects, Classes, and Methods" in the Programmer's Guide for more information on NoIVarGet().
      </remarks>
    </member>
    <member name="M:VO.DataServer.NoIVarPut(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Provide a general error interception that is automatically called (in any class) whenever an assignment reference is made to a non-existent exported instance variable.  In the DataServer class, it is used to implement the virtual field variable.
        <br />Important!  NoIVarPut() should not be called directly; it is called by the system for handling invalid references.
      </summary>
      <param name="symFieldName">The symbolic name of the variable that was referenced.  In the standard usage of the method with the DBServer class, this is a field name.</param>
      <param name="uValue">The value to be assigned to the field.  The data type of this value must match the data type of the field.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        When executed successfully, this method sends a NotifyFieldChange message to this data server's clients.
        For DataServer, this method is used to intercept references to field names as exported variables, which ordinarily would not be allowed.  If the field name is valid, it does a DataServer:FieldPut() for the corresponding field name with the passed value (in effect, turning database fields into assign methods of each DBServer object).  See "Objects, Classes, and Methods" in the Programmer's Guide for more information on NoIVarPut().
      </remarks>
    </member>
    <member name="M:VO.DataServer.Notify(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        An event handler that responds to events that have occurred in methods of this server, or in other servers that are linked to this server in some way.  The standard implementation notifies all the server's clients of the event.
        Description
        <br />Important!  This method is automatically called by the various action methods of the data server, and should normally not be called by application code.
      </summary>
      <param name="kNotification">Identifies the event, specified as one of the following constants:</param>
      <param name="uDescription">Used only with some notification types.</param>
      <returns>
        SELF, except if NOTIFYINTENTTOMOVE is specified for &lt;kNotifyName&gt;.  In this case, the return value is TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <include file="VOSDK_Classes.xml" path="doc/commonblocks/notify/*" />
      </remarks>
    </member>
    <member name="M:VO.DataServer.PostInit">
      <summary>
        Implement customized initialization code for the window.
      </summary>
      <remarks>
        This method is used to customize the initialization code for a dataserver.  
        The customized initialization code will not be overridden by the generated default initialization code.
        A call to PostInit() is automatically generated at the end of the Init() method.
      </remarks>
    </member>
    <member name="M:VO.DataServer.PreInit">
      <summary>
        Implement customized initialization code for the server.
      </summary>
      <remarks>
        This method is used to customize the initialization code for a server.  
        The customized initialization code will not be overridden by the generated default initialization code.
        A call to PreInit() is automatically generated at the beginning of the Init() method.  
        The default implementation of PostInit() in this class is empty.
        <note type="tip">
          In .Net it is normally not allowed or recommended to run code in a class before the parent constructor is called.
          The generated code in the Window editor does this (it calls PreInit before the SUPER() call). We advise you to
          be very careful not to touch protected instance variables inherited from parent classes, since these may not be
          initialized and/or values that you assign to them may be overwritten in the constructor of the parent class.
        </note></remarks>
    </member>
    <member name="P:VO.DataServer.RecCount">
      <summary>
        A numeric value representing the number of records in this data server.
      </summary>
      <value>A numeric value representing the number of records in this data server.</value>
      <remarks>
        <note type="tip">Some types of data servers may not be able to provide this number.  If a failure does occur, -1 is returned.</note>
      </remarks>
    </member>
    <member name="P:VO.DataServer.RecNo">
      <summary>
        A numeric value representing the current record number, identifying the position of the record pointer in this data server.
      </summary>
      <value>A numeric value representing the current record number, identifying the position of the record pointer in this data server.</value>
      <remarks>
        A numeric value representing the current record number, identifying the position of the record pointer in this data server.
        Assigning a value to DataServer:RecNo is equivalent to executing DataServer:GoTo(); both reposition the record pointer on the given record.
        <note type="tip">Some types of data servers cannot support movement by record number.</note></remarks>
    </member>
    <member name="M:VO.DataServer.RegisterClient(XSharp.__Usual)">
      <summary>
        Register an object as a client of this data server, so that it receives notification messages from the server about certain actions.
      </summary>
      <param name="oForm">The object to be registered as a client of this data server (for example, a data window or a data browser).  Any object that provides a Notify() method can register itself as a client.</param>
    </member>
    <member name="M:VO.DataServer.ResetNotification">
      <summary>
        Resume the broadcasting of Notify messages to the server's attached clients (after DataServer:SuspendNotification() has been called).
      </summary>
      <remarks>
        This method is used in conjunction with DataServer:SuspendNotification(), which suspends the broadcasting of Notify messages.
        Note that DataServer:SuspendNotification() stacks its invocations.  Therefore, for each call to DataServer:SuspendNotification(), there needs to be a corresponding call DataServer:ResetNotification().
      </remarks>
    </member>
    <member name="M:VO.DataServer.RLOCK(XSharp.__Usual)">
      <summary>
        Lock a specific record in this data server for exclusive write access; other users can still make read-only reference to the record.
      </summary>
      <param name="nRecord">The ID (usually a record number) of the record to be locked.  If specified, record locks held by the current process are retained.  If not specified, all locks held by the current process are released and the current record is assumed.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.  Note that FALSE is returned even if the record was successfully locked but other record locks cannot be maintained.
      </returns>
      <remarks>
        When specified with an argument, RLock() does not release records locks held by the current process.  Instead, it adds the newly locked record to the lock list.
        <note type="tip">Some data servers cannot support the maintenance of multiple record locks or even the lock of a record other than the current one based on a record number.</note></remarks>
    </member>
    <member name="M:VO.DataServer.RLockVerify">
      <summary>
        Determine if the current record in this data server has any pending updates and lock it for exclusive write access if there are none.
      </summary>
      <returns>
        TRUE if the record is unchanged and the lock was successfully taken; otherwise, FALSE.
      </returns>
      <remarks>
        This method checks for pending updates to the current record by comparing the values that were read to the record when the server was initially positioned on the record with the current values in the corresponding database record.
        If the values match, it signifies that no other user has modified the data since the user started working on it, and, therefore, that it is safe to lock the record and let the user continue with an update transaction.  (Note that when locked, other users can still make read-only reference to the record.)
        If the values do not match, somebody else has changed the record, and the user should refresh the values from disk and  restart the transaction.  The application has to decide what to do about values that are different.  Note that DataServer:Status can be used to determine the reason for the failure.
        This method is used for optimistic concurrency control.  See "Concurrency Control" in the Programmer's Guide for more information.)
      </remarks>
    </member>
    <member name="M:VO.DataServer.Rollback">
      <summary>
        Undo the changes made to this data server within the current transaction.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method can fail for many reasons, from a lack of capability in the server to lock conflicts to technical problems such as network crashes.  Use DataServer:Status to determine the exact cause of the failure.
        Note that not all servers support this operation, including the standard Xbase DBServer.  If the server does support it, the exact implications of a rollback vary with the server.  With some database management systems, the method rolls back all servers using the same connection; with others, it rolls back only this server.  In addition, some SQL servers have other implications of a rollback operation (they can close cursors, for example).
        <note type="tip">You should carefully study the documentation for your database management system.</note></remarks>
    </member>
    <member name="M:VO.DataServer.Seek(XSharp.__Usual)">
      <summary>
        Move to the next record having a specified key value in the controlling order.
      </summary>
      <param name="uValue">The value to be searched for.  The data type of the search expression should match the type of the controlling order.  If there is no controlling order, Seek() searches on the record number and is therefore equivalent to GoTo().</param>
      <returns>
        TRUE if the specified key value was found; otherwise, FALSE.  Note that a FALSE value can indicate either that the value was not found or that the server does not support this search operation.  Use the DataServer:Status property to determine the reason for a failure.
      </returns>
    </member>
    <member name="M:VO.DataServer.SetDataField(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Assign a DataField object to a specified field in this data server.
      </summary>
      <param name="nFieldPosition">The number of the data field.</param>
      <param name="oDataField">The data field to be assigned.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        The data type of the new field must be compatible with the actual database field.
        This method is normally used only during instantiation of a data server (most often in Init() methods of subclasses).  For example, the code generated by the data server editors use this method.
      </remarks>
    </member>
    <member name="M:VO.DataServer.Skip(XSharp.__Usual)">
      <summary>
        Move the record pointer forward or backward in this data server a specified number of records.
      </summary>
      <param name="nRelativePosition">The number of records to move, relative to the current record.  A positive value means to move forward, and a negative value means to move backward.  The default is +1.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.  Note that a FALSE value can also indicate that beginning- or end-of-file was encountered.  Use the DataServer:Status property to determine the reason for a failure.
      </returns>
      <remarks>
        When executed successfully, this method sends a NotifyRecordChange message to this data server's clients.
        <note type="tip">Not all data servers are capable of moving backward.</note></remarks>
    </member>
    <member name="P:VO.DataServer.Status">
      <summary>
        A hyperlabel identifying the status of this data server after the last operation.
      </summary>
      <value>A hyperlabel identifying the status of this data server after the last operation.</value>
      <remarks>
        A hyperlabel identifying the status of this data server after the last operation.  If the last operation was successful, this value is NULL_OBJECT; if something went wrong (whether it raised an error condition or merely returned a failure code), DataServer:Status returns an informative hyperlabel.
        By accessing the properties of this hyperlabel, you can retrieve not only a description of the condition that was raised, but also context-sensitive help on the condition that was raised.
      </remarks>
      <example>
        The following examples invoke several DataServer:Status properties of the data server:
        <code language="X#">
          oDataServer:Status:Caption
          oDataServer:Status:Description
          oDataServer:Status:HelpContext
        </code></example>
    </member>
    <member name="M:VO.DataServer.SuspendNotification">
      <summary>
        Suspend the broadcasting of Notify messages to the server's attached clients.
      </summary>
      <remarks>
        This method is useful, for example, when the server is moving through the database and the server is ultimately restored to its original position.  Therefore, there is no reason to notify the clients of the server of a change in position within the database.
        Note that DataServer:SuspendNotification() stacks its invocations.  Therefore, for each call to DataServer:SuspendNotification(), there needs to be a corresponding call DataServer:ResetNotification().
      </remarks>
    </member>
    <member name="M:VO.DataServer.UnLock">
      <summary>
        Remove all locks held on this data server.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.DataServer.UnRegisterClient(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Remove the registration of an object as a client of this data server, so that it no longer receives notification messages from the server about certain actions.
      </summary>
      <param name="oClient">The object to unregister (for example, DataWindow or DataBrowser).</param>
      <param name="lAllowClose">
        TRUE closes the server if this is the last client registered with the server;
        FALSE does not close the server.  The default is TRUE.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE (including if the client was not previously registered).
      </returns>
    </member>
    <member name="M:VO.DataServer.Update">
      <summary>
        Update this server with data from another server or table.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE, although even with FALSE, some records may have been updated.  
        This can happen if the operation failed halfway through because of technical problems.
      </returns>
      <remarks>
        Sends a NotifyFileChange message upon completion.
        There are two different formulations of the matching relationship between the two servers.  
        If &lt;lRandomFlag&gt; is TRUE, this server must be indexed on the specified key, but the other server can be in any order; if &lt;lRandomFlag&gt; is not specified or is FALSE, both servers must be indexed or sorted on the specified key.  If there is more than one record in this server with matching key fields, only the first one is updated.
      </remarks>
    </member>
    <member name="T:VO.DataWindow">
      <summary>
        Create a data window which is capable of interacting intelligently with a data server.
      </summary>
      <remarks>
        Data windows combine the properties and behavior of both child windows and dialog windows, and add data-aware behavior that enables them to interact intelligently with data servers.  When connected to a data server, a data window forms a view of the server that allows for direct access and manipulation of the server's data.

        Unlike the other types of windows, a data window takes on different behavior depending on how it is used.  It adapts itself to the demands placed on it by its owner, behaving differently depending on the circumstances:
        If Owner Is	Data Window Acts Like
        ChildAppWindow	Modal DialogWindow
        DataWindow	Modal DialogWindow (if no placement is specified) or nested sub-data window (if placement is specified)
        DialogWindow	Modal DialogWindow
        ShellWindow	ChildAppWindow
        TopAppWindow	Modal DialogWindow

        A data window can be placed on a data window in an owner-child relationship (similar to other controls like check boxes and radio buttons).  When a data window is placed on another data window in this way, it is referred to as a sub-data window.  Note that only a data window can own a sub-data window because it is the only window type of window that can deal with data-related events.
        You can create a data window as a sub-data window when the data window is created.  You can optionally specify a third parameter (&lt;nResourceID&gt;), indicating that the new data window should be created as a control on a window by giving its location and size.  When placed like a control, the data window hides its border decoration and behaves like a sub-data window.  (If this parameter is omitted, the data window is created as a modal DialogWindow, not a sub-data window.)  See DataWindow:Init() for details.
        Tip:  Instead of newly creating a data window, you may prefer to use the Window Editor's Auto Layout feature which — at the touch of a button — automatically creates controls for every available field in a data window's associated data server(s).  See "Using the Window Editor" in the IDE User Guide.

        A data window is connected to a server with the Use() method.  When this connection is established, each control on the window is connected to a field in the data server based on matching names:  a field named CustName is connected to the control named CustName.  The control always reflects the current value of the data in the data server, and assigning a value to a control automatically propagates it to the server.
        Data windows can be associated with data servers in two ways:  in a single server or dual server (master detail) relationship.

        The Master-Detail option allows you to link a window to two data servers in a master-detail relationship.  In this case, a data window is created for the master server with a nested sub-data window for the detail server.
        The field list presented is taken from the Master data server.  The field that you choose is used to perform a SetSelectiveRelation() to the detail server based on its controlling order.  If you do not choose a field, the detail window is updated relative to the current record position in the master window.

        A data window can take on two different view modes:  form view, which contains individual controls for the data fields and browse view, which contains a spreadsheet-like data browser.  The data window can be initially displayed in either mode, and can be switched to the other mode at any time (using the DataWindow:ViewAs() method).  Any data window supports both appearances, although the developer can, of course, choose not to provide a way to select one mode or the other.
        The two view modes provide the same set of facilities:  the same data linkage facilities, the same display options, the same data manipulation methods.  From the perspective of the application, a data window has the same behavior and the same data properties regardless of view mode.

        The standard way of using a data window is to paint its layout in the Window Editor.  This produces a resource entity that specifies what controls the window has, and their locations, sizes, captions, and accelerators.  It also generates a data window subclass and an Init() method that associates names and further annotation with each control.  With such a predefined layout, the window is displayed very quickly and the methods of the window have enough information to act intelligently.

        A data window can also be created without a resource entity.  In this case, the layout of controls on the window is automatically generated when the window is connected to a data server.  After a layout is automatically generated, the window has exactly the same behavior that it has with a resource-based instantiation.
        If a data window is switched over to a new view mode, and the new mode has not been defined through a resource entity or programmatically, the data window automatically creates a layout based on the characteristics of the connected data server.  The new layout picks up all information about fields and controls that is known to the other view; thus, if complex validation rules, prompts, and help have been specified for the individual controls in form view, the columns of the browse view inherit the same properties.

        When a control is connected to a field in a data server, a value entered into the control or assigned to the appropriate name from the program is automatically propagated to the server.  Thus, after executing this statement:
        <code language="X#">oCustomerWindow:CustName := x</code>
        the CustName field in the server has the correct value.
        Values are propagated up from the data server to the data window when the server repositions itself, or when another window makes a change.  This requires no special action: after executing a Skip() method or assigning a value to a field, every window connected to the server is automatically updated to reflect the change.

        Data entered by the user is automatically validated using the rules of the field specification attached to a control or column.  (For more detail on the validation rules provided, see the FieldSpec class.)  If data fails the validation test, the data window will not propagate invalid information down to the server or to other windows, nor will it take any action that requires writing the invalid value to the server.
        In addition to the field-specific validations, the system allows the specification of a ValidateRecord() method for the window as a whole, for the purpose of cross-field validation.  This method, if provided, is called after all the fields have passed their individual validations.
        The data window also provides for registering controls that are subject to the validation status.  Such registered controls are disabled whenever the window's validation status is bad.

        The data window class also provides action methods that correspond to the general capabilities of all data servers: GoTop(), GoTo(), GoBottom(), SkipNext(), SkipPrevious(), Append(), Delete(), and so on.  The data window versions of these methods verify the validation status of the controls on the window.  If everything is valid, the window invokes the corresponding method of the data server.

        The data window provides built-in facilities for concurrency control, automatically taking and releasing record locks as appropriate.  Once the appropriate mode has been selected by assigning one of the available modes to DataWindow:ConcurrencyControl, record movements and changes use the concurrency control facilities of the data server to take and release locks.  If taking a lock fails because another user controls the record, the data window action fails.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a data window.
      </summary>
      <param name="oOwner">
        The window that owns the data window.  The following window types can be owners:  
        ShellWindow, TopAppWindow, ChildAppWindow, DialogWindow, DataDialog, or another DataWindow.
        The behavior of the data window is determined by the type of its owner — see the discussion of
        Adaptive Behavior in the description of this class.
      </param>
      <param name="oSource">
        The ID of the resource that defines the layout of the data window.  
        If not specified, the data window automatically lays itself out when attached to a data server.
      </param>
      <param name="nResourceID">
        The resource ID that specifies the location and size of the sub-data window.  
        Specifying this argument creates the new data window as a sub-data window on its owner data window
        (only data window owners can have sub-data windows).  It should refer to a control defined in the
        resource entity of the owner data window.
        If <paramref name="nResourceID" /> is omitted or if <paramref name="oOwner" /> is not a data window,
        the data window is created as a modal DialogWindow.
      </param>
      <param name="nDialogStyle">** missing parameter documentation **</param>
      <example>
        The following creates a data window and a data server, assigns the server to the window, and then displays the window:
        <code language="X#">
          ...
          oDWCust := DataWindow{oShell,"CustomerWindow"}
          oDWCustOrders := DBServer{SELF,"CustOrders",IDW_CUSTORDERS}
          oDWGeneric := DBServer{SELF}
          oDWGeneric:Use(DBServer{cFileName})
          oDWGeneric:Show()
        </code></example>
    </member>
    <member name="M:VO.DataWindow.Activate(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.DataWindow.AllowServerClose">
      <summary>
        A logical value specifying whether the server is automatically closed with the data window.  By default, this is set to TRUE in the DataWindow:Init() method.
      </summary>
      <value>A logical value specifying whether the server is automatically closed with the data window.  By default, this is set to TRUE in the DataWindow:Init() method.</value>
    </member>
    <member name="M:VO.DataWindow.Append">
      <summary>
        Append a blank record to the data server connected to this data window and position the window on this new record.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        When executed successfully, the data server to which the new record was appended sends a NotifyAppend
        message to all of its clients, including this data window.
        DataWindow:Append() can fail for many reasons (for example, data entered in the window fails validation,
        record locks failed because another user controls the data server, or access to the database failed for
        technical reasons).  Use the DataWindow:Status property to determine the exact cause of the failure.  
        You might also want to check the feasibility of the operation beforehand, using methods like DataWindow:StatusOK().
      </remarks>
    </member>
    <member name="P:VO.DataWindow.AutoScroll">
      <summary>
        A data window scrolls automatically to any control which gains focus while tabbing, even if the control is not visible (for example, when the window is resized).  By setting AutoScroll to FALSE, this automatic scrolling behavior is blocked.
      </summary>
      <value>A data window scrolls automatically to any control which gains focus while tabbing, even if the control is not visible (for example, when the window is resized).  By setting AutoScroll to FALSE, this automatic scrolling behavior is blocked.</value>
    </member>
    <member name="P:VO.DataWindow.Background">
      <summary>
        The background brush currently in use by this data window.

        The background brush currently in use by this data window.
        A window's background brush is used by CanvasErase() and in handling Expose events.  Assigning a new background brush has no effect until the data window (or portion of the data window) is redrawn.  If a data window was partially covered and is then fully exposed, only the covered part of the data window is redrawn and only that part gets the new background.
      </summary>
      <value>
        The background brush currently in use by this data window.

        The background brush currently in use by this data window.
        A window's background brush is used by CanvasErase() and in handling Expose events.  Assigning a new background brush has no effect until the data window (or portion of the data window) is redrawn.  If a data window was partially covered and is then fully exposed, only the covered part of the data window is redrawn and only that part gets the new background.
      </value>
    </member>
    <member name="P:VO.DataWindow.Browser">
      <summary>
        The DataBrowser object to use when this data window is displayed in browse view.
      </summary>
      <value>The DataBrowser object to use when this data window is displayed in browse view.</value>
      <remarks>
        The DataBrowser object to use when this data window is displayed in browse view.
        A data window does not necessarily need to own a particular data browser.  If a data window has no browser and the application chooses to view it in browse mode, X# automatically creates a browser for the window, populating it with one column for each field in the server.  The column headings are taken from the server, using the hyperlabels of its fields.
      </remarks>
    </member>
    <member name="P:VO.DataWindow.BrowserClass">
      <summary>
        A symbol specifying the class used for the data window's browse mode.  Valid values are:  #DATABROWSER, #DATALISTVIEW, or any user-defined class.
        The default is #DATABROWSER.
      </summary>
      <value>
        A symbol specifying the class used for the data window's browse mode.  Valid values are:  #DATABROWSER, #DATALISTVIEW, or any user-defined class.
        The default is #DATABROWSER.
      </value>
    </member>
    <member name="M:VO.DataWindow.ButtonClick(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a check box, push button, or radio button is clicked with the mouse.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlEvent">The ControlEvent object that describes which button was clicked.</param>
      <seealso cref="T:VO.ControlEvent" />
      <remarks>
        Button click events are propagated to the data window's owner the same way as menu events.  
        For an in-depth discussion on command event propagation, refer to the Programmer's Guide.
        You must supply the code to turn a radio button on (and all the other radio buttons off)
        when a user clicks on a radio button.  Similarly, you must also be sure to invert the state of a check box when it is clicked.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.Cancel">
      <summary>
        Discard all information entered in this data window and close the window.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        The "cancel" operation is very clear and easily understood and might be profitably used on
        data windows when they are created as MDI children (unconventional or not).
        Note that a user might be unclear on exactly what transactions are discarded.  
        For example, if several records have been modified, the default implementation
        of DataWindow:Cancel() discards changes only to the current record.  
        You might want to label the button or menu command something else or provide a more comprehensive implementation.
        <note type="tip">
          DataWindow:Cancel() disconnects itself from the data server using
          DataServer:UnregisterClient() and tells the server that it can close itself if it has no other registered clients.  
          Explicitly forcing the server to close from a window is not recommended, since this can create future problems.  
          Modifications to the application can attach other clients to the server, and any one window should not
          disable other windows.
        </note></remarks>
    </member>
    <member name="M:VO.DataWindow.CanvasErase">
      <summary>
        Erase the current canvas area of this data window and repaint it using either the background brush or the system's default background color.
      </summary>
    </member>
    <member name="M:VO.DataWindow.ChangeFont(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Change the font used by this datawindow.
      </summary>
      <param name="oFont">The new font to be used.</param>
      <param name="lUpdate">
        Specify TRUE to resize and reposition all controls in this dialog window and change their fonts; otherwise, FALSE.  
        If omitted, the default is FALSE.
      </param>
      <returns>
        The font previously assigned to the datawindow.
      </returns>
    </member>
    <member name="M:VO.DataWindow.CheckStatus">
      <summary>
        Test the information currently displayed in the controls in this data window to see if it passes all validation
        rules defined to the connected server.
      </summary>
      <returns>
        TRUE if the window passes all validation checks; otherwise, FALSE.
      </returns>
      <remarks>
        This method invokes DataWindow:StatusOK() which validates the information for each control in the window.
        If a validation check fails, use the DataWindow:Status property to determine the exact cause of the failure.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.Clear">
      <summary>
        Clear the current selection in this data window.
      </summary>
      <remarks>
        If the data window is in form view, the contents of the edit control is cleared; if in browse view, the contents
        of the selected cell(s) or part of a cell in the data browser is cleared.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.ClearRelations">
      <summary>
        Clear all relations defined to this data window's server.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        In data windows, relations are used to manage relationships between windows that are linked to the same data server.  
        Clearing a relation removes the link between the windows; in actuality, it clears the relations set for the data server to which this and any other windows are connected.  Relations are set using DataWindow:SetRelation() and DataWindow:SetSelectiveRelation().
      </remarks>
    </member>
    <member name="P:VO.DataWindow.Clipper Keys">
      <summary>
        A logical value indicating that the CA-Clipper navigation keys (i.e., the Direction and Return keys) are to be used for this dialog window (TRUE if yes, FALSE if no).
      </summary>
      <value>A logical value indicating that the CA-Clipper navigation keys (i.e., the Direction and Return keys) are to be used for this dialog window (TRUE if yes, FALSE if no).</value>
    </member>
    <member name="P:VO.DataWindow.ClipperKeys">
      <summary>
        A logical value indicating that the Clipper navigation keys (i.e., the Direction and Return keys) are to be used for this data window (TRUE if yes, FALSE if no).
      </summary>
      <value>A logical value indicating that the Clipper navigation keys (i.e., the Direction and Return keys) are to be used for this data window (TRUE if yes, FALSE if no).</value>
    </member>
    <member name="M:VO.DataWindow.Close(XSharp.__Usual)">
      <summary>
        Invoked just as the data window is about to close.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oEvent">An event required to maintain the protocol that all event handlers have exactly one event as their argument.</param>
      <seealso cref="T:VO.Event" />
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method is not used to close a data window.  Use DataWindow:Hide() to make a data window disappear from view,
        but remain available for re-opening; use DataWindow:Destroy() to permanently destroy the data window.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.Commit">
      <summary>
        Force all pending updates to this data window's server to be permanently written to disk.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method also makes the changes visible to other users on other machines on a network, as well as to other
        applications on the same machine.  Prior to DataWindow:Commit(), the changes are guaranteed to be visible
        only to other data windows connected to the same server within the same application.
        DataWindow:Commit() can fail for many reasons, from a lack of capability in the server to lock conflicts to
        technical problems, such as network crashes.  Use the DataServer:Status property to determine the exact cause of the failure.
        You should also note that there is no guarantee that changes which have not been committed can be rolled back.  
        The rollback capabilities depend on the particular data server implementation (for example, SQLSelect can usually
        do it — depending on the particular SQL database in use — but DBServer cannot).  
        For details, please refer to the documentation on the specific server you intend to use.
      </remarks>
    </member>
    <member name="P:VO.DataWindow.ConcurrencyControl">
      <summary>
        A constant, identifying the mode of automatic concurrency control for this data window, determining when and how records are locked and released:
      </summary>
      <value>A constant, identifying the mode of automatic concurrency control for this data window, determining when and how records are locked and released:</value>
      <remarks>
        One of the following constants, identifying the mode of automatic concurrency control for this data window, determining when and how records are locked and released:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>CCNONE</term><description>The data window provides no automatic record locking; the application is required to do all locking explicitly. </description></item><item><term>CCSTABLE</term><description>The record that the window is sitting on is always kept locked.  Note that when in browse view, the row that the cursor is on represents the current record.</description></item><item><term>CCOPTIMISTIC</term><description>
              No locks are maintained continuously except when appending — the record just appended is locked, and the lock is only
              released when moving off the record or explicitly calling the DataServer or DBServer Unlock() method.  
              For all other records, the record is reread from disk before any update is done.  This is the <b>default</b>.
            </description></item><item><term>CCREPEATABLE</term><description>All records that have been read are maintained locked.  The user is guaranteed that when moving back among previously viewed data, they are unchanged.</description></item><item><term>CCFILE</term><description>All the records in the entire set provided by the server are locked throughout.  This is not very practical for windows associated with all the records of a server, since it would correspond to a file lock.  It is intended to be used in conjunction with method DataWindow:SetSelectiveRelation(). </description></item></list></remarks>
    </member>
    <member name="P:VO.DataWindow.ContextMenu">
      <summary>
        The context menu attached to the window
      </summary>
      <value>The context menu attached to the window</value>
      <remarks>
        This can be used in two ways.
        The DataWindow and its Browser usually share the same ContextMenu and in this situation the assign can be used like this –
        <code language="X#">&lt;oDataWindow&gt;:ContextMenu := MyContextMenu{}</code>
        If you want the context menus to be different you can now use code like this –
        <code language="X#">&lt;oDataWindow&gt;:[ContextMenu,#FormView] := MyContextMenu{}</code>
        to just set the FormView context menu, and this –
        <code language="X#">&lt;oDataWindow&gt;:[ContextMenu,#BrowseView] := MyOtherContextMenu{}</code>
        to set the BrowseView context menu.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.ControlFocusChange(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.DataWindow.Controls">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DataWindow.Copy">
      <summary>
        Copy the current selection in this data window to the clipboard.
      </summary>
      <remarks>
        If the data window is in form view, the contents of the edit control is copied; if in browse view,
        the contents of the selected cell(s) or part of a cell in the data browser is copied.
      </remarks>
    </member>
    <member name="P:VO.DataWindow.CurrentControl">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.DataWindow.CurrentView">
      <summary>
        A symbol representing the view mode of the data window, as #BrowseView or #FormView.
      </summary>
      <value>A symbol representing the view mode of the data window, as #BrowseView or #FormView.</value>
    </member>
    <member name="M:VO.DataWindow.Cut">
      <summary>
        Delete the current selection in this data window and copy it to the clipboard.
      </summary>
      <remarks>
        If the data window is in form view, the contents of the edit control is cut; if in browse view, the contents of the selected cell(s) or part of a cell in the data browser is cut.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.DeActivate(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DataWindow.DeactivateAllOLEObjects(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.DataWindow.DeferUse">
      <summary>
        A logical value specifying whether the Use() operation for connecting the data window to the associated server should be deferred until the data window is first displayed.
      </summary>
      <value>A logical value specifying whether the Use() operation for connecting the data window to the associated server should be deferred until the data window is first displayed.</value>
      <remarks>
        A logical value specifying whether the Use() operation for connecting the data window to the associated server should be deferred until the data window is first displayed.  This is useful, for example, in a situation where multiple data windows build up pages for a tab control.  The default is FALSE.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.Delete">
      <summary>
        Delete the current record in the attached server and update the window based on the change.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        When executed successfully, the data server from which the record was deleted sends a NotifyDelete message to all of its clients, including this data window.
        With some servers (notably DBServer), a deleted record is not removed from the server but is simply marked as deleted.  Marked records are removed only when the file is packed, and until such time can be recalled.  (With DBServer, the current setting of the SetDeleted() function affects whether deleted records are visible.)  Changes that have been made to fields are recorded in the record before it is deleted; if the field is subsequently recalled, it correctly reflects any changes made before the delete operation.
        <note type="tip">DataWindow:Delete() advances to the next record (if SetDeleted() is TRUE) after the deletion takes place, unlike DBServer:Delete() which does not.</note>
        DataWindow:Delete() does not check validation status before allowing a delete operation.  If the window contains invalid data, it is discarded and the delete operation is completed.  If you would prefer to validate before deletion, use DataWindow:DeleteValidated().
        <note type="tip">Do not confuse clearing with deleting.  Clearing a structure (such as a record or field) removes its contents.  Deleting a structure, on the other hand, removes the actual structure.</note></remarks>
    </member>
    <member name="M:VO.DataWindow.DeleteValidated">
      <summary>
        Delete the current record in the attached server only if it passes its validation rules and update the window based on the change.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        When executed successfully, the data server from which the record was deleted sends a NotifyDelete message to all of its clients, including this data window.
        This method checks validation status before allowing a delete operation.  If the window contains invalid data, the user is asked if the data should be discarded or corrected before the delete operation is continued.  If this behavior is not desired (perhaps because the application does not use recall or the window is to be used only with servers that do not support recall of deleted records), use DataWindow:Delete().
        With some servers (notably DBServer), a deleted record is not removed from the server but is simply marked as deleted.  Marked records are removed only when the file is packed, and until such time can be recalled.  (With DBServer, the current setting of the SetDeleted() function affects whether deleted records are visible.)  Changes that have been made to fields are recorded in the record before it is deleted; if the field is subsequently recalled, it correctly reflects any changes made before the delete operation.
        <note type="tip">Do not confuse clearing with deleting.  Clearing a structure (such as a record or field) removes its contents.  Deleting a structure, on the other hand, removes the actual structure.</note></remarks>
    </member>
    <member name="M:VO.DataWindow.Destroy">
      <summary>
        Free memory resources allocated for a window and its derived objects.
      </summary>
      <remarks>
        This method immediately frees resources for DataWindow objects created explicitly in your application.  DataWindow:Destroy() also takes care of resources allocated to derived classes and deallocates them in the necessary order.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.DisableConditionalControls">
      <summary>
        Disable those controls in this data window that have been registered with RegisterConditionalControls().
      </summary>
      <remarks>
        This method disables all controls that have been registered with DataWindow:RegisterConditionalControls(), which registers controls as being subject to validation.  It is automatically called by DataWindow:Prevalidate() whenever the window fails validation.  This way, all registered controls are guaranteed to be unavailable whenever the window is known to be in an invalid state.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.Dispatch(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DataWindow.Draw(XSharp.__Usual)">
      <summary>
        Display a Draw object on this data window.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oDrawObject">The object to be drawn.</param>
      <param name="aoDrawObject">The array of objects to be drawn.</param>
      <remarks>
        A Draw object is drawn by placing the device context or presentation space into the Draw object and then calling the Draw object's method Draw().  This is the only valid way of drawing a Draw object on a window.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.EditChange(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the text in an edit control is changed.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlEvent">The ControlEvent object that describes which edit control was changed.</param>
      <seealso cref="T:VO.ControlEvent" />
      <remarks>
        This method is called every time the contents of an edit control is changed.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.EnableConditionalControls">
      <summary>
        Enable those controls that have been registered with RegisterConditionalControls().
      </summary>
      <remarks>
        This method enables all controls that have been registered with DataWindow:RegisterConditionalControls(), which registers controls as being subject to validation.  It is automatically called by DataWindow:Prevalidate() whenever the window's validation status is OK.  This way, all registered controls are guaranteed to be available whenever the window is known to be in a valid state.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.EnableDragDropClient(XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DataWindow.EnableStatusBar(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DataWindow.EnableToolTips(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DataWindow.Error(XSharp.__Usual)">
      <summary>
        Provide a method for handling error conditions raised during data window processing.
      </summary>
      <param name="oErrorObj">An Error object describing the error condition.</param>
      <remarks>
        <note type="tip">This is an event handler and is automatically called by other methods; the developer does not normally need to call the DataWindow:Error() method, but might want to override it.</note>
      </remarks>
    </member>
    <member name="M:VO.DataWindow.Expose(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked whenever part of the data window needs repainting.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oExposeEvent">The ExposeEvent object that describes which area of the data window needs repainting.</param>
      <remarks>
        This is one of the most important event handlers.  A data window requires repainting when the data window:
        <list type="bullet"><item>Is partially uncovered by another window</item><item>Is first shown</item><item>Increases in size</item><item>Is being restored after being iconized</item><item>The data window should retain enough information to redraw the screen as it was (or as it should be).</item></list>
        An ExposeEvent is also triggered by calling Repaint() or Update(); you should not call Repaint() or Update() during the Expose().
      </remarks>
    </member>
    <member name="M:VO.DataWindow.FIELDGET(XSharp.__Usual)">
      <summary>
        Retrieve the current value of the indicated control in this data window (and the data server field associated with this control, if any).
      </summary>
      <param name="uFieldID">The name, number, or symbol representing the desired field.</param>
      <returns>
        The field's contents.  The data type of the return value depends on the data type of the field.
      </returns>
      <remarks>
        In data windows, controls (such as edit controls and check boxes) can be linked to the fields in the connected data server.  Since the name of the control and the field are the same, FieldGet() can also be used to retrieve a control that is not connected to a server.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.FIELDPUT(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the value of the control in this data window (and the data server field associated with this control, if any).
      </summary>
      <param name="uFieldId">The name, number, or symbol representing the field that is referenced.</param>
      <param name="uNewValue">The value to be assigned to the field.  The data type of this value must match the data type of the field.</param>
      <returns>
        The newly assigned value if the operation was successful; otherwise, NIL.
      </returns>
      <remarks>
        When executed successfully, the data server that received the updated value sends a NotifyFieldChange message to all of its clients, including this data window.
        In data windows, controls (such as edit controls and check boxes) can be linked to the fields in the connected data server.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.FocusChange(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the input focus changes from the current data window to another window (or vice versa).
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oFocusChangeEvent">The FocusChangeEvent object that identifies whether the focus is being gained or lost.</param>
      <remarks>
        If your data window uses cursors, you should hide the data window's cursor when the focus is changed to a different data window, and then show the cursor when the data window receives focus again.  This should be used in conjunction with the Activate() and Deactivate() event handlers.
      </remarks>
      <example>
        This example demonstrates how FocusChange() displays the cursor at the specified cursor position when focus is gained.  If the focus is lost, the cursor is hidden:
        <code language="X#">
          METHOD FocusChange(oFocusChangeEvt) CLASS MyDataWindow
            IF(oFocusChangeEvt:GotFocus())       // Gaining focus
               oMyCursor:Show()
               oMyCursor:ChangePos(oMyCursorPos)
            ELSE                     // Losing focus
               oMyCursorPos := oMyCursor:GetPos()
               oMyCursor:Hide()
            ENDIF
        </code></example>
    </member>
    <member name="P:VO.DataWindow.Foreground">
      <summary>
        The foreground brush currently in use by this data window.
      </summary>
      <value>The foreground brush currently in use by this data window.</value>
    </member>
    <member name="M:VO.DataWindow.GetAllChildren">
      <inheritdoc />
    </member>
    <member name="M:VO.DataWindow.GoBottom">
      <summary>
        Position the data server connected to this data window on the last logical record and update the window based on the change.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        When executed successfully, the data server sends a NotifyGoBottom message to all of its clients, including this data window.
        DataWindow:GoBottom() can fail for many reasons, from a lack of capability in the server to lock conflicts to technical problems, such as network crashes.  Use the DataServer:Status property to determine the exact cause of the failure.
        Note also that DataWindow:GoBottom(), like all repositioning operations, is subject to validation — if the current data in the window fails validation, it cannot be written out and the move is refused.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.GoTo(XSharp.__Usual)">
      <summary>
        Position the data server connected to this data window on a specified record number and update the window based on the change.
      </summary>
      <param name="nRecNo">The record number to which the data window should be positioned.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        When executed successfully, the data server sends a NotifyRecordChange message to all of its clients, including this data window.
        DataWindow:GoTo() can fail for many reasons, from a lack of capability in the server to lock conflicts to technical problems, such as network crashes.  Use the DataServer:Status property to determine the exact cause of the failure.
        Note also that DataWindow:GoTo(), like all repositioning operations, is subject to validation — if the current data in the window fails validation, it cannot be written out and the move is refused.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.GoTop">
      <summary>
        Position the data server connected to this data window on the first logical record and update the window based on the change.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        When executed successfully, the data server sends a NotifyGoTop message to all of its clients, including this data window.
        DataWindow:GoTop() can fail for many reasons, from a lack of capability in the server to lock conflicts to technical problems, such as network crashes.  Use the DataServer:Status property to determine the exact cause of the failure.
        Note also that DataWindow:GoTop(), like all repositioning operations, is subject to validation — if the current data in the window fails validation, it cannot be written out and the move is refused.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.HelpRequest(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the user requests help from the application using one of the available context-sensitive help mechanisms.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oHelpRequestEvent">The HelpRequestEvent object that describes which item help is being requested for.</param>
      <remarks>
        This event handler is invoked only if the help mechanism has been enabled for the current data window (or one of its owners).  The help mechanism is enabled by assigning a HelpDisplay object to the windows HelpDisplay property.
        The default implementation of this event handler is to display the help topic that is associated with the control, menu command, or window region with focus when the HelpRequestEvent was generated.  This is accomplished using HelpDisplay:Show(&lt;cKeyword&gt;), where &lt;cKeyword&gt; is either a HyperLabel:HelpContext property or a default keyword generated by this event handler in cases where a hyperlabel is not available.
        If there is no hyperlabel for an item, the keyword generated is as follows:
        A HELPCONTROL request generates the keyword Control_xxxx, where xxxx is the numeric ID of the control, in decimal.  For example, an OK push button might generate the keyword Control_101.
        A HELPMENU request generates the keyword Menu_xxxx, where xxxx is the "cleaned" text of the menu command.  The cleaned text has all leading and trailing spaces and the ampersand character (&amp;) removed.  In addition, all sequences of spaces are replaced by a single underscore, and the string is truncated at the first tab character.

        For example, the keyword generated for the menu command:
        Save &amp;As\tF3
        is
        Menu_Save_As
        A HELPWINDOW request generates one of the keywords listed in the table below, depending on the window region that has focus.
        Keyword	Window Region
        Window_Border	Border
        Window_Caption	Title bar
        Window_MaxBox	Maximize button
        Window_MinBox	Minimize button
        Window_SysMenuBox	System menu button
        Window_Unknown	Any area of the window not explicitly identified in this table
        Window_WindowCanvas	Canvas area

        <note type="tip">If the Window_Unknown keyword is generated, the default behavior of HelpRequest() is to display the Contents topic as defined in the HelpDisplay (that is, HelpDisplay:Show("HelpIndex")).</note>

        If a HELPWINDOW request is received, while DataWindow:HelpContext is defined, DataWindow:HelpRequest() uses the HelpContext property, regardless of the window region that has focus.
        Refer to the "GUI Classes" chapter in the Programmer's Guide for more information on programming an online help system for your application.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.Hide">
      <summary>
        Hide this data window so it is not visible.
      </summary>
      <remarks>
        The data window remains hidden from display until the Show() method is called.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.HorizontalScroll(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a horizontal scroll bar is scrolled.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oScrollEvent">The ScrollEvent object that describes the scroll type and new position.</param>
      <remarks>
        The default behavior for this event handler is to update the thumb position of the scrollbar; this can be changed using your own implementation of the handler.  This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects.  If the application has vertical scroll bars, use a WindowVerticalScrollBar event handler.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.HorizontalSlide(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DataWindow.HorizontalSpin(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DataWindow.InsertObject">
      <summary>
        Use the standard Insert Object dialog to insert an OLE object into the focused OLEObject of the data window.
      </summary>
      <remarks>
        DataWindow:InsertObject() displays the standard Insert Object dialog and allows the user to insert an OLE object into an OLEObject container, which currently must have the input focus.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.IsDialog">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DataWindow.KeyDown(XSharp.__Usual)">
      <summary>
        This method is inherited from the Window class but does not apply to DataWindow.
      </summary>
    </member>
    <member name="M:VO.DataWindow.KeyUp(XSharp.__Usual)">
      <summary>
        This method is inherited from the Window class but does not apply to DataWindow.
      </summary>
    </member>
    <member name="P:VO.DataWindow.LastFocus">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DataWindow.LineTo(XSharp.__Usual)">
      <summary>
        Draw a line on this data window (using the current pen) from the current pen position to a specified point.
      </summary>
      <param name="uPoint">The position where the line should end, in canvas coordinates, or an array of points, in canvas coordinates,  where the line should end, in which case DataWindow:LineTo() acts like a polyline method.</param>
      <remarks>
        The current pen position is updated to the line's ending position (as specified by &lt;oPoint&gt; or &lt;aoPoint&gt; ).
      </remarks>
    </member>
    <member name="M:VO.DataWindow.Links">
      <summary>
        Display the standard Links dialog.
      </summary>
      <remarks>
        DataWindow:Links() displays the standard Links dialog, allowing the user to manage all linked OLE objects.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.ListBoxClick(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when an item in a list box owned by this data window is double-clicked.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlEvent">The ControlEvent object that describes which list box contained the item that is double-clicked.</param>
      <seealso cref="T:VO.ControlEvent" />
    </member>
    <member name="M:VO.DataWindow.ListBoxSelect(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when an item in a list box owned by this data window is clicked.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlEvent">The ControlEvent object that describes which list box contained the item that was clicked.</param>
      <seealso cref="T:VO.ControlEvent" />
    </member>
    <member name="M:VO.DataWindow.MouseButtonDown(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DataWindow.MoveTo(XSharp.__Usual)">
      <summary>
        Move the current pen to a point on the data window's canvas area.
      </summary>
      <param name="oPoint">The position of the pen, in canvas coordinates.</param>
      <returns>
        A point representing the previous location of the pen, in canvas coordinates.
      </returns>
      <remarks>
        The pen location may not be remembered between event handlers.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.Notify(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        An event handler that reflects events that have occurred in the server connected to this data window.
        <br />Important!  Notify() is automatically called by the server, and should normally not be called by application code.
      </summary>
      <param name="kNotification">Identifies the event, specified as one of the following constants:</param>
      <param name="uDescription">Used only with some notification types, as described above.</param>
      <returns>
        SELF, except if NOTIFYINTENTTOMOVE is specified for &lt;kNotifyName&gt;.  In this case, the return value is TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <include file="VOSDK_Classes.xml" path="doc/commonblocks/notify/*" />
      </remarks>
    </member>
    <member name="M:VO.DataWindow.OK">
      <summary>
        Accept all information entered in this data window and close the window.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method checks the validation status of the window.  If the data is valid and is correctly downloaded to the data server, it forces a commitment to the server and then closes the window.
        The "OK" operation is very clear and easily understood and might be profitably used on data windows used as MDI children (unconventional or not).
        Note that a user might be confused about exactly what information is accepted (for example, in a complex data window with nested windows).  If there is any uncertainty, you might consider labeling a button or menu command with something more explicit.
        <note type="tip">DataWindow:OK() disconnects itself from the data server using DataServer:UnregisterClient() and tells the server that it can close itself if it has no other registered clients.  Explicitly forcing the server to close from a window is not recommended, since this can create future problems.  Modifications to the application can attach other clients to the server, and any one window should not disable other windows.</note></remarks>
    </member>
    <member name="M:VO.DataWindow.OLEInPlaceActivate">
      <inheritdoc />
    </member>
    <member name="M:VO.DataWindow.OLEInPlaceDeactivate">
      <inheritdoc />
    </member>
    <member name="P:VO.DataWindow.Origin">
      <summary>
        The point representing the new location of this data window, in the canvas coordinates of its owner.
      </summary>
      <value>The point representing the new location of this data window, in the canvas coordinates of its owner.</value>
      <example>
        The following example sets the origin of a data window object:
        <code language="X#">oDW:Origin := Point{nLeft,nBottom}</code></example>
    </member>
    <member name="P:VO.DataWindow.Owner">
      <summary>
        The owner of the data window, which itself will be a Window object.
      </summary>
      <value>The owner of the data window, which itself will be a Window object.</value>
    </member>
    <member name="P:VO.DataWindow.OwnerServer">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DataWindow.PaintBoundingBox(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Paint a rectangular area in the data window using a specified painting method.
      </summary>
      <param name="oBB">The bounding box (group or character box) representing the data window area to be painted, in canvas coordinates.</param>
      <param name="kPM">The constant that represents how the data window area is painted:</param>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>PAINTFILL</term>
            <description>Fills the entire rectangle using the currently selected brush.  This is the default.</description>
          </item>
          <item>
            <term>PAINTFRAME</term>
            <description>Frames the entire rectangle using the currently selected pen</description>
          </item>
          <item>
            <term>PAINTINVERT</term>
            <description>Inverts the entire rectangle</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:VO.DataWindow.Paste">
      <summary>
        Replace the current selection in this data window with the contents of the clipboard.
      </summary>
      <remarks>
        If the data window is in "form" view, the contents of the edit control is replaced with the contents of the clipboard; if in "browse" view, the contents of the selected cell(s) or part of a cell is replaced.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.PasteSpecial">
      <summary>
        Use the standard Paste Special dialog to insert an OLE object into the focused OLEObject of the data window.
      </summary>
      <remarks>
        DataWindow:PasteSpecial() displays the standard Paste Special dialog and allows the user to insert an OLE object from the Clipboard into an OLEObject container, which currently must have the input focus.
      </remarks>
    </member>
    <member name="P:VO.DataWindow.Pointer">
      <summary>
        The pointer used by the data window to represent the mouse when it enters the window.
      </summary>
      <value>The pointer used by the data window to represent the mouse when it enters the window.</value>
    </member>
    <member name="M:VO.DataWindow.PreValidate">
      <summary>
        Called after any status change in this data window to allow controls and menu commands to be enabled/disabled based on the current validation status.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <remarks>
        This method provides some of the functionality of the WHEN clause in classical Xbase @...SAY...GET statements.  However, since the GUI approach does not enforce a rigid sequence of data entry but allows the user to move from control to control at random, the logic of enabling and disabling controls must be different.
        Instead of checking a condition when focus switches into the control (this is too late, a user with a mouse is already on the new control), the system must keep checking on every significant event.
        DataWindow:Prevalidate() provides some automatic handling of this type of validation (through DataWindow:RegisterConditionalControls()), but it also allows you to insert custom logic by overriding the method.
        The standard action in DataWindow:Prevalidate() is to call DataWindow:EnableConditionalControls(); if problems exist, it calls DataWindow:DisableConditionalControls().  DataWindow:Prevalidate() is called after the application of the standard validation, allowing the user to replace the default handling, upon success or failure of validation.
      </remarks>
    </member>
    <member name="P:VO.DataWindow.PreventAutoLayout">
      <summary>
        A logical value indicating that the AutoLayout behavior of the data window is blocked (TRUE if yes, FALSE if no).  An empty data window does not create controls automatically when it first uses a new data server.
      </summary>
      <value>A logical value indicating that the AutoLayout behavior of the data window is blocked (TRUE if yes, FALSE if no).  An empty data window does not create controls automatically when it first uses a new data server.</value>
    </member>
    <member name="M:VO.DataWindow.QueryClose(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked just before the data window closes to confirm if the application really wants to close the window.
      </summary>
      <param name="oQCE">The Event object that describes which data window is about to be closed.</param>
      <seealso cref="T:VO.Event" />
      <returns>
        TRUE if the data window is to be closed; otherwise, FALSE.
      </returns>
      <remarks>
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
        <note type="tip">If you reimplement this method in your subclass, it is recommended that you first call SUPER:QueryClose() within the method to obtain its default behavior.</note>
        When a user tries to close an application by selecting the Close menu command from a system menu (or by using another method to end the session), the system calls each data window's QueryClose() event handler.
      </remarks>
    </member>
    <member name="P:VO.DataWindow.RadioGroups">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DataWindow.RegisterConditionalControls(XSharp.__Usual)">
      <summary>
        Register a control in this data window as being subject to validation status and hence automatically dimmed whenever the window is in an invalid state.
      </summary>
      <param name="oCC">The control to be registered.</param>
      <remarks>
        Conditional controls allow the developer to register several controls as subject to validation.  This means that when the window fails validation, these controls are automatically disabled; when the window's status is OK, they are automatically enabled again.
        Controls that have been registered are automatically enabled or disabled — depending on validation status — by DataWindow:Prevalidate(), which is called on any status change in the window.
        In a practical data entry window, all the buttons would be registered and conditionally disabled — SkipNext, SkipPrevious, GoTop, GoBottom, Insert, Delete, OK — except for Cancel, which discards the invalid changes and hence should always be available.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.RePaint">
      <summary>
        Send an ExposeEvent to repaint the data window's canvas area.
      </summary>
    </member>
    <member name="M:VO.DataWindow.RepaintBoundingBox(XSharp.__Usual)">
      <summary>
        Repaint a rectangular area in the data window.
      </summary>
      <param name="oBB">The bounding box (group or character box) representing the data window area to be repainted, in canvas coordinates.</param>
      <remarks>
        This method should be avoided within an Expose() event handler.  If it is used, make sure the application does not fall into an infinite loop.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.Resize(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the data window changes size.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oResizeEvent">The ResizeEvent object that describes the new dimensions of the data window canvas area.</param>
      <remarks>
        In the Resize() event handler, calling DataWindow:Size should be used with caution to avoid entering an infinite loop.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.Seek(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Search for a value in the data server connected to this data window based on a controlling search order and update the window based on the change.
      </summary>
      <param name="uValue">The value to search for.  Its data type should be compatible with the controlling search order.</param>
      <param name="lSoftSeek">Determines how the attached data server is positioned if the specified key value is not found:  TRUE performs a soft seek; FALSE does not.  If &lt;lSoftSeek&gt; is omitted, the current SetSoftSeek() setting is used.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.  Note that a FALSE value can indicate either that the value was not found or that the server does not support this search operation.  Use the DataWindow:Status property to determine the exact cause of a failure.
      </returns>
    </member>
    <member name="P:VO.DataWindow.Server">
      <summary>
        The DataServer object currently connected to this data window.  If no server is connected, this value is NIL.
      </summary>
      <value>The DataServer object currently connected to this data window.  If no server is connected, this value is NIL.</value>
    </member>
    <member name="M:VO.DataWindow.SetAlignStartSize(XSharp.__Usual)">
      <summary>
        Sets the start size of the form window. In general, this size is set with the first assign to OwnerAlignment but it can be useful when trying to control the sizes for yourself.
      </summary>
      <param name="oDataWindow">The window attached to the child server; which must be a data window linked to a server of compatible type.  If omitted, all relations for this server are removed (although the recommended way of doing this is the DataWindow:ClearRelations() method).</param>
      <param name="oSize">The Dimension representing the size of the window.</param>
    </member>
    <member name="M:VO.DataWindow.SetContextMenu(VO.Menu,XSharp.__Symbol)">
      <summary>**Missing documentation **</summary>
      <param name="oNewMenu">** missing parameter documentation **</param>
      <param name="symView">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.DataWindow.SetDialog(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="lResizable">** missing parameter documentation **</param>
      <param name="lMaximizeBox">** missing parameter documentation **</param>
      <param name="lMinimizeBox">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.DataWindow.SetRelation(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a relation from the data server connected to this data window to the data server of another, creating an owner-child relationship between the two servers and the two windows.
      </summary>
      <remarks>
        <note type="tip">This operation may not be supported, depending on whether the servers used supports relations and are of compatible types.  The prototypical implementation is the standard Xbase DBServer:SetRelation() method provided.</note>
      </remarks>
      <param name="oDWChild">
        The window attached to the child server; which must be a data window linked to a server
        of compatible type.  If omitted, all relations for this server are removed (although the recommended way of
        doing this is the DataWindow:ClearRelations() method).
      </param>
      <param name="uRelation">
        The relation code block for the server, The name or symbol representing the field from
        this server; a code block is constructed and macro-compiled or the array of field names or symbols representing
        the relation for the server.  The field names are concatenated with plus signs and formed into a code block which is macro-compiled.
      </param>
      <param name="cRelation">
        When the relation is specified as a code block, a string version of the code block
        can be provided as well; it is returned by the Relation() method.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <example>
        The API can take these forms:
        <code language="X#">
          oDWCustomer:SetRelation(oDWOrders, {||_FIELD-&gt;CustNo},"CustNo")
          oDWCustomer:SetRelation(oDWOrders, #CustNo)
          oDWCustomer:SetRelation(oDWOrders, {#LastName,#Initial,#FirstName})
        </code></example>
    </member>
    <member name="M:VO.DataWindow.SetSelectiveRelation(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a selective relation from this window to the child window, or actually from the server of
        this window to the server of the other window.  A selective relation is one that limits operations on the child server to those records that match the relation condition.
      </summary>
      <remarks>
        <note type="tip">
          This operation may not be supported, depending on whether the servers used supports
          relations and are of compatible types.
        </note>
      </remarks>
      <param name="oDWChild">
        The window attached to the child server; which must be a data window linked to a
        server of compatible type.  If omitted, all relations for this server are removed (although the recommended
        way of doing this is the DataWindow:ClearRelations() method).
      </param>
      <param name="uRelation">
        The relation code block for the server, The name or symbol representing the
        field from this server; a code block is constructed and macro-compiled or the array of field names or
        symbols representing the relation for the server.  The field names are concatenated with plus signs and
        formed into a code block which is macro-compiled.
      </param>
      <param name="cRelation">
        When the relation is specified as a code block, a string version of the code block
        can be provided as well; it is returned by the Relation() method.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <example>
        The API can take these forms:
        <code language="X#">
          oDWCustomer:SetSelectiveRelation(oDWOrders, {||_FIELD-&gt;CustNo},"CustNo")
          oDWCustomer:SetSelectiveRelation(oDWOrders, #CustNo)
          oDWCustomer:SetSelectiveRelation(oDWOrders, {#LastName,#Initial,#FirstName})
        </code></example>
    </member>
    <member name="M:VO.DataWindow.Show(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.DataWindow.Size">
      <summary>
        The dimension representing the size of this data window in canvas coordinates.
      </summary>
      <value>The dimension representing the size of this data window in canvas coordinates.</value>
      <example>
        The following example sets the size of a data window object:
        <code language="X#">oDW:Size := Dimension{nWidth,nHeight}</code></example>
    </member>
    <member name="M:VO.DataWindow.Skip(XSharp.__Usual)">
      <summary>
        Move forward or backward in the server by a specified number of records.
      </summary>
      <param name="uRelativePosition">The number of records to be moved.  Positive numbers more forward, negative numbers move backward.  The default is +1.</param>
      <returns>
        TRUE if operation was successful; otherwise, FALSE.  Skip() can fail for several different reasons.  It can fail validation, there may not be that many records to move, the write that precedes the move can fail because of lock conflicts with other users that control the server, or the server can have become unavailable due to technical problems.  Use DataWindow:Status to determine the reason for the failure.
      </returns>
      <remarks>
        This method is subject to validation (i.e., if the data in the window fails validation, the movement is refused).
        The method does not explicitly refresh the contents of the window after the move; this is done automatically by the NotifyRecordChange message that follows.
        Because it takes a numeric argument, the Skip() method is rarely connected directly with a push button or menu command:  for simple movements, use the SkipNext() and SkipPrevious() methods.  Skip() provides a lot of flexibility but is usually called from code, in methods of the data window.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.SkipNext">
      <summary>
        Move to the next record (identical to Skip(1)).
      </summary>
      <returns>
        TRUE if operation was successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.DataWindow.SkipPrevious">
      <summary>
        Move to the previous record (identical to Skip(-1)).
      </summary>
      <returns>
        TRUE if operation was successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.DataWindow.Status">
      <summary>
        A hyperlabel identifying the status of this data window after the last operation.
      </summary>
      <value>A hyperlabel identifying the status of this data window after the last operation.</value>
      <remarks>
        A hyperlabel identifying the status of this data window after the last operation.  If the last operation was successful, this value is NULL_OBJECT; if something went wrong (whether it raised an error condition or merely returned a failure code), DataWindow:Status returns an informative hyperlabel.
      </remarks>
      <example>
        The following examples invoke several DataWindow:Status properties of the data server:
        <code language="X#">
          oDataWindow:Status:Caption
          oDataWindow:Status:Description
          oDataWindow:Status:HelpContext
        </code></example>
    </member>
    <member name="P:VO.DataWindow.StatusBar">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DataWindow.StatusOK">
      <summary>
        Indicate the current validation status of the window through a return code and by setting the DataWindow:Status property.
      </summary>
      <remarks>
        StatusOK() scans all controls on the window for an invalid status.  If an invalid control status is found, the method returns TRUE.  Use the DataWindow:Status property to determine which control returned an invalid status.
        Otherwise, StatusOK() returns FALSE.
      </remarks>
    </member>
    <member name="P:VO.DataWindow.SubForms">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.DataWindow.Surface">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="F:VO.DataWindow.symFormDialog">
      <exclude />
    </member>
    <member name="M:VO.DataWindow.TextPrint(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Display a given string on the data window at a specified location using the current font and the current pen color.
      </summary>
      <param name="cText">The string to be printed.</param>
      <param name="oPoint">The position of the string's origin, in canvas coordinates.</param>
    </member>
    <member name="M:VO.DataWindow.ToolBarHeightChanged(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DataWindow.Undo">
      <summary>
        Undo recent changes made in this data window.
      </summary>
      <remarks>
        If the data window is in "form" view, this applies to changes to the contents of the current edit control in the data window; if in "browse" view, this applies to the changes made to a cell in the data browser.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.UndoAll">
      <summary>
        Undo all changes made in this data window since the last record movement or Commit() operation.
      </summary>
      <remarks>
        After a long series of changes to this record, the DataWindow:UndoAll() method restores the record to the values it had when it was originally accessed.  However, the method does not provide for restoring changes made to several records; once the server has moved off a record, the changes are permanent as far as DataWindow:UndoAll() is concerned.
        If the data window is in "form" view, this applies to changes to the contents of the edit controls in the data window; if in "browse" view, this applies to the changes made to a row in the data browser.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.UpdateActiveObject">
      <summary>
        Update the toolbars of any in-place active OLE objects.
      </summary>
      <remarks>
        OLEDataWindow:UpdateActiveObject() calls the UpdateTools() method of any currently activated OLE object that the OLE data window contains.  It first determines which OLE object control is in-place active, and then replaces the X# container application's toolbars with the OLE server's toolbars.  In response to a resizing of the container application, this method causes the OLE object server to rearrange its toolbars.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.Use(XSharp.__Usual)">
      <summary>
        Connect the data window to a data server in a client-server relationship.
      </summary>
      <param name="oDataServer">The DataServer object that the window is to be connected to.  If the window is already connected to a server, it is disconnected first.  If the server argument is omitted, the server is not connected to any window.</param>
      <returns>
        TRUE if the connection was successful; otherwise, FALSE.  The operation fails under the following conditions:  if the window has controls and columns but none matches the names of the fields of the server and, of course, if there is a technical problem with the server.
      </returns>
      <remarks>
        The Use() method connects controls and browser columns with fields of the data server based on matching names.  Any control that does not have an explicitly provided field specification and hyperlabel inherits the field specification and hyperlabel from its data server field.
        If the window does not have any controls or columns, the Use() method automatically creates a layout with controls or columns for all the fields in the server.  A layout is created for each view — data window and browse — only when it is needed.
        Use() also registers the window as a client of the server with the DataServer:RegisterClient() method.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.ValidateRecord">
      <summary>
        If provided by the developer, ValidateRecord() is called by X# when you try to change records.
      </summary>
      <returns>
        TRUE if all fields in the current record are valid; otherwise, FALSE.
      </returns>
      <remarks>
        No default version of this method exists in the data window class.  If a record-level validation method is provided, it should return a logical value indicating if the window is valid overall.  If it returns FALSE, the method should set the window's Status property to a HyperLabel object with at least an appropriate description and possibly a help context tag, as well.
        ValidateRecord() can be used to perform cross-field validations, such as "the bonus can be no greater than half the salary and no greater than 10,000 for grades 6 and lower" and "tax filing information must be filled in if state is NY".  While it is certainly possible to specify such validation rules for individual controls, and keep the controls independent of one another.  This improves the reusability of code, making a control and its field specification usable regardless of what else is on the window.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.VerticalScroll(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a vertical scroll bar is scrolled.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oScrollEvent">The ScrollEvent object that describes the scroll type and new position.</param>
      <remarks>
        The default behavior for this event handler is to update the thumb position; this can be changed using your own implementation of the handler.  This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects.  If the application has horizontal scroll bars, use a HorizontalScrollBar event handler.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.VerticalSlide(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DataWindow.VerticalSpin(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DataWindow.ViewAs(XSharp.__Usual)">
      <summary>
        Specify the view mode of the data window, as browse view or form view.
      </summary>
      <param name="symViewType">Specifies which view mode is to be used.  Use one of these symbols:
      <pre>
        Symbol      Description
        #BrowseView Several records are displayed at the same time, as rows in a spreadsheet-like table with each field corresponding to a column.
        #FormView   A single record is viewed at a time, with its fields displayed in individual controls.
      </pre></param>
      <remarks>
        When a window is switched to a new view mode, a layout is automatically generated if one had not been defined previously.
        Because it takes an argument, DataWindow:ViewAs() is rarely connected directly with a push button or menu command; instead, the DataWindow:ViewForm() and DataWindow:ViewTable() methods are used.
      </remarks>
    </member>
    <member name="M:VO.DataWindow.ViewForm">
      <summary>
        Select form view for the data window.
      </summary>
    </member>
    <member name="M:VO.DataWindow.ViewTable">
      <summary>
        Select browse view for the data window.
      </summary>
    </member>
    <member name="T:VO.DateFS">
      <summary>
        Create a date field specification which holds date data type information.
      </summary>
    </member>
    <member name="M:VO.DateFS.#ctor(XSharp.__Usual)">
      <summary>
        Construct a date specification.
      </summary>
      <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new date field specification.</param>
    </member>
    <member name="T:VO.DateRange">
      <summary>
        An auxiliary class used by the DateTimePicker and MonthCalendar controls to represent a date range.
      </summary>
      <remarks>
        The DateRange class encapsulates a date range as expected by various methods of the MonthCalendar and DateTimePicker classes.
      </remarks>
    </member>
    <member name="M:VO.DateRange.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a DateRange object.
      </summary>
      <param name="dStart">The start date of the date range.  If omitted, defaults to Today().</param>
      <param name="dEnd">The end date of the date range.  If omitted, defaults to Today().</param>
    </member>
    <member name="P:VO.DateRange.Max">
      <summary>
        The date representing the upper limit of the date range.
      </summary>
      <value>The date representing the upper limit of the date range.</value>
    </member>
    <member name="P:VO.DateRange.Min">
      <summary>
        The date representing the lower limit of the date range.
      </summary>
      <value>The date representing the lower limit of the date range.</value>
    </member>
    <member name="T:VO.DateTimePicker">
      <summary>
        Encapsulate a DateTimePicker control.
      </summary>
      <remarks>
        The DateTimePicker control allows the user to select a date or time.
        <note type="tip">Version 4.70 or higher of COMCTL32.DLL is needed to use the DateTimePicker control.</note></remarks>
    </member>
    <member name="M:VO.DateTimePicker.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a DateTimePicker object.
      </summary>
      <param name="oOwner">The window that owns the DateTimePicker object.</param>
      <param name="xID">The unique ID for the DateTimePicker object (between 1 and 8000).</param>
      <param name="oPoint">The origin of the DateTimePicker object in canvas coordinates.</param>
      <param name="oDimension">The dimension of the DateTimePicker object in canvas coordinates.</param>
      <param name="dwStyle">
        Constant representing the style of the DateTimePicker object, specified either by a X# style constant or a Windows API style constant.  Styles can be combined using the _Or() operator.
      </param>
      <param name="lDataAware">A logical value that is TRUE if the DateTimePicker object is data-aware;  otherwise, FALSE.  If omitted, defaults to TRUE.</param>
      <param name="nResourceID">The resource ID of the DateTimePicker object.</param>
      <remarks>
        <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular style constant.</note>
      </remarks>
    </member>
    <member name="P:VO.DateTimePicker.DateRange">
      <summary>
        A DateRange object setting the range of allowable dates.
      </summary>
      <value>A DateRange object setting the range of allowable dates.</value>
    </member>
    <member name="P:VO.DateTimePicker.Format">
      <summary>
        Sets the display format of the DateTimePicker control.  The assign expects a string containing any of the following fragments:
      </summary>
      <value>Sets the display format of the DateTimePicker control.  The assign expects a string containing any of the following fragments:</value>
      <remarks>
        Sets the display format of the DateTimePicker control.  The assign expects a string containing any of the following fragments:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>"d"</term><description>The one- or two-digit day.</description></item><item><term>"dd"</term><description>The two-digit day.  Single-digit day values are preceded by a zero (0).</description></item><item><term>"ddd"</term><description>The three-character weekday abbreviation.</description></item><item><term>"dddd"</term><description>The full weekday name.</description></item><item><term>"h"</term><description>The one- or two-digit hour in 12-hour format.</description></item><item><term>"hh"</term><description>The two-digit hour in 12-hour format.  Single-digit values are preceded by a zero (0).</description></item><item><term>"H"</term><description>The one- or two-digit hour in 24-hour format.</description></item><item><term>"HH"</term><description>The two-digit hour in 24-hour format.  Single-digit values are preceded by a zero (0).</description></item><item><term>"m"</term><description>The one- or two-digit minute.</description></item><item><term>"mm"</term><description>The two-digit minute.  Single-digit values are preceded by a zero (0).</description></item><item><term>"M"</term><description>The one- or two-digit month number.</description></item><item><term>"MM"</term><description>The two-digit month number.  Single-digit values are preceded by a zero (0).</description></item><item><term>"MMM"</term><description>The three-character month abbreviation.</description></item><item><term>"MMMM"</term><description>The full month name.</description></item><item><term>"t"</term><description>The one-letter AM/PM abbreviation (that is, AM is displayed as "A").</description></item><item><term>"tt"</term><description>The two-letter AM/PM abbreviation (that is, AM is displayed as "AM").</description></item><item><term>"y"</term><description>The one-digit year (that is, 1999 would be displayed as "9").</description></item><item><term>"yy"</term><description>The last two digits of the year (that is, 1999 would be displayed as "99").</description></item><item><term>"yyy"</term><description>The full year (that is, 1999 would be displayed as "1999").</description></item></list></remarks>
      <example>
        This example displays the current time only on the date time picker control:
        <code language="X#">oDTPicker:Format := "hh:mm:ss"   // 10:23:14</code>
        This example displays a string along with the date:
        <code language="X#">
          ODTPicker:Format := "'Today is' dddd, MMMM d, yyy"
          // Today is Friday, April 9, 1999
        </code></example>
    </member>
    <member name="P:VO.DateTimePicker.IsNone">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.DateTimePicker.IsTimePicker">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.DateTimePicker.MCBackgroundColor">
      <summary>
        A Color object describing the background color (between the months) of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.
      </summary>
      <value>A Color object describing the background color (between the months) of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.</value>
    </member>
    <member name="P:VO.DateTimePicker.MCFont">
      <summary>
        A Font object specifying the font of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.
      </summary>
      <value>A Font object specifying the font of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.</value>
    </member>
    <member name="P:VO.DateTimePicker.MCMonthBackgroundColor">
      <summary>
        A Color object describing the background color (within the month area) of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.
      </summary>
      <value>A Color object describing the background color (within the month area) of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.</value>
    </member>
    <member name="P:VO.DateTimePicker.MCTextColor">
      <summary>
        A Color object describing the text color of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.
      </summary>
      <value>A Color object describing the text color of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.</value>
    </member>
    <member name="P:VO.DateTimePicker.MCTitleBackgroundColor">
      <summary>
        A Color object describing the title background color of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.
      </summary>
      <value>A Color object describing the title background color of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.</value>
    </member>
    <member name="P:VO.DateTimePicker.MCTitleTextColor">
      <summary>
        A Color object describing the title text color of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.
      </summary>
      <value>A Color object describing the title text color of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.</value>
    </member>
    <member name="P:VO.DateTimePicker.MCTrailingTextColor">
      <summary>
        A Color object describing the color of the trailing and leading days, i.e., those not belonging to the current month, that appear on the MonthCalendar pop-up window, if the DateTimePicker is in date mode.
      </summary>
      <value>A Color object describing the color of the trailing and leading days, i.e., those not belonging to the current month, that appear on the MonthCalendar pop-up window, if the DateTimePicker is in date mode.</value>
    </member>
    <member name="P:VO.DateTimePicker.NullFormat">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DateTimePicker.ParentNotify(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="nCode">** missing parameter documentation **</param>
      <param name="lParam">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.DateTimePicker.PerformValidations">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.DateTimePicker.SelectedDate">
      <summary>
        A date specifying the currently selected date.
      </summary>
      <value>A date specifying the currently selected date.</value>
    </member>
    <member name="P:VO.DateTimePicker.SelectedTime">
      <summary>
        A string (format "HH:MM:SS") specifying the currently selected time.
      </summary>
      <value>A string (format "HH:MM:SS") specifying the currently selected time.</value>
    </member>
    <member name="M:VO.DateTimePicker.SetDateTime(XSharp.__Date,System.String)">
      <summary>**Missing documentation **</summary>
      <param name="dNewDate">** missing parameter documentation **</param>
      <param name="sNewTime">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.DateTimePicker.TextValue">
      <summary>
        The current value in string format.  This is needed internally to allow the binding of a DateTimePicker control to a database field.
      </summary>
      <value>The current value in string format.  This is needed internally to allow the binding of a DateTimePicker control to a database field.</value>
    </member>
    <member name="P:VO.DateTimePicker.Value">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.DateTimeSelectionEvent">
      <summary>
        Provide information about a date time selection event, which is generated when a user selected a Date or Time in a DateTimePicker control.
      </summary>
      <remarks>
        This event occurs when a date is selected in a DateTimePicker control

      </remarks>
    </member>
    <member name="M:VO.DateTimeSelectionEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.DateTimeSelectionEvent.SelectedDate">
      <summary>
        A date value indicating the date the user selected in the control
      </summary>
      <value>A date value indicating the date the user selected in the control</value>
    </member>
    <member name="P:VO.DateTimeSelectionEvent.SelectedTime">
      <summary>
        A string value indicating the time the user selected in the control
      </summary>
      <value>A string value indicating the time the user selected in the control</value>
    </member>
    <member name="T:VO.DbError">
      <exclude />
    </member>
    <member name="M:VO.DbError.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <exclude />
    </member>
    <member name="M:VO.DbError.Throw">
      <exclude />
    </member>
    <member name="T:VO.DbFileSpec">
      <summary>
        Hold the file name and path for a .DBF file and provide DBF-related functions, such as creating, copying, deleting, moving, and renaming files.
      </summary>
      <remarks>
        A FileSpec is a general purpose object that holds the file name and path of a file.  The DBFileSpec subclass is intended specifically for holding information about a DBF file.
        The FileSpec class does not contain any methods for reading or writing the file, however you can in fact create a DBF structure with this class; it is limited to directory-level properties such as size, date and time changed and operations such as delete and rename.  The DBFileSpec adds two operations that apply to DBF files only:  reading the record layout through DBFileSpec:DBStruct and creating a file given a record layout through DBFileSpec:Create().
        Note that a DBServer object opens an existing file on instantiation; it requires that the file exists, so it cannot be used to create a DBF file.  DBFileSpec:Create() is the ideal method for creating a DBF file.
        DBStruct is available as a access method of the DBServer class, but instantiating a DBServer is an unnecessary complex way of reading a file header.  DBFileSpec:DBStruct is a simpler way of getting the record layout.
      </remarks>
      <example>
        The two methods may be used together, in concert with the path manipulation methods of the FileSpec class.
        For example, to create in the corresponding directory on a different drive a new file with the same record layout as an existing file, you might do something like this:
        <code language="X#">
          oDBFileSpec := DBFileSpec{"c:\data\custdata.dbf"}
          IF oDBFileSpec:Find()		// File exists?
          aDBStruct := oDBFileSpec:DBStruct
          oDBFileSpec:Drive := "d:"
          oDBFileSpec:Create(aDBStruct)
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.DbFileSpec.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Instantiates a DBFileSpec object and fills its instance variables with DBF information.
      </summary>
      <param name="cFullPath">The drive, path and file name of the DBF file.</param>
      <param name="cDriver">The RDD used to instantiate the DBFileSpec.</param>
      <param name="_aRDDs">The 1-D array of 'hidden' RDDs required to open a DBF file, such as DBFMEMO.</param>
      <returns>
        A DBFileSpec object.
      </returns>
      <example>
        <code language="X#">
          oDB1 := DBFileSpec{ "C:\TEST\TEST.DBF" }
          oDB2 := DBFileSpec{}
          oDB2:FullPath := "C:\TEST\TEST.DBF"
        </code>
      </example>
    </member>
    <member name="M:VO.DbFileSpec.Copy(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Copies all files associated with DBFileSpec objects to a different drive and/or directory.
      </summary>
      <param name="oDBFSTarget">The DBFileSpec object's target directory.  Can be either optional or full path.</param>
      <param name="lIDX">Logical parameter.  TRUE also moves any index files associated with SELF.  The default is TRUE.</param>
      <param name="lName">Logical parameter.  TRUE causes an auto-rename of the target file if a file conflict occurs during the copy.  The default is FALSE. </param>
      <returns>
        TRUE if the file was successfully copied; otherwise, FALSE.
      </returns>
      <example>
        <code language="X#">
          // Copy the CUSTOMER.DBF file to C:\TEST directory:
          SetDefault( "C:\CAVOxx\SAMPLES\GSTUTOR" )
          oDB := DBFileSpec{}
          oDB:FileName := "CUSTOMER"
          IF oDB:Find()
          oDB:Copy( "C:\TEST\" )
          ENDIF
          // Copy using FileSpec object
          // Copy CUSTOMER.DBF file to C:\TEST\COPY\DBFS directory:
          // Copy the TEST.DBF file to C:\TEST directory:
          SetDefault( "C:\CAVOxx\SAMPLES\GSTUTOR" )
          oFS := FileSpec{ "C:\TEST\" }
          oDB := DBFileSpec{}
          oDB:FileName := "CUSTOMER"
          IF oDB:Find()
          oDB:Copy( oFS )
          ENDIF
        </code>
      </example>
    </member>
    <member name="M:VO.DbFileSpec.CopyTo(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Copies the DBFileSpec object's DBF file to another data format.  This can be used for copying out to another RDD, to a delimited file, or to an SDF file.
      </summary>
      <param name="oFS">The drive and directory into which to copy SELF's files.  Can also be an existing DBFileSpec object or FileSpec object.</param>
      <param name="cDriver">The target file's RDD.</param>
      <param name="lWantAnsi">Logical parameter.  TRUE creates the target file in ANSI format.  The default is the source DBFileSpec's ANSI setting.</param>
      <returns>
        TRUE if the file was successfully copied; otherwise, FALSE.
      </returns>
      <example>
        The following examples illustrate copying a DBF file to different data formats:
        <code language="X#">
          // Export the records of CUSTOMER.DBF/DBT file to various formats:
          SetDefault( "C:\CAVOxx\SAMPLES\SSATUTOR" )
          oDB := DBFileSpec{}
          oDB:FileName := "CUSTOMER"
          IF oDB:Find()
          // copy out to DBF/FPT
          oDB:CopyTo( "cust_CDX", "DBFCDX" )
          // copy out to a delimited file
          oDB:Delim := ","
          oDB:CopyTo( "cust_DEL" )
          oDB:Delim := NULL_STRING
          // copy out to an  SDF file
          oDB:SDF := TRUE
          oDB:CopyTo( "cust_SDF" )
          oDB:SDF := FALSE
          // copy out to a DBF/DBV file
          oDB:HidRDDs := { "DBFMEMO" }
          oDB:CopyTo( "cust_DBV" )
          oDB:HidRDDs := {}
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.DbFileSpec.Create(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Create a new DBF file with the given name, using a provided DBStruct array.
      </summary>
      <param name="cFullPath">The file name for the new DBF and optional path or FileSpec object.</param>
      <param name="aDbStruct">The layout of the DBF to be created with each field represented by a subarray containing the field name, the type, the length, the decimals, and the alias in the DBStruct() format if different from SELF's DBF file structure.</param>
      <param name="cDriver">The RDD used to create the new DBF file structure if different from SELF's.</param>
      <param name="lWantAnsi">TRUE if this new DBF is to be an ANSI DBF (default). </param>
      <param name="aRDDs">The 1-D array of 'hidden' RDDs required to open a DBF file, such as DBFMEMO.  Defaults to SELF's.</param>
      <returns>
        TRUE if the file was successfully created; otherwise, FALSE.
      </returns>
      <remarks>
        The DBFileSpec:Create() method is useful for generating a new DBF file given a file specification and path.  The DBCreate() function is also useful to do the same thing, however this approach is more efficient.
        Note that the DBServer class does not contain a Create() method: instantiating a DBServer requires that the file exists already, so one cannot be created. The CopyDB() and CopyStructure() methods of the DBServer class often provide an easier way of copying the structure, completely or partially, of an existing file.
        Note that the method does not open the file.
      </remarks>
      <example>
        <code language="X#">
          aDBF := { { "FLD1_C", "C", 10, 0 }, { "FLD2_N", "N", 10, 2 }, { "FLD3_D", "D", 8, 0 }, ;
          { "FLD4_L", "L", 1, 0 }, { "FLD5_M", "M", 10, 0 } }
          aRDD := { "DBFMEMO" }
          cSomePath	:= WorkDir{} + "data\"
          SetDefault( "C:\TEST" )
          oDB := DBFileSpec{}
          // create a DBF/DBV file
          oDB:Create( "NewFile1", aDBF, "DBFNTX", TRUE, aRDD )
          // create a DBF/FPT file to a different folder
          oDB:Create( cSomePath + "NewFile2", aDBF, "DBFCDX", TRUE )
        </code>
      </example>
    </member>
    <member name="P:VO.DbFileSpec.DBFAttr">
      <summary>
        The DBF file attributes returned as a string type.
      </summary>
      <value>The DBF file attributes returned as a string type.</value>
    </member>
    <member name="P:VO.DbFileSpec.DBFDateChanged">
      <summary>
        The DBF file date stamp returned as a date type.
      </summary>
      <value>The DBF file date stamp returned as a date type.</value>
    </member>
    <member name="P:VO.DbFileSpec.DBFName">
      <summary>
        The DBF file name and extension.
      </summary>
      <value>The DBF file name and extension.</value>
    </member>
    <member name="M:VO.DbFileSpec.DBFSGetInfo(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Fills in the DBFileSpec object's instance variables.  This method is not required when using the Find() method, which will invoke this method internally if the file is found.
      </summary>
      <param name="xRDDs">The RDD used to open the target file defined in the DBFileSpec object.</param>
      <param name="aHidden">The 1-D Array of 'hidden' RDDs required for target file defined in the DBFileSpec object.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <example>
        <code language="X#">
          oDB := DBFileSpec{}
          // path to existing DBF file
          oDB:FullPath := "C:\TEST\CUSTOMER.DBF"
          IF !oDB:DBFSGetInfo()
          MessageBox( 0, "an error occurred", "", 0 )
          ENDIF
        </code>
      </example>
    </member>
    <member name="P:VO.DbFileSpec.DBFSize">
      <summary>
        The DBF file size.
      </summary>
      <value>The DBF file size.</value>
    </member>
    <member name="P:VO.DbFileSpec.DBFTime">
      <summary>
        The DBF file time stamp returned as a string.
      </summary>
      <value>The DBF file time stamp returned as a string.</value>
    </member>
    <member name="P:VO.DbFileSpec.DbStruct">
      <summary>
        An array containing the structure of the DBF file.
      </summary>
      <value>An array containing the structure of the DBF file.</value>
      <remarks>
        An array containing the structure of the DBF file.
        The structure of the current database file in an array whose length is equal to the number of fields in the database file.  Each element of the array is a subarray containing information for one field.  The subarrays have the following format:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>DBS_NAME</term><description>cName</description></item><item><term>DBS_TYPE</term><description>cType</description></item><item><term>DBS_LEN</term><description>nLength</description></item><item><term>DBS_DEC</term><description>nDecimals</description></item><item><term>DBS_ALIAS</term><description>cAlias</description></item></list></remarks>
    </member>
    <member name="M:VO.DbFileSpec.Delete">
      <summary>
        Physically deletes all files that are associated with the DBFileSpec object, including memo files and any index files associated with the DBF through OrderSpec objects.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <example>
        <code language="X#">
          oDB := DBFileSpec{ "C:\TEST\DELETE\STRING\TEST.DBF" }
          oDB:Delete( )
        </code>
      </example>
    </member>
    <member name="P:VO.DbFileSpec.Delim">
      <summary>
        Access the delimiter used for the CopyTo() method.
      </summary>
      <value>Access the delimiter used for the CopyTo() method.</value>
    </member>
    <member name="P:VO.DbFileSpec.FCount">
      <summary>
        The number of fields in the DBF file.
      </summary>
      <value>The number of fields in the DBF file.</value>
    </member>
    <member name="P:VO.DbFileSpec.Fields">
      <summary>
        The 1-D array of DBF fields to copy out to when using the CopyTo() method.
      </summary>
      <value>The 1-D array of DBF fields to copy out to when using the CopyTo() method.</value>
    </member>
    <member name="P:VO.DbFileSpec.FileName">
      <summary>
        Assign a file name to the DBFileSpec object.
      </summary>
      <value>Assign a file name to the DBFileSpec object.</value>
    </member>
    <member name="M:VO.DbFileSpec.Find">
      <summary>
        Locates the file defined in the DBFileSpec object using the current directory, SetDefault(), or SetPath().  Fills in the instance variables of the DBFileSpec if successful.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <example>
        <code language="X#">
          // find the DBF
          SetDefault( "C:\CAVOxx\SAMPLES\GSTUTOR" )
          oDB := DBFileSpec{}
          oDB:FileName := "CUSTOMER"
          IF oDB:Find()
          &lt;execute some code&gt;
          ENDIF
        </code>
      </example>
    </member>
    <member name="P:VO.DbFileSpec.ForBlock">
      <summary>
        The FOR condition code block used for the CopyTo() method.
      </summary>
      <value>The FOR condition code block used for the CopyTo() method.</value>
    </member>
    <member name="P:VO.DbFileSpec.FullPath">
      <summary>
        Assign a full path — including drive, directory, file name, and extension — to the DBFileSpec object.
      </summary>
      <value>Assign a full path — including drive, directory, file name, and extension — to the DBFileSpec object.</value>
    </member>
    <member name="P:VO.DbFileSpec.HeaderSize">
      <summary>
        The size of the DBF file header.
      </summary>
      <value>The size of the DBF file header.</value>
    </member>
    <member name="P:VO.DbFileSpec.HidRDDs">
      <summary>
        The 1-D array of "hidden" RDDs (i.e., DBFMEMO) used for the CopyTo() method.
      </summary>
      <value>The 1-D array of "hidden" RDDs (i.e., DBFMEMO) used for the CopyTo() method.</value>
    </member>
    <member name="P:VO.DbFileSpec.IndexNames">
      <summary>
        The 1-D array of  index files with drive, path, file name, and extension information.
      </summary>
      <value>The 1-D array of  index files with drive, path, file name, and extension information.</value>
      <remarks>
        <note type="tip">It is not required to assign this array when using the OrderSpec:OrderCreate() and OrderSpec:OrderAdd() methods.</note>
      </remarks>
    </member>
    <member name="P:VO.DbFileSpec.IsAnsi">
      <summary>
        The ANSI/OEM setting used in the DBF file header.
      </summary>
      <value>The ANSI/OEM setting used in the DBF file header.</value>
    </member>
    <member name="P:VO.DbFileSpec.LastUpDate">
      <summary>
        The date of the last update made to the DBF file as reported in the DBF header.
      </summary>
      <value>The date of the last update made to the DBF file as reported in the DBF header.</value>
    </member>
    <member name="P:VO.DbFileSpec.MemAttr">
      <summary>
        The memo file attributes.
      </summary>
      <value>The memo file attributes.</value>
    </member>
    <member name="P:VO.DbFileSpec.MemBlockSize">
      <summary>
        The memo block size used in the memo file.
      </summary>
      <value>The memo block size used in the memo file.</value>
    </member>
    <member name="P:VO.DbFileSpec.MemDateChanged">
      <summary>
        The memo file date stamp returned as a date type.
      </summary>
      <value>The memo file date stamp returned as a date type.</value>
    </member>
    <member name="P:VO.DbFileSpec.MemFileExt">
      <summary>
        The memo file name extension excluding the file name.
      </summary>
      <value>The memo file name extension excluding the file name.</value>
    </member>
    <member name="P:VO.DbFileSpec.MemFileName">
      <summary>
        The base memo file name excluding the file name extension.
      </summary>
      <value>The base memo file name excluding the file name extension.</value>
    </member>
    <member name="P:VO.DbFileSpec.MemFullPath">
      <summary>
        The full path of the memo file, including drive, directory, file name, and extension.
      </summary>
      <value>The full path of the memo file, including drive, directory, file name, and extension.</value>
    </member>
    <member name="P:VO.DbFileSpec.MemName">
      <summary>
        The memo file name and extension.
      </summary>
      <value>The memo file name and extension.</value>
    </member>
    <member name="P:VO.DbFileSpec.MemSize">
      <summary>
        The memo file size.
      </summary>
      <value>The memo file size.</value>
    </member>
    <member name="P:VO.DbFileSpec.MemTime">
      <summary>
        The memo file time stamp returned as a string.
      </summary>
      <value>The memo file time stamp returned as a string.</value>
    </member>
    <member name="M:VO.DbFileSpec.Move(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Moves and/or renames all files associated with DBFileSpec objects to a different drive and/or directory.  Updates DBFileSpec and/or OrderSpec instance variables.  Will also rename auto-open index files.  Only DBF, MEMO and auto-open index files will get renamed.
      </summary>
      <param name="oDBFSTarget">The drive and directory to move SELF's files into.  Can also be an existing DBFileSpec object.</param>
      <param name="lIDX">Logical parameter.  TRUE also moves any index files associated with SELF.  The default is TRUE.</param>
      <param name="lName">Logical parameter.  TRUE causes an auto-rename of the target file if a file conflict occurs during the move.  The default is FALSE. </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <example>
        <code language="X#">
          // Move the CUSTOMER.DBF file to C:\TEST directory:
          SetDefault("C:\CAVO25\SAMPLES\GSTUTOR")
          oDB := DBFileSpec{ }
          oDB:FileName := "customer"
          IF oDB:Find()
          oDB:Move("C:\TEST\")
          ENDIF
          // Move using FileSpec object
          // Move the CUSTOMER.DBF file to C:\TEST directory:
          SetDefault("C:\CAVO25\SAMPLES\GSTUTOR")
          oFS := FileSpec{"C:\TEST\"}
          oDB := DBFileSpec{ }
          oDB:FileName := "customer"
          IF oDB:Find()
          oDB:Move(oFS)
          ENDIF
          // Move the CUSTOMER.DBF file to C:\TEST directory and rename:
          SetDefault("C:\CAVO25\SAMPLES\GSTUTOR")
          oDB := DBFileSpec{ }
          oDB:FileName := "customer"
          IF oDB:Find()
          oDB:Move("C:\TEST\NewFile")
          ENDIF
        </code>
      </example>
    </member>
    <member name="P:VO.DbFileSpec.Orders">
      <summary>
        The 1-D array of OrderSpec objects that are associated with this DBFileSpec object.
      </summary>
      <value>The 1-D array of OrderSpec objects that are associated with this DBFileSpec object.</value>
      <remarks>
        <note type="tip">It is not required to assign this array when using OrderSpec:OrderCreate() and OrderSpec:OrderAdd() methods.</note>
      </remarks>
    </member>
    <member name="P:VO.DbFileSpec.RDD_Name">
      <summary>
        The name of the RDD used for instantiation.
      </summary>
      <value>The name of the RDD used for instantiation.</value>
    </member>
    <member name="P:VO.DbFileSpec.RDD_Version">
      <summary>
        The version number of the RDD.
      </summary>
      <value>The version number of the RDD.</value>
    </member>
    <member name="P:VO.DbFileSpec.RDDs">
      <summary>
        An array of "hidden" RDDs (such as DBFMEMO) used for instantiation.
      </summary>
      <value>An array of "hidden" RDDs (such as DBFMEMO) used for instantiation.</value>
    </member>
    <member name="P:VO.DbFileSpec.RecCount">
      <summary>
        The number of records in the DBF.  (Note that "LastRec" is not available in this class, only in the dbServer class)
      </summary>
      <value>The number of records in the DBF.  (Note that "LastRec" is not available in this class, only in the dbServer class)</value>
    </member>
    <member name="P:VO.DbFileSpec.Recno">
      <summary>
        The record number for the CopyTo() method when a single record is required.
      </summary>
      <value>The record number for the CopyTo() method when a single record is required.</value>
    </member>
    <member name="P:VO.DbFileSpec.Records">
      <summary>
        The number of records for the CopyTo() method.
      </summary>
      <value>The number of records for the CopyTo() method.</value>
    </member>
    <member name="P:VO.DbFileSpec.RecSize">
      <summary>
        The record size of the DBF.
      </summary>
      <value>The record size of the DBF.</value>
    </member>
    <member name="M:VO.DbFileSpec.Rename(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Renames files associated with DBFileSpec object.  Only DBF/MEMO and auto-open index files will get renamed.  
        Rename() will not rename a file if it is already open or there is a file name conflict.  
        To rename files to another directory, use the Move() method and supply a different target file name.
      </summary>
      <param name="oDBFSNewName">The new name for the DBF file.</param>
      <param name="lName">Logical parameter.  TRUE causes an auto-rename of the target file if a file conflict occurs during the move.  The default is FALSE. </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <example>
        <code language="X#">
          SetDefault("C:\CAVO2x\SAMPLES\GSTUTOR")
          oDB := DBFileSpec{ }
          oDB:FileName := "customer"
          IF oDB:Find()
          IF !oDB:Rename("NewFile", TRUE )
          // Did not work, so let the user know…
          ENDIF
          ENDIF
        </code>
      </example>
    </member>
    <member name="P:VO.DbFileSpec.Rest">
      <summary>
        A logical determining if the CopyTo() method is to copy all records or the current record to EOF.
      </summary>
      <value>A logical determining if the CopyTo() method is to copy all records or the current record to EOF.</value>
    </member>
    <member name="P:VO.DbFileSpec.RLockCount">
      <summary>
        The number of locked records in the DBF.
      </summary>
      <value>The number of locked records in the DBF.</value>
    </member>
    <member name="P:VO.DbFileSpec.SDF">
      <summary>
        A logical determining if the CopyTo() method is to copy out to an SDF file.
      </summary>
      <value>A logical determining if the CopyTo() method is to copy out to an SDF file.</value>
    </member>
    <member name="P:VO.DbFileSpec.WhileBlock">
      <summary>
        A WHILE condition code block used with the CopyTo() method.
      </summary>
      <value>A WHILE condition code block used with the CopyTo() method.</value>
    </member>
    <member name="T:VO.DBSelectionIndex">
      <exclude />
    </member>
    <member name="M:VO.DBSelectionIndex.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <exclude />
    </member>
    <member name="M:VO.DBSelectionIndex.Eval">
      <exclude />
    </member>
    <member name="T:VO.DbServer">
      <summary>
        Create a data server that can operate with existing .DBF database files and their associated index files.
      </summary>
      <remarks>
        Once a DBF table is opened in a DBServer object, it can be manipulated through the methods of the DBServer class, several of which are shown in the following examples:
        <code language="X#">
          oDBCust := DBServer{"customer"}
          oDBCust:Skip(3)
          ? oDBCust:CustName
          oDBCust:CustNo := NewNumber
          oDBCust:GoTo(86)
          oDBCust:Delete()
          oDBCust:Append()
          oDBCust:Close()
        </code>

        The fields of the table can be considered as exported instance variables of the object.  They can also be accessed through the FieldGet() and FieldPut() methods, with the field identified through a symbol, a string, or a number:
        <code language="X#">
          oDBCust := DBServer{"customer"}
          oDBCust:CustNo := 1234
          ? oDBCust:CustNo
          oDBCust:FieldPut(#CustNo, 1234)
          oDBCust:FieldPut("CustNo", 1234)
          oDBCust:FieldPut(1, 1234)
          ? oDBCust:FieldGet(#CustNo)
          ? oDBCust:FieldGet("CustNo")
          ? oDBCust:FieldGet(1)
        </code>
        (The fields are, of course, not real exported variables of the DBServer class.  See "Objects, Classes, and Methods" in the Programmer's Guide  for a discussion of how these "virtual" exported variables are created using the NoIVarGet() and NoIVarPut() methods.)

        All the traditional database operations available through commands or functions are available as methods for the DBServer object.  In general, they behave the same way, with two exceptions:  expanded parameter types and general scope-setting.

        Whenever an operation requires the specification of a file, an alias, a work area, or a field, the methods accept an object of the corresponding class:  a FileSpec object for a file, a DBServer object for an alias or a work area, or a DataField object for a field.  These options allow a more consistent use of objects and all the benefits they convey.  The new, object-oriented approach is not required:  a file can be specified as either an object or a string, an alias as an object, string or symbol, fields as objects, strings, or symbols.

        The classical SetRelation() operation allows you to link to servers, so that a movement in the parent server causes an automatic movement in the child server.  The prototypical situation is a relation between a customer server and an order server, to make the order server show the orders for the current customer:
        <code language="X#">
          oDBCust := DBServer{"customer"}
          oDBCust:SetIndex("custname")
          oDBOrder := DBServer{"order"}
          oDBOrder:SetIndex("ordcstno")
          oDBCust:SetRelation(oDBOrder,#CustNo)
        </code>
        After this relation is established, any movement in the parent of the relationship causes a corresponding repositioning of the client:  moving to customer Jones positions the order database at the first of Jones's orders, if any.  The DBServer:SetRelation() method works exactly the same as the corresponding command and function in traditional Xbase DML.
        However, this type of relation is not very helpful.  The child database is positioned correctly at the beginning of the orders, but it is not limited at the end of the orders.  Thus, the application that uses the server must continually check if it is still on the appropriate customer's orders.  DBServer:SetFilter() is not very helpful, because if you skip past the last of the customer's orders, DBServer:Skip() continues to scan the file until it finds one that matches.  This kind of behavior is particularly burdensome for general purpose tools like data windows, which have to express these tests in a general way while they provide for data browsing.
        This is where a selective relation is more valuable.  If we establish a selective relation, all operations on the child server are restricted to those records that match.  DBServer:GoTop(), DBServer:GoBottom(), DBServer:BOF, DBServer:EOF, and DBServer:Skip() act as if the only records that exist are those that match the relation.  Specifically, if you try to skip past the last appropriate order, Skip() fails and returns an end-of-file condition.  Similarly, if you try to GoTo() a record that doesn't match, GoTo() fails as if that record didn't exist and stays on the current record.  And utilities like Eval(), Count(), Sum(), etc., by default apply only to the selection (although explicitly specified scopes are allowed to violate this restriction).
        <code language="X#">
          LOCAL aSum
          oDBCust := DBServer{"customer"}
          oDBCust:SetIndex("custname")
          oDBOrder := DBServer{"order"}
          oDBOrder:SetIndex("ordcstno")
          oDBCust:SetSelectiveRelation(oDBOrder,#CustNo)
          oDBCust:Seek("Jones")
          DO WHILE ! oDBOrder:EOF
          ? oDBOrder:OrderNumber
          ENDDO
          aSum := oDBOrder:Sum(#Charge)
          ? "Number of orders:",oDBOrder:RecCount
          ? "Total value:",oDBOrder:aSum[1]
        </code>
        The following table lists the properties and methods that reflect the currently active selection:
        <list type="table"><listheader><term>Method or Property</term><description>Description</description></listheader><item><term>BOF</term><description>Attempt to position before first record in selection.</description></item><item><term>EOF</term><description>Attempt to position after last record in selection.</description></item><item><term>Found</term><description>Indicates if a record is found within the selection only (after Seek(), Locate(), Continue())</description></item><item><term>RecCount</term><description>Returns number of records in selection (note that LastRec is not dependent on selection)</description></item><item><term>Average()</term><description>If no scope is specified, makes the calculation over the current selection instead of ALL records</description></item><item><term>Continue()</term><description>Limits the search to the current selection</description></item><item><term>CopyDB(), CopySDF(), CopyDelimited() </term><description>If no scope is specified, copies the current selection instead of ALL records</description></item><item><term>Count()</term><description>If no scope is specified, makes the calculation over the current selection instead of ALL records</description></item><item><term>DeleteAll()</term><description>Deletes all the records of the selection, instead of all records in the file</description></item><item><term>Eval()</term><description>If no scope is specified, evaluates the code block over the current selection instead of ALL records</description></item><item><term>GetArray()</term><description>Limits array to current selection</description></item><item><term>GetLookupTable()</term><description>Limits array to current selection</description></item><item><term>GoTop()</term><description>Goes to first record in selection</description></item><item><term>GoTo()</term><description>Fails if the record number is not within selection</description></item><item><term>GoBottom()</term><description>Goes to last record in selection</description></item><item><term>Locate()</term><description>Succeeds only if the record is found within the selection</description></item><item><term>LockSelection()</term><description>Locks all records in the current selection</description></item><item><term>RecallAll()</term><description>Recalls all the records of the selection, instead of all records in the file</description></item><item><term>Replace()</term><description>If no scope is specified, processes the current selection instead of ALL records</description></item><item><term>Seek()</term><description>Positions to the beginning of the current selection — only if the seek value is the same as the selection value; otherwise, positions to the last record of the file and set the EOF flag.  (Softseek is ignored.)</description></item><item><term>Skip()</term><description>If the move would lead out of the selection: positions to the last record of the selection and sets the EOF flag or positions to the first record in the selection and sets the BOF flag, depending on the direction of the move.</description></item><item><term>Sort(), Sum(), Total()</term><description>If no scope is specified, processes the current selection instead of ALL records</description></item></list><note type="tip">
          The following methods are not subject to the limitations of an active selection:
          AppendDB(), AppendDelimited(), and AppendSDF(), because their scoping parameters apply to the source file, not to this server
          Delete(), because its default is this record rather than all
          Recall(), because its default is this record rather than all
        </note>

        Several Xbase database commands provide a number of options for specifying the scope of the operation through keywords: ALL, REST, NEXT &lt;nRecords&gt;, RECORD &lt;nRecord&gt;, as well as through FOR and WHILE clauses.  The semantics of these clauses, and how they interact when several are specified, are described under "Using DBF Files" in the Programmer's Guide.
        The corresponding DBServer methods (like Average(), AppendDB(), CopyDB(), Sort(), Sum(), Total(), and others) allow the specification of a FOR clause, a WHILE clause and a scope as arguments in the invocation.  In addition, it is possible to set up a "general server scope" using simple assigns (the corresponding accesses are also provided).  This general scope applies whenever one of these bulk processing methods is invoked without an explicit scope.  This approach can in many cases be more convenient.
        For example, to delete the next five records:
        <code language="X#">
          oDB:Scope := 5			// NEXT 5 records
          oDB:Delete()
          oDB:Scope := NIL		// Don't forget to reset the scope!
        </code>
        For example, to delete all the remaining records:
        <code language="X#">
          oDB:Scope := DBScopeRest		// REST
          oDB:Delete()
          oDB:Scope := NIL			// Don't forget to reset the scope!
        </code>
        To count the number of Smiths in New Jersey:
        <code language="X#">
          oDBCust:SetOrder("CustomerName")	// ORDER by name
          oDBCust:Seek("Smith")			// FIND first Smith
          oDBCust:WhileBlock := {||CustomerName = "Smith"}
          // WHILE still on the Smiths...
          oDBCust:ForBlock := {||State = "NJ"}	// FOR 									// customers
          // in NJ...
          Tally := oDBCust:Count()			// COUNT 'em!
          oDBCust:ClearScope()			// RESET everything
        </code>
        Remember to restore the scope afterwards:  the scope is persistent and applies to all following scope-based methods until reset.  The convenience of this style of specifying a scope comes with the danger of leaving it active for too long.  The scope can be reset with the DBServer:ClearScope() method, or by assigning NIL to the individual components.
        The general server scope can be set with:
        Property 	Meaning
        ForBlock	A string or codeblock specifying the FOR condition.
        Scope	DBSCOPEALL, DBSCOPEREST or a number &lt;nRecords&gt; (meaning NEXT &lt;nRecords&gt;).
        WhileBlock	A string or codeblock specifying the WHILE condition.
        Note that there is no provision for specifying a specific record number with this approach.  There is rarely a need to process a specific record (e.g., the average of the salary of record 5).  In cases where there is, such as for Delete(), use RecNo :=  &lt;n&gt;, GoTo(&lt;n&gt;) or Seek(&lt;Value&gt;) to position the server, and then invoke Delete().
        The methods that are subject to the general server scope are:
        <list type="table"><listheader><term>Method Name</term><description>Description</description></listheader><item><term>AppendDB()</term><description>Append records from DBF.</description></item><item><term>AppendDelimited()</term><description>Append records from delimited file.</description></item><item><term>AppendSDF()</term><description>Append records from SDF file.</description></item><item><term>Average()</term><description>Calculate average of expressions.</description></item><item><term>CopyDB()</term><description>Copy records to DBF.</description></item><item><term>CopyDelimited()</term><description>Copy records to delimited file.</description></item><item><term>CopySDF()</term><description>Copy records to SDF file.</description></item><item><term>Count()</term><description>Count how many records match.</description></item><item><term>Delete()</term><description>Delete records.</description></item><item><term>Eval()</term><description>Evaluate code block for each record.</description></item><item><term>Join()</term><description>Join with another DBF, write to DBF.</description></item><item><term>Locate()</term><description>Find record that matches conditions.</description></item><item><term>Recall()</term><description>Recall deleted records.</description></item><item><term>Replace()</term><description>Replace values with data from DBF.</description></item><item><term>Sort()</term><description>Sort records to a DBF.</description></item><item><term>Sum()</term><description>Calculate sums of expressions.</description></item><item><term>Total()</term><description>Summarize fields to a DBF.</description></item></list>
        The default scope is, of course, "no scope," so these methods have the same default behavior as the corresponding commands and functions.  Most of them process all records or all remaining records, depending on how the scope is defined; those for which the default is "the current record" also have corresponding "all" methods:
        <list type="table"><listheader><term>Method Name</term><description>Description</description></listheader><item><term>Delete()</term><description>Delete current record.</description></item><item><term>DeleteAll()</term><description>Delete all records.</description></item><item><term>Recall()</term><description>Recall current record.</description></item><item><term>RecallAll()</term><description>Recall all records.</description></item></list>
        But note that if a selective relation has been specified, the default source scope is the selection, not the entire file.  Thus, we have four levels of inheritance with regard to the scope of an operation:
        1.	The scope that explicitly specified through arguments of the call
        2.	If none was provided, the scope that is set through the ForBlock, WhileBlock and Scope properties
        3.	If none was set, the selection specified with the selective relation
        4.	If no selective relation is active, the entire file
        The exceptions Delete() and Recall() use options 1 and 2, then default to the current record.  DeleteAll() and RecallAll() apply to the current selection, if any; otherwise, to the entire file.  Of course, a selection scope is not relevant to the Append... methods, for which the conditions apply to the source file, not this server.

        The DBServer Editor generates a subclass of the generic DBServer class, one with specific information such as file names and virtual fields created as access/assign methods.

        It is not possible to use the DBServer class to create a database file; the file must exist before a server can be opened on it.  To create a database file, use the DBCreate() (recommended) method, the VODBCreate() function, or the DBServer Editor.

        This section describes the shared access and aliasing mechanisms used when creating multiple DBServer work areas or servers, as well as hybrid object/procedural operation.

        Work area
        Creating a DBServer object opens a database in a work area.  There is no provision for specifying whether a new or existing work area should be used; the DBServer always uses a new work area.

        After the instantiation, the new work area is not selected; the work area that was selected before the instantiation remains active.  Thus, traditional database commands and functions issued after the instantiation of the DBServer does not apply to the newly opened database.  The proper way to operate on the new DBServer is through its methods.
        Shared access
        Creating two DBServer objects on the same database file is equivalent to opening the same file in two different work areas.  The two servers (work areas) each maintain its own position and record locks, and operate as two users sharing access to the same file.

        To allow creating two servers on the same database file (opening the same file in two work areas), they must, of course, be opened in shared mode; otherwise the second attempt produces a sharing violation.  However, this does not raise an error condition, it simply stores an invalid status of the object.  Use the DBServer:Status or DBServer:Used properties after the instantiation to verify if a file was successfully opened.

        Shared mode can be specified as an instantiation parameter (for example, SetExclusive(FALSE) in the Start() function) or as a system default (see DBServer:Init()).
        Alias
        When using the methods of the DBServer to work with the database, an alias is not needed; the DBServer object provides the handle by which the database is referenced.  The alias has no role in operating with a DBServer object, but internally the system needs a unique alias for every work area.
        The DBServer automatically constructs a unique alias.  If the file is not open in any other work area or server, it uses the file name as the alias in the traditional manner, but if the file is already open, it creates a unique alias by appending a number.  Thus, opening the CUSTOMER file twice would produce the two aliases #Customer and #Customer_1.

        The only reason for explicitly using the alias is to perform "hybrid" operation, using traditional, procedural operations with commands or functions on a DBServer object.  This practice is strongly discouraged, however.  Because the DBServer object may not be aware of what is done through the commands, DBServer methods can malfunction after use of procedural commands.  (For more details, see "Using DBF Files" in the Programmer's Guide.)
        It is possible to retrieve the automatically generated alias from the DBServer object, to enable selection of the work area as the focus of procedural database operations:
        <code language="X#">
          oDBCust := DBServer{"customer"}
          cCust := oDBCust:Alias
          SELECT (cCust)
          SKIP
          DELETE
          ? (cCust) -&gt; CustNo
        </code>

        Most of the changes we made in the RDD classes were made to improve the speed of the RDD classes. One change in particular could influence your application: in the old implementation Visual Objects was restoring the ‘current workarea’ after each DbServer:Method call. This is only useful if you are mixing Object Oriented DBF access with traditional work area oriented DBF access. If all you do is Object Oriented DBF access, the work area switching is unnecessary and may have a negative impact on your applications performance.
        Therefore we have added a switch to the RDD classes that allows you do enable/disable this restore mechanism. The default for Visual Objects 2.8 is to NOT restore the workarea. The switch is in the function:
        <code language="X#">DbSetRestoreWorkarea (lEnable)</code>
        This is a global switch, which changes the behaviour of the DBServer class.
        The default value of the lEnable switch is FALSE which means that workarea restoring is disabled. As a result of this at the end of each DbServer method the current workarea is the workarea of the DBServer.
        If you set the lEnable flag to TRUE every DBServer method restores the workarea at the end of the method to the value of the work area at the beginning of the method. This is the old behavior, but costs some extra time.
        The return value of DbSetRestoreWorkarea () is the previous value.
        If lEnable is NIL the switch is not set and SetRestoreWorkarea() returns only the current value.
        DbSetRestoreWorkarea () also changes the internal behaviour of the new internal function __DBSetSelect(siNew). If you call DbSetRestoreWorkarea (TRUE) which is the default __DBSetSelect() is identical to VODBSetSelect(), if  you call DbSetRestoreWorkarea (FALSE) DBSetSelect() is empty and do nothing.

        <note type="tip">
          There have been some major changes in the DbServer class in VO 2.8. Please read the section on the bottom of this topic carefully if you are migrating from an older version of Visual Objects.
        </note></remarks>
    </member>
    <member name="M:VO.DbServer.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a DBServer object.
      </summary>
      <param name="oFile">
        Identifies the DBF file that is to be opened.
        If a string is specified, it corresponds exactly to the file name parameter of the DBUseArea() function; it can contain a full path with drive and directories, or just a file name.
        If a FileSpec object is specified, its file name component is used as the file to open.  It can also contain a full path with drive and directories, or just a file name.
        With either type of parameter, if only a file name is specified, the DBServer works the same way as the USE command or the DBUseArea() function with regard to default path — it is subject to SET PATH and SET DEFAULT, for example.  The extension DBF is assumed by default.
        In either case, after the DBServer object has been successfully created, it contains a FileSpec object with the original file specification.
      </param>
      <param name="lShareMode">Identifies whether the file should be opened in shared mode.  Can be specified as a constant, DBSHARED (TRUE) or DBEXCLUSIVE (FALSE).  If not specified, the default is determined by the SetExclusive() function, which in turn defaults to 'exclusive' or FALSE.</param>
      <param name="lReadOnlyMode">Identifies whether the file should be opened in read only mode. Can be specified as a constant, DBREADONLY (TRUE) DBREADWRITE (FALSE).  If not specified, it defaults to read-write or FALSE.</param>
      <param name="xDriver">The driver can be specified.  If not specified, it defaults to the driver specified by RDDSetDefault() which in turn defaults to DBFNTX.</param>
      <param name="aRdd">A one-dimensional array with the names of RDDs from which the main RDD inherits special functionality.  This allows you to use RDDs with special capabilities, like encryption or decryption, for different data servers with different database drivers.  These RDDs overlay special functions of the main RDD (specified with the &lt;cDriver&gt; argument).  If multiple RDDs (specified with this argument) implement the same function, the function associated with the last RDD in the list takes precedence.  If &lt;aRDDs&gt; is omitted, no additional RDDs are assumed.</param>
      <returns>
        As with all Init() methods, the instantiation returns the object.  An object is created even if the file was not successfully opened, perhaps because the file does not exist, is corrupted or is locked by another user.  Thus, before using the DBServer error, verify that it was successfully opened with the DBServer:Used or Status access methods.
      </returns>
      <example>
        The following examples demonstrate several different methods of constructing a DBServer object:
        <code language="X#">
          \\ Specify only the DBF file
          oDBCust := DBServer{"CUSTOMER"}
          \\ Specify all four parameters
          oDBCust := DBServer{"CUSTOMER",DBSHARED,DBREADONLY, "DBFNTX"}
          \\ Use a FileSpec object specification to define the
          \\ DBF file to open (in "exclusive", read-write mode)
          oFSCust := FileSpec{"d:\data\customer"}
          oDBCust := DBServer{oFSCust,,FALSE}
        </code></example>
    </member>
    <member name="P:VO.DbServer.Alias">
      <summary>
        A string representing the alias of the work area.
      </summary>
      <value>A string representing the alias of the work area.</value>
      <remarks>
        A string representing the alias of the work area.
        <note type="tip">"Hybrid" operation, with procedural commands referencing a DBServer object, is strongly discouraged.  See the discussion of hybrid operation under CLASS DBServer.</note></remarks>
    </member>
    <member name="P:VO.DbServer.AliasSym">
      <summary>
        A symbol representing the alias of a DBServer object.
      </summary>
      <value>A symbol representing the alias of a DBServer object.</value>
      <remarks>
        A symbol representing the alias of a DBServer object.
        <note type="tip">"Hybrid" operation, with procedural commands referencing a DBServer object, is strongly discouraged.  See the discussion of hybrid operation under CLASS DBServer.</note></remarks>
    </member>
    <member name="M:VO.DbServer.Append(XSharp.__Usual)">
      <summary>
        Append a blank record to the table; this blank record becomes the current position and is ready for assignment of data values.  The record is automatically locked if the Append() method returns TRUE.
      </summary>
      <param name="lReleaseLocks">Indicates if existing record locks should be released.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyAppend message, if successful.
      </remarks>
    </member>
    <member name="M:VO.DbServer.AppendDB(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Append new records to the table from another DBF file.
      </summary>
      <param name="oFSSource">
        The source file is opened in shared, read-only mode, and can be open elsewhere in this or some other application.

        This function attempts to open &lt;oDBFSource&gt; | &lt;oFSSource&gt; | &lt;cSource&gt; in shared mode.  If the file does not exist, a runtime error is raised.  If the file is successfully opened, the operation proceeds.  Refer to the 'Concurrency Control' chapter in the Programmer's Guide for more information on resolving concurrency conflicts.
      </param>
      <param name="aFieldList">An array of the fields from the source file that are to be included.  The default is all fields.</param>
      <param name="cbForBlock">The condition evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.</param>
      <param name="cbWhileBlock">The condition evaluated for each record from the first record until the condition returns FALSE.  It provides the same functionality as the WHILE clause of record processing commands.</param>
      <param name="uScope">
        The range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands.
        Value	Description
        DBSCOPEALL	The scope is all the records in the table.  This is the default, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
        DBSCOPEREST	The scope is the remaining records in the table from the current position.
        &lt;nRecords&gt;	The scope is the next &lt;nRecords&gt; records.
      </param>
      <param name="cDriver">The name of the RDD that will service the data server.  If not specified, the default RDD as determined by RDDSetDefault() is used.</param>
      <param name="aRdd">A one-dimensional array with the names of RDDs from which the main RDD inherits special functionality.  This allows you to use RDDs with special capabilities, like encryption or decryption, for different data servers with different database drivers.  These RDDs overlay special functions of the main RDD (specified with the &lt;cDriver&gt; argument).  If multiple RDDs (specified with this argument) implement the same function, the function associated with the last RDD in the list takes precedence.  If &lt;aRDDs&gt; is omitted, no additional RDDs are assumed.</param>
      <returns>
        TRUE if successful; otherwise, FALSE (although records still might have been appended).
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyFileChange message, if any record was appended.
      </remarks>
    </member>
    <member name="M:VO.DbServer.AppendDelimited(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Append new records to the table from a delimited file, such as the "comma-separated-value" (CSV) file format.
      </summary>
      <param name="oFSSource">The source file containing the records to be appended.  The source file is opened in shared, read-only mode, and can be open elsewhere in this or some other application.</param>
      <param name="cDelimiter">The delimiter for fields within a delimited database file. If omitted, the default is NULL_STRING.</param>
      <param name="aFieldList">An array of fields from the source file that are to be included.  The default is all fields.</param>
      <param name="cbForBlock">The condition evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.</param>
      <param name="cbWhileBlock">The condition evaluated for each record from the first record until the condition returns FALSE.  It provides the same functionality as the WHILE clause of record processing commands.</param>
      <param name="uScope">
        The range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands.
        Value	Description
        DBSCOPEALL	The scope is all the records in the table.  This is the default, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
        DBSCOPEREST	The scope is the remaining records in the table from the current position.
        &lt;nRecords&gt;	The scope is the next &lt;nRecords&gt; records.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE (although records still might have been appended).
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyFileChange message, if any record was appended.
      </remarks>
    </member>
    <member name="M:VO.DbServer.AppendSDF(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Append new records to the table from an SDF-formatted file.
      </summary>
      <param name="oFSSource">The source file containing the records to be appended.  The source file is opened in shared, read-only mode, and can be open elsewhere in this or some other application.</param>
      <param name="aFieldList">An array of fields from the source file that are to be included.  The default is all fields.</param>
      <param name="cbForBlock">The condition evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.</param>
      <param name="cbWhileBlock">The condition evaluated for each record from the first record until the condition returns FALSE.  It provides the same functionality as the WHILE clause of record processing commands.</param>
      <param name="uScope">
        The range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands.
        Value	Description
        DBSCOPEALL	The scope is all the records in the table.  This is the default, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
        DBSCOPEREST	The scope is the remaining records in the table from the current position.
        &lt;nRecords&gt;	The scope is the next &lt;nRecords&gt; records.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE (although this can still have caused records to be appended).
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyFileChange message, if any record was appended.
      </remarks>
    </member>
    <member name="M:VO.DbServer.Average(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Calculate the average of a series of numeric expressions, based on the number of actual records involved.
      </summary>
      <param name="acbExpression">The single expression to be averaged or the array of expressions to be averaged.</param>
      <param name="cbForBlock">The condition evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.</param>
      <param name="cbWhileBlock">The condition evaluated for each record from the first record until the condition returns FALSE.  It provides the same functionality as the WHILE clause of record processing commands.</param>
      <param name="uScope">
        The range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands.
        Value	Description
        DBSCOPEALL	The scope is all the records in the table.  This is the default, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
        DBSCOPEREST	The scope is the remaining records in the table from the current position.
        &lt;nRecords&gt;	The scope is the next &lt;nRecords&gt; records.
      </param>
      <returns>
        An array that contains the averages for each field or expression specified.  If a single expression was specified, an array length of 1 is returned.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyRecordChange message upon completion.
        The Average() method allows several averages to be calculated in one pass through the database.  On successful completion, the current record will be the last file record and EOF will be TRUE.
      </remarks>
    </member>
    <member name="M:VO.DbServer.BLOBDirectExport(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Export the contents of a binary large object (BLOB) pointer to a file.
      </summary>
      <param name="nPointer">A pointer to the BLOB data.  This pointer can be obtained using DBServer:BLOBDirectPut(), DBServer:BLOBDirectExport(), or DBServer:FieldInfo(DBS_BLOB_POINTER, &lt;nFieldPos&gt;).</param>
      <param name="oFSTarget">
        The name of the target file where the BLOB data will be written, including an optional drive, directory, and extension.  See SetDefault() and SetPath() for file searching and creation rules.  No default extension is assumed.
        If &lt;oFSTargetFile&gt; | &lt;cTargetFile&gt; does not exist, it is created.  If it exists, this method attempts to open the file in exclusive mode and, if successful, the file is written to without warning or error.  If access is denied because, for example, another process is using the file, NetErr() is set to TRUE and the data server's Status property is set.  Refer to the 'Concurrency Control' chapter in the Programmer's Guide  for more information on resolving concurrency conflicts.
      </param>
      <param name="kMode">
        A constant defining the copy mode, as shown in the table below:
        <pre>
          Constant              Description
          BLOB_EXPORT_APPEND    Appends to the file
          BLOB_EXPORT_OVERWRITE Overwrites the file — this is the default
        </pre></param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">A BLOB file (.DBV or .FPT) is used for storing memo field information, as an alternative to the standard .DBT file mechanism supported by some RDDs.  It is a more powerful and efficient mechanism for storing and retrieving large amounts of data than using .DBT files.  X# supplies the DBFCDX driver, which uses the BLOB file storage mechanism by default, and the DBFBLOB driver, which you can use as an inherited driver with other RDDs.  Refer to the "RDD Specifics" appendix in the Programmer's Guide for further information on using this driver.</note>
      </remarks>
      <example>
        This example extracts an array of pointers from the BLOB file's root area, then uses one of the pointers to export a picture to a file:
        <code language="X#">
          FUNCTION PutPix()
          LOCAL cPixFile AS STRING
          LOCAL nPointer
          LOCAL aBLOBPtrs AS ARRAY
          LOCAL oDBCust AS DBServer
          cPixFile := "picture.gif"
          // Customer data server with a picture of each
          // customer stored in a field called Pix
          oDBCust := Customer{}
          // Assumes that the program previously stored
          // an array of direct BLOB pointers into the root area of the BLOB file.
          // The picture that we want is assumed to be the second array element.
          aBLOBPtrs := BLOBRootGet()
          nPointer := aBLOBPtrs[2]
          // Export picture pointed to by nPointer to a file
          IF !oDBCust:BLOBDirectExport(nPointer, cPixFile, BLOB_EXPORT_OVERWRITE)
          Alert("Export of picture " + cPixFile + "failed!")
          ELSE
          // Code for displaying picture would go here
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.DbServer.BLOBDirectGet(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Retrieve data stored in a BLOB file without referencing a specific field.
      </summary>
      <param name="nPointer">A pointer to the BLOB data.  This pointer can be obtained using DBServer:BLOBDirectPut(), DBServer:BLOBDirectImport(), or DBServer:FieldInfo(DBS_BLOB_POINTER, &lt;nFieldPos&gt;).</param>
      <param name="nStart">The starting position in &lt;nPointer&gt;.  If &lt;nStart&gt; is positive, the starting position is relative to the leftmost character in &lt;nPointer&gt;.  If &lt;nStart&gt; is negative, it is relative to the rightmost character in &lt;nPointer&gt;.  If &lt;nStart&gt; is omitted, it is assumed to be 1.</param>
      <param name="nCount">
        The number of bytes of data to retrieve, beginning at &lt;nStart&gt;.  If &lt;nCount&gt; is larger than the amount of data stored, excess data is ignored.  If omitted, DBServer:BLOBDirectGet() retrieves to the end of the data.
      </param>
      <returns>
        The data retrieved from the BLOB file.  The data type of the return value depends on the actual data stored.  Use ValType() or UsualType() to determine the data type.
      </returns>
      <remarks>
        <note type="tip">&lt;nStart&gt; and &lt;nCount&gt; apply to string data only.  They are ignored for any other data types.</note>
        DBServer:BLOBDirectGet() retrieves data stored in a BLOB file without the need to reference a particular field in the data server.  It is particularly useful when accessing data that is larger than 64 KB, (such as memo fields created with the BLOBImport() method).
      </remarks>
      <example>
        This example illustrates storing setup information in a BLOB file, then selectively retrieving the stored information:
        <code language="X#">
          FUNCTION PutSettings(aColors AS ARRAY,;
          aPaths AS ARRAY, aPW AS ARRAY) AS VOID
          LOCAL aSettings AS ARRAY
          LOCAL oDBSetup AS DBServer
          oDBSetup := Setup{}
          aSettings := {}
          AAdd(aSettings, oDBSetup:BLOBDirectPut(0, aColors))
          AAdd(aSettings, oDBSetup:BLOBDirectPut(0, aPaths))
          AAdd(aSettings, oDBSetup:BLOBDirectPut(0, aPW))
          oDBSetup:BLOBRootPut(aSettings)
          oDBSetup:Close()
          FUNCTION GetColors() AS ARRAY
          LOCAL aSettings AS ARRAY
          LOCAL aColors   AS ARRAY
          LOCAL oDBSetup AS DBServer
          oDBSetup := Setup{}
          aSettings := oDBSetup:BLOBRootGet()
          aColors := oDBSetup:BLOBDirectGet(aSettings[1])
          oDBSetup:Close()
          RETURN aColors
        </code></example>
    </member>
    <member name="M:VO.DbServer.BLOBDirectImport(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Import a file into a BLOB file and return a pointer to the data.
      </summary>
      <param name="nPointer">
        A pointer to the BLOB data which will be released after the import.  This pointer can be obtained using DBServer:BLOBDirectPut(), DBServer:BLOBDirectImport(), or DBServer:FieldInfo(DBS_BLOB_POINTER, &lt;nFieldPos&gt;).  Passing 0 disables the release of data.
        <br />Important!  If specified, DBServer:BLOBDirectImport() releases the space associated with &lt;nOldPointer&gt; for reuse by other data.  Therefore, it is illegal to use &lt;nOldPointer&gt; with any of the BLOB methods after passing it as an argument to this method.  Use the method's return value to refer to the newly stored data.
      </param>
      <param name="oFSSource">
        The name of the file from which to read the BLOB data, including an optional drive, directory, and extension.  See SetDefault() and SetPath() for file searching and creation rules.  No default extension is assumed.
      </param>
      <returns>
        A numeric pointer to the BLOB image stored in &lt;oFSTargetFile&gt; | &lt;cTargetFile&gt;.
      </returns>
      <remarks>
        This method attempts to open &lt;oFSTargetFile&gt; | &lt;cTargetFile&gt; in shared mode.  If the file does not exist, a runtime error is raised.  If the file is successfully opened, the operation proceeds.  If access is denied because, for example, another process has exclusive use of the file, NetErr() is set to TRUE and the data server's Status property is set.  Refer to the 'Concurrency Control' chapter in the Programmer's Guide for more information on resolving concurrency conflicts.
        <note type="tip">There are no restrictions on the size of &lt;oFSTargetFile&gt; | &lt;cTargetFile&gt; except that you must have enough disk space to make the copy.</note>
        DBServer:BLOBDirectImport() provides a mechanism for copying the contents of a file into a BLOB file.
        DBServer:BLOBDirectImport() is used in conjunction with DBServer:BLOBDirectExport() to transfer data back and forth between external files and BLOB files.  You can use DBServer:BLOBDirectImport() with a variety of file types, including graphics images, word processor files, and printer fonts.  These two methods are excellent for creating databases of documents, graphics, sounds, and so on.
        <br />Important!  After importing a file with DBServer:BLOBDirectImport(), nNewPointer, the return value, is the only way to access the data from the BLOB file.  It is up to you, the developer, to provide permanent storage for this reference (see example below)
        <note type="tip">DBServer:FieldInfo(DBS_BLOB_TYPE, &lt;nFieldPos&gt;) will return "C" (string) for any memo field created using DBServer:BLOBDirectImport().</note></remarks>
      <example>
        This example imports a .BMP file to be part of an array of startup data.  The data, stored in the root area of the BLOB file, could then be used to display the application's startup screen:
        <code language="X#">
          FUNCTION PutPix()
          LOCAL cBMPFile AS STRING
          LOCAL aSettings AS ARRAY
          LOCAL oDBCust AS DBServer
          cBMPFile := "logo.bmp"
          aSettings := {}
          // Customer database where startup parameters
          // are stored for convenience
          oDBCust := Customer{}
          // Get default path settings
          AAdd(aSettings, StartPaths())
          // Get default color settings
          AAdd(aSettings, DefaultColors())
          // Get company logo for display at startup.
          // There is nothing to free because this
          // is the first time importing.
          nPointer := oDBCust:BLOBDirectImport(0, cBMPFile)
          AAdd(aSettings, nPointer)
          // Store the settings in the root area of
          // the customer.fpt file
          oDBCust:BLOBRootPut(aSettings)
        </code></example>
    </member>
    <member name="M:VO.DbServer.BLOBDirectPut(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Put data in a BLOB file without referencing a specific field.
      </summary>
      <param name="nPointer">
        A reference to previously stored BLOB data.  This reference can be obtained using DBServer:BLOBDirectPut(), DBServer:BLOBDirectImport(), or DBServer:FieldInfo(DBS_BLOB_POINTER, &lt;nFieldPos&gt;).  If other than 0, the data referenced by &lt;nOldPointer&gt; is replaced by &lt;uBLOB&gt;; otherwise, &lt;uBLOB&gt; is added to the current contents of the BLOB file.
        <br />Important!  If specified, DBServer:BLOBDirectPut() releases the space associated with &lt;nOldPointer&gt; for reuse by other data.  Therefore, it is illegal to use &lt;nOldPointer&gt; with any of the BLOB methods after passing it as an argument to this method.  Use the method's return value to refer to the newly stored data.
      </param>
      <param name="uBlob">The data you want to put into the BLOB file.  &lt;uBLOB&gt; can be any X# usual data type, except code block and object.</param>
      <returns>
        A numeric pointer to the &lt;uBLOB&gt; data.
      </returns>
      <remarks>
        DBServer:BLOBDirectPut() stores variable length BLOB data without creating a link with a particular memo field in a data server.  After adding data to a BLOB file using DBServer:BLOBDirectPut(), you should store the method's return value, as this is the only way to access the data from the BLOB file.  It is up to you, the developer, to provide permanent storage for this reference (see DBServer:BLOBRootPut()).
      </remarks>
      <example>
        This example illustrates storing setup information in a BLOB file, then selectively retrieving the stored information:
        <code language="X#">
          FUNCTION PutSettings(aColors AS ARRAY,;
          aPaths AS ARRAY, aPW AS ARRAY) AS VOID
          LOCAL aSettings AS ARRAY
          LOCAL oDBSetup AS DBServer
          oDBSetup := Setup{}
          aSettings := {}
          AAdd(aSettings, oDBSetup:BLOBDirectPut(0, aColors))
          AAdd(aSettings, oDBSetup:BLOBDirectPut(0, aPaths))
          AAdd(aSettings, oDBSetup :BLOBDirectPut(0, aPW))
          oDBSetup:BLOBRootPut(aSettings)
          oDBSetup:Close()
          FUNCTION GetColors() AS ARRAY
          LOCAL aSettings AS ARRAY
          LOCAL aColors AS ARRAY
          LOCAL oDBSetup AS DBServer
          oDBSetup := Setup{}
          aSettings := oDBSetup:BLOBRootGet()
          aColors := oDBSetup:BLOBDirectGet(aSettings[1])
          oDBSetup:Close()
          RETURN aColors
        </code></example>
    </member>
    <member name="M:VO.DbServer.BLOBExport(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Copy the contents of a BLOB, identified by its memo field number, to a file.
      </summary>
      <param name="uField">The name, number, or symbol representing the position of the field in the database file structure.</param>
      <param name="oFSTarget">
        The name of the target file where the BLOB data will be written, including an optional drive, directory, and extension.  
        See SetDefault() and SetPath() for file searching and creation rules.  No default extension is assumed.
        If &lt;oFSTargetFile&gt; does not exist, it is created.  If it exists, this method attempts to 
        open the file in exclusive mode and, if successful, the file is written to without warning or error.  If access is denied because, 
        for example, another process is using the file, NetErr() is set to TRUE and the data server's Status property is set.  
      </param>
      <param name="kMode">
        A constant defining the copy mode, as shown in the table below:
        <pre>
          Constant				Description
          BLOB_EXPORT_APPEND	Appends to the file
          BLOB_EXPORT_OVERWRITE	Overwrites the file — this is the default
        </pre></param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <example>
        This example exports the contents of a field that stores a picture to a .GIF file, so that the file can be programmatically displayed:
        <code language="X#">
          FUNCTION ShowPix()
          LOCAL cPixFile := "picture.gif" AS STRING
          LOCAL nPos
          LOCAL oDBCust AS DBServer
          // Customer database with a picture of each 	// customer stored in a field called Pix
          oDBCust := Customer{}
          nPos := oDBCust:FieldPos("Pix")
          // Export the BLOB file's data
          // for the current Pix field
          IF !oDBCust:BLOBExport(nPos, cPixFile, ;
          BLOB_EXPORT_OVERWRITE)
          Alert("Export of picture " + cPixFile + " failed!")
          ELSE
          // Code for displaying picture would go here
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.DbServer.BLOBGet(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Get the contents of a BLOB, identified by its memo field number.
      </summary>
      <param name="uField">The name, number, or symbol representing the position of the field in the database file structure.</param>
      <param name="nStart">The starting position in the memo field of the BLOB data.  If &lt;nStart&gt; is positive, the starting position is relative to the leftmost character in &lt;uFieldPos&gt;.  If &lt;nStart&gt; is negative, it is relative to the rightmost character in &lt;uFieldPos&gt;.  If &lt;nStart&gt; is omitted, it is assumed to be 1.</param>
      <param name="nCount">
        The number of bytes of data to retrieve, beginning at &lt;nStart&gt;.  If &lt;nCount&gt; is larger than the amount of data stored, excess data is ignored.  If omitted, DBServer:BLOBGet() retrieves to the end of the data.
      </param>
      <returns>
        The BLOB data retrieved from the memo field.  The data type of the return value depends on the actual data stored.  Use ValType() or UsualType() to determine the data type.  If the indicated field is not a memo field, DBServer:BLOBGet() returns NIL.
      </returns>
      <remarks>
        <note type="tip">&lt;nStart&gt; and &lt;nCount&gt; apply to string data only.  They are ignored for any other data types.</note>
        DBServer:BLOBGet() is very similar to DBServer:FieldGet().  However, because string type variables cannot be larger than 64 KB, DBServer:FieldGet() will raise a runtime error when attempting to retrieve memo fields of this magnitude or greater.
        DBServer:BLOBGet() will also raise an error if you attempt to retrieve a field greater than this magnitude; however, you can retrieve any subset of the BLOB data by using an &lt;nCount&gt; less than 64 KB.
        <note type="tip">BLOB data less than 64 KB can be retrieved from a memo field using standard means (for example, referring to the field by name in an expression or using the DBServer:FieldGet() method).</note></remarks>
      <example>
        This example imports information from a word processing document into a field, then uses DBServer:BLOBGet() to extract the first 25 characters of the field:
        <code language="X#">
          FUNCTION GetFirst25()
          LOCAL nPos
          LOCAL cStr AS STRING
          LOCAL oDBCust := Customer{}
          oDBCust := Customer{}
          // Field that contains word processor documentation
          nPos := oDBCust:FieldPos("WP_DOC")
          // Import a file (can be larger than 64 KB), then obtain the
          // first 25 characters to show to the user
          IF oDBCust:BLOBImport(nPos, "c:\app\temp.doc")
          cStr := oDBCust:BLOBGet(nPos, 1, 25)
          ELSE
          cStr := "Error: could not import file!"
          ENDIF
          oDBCust:Close()
          RETURN cStr
        </code></example>
    </member>
    <member name="M:VO.DbServer.BLOBImport(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Read the contents of a file as a BLOB, identified by a memo field number.
      </summary>
      <param name="uField">The name, number, or symbol representing the position of the field in the database file structure.</param>
      <param name="oFSSource">
        The name of the file from which to read the BLOB data, including an optional drive, directory, and extension.  See SetDefault() and SetPath() for file searching and creation rules.  No default extension is assumed.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method attempts to open &lt;oFSSourceFile&gt; | &lt;cSourceFile&gt; in shared mode.  If the file does not exist, a runtime error is raised.  If the file is successfully opened, the operation proceeds.  If access is denied because, for example, another process has exclusive use of the file, NetErr() is set to TRUE and the data server's Status property is set.  Refer to the 'Concurrency Control' chapter in the Programmer's Guide for more information on resolving concurrency conflicts.
        <note type="tip">There are no restrictions on the size of &lt;oFSSourceFile&gt; | &lt;cSourceFile&gt; except that you must have enough disk space to make the copy.</note>
        DBServer:BLOBImport() provides a mechanism for copying the contents of a file into a memo field as BLOB data.
        DBServer:BLOBImport() is used in conjunction with DBServer:BLOBExport() to transfer BLOB data back and forth between files and memo fields.  You can use DBServer:BLOBImport() with a variety of file types, including graphics images, word processor files, and printer fonts.  These two methods are excellent for creating databases of documents, graphics, sounds, and so on.
        DBServer:BlobImport() sends a NotifyFieldChange message upon successful completion.
        <note type="tip">DBServer:FieldInfo(DBS_BLOB_TYPE, &lt;uFieldPos&gt;) will return "C" (string) for any memo field created using DBServer:BLOBImport().</note></remarks>
      <example>
        This example imports information from a word processing document into a field, then uses DBServer:BLOBGet() to extract the first 25 characters of the field:
        <code language="X#">
          FUNCTION Populate()
          LOCAL oDBCust AS DBServer
          oDBCust := Customer{}
          // Construct unique name based on last name 	// and id
          DO WHILE .NOT. oDBCust:EOF
          oDBCust:GetPix("Pix", ;
          Substr(oDBCust:LastName, 1, 4) + oDBCust:CustID)
          oDBCust:Skip()
          ENDDO
          METHOD GetPix(cPixField, cPixFile) CLASS Customer
          LOCAL nPos
          nPos := SELF:FieldPos(cPixField)
          // Import the picture file into indicated 	// field
          IF !SELF:BLOBImport(nPos, cPixFile)
          Alert("Import of picture " + cPixFile + " 	failed!")
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.DbServer.BLOBRootGet">
      <summary>
        Retrieve the data from the root area of a BLOB file.
      </summary>
      <returns>
        The data retrieved from the root of the BLOB file.  The data type of the return value depends on the actual data stored.  Use ValType() or UsualType() to determine the data type.  Note that DBServer:BLOBRootGet() returns NIL if the root reference has never been written to with DBServer:BLOBRootPut().
      </returns>
      <remarks>
        DBServer:BLOBRootGet() allows the retrieval of a BLOB from the root of a BLOB file.
        <note type="tip">Because the root data does not reference a particular record in the data server, it is not affected by DBServer:RLock(), nor is it subject to the DataServer:ConcurrencyControl settings.  Therefore, if the data server is opened in shared mode, you should use DBServer:BLOBRootLock() before calling DBServer:BLOBRootGet().</note></remarks>
      <example>
        This example uses DBServer:BLOBRootGet() to read system settings from a BLOB file into an array, then demonstrates how to allow the user to modify the settings are restore them in the BLOB file:
        <code language="X#">
          FUNCTION UpdateSettings()
          LOCAL aSettings AS ARRAY
          LOCAL oDBCust AS DBServer
          oDBCust := Customer{}
          IF oDBCust:BLOBRootLock()
          // Get any existing settings
          aSettings := oDBCust:BLOBRootGet()
          IF Empty(aSettings)
          // This method would populate aSettings
          // with default data
          aSettings := oDBCust:GetDefaultSettings()
          ENDIF
          // This method would allow the user to
          // modify the settings.
          IF oDBCust:ModifySettings(aSettings)
          // Finally, store the settings
          oDBCust:BLOBRootPut(aSettings)
          ENDIF
          oDBCust:BLOBRootUnlock()
          ELSE
          aSettings := {}
          Alert("Could not obtain a lock on the root")
          ENDIF
          oDBCust:Close()
          RETURN aSettings
        </code></example>
    </member>
    <member name="M:VO.DbServer.BLOBRootLock">
      <summary>
        Obtain a lock on the root area of a BLOB file.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Use DBServer:BLOBRootLock() when accessing the data server in shared mode to obtain a lock on the root area of a BLOB file for reading from or writing to the root area.
      </remarks>
      <example>
        This example illustrates how to properly lock and unlock the root area of a BLOB file for a data server opened in shared mode.
        <code language="X#">
          FUNCTION GetSettings()
          LOCAL aCustSettings AS ARRAY
          LOCAL oDBCust AS DBServer
          // Open a customer file in shared mode
          oDBCust := Customer{}
          IF oDBCust:BLOBRootLock()
          aCustSettings := oDBCust:BLOBRootGet()
          oDBCust:BLOBRootUnlock()
          ELSE
          Alert("Could not obtain root lock")
          ENDIF
          oDBCust:Close()
          RETURN aCustSettings
        </code></example>
    </member>
    <member name="M:VO.DbServer.BLOBRootPut(XSharp.__Usual)">
      <summary>
        Store data in the root area of a BLOB file.
      </summary>
      <param name="uBlob">The data you want to put into the BLOB file's root area.  &lt;uBLOB&gt; can be any X# usual data type, except code block and object.</param>
      <returns>
        TRUE if successful; otherwise FALSE.
      </returns>
      <remarks>
        DBServer:BLOBRootPut() allows the storage of one — and only one — piece of data to a BLOB file's root area (there is no size limitation on this one piece of data).  After storing the new data, DBServer:BLOBRootPut() releases the space associated with any data previously stored in the BLOB file's root area.
        <note type="tip">Because the root data does not reference a particular record in the data server, it is not affected by DBServer:RLock(), nor is it subject to the DataServer:ConcurrencyControl settings.  Therefore, if the data server is opened in shared mode, you should use DBServer:BLOBRootLock() before calling DBServer:BLOBRootGet().</note></remarks>
      <example>
        This example uses DBServer:BLOBRootPut() to store system settings to a BLOB file after modification:
        <code language="X#">
          FUNCTION UpdateSettings()
          LOCAL aSettings AS ARRAY
          LOCAL oDBCust AS DBServer
          oDBCust := Customer{}
          IF oDBCust:BLOBRootLock()
          // Get any existing settings
          aSettings := oDBCust:BLOBRootGet()
          IF Empty(aSettings)
          // This function would populate 				// aSettings with default data
          aSettings := oDBCust:GetDefaultSettings()
          ENDIF
          // This function would allow the user to
          // modify the settings.
          IF oDBCust:ModifySettings(aSettings)
          // Finally, store the settings
          oDBCust:BLOBRootPut(aSettings)
          ENDIF
          oDBCust:BLOBRootUnlock()
          ELSE
          aSettings := {}
          Alert("Could not obtain a lock on the root")
          ENDIF
          oDBCust:Close()
          RETURN aSettings
        </code></example>
    </member>
    <member name="M:VO.DbServer.BLOBRootUnlock">
      <summary>
        Release the lock on a BLOB file's root area.
      </summary>
      <remarks>
        Use DBServer:BLOBRootUnlock() to release a lock previously obtained using DBServer:BLOBRootLock().
        <note type="tip">The only methods that require the use of DBServer:BLOBRootLock() or DBServer:BLOBRootUnlock() are DBServer:BLOBRootGet() and DBServer:BLOBRootPut().</note></remarks>
      <example>
        This example illustrates how to properly lock and unlock the root area of a BLOB file for a data server opened in shared mode.
        <code language="X#">
          FUNCTION GetSettings()
          LOCAL aCustSettings AS ARRAY
          LOCAL oDBCust AS DBServer
          // Open a customer file in shared mode
          oDBCust := Customer{}
          IF oDBCust:BLOBRootLock()
          aCustSettings := oDBCust:BLOBRootGet()
          oDBCust:BLOBRootUnlock()
          ELSE
          Alert("Could not obtain root lock")
          ENDIF
          oDBCust:Close()
          RETURN aCustSettings
        </code></example>
    </member>
    <member name="P:VO.DbServer.BoF">
      <summary>
        A logical value indicating whether the server is positioned at the beginning of the file, on the first record.
      </summary>
      <value>A logical value indicating whether the server is positioned at the beginning of the file, on the first record.</value>
      <remarks>
        A logical value indicating whether the server is positioned at the beginning of the file, on the first record.
        It returns TRUE after an attempt to move backward beyond the first logical record in a database file; otherwise, it returns FALSE.  If the current database file contains no records, BOF also returns TRUE.
      </remarks>
      <example>
        This example demonstrates BOF by attempting to move the record pointer before the first record:
        <code language="X#">
          CLASS Sales INHERIT DBServer
          ...
          FUNCTION BOFDemo()
          LOCAL oDBSales AS Sales
          oDBSales := Sales{}
          ? ODBSales:BOF		// Result: FALSE
          oDBSales:Skip(-1)
          ? ODBSales:BOF		// Result: TRUE
        </code></example>
    </member>
    <member name="M:VO.DbServer.ClearFilter">
      <summary>
        Clear a filter condition specified with the DBServer:SetFilter() method.
      </summary>
      <returns>
        TRUE if successful; otherwise, it returns FALSE.
      </returns>
    </member>
    <member name="M:VO.DbServer.ClearIndex(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Clear all indexes currently associated with the server.
      </summary>
      <param name="uOrder">The name of an order, or the ordinal position of the order within the order list.  A value of 0 specifies the controlling index, without regard to its actual position in the list.</param>
      <param name="cOrdBag">The name of the orderbag in which the order resides.  </param>
      <returns>
        TRUE if successful; otherwise, it returns FALSE.
      </returns>
    </member>
    <member name="M:VO.DbServer.ClearLocate">
      <summary>
        Clear the LOCATE condition of the server, if any.
      </summary>
      <returns>
        TRUE if successful; otherwise, it returns FALSE.
      </returns>
    </member>
    <member name="M:VO.DbServer.ClearOrderScope">
      <summary>
        Set or clear the boundaries for scoping key values in the controlling order.
      </summary>
      <remarks>
        DBServer:ClearOrderScope() resets the values set by the DBServer:OrderScope() method.
      </remarks>
    </member>
    <member name="M:VO.DbServer.ClearRelation">
      <summary>
        Clear all active relations held by this server to other servers.
      </summary>
      <returns>
        TRUE if successful; otherwise, it returns FALSE.
      </returns>
    </member>
    <member name="M:VO.DbServer.ClearScope">
      <summary>
        Clear the settings that define the default scope for multi-record operations.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.DbServer.Close">
      <summary>
        Close the database file and its associated index files.
      </summary>
      <returns>
        TRUE if the operation was successful; FALSE if not.
      </returns>
      <remarks>
        It will also help the garbage collector if you set the &lt;oDBServer&gt; to NULL_OBJECT after closing it.
      </remarks>
    </member>
    <member name="M:VO.DbServer.Commit">
      <summary>
        Commit all changes to disk from the buffer, ensuring that all buffers are flushed.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyCompletion message, if successful.  If using in conjunction with an Unlock() method, then the Commit() method should be executed prior to the Unlock() method call.  Using a Commit() when scanning numerous records can be a very slow process, thus you may want to limit your Commit() statements to every 10 or 20 records to speed up your process.
        Note that DBServer:Commit() can fail for many reasons, ranging from a lack of capability in the server to lock conflicts and technical problems, such as network crashes.  Use the DBServer:Status property to determine the exact cause of the failure.

        DBCommit() Function
      </remarks>
    </member>
    <member name="P:VO.DbServer.ConcurrencyControl">
      <summary>
        A constant, identifying the mode of automatic concurrency control for this data server, determining when and how records are locked and released:
      </summary>
      <value>A constant, identifying the mode of automatic concurrency control for this data server, determining when and how records are locked and released:</value>
      <remarks>
        One of the following constants, identifying the mode of automatic concurrency control for this data server, determining when and how records are locked and released:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>CCNONE</term><description>The data server provides no automatic record locking; the application is required to do all locking explicitly. </description></item><item><term>CCOPTIMISTIC</term><description>
              No locks are maintained continuously except when appending — the record just appended is locked, and the lock is only
              released when moving off the record or explicitly calling the DataServer or DBServer Unlock() method.
              For all other records, the record is reread from disk before any update is done.  This is the <b>default</b>.
            </description></item><item><term>CCSTABLE</term><description>The record that the window is sitting on is always kept locked.  Note that when in browse view, the row that the cursor is on represents the current record.</description></item><item><term>CCREPEATABLE</term><description>All records that have been read are maintained locked.  The user is guaranteed that when moving back among previously viewed data, they are unchanged.</description></item><item><term>CCFILE</term><description>All the records in the entire set provided by the server are locked throughout.  This is not very practical for windows associated with all the records of a server, since it would correspond to a file lock.  It is intended to be used in conjunction with method DBServer:SetSelectiveRelation(). </description></item></list></remarks>
      <example>
        This example sets up the Sales:Init() method to accept the open mode for the server as an argument.  Then, the oDBSales server is opened using CCNONE, indicating that any application using this server must supply code for explicit locking:
        <code language="X#">
          CLASS Sales INHERIT DBServer
          ...
          METHOD Init(kOpenMode) CLASS Sales
          ...
          SELF:ConcurrencyControl := kOpenMode
          FUNCTION CreateSales()
          LOCAL oDBSales AS Sales
          oDBSales := Sales{CCNONE}
          ...
        </code></example>
    </member>
    <member name="M:VO.DbServer.ConstructUniqueAlias(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="cFileName">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.DbServer.Continue">
      <summary>
        Resume a pending DBServer:Locate() operation, searching for the next record that matches (like the DBContinue() function).
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.  After the operation, the DBServer:Found access can be used to determine if a record was found.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyRecordChange message upon completion, whether successful or not.
        Continue respects the FOR clause of the original Locate(), but ignores any WHILE clause and scope.  If you want to continue searching with the WHILE clause of the original Locate() operation, set the scope to REST and do another Locate().  If DBServer:Found returns FALSE, the current record will be the last record and DBServer:EOF will be TRUE.
      </remarks>
    </member>
    <member name="M:VO.DbServer.CopyDB(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Copy records to another DBF file.
      </summary>
      <param name="oFSTarget">The file to which the records is copied.  This file is opened exclusively during the operation, so it should not be open elsewhere with write capability.</param>
      <param name="aFieldList">An array of the fields that are to be included in the records to be copied.  The default is all fields.</param>
      <param name="cbForBlock">The condition evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.</param>
      <param name="cbWhileBlock">The condition evaluated for each record from the current record until the condition returns FALSE.  It provides the same functionality as the WHILE clause of record processing commands.</param>
      <param name="uScope">
        The range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands.
        Value	Description
        DBSCOPEALL	The scope is all the records in the table.  This is the default, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
        DBSCOPEREST	The scope is the remaining records in the table from the current position.
        &lt;nRecords&gt;	The scope is the next &lt;nRecords&gt; records.
      </param>
      <param name="cdriver">The name of the RDD that will service the data server.  If not specified, the default RDD as determined by RDDSetDefault() is used.</param>
      <param name="aRdd">A one-dimensional array with the names of RDDs from which the main RDD inherits special functionality.  This allows you to use RDDs with special capabilities, like encryption or decryption, for different data servers with different database drivers.  These RDDs overlay special functions of the main RDD (specified with the &lt;cDriver&gt; argument).  If multiple RDDs (specified with this argument) implement the same function, the function associated with the last RDD in the list takes precedence.  If &lt;aRDDs&gt; is omitted, no additional RDDs are assumed.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.  Note that after a FALSE indication, records can still have been copied to the target: the operation can have failed halfway through because the disk had been filled or other problems.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyRecordChange message upon completion.
        This method does not open the new file, it simply creates the file on disk.  If you want to open it afterwards, you simply instantiate it directly.
      </remarks>
      <example>
        The example below creates the file and instantiates it to open it.
        <code language="X#">
          IF oDB1:CopyDB(oFSTarget)
          oDB2 := DBServer{oFSTarget}
          ELSE
          ...
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.DbServer.CopyDelimited(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Copy records to a delimited file.
      </summary>
      <param name="oFSTarget">The file to which the records is copied.</param>
      <param name="cDelimiter">The delimiter for fields within a delimited database file. If omitted, the default is NULL_STRING.</param>
      <param name="aFieldList">An array of fields that are to be included in the records to be copied.  The default is all fields.</param>
      <param name="cbForBlock">
        The condition evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.
      </param>
      <param name="cbWhileBlock">The condition evaluated for each record from the current record until the condition returns FALSE.  It provides the same functionality as the WHILE clause of record processing commands.</param>
      <param name="uScope">
        The range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands.
        Value	Description
        DBSCOPEALL	The scope is all the records in the table.  This is the default, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
        DBSCOPEREST	The scope is the remaining records in the table from the current position.
        &lt;nRecords&gt;	The scope is the next &lt;nRecords&gt; records.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.  Note that after a FALSE indication, records can still have been copied to the target: the operation can have failed halfway through because the disk had been filled or other problems.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyRecordChange message upon completion.
      </remarks>
    </member>
    <member name="M:VO.DbServer.CopySDF(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Copy records to an SDF file.
      </summary>
      <param name="oFSTarget">The file to which the records is copied.</param>
      <param name="aFieldList">An array of fields that are to be included in the records to be copied.  The default is all fields.</param>
      <param name="cbForBlock">
        The condition evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.
      </param>
      <param name="cbWhileBlock">The condition evaluated for each record from the current record until the condition returns FALSE.  It provides the same functionality as the WHILE clause of record processing commands.</param>
      <param name="uScope">
        The range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands.
        Value	Description
        DBSCOPEALL	The scope is all the records in the table.  This is the default, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
        DBSCOPEREST	The scope is the remaining records in the table from the current position.
        &lt;nRecords&gt;	The scope is the next &lt;nRecords&gt; records.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.  Note that after a FALSE indication, records can still have been copied to the target: the operation can have failed halfway through because the disk had been filled or other problems.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyRecordChange message upon completion.
      </remarks>
    </member>
    <member name="M:VO.DbServer.CopyStructure(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Create a DBF file with the same record layout as the server object to which the message is sent.
      </summary>
      <param name="oFSTarget">The file to which the record is copied.</param>
      <param name="aFieldList">An array of fields that are to be included in the records to be copied.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyCompletion message, if successful.
        This method does not open the new file; it simply creates the file on disk.  If you want to open it afterwards, you simply instantiate it directly.
      </remarks>
      <example>
        The example below creates the file and instantiates it to open it.
        <code language="X#">
          IF oDB1:CopyStructure(oFSTarget)
          oDB2 := DBServer{oFSTarget}
          ELSE
          ...
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.DbServer.Count(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Return the number of records that match a specified scope.
      </summary>
      <param name="cbForBlock">The condition evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.</param>
      <param name="cbWhileBlock">The condition evaluated for each record from the current record until the condition returns FALSE.  It provides the same functionality as the WHILE clause of record processing commands.</param>
      <param name="uScope">
        The range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands.
        Value	Description
        DBSCOPEALL	The scope is all the records in the table.  This is the default, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
        DBSCOPEREST	The scope is the remaining records in the table from the current position.
        &lt;nRecords&gt;	The scope is the next &lt;nRecords&gt; records.
      </param>
      <returns>
        The number of records that match the scope.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyRecordChange message upon completion.
        On successful completion, the current record will be the last file record and DBServer:EOF will be TRUE.
      </remarks>
      <example>
        Compare with the way the COUNT command is used:
        <code language="X#">
          COUNT TO nBranchCnt FOR Branch = 100
          nBranchCnt := oDBSales:Count({||Branch=100})
        </code></example>
    </member>
    <member name="M:VO.DbServer.CreateIndex(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Create an index file with an order in it.
      </summary>
      <param name="oFSIndex">The name of the index file to be created.</param>
      <param name="cExpr">The indexing expression.</param>
      <param name="cbExpr">The indexing expression.  If a code block is provided, it should match the string expression; if a code block is not provided, one is created from the string expression.</param>
      <param name="lUnique">Whether the index is unique.  If not specified, the default is determined by SetUnique().</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyFileChange message upon completion.
      </remarks>
    </member>
    <member name="M:VO.DbServer.CreateOrder(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Create an order within an existing index file.  The behavior depends on which driver is used.
      </summary>
      <param name="cOrderName">The order name to be used.</param>
      <param name="cIndexFileName">The name of the index file.</param>
      <param name="cExpr">The indexing expression.</param>
      <param name="cbExpr">The indexing expression.  If a code block is provided, it should match the string expression; if a code block is not provided, one is created from the string expression.</param>
      <param name="lUnique">Whether the index is unique.  If not specified, the default is determined by SetUnique().</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyFileChange message upon completion.

        This sample shows how to create a single tag order:
        <code language="X#">
          // If you want descending order by chance, then include this line first:
          &lt;oDbServer&gt;:SetOrderCondition(,,,,,,,,,,TRUE)
          IF &lt;oDbServer&gt;:CREATEORDER( "PlayerName", SELF:cPath + "Players", "Upper(LastName + FirstName + MiddleInit)" )
          &lt;oDbServer&gt;:Commit()
          ELSE
          // If the index tag was not created successfully, then tell somebody about it:  ….
          ENDIF
          // Don't forget to turn the ascending order back on:
          &lt;oDbServer&gt;:SetOrderCondition(,,,,,,,,,,FALSE)
        </code>

        DBCreateOrder() Function
      </remarks>
    </member>
    <member name="M:VO.DbServer.DataField(XSharp.__Usual)">
      <summary>
        Retrieve the data field object at the specified field position.
      </summary>
      <param name="uField">The name, number, or symbol representing the desired field.</param>
    </member>
    <member name="P:VO.DbServer.DBStruct">
      <summary>
        An array containing the structure of this data server, whose length (that is, number of elements) is equal to the number of fields in the server.
      </summary>
      <value>An array containing the structure of this data server, whose length (that is, number of elements) is equal to the number of fields in the server.</value>
      <remarks>
        An array containing the structure of this data server, whose length (that is, number of elements) is equal to the number of fields in the server.
        Each sub-array is comprised of five elements, which contain the following information, in this order:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>DBS_NAME</term><description>cName</description></item><item><term>DBS_TYPE</term><description>cType</description></item><item><term>DBS_LEN</term><description>nLength</description></item><item><term>DBS_DEC</term><description>nDecimals</description></item><item><term>DBS_ALIAS</term><description>cAlias</description></item></list></remarks>
      <example>
        This example opens a database file, then creates an array containing the database structure using DBServer:DBStruct within an aliased expression.  The field names are then listed using AEval():
        <code language="X#">
          CLASS Sales INHERIT DBServer
            ...
          FUNCTION StructDemo()
            LOCAL aStruct AS ARRAY, oDBSales AS DBServer
            oDBSales := Sales{}
            aStruct := oDBSales:DBStruct
            AEval(aStruct, {|aField|QOut(aField[DBS_NAME])})
        </code></example>
    </member>
    <member name="P:VO.DbServer.DbStructure">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.DbServer.Delete(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Delete the current record or the records specified with the scoping parameters.
      </summary>
      <param name="cbForBlock">The condition evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.</param>
      <param name="cbWhileBlock">The condition evaluated for each record from the current record until the condition returns FALSE.  It provides the same functionality as the WHILE clause of record processing commands.</param>
      <param name="uScope">
        The range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands.
        Value	Description
        DBSCOPEALL	The scope is all the records in the table.  This is the default, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
        DBSCOPEREST	The scope is the remaining records in the table from the current position.
        &lt;nRecords&gt;	The scope is the next &lt;nRecords&gt; records.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.  Note that after a FALSE indication of a scoped operation, some records can have been deleted: the operation can have failed halfway through because of lock conflicts or technical problems.
      </returns>
      <remarks>
        If called with a scope or if a server scope is active, Delete() sends a NotifyIntentToMove message before the operation, and a NotifyFileChange upon completion (regardless of the number of records actually deleted).  If no scope is used and Delete() applies to the current record only, it sends a NotifyRecordChange message, if successful.  If a scope is specified, on successful completion, the current record will be the last file record and DBServer:EOF will be TRUE.
        <br />Important!  Since the scope is persistent, a scope left around from processing a method like CopyDB() or Average() could cause Delete() to process too many records.  Remember to reset a scope after it has been used.
        Even though the record is marked for deletion, it remains in the file and can be recalled.  (The current setting of the SetDeleted() function affects whether deleted records are visible.)  If changes have been made to fields, the changes are recorded in the record before it is flagged as deleted; thus, if the field is recalled, it correctly reflects any changes made before the delete operation.
        <note type="tip">DBServer:Delete() does not advance to the next record after the deletion takes place, unlike DataWindow:Delete() which does (if SetDeleted() is TRUE).</note></remarks>
    </member>
    <member name="M:VO.DbServer.DeleteAll">
      <summary>
        Delete all records of the table.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE, but note that, even with FALSE, some records may have been deleted.  This could happen if the operation failed halfway through because of lock conflicts or technical problems.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyFileChange message upon completion.
      </remarks>
    </member>
    <member name="P:VO.DbServer.Deleted">
      <summary>
        A logical value indicating whether the current record is marked as deleted.
      </summary>
      <value>A logical value indicating whether the current record is marked as deleted.</value>
      <remarks>
        A logical value indicating whether the current record is marked as deleted.  Note that a pointer change, such as GoTop(), must be invoked in order for the filter condition to become active.
      </remarks>
      <example>
        This example uses Deleted as a filtering condition with the DBServer:SetFilter() method:
        <code language="X#">
          CLASS Sales INHERIT DBServer
          ...
          FUNCTION IgnoreDeleted()
          LOCAL oDBSales AS Sales
          oDBSales := Sales{}
          oDBSales:SetFilter(!oDBSales:Deleted)
          oDBSales:GoTop()
          .
          . &lt;Process records&gt;
          .
          oDBSales:ClearFilter()
        </code>
        This example uses a compound filtering condition with the DBServer:SetFilter() method, and is also assuming that the Players.dbf file is already open at the class level:
        <code language="X#">
          CLASS Players INHERIT DBServer
          ...
          FUNCTION pbResetFilter()
          Local cFilter
          cFilter	:= [Season = '] + SELF:cSeason + [' .and. .not. empty(TeamNr) ]
          cFilter	+= [ .and. empty(HomePhone)]
          cFilter	+= [ .and. Gender = '] + SELF:cGender + [']
          SELF:oPlayersServer:SetFilter(, cFilter )	// Note placement of comma parameter
          SELF:oPlayersServer:GoTop()
          .
          . &lt;Process records&gt;
          .
          SELF:oPlayersServer:ClearFilter()
        </code></example>
    </member>
    <member name="M:VO.DbServer.DeleteOrder(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Delete an order from an index file.
      </summary>
      <param name="uOrder">The name or number of the order to be deleted.</param>
      <param name="cIndexFileName">The index file does not have to be specified if the order name specified is unique among all the opened orders, or if an order number is used.  But if a non-unique order name is specified, the index file should also be specified.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.DbServer.Driver">
      <summary>
        A string representing the name of the database driver in use with this server.
      </summary>
      <value>A string representing the name of the database driver in use with this server.</value>
      <remarks>
        A string representing the name of the database driver in use with this server.
        The server can be specified as an instantiation parameter to the server.  If no driver is set, the default driver is used; it can be set by RDDSetDefault() or DBSetDriver().
      </remarks>
    </member>
    <member name="P:VO.DbServer.EoF">
      <summary>
        A logical value indicating whether the server is positioned at the end of the file, on the last record
      </summary>
      <value>A logical value indicating whether the server is positioned at the end of the file, on the last record</value>
      <remarks>
        A logical value indicating whether the server is positioned at the end of the file, on the last record.
        It returns TRUE after an attempt is made to move the record pointer beyond the last logical record in a database file; otherwise, FALSE.  If the current database file contains no records, EOF returns TRUE.
      </remarks>
      <example>
        This example demonstrates using EOF as the condition defining a WHILE loop.  Note that while performing a DO loop similar to the one below but you might also be including some other field-to-var comparisons, always have the EOF as the first condition on the DO WHILE line.  This prevents you from comparing field values when you are in fact at an EOF condition:
        <code language="X#">
          CLASS Sales INHERIT DBServer
          ...
          FUNCTION EOFDemo()
          LOCAL oDBSales AS Sales
          oDBSales := Sales{}
          DO WHILE !oDBSales:EOF
          ...
          oDBSales:Skip()
          ENDDO
        </code></example>
    </member>
    <member name="P:VO.DbServer.ErrInfo">
      <summary>
        An Error object identifying the error condition after the last operation.
      </summary>
      <value>An Error object identifying the error condition after the last operation.</value>
      <remarks>
        An Error object identifying the error condition after the last operation.  If the last operation was successful, DBServer:ErrInfo returns NULL_OBJECT.
      </remarks>
      <example>
        This example demonstrates a SEQUENCE construct in which ErrInfo is passed to the RECOVER USING statement:
        <code language="X#">
          CLASS Sales INHERIT DBServer
          ...
          FUNCTION EOFDemo()
          LOCAL oDBSales AS Sales
          oDBSales := Sales{}
          BEGIN SEQUENCE
          .
          . &lt;Some statements that may fail&gt;
          .
          RECOVER USING oDBSales:ErrInfo
          .
          . &lt;Some recovery statements&gt;
          .
          END SEQUENCE
        </code></example>
    </member>
    <member name="M:VO.DbServer.Error(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Provide a method for handling error conditions raised during database processing.
      </summary>
      <param name="oError">An Error object describing the error condition.</param>
      <param name="symMethod">The symbolic name of the method that originated the error.</param>
      <remarks>
        <note type="tip">This is an event handler and is automatically called by other methods; the developer does not normally need to call the DBServer:Error() method, but might want to replace or amend it.</note>
        All methods of the DBServer trap serious errors with a recover statement and send them to this method.  Ordinary failures, such as locking conflicts or record-not-found, do not raise error conditions; they are simply indicated through failure return values.
        The standard Error() handling method fills in some more information about the errors and about the DBServer object that originates the error, sets the status value for the server object, and passes the problem to its client, if there is one, in its standard Error() handling method.  If there is no client who wants to deal with the problem, the method passes it up the call stack by issuing a BREAK with the same Error object.
        <note type="tip">If an error comes in while one is being handled, the Error() method immediately breaks.</note></remarks>
      <example>
        The Skip() method uses the Error() method like this:
        <code language="X#">
          METHOD Skip(n) CLASS DBServer
          LOCAL oError AS USUAL
          BEGIN SEQUENCE
          RETURN (wWorkarea)-&gt;(VODBSkip(...))
          RECOVER USING oError
          SELF:Error(oError,#Skip)
          RETURN FALSE
          END SEQUENCE
        </code></example>
    </member>
    <member name="P:VO.DbServer.ErrorInfo">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.DbServer.Eval(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Evaluate a code block for each record matching a scope and condition.  If neither conditions nor scope is passed to the method, it is subject to the general server scope.
      </summary>
      <param name="cbBlock">The code block to execute for each record processed.</param>
      <param name="cbForBlock">The condition evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.</param>
      <param name="cbWhileBlock">The condition evaluated for each record from the current record until the condition returns FALSE.  It provides the same functionality as the WHILE clause of record processing commands.</param>
      <param name="uScope">
        The range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands.
        Value	Description
        DBSCOPEALL	The scope is all the records in the table.  This is the default, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
        DBSCOPEREST	The scope is the remaining records in the table from the current position.
        &lt;nRecords&gt;	The scope is the next &lt;nRecords&gt; records.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE (but note that even in the case of a failure, some records may have been processed).
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyFileChange message upon completion, whether successful or not.
        On successful completion, the current record will be the last file record and DBServer:EOF will be TRUE.
      </remarks>
    </member>
    <member name="P:VO.DbServer.FCount">
      <summary>
        The number of fields in the server.
      </summary>
      <value>The number of fields in the server.</value>
      <example>
        This example uses FCount as the upper boundary of a FOR loop that processes the list of current work area fields:
        <code language="X#">
          CLASS Sales INHERIT DBServer
          ...
          FUNCTION ListFields()
          LOCAL nField AS SHORTINT, oDBSales AS Sales
          oDBSales := Sales{}
          FOR nField := 1 UPTO oDBSales:FCount
          ? oDBSales:FieldName(nField)
          NEXT
        </code></example>
    </member>
    <member name="P:VO.DbServer.FieldDesc">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.DbServer.FIELDGET(XSharp.__Usual)">
      <summary>
        Get the contents of a field that is identified by its position.
      </summary>
      <param name="uField">The name, number, or symbol representing the desired field.</param>
      <returns>
        The value of the specified field.  If &lt;nFieldPos&gt; does not correspond to the position of any field in the current data server, DBServer:FieldGet() returns NIL.
      </returns>
      <remarks>
        DBServer:FieldGet() retrieves the value of a field using its position within the database file structure rather than its field name.  Within generic database service functions this allows, among other things, the retrieval of field values without use of the macro operator.
        <note type="tip">DBServer:FieldGet() can be used with a BLOB field (that is, a memo field associated with a BLOB file), provided the length of the field does not exceed 64 KB.  For BLOB fields longer than 64 KB, use DBServer:BLOBGet() instead.</note></remarks>
      <example>
        This example compares DBServer:FieldGet() to functionally equivalent code that uses the macro operator to retrieve the value of a field:
        <code language="X#">
          LOCAL nFieldPos := 1, FName, FVal
          LOCAL oDBCust := Customer{} AS DBServer
          // Get field value using macro operator
          FName := oDBCust:FieldName(nFieldPos)
          FVal := &amp;FName
          // Get field value using FieldGet()
          FVal := oDBCust:FieldGet(nFieldPos)
          FVal := oDBCust:FieldGet( #Fname )
          Fval := oDBCust:FieldGet( "Fname" )
        </code></example>
    </member>
    <member name="M:VO.DbServer.FieldGetBytes(XSharp.__Usual)">
      <summary>
        Read an array of bytes direct from the workarea buffer.
      </summary>
      <param name="uField">
        The position of the field in the database file structure for the current work area.
      </param>
      <returns>
        The value of the field.   IF nFieldPos does not correspond to the position of any field in the database file, FieldGetBytes() will generate an error.
      </returns>
    </member>
    <member name="M:VO.DbServer.FieldGetFormatted(XSharp.__Usual)">
      <summary>
        Return the contents of a specified field according to the formatting specifications of its FieldSpec object.
      </summary>
      <param name="uField">The name, number, or symbol representing the desired field.</param>
    </member>
    <member name="M:VO.DbServer.FieldHyperLabel(XSharp.__Usual)">
      <summary>
        Return the hyperlabel of a specified field.
      </summary>
      <param name="uField">The name, number, or symbol representing the desired field.</param>
      <returns>
        The field hyperlabel or NIL.
      </returns>
      <remarks>
        By accessing the hyperlabel, you can in turn access its various properties which annotate the field:
        <code language="X#">
          oDBServer:FieldHyperLabel(#LastName):Caption
          oDBServer:FieldHyperLabel(#LastName):Description
          oDBServer:FieldHyperLabel(#LastName):HelpContext
        </code></remarks>
    </member>
    <member name="M:VO.DbServer.FieldInfo(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Return and optionally change information about a field.
      </summary>
      <param name="kFieldInfoType">
        Specifies the type of information.  The constants are described in the Constants section below.  Note, however, that not all constants are supported for all RDDs.
        <br />Important!  DBS_USER is a constant that returns the minimum value that third-party RDD developers can use for defining new &lt;kInfoType&gt; parameters.  
        Values less than DBS_USER are reserved for development.
      </param>
      <param name="uField">The name, number, or symbol representing the position of the field in the database file structure or a numeric pointer to a BLOB.  
        Only certain &lt;kFieldInfoType&gt; constants designed to work with BLOB fields — all noted in the Constants section below — allow specifying the 
        field using a pointer; all others require specifying the field by its position.</param>
      <param name="uFieldVal">If specified, this parameter is used to change the value of a setting.  The data type (and whether &lt;uNewSetting&gt; can be specified), depends on the &lt;kInfoType&gt; constant and is documented in the Constants section below.</param>
      <returns>
        If &lt;uNewSetting&gt; is not specified, DBServer:FieldInfo() returns the current setting.  If &lt;uNewSetting&gt; is specified, the previous setting is returned.
      </returns>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constants</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>DBS_ALIAS</term>
            <description>Returns and optionally changes an alternate name (or alias) by which a field can be referenced (by default, same as DBS_NAME).  Using the &lt;uNewSetting&gt; argument, you can specify a string that you can subsequently use to access the indicated field.</description>
          </item>
          <item>
            <term>DBS_BLOB_DIRECT_LEN</term>
            <description>Returns the length of data in a BLOB as an unsigned long integer, without referencing a particular memo field.  For strings, the return value is the length of the string in bytes; for arrays, it is the number of elements in the first dimension; for all other data types, it returns -1.  With this constant, you must specify the BLOB using a numeric pointer obtained from DBServer:BLOBDirectPut(), DBServer:BLOBDirectImport(), or DBServer:FieldInfo(DBS_BLOB_POINTER, &lt;uFieldPos&gt;).</description>
          </item>
          <item>
            <term>DBS_BLOB_DIRECT_TYPE</term>
            <description>To determine the data type of BLOB data, without reference to a particular memo field, use DBServer:FieldInfo(DBS_BLOB_DIRECT_TYPE, ...).  With this constant, you must specify the BLOB using a numeric pointer obtained from DBServer:BLOBDirectPut(), DBServer:BLOBDirectImport(), or DBServer:FieldInfo(DBS_BLOB_POINTER, &lt;uFieldPos&gt;).</description>
          </item>
          <item>
            <term></term>
            <description>See DBS_BLOB_TYPE for a table of possible return values.</description>
          </item>
          <item>
            <term>DBS_BLOB_LEN</term>
            <description>
              Returns the length of the BLOB data in a memo field as an unsigned long integer.  For strings, the return value is the length of the string in bytes; for arrays, it is the number of elements in the first dimension; for all other data types, it returns -1.
              <note type="tip">DBServer:FieldInfo(DBS_BLOB_LEN, ...) has a performance advantage over the Len() function.,</note></description>
          </item>
          <item>
            <term>DBS_BLOB_POINTER</term>
            <description>Returns a numeric pointer to the BLOB data associated with a memo field.</description>
          </item>
          <item>
            <term>DBS_BLOB_TYPE</term>
            <description>Unlike memo fields maintained in .DBT files, BLOB files allow you to store many different types of data in memo fields.  However, the standard functions for determining data types, such as ValType(), simply treat BLOB fields as regular memo fields.  To determine the actual type of BLOB data stored in a memo field, use DBServer:FieldInfo(DBS_BLOB_TYPE, ...).  </description>
          </item>
          <item>
            <term></term>
            <description>The data type of the return value is string and can be interpreted using this table:</description>
          </item>
          <item>
            <term>Returns</term>
            <description>Meaning</description>
          </item>
          <item>
            <term>?</term>
            <description>Blank (empty/uninitialized field)</description>
          </item>
          <item>
            <term>A</term>
            <description>Array</description>
          </item>
          <item>
            <term>C</term>
            <description>String</description>
          </item>
          <item>
            <term>D</term>
            <description>Date</description>
          </item>
          <item>
            <term>E</term>
            <description>Error</description>
          </item>
          <item>
            <term>L</term>
            <description>Logical</description>
          </item>
          <item>
            <term>N</term>
            <description>Numeric</description>
          </item>
          <item>
            <term>U</term>
            <description>Undefined (NIL was stored)</description>
          </item>
          <item>
            <term>DBS_DEC</term>
            <description>Returns the number of decimal places for the field.</description>
          </item>
          <item>
            <term>DBS_LEN</term>
            <description>Returns the length of the field.</description>
          </item>
          <item>
            <term>DBS_NAME</term>
            <description>Returns the name of the field.</description>
          </item>
          <item>
            <term>DBS_PROPERTIES</term>
            <description>Returns the number of properties defined for a field.</description>
          </item>
          <item>
            <term>DBS_TYPE</term>
            <description>Returns the data type of the field.</description>
          </item>
        </list>

        DBServer:FieldInfo() retrieves information about the state of a field (column).
        The field information that is available is defined by the RDD.  In the DBF model, this is limited to the information stored in the DBF file structure (that is, name, length, number of decimals, and data type) plus the field alias that can be changed at runtime.
        To support RDDs for other database models (such as dictionary based databases) that store more information about each field or column, the X# RDD API has been enhanced.  The DBServer:FieldInfo() method is designed to allow for additional &lt;kInfoType&gt; values that can be defined by third-party RDD developers.
      </remarks>
      <example>
        The following examples use DBServer:FieldInfo() to retrieve field information:
        <code language="X#">
          METHOD DBOutStruct() CLASS Customer
          LOCAL aStruct AS ARRAY
          LOCAL wFcount AS DWORD
          LOCAL i       AS DWORD
          aStruct := {}
          wFcount := FCount()
          FOR i := 1 UPTO wFcount
          AAdd(aStruct,;
          {SELF:FieldInfo(DBS_NAME, i),;
          SELF:FieldInfo(DBS_TYPE, i),;
          SELF:FieldInfo(DBS_LEN, i),;
          SELF:FieldInfo(DBS_DEC, i)})
          NEXT
          RETURN aStruct
        </code>
        The next example illustrates using the third parameter to assign an alias to a field name:
        <code language="X#">
          METHOD Start() CLASS App
          LOCAL oDBDate AS DBServer
          oDBDate := DateBook{}
          oDBDate:FieldInfo(DBS_ALIAS,;
          oDBDate:FieldPos("Name"),;
          "NewName")
          ? Name		// Displays name field
          ? NewName	// Also displays name field
          ...
        </code></example>
    </member>
    <member name="M:VO.DbServer.FieldName(XSharp.__Usual)">
      <summary>
        Return the name of a specified field as a string.
      </summary>
      <param name="nFieldPosition">The number of the field referenced.</param>
      <remarks>
        The field's hyperlabel also contains a name; these two names are the same in the code generated by the DBServer Editor.
      </remarks>
    </member>
    <member name="M:VO.DbServer.FieldPos(XSharp.__Usual)">
      <summary>
        Return the position of a specified field within the data server, as a number starting with 1.
      </summary>
      <param name="cFieldName">The name or symbol of the desired field.</param>
      <returns>
        The field position in the dbServer structure, or zero if not found.

        FieldPos() Function
      </returns>
    </member>
    <member name="M:VO.DbServer.FIELDPUT(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the value of a field identified by its position.
      </summary>
      <param name="uField">The name, number, or symbol representing the desired field.</param>
      <param name="uValue">The value to assign to the field.  The data type of this expression must match the data type of the field.</param>
      <returns>
        The value assigned to the field.  If &lt;nFieldPos&gt; does not correspond to the position of any field in the data server, DBServer:FieldPut() returns NIL.
      </returns>
      <remarks>
        DBServer:FieldPut() allows you to set the value of a field using its position within the database file structure rather than its field name.  Within generic database service functions this allows, among other things, the setting of field values without use of the macro operator.
        <note type="tip">DBServer:FieldPut() can be used with a BLOB field (that is, a memo field associated with a BLOB file), provided the length of the field does not exceed 64 KB.</note>
        Shared mode:  For a shared database, this function requires a record lock.  Refer to the "Concurrency Control" chapter in the Programmer's Guide for more information on locking.
      </remarks>
      <example>
        This example compares DBServer:FieldPut() to functionally equivalent code that uses the macro operator to set the value of a field:
        <code language="X#">
          LOCAL nFieldPos := 1, FName, FVal
          LOCAL oDBCust := Customer{} AS DBServer
          // Set field value using macro operator
          FName := oDBCust:FieldName(nFieldPos)
          oDBCust:&amp;FName := FVal
          // Set field value using FieldPut() samples:
          oDBCust:FieldPut(nFieldPos, FVal)
          oDBCust:FieldPut( #SSN, SELF:oDCsleSSN:Value )
          oDBCust:FieldPut( "SSN", SELF:cSSN )
        </code></example>
    </member>
    <member name="M:VO.DbServer.FieldPutBytes(XSharp.__Usual,System.Byte[])">
      <summary>Write an array of bytes direct to the workarea buffer.</summary>
      <param name="uField">The position of the field in the database file structure.</param>
      <param name="bValue">The value to write to the field</param>
    </member>
    <member name="M:VO.DbServer.FieldSpec(XSharp.__Usual)">
      <summary>
        Return the FieldSpec object in the specified field.
      </summary>
      <param name="uField">The name, number, or symbol representing the desired field.</param>
    </member>
    <member name="M:VO.DbServer.FieldStatus(XSharp.__Usual)">
      <summary>
        Return the status of a field after the last operation.
      </summary>
      <param name="uField">The name, number, or symbol representing the desired field.</param>
      <returns>
        A HyperLabel object if any error condition had occurred or if a validation has failed, NIL if everything is OK, if the validation passed, or if there has been no validation attempt.
      </returns>
      <remarks>
        DBServer:FieldStatus() can be used to find out more about a validation failure.
        By accessing the properties of this hyperlabel, you can retrieve not only a description but also context-sensitive help on the condition that was raised:
        <code language="X#">
          oDBServer:FieldStatus(#LastName):Caption
          oDBServer:FieldStatus(#LastName):Description
          oDBServer:FieldStatus(#LastName):HelpContext
        </code></remarks>
    </member>
    <member name="M:VO.DbServer.FieldSym(XSharp.__Usual)">
      <summary>
        Return the name of a specified field.
      </summary>
      <param name="uField">The number of the desired field.</param>
      <remarks>
        The field's hyperlabel also contains a name; these two names are the same in the code generated by the DBServer Editor.
      </remarks>
    </member>
    <member name="M:VO.DbServer.FieldValidate(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Perform all the validations defined to the FieldSpec object of a field (for example, required, maximum and minimum digits, maximum and minimum value, validation rule) and return the result of the test.
      </summary>
      <param name="uField">The name, number, or symbol representing the desired field.</param>
      <param name="uValue">
        The value that is to be validated.  Its data type should be compatible with the data type of the specified field.  If the type cannot be converted to the appropriate data type, it is considered to have failed validation.
        See the Programmer's Guide for the rules on data type conversion; in general, any kind of conversion that is reasonable is done, including converting strings like 'TRUE' and 'T' to the logical value TRUE.
      </param>
      <returns>
        FALSE if any of the validations fail; otherwise, TRUE.
      </returns>
    </member>
    <member name="P:VO.DbServer.FileSpec">
      <summary>
        The FileSpec object that defines the path and file name of the DBF file.
      </summary>
      <value>The FileSpec object that defines the path and file name of the DBF file.</value>
      <remarks>
        The FileSpec object that defines the path and file name of the DBF file.  If the DBServer was originally instantiated with a FileSpec object, this is that original FileSpec object; if the server was originally instantiated with a file name in string format, a FileSpec object is created.
        Note that the path of the file specification is exactly as originally entered.  To store the full path of the file in the file specification, use the FileSpec:Find() method.
      </remarks>
      <example>
        This example opens a data server using a FileSpec object, the retrieves information based on the server's FileSpec property:
        <code language="X#">
          oFSSales := FileSpec{"c:\data\cust\sales.dbf"}
          oDBSales := DBServer{oFSSales}
          ? oDBSales:FileSpec:Drive		// C:
          ? oDBSales:FileSpec:Extension	// .DBF
        </code></example>
    </member>
    <member name="P:VO.DbServer.Filter">
      <summary>
        A string representing the current active filter.
      </summary>
      <value>A string representing the current active filter.</value>
      <remarks>
        A string representing the current active filter.  If no filter has been set, NULL_STRING is returned.  Assigning a string or a code block to DBServer:Filter is equivalent to calling DBSetFilter().
      </remarks>
      <example>
        This example displays the current Filter condition.  Also, if you already have an existing filter condition, you might want to retrieve its :Filter value first, then if your new SetFilter() condition fails, you can reset it back to it's prior filter expression:
        <code language="X#">
          CLASS Sales INHERIT DBServer
          ...
          FUNCTION IgnoreDeleted()
          LOCAL oDBSales AS Sales
          oDBSales := Sales{}
          oDBSales:SetFilter(!oDBSales:Deleted)
          oDBSales:GoTop()		// move pointer to invoke filter
          ? oDBSales:Filter		// !oDBSales:Deleted
          .
          . &lt;Process records&gt;
          .
          oDBSales:ClearFilter()
          ? oDBSales:Filter		// NULL_STRING
        </code></example>
    </member>
    <member name="M:VO.DbServer.FLOCK">
      <summary>
        Lock the table used by this server for exclusive access.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.DbServer.ForBlock">
      <summary>
        The "FOR block" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope.
      </summary>
      <value>The "FOR block" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope.</value>
      <remarks>
        The "FOR block" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope.  The FOR block can be specified as a code block or a string.  This access always returns a code block.
        Specifying a FOR block makes the method process all those records where the FOR block evaluates TRUE, subject to other scope settings, of course.  Specifying a FOR block makes the Scope default to ALL in those cases where it is otherwise "current record," unless a WhileBlock is also specified in which case it is set to REST.
      </remarks>
      <example>
        This example assigns a code block to ForBlock to limit the scope of a recall operation:
        <code language="X#">
          // RECALL FOR Last == "Smith" REST
          oDB:ForBlock := {|| Last == "Smith"}
          oDB:Scope := DBSCOPEREST
          oDB:Recall()
          oDB:ClearScope()
        </code></example>
    </member>
    <member name="P:VO.DbServer.Found">
      <summary>
        A logical value indicating whether the previous search operation succeeded.
      </summary>
      <value>A logical value indicating whether the previous search operation succeeded.</value>
      <remarks>
        A logical value indicating whether the previous search operation succeeded.  Note that this is old technology and is mainly here for backwards compatibility.  Typically if you are doing a SEEK/FOUND scenario, you would simply do a "IF oDB:Seek(…)" to check if the seek was successful (FOUND) or not.
      </remarks>
      <example>
        This example illustrates the behavior of Found after a record movement operation:
        <code language="X#">
          CLASS Sales INHERIT DBServer
          ...
          METHOD Init() CLASS Sales
          ...
          SELF:SetIndex("sales")
          ...
          FUNCTION FoundDemo()
          LOCAL oDBSales AS Sales
          oDBSales := Sales{}
          oDBSales:Seek("1000")
          ? DBSales:Found		// Result: FALSE
          oDBSales:Seek("100")
          ? DBSales:Found		// Result: TRUE
          DBSales:Skip()
          ? DBSales:Found		// Result: FALSE
        </code></example>
    </member>
    <member name="M:VO.DbServer.GetArray(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Retrieve an array of values from a field in the server, subject to the currently active selection, if any.
      </summary>
      <param name="nMaxRows">The maximum number of rows that should be retrieved.  If omitted, a maximum of 100 rows are retrieved.</param>
      <param name="uField1">The name, number, or symbol representing the field to be retrieved.  If omitted, the first field is retrieved.</param>
      <param name="uSearchValue">The value to be searched for, under the currently controlling order.  The system performs a Seek() operation, and then proceeds to load up the array from there.</param>
      <returns>
        An array of values found for the specified field, moving sequentially until the specified maximum number of rows or until end of file.  If a selection is active, the method includes only records from that selection.  The values are retrieved under the current controlling order, if any.
        Note that the method does not reposition to the beginning before starting to fill the array.  Either provide a start value, or explicitly position the server before using the method.  (This allows incremental reading, building up an array in pieces.)
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyRecordChange message upon completion, and leaves the server positioned at the last record used or at end of file (last file record).  One use of this method is to populate validation lists in user interfacing.
      </remarks>
      <example>
        The following fills an array with product names for use as validation values, beginning at the indicated product number:
        <code language="X#">
          oDB := DBServer{"products",#Shared,#ReadOnly}
          oDB:SetIndex("prodno")
          aProducts := oDB:GetArray(100,#ProdName, 22750)
          oDB:Close()
        </code></example>
    </member>
    <member name="M:VO.DbServer.GetLocate">
      <summary>
        Retrieve the code block of the current LOCATE condition, or NIL if no code block is set.
      </summary>
      <remarks>
        DBServer:GetLocate() returns the FOR condition code block used in the Locate() method.
      </remarks>
    </member>
    <member name="M:VO.DbServer.GetLookupTable(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Retrieve a two-column array of values from two fields in the server, subject to the currently active selection, if any.
      </summary>
      <param name="nMaxRows">The maximum number of rows that should be retrieved.  If omitted, 100 rows at most are retrieved.</param>
      <param name="uField1">The name, number, or symbol of the first field to be retrieved.  If omitted, the first field is retrieved.</param>
      <param name="uField2">The name, number, or symbol of the second field to be retrieved.  If omitted, the second field is retrieved.</param>
      <param name="uSearchValue">The value to be searched for, under the currently controlling order.  The system performs a Seek() operation, and then proceeds to load up the array from there.</param>
      <returns>
        The method returns a two-column array of values found for the specified fields, moving sequentially until the specified maximum number of rows or until end of file.  If a selection is active, the method includes only records from that selection.  The values are retrieved under the current controlling order, if any.
        Note that the method does not reposition to the beginning before starting to fill the array.  Either provide a start value, or explicitly position the server before using the method.  (This allows incremental reading, building up an array in pieces.)
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyRecordChange message upon completion, and leaves the server positioned at the last record used or at end of file (last file record).  One use of this method is to populate translation lists in user interfacing.  The resulting array can be used in ATranslate().
      </remarks>
      <example>
        The following builds a lookup table, for example to translate product codes into product names and vice versa, beginning at the indicated product number:
        <code language="X#">
          oDB := DBServer{"products",#Shared,#ReadOnly}
          oDB:SetIndex("prodno")
          aProducts := oDB:GetLookupTable(500,#ProdNo,#ProdName, 22750)
          oDB:Close()
        </code></example>
    </member>
    <member name="M:VO.DbServer.GoBottom">
      <summary>
        Position the data server at the last record.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyGoBottom message, if successful.
        If DBServer:RecNo is greater than DBServer:LastRec, the DBServer will be positioned at the last record and DBServer:EOF will be TRUE.
      </remarks>
    </member>
    <member name="M:VO.DbServer.GoTo(XSharp.__Usual)">
      <summary>
        Position the data server at a specified record number.
      </summary>
      <param name="nRecordNumber">The record number at which the server should be positioned.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyRecordChange message, if successful.
      </remarks>
    </member>
    <member name="M:VO.DbServer.GoTop">
      <summary>
        Position the data server at the first record.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyGoTop message, if successful.
      </remarks>
    </member>
    <member name="P:VO.DbServer.Header">
      <summary>
        A numeric value representing the length of the database file header.
      </summary>
      <value>A numeric value representing the length of the database file header.</value>
      <example>
        This example uses Header to define an access method to return the Size of the data server:
        <code language="X#">
          CLASS Sales INHERIT DBServer
          ...
          ACCESS Size CLASS Sales
          RETURN (SELF:RecSize * SELF:RecCount) + ;
          SELF:Header + 1
        </code></example>
    </member>
    <member name="P:VO.DbServer.IndexExt">
      <summary>
        A string representing the default index extension based on the database driver currently linked (for example, ".NTX" for the DBFNTX driver).
      </summary>
      <value>A string representing the default index extension based on the database driver currently linked (for example, ".NTX" for the DBFNTX driver).</value>
    </member>
    <member name="M:VO.DbServer.INDEXKEY(XSharp.__Usual)">
      <summary>
        Return the key expression of a specified single-order index.
      </summary>
      <param name="uOrder">The name of an order, or the ordinal position of the order within the order list.  A value of 0 specifies the controlling index, without regard to its actual position in the list.</param>
      <returns>
        The key expression of the specified index as a string; if there is no corresponding order or the order name is not unique, the method returns a NULL_STRING.
      </returns>
      <remarks>
        The key expression actually belongs to an order and not to an index file.  When using single-order indexes, or when the order name uniquely identifies an order, requesting key information for an index with IndexKey() works.  But this practice is not recommended, since the request may not work when a different driver is used.
      </remarks>
    </member>
    <member name="P:VO.DbServer.IndexList">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.DbServer.INDEXORD">
      <summary>
        Return the ordinal position of the controlling order in the order list.  (Similar to the IndexOrd() function.)
      </summary>
      <returns>
        An integer numeric value.  The value returned is equal to the position of the controlling index in the list of open indexes for the current work area.  A value of 0 indicates that there is no controlling index and records are being accessed in natural order.
      </returns>
    </member>
    <member name="M:VO.DbServer.Info(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Return and optionally change information about a data server.
      </summary>
      <param name="kInfoType">
        Specifies the type of information.  The constants are described in the Constants section below.  Note, however, that not all constants are supported for all RDDs.
        <br />Important!  DBI_USER is a constant that returns the minimum value that third-party RDD developers can use for defining new &lt;kInfoType&gt; parameters.  Values less than DBI_USER are reserved for CA development.
      </param>
      <param name="uInfo">If specified, this parameter is used to change the value of a setting.  The data type (and whether &lt;uInfo&gt; can be specified), depends on the &lt;kInfoType&gt; constant and is documented in the Constants section below.</param>
      <returns>
        If &lt;uInfo&gt; is not specified, DBServer:RDDInfo() returns the current setting.  If &lt;uInfo&gt; is specified, the previous setting is returned.
      </returns>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>DBI_ALIAS</term>
            <description>Returns the alias name of the work area as a string.</description>
          </item>
          <item>
            <term>DBI_BLOB_HANDLE</term>
            <description>Returns an integer representing the DOS file handle for a BLOB file.  The constant is most often used in conjunction with DBServer:FieldInfo(DBS_BLOB_LEN, ...) and DBServer:FieldInfo(DBS_BLOB_POINTER, ...) to directly access BLOB fields using low-level functions, such as FRead().</description>
          </item>
          <item>
            <term>DBI_BLOB_INTEGRITY</term>
            <description>Tests a BLOB file for the integrity of its internal tables and returns a logical value indicating the success (TRUE) or failure (FALSE) of the integrity check.  This should not generally be necessary, but it is handy if the file's integrity is in question for any reason.  This does not test the integrity between the .DBF and the BLOB file.</description>
          </item>
          <item>
            <term></term>
            <description>If the integrity check fails, you can run DBServer:Info(DBI_BLOB_RECOVER), which will automatically correct the BLOB file's tables, however, it will abandon some space within the file that would otherwise be reused.</description>
          </item>
          <item>
            <term></term>
            <description>
              <br />Important!  DBServer:Info(DBI_BLOB_INTEGRITY) is a disk intensive operation and may slow down processing of the data server significantly, especially on a busy network.
            </description>
          </item>
          <item>
            <term>DBI_BLOB_RECOVER</term>
            <description>Recovers a damaged BLOB file by correcting its internal tables and returns NIL.  You should run this only if DBServer:Info(DBI_BLOB_INTEGRITY) returns FALSE.  Note that after running DBServer:Info(DBI_BLOB_RECOVER), the BLOB file loses some size efficiency.</description>
          </item>
          <item>
            <term>DBI_BOF</term>
            <description>Returns a logical value indicating the data server's beginning-of-file status (see DBServer:BOF).</description>
          </item>
          <item>
            <term>DBI_CANPUTREC</term>
            <description>Returns a logical value indicating whether the data server supports putting records.</description>
          </item>
          <item>
            <term>DBI_CHILDCOUNT</term>
            <description>Returns the number of relations set from this data server.</description>
          </item>
          <item>
            <term>DBI_DB_VERSION</term>
            <description>Returns the version number of the host RDD (CAVORDDB.DLL or CAVORDD.DLL).</description>
          </item>
          <item>
            <term>DBI_DBFILTER</term>
            <description>Returns the filter expression as a string (see DBServer:Filter).</description>
          </item>
          <item>
            <term>DBI_EOF</term>
            <description>Returns a logical value indicating the data server's end-of-file status (see DBServer:EOF).</description>
          </item>
          <item>
            <term>DBI_FCOUNT</term>
            <description>Returns the number of fields (see DBServer:FCount).</description>
          </item>
          <item>
            <term>DBI_FILEHANDLE</term>
            <description>Returns an integer representing the DOS file handle for this database file.</description>
          </item>
          <item>
            <term>DBI_FOUND</term>
            <description>Returns a logical value indicating the success or filure of the last seek operation for this data server (see DBServer:Found).</description>
          </item>
          <item>
            <term>DBI_FULLPATH</term>
            <description>Returns the full path name of opened database file.</description>
          </item>
          <item>
            <term>DBI_GETDELIMITER</term>
            <description>Returns the default delimiter.</description>
          </item>
          <item>
            <term>DBI_GETHEADERSIZE</term>
            <description>Returns the header size of the file (see DBServer:Header).</description>
          </item>
          <item>
            <term>DBI_GETLOCKARRAY</term>
            <description>Returns the array of locked records.</description>
          </item>
          <item>
            <term>DBI_GETRECSIZE</term>
            <description>Returns the record size of the file (see DBServer:RecSize).</description>
          </item>
          <item>
            <term>DBI_GETSCOPE</term>
            <description>Returns the locate condition as a code block.</description>
          </item>
          <item>
            <term>DBI_ISANSI</term>
            <description>Returns the ANSI flag of the database file (TRUE for ANSI and FALSE for OEM).</description>
          </item>
          <item>
            <term>DBI_ISDBF</term>
            <description>Returns a logical value indicating whether the RDD provides support for the .DBF file format.</description>
          </item>
          <item>
            <term>DBI_ISFLOCK</term>
            <description>Returns the file lock status.</description>
          </item>
          <item>
            <term>DBI_LASTUPDATE</term>
            <description>Returns the last date on which the file was updated (see DBServer:LUpdate).</description>
          </item>
          <item>
            <term>DBI_LOCKCOUNT</term>
            <description>Returns the number of locked records.</description>
          </item>
          <item>
            <term>DBI_LOCKOFFSET</term>
            <description>Returns the current locking offset as a numeric value.</description>
          </item>
          <item>
            <term>DBI_MEMOBLOCKSIZE</term>
            <description>Returns the block size for the memo file associated with this database.</description>
          </item>
          <item>
            <term>DBI_MEMOEXT</term>
            <description>Returns the default extension for the memo file associated with this database.</description>
          </item>
          <item>
            <term>DBI_MEMOHANDLE</term>
            <description>Returns an integer representing the DOS file handle for the memo file associated with this database file.</description>
          </item>
          <item>
            <term>DBI_RDD_VERSION</term>
            <description>Returns the version number of the RDD for this database.</description>
          </item>
          <item>
            <term>DBI_SETDELIMITER</term>
            <description>Sets the default delimiter.</description>
          </item>
          <item>
            <term>DBI_SHARED</term>
            <description>Returns the shared flag value.</description>
          </item>
          <item>
            <term>DBI_TABLEEXT</term>
            <description>Returns the database file extension.</description>
          </item>
          <item>
            <term>DBI_VALIDBUFFER</term>
            <description>Returns a logical value indicating whether the current buffer is valid.</description>
          </item>
        </list>
      </remarks>
      <example>
        The following examples return data server information:
        <code language="X#">
          // Same as oDBServer:Header
          oDBServer:Info(DBI_GETHEADERSIZE)
          // Same as oDBServer:LUpdate
          oDBServer:Info(DBI_LASTUPDATE)
          // Same as oDBServer:RecSize
          oDBServer:Info(DBI_GETRECSIZE)
          // Get the full path
          oDBServer:Info(DBI_FULLPATH)
        </code></example>
    </member>
    <member name="M:VO.DbServer.Join(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Join this DBServer object with another DBServer object and place the results in the file specified.
      </summary>
      <param name="oDBSource">The 'other' DBServer object to which this DBServer object is joined.  It can be specified as a DBServer object, or as the alias of a table opened in a work area.</param>
      <param name="oFSTarget">The file into which results of the join operation is placed.</param>
      <param name="aFieldList">An array of fields to be included in the join operation.</param>
      <param name="cbForBlock">The condition evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.</param>
      <returns>
        TRUE if successful; otherwise, FALSE, although even with FALSE, some records may have been processed.  This would happen if the operation failed halfway through because of lock conflicts or technical problems.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyRecordChange message, if successful.
      </remarks>
    </member>
    <member name="P:VO.DbServer.LastRec">
      <summary>
        The number of records in the current database file.
      </summary>
      <value>The number of records in the current database file.</value>
      <remarks>
        The number of records in the current database file.  Filtering commands such as SET FILTER or SET DELETED have no effect on the return value.
      </remarks>
      <example>
        This example uses LastRec to define an access method to return the Size of the data server:
        <code language="X#">
          CLASS Sales INHERIT DBServer
          ...
          ACCESS Size CLASS Sales
          RETURN (SELF:RecSize * SELF:LastRec) + ;
          SELF:Header + 1
        </code></example>
    </member>
    <member name="M:VO.DbServer.Locate(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Search sequentially for a record matching a condition.  If neither conditions nor scope is passed to the method, it is subject to the general server scope.
      </summary>
      <param name="cbForBlock">The condition that is evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.</param>
      <param name="cbWhileBlock">The condition that is evaluated for each record from the current record until the condition returns FALSE.  It provides the same functionality as the WHILE clause of record processing commands.</param>
      <param name="uScope">
        The range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands.
        Value	Description
        DBSCOPEALL	The scope is all the records in the table.  This is the default, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
        DBSCOPEREST	The scope is the remaining records in the table from the current position.
        &lt;nRecords&gt;	The scope is the next &lt;nRecords&gt; records.
      </param>
      <returns>
        TRUE if a record was found that matches the conditions, FALSE if no match was found or if the operation failed for some other reason.  Afterwards, the Found and Status access methods can be used to determine exactly what happened.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyRecordChange message upon completion, whether successful or not.
        If no match was found, the current record will be the last file record and DBServer:EOF will be TRUE.
      </remarks>
    </member>
    <member name="M:VO.DbServer.LockCurrentRecord">
      <summary>
        Lock the current record.  This method is identical to invoking RLock() with the current record number as a parameter.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.DbServer.LockSelection">
      <summary>
        Lock all the records in the currently active selection.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.  If it fails, some records may remain locked; this allows the program to try again, incrementally locking more and more records as other applications free them.  If the application gives up on the attempt, the locks should be explicitly released.
      </returns>
      <remarks>
        If a selection is not active, sends a NotifyIntentToMove message before the operation and functions the same as FLock().
      </remarks>
      <example>
        A selective relation is set up between customer and order servers.  The application operates under "cursor stability" mode, which means that the currently active record remains locked and hence protected from outside influence.  When a customer record is locked, all the orders that correspond to that customer are also locked:
        <code language="X#">
          oDBCust := DBServer{"customer"}
          oDBOrder := DBServer{"order"}
          oDBOrder:SetIndex{("ORDCSTNO")
          oDBCust:SetSelectiveRelation(oDBOrder,#CustNo)
          ...
          METHOD Skip() CLASS CustomerWindow
          oDBCust:Skip()				// Reposition order server
          oDBCust:RLock()			// Lock customer record
          oDBOrder:LockSelection()		// Lock order records
        </code></example>
    </member>
    <member name="P:VO.DbServer.Lupdate">
      <summary>
        The last modification date of the DBF file used in the server.
      </summary>
      <value>The last modification date of the DBF file used in the server.</value>
    </member>
    <member name="P:VO.DbServer.MemoExt">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="P:VO.DbServer.Name">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.DbServer.NoIVarGet(XSharp.__Usual)">
      <summary>
        Provide a general error interception that is automatically called (in any class) whenever an access reference is made to a non-existent exported instance variable.  In the DBServer class, it is used to implement the virtual field variable.
        <br />Important!  NoIVarGet() should not be called directly; it is called by the system for handling invalid references.
      </summary>
      <param name="symFieldName">The symbolic name of the variable that was referenced.  In the standard usage of the method with the DBServer class, this is a field name.</param>
      <remarks>
        For DBServer, this method is used to intercept references to field names as exported variables, which ordinarily would not be allowed.  If the field name is valid, it does FieldGet() for the corresponding field name, in effect turning database fields into Access methods of each DBServer object.  See "Objects, Classes, and Methods" in the Programmer's Guide for more information on NoIVarGet().
      </remarks>
    </member>
    <member name="M:VO.DbServer.NoIVarPut(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Provide a general error interception that is automatically called (in any class) whenever an assignment reference is made to a non-existent exported instance variable.  In the DBServer class, it is used to implement the virtual field variable.
        <br />Important!  NoIVarPut() should not be called directly; it is called by the system for handling invalid references.
      </summary>
      <param name="symFieldName">The symbolic name of the variable that was referenced.  In the standard usage of the method with the DBServer class, this is a field name.</param>
      <param name="uValue">The value to be assigned to the field.  The data type of this value must match the data type of the field.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyFieldChange message if the variable reference was to a valid field of the server, and the assignment was successful.
        For DBServer, this method is used to intercept references to field names as exported variables, which ordinarily would not be allowed.  If the field name is valid, it does a FieldPut() for the corresponding field name with the passed value, in effect turning database fields into assign methods of each DBServer object.  See "Objects, Classes, and Methods" in the Programmer's Guide for more information on NoIVarGet().
      </remarks>
    </member>
    <member name="M:VO.DbServer.Notify(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        An event handler that responds to events that have occurred in methods of this server, or in other servers that are linked to this server in some way.  The standard implementation notifies all the server's clients of the event.
        <br />Important!  This method is automatically called by the various action methods of the data server, and should normally not be called by application code.
      </summary>
      <param name="kNotification">Identifies the event, specified as one of the constants below.</param>
      <param name="uDescription">Used only with some notification types.</param>
      <returns>
        SELF, except if NOTIFYINTENTTOMOVE is specified for &lt;kNotifyName&gt;.  In this case, the return value is TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <include file="VOSDK_Classes.xml" path="doc/commonblocks/notify/*" />
      </remarks>
    </member>
    <member name="P:VO.DbServer.OleExt">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="P:VO.DbServer.OrderBottomScope">
      <summary>
        A key value representing the record of the bottom boundary in the range of key values that will be included in the controlling order's current scope.
      </summary>
      <value>A key value representing the record of the bottom boundary in the range of key values that will be included in the controlling order's current scope.</value>
    </member>
    <member name="M:VO.DbServer.OrderDescend(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Return and optionally change the descending flag of an order.
      </summary>
      <param name="uOrder">
        The name of the order or a number representing its position in the order list.  Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.  If omitted or NIL, the controlling order is assumed.
        Specifying an invalid value will raise a runtime error.
      </param>
      <param name="oFSIndex">
        The name of an index file, including an optional drive and directory (no extension should be specified).  Use this argument with &lt;cOrder&gt; to remove ambiguity when there are two or more orders with the same name in different index files.
        If &lt;oFSIndex&gt; is not open by the current process, a runtime error is raised.
      </param>
      <param name="lNew">TRUE dynamically turns on the descending flag for the order, resulting in descending order.  FALSE dynamically turns the flag off, resulting in ascending order.</param>
      <returns>
        If &lt;lNew&gt; is not specified, DBServer:OrderDescend() returns the current setting.  If &lt;lNewDescend&gt; is specified, the previous setting is returned.
      </returns>
      <remarks>
        DBServer:OrderDescend() changes the ascending/descending flag at runtime only — it does not change the descending flag stored in the actual index file.
        <note type="tip">
          If you are using DbServer:OrderDescend() with Scopes, you need to swap the Top and Bottom scope values !
          <code language="X#">
            oServer:OrderScope (TOPSCOPE, cFrom)
            oServer:OrderScope (BOTTOMSCOPE, cTo)
            oServer:OrderDescend(,, TRUE)
            oServer:OrderScope (TOPSCOPE, cTo)
            oServer:OrderScope (BOTTOMSCOPE, cFrom)
          </code></note></remarks>
      <example>
        The following example illustrates DBServer:OrderDescend(); every order can be both ascending and descending:
        <code language="X#">
          LOCAL oDBCust AS DBServer
          oDBCust := Customer{}
          oDBCust:CreateOrder("Last", "customer", "oDBCust:LastName")
          oDBCust:SetOrderCondition(,,,,,,,,,, TRUE)
          oDBCust:CreateOrder("First", "customer", "oDBCust:FirstName")
          oDBCust:SetOrder("Last")		// Last was originally created in ascending order
          oDBCust:OrderDescend(,, TRUE)	// Swap it to descending
          // Last will now be processed in descending order
          oDBCust:SetOrder("First")		// First was originally created in descending order
          oDBCust:OrderDescend(,, FALSE)	// Swap it to ascending
          // First will now be processed in ascending order
        </code></example>
    </member>
    <member name="M:VO.DbServer.OrderInfo(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Return and optionally change information about orders and index files.
      </summary>
      <param name="kOrderInfoType">
        Specifies the type of information.  The constants are listed below.  Note, however, that not all constants are supported for all RDDs.
        <br />Important!  DBOI_USER is a constant that returns the minimum value that third-party RDD developers can use for defining new &lt;kInfoType&gt; parameters.  Values less than DBOI_USER are reserved for VO development.
      </param>
      <param name="oFSIndex">
        The name of an index file, including an optional drive and directory (no extension should be specified).  Use this argument with &lt;cOrder&gt; to remove ambiguity when there are two or more orders with the same name in different index files.
        If &lt;oFSIndex&gt; is not open by the current process, a runtime error is raised.
      </param>
      <param name="uOrder">
        The name of the order about which you want to obtain information or a number representing its position in the order list.  (For single-order index files, the order name is the eight-letter index file name.)  Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.  Invalid values are ignored.
        If no index file or order is specified, the controlling order is assumed.
      </param>
      <param name="uOrdVal">If specified, this parameter is used to change the value of a setting.  The data type (and whether &lt;uOrdVal&gt; can be specified), depends on the &lt;kInfoType&gt; constant and is documented in the Constants section below.</param>
      <returns>
        If &lt;uNewSetting&gt; is not specified, DBServer:OrderInfo() returns the current setting.  If &lt;uNewSetting&gt; is specified, the previous setting is returned.
      </returns>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>DBOI_CONDITION</term>
            <description>Returns the for condition of the specified order as a string.</description>
          </item>
          <item>
            <term>DBOI_CUSTOM</term>
            <description>Returns and optionally sets the logical flag indicating whether the specified order is custom built (for RDDs that support custom built orders).  Note that although you can turn the custom built flag on for a standard order by specifying TRUE for the &lt;uNewSetting&gt; argument, you cannot turn a custom built order into a standard order.  Specifying FALSE for &lt;uNewSetting&gt; is the same as not specifying the argument at all — both return the current setting.</description>
          </item>
          <item>
            <term>DBOI_EXPRESSION</term>
            <description>Returns the order key expression of the specified order as a string.</description>
          </item>
          <item>
            <term>DBOI_FILEHANDLE</term>
            <description>Returns the handle of the specified index file as a number.</description>
          </item>
          <item>
            <term>DBOI_FULLPATH</term>
            <description>Returns the full path of the specified index file as a string.</description>
          </item>
          <item>
            <term>DBOI_HPLOCKING</term>
            <description>Returns a logical flag indicating whether the specified index file uses the high performance index locking schema (see IndexHPLock() function).</description>
          </item>
          <item>
            <term>DBOI_INDEXEXT</term>
            <description>Returns the default index file extension as a string.</description>
          </item>
          <item>
            <term>DBOI_INDEXNAME</term>
            <description>Returns the name of the specified index file as a string.</description>
          </item>
          <item>
            <term>DBOI_ISCOND</term>
            <description>Returns a logical flag that determines whether the specified order was defined using a for condition.</description>
          </item>
          <item>
            <term>DBOI_ISDESC</term>
            <description>Returns the logical flag that determines if the specified order is descending.  For drivers that support dynamically setting the descending flag at runtime, specify the new value as a logical, using DBServer:OrderInfo(DBOI_ISDESC, [&lt;oFSIndexFile&gt; | &lt;cIndexFile&gt;], [&lt;cOrder&gt; | &lt;nPosition&gt;], &lt;lNewSetting&gt;).  The current setting is returned before it is changed.</description>
          </item>
          <item>
            <term>DBOI_KEYCOUNT</term>
            <description>Returns the number of keys in the specified order.</description>
          </item>
          <item>
            <term>DBOI_KEYDEC</term>
            <description>Returns the number of decimals in the key of the specified order.</description>
          </item>
          <item>
            <term>DBOI_KEYSINCLUDED</term>
            <description>Returns the number of keys included in the specified order so far.  This is primarily useful for conditional orders.  It can be used during the status display process (with the EVAL clause of the INDEX command). </description>
          </item>
          <item>
            <term>DBOI_KEYSIZE</term>
            <description>Returns the size of the key in the specified order as a number.</description>
          </item>
          <item>
            <term>DBOI_KEYTYPE</term>
            <description>Returns the data type of the key in the specified order as a string.</description>
          </item>
          <item>
            <term>DBOI_KEYVAL</term>
            <description>Returns the key value of the current record in the specified order.</description>
          </item>
          <item>
            <term>DBOI_LOCKOFFSET</term>
            <description>Returns the locking offset (see NewIndexLock() function) for the specified index file as a numeric value.</description>
          </item>
          <item>
            <term>DBOI_NAME</term>
            <description>Returns the name of the specified order as a string.</description>
          </item>
          <item>
            <term>DBOI_NUMBER</term>
            <description>Returns the numeric position of the specified order in the order list.</description>
          </item>
          <item>
            <term>DBOI_ORDERCOUNT</term>
            <description>Returns the number of orders defined in the specified index file.</description>
          </item>
          <item>
            <term>DBOI_POSITION</term>
            <description>Returns the logical record number of the current record within the specified order.</description>
          </item>
          <item>
            <term>DBOI_RECNO</term>
            <description>Returns the physical record number of the current record within the specified order.</description>
          </item>
          <item>
            <term>DBOI_SCOPEBOTTOMs</term>
            <description>Returns the bottom boundary of the scope for the specified order.</description>
          </item>
          <item>
            <term>DBOI_SCOPETOP</term>
            <description>Returns the top boundary of the scope for the specified order.</description>
          </item>
          <item>
            <term>DBOI_SETCODEBLOCK</term>
            <description>Returns the key for the specified order as a code block.</description>
          </item>
          <item>
            <term>DBOI_UNIQUE</term>
            <description>Returns a logical flag indicating whether the specified order has the unique attribute set.</description>
          </item>
        </list>
      </remarks>
      <example>
        This example uses DBOI_NAME to save the current controlling order.  After changing to a new controlling order, it uses the saved value to restore the original order:
        <code language="X#">
          oDBCust := Customer{}
          oDBCust:SetIndex("name")
          oDBCust:SetIndex("serial")
          cOrder := oDBCust:OrderInfo(DBOI_NAME)		// name
          oDBCust:SetOrder("serial")
          ? oDBCust:OrderInfo(DBOI_NAME)			// serial
          oDBCust:SetOrder(cOrder)
          ? oDBCust:OrderInfo(DBOI_NAME)			// name
        </code>
        This example returns the default index file extension (using DBOI_INDEXEXT) for two different data servers:
        <code language="X#">
          oDBSales := Sales{}
          oDBCust := Customer{}
          ? oDBSales:OrderInfo(DBOI_INDEXEXT)	    	// .CDX
          ? oDBCust:OrderInfo(DBOI_INDEXEXT)     		// .NTX
        </code>
        In this example, DBServer:OrderInfo(DBOI_INDEXEXT) checks for the existence of the CUSTOMER index file independent of the RDD associated with the data server:
        <code language="X#">
          oDBCust := Customer{}
          IF !File("customer" + oDBCust:OrderInfo(DBOI_INDEXEXT))
          oDBCust:CreateIndex("customer", "oDBCust:CustName")
          ENDIF
        </code>
        This example accesses the key expression of several orders from the same index file:
        <code language="X#">
          oDBCust := Customer{}
          oDBCust:SetOrder("serial")
          ? oDBCust:OrderInfo(DBOI_EXPRESSION,, "name")
          // Result: key expression for name order
          ? oDBCust:OrderInfo(DBOI_EXPRESSION,, "serial")
          // Result: key expression for serial order
        </code>
        In this example, ALL_CUST.MDX contains three orders named CUACCT, CUNAME, CUZIP.  The DBOI_INDEXNAME constant is used to display the name of the index file using one of its orders:
        <code language="X#">
          oDBCust := Customer{}
          oDBCust:SetIndex("all_cust")
          ? oDBCust:OrderInfo(DBOI_INDEXNAME,, "cuname")
          // Returns: all_cust
        </code>
        The following example searches for CUNAME in the order list:
        <code language="X#">
          oDBCust := Customer{}
          oDBCust:SetIndex("cuacct")
          oDBCust:SetIndex("cuname")
          oDBCust:SetIndex("cuzip")
          ? oDBCust:OrderInfo(DBOI_NUMBER,, "cuname")  // 2
        </code>
        This example retrieves the "for condition" from an order:
        <code language="X#">
          oDBCust := Customer{}
          oDBCust:SetOrderCondition("oDBCust:Acct &gt; 'AZZZZZ'")
          oDBCust:CreateIndex("customer", "oDBCust:Acct")
          oDBCust:OrderInfo(DBOI_CONDITION,, "customer")
          // Returns: oDBCust:Acct &gt; 'AZZZZZ'
        </code></example>
    </member>
    <member name="M:VO.DbServer.OrderIsUnique(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Return the status of the unique flag for a given order.
      </summary>
      <param name="uOrder">
        The name of the order or a number representing its position in the order list.  Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.  If omitted or NIL, the controlling order is assumed.
        Specifying an invalid order will raise a runtime error.
      </param>
      <param name="oFSIndex">
        The name of an index file, including an optional drive and directory (no extension should be specified).  Use this argument with &lt;uOrder&gt; to remove ambiguity when there are two or more orders with the same name in different index files.
        If &lt;oFSIndex&gt; is not open by the current process, a runtime error is raised.
      </param>
      <returns>
        The status of the indicated order's unique flag as a logical value.
      </returns>
      <example>
        This example shows the return value of DBServer:OrderIsUnique() using various orders:
        <code language="X#">
          oDBCust := Customer{}
          oDBCust:CreateOrder("Last", "Customer",;
          "oDBCust:LastName",, TRUE)
          oDBCust:CreateOrder("First", "Customer",;
          "oDBCust:FirstName")
          oDBCust:CreateIndex("j:\test\tmp\age",	;
          "oDBCust:Age",, TRUE)
          oDBCust:SetOrder("Last")
          ? oDBCust:OrderIsUnique()	 		// Result: TRUE, for order last
          ? oDBCust:OrderIsUnique("First")	// Result: FALSE
          ? oDBCust:OrderIsUnique("Age")		// Result: TRUE
        </code></example>
    </member>
    <member name="M:VO.DbServer.OrderKeyAdd(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Add a key to a custom built order.
      </summary>
      <param name="uOrder">
        The name of the order or a number representing its position in the order list.  Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.  If omitted or NIL, the controlling order is assumed.
        Specifying an invalid order, such as one that is not custom built, will raise a runtime error.
      </param>
      <param name="oFSIndex">
        The name of an index file, including an optional drive and directory (no extension should be specified).  Use this argument with &lt;uOrder&gt; to remove ambiguity when there are two or more orders with the same name in different index files.
        If &lt;oFSIndex&gt; is not open by the current process, a runtime error is raised.
      </param>
      <param name="uKeyValue">A specific key value that you want to add for the current record.  The data type must match that of the order.  If not specified, the order's key expression is evaluated for the current record and added to the order.</param>
      <returns>
        TRUE if successful; otherwise FALSE.
      </returns>
      <remarks>
        A custom built order is one that is not automatically maintained by the DBFCDX driver.  You can determine if an order is custom built using DBServer:OrderInfo(DBOI_CUSTOM, ...).  When you create such an order, it is initially empty.
        You must manually add and delete keys using DBServer:OrderKeyAdd() and DBServer:OrderKeyDel().
        DBServer:OrderKeyAdd() evaluates the key expression (or &lt;uKeyValue&gt;, if specified), then adds the key for the current record to the order.  If the order has a for condition, the key will be added only if that condition is met, and then, only if it falls within the current scoping range.
        <note type="tip">RDDs may allow you to add several keys for the same record with consecutive calls to DBServer:OrderKeyAdd().</note>
        DBServer:OrderKeyAdd() will fail if:
        The record pointer is positioned on an invalid record (i.e., at DBServer:EOF)
        The specified order is not custom built
        The specified order does not exist
        No order was specified and there is no controlling order
        <note type="tip">
          From the standard RDDs only the DBFCDX RDD supports Custom Indexes. This RDD does NOT support the use of the &lt;uKeyValue&gt; parameter. It always uses the Key Expression to calculate the Key Values to insert.
        </note></remarks>
      <example>
        This example creates a custom index and adds every fiftieth record to it:
        <code language="X#">
          oDBCust := Customer{}
          // Create custom built order that is initially empty
          oDBCust:SetOrderCondition(,,,,,,,,,,,,, TRUE)
          oDBCust:CreateIndex("last", "oDBCust:LastName")
          // Add every 50th record
          FOR n := 1 UPTO oDBCust:RecCount STEP 50
          oDBCust:GoTo(n)
          oDBCust:OrderKeyAdd()
          NEXT
        </code></example>
    </member>
    <member name="M:VO.DbServer.OrderKeyCount(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Return the number of keys in an order.
      </summary>
      <param name="uOrder">
        The name of the order or a number representing its position in the order list.  Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.  If omitted or NIL, the controlling order is assumed.
        Specifying an invalid order will raise a runtime error.
      </param>
      <param name="oFSIndex">
        The name of an index file, including an optional drive and directory (no extension should be specified).  Use this argument with &lt;uOrder&gt; to remove ambiguity when there are two or more orders with the same name in different index files.
        If &lt;oFSIndex&gt; is not open by the current process, a runtime error is raised.
      </param>
      <remarks>
        DBServer:OrderKeyCount() counts the keys in the specified order and returns the result as a numeric value.  If the order is not conditional and no scope has been set for it, DBServer:OrderKeyCount() is identical to DBServer:RecCount, returning the number of records in the data server.  However, for a conditional order, there may be fewer keys than there are records, since some records may not meet the order's for condition or may not fall inside the scope specified by DBServer:OrderScope() — in counting the keys, DBServer:OrderKeyCount() respects the currently defined scope and for condition.
        <note type="tip">
          If there is no order in operation, DBServer:OrderKeyCount() will return 0 and not the value of DBServer:RecCount().
        </note></remarks>
      <example>
        This example demonstrates using DBServer:OrderKeyCount() with various orders.
        <code language="X#">
          oDBCust := Customer{}
          // Assume 1000 total records,
          // 500 less than thirty years old, and
          // 895 making less than 50,000
          ? oDBCust:RecCount				// Result: 1000
          ? oDBCust:OrderKeyCount()			// Result: 0
          oDBCust:CreateIndex("age", "oDBCust:Age")
          oDBCust:SetOrderCondition("oDBCust:Age &lt; 30")
          oDBCust:CreateIndex("first", "oDBCust:FirstName")
          oDBCust:SetOrderCondition("oDBCust:Salary &lt; 50000")
          oDBCust:CreateIndex("last", "oDBCust:LastName")
          // age is the controlling order
          oDBCust:SetIndex("age")
          oDBCust:SetIndex("first")
          oDBCust:SetIndex("last")
          ? oDBCust:RecCount				// Result: 1000
          ? oDBCust:OrderKeyCount()			// Result: 1000
          ? oDBCust:OrderKeyCount("first")	// Result: 500
          ? oDBCust:OrderKeyCount(3)		// Result: 895
        </code></example>
    </member>
    <member name="M:VO.DbServer.OrderKeyDel(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Delete a key from a custom built order.
      </summary>
      <param name="uOrder">
        The name of the order or a number representing its position in the order list.  Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.  If omitted or NIL, the controlling order is assumed.
        Specifying an invalid order, such as one that is not custom built, will raise a runtime error.
      </param>
      <param name="oFSIndex">
        The name of an index file, including an optional drive and directory (no extension should be specified).  Use this argument with &lt;uOrder&gt; to remove ambiguity when there are two or more orders with the same name in different index files.
        If &lt;oFSIndex&gt; is not open by the current process, a runtime error is raised.
      </param>
      <returns>
        TRUE if successful; otherwise FALSE.
      </returns>
      <remarks>
        A custom built order is one that is not automatically maintained by the DBFCDX driver.  You can determine if an order is custom built using DBServer:OrderInfo(DBOI_CUSTOM, ...).  When you create such an order, it is initially empty.
        You must manually add and delete keys using DBServer:OrderKeyAdd() and DBServer:OrderKeyDel().
        DBServer:OrderKeyDel() will fail if:
        The record pointer is positioned on an invalid record (for example, DBServer:EOF returns TRUE or the record pointer is positioned on a record that falls outside the orders' scope or for condition)
        The specified order is not custom built
        The specified order does not exist
        No order was specified and there is no controlling order
      </remarks>
      <example>
        This example creates a custom index, adds every fiftieth record to it, and deletes every hundredth record:
        <code language="X#">
          oDBCust := Customer{}
          // Create custom built order that is initially empty
          oDBCust:SetOrderCondition(,,,,,,,,,,,,, TRUE)
          oDBCust:CreateIndex("last", "oDBCust:LastName")
          // Add every 50th record
          FOR n := 1 UPTO oDBCust:RecCount STEP 50
          oDBCust:GoTo(n)
          oDBCust:OrderKeyAdd()
          NEXT
          // Remove every 100th record
          FOR n := 1 UPTO oDBCust:RecCount STEP 100
          oDBCust:GoTo(n)
          oDBCust:OrderKeyDel()
          NEXT
        </code></example>
    </member>
    <member name="M:VO.DbServer.OrderKeyGoTo(XSharp.__Usual)">
      <summary>
        Move to a record specified by its logical record number in the controlling order.
      </summary>
      <param name="nKeyNo">The logical record number.  If the value specified does not satisfy the scope or for condition for the order, the record pointer is positioned at the end-of-file.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        DBServer:OrderKeyGoTo() is the complement to DBServer:OrderKeyNo().  DBServer:OrderKeyNo() returns the logical record number (i.e., its position in the controlling order) of the current record, and DBServer:OrderKeyGoTo() moves the record pointer to the specified logical record.
        DBServer:OrderKeyGoTo() sends a NotifyIntentToMove message before the operation.  It also sends a NotifyRecordChange message upon successful completion.
        Tip:  This method can be useful when displaying scroll bars.  If the user clicks on a certain position on the scroll bar, you can move to the corresponding record by calling DBServer:OrderKeyGoTo().
      </remarks>
      <example>
        This example shows the difference between physical and logical record number:
        <code language="X#">
          oDBCust := Customer{}
          oDBCust:SetIndex("first") 	// Make records in first name order
          oDBCust:OrderKeyGoTo(100)	 	// Go to the 100th logical record
          ? oDBCust:RECNO			// Returns the physical record number
          ? oDBCust:OrderKeyNo()		// Returns 100, the logical record no
        </code></example>
    </member>
    <member name="M:VO.DbServer.OrderKeyNo(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Get the logical record number of the current record.
      </summary>
      <param name="uOrder">
        The name of the order or a number representing its position in the order list.  Using the order name is the preferred method since the position may be difficult to determine using multiple-order index files.  If omitted or NIL, the controlling order is assumed.
        Specifying an invalid order will raise a runtime error.
      </param>
      <param name="oFSIndex">
        The name of an index file, including an optional drive and directory (no extension should be specified).  Use this argument with &lt;uOrder&gt; to remove ambiguity when there are two or more orders with the same name in different index files.
        If &lt;oFSIndex&gt; is not open by the current process, a runtime error is raised.
      </param>
      <returns>
        The relative position of the current record in the specified order, as a numeric value.  DBServer:OrderKeyNo() respects the scope and for condition of the order by returning zero if the record pointer is positioned on an invalid record or if DBServer:EOF is TRUE.
      </returns>
      <remarks>
        DBServer:OrderKeyNo() returns the logical record number of a key in an order.  This in contrast to the physical record number (returned using DBServer:RecNo), which is the relative position of the record in the physical database file.
        DBServer:OrderKeyNo() sends a NotifyIntentToMove message before the operation.
        Tip:  This method can be useful for displaying scroll bars and messages such as "Record 9 of 123" when viewing records in a browser.
        By default, DBServer:OrderKeyNo() operates on the currently selected work area.  It will operate on an unselected work area if you specify it as part of an aliased expression.
      </remarks>
      <example>
        This example shows the difference between physical and logical record number:
        <code language="X#">
          oDBCust := Customer{}	// Assuming 1000 records
          oDBCust:SetIndex("first")	// Make records in first name order
          ? oDBCust:OrderKeyNo()	// Result: 1
          oDBCust:Skip(10)
          ? oDBCust:OrderKeyNo()	// Result: 11
          ? oDBCust:RECNO		// Result: Unknown
          oDBCust:GoBottom()
          ? oDBCust:OrderKeyNo()	// Result: 1000
          ? oDBCust:RECNO		// Result: Unknown
        </code></example>
    </member>
    <member name="P:VO.DbServer.OrderKeyNo(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        A numeric value representing the logical record number of the current record.
        The DBServer:OrderKeyNo assign sends a NotifyRecordChange message upon successful completion.
      </summary>
      <value>
        A numeric value representing the logical record number of the current record.
        The DBServer:OrderKeyNo assign sends a NotifyRecordChange message upon successful completion.
      </value>
    </member>
    <member name="P:VO.DbServer.OrderKeyVal">
      <summary>
        The key value of the current record from the controlling order.
      </summary>
      <value>The key value of the current record from the controlling order.</value>
      <remarks>
        The key value of the current record from the controlling order.  The data type is the same as the that of the key expression used to create the order.  Use ValType() or UsualType() to determine the data type.
      </remarks>
    </member>
    <member name="M:VO.DbServer.OrderScope(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the boundaries for scoping key values in the controlling order.
      </summary>
      <param name="nScope">A number specifying the top (TOPSCOPE) or bottom (BOTTOMSCOPE) boundary.</param>
      <param name="uValue">
        The top or bottom range of key values that will be included in the controlling order's current scope.  &lt;uValue&gt; can be an expression that matches the data type of the key expression in the controlling order or a code block that returns the correct data type.
        Omitting &lt;uValue&gt; or specifying it as NIL has the special effect of resetting the specified scope to its original default.  The default top range is the first logical record in the controlling order, and the default bottom range is the last logical record.
      </param>
      <returns>
        If &lt;uNewValue&gt; is not specified, DBServer:OrderScope() returns the current setting.  If &lt;uNewValue&gt; is specified, the previous setting is returned.
      </returns>
      <remarks>
        The range of values specified using DBServer:OrderScope() is inclusive.  In other words, the keys included in the scope will be greater than or equal the top boundary and less than or equal to the bottom boundary.
        <note type="tip">
          If you are using DbServer:OrderDescend() with Scopes, you need to swap the Top and Bottom scope values !
          <code language="X#">
            oServer:OrderScope (TOPSCOPE, cFrom)
            oServer:OrderScope (BOTTOMSCOPE, cTo)
            oServer:OrderDescend(,, TRUE)
            oServer:OrderScope (TOPSCOPE, cTo)
            oServer:OrderScope (BOTTOMSCOPE, cFrom)
          </code></note></remarks>
      <example>
        This example illustrates using DBServer:OrderScope() to set various scoping limitations on an order.  Although not shown in the examples below, the GoTop() or some other pointer mechanism, should be used immediately following the OrderScope() method calls to invoke the scope itself.  Checking for :EOF after the GoTop() call will also let you know if
        in fact any records even matched the scope conditions:
        <code language="X#">
          oDBFr := Friends{}
          oDBFr:SetIndex("age")
        </code><code language="X#">
          oDBFr:OrderScope(BOTTOMSCOPE, 25)	// Make 25 the lowest age in range
          oDBFr:OrderScope(TOPSCOPE, 30)	// Make 30 the highest age in range
          LIST Age					// Shows records with 25 &lt;= Age &lt;= 30
          oDBFr:OrderScope(BOTTOMSCOPE, 35)	// Change highest age to 35
          LIST Age					// Shows records with 25 &lt;= Age &lt;= 35
          oDBFr:OrderScope(TOPSCOPE, NIL)	// Reset top boundary
          LIST Age					// Shows records with Age &lt;= 35
          oDBFr:OrderScope(BOTTOMSCOPE, NIL)	// Reset bottom boundary
          LIST Age					// Shows all records
        </code></example>
    </member>
    <member name="M:VO.DbServer.OrderSkipUnique(XSharp.__Usual)">
      <summary>
        Move the record pointer to the next or previous unique key in the controlling order.
      </summary>
      <param name="nDirection">Specifies whether the method will skip to the next or previous key.  Omitting this value or specifying it as 1 skips to the next unique key.  Specifying a negative value skips to the previous key.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        DBServer:OrderSkipUnique() allows you to make a non-unique order look like a unique order.  Each time you use DBServer:OrderSkipUnique(), you are moved to the next (or previous) unique key, exactly as if you were skipping through a unique order.  This method eliminates the problems associated with maintaining a unique order, while providing you with fast access to unique keys.
        DBServer:OrderSkipUnique() sends a NotifyIntentToMove message before the operation.   It also sends a NotifyRecordChange message upon successful completion.
      </remarks>
      <example>
        This examples uses DBServer:OrderSkipUnique() to build an array of unique last names beginning with the letter "J:"
        <code language="X#">
          METHOD LastUnique() CLASS Customer
          LOCAL aLast[0] AS ARRAY
          SELF:SetIndex("last")	  // Use the last name order
          ? SELF:OrderIsUnique()	 // Result: FALSE
          // Only look at the J's
          SELF:OrderScope(0, "J")
          SELF:OrderScope(1, "J")
          SELF:GoTop()
          DO WHILE !SELF:EOF		    // Add all the unique J
          AADD(aLast, Last)	 // last names to aLast
          SELF:OrderSkipUnique()
          ENDDO
          // Clear the scope
          SELF:OrderScope(0, NIL)
          SELF:OrderScope(1, NIL)
          RETURN aLast
        </code></example>
    </member>
    <member name="P:VO.DbServer.OrderTopScope">
      <summary>
        A key value representing the record of the top boundary in the range of key values that will be included in the controlling order's current scope.
      </summary>
      <value>A key value representing the record of the top boundary in the range of key values that will be included in the controlling order's current scope.</value>
    </member>
    <member name="M:VO.DbServer.Pack">
      <summary>
        Remove deleted records from a database file.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyFileChange message, if successful.
      </remarks>
    </member>
    <member name="P:VO.DbServer.PaintedStructure">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.DbServer.RDDINFO(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Return and optionally change settings controlled directly by the RDD.
      </summary>
      <param name="kRDDInfoType">
        Specifies the setting.  The initial default of a setting depends on the RDD.
        The constants are described in the Constants section below.  Note, however, that not all constants are supported for all RDDs.
        <br />Important!  _SET_USER is a constant that returns the minimum value that third-party RDD developers can use for defining new &lt;kRDDInfoType&gt; parameters.  Values less than _SET_USER are reserved for CA development.
      </param>
      <param name="uRDDVal">If specified, this parameter is used to change the value of a setting.  The data type (and whether &lt;uNewSetting&gt; can be specified), depends on the &lt;kRDDInfoType&gt; constant and is documented in the Constants section below.</param>
      <returns>
        If &lt;uNewSetting&gt; is not specified, DBServer:RDDInfo() returns the current setting.  If &lt;uNewSetting&gt; is specified, the previous setting is returned.
      </returns>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>_SET_AUTOOPEN</term>
            <description>Returns and optionally changes the logical flag that determines whether the RDD will open production indexes automatically when a database file is opened.  A TRUE setting indicates that the production index is opened automatically.</description>
          </item>
          <item>
            <term>_SET_AUTOORDER</term>
            <description>Returns and optionally changes the numeric setting that determines whether the production index will set a controlling order.  A setting of 1 indicates that the first order in the production index will be the controlling order.  A setting of 0 indicates that database files will be processed in natural order when the production index is initially opened.</description>
          </item>
          <item>
            <term>_SET_AUTOSHARE</term>
            <description>Returns and optionally changes the numeric setting that determines the automatic sharing mode.</description>
          </item>
          <item>
            <term></term>
            <description>A setting of 0 completely disables automatic sharing control.  This is primarily useful when developing network applications in a stand-alone environment.</description>
          </item>
          <item>
            <term></term>
            <description>A setting of 1 causes the RDD to determine at runtime whether the application is running in a network environment.  If not, the RDD automatically opens all files in exclusive mode.  This allows you to write code that is network-aware, while still getting optimal performance when you application is running in single-user mode.</description>
          </item>
          <item>
            <term></term>
            <description>A setting of 2 opens all files in exclusive mode, regardless of the current environment.  Using this mode, you can easily convert an application designed for a network environment to work as a single-user application.  This is useful if you prefer to deliver separate stand-alone and LAN versions of the application.</description>
          </item>
          <item>
            <term>_SET_BLOB_CIRCULAR_ARRAY_REF</term>
            <description>Returns and optionally sets the logical flag indicating whether to check for circular array references when storing and retrieving arrays to and from BLOB fields.  A FALSE setting indicates that the RDD will not check for circular references.</description>
          </item>
          <item>
            <term></term>
            <description>The algorithm for storing/retrieving arrays uses a recursive process which will call itself indefinitely if the array has a circular reference, quickly exhausting the program's stack.  You can set DBServer:RDDInfo(_SET_BLOB_CIRCULAR_ARRAY_REF, TRUE) to cause the algorithm to check for and correctly process circular references.  Note, however, that the checking takes extra time and is unnecessary unless there are circular references.</description>
          </item>
          <item>
            <term>_SET_DEFAULTRDD</term>
            <description>Returns the name of the default RDD, specified as a string.</description>
          </item>
          <item>
            <term>_SET_HPLOCKING</term>
            <description>Returns and optionally changes the logical flag that determines whether to use the High Performance (HP) locking schema for newly created index files.  A FALSE setting indicates that the HP locking schema is not used.</description>
          </item>
          <item>
            <term>_SET_MEMOBLOCKSIZE</term>
            <description>Returns and optionally changes the numeric value specifying block size (in bytes) for memo files.</description>
          </item>
          <item>
            <term>_SET_MEMOEXT</term>
            <description>Returns and optionally changes the string value indicating the default memo file extension.</description>
          </item>
          <item>
            <term>_SET_NEWINDEXLOCK</term>
            <description>Returns and optionally changes the logical flag that determines the locking offset flag for newly created index files.  A FALSE setting indicates a locking offset that is compatible with Xbase applications but more restrictive than the offset that will be used if this flag is set to TRUE.</description>
          </item>
          <item>
            <term>_SET_OPTIMIZE</term>
            <description>Returns and optionally changes the logical flag that determines whether optimization will be used when filtering records in the database files.  A TRUE setting indicates that the RDD will use the available orders to make processing a filtered database as efficient as possible.</description>
          </item>
          <item>
            <term>_SET_STRICTREAD</term>
            <description>Returns and optionally changes the logical flag that determines whether the RDD will read records directly from disk when creating orders.</description>
          </item>
          <item>
            <term></term>
            <description>A FALSE setting indicates that the RDD will read records directly from disk when creating orders, which is the most efficient setting.  However, if you are using a DBF RDD layer that encrypts the database file, this setting will give incorrect results because the RDD will see the encrypted value rather than the actual value of the records.  In order to use the RDD with encryption packages, use DBServer:RDDInfo(_SET_STRICTREAD, TRUE).  This setting lets the DBF RDD layer read the records when creating an order.</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:VO.DbServer.RddName">
      <summary>
        A string representing the name of the database driver in use with this server.
      </summary>
      <value>A string representing the name of the database driver in use with this server.</value>
      <remarks>
        A string representing the name of the database driver in use with this server.
        The server can be specified as an instantiation parameter to the server.  If no driver is set, the default driver is used; it can be set by RDDSetDefault() or DBSetDriver().
      </remarks>
    </member>
    <member name="P:VO.DbServer.Rdds">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="P:VO.DbServer.ReadOnly">
      <summary>
        A logical value indicating whether the file was opened as a read-only file.  This is determined by an instantiation parameter of the server.
      </summary>
      <value>A logical value indicating whether the file was opened as a read-only file.  This is determined by an instantiation parameter of the server.</value>
      <example>
        This example function processes updates against the server only if the ReadOnly property is FALSE; otherwise, the function returns FALSE:
        <code language="X#">
          FUNCTION SalesUpdates(oDBServer)
          ...
          IF oDBServer:ReadOnly
          RETURN FALSE
          ELSE
          .
          . &lt;Statements TO update server&gt;
          .
          RETURN TRUE
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.DbServer.Recall(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Recall those deleted records indicated by a specified scope.
      </summary>
      <param name="cbForBlock">The condition that is evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.</param>
      <param name="cbWhileBlock">The condition that is evaluated for each record from the current record until the condition returns FALSE.  It provides the same functionality as the WHILE clause of record processing commands.</param>
      <param name="uScope">
        The range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands.
        Value	Description
        DBSCOPEALL	The scope is all the records in the table.  This is the default, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
        DBSCOPEREST	The scope is the remaining records in the table from the current position.
        &lt;nRecords&gt;	The scope is the next &lt;nRecords&gt; records.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.  Note that after a FALSE indication of a scoped operation, some records can have been recalled: the operation can have failed halfway through because of lock conflicts or technical problems.
      </returns>
      <remarks>
        If no scope was passed and no scope was active, it sends a NotifyRecordChange, if the operation was successful; if a scope was used, it sends a NotifyFileChange message regardless of the number of records processed.
        If no server scope is set, it recalls the current record.  On successful completion, the current record will be the last file record and DBServer:EOF will be TRUE.
      </remarks>
    </member>
    <member name="M:VO.DbServer.RecallAll">
      <summary>
        Recall all deleted records in the table.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE, although even with FALSE, some records may be recalled.  This would happen if the operation failed halfway through because of lock conflicts or technical problems.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyFileChange message upon completion.
        On successful completion, the current record will be the last file record and DBServer:EOF will be TRUE.
      </remarks>
    </member>
    <member name="P:VO.DbServer.RecCount">
      <summary>
        The number of records in the current database file.
      </summary>
      <value>The number of records in the current database file.</value>
      <remarks>
        The number of records in the current database file.  Filtering commands such as SET FILTER or SET DELETED have no effect on the return value.  This access is identical to the :LastRec Access.
      </remarks>
      <example>
        This example uses RecCount to define an access method to return the Size of the data server:
        <code language="X#">
          CLASS Sales INHERIT DBServer
          ...
          ACCESS Size CLASS Sales
          RETURN (SELF:RecSize * SELF:RecCount) + ;
          SELF:Header + 1
        </code></example>
    </member>
    <member name="P:VO.DbServer.RecNo">
      <summary>
        A numeric value representing the current record number, identifying the position of the record pointer.
      </summary>
      <value>A numeric value representing the current record number, identifying the position of the record pointer.</value>
      <remarks>
        A numeric value representing the current record number, identifying the position of the record pointer.
        Assigning a value to RecNo is equivalent to executing GoTo(); both reposition the record pointer on the given record.
        These two statements are equivalent:
        <code language="X#">
          oDBServer:RecNo := 1168
          oDBServer:GoTo(1168)
        </code>
        If the server contains a database file with 0 records, RecNo returns 1, BOF and EOF both return TRUE, and RecCount/LastRec return 0.  If the record pointer is moved past the last record, RecNo returns LastRec + 1 and EOF returns TRUE.  If an attempt is made to move before the first record, RecNo returns the record number of the first logical record in the database file and BOF returns TRUE.
        The DBServer:RecNo assign sends a NotifyIntentToMove message before the operation.
      </remarks>
      <example>
        This example queries RecNo after deliberately moving the record pointer:
        <code language="X#">
          CLASS Sales INHERIT DBServer
          ...
          FUNCTION RecNoDemo()
          LOCAL oDBSales AS Sales
          oDBSales := Sales{}
          oDBSales:GoTo(3)
          ? oDBSales:RECNO			// Result: 3
          oDBSales:GoTop()
          ? oDBSales:RECNO			// Result: 1
          oDBSales:GoBottom()
          ? oDBSales:RECNO			// Result: 10
        </code></example>
    </member>
    <member name="M:VO.DbServer.RecordInfo(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Retrieve information about the indicated record.
      </summary>
      <param name="kRecInfoType">
        The information retrieved depends on the constant specified
        Constant	Returned Value
        DBRI_BUFFPTR	Pointer to current record buffer
        DBRI_DELETED	Is record deleted?
        DBRI_DELETED	Is record deleted?
        DBRI_RECSIZE	Record length.
        DBRI_LOCKED	Is record locked?
        DBRI_RECNO	Record position (like the RecNo access).
        <br />Important!  DBRI_USER is a constant that returns the minimum value that third-party RDD developers can use for defining new &lt;kInfoType&gt; parameters.  Values less than DBRI_USER are reserved for CA development.
      </param>
      <param name="nRecordNumber">Indicates the record for which information is to be retrieved; if 0 or omitted, refers to the current record.</param>
      <param name="uRecVal">This parameter is reserved for RDDs that allow you to change the information rather than just retrieve it.  None of the supplied RDDs (as outlined in the 'RDD Specifics' appendix in the Programmer's Guide) support this argument.  Either omit the argument or specify it as NIL.</param>
      <returns>
        The data type of the return value depends on the value requested.
      </returns>
    </member>
    <member name="P:VO.DbServer.RecSize">
      <summary>
        A numeric value representing the record length of the server in bytes.
      </summary>
      <value>A numeric value representing the record length of the server in bytes.</value>
      <example>
        This example uses RecSize to define an access method to return the Size of the data server:
        <code language="X#">
          CLASS Sales INHERIT DBServer
          ...
          ACCESS Size CLASS Sales
          RETURN (SELF:RecSize * SELF:RecCount) + ;
          SELF:Header + 1
        </code></example>
    </member>
    <member name="M:VO.DbServer.Refresh">
      <summary>
        Reread the current record from the database, discarding any changes that have been made.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyRecordChange message, if successful.
        This command discards all changes to the current record.  It is useful as a way of implementing Undo in an application.  However, it cannot roll back changes that have been committed with the DBServer:Commit().  Also, note that it applies only to the current record; the data server and the drivers do not buffer changes made to multiple records.
      </remarks>
    </member>
    <member name="M:VO.DbServer.Reindex">
      <summary>
        Recreate all active indexes for this server.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyCompletion message upon completion.  Obviously all other users should be out of your system prior to executing this method.
      </remarks>
    </member>
    <member name="M:VO.DbServer.Relation(XSharp.__Usual)">
      <summary>
        Return the linking expression of a specified relation.
      </summary>
      <param name="nRelation">The position of the desired relation in the list of current relations.  The relations are numbered according to the order in which they were defined with DBServer:SetRelation().</param>
      <returns>
        A string containing the linking expression of the relation specified by &lt;nRelation&gt;.  If there is no relation set for &lt;nRelation&gt;, DBServer:Relation() returns a NULL_STRING.
      </returns>
    </member>
    <member name="P:VO.DbServer.RelationChildren">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.DbServer.Replace(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Replace one or several fields with a new expression, for all records that match a specified scope.
      </summary>
      <param name="acbExpression">The single expression to be evaluated to yield the replacement value or the array of expressions to be evaluated to yield the replacement values.</param>
      <param name="aFieldList">The single field to be modified or the array of fields that are to be modified.</param>
      <param name="cbForBlock">The condition that is evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.</param>
      <param name="cbWhileBlock">The condition that is evaluated for each record from the current record until the condition returns FALSE.  It provides the same functionality as the WHILE clause of record processing commands.</param>
      <param name="uScope">
        The range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands.
        Value	Description
        DBSCOPEALL	The scope is all the records in the table.  This is the default, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
        DBSCOPEREST	The scope is the remaining records in the table from the current position.
        &lt;nRecords&gt;	The scope is the next &lt;nRecords&gt; records.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE (although this can still have caused records to be modified).
      </returns>
      <remarks>
        If the specified scope is active, DBServer:Replace() sends a NotifyIntentToMove message before the operation.  It also sends a NotifyFileChange message upon completion, whether successful or not.
        If no scope is used, on successful completion, the current record will be the last file record and DBServer:EOF will be TRUE.
      </remarks>
      <example>
        The following examples demonstrate how the DBServer:Replace() method can be used:
        <code language="X#">
          // Add 100 to the salaries of female employees
          oDBEmp:Replace({||Salary+100}, #Salary, {||Sex="F"})
          // Subtract 20 from grade, assign a raise of 100,
          // and establish a new raise date for those
          // employees that are newly assigned to Proj20
          oDBEmp:Replace({"GRADE-20", "100", "NewDate"}, {#Grade, #Raise, #RaiseDate},	;
          {|| NewAssignment(EmpNo) = Proj20})
          // Assign 0 to the credit status field of all records
          oDBEmp:Replace(0,#CreditStatus)
        </code></example>
    </member>
    <member name="M:VO.DbServer.ResetNotification">
      <summary>
        Resume the broadcasting of Notify messages to the server's attached clients (after DBServer:SuspendNotification() has been called).
      </summary>
      <remarks>
        This method is used in conjunction with DBServer:SuspendNotification(), which suspends the broadcasting of Notify messages.
        Note that DBServer:SuspendNotification() stacks its invocations.  Therefore, for each call to DBServer:SuspendNotification(), there needs to be a corresponding call DBServer:ResetNotification().
      </remarks>
    </member>
    <member name="P:VO.DbServer.Retries">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.DbServer.RLOCK(XSharp.__Usual)">
      <summary>
        Lock a record for exclusive write access; other users can still make read-only reference to the record.
      </summary>
      <param name="nRecordNumber">The number of the record number to be locked.  The indicated record is locked, and previous record locks are maintained.  Note that this can be the current record: explicitly specifying the current record indicates that previous locks should be maintained.  If omitted, or NIL, the current record is locked and all previous record locks are released.</param>
      <returns>
        TRUE if successful; otherwise, FALSE (including if the indicated record was successfully locked but other record locks cannot be maintained).
      </returns>
    </member>
    <member name="P:VO.DbServer.RLockList">
      <summary>
        An array of record numbers that are currently locked.
      </summary>
      <value>An array of record numbers that are currently locked.</value>
      <example>
        The following method processes all locked records in the data server:
        <code language="X#">
          CLASS Sales INHERIT DBServer
          ...
          METHOD ProcessLocked() CLASS Sales
          LOCAL siCount AS SHORTINT
          FOR siCount := 1 UPTO ALen(SELF:RLockList)
          SELF:GoTo(RLockList[siCount])
          // Process record
          NEXT
          SELF:Unlock()			// Release all locks
        </code></example>
    </member>
    <member name="M:VO.DbServer.RLockVerify">
      <summary>
        Determine if the current record in this data server has any pending updates and lock it for exclusive write access if there are none.
      </summary>
      <returns>
        TRUE if the record is unchanged and the lock was successfully taken; otherwise, FALSE.
      </returns>
      <remarks>
        This method checks for pending updates to the current record by comparing the values that were read to the record when the server was initially positioned on the record with the current values in the corresponding database record.
        If the values match, it signifies that no other user has modified the data since the user started working on it, and, therefore, that it is safe to lock the record and let the user continue with an update transaction.  (Note that when locked, other users can still make read-only reference to the record.)
        If the values do not match, somebody else has changed the record, and the user should refresh the values from disk and  restart the transaction.  The application has to decide what to do about values that are different.  Note that DBServer:Status can be used to determine the reason for the failure.
        This method is used for optimistic concurrency control.  (See "Concurrency Control" in the Programmer's Guide  for more information.)
      </remarks>
    </member>
    <member name="P:VO.DbServer.Scope">
      <summary>
        The "scope" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope.  The initial value of the scope is NIL.
      </summary>
      <value>The "scope" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope.  The initial value of the scope is NIL.</value>
      <remarks>
        The following constants represent the range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>DBSCOPEALL</term><description>
              The scope is all the records in the table.  This is the <b>default</b>, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
            </description></item><item><term>DBSCOPEREST</term><description>The scope is the remaining records in the table from the current position.</description></item></list></remarks>
      <example>
        This example illustrates how various Scope values affect the extent of a recall operation:
        <code language="X#">
          // RECALL FOR Last == "Smith" REST
          oDB:ForBlock := {|| Last == "Smith"}
          oDB:Scope := DBSCOPEREST
          oDB:Recall()
          // RECALL WHILE Last == "Smith" NEXT 10
          oDB:WhileBlock := {|| Last == "Smith"}
          oDB:Scope := 10
          oDB:Recall()
        </code></example>
    </member>
    <member name="M:VO.DbServer.Seek(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Move to the record having the specified key value in the controlling order.
      </summary>
      <param name="uSearchExpr">Specifies the key value associated with the desired record.</param>
      <param name="lSoftSeek">Determines how the data server is positioned if the specified key value is not found: TRUE performs a soft seek; FALSE does not.  If &lt;lSoftSeek&gt; is omitted, the current SetSoftSeek() setting is used.</param>
      <param name="lLast">TRUE seeks the last occurrence of the specified key value.  FALSE, the default, seeks the first occurrence.  &lt;lLast&gt; only applies to CDX indexes.</param>
      <returns>
        TRUE if the specified key value was found; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.
        DBServer:Seek() moves to the first logical record whose key value is equal to &lt;uKey&gt;.  If such a record is found, it becomes the current record and DBServer:Seek() returns TRUE.  Otherwise, DBServer:Seek() returns FALSE and the positioning of the data server is as follows: for a normal (not soft) seek, the data server is positioned to DBServer:LastRec + 1 and DBServer:EOF returns TRUE; for a soft seek, the data server is positioned to the first record whose key value is greater than the specified key value.  If no such record exists, the data server is positioned to DBServer:LastRec + 1 and DBServer:EOF returns TRUE.
        For a data server with no controlling order, DBServer:Seek() has no effect.
        <note type="tip">
          Logical records:	DBServer:Seek() operates on logical records.  Records are processed in controlling order.  If a filter is set, only records which meet the filter condition are considered.
          Shared mode:	For a shared file, moving to a different record can cause updates to the current record to become visible to other processes.  For more information, refer to "Concurrency Control" in the Programmer's Guide.
        </note></remarks>
      <example>
        In this example, DBServer:Seek() moves the pointer to the record in the database, EMPLOYEE, in which the value in the control field sleLastName matches a record in the database:
        <code language="X#">
          IF Employee:Seek( UPPER( SELF:oDCsleLastName:Value ) )
          Employee:ViewRecord()
          ELSE
          QOut("Not found")
          END
        </code></example>
    </member>
    <member name="M:VO.DbServer.SELECT">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.DbServer.SelectionWorkArea">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.DbServer.SetDataField(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Assign a DataField object to a specified field.
      </summary>
      <param name="nFieldPosition">The number of the desired field.</param>
      <param name="oDataField">The data field to assign.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        The new field is verified to be compatible with the actual database field, if one is open.  This method is normally used only during instantiation of a data server, most often in Init() methods of subclasses.  For example, the code generated by the DBServer Editor uses this method.
      </remarks>
    </member>
    <member name="M:VO.DbServer.SetFilter(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a filter condition.
      </summary>
      <param name="cbFilterBlock">The code block that expresses the filter condition in executable form.  If the code block is omitted, the string version of the filter expression is macro-compiled into a code block.</param>
      <param name="cFilterText">The filter condition.  If omitted, the DBServer:Filter access method returns a NULL_STRING.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Both arguments specify the filter expression, one in the form of a code block, one in the form of a string.  Both arguments are optional, but at least one must be provided.  The reason for specifying both versions is that a compiled code block is faster, while the string version can be reported back through the Filter access method.  Obviously, if both forms are specified, they should define the same expression.
      </remarks>
      <example>
        The following examples demonstrate the various methods of setting a filter using the DBServer:SetFilter().  The filter condition is customer numbers (CustNo) exceeding 20,000.  Note the user of the GoTop() method to invoke the filter expression by moving the record pointer.
        <code language="X#">
          // Codeblock specified only
          oDBCust:SetFilter({||CustNo &gt; 20000})
          oDBCust:GoTop()
          // Codeblock and text to describe the filter text specified
          oDBCust:SetFilter({||CustNo &gt; 20000}, "CustNo &gt; 20000")
          oDBCust:GoTop()
          // Filter text specified only, which is compiled into a code block
          oDBCust:SetFilter(, "CustNo &gt; 20000")
          oDBCust:GoTop()
          // Filter text specified only, which is compiled into a code block
          oDBCust:SetFilter(, [ Gender = '] + SELF:cGender + ['] )
          oDBCust:GoTop()
        </code></example>
    </member>
    <member name="M:VO.DbServer.SetIndex(XSharp.__Usual)">
      <summary>
        Open an index file and select its order as the controlling order, if this is the first index being opened.
      </summary>
      <param name="oFSIndexFile">
        The index file can be specified as a FileSpec object or as a file name in string format, with or without file type.  File type defaults to the native type for the driver (RDD).
        If no argument is passed, all currently opened indexes are closed, and the server reverts back to sequential access based on record number (natural order).  This is equivalent to ClearIndex().
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyFileChange message, if successful.
        If the index file contains more than one order, the first one is set as the controlling order.  The server is positioned to the first logical record in the controlling order.
      </remarks>
      <example>
        The following example opens multiple index files:
        <code language="X#">
          oSales := DBServer{"sales"}
          oSales:SetIndex("firstname")
          oSales:SetIndex("lastname")
          IF oSales:Seek(cLast)
          IF oSales:Deleted() .AND. RLock()
          oSales:Recall()
          ENDIF
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.DbServer.SetOrder(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Select an order from one of the open index files as the controlling order.
      </summary>
      <param name="uOrder">The order can be identified by an order number, the position of the order in the order list, or a name.</param>
      <param name="cIndexFileName">If the order is specified by an order name that is not unique within the order list, the index file name can be specified, either as a FileSpec object or as a file name in string format, with or without file type.  File type defaults to the native type for the driver (RDD).  Note, however, that SetOrder() does not open the index file, it refers only to orders within already opened files.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyFileChange message, if successful.
        The server remains positioned on the same record after the controlling order is changed.  Note that when a dbServer object is first instantiated, and the CDX index driver is used and auto-open indexes is set to TRUE, then the tag that will be opened will be the first tag identified alphabetically – NOT the sequence that you created the tags in.  Thus a SetOrder() should typically be set before performing any sort of Seek() operation to ensure that the proper index tag is set.
      </remarks>
    </member>
    <member name="M:VO.DbServer.SetOrderCondition(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set conditions that is applied to index and order creation.  If SetOrderCondition() has not been called, order creation is subject to the general server scope.  If neither has been set, orders are not conditional.
      </summary>
      <param name="cFor">A string that specifies the FOR condition for the order.  If you do not need this information, you can specify a NULL_STRING.</param>
      <param name="cbForBlock">
        A code block that defines a FOR condition that each record within the scope must meet in order to be processed.  Only those records that meet the condition are included in the resulting order.  Duplicate key values are not added to the index file.
        The FOR condition is stored as part of the index file and used when updating or recreating the index using the DBServer:Reindex() method.  The FOR clause provides the only scoping that is maintained for all database changes.  All other scope conditions create orders that do not reflect database updates.
        If a string is provided, it is compiled into a code block dynamically.  It can be no longer than 250 characters under the DBFNTX driver.
      </param>
      <param name="lAll">Specifies all orders in the current or specified work area.  ALL is the default scope of INDEX ON.</param>
      <param name="cbWhileBlock">
        A code block that specifies another condition that must be met by each record as it is processed.  As soon as a record is encountered that causes the condition to fail, the order creation terminates.  If a WHILE clause is specified, the data is processed in the controlling order.
        The WHILE condition is transient (that is, it is not stored in the file and not used for index updates and reindexing purposes). The WHILE condition creates temporary orders, but these orders are not updated.
        Using the WHILE condition is more efficient and faster than using the FOR condition.  The WHILE condition processes only data for which &lt;cbWhileCondition&gt; is TRUE from the current position.  The FOR condition, in contrast, processes all data in the data source.
      </param>
      <param name="cbEvalBlock">The code block that is evaluated for every record that is processed, or as specified below.  This code block allows the application to intercede during the order creation, which might be quite lengthy; it might be used to update the screen, for example, showing progress on a thermometer-type display or in the status bar.</param>
      <param name="nStep">The numeric expression that modifies the number of times &lt;cbEvalBlock&gt; is evaluated.  This argument offers a performance enhancement by evaluating the condition for every nth record instead of for every record ordered.  To step through every record, specify a value of 0 or omit the parameter.</param>
      <param name="nStart">The record number to start the evaluation from.  To start at the top, specify a value of 0 or omit the parameter.</param>
      <param name="nNext">The number of records to process, starting at &lt;nStart&gt;.  Specify 0 to ignore this argument.</param>
      <param name="nRecno">A single record number to process.  Specify 0 to ignore this argument.</param>
      <param name="lRest">Specifies whether the scope of processing is all records, or, starting with the current record, all records to the end of file.  This argument corresponds to the REST and ALL clauses of record processing commands.  If TRUE , the scope is REST; otherwise, the scope is ALL records.</param>
      <param name="lDescending">Specifies whether the keyed pairs be sorted in decreasing or increasing order of value.  If TRUE the order is in descending order otherwise the order is in ascending order.</param>
      <param name="lAdditive">Specifies whether open orders should remain open while the new order is being created.  TRUE specifies that they should remain open.  FALSE specifies that all open order should be closed.  The default is FALSE.</param>
      <param name="lCurrent">Specifies whether only records in the controlling order — and within the current range as specified by DBServer:OrderScope() — will be included in this order.  TRUE specifies that the controlling order and range should be used to limit the scope of the newly created order.  FALSE specifies that all records in the database file are included in the order.  The default is FALSE.</param>
      <param name="lCustom">Specifies whether the new order will be a custom built order (for RDDs that this feature).  TRUE specifies that a custom built order will be created.  A custom built order is initially empty, giving you complete control over order maintenance.  The system does not automatically add and delete keys from a custom built order.  Instead, you explicitly add and delete keys using DBServer:OrderKeyAdd() and DBServer:OrderKeyDel().  FALSE specifies a standard, system-maintained order.  The default is FALSE.</param>
      <param name="lNoOptimize">Specifies whether the FOR condition will be optimized (for RDDs that support this feature).  TRUE optimizes the FOR condition, and FALSE does not.  The default is FALSE.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.DbServer.SetRelation(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a relation from this server to the child server.
      </summary>
      <param name="oDBChild">The server attached to the child server must be specified as a DBServer object (not as an alias).  If &lt;oDBChild&gt; is omitted, all relations for this server are removed (the recommended way of doing this is the ClearRelations() method).</param>
      <param name="uRelation">The relation code block for the server or the name or symbol representing the field from this server; a code block is constructed and macro-compiled</param>
      <param name="cRelation">When the relation is specified as a code block, a string version of the code block can be provided as well; it is returned by the Relation() method.</param>
      <param name="lSelective">Should this be a selective relation ?</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyRecordChange message to the child server, if successful.
        As always, the child work area should have a controlling index that matches the expression.
      </remarks>
      <example>
        The API can take these forms:
        <code language="X#">
          oDBCustomer:SetRelation(oDBOrders, {||_FIELD-&gt;CustNo},"CustNo")
          oDBCustomer:SetRelation(oDBOrders, #CustNo)
          oDBCustomer:SetRelation(oDBOrders, {#LastName, #Initial, #FirstName})
        </code></example>
    </member>
    <member name="M:VO.DbServer.SetSelectiveRelation(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a selective relation from this server to the child server; standard database operations are restricted to those records that match the relation.
      </summary>
      <param name="oDBChild">The server attached to the child server must be specified as a DBServer object (not as an alias).  If &lt;oDBChild&gt; is omitted, all relations for this server are removed (the recommended way of doing this is the ClearRelations() method).</param>
      <param name="uRelation">The relation code block for the server or the name or symbol representing the field from this server; a code block is constructed and macro-compiled</param>
      <param name="cRelation">When the relation is specified as a code block, a string version of the code block can be provided as well; it is returned by the Relation() method.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyRecordChange message to the child server, if successful.
        As always, the expression should match or be a partial index of the controlling index of the child's work area.
      </remarks>
      <example>
        The API can take these forms:
        <code language="X#">
          oDBCustomer:SetSelectiveRelation(oDBOrders, {||_FIELD-&gt;CustNo},"CustNo")
          oDBCustomer:SetSelectiveRelation(oDBOrders, #CustNo)
          oDBCustomer:SetSelectiveRelation(oDBOrders, {#LastName,#Initial,#FirstName})
        </code></example>
    </member>
    <member name="P:VO.DbServer.Shared">
      <summary>
        A logical value indicating whether the server is sharable or exclusive.
      </summary>
      <value>A logical value indicating whether the server is sharable or exclusive.</value>
      <remarks>
        A logical value indicating whether the server is sharable or exclusive.  DBServer:Shared is determined by an instantiation parameter of the server; if not specified, the default set by SetExclusive() is used.
      </remarks>
      <example>
        This example function processes updates against the server only if the Shared property is FALSE; otherwise, the function returns FALSE:
        <code language="X#">
          FUNCTION SalesUpdates(oDBServer)
          ...
          IF oDBServer:Shared
          RETURN FALSE
          ELSE
          .
          . &lt;Statements TO update server&gt;
          .
          RETURN TRUE
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.DbServer.Skip(XSharp.__Usual)">
      <summary>
        Move the record pointer forward or backward a specified number of records.
      </summary>
      <param name="nRecordCount">The number of records to move, relative to the current record.  A positive value means to move forward, and a negative value means to move backward.  If omitted, +1 is assumed.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyRecordChange message, if a move was made.
        If DBServer:Skip() positions the DBServer beyond the last record, DBServer:EOF will be set and the DBServer will be positioned on the last record.
      </remarks>
    </member>
    <member name="M:VO.DbServer.Sort(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Copy records to another database file in sorted order.  If neither conditions nor scope is passed to the method, it is subject to the general server scope.
      </summary>
      <param name="oFSTarget">The file to which the records is copied.</param>
      <param name="aFieldList">An array of fields to be used as sort keys.  If an array of strings is specified, you may optionally add a sort key, after the field name; /A (to sort in dictionary order), /C (to ignore capitalization), or /D (to sort in descending order).  The default setting is /A.</param>
      <param name="cbForBlock">The condition evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.</param>
      <param name="cbWhileBlock">The condition evaluated for each record from the current record until the condition returns FALSE.  It provides the same functionality as the WHILE clause of record processing commands.</param>
      <param name="uScope">
        The range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands
        Value	Description
        DBSCOPEALL	The scope is all the records in the table.  This is the default, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
        DBSCOPEREST	The scope is the remaining records in the table from the current position.
        &lt;nRecords&gt;	The scope is the next &lt;nRecords&gt; records.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.  Note that after a FALSE indication, some records can have been copied: the operation can have failed halfway through because of lock conflicts or technical problems.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyRecordChange message upon completion.
        This method does not open the new file, it simply creates the file on disk.  If you want to open it afterwards, you simply instantiate it directly:
        <code language="X#">
          oDB1:Sort(oFSTarget)
          oDB2 := DBServer{oFSTarget}
        </code></remarks>
    </member>
    <member name="P:VO.DbServer.Status">
      <summary>
        A HyperLabel object identifying the status after the last operation.  If
      </summary>
      <value>A HyperLabel object identifying the status after the last operation.  If</value>
      <remarks>
        A HyperLabel object identifying the status after the last operation.  If the last operation was successful, DBServer:Status returns NULL_OBJECT; if something went wrong (whether it raised an error condition or merely returned a failure code), DBServer:Status returns an informative HyperLabel object.
        By accessing the properties of this hyperlabel, you can retrieve not only a description of the condition that was raised, but also context-sensitive help on the condition that was raised.
      </remarks>
      <example>
        The following examples invoke several DBServer:Status access/assign methods:
        <code language="X#">
          oDataServer:Status:Caption
          oDataServer:Status:Description
          oDataServer:Status:HelpContext
        </code></example>
    </member>
    <member name="M:VO.DbServer.Sum(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Calculate the sum of a series of numeric expressions.
      </summary>
      <param name="acbExpression">The single expression that Sum() operates on or the array of expressions that Sum() operates on.</param>
      <param name="cbForBlock">The condition evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.</param>
      <param name="cbWhileBlock">The condition evaluated for each record from the current record until the condition returns FALSE.  It provides the same functionality as the WHILE clause of record processing commands.</param>
      <param name="uScope">
        The range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands
        Value	Description
        DBSCOPEALL	The scope is all the records in the table.  This is the default, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
        DBSCOPEREST	The scope is the remaining records in the table from the current position.
        &lt;nRecords&gt;	The scope is the next &lt;nRecords&gt; records.
      </param>
      <returns>
        An array that contains the sums for each expression or field specified.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.
        On successful completion, the current record will be the last file record and DBServer:EOF will be TRUE.
      </remarks>
      <example>
        The following example calculates the totals of the salaries, commissions, and withholdings for department 1348:
        <code language="X#">
          aSums := oDB1:Sum({#Salary, #Commission, #Withholdings},{||Department=1348})
          ? "Salary:", aSums[1]
          ? "Commission:", aSums[2]
          ? "Withholdings:", aSums[3]
        </code></example>
    </member>
    <member name="M:VO.DbServer.SuspendNotification">
      <summary>
        Suspend the broadcasting of Notify messages to the server's attached clients.
      </summary>
      <remarks>
        This method is useful, for example, when the server is moving through the database and the server is ultimately restored to its original position.  Therefore, there is no reason to notify the clients of the server of a change in position within the database.
        Note that DBServer:SuspendNotification() stacks its invocations.  Therefore, for each call to DBServer:SuspendNotification(), there needs to be a corresponding call DBServer:ResetNotification().
      </remarks>
    </member>
    <member name="P:VO.DbServer.TableExt">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.DbServer.Total(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Aggregate records by key value, producing grouped summarizations, and write the aggregate records to another database.
      </summary>
      <param name="oFSTarget">The file to which the summary data is written.</param>
      <param name="cbKeyField">The key field in this server that is the basis for the summarization.  Note that for the summarization to produce correct results, the table should be indexed or sorted on this key field.</param>
      <param name="aFieldList">An array of the fields that are to be summarized.</param>
      <param name="cbForBlock">The condition evaluated for each record in the scope; if TRUE, the record is included in the processing.  It provides the same functionality as the FOR clause of record processing commands.</param>
      <param name="cbWhileBlock">The condition evaluated for each record from the current record until the condition returns FALSE.  It provides the same functionality as the WHILE clause of record processing commands.</param>
      <param name="uScope">
        The range of records to process, providing the same functionality as the ALL, REST and NEXT clauses of record processing commands
        Value	Description
        DBSCOPEALL	The scope is all the records in the table.  This is the default, although if a WHILE condition is specified, the scope becomes DBSCOPEREST.
        DBSCOPEREST	The scope is the remaining records in the table from the current position.
        &lt;nRecords&gt;	The scope is the next &lt;nRecords&gt; records.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.  Note that after a FALSE indication of a scoped operation, some records can have been written to the target file: the operation can have failed halfway through because of lock conflicts or technical problems.
      </returns>
      <remarks>
        Sends a NotifyIntentToMove message before the operation.  Sends a NotifyRecordChange message upon completion.
      </remarks>
      <example>
        This method does not open the new file, it simply creates the file on disk.  If you want to open it afterwards, you simply instantiate it directly.
        <code language="X#">
          IF oDB1:Total(oFSTarget)
          oDB2 := DBServer{oFSTarget}
          ELSE
          ...
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.DbServer.UnLock(XSharp.__Usual)">
      <summary>
        Release a specified lock or all locks.
      </summary>
      <param name="nRecordNumber">The number of the desired record.  If 0 or omitted, all locks for this server are released, record locks as well as file locks.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.DbServer.Update(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Update this server with data from another server or table.
      </summary>
      <param name="oDbServer">The database that provides the new data.</param>
      <param name="cbKey">The key field that defines how records are matched between the servers.</param>
      <param name="lRandomFlag">Indicates if the records in the other database are allowed to be in random order.  If FALSE or not specified, the other database must be ordered on the specified key.</param>
      <param name="cbReplace">Code block that performs the update operations.</param>
      <returns>
        TRUE if successful; otherwise, FALSE, although even with FALSE, some records may have been updated.  This can happen if the operation failed halfway through because of technical problems.
      </returns>
      <remarks>
        <note type="tip">This method requires a file lock or exclusive access.</note>
        Sends a NotifyFileChange message upon completion.
        There are two different formulations of the matching relationship between the two servers.  If &lt;lRandomFlag&gt; is TRUE, this server must be indexed on the specified key, but the other server can be in any order; if &lt;lRandomFlag&gt; is not specified or is FALSE, both servers must be indexed or sorted on the specified key.  If there is more than one record in this server with matching key fields, only the first one is updated.
      </remarks>
    </member>
    <member name="P:VO.DbServer.Used">
      <summary>
        A logical value indicating whether the server is currently open
      </summary>
      <value>A logical value indicating whether the server is currently open</value>
      <remarks>
        A logical value indicating whether the server is currently open.  DBServer:Used returns TRUE if the server was successfully opened, and FALSE if the server has been closed or if a serious error has occurred that renders the table unusable.  In that case, more information can be retrieved through DBServer:Status or by intercepting the error condition.
        If DBServer:Used is FALSE, the properties and methods return NIL, FALSE, or some similar null value.
      </remarks>
    </member>
    <member name="P:VO.DbServer.WhileBlock">
      <summary>
        The "WHILE block" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope
      </summary>
      <value>The "WHILE block" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope</value>
      <remarks>
        The "WHILE block" component of the "general server scope," which affects several bulk processing methods if they are called with no explicit scope.  The access always returns a code block.
        Specifying a WHILE block makes the method process all remaining records until the WHILE block evaluates FALSE, subject to other scope settings, of course.  Specifying a WHILE block makes the scope default to REST.
      </remarks>
      <example>
        This example assigns a code block to WhileBlock to limit the scope of a recall operation:
        <code language="X#">
          // RECALL WHILE Last == "Smith" ALL
          oDB:WhileBlock := {|| Last == "Smith"}
          oDB:Scope := DBSCOPEALL
          oDB:Recall()
        </code></example>
    </member>
    <member name="P:VO.DbServer.WorkArea">
      <summary>
        A number representing the workarea of the server
      </summary>
      <value>A number representing the workarea of the server</value>
    </member>
    <member name="M:VO.DbServer.Zap">
      <summary>
        Permanently remove all records from the server and release the disk space.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">This method requires exclusive access.</note>
        Sends a NotifyFileChange message upon completion.
      </remarks>
    </member>
    <member name="M:VO.DDECallbackDelegate.#ctor(System.Object,System.IntPtr)">
      <exclude />
    </member>
    <member name="M:VO.DDECallbackDelegate.BeginInvoke(System.UInt16,System.UInt16,System.Void*,System.Void*,System.Void*,System.Void*,System.UInt32,System.UInt32,System.AsyncCallback,System.Object)">
      <exclude />
    </member>
    <member name="M:VO.DDECallbackDelegate.EndInvoke(System.IAsyncResult)">
      <exclude />
    </member>
    <member name="M:VO.DDECallbackDelegate.Invoke(System.UInt16,System.UInt16,System.Void*,System.Void*,System.Void*,System.Void*,System.UInt32,System.UInt32)">
      <exclude />
    </member>
    <member name="T:VO.DialogWindow">
      <summary>
        Create a dialog window (also commonly referred to as a dialog box), which allows the application and end user to interact.  This type of dialog can be modal or modeless (see the description below).
      </summary>
      <remarks>
        Dialog windows are windows that present a collection of controls for user I/O.  They also have a result code that indicates the result of the user-dialog interaction (for example, if the user pressed the OK or Cancel push button in the dialog).
        Most windowing systems distinguish between modal and modeless objects.  Modal objects must be acknowledged before the current thread of execution can continue; conversely, modeless objects do not affect the current execution thread.
        When a dialog box is modal, a further distinction must be made between system modal and application modal objects.  Objects that are system modal must be acknowledged before any execution in any windows created by any currently running application, including the Windows desktop, can continue.  Application modal objects, on the other hand, must be acknowledged before any execution in just the current application can continue (that is, the user can access windows created by other applications).
        By default, a dialog window is application modal.  However, it can be made modeless by assigning FALSE to the &lt;lModal&gt; flag in the DialogWindow:Init() method.  You may also just want to create a modeless dialog box.
      </remarks>
    </member>
    <member name="M:VO.DialogWindow.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a dialog window.
      </summary>
      <param name="oOwner">The window that owns the dialog window.</param>
      <param name="xResourceID">The resource ID of the desired dialog window.</param>
      <param name="lModal">TRUE creates a modal dialog window; FALSE, a modeless one.  The default is TRUE.</param>
      <remarks>
        <note type="tip">
          When creating windows without using the Window Editor there is a difference between the DialogWindow class and all other Window classes.
          With the other window classes it is possible to write code like this -
          <code language="X#">
            LOCAL oDW AS DataWindow
            oDW := DataWindow{ oOwner }
            oDW:Show( )
          </code>
          However, this code will not work -
          <code language="X#">
            LOCAL oDW AS DialogWindow
            oDW := DialogWindow{ oOwner }
            oDW:Show( )
          </code>
          It is possible to use a generated resource for a blank DialogWindow and inherit from this. The alternative is to do something like this -
          <code language="X#">
            oWin := DialogWindow{ oOwner, "IDD_DEFDLG2", TRUE }
            oWin:Size := Dimension{ 100 , 100 }
            oWin:Show( SHOWCENTERED )
          </code>
          Or
          <code language="X#">
            oWin := DialogWindow{ oOwner, "IDD_DEFDLG", FALSE }
            oWin:Size := Dimension{ 100 , 100 }
            oWin:Show( )
          </code>
          The difference between these two pieces of code is -
          <code language="X#">
            - The first uses the "IDD_DEFDLG2" resource ID and sets the modal property to TRUE. This will create a normal style dialog window and is known as a Pop-Up Dialog.
            - The second uses the "IDD_DEFDLG" resource ID and sets the modal property to FALSE. This is the style of dialog window that would be used as a Tab Page and is known as a Child Dialog.
          </code></note>
      </remarks>
    </member>
    <member name="M:VO.DialogWindow.Activate(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DialogWindow.Active">
      <inheritdoc />
    </member>
    <member name="M:VO.DialogWindow.ButtonClick(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a check box, push button, or radio button is clicked with the mouse.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlEvent">The ControlEvent object that describes which button was clicked.</param>
      <seealso cref="T:VO.ControlEvent" />
      <remarks>
        Button click events are propagated to the dialog window's owner the same way as MenuEvents.  For an in-depth discussion on command event propagation, refer to the Programmer's Guide .
        You must supply the code to turn a radio button on (and all the other radio buttons off) when a user clicks on a radio button.  Similarly, you must also be sure to invert the state of a check box when it is clicked.
      </remarks>
    </member>
    <member name="M:VO.DialogWindow.ChangeFont(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Change the font used by this dialog window.
      </summary>
      <param name="New_Font">The new font to be used.</param>
      <param name="lRescale">Specify TRUE to resize and reposition all controls in this dialog window and change their fonts; otherwise, FALSE.  If omitted, the default is FALSE.</param>
      <returns>
        The font previously assigned to the dialog window.
      </returns>
    </member>
    <member name="P:VO.DialogWindow.ClipperKeys">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DialogWindow.ControlFocusChange(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oControlFocusChangeEvent">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.DialogWindow.DeActivate(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DialogWindow.Default(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DialogWindow.Destroy">
      <summary>
        Free memory resources allocated for a dialog window and its derived objects.
      </summary>
      <remarks>
        This method immediately frees resources for DialogWindow objects created explicitly in your application.  DialogWindow:Destroy() also takes care of resources allocated to derived classes and deallocates them in the necessary order.
      </remarks>
    </member>
    <member name="M:VO.DialogWindow.EditChange(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the text in an edit control is changed.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlEvent">The ControlEvent object that describes which edit control was changed.</param>
      <seealso cref="T:VO.ControlEvent" />
    </member>
    <member name="M:VO.DialogWindow.EditFocusChange(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the input focus changes to or from an edit control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oEditFocusChangeEvent">The EditFocusChangeEvent object that identifies which edit control generated the EditFocusChangeEvent object and whether it has just gained or lost the keyboard focus.</param>
      <seealso cref="T:VO.EditFocusChangeEvent" />
      <remarks>
        If DialogWindow:EditFocusChange() is used to validate an edit control (and also return the focus to it if invalid), Control:SetFocus() should not be called until another control has received the focus.
        In complex dialog windows that contain many edit controls, it makes sense to grab the edit control's text when the focus is changing so that other controls can be updated with it if necessary.
      </remarks>
    </member>
    <member name="M:VO.DialogWindow.EndDialog(XSharp.__Usual)">
      <summary>
        Remove this dialog window from view (passing control back to the routine which created the dialog window) and post a result code indicating how it was closed.
      </summary>
      <param name="iResult">The result code that should be posted.  The default is 0.</param>
      <example>
        <note type="tip">This result code can then be passed to the routine that called the dialog window if the routine invokes DialogWindow:Result.</note>
        The following example instructs EndDialog() to return 0 if the Cancel push button is pressed and 1 if OK is pressed:
        <code language="X#">
          METHOD ButtonClick(oEvent) CLASS MyDialogWindow
          IF oEvent:nControlID == ID_OK
            SELF:EndDialog(1)
          ENDIF
          IF oEvent:nControlID == ID_CANCEL
            SELF:EndDialog(0)
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.DialogWindow.ExecModal">
      <summary>
        Allows the programmer greater control over Windows message handling in dialog windows.
      </summary>
      <remarks>
        Normally a dialog window will cause program execution to pause when the window is shown and then continue once the window is closed. The default behavior of ExecModal( ) maintains the expected behavior.
        However the programmer can create a new class which inherits from DialogWindow and implement a new ExecModal() method so as to change this behavior.
      </remarks>
      <example>
        As an example the programmer could use the following version which performs no action:
        <code language="X#">
          METHOD ExecModal() CLASS DialogWindow
             RETURN NIL
        </code>
        Now the program control comes back immediately after calling the Show() method. This is very useful for cases where your code wants to control the windows dispatcher loop with the function ApplicationExec(EXECWHILEEVENT):
        <code language="X#">
          METHOD xyz() CLASS xyz
             LOCAL oPDlg AS ProgressDialog // inherit from DialogWindow

             oPDlg := ProgressDialog{SELF, "Processing is going on!"}
             oPDlg:Count := oServer:Reccount
             oPDlg:Show()

             //ProgressDialog is modal, the user can do
            // nothing during the processing other than what
             // your code permits.
             //In this example you can abort the loop.

             oServer:GoTop()

             DO WHILE oServer:EOF
                 IF ! oPDlg:STEP()  //FALSE if abort button is pressed
                     EXIT
                 ENDIF
                 //do something
                 oServer:Skip()
             ENDDO

             oPDlg:EndDialog()
        </code></example>
    </member>
    <member name="P:VO.DialogWindow.Font">
      <summary>
        The font to be used in this dialog window.
      </summary>
      <value>The font to be used in this dialog window.</value>
    </member>
    <member name="M:VO.DialogWindow.Handle">
      <summary>
        Return the handle for a dialog window.
      </summary>
      <param name="nHandleType">The type of handle required.  Specify 0 for the window handle and 2 for the window device context.  If omitted, 0 is the default.</param>
      <returns>
        A handle to the window, describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the window, which can then be used by Windows API calls.
      </remarks>
    </member>
    <member name="M:VO.DialogWindow.HelpRequest(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oHelpRequestEvent">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.DialogWindow.HorizontalScroll(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a horizontal scroll bar is scrolled.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oScrollEvent">The ScrollEvent object that describes the scroll type and new position.</param>
      <remarks>
        The default behavior for this event handler is to update the thumb position; this can be changed using your own implementation of the handler.  This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects.  If the application has vertical scroll bars, use a WindowVerticalScrollBar event handler.
      </remarks>
    </member>
    <member name="P:VO.DialogWindow.IsModal">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.DialogWindow.LastFocus">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DialogWindow.ListBoxClick(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when an item in a list box owned by this dialog window is double-clicked.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlEvent">The ControlEvent object that describes which list box contained the item that is double-clicked.</param>
      <seealso cref="T:VO.ControlEvent" />
    </member>
    <member name="M:VO.DialogWindow.ListBoxSelect(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when an item in a list box owned by this window is clicked.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlEvent">The ControlEvent object that describes which list box contained the item that was clicked.</param>
      <seealso cref="T:VO.ControlEvent" />
    </member>
    <member name="P:VO.DialogWindow.Owner">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DialogWindow.PostShowDialog">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.DialogWindow.Result">
      <summary>
        A numeric result code posted by the DialogWindow:EndDialog() method returned to the system when this dialog window was closed.
      </summary>
      <value>A numeric result code posted by the DialogWindow:EndDialog() method returned to the system when this dialog window was closed.</value>
      <remarks>
        A numeric result code posted by the DialogWindow:EndDialog() method returned to the system when this dialog window was closed.  (For example, it may have posted a 0 if the Cancel push button was pressed or a 1 if OK was pressed.)
        <note type="tip">DialogWindow:Result should be invoked by the owner's method that showed the dialog window to determine the action that closed the dialog window.</note></remarks>
    </member>
    <member name="M:VO.DialogWindow.Show(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DialogWindow.ShowModal(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="lActive">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.DialogWindow.StatusMessage(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Display a message in the status bar of the shell window.
      </summary>
      <param name="oHyperLabel">The hyperlabel containing a description (HyperLabel:Description) for the status message.</param>
      <param name="kMessageType">The constant value indicating the type and priority of the message to be displayed on the status bar. See the remarks section for more information.</param>
      <remarks>
        <list type="table">
           The highest priority message (MESSAGEMENU) always takes precedence over and replaces lower priority messages.
          <listheader><term>Constant</term><description>Description</description></listheader><item><term>MESSAGEMENU</term><description>Priority 4 (Highest priority):  A message associated with a menu selection.</description></item><item><term>MESSAGEERROR</term><description>Priority 3:  An error message.</description></item><item><term>MESSAGECONTROL</term><description>Priority 2:  A message associated with a control.</description></item><item><term>MESSAGEPERMANENT</term><description>
              Priority 1 (Lowest priority):  The default message displayed on the status bar; stored whenever a higher
              priority message takes precedence and redisplayed when no other messages take priority.  This is the <b>default</b>.
            </description></item></list>
      </remarks>
    </member>
    <member name="M:VO.DialogWindow.VerticalScroll(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a vertical scroll bar is scrolled.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oScrollEvent">The ScrollEvent object that describes the scroll type and new position.</param>
      <remarks>
        The default behavior for this event handler is to update the thumb position; this can be changed using your own implementation of the handler.  This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects.  If the application has horizontal scroll bars, use a HorizontalScrollBar event handler.
      </remarks>
    </member>
    <member name="T:VO.Dimension">
      <summary>
        Create a Dimension object, which is used to describe the size of two-dimensional objects using ordered pair coordinates (width, height or x, y).
      </summary>
      <remarks>
        <note type="tip">When a dimension is used to describe irregularly-shaped objects, it specifies the size of the smallest bounding box that can fully enclose the object.</note>
      </remarks>
    </member>
    <member name="M:VO.Dimension.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a dimension.
      </summary>
      <param name="nWidth">The width of the dimension  The default is 0, inherited from CLASS Pair.</param>
      <param name="nHeight">The height of the dimension.  The default is 0, inherited from CLASS Pair.</param>
    </member>
    <member name="P:VO.Dimension.Height">
      <summary>
        A numeric value representing this dimension's height.
      </summary>
      <value>A numeric value representing this dimension's height.</value>
    </member>
    <member name="P:VO.Dimension.Width">
      <summary>
        A numeric value representing this dimension's width.
      </summary>
      <value>A numeric value representing this dimension's width.</value>
    </member>
    <member name="T:VO.DragDropClient">
      <summary>
        Create the client for use in a drag-and-drop operation.
      </summary>
      <remarks>
        In Windows, "drag-and-drop" is a technique by which users can move files from one location to another, either visually (using the mouse) or through another system-accepted method.  The client in a drag-and-drop operation is a utility object with an associated owner window that accepts dropped files.
        Creating a drag-and-drop client automatically makes its owner window capable of accepting drag-and-drop loads.  The event handlers in the drag-and-drop client handle the events relevant to the drag-and-drop operation.
        <br />Important!  When you call Window:EnableDragDropClient(TRUE), the window becomes a DragDropClient and inherits all the methods of DragDropClient.  The callback methods DragLeave(), DragOver(), and Drop() are called on the Window object when a DragLeave, DragOver, or Drop event occurs (see the example below.)
      </remarks>
      <example>
        The following example demonstrates the use of the DragDropClient class:
        <code language="X#">
          METHOD Init(oOwner) CLASS StandardShellWindow
          SUPER:Init(oOwner)
          SELF:Size := Dimension{300,100}
          SELF:Origin:= Point{0,20}
          SELF:Caption := "Non-MDI ChildWindow"
          SELF:EnableMinBox()
          SELF:EnableMaxBox()
          SELF:EnableSystemMenu
          SELF:EnableBorder()
          SELF:EnableDragDropClient()	// Make the window a DragDropClient
          SELF:Show()
          METHOD DragOver(oDragEvent) CLASS StandardShellWindow
          LOCAL iCount AS INT
          LOCAL iAcceptDrop AS LOGIC
          // Check files that are being dragged over the window
          // Only accept if all files are .DBF
          lAcceptDrop := TRUE
          FOR iCount := 1 TO oDragEvent:FileCount
          IF RAT(".DBF", oDragEvent:FileName(iCount)) == 0
          lAcceptDrop := FALSE
          EXIT
          ENDIF
          NEXT
          RETURN lAcceptDrop
          METHOD DragLeave() CLASS StandardShellWindow
          // Undo any actions taken during drag-drop attempt
          METHOD Drop(oDragEvent) CLASS StandardShellWindow
          LOCAL nNumFiles := oDragEvent:FileCount
          // Number of entries dropped
          LOCAL nFile AS INT
          // For each item that is dropped, if it is a file, open it.
          FOR nFile := 1 TO nNumFiles
          IF File(oDragEvent:FileName(nFile))
          SELF:DoOpenFile(oDragEvent:FileName(nFile))
          ENDIF
          NEXT
        </code></example>
    </member>
    <member name="M:VO.DragDropClient.#ctor(XSharp.__Usual)">
      <summary>
        Construct a drag-and-drop client.
        <br />Important!  Normally, this method should not be called in your application code.  Instead use Window:EnableDragDropClient(TRUE) to create a drag-and-drop client.
      </summary>
      <param name="oOwner">The window that owns this drag-and-drop client.</param>
    </member>
    <member name="M:VO.DragDropClient.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DragDropClient.Dispatch(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.DragDropClient.DragLeave(XSharp.__Usual)">
      <summary>
        Notify the application that the mouse has left the client area of the window that owns the drag-and-drop client.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oEvent">An empty event maintaining the protocol requirement that an event handler has exactly one event as its argument.</param>
      <seealso cref="T:VO.Event" />
      <remarks>
        The system dispatches this method when, during an apparent drag-and-drop operation (that is, DragDropClient:DragOver() returns TRUE), the mouse leaves the client area of the window that owns the drag-and-drop client.  This means that the user has thought better of performing the operation.  Your implementation of DragLeave() should undo any actions taken during the drag-and-drop attempt, in case the user was simply en route to some other client.
      </remarks>
    </member>
    <member name="M:VO.DragDropClient.DragOver(XSharp.__Usual)">
      <summary>
        Notify the application of a DragOver event and accept or reject the drop.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oDragEvent">The drag event that determines the position of the mouse (in canvas coordinates), as well as the number and names of files, in the drag-and-drop load.</param>
      <returns>
        The client can refuse a drag-and-drop operation by returning FALSE from this method (usually because a certain file type is not accepted).  Windows then changes the pointer to a no-entry sign.  The method returns TRUE if a drop is accepted.
      </returns>
      <remarks>
        The system dispatches this method when, during a drag-and-drop operation, the mouse drags inside the client area of the drag-and-drop client.  Several drag events can arrive at DragDropClient:DragOver() during the one operation, before the user finally drops the load or leaves the client area.  Windows displays a special pointer to give the user visual feedback on the progress of the operation.
      </remarks>
    </member>
    <member name="M:VO.DragDropClient.Drop(XSharp.__Usual)">
      <summary>
        Retrieve information about a load from the drag event and act on each file in the selection.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oDragEvent">The drag event that determines the position of the mouse (in canvas coordinates), as well as the number and names of files, in the drag-and-drop load.</param>
      <remarks>
        The system dispatches this method when the user lets go of the mouse button to drop the load in the client area.  This method is required to handle drag-and-drop correctly.  It retrieves information about the load from the drag event and acts on each file in the selection.  If the drag-and-drop client is a shell window, it might open a data browser for each file in the selection.
      </remarks>
    </member>
    <member name="P:VO.DragDropClient.Owner">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.DragDropServer">
      <summary>
        Create the server for use in a drag-and-drop operation.
      </summary>
      <remarks>
        In Windows, "drag-and-drop" is a technique by which users can move files from one location to another, either visually (using the mouse) or through another system-accepted method.  The server in a drag-and-drop operation is the source of the drag-and-drop operation.
        The user normally uses the mouse to select a group of files to drag (however, the application can choose any reasonable metaphor for selection). After selection, the application creates a drag-and-drop load by storing the file names in an array; it then calls the DragDropServer:StartDrag() method.
        When you call Window:EnableDragDropServer(TRUE), the window becomes a DragDropServer.  The DragDropServer is a property in the Window and is called Window:DragDropServer.
      </remarks>
    </member>
    <member name="M:VO.DragDropServer.#ctor(XSharp.__Usual)">
      <summary>
        Construct a drag-and-drop server.
        <br />Important!  Normally, this method should not be called in your application code.  Instead use Window:EnableDragDropServer(TRUE) to make the window a drag-and-drop server.
      </summary>
      <param name="oOwner">The window that owns this drag-and-drop server.</param>
      <remarks>
        Once defined as a server, the GUI recognizes it as a possible source of drag-and-drop operations.
      </remarks>
    </member>
    <member name="M:VO.DragDropServer.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.DragDropServer.StartDrag(XSharp.__Usual)">
      <summary>
        Notify the GUI that a drag-and-drop operation has started.
      </summary>
      <param name="acFilesToDrag">An array of file names to drag.</param>
      <returns>
        TRUE if the drop was successful; otherwise, FALSE (for example, if the user dropped the files on a non-drag-and-drop client).
      </returns>
      <remarks>
        This method is called when the user starts the drag operation, usually by dragging the mouse.  DragDropServer:StartDrag() is modal; once it is called, control is only returned to the program when the user has dropped the files.
      </remarks>
      <example>
        The following example demonstrates how to use the DragDropServer:StartDrag() method:
        <code language="X#">
          CLASS MyChildWindow INHERIT ChildAppWindow
          HIDDEN aDragList AS ARRAY
          METHOD Init(oOwner) CLASS MyChildAppWindow
          SUPER:Init(oOwner)
          EnableDragDropServer(TRUE)			// Make Window
          // a DragDropServer
          METHOD MouseDrag(oEvent) CLASS MyChildWindow
          LOCAL ListLength AS INT
          LOCAL lResult	 AS LOGIC
          ListLength := ALen(aDragList)
          // aDragList is already filled with list of file names
          IF ListLength &gt; 0 		// if there are files to drag
          lResult := SELF:DragDropServer:StartDrag(aDragList)
          ENDIF
        </code></example>
    </member>
    <member name="T:VO.DragEvent">
      <summary>
        Provide information about a drag event, which enables the drag-and-drop client (the receiving window) to track the progress of the mouse during the drag operation and to identify the files that the user can drop.
      </summary>
      <remarks>
        Drag-and-drop is a GUI convention for moving objects from one place to another.  In Windows, the convention only supports files.  A drag event occurs when the user drags a group of previously selected files to a new location.  Drag events occur in the target window where the selection will be dropped (not in the window where the selection was made).
        <note type="tip">Drag events do not occur in the drag-and-drop server (the source of the files) — only in the drag-and-drop client (the target).  When the drag enters the client area, the drag event goes to the DragDropClient:DragOver() method of the client.  If the drag leaves the client without dropping its files, and the drag-and-drop client has returned TRUE to the DragOver() method, a generic event goes to DragDropClient:DragLeave().  It is then no longer relevant or correct for the application to query the event if it is leaving the client.  If the user drops the files, the drag event goes to DragDropClient:Drop().</note></remarks>
    </member>
    <member name="M:VO.DragEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.DragEvent.Control">
      <summary>
        A control object returning the control whenever a drop-and-drag event has occurred inside a control with WS_EX_ACCEPTFILES set.  If WS_EX_ACCEPTFILES is TRUE, the control accepts files and triggers a call to its parent Drop() method.
      </summary>
      <value>A control object returning the control whenever a drop-and-drag event has occurred inside a control with WS_EX_ACCEPTFILES set.  If WS_EX_ACCEPTFILES is TRUE, the control accepts files and triggers a call to its parent Drop() method.</value>
    </member>
    <member name="P:VO.DragEvent.FileCount">
      <summary>
        A numeric value representing the number of files in the drag-and-drop load that generated this drag event.
      </summary>
      <value>A numeric value representing the number of files in the drag-and-drop load that generated this drag event.</value>
    </member>
    <member name="M:VO.DragEvent.FileName(XSharp.__Usual)">
      <summary>
        Return the name of a specified file in the drag-and-drop load that generated this drag event.
      </summary>
      <param name="nfile">The position of the desired file in the drag-and-drop load array; file numbers in this array start at 1 (see DragEvent:FileCount).</param>
    </member>
    <member name="P:VO.DragEvent.Origin">
      <summary>
        A point representing the location of the mouse in canvas coordinates at the time this drag event was generated.
      </summary>
      <value>A point representing the location of the mouse in canvas coordinates at the time this drag event was generated.</value>
    </member>
    <member name="T:VO.DrawObject">
      <summary>
        Provide the base class from which all X# DrawObject objects are subclassed.
      </summary>
      <remarks>
        The DrawObject class provides a protocol for drawable objects (for example, the Window class invokes DrawObject's methods to manage a drawable object).  This protocol provides a means to maintain arrays of drawing objects for subsequent display on a window.
        Each object in the DrawObject hierarchy should provide both a BoundingBox property (to identify the smallest area that can enclose the drawing object) and a Draw() method (to specify how the object is to be drawn).  When the application is finished with the object, it must be explicitly destroyed using the Destroy() method.
      </remarks>
    </member>
    <member name="M:VO.DrawObject.#ctor(XSharp.__Usual)">
      <summary>
        Construct a DrawObject object.
      </summary>
      <param name="oPoint">The origin of the DrawObject object in canvas coordinates.</param>
    </member>
    <member name="P:VO.DrawObject.BoundingBox">
      <summary>
        A bounding box representing the smallest rectangle (in the owner window's canvas coordinates) which encloses this DrawObject object.
      </summary>
      <value>A bounding box representing the smallest rectangle (in the owner window's canvas coordinates) which encloses this DrawObject object.</value>
    </member>
    <member name="M:VO.DrawObject.Destroy">
      <summary>
        Provide a method to de-instantiate a DrawObject object.
      </summary>
      <remarks>
        DrawObject:Destroy() de-instantiates the DrawObject object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.  When the application is finished with the object, it must be explicitly destroyed using this method.
      </remarks>
    </member>
    <member name="M:VO.DrawObject.Draw">
      <summary>
        Display a DrawObject object.
      </summary>
      <remarks>
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called by your application code.
        <note type="tip">The default implementation of the DrawObject:Draw() method has no effect.  You should derive your class from DrawObject and overload the Draw() method to contain the code to draw the new object. This method can then be called by Window:Draw().</note>
        To display a DrawObject object, call Window:Draw() with the DrawObject object as its argument.  The window does the drawing by asking each object to draw itself — for example:
        <code language="X#">
          METHOD Expose(oEvent) CLASS MyWindow
          LOCAL oEllipse AS ELLIPSEOBJECT
          oEllipse := EllipseObject{Point{10,10},;
          Dimension{50,100}}
          SELF:Draw(oEllipse)
          // Calls the method Draw() on oEllipse
        </code></remarks>
    </member>
    <member name="M:VO.DrawObject.Handle(XSharp.__Usual)">
      <summary>
        Return the handle for a DrawObject object.
      </summary>
      <param name="nHandleType">The type of handle required.  0 is the only supported option and is the default if &lt;nHandleType&gt; is omitted.</param>
      <returns>
        A handle to the device context for the window on which the object is to be drawn.  X# will release this handle when necessary.  You should not save it to a variable.
      </returns>
      <remarks>
        <note type="tip">This method only has an effect in an overridden DrawObject:Draw() method.</note>
      </remarks>
    </member>
    <member name="M:VO.DrawObject.HitTest(XSharp.__Usual)">
      <summary>
        Determine if a given point lies within the bounding box of a DrawObject object.
      </summary>
      <param name="oPoint">The point to test for inclusion.</param>
      <returns>
        TRUE if the point lies within the bounding box of the DrawObject object; otherwise, FALSE.
      </returns>
      <remarks>
        This method should be provided by objects in classes subclassed from DrawObject, when behavior other than the default behavior is required.
        When HitTest() is invoked, it does the following by default:
        <code language="X#">RETURN(SELF:BoundingBox()):PtInRect(oPoint)</code></remarks>
    </member>
    <member name="P:VO.DrawObject.Origin">
      <summary>
        A point representing the origin of this DrawObject object in canvas coordinates.
      </summary>
      <value>A point representing the origin of this DrawObject object in canvas coordinates.</value>
    </member>
    <member name="P:VO.DrawObject.RasterOperation">
      <summary>
        A constant, indicating the raster operation in use for this DrawObject object:
      </summary>
      <value>A constant, indicating the raster operation in use for this DrawObject object:</value>
      <remarks>
        One of the following constants, indicating the raster operation in use for this DrawObject object:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>ROPBACKGROUND</term><description>Draw this object using the background color of the window.</description></item><item><term>ROPINVERT</term><description>Invert the object currently displayed.  This operation can be used for elastic banding, moving objects, and so forth.</description></item><item><term>ROPOVERWRITE</term><description>
              Overwrite the current display.  This is the <b>default</b>.
            </description></item><item><term>ROPXOR</term><description>Exclusive OR with the current window contents.</description></item></list>
        This property allows you to specify how the drawing affects whatever is already on the window.  The XOR operation, for example, is useful for temporary drawings you want to be able to remove, restoring the original image.
      </remarks>
    </member>
    <member name="P:VO.DrawObject.Size">
      <summary>
        A dimension representing the size of this DrawObject object.
      </summary>
      <value>A dimension representing the size of this DrawObject object.</value>
    </member>
    <member name="T:VO.Edit">
      <summary>
        Provide the base class from which all X# edit controls are subclassed.
      </summary>
      <remarks>
        The Edit class provides simple text editing facilities for entering, deleting, and selecting text.  In addition, you can specify if edit controls are to have a border, whether they should be read-only, or perhaps whether they should be password protected.
        Edit controls in this class hierarchy treat the text they contain as a series of numbered characters.  In these edit controls, a selection is an ordered pair of character numbers.  For example, if an edit control contains the text "samarkand," the selection (3,7) would select the text "mark."
        Also, for each control, the text limit is the maximum number of characters you wish the edit to hold.
        The non-graphic characters for newline (Chr(10)), tab (Chr(9)), and null (Chr(0)) occupy one character position.
      </remarks>
    </member>
    <member name="M:VO.Edit.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct an edit control.
      </summary>
      <param name="oOwner">The window that owns the edit control.</param>
      <param name="xID">The ID of the edit control.</param>
      <param name="oPoint">The origin of the edit control in canvas coordinates.</param>
      <param name="oDimension">The dimension of the edit control in canvas coordinates.</param>
      <param name="kStyle">The style of the edit control, specified as one of the following constants:</param>
      <param name="nResourceID">The resource ID of the edit control.</param>
      <remarks>
        Constant	Windows API Constant
        EDITAUTOHSCROLL	ES_AUTOHSCROLL
        EDITAUTOVSCROLL	ES_AUTOVSCROLL
        EDITBORDERED	WS_BORDER
        EDITCENTER	ES_CENTER
        EDITLEFT	ES_LEFT
        EDITLOWERCASE	ES_LOWERCASE
        EDITMULTILINE	ES_MULTILINE
        EDITNOHIDESEL	ES_NOHIDESEL
        EDITOEMCONVERT	ES_OEMCONVERT
        EDITPASSWORD	ES_PASSWORD
        EDITREADONLY	ES_READONLY
        EDITRIGHT	ES_RIGHT
        EDITUPPERCASE	ES_UPPERCASE
        EDITWANTRETURN	ES_WANTRETURN
      </remarks>
    </member>
    <member name="M:VO.Edit.CanUndo">
      <summary>
        Determine if the Edit:Undo() method can be called for this edit control.
      </summary>
      <returns>
        TRUE if Edit:Undo() can be invoked; otherwise, FALSE.
      </returns>
      <remarks>
        This method is often used to modify Undo menu commands to reflect the state of the different possibilities.
      </remarks>
    </member>
    <member name="P:VO.Edit.Caption">
      <summary>
        Caption text is not displayed for single-line or multiline edit controls.  It can be used to store general text information.
      </summary>
      <value>Caption text is not displayed for single-line or multiline edit controls.  It can be used to store general text information.</value>
    </member>
    <member name="M:VO.Edit.Clear">
      <summary>
        Delete the current selection in this edit control.
      </summary>
      <remarks>
        If the current selection refers to a cursor position (for example, {5,5}), no text is deleted.
      </remarks>
    </member>
    <member name="M:VO.Edit.Copy">
      <summary>
        Copy the current selection in this edit control to the clipboard.
      </summary>
      <remarks>
        If the current selection refers to a cursor position (for example, {5,5}), no text is copied.
      </remarks>
    </member>
    <member name="M:VO.Edit.Cut">
      <summary>
        Delete the current selection in this edit control and copy it to the clipboard.
      </summary>
      <remarks>
        If the current selection refers to a cursor position (for example, {5,5}), no text is deleted.
      </remarks>
    </member>
    <member name="M:VO.Edit.Font(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oNewFont">** missing parameter documentation **</param>
      <param name="lRescal">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.Edit.IsPassword">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Edit.Margins">
      <summary>
        A Dimension object specifying the left and right margins of the edit control.
      </summary>
      <value>A Dimension object specifying the left and right margins of the edit control.</value>
    </member>
    <member name="P:VO.Edit.Modified">
      <summary>
        A logical value indicating whether an editable control is in the process of being modified.
      </summary>
      <value>A logical value indicating whether an editable control is in the process of being modified.</value>
      <remarks>
        A logical value indicating whether an editable control is in the process of being modified.  While you are editing the text, it is set to TRUE.  When the edit is completed and focus shifts to another control, Edit:Modified is reset to FALSE.
      </remarks>
    </member>
    <member name="M:VO.Edit.Paste(XSharp.__Usual)">
      <summary>
        Replace the current selection in this edit control with a string, if specified, or the contents of the clipboard.
      </summary>
      <param name="cNewString">The text to be placed in the edit control.  If not specified, the contents of the clipboard is used.</param>
      <remarks>
        If the current selection refers to a cursor position (for example, {5,5}), the text is inserted at that point and no text is deleted.
      </remarks>
    </member>
    <member name="P:VO.Edit.ReadOnly">
      <summary>
        A logical value specifying the read-only state of an edit control.
      </summary>
      <value>A logical value specifying the read-only state of an edit control.</value>
      <remarks>
        A logical value specifying the read-only state of an edit control.  
        This property allows you to change the read-only state at runtime.  
        Note that changing the ReadOnly style via Edit:SetStyle(ES_READONLY) is not respected by the edit control at runtime.
      </remarks>
    </member>
    <member name="M:VO.Edit.SelectAll">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Edit.SelectedText">
      <summary>
        A string representing the text that is currently selected in this edit control.
      </summary>
      <value>A string representing the text that is currently selected in this edit control.</value>
    </member>
    <member name="P:VO.Edit.Selection">
      <summary>
        The position of the cursor in the edit control.
      </summary>
      <value>The position of the cursor in the edit control.</value>
      <remarks>
        The position of the cursor in the edit control.  For example, a Selection of {5,10} means the text from position 5 through 9 inclusive is selected, while a Selection of {5,5} means the cursor is positioned in front of the fifth character.
      </remarks>
    </member>
    <member name="M:VO.Edit.SelectNone">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.Edit.SetSelectionFocus">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Edit.TextLimit">
      <summary>
        A numeric value representing the maximum number of characters this edit control can hold.
      </summary>
      <value>A numeric value representing the maximum number of characters this edit control can hold.</value>
      <remarks>
        A numeric value representing the maximum number of characters this edit control can hold.  A value of 0 indicates that there is no limit being imposed.  If the limit specified is less than the size of the text already in the buffer, the existing text is truncated.
      </remarks>
    </member>
    <member name="P:VO.Edit.TextValue">
      <summary>
        A string representing the value held in the control.
      </summary>
      <value>A string representing the value held in the control.</value>
      <remarks>
        A string representing the value held in the control.  For example, in a standard edit control, the value can be "Jones" or "$14,683.00".  The Edit:TextValue assign also changes the Edit:CurrentText and Edit:Value.
        Note that the string is formatted according to the picture clause held in the field specification of the edit field; in turn, edit fields linked to a data server inherit the field specification — and hence picture — from the field of the server.
      </remarks>
    </member>
    <member name="M:VO.Edit.Undo">
      <summary>
        Undo the last modification to the text in this edit control.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method only undoes the last change — undos are not nested.
      </remarks>
    </member>
    <member name="P:VO.Edit.Value">
      <summary>
        Edit:Value contains the text after the previous edit operation.  The Edit:TextValue assign also changes the Edit:CurrentText and Edit:TextValue.  For non-editable controls (fixed icon, fixed text, group box), Edit:Value is set to NULL_STRING.
      </summary>
      <value>Edit:Value contains the text after the previous edit operation.  The Edit:TextValue assign also changes the Edit:CurrentText and Edit:TextValue.  For non-editable controls (fixed icon, fixed text, group box), Edit:Value is set to NULL_STRING.</value>
    </member>
    <member name="T:VO.EditFocusChangeEvent">
      <summary>
        Provide information about an EditFocusChangeEvent, generated when an edit control (i.e., SingleLineEdit, MultiLineEdit, or EditWindow) gains or loses the keyboard focus.
      </summary>
    </member>
    <member name="M:VO.EditFocusChangeEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.EditFocusChangeEvent.GotFocus">
      <summary>
        A logical value representing whether an edit control has either just gained keyboard focus (TRUE) or has just lost it (FALSE).
      </summary>
      <value>A logical value representing whether an edit control has either just gained keyboard focus (TRUE) or has just lost it (FALSE).</value>
    </member>
    <member name="P:VO.EditFocusChangeEvent.HyperLabel">
      <summary>
        The Hyperlabel connected to the edit control focus change event.  From the hyperlabel, you can retrieve additional information about the edit control focus change event — for example:
        <code language="X#">
          cCaption := oEditFocusChangeEvent:HyperLabel:Caption
          cDescription := oEditFocusChangeEvent:HyperLabel:Description
          cHelpContext := oEditFocusChangeEvent:HyperLabel:HelpContext
        </code></summary>
      <value>
        The Hyperlabel connected to the edit control focus change event.  From the hyperlabel, you can retrieve additional information about the edit control focus change event — for example:

        cCaption := oEditFocusChangeEvent:HyperLabel:Caption
        cDescription := oEditFocusChangeEvent:HyperLabel:Description
        cHelpContext := oEditFocusChangeEvent:HyperLabel:HelpContext
      </value>
    </member>
    <member name="T:VO.EditWindow">
      <summary>
        Create an edit control as part of the Window hierarchy, thereby allowing the behavior of the edit control to be customized using event handlers.
      </summary>
      <remarks>
        When an edit control is created as part of the Window hierarchy, it can trap events.  For example, you might want to customize the appearance of edit controls (like changing the background and foreground colors) or modify their default key handling.
        Manipulating a control via the ControlWindow class requires more overhead than those created by the subclasses of Control.  Therefore, it is recommended that control windows be used only where special handling is needed (for example, to override the handling of certain events or call some window method on a control).
      </remarks>
    </member>
    <member name="M:VO.EditWindow.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Create an edit window.
      </summary>
      <param name="oOwner">The window that owns the edit window.</param>
      <param name="xID">The ID of the edit window.</param>
      <param name="oPoint">The origin of the edit window in canvas coordinates.</param>
      <param name="oDimension">The dimension of the edit window in canvas coordinates.</param>
      <param name="nResourceID">The resource ID of the edit window.</param>
    </member>
    <member name="M:VO.EditWindow.AsString">
      <summary>
        Return the contents of the edit window.
      </summary>
      <remarks>
        This method returns the same as EditWindow:TextValue.  EditWindow:AsString() presents the edit window as a recognizable string.
      </remarks>
    </member>
    <member name="M:VO.EditWindow.Clear">
      <summary>
        Delete the current selection in this edit window.
      </summary>
      <remarks>
        If the current selection refers to a cursor position (for example, {5,5}), no text is deleted.
      </remarks>
    </member>
    <member name="P:VO.EditWindow.Control">
      <summary>
        This property is inherited from the ControlWindow class but does not apply to EditWindow.  It returns NULL_OBJECT.
      </summary>
      <value>This property is inherited from the ControlWindow class but does not apply to EditWindow.  It returns NULL_OBJECT.</value>
    </member>
    <member name="P:VO.EditWindow.ControlID">
      <summary>
        This property is inherited from the EditControl class but does not apply to EditWindow.  Its return value is NIL.
      </summary>
      <value>This property is inherited from the EditControl class but does not apply to EditWindow.  Its return value is NIL.</value>
    </member>
    <member name="M:VO.EditWindow.Copy">
      <summary>
        Copy the text that is currently selected in an edit window to the clipboard.
      </summary>
      <remarks>
        If the current selection refers to a cursor position (for example, {5,5}), no text is copied.
      </remarks>
    </member>
    <member name="M:VO.EditWindow.Cut">
      <summary>
        Delete the text that is currently selected in an edit window and copy it to the clipboard.
      </summary>
      <remarks>
        If the current selection refers to a cursor position (for example, {5,5}), no text is deleted.
      </remarks>
    </member>
    <member name="M:VO.EditWindow.Destroy">
      <summary>
        Free memory resources allocated for a EditWindow object and its derived objects.
      </summary>
      <remarks>
        This method immediately frees resources for EditWindow objects created explicitly in your application.
        EditWindow:Destroy() also takes care of resources allocated to derived classes and deallocates them in the necessary order.
      </remarks>
    </member>
    <member name="M:VO.EditWindow.GetLine(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Get a specified line of text in this edit window.
      </summary>
      <param name="nLineNumber">The position of the desired line in the edit window.  Specify one of the following values:</param>
      <param name="Value">Position</param>
      <param name="0">The current line in the edit window (that is, the line currently containing the text cursor).  This is the default.</param>
      <param name="1">The first line in the edit window.</param>
      <param name="n">The nth line in the edit window.</param>
      <param name="nMaxLength">The maximum length that you expect the string to be in any language.  If not specified, the system substitutes 255.  If it is set too low, Windows truncates the resource string.</param>
      <returns>
        The text of the specified line.
      </returns>
    </member>
    <member name="P:VO.EditWindow.Length">
      <summary>
        A numeric value representing the number of characters in this edit window.
      </summary>
      <value>A numeric value representing the number of characters in this edit window.</value>
    </member>
    <member name="P:VO.EditWindow.LineCount">
      <summary>
        A numeric value representing the number of text lines in this edit window.
      </summary>
      <value>A numeric value representing the number of text lines in this edit window.</value>
    </member>
    <member name="M:VO.EditWindow.LineDown">
      <summary>
        Scroll the text in this edit window down by a single line.
      </summary>
    </member>
    <member name="M:VO.EditWindow.LineUp">
      <summary>
        Scroll the text in this edit window up by a single line.
      </summary>
    </member>
    <member name="M:VO.EditWindow.PageDown">
      <summary>
        Scroll the text in this edit window down by a single page.
      </summary>
      <remarks>
        A page is the number of lines that fits in the current edit window in the current font.
      </remarks>
    </member>
    <member name="M:VO.EditWindow.PageUp">
      <summary>
        Scroll the text in this edit window up by a single page.
      </summary>
      <remarks>
        A page is the number of lines that fits in the current edit window in the current font.
      </remarks>
    </member>
    <member name="M:VO.EditWindow.Paste(XSharp.__Usual)">
      <summary>
        Replace the text that is currently selected in an edit window with the contents of the clipboard.
      </summary>
      <param name="cNewString">The text to be placed in the edit window.  If not specified, the contents of the clipboard is used.</param>
      <remarks>
        If the current selection refers to a cursor position (for example, {5,5}), the text is inserted at that point and no text is deleted.
      </remarks>
    </member>
    <member name="M:VO.EditWindow.ScrollHorizontal(XSharp.__Usual)">
      <summary>
        Scroll the current line in this edit window a specified number of characters to the right or left.
      </summary>
      <param name="nChars">The number of characters to scroll.  Positive values scroll to the right; negative values to the left.</param>
    </member>
    <member name="M:VO.EditWindow.ScrollVertical(XSharp.__Usual)">
      <summary>
        Scroll the current line in this edit window up or down a specified number of lines.
      </summary>
      <param name="nLines">The number of lines to scroll.  Positive values scroll up; negative values down.</param>
    </member>
    <member name="P:VO.EditWindow.Selection">
      <summary>
        A Selection object, representing the currently selected text in the edit window.
      </summary>
      <value>A Selection object, representing the currently selected text in the edit window.</value>
      <remarks>
        A Selection object, representing the currently selected text in the edit window.
        For example, a Selection value of {5,10} means the text from position 5 through 9 inclusive is selected, while a Selection value of {5,5} means the cursor is positioned in front of the fifth character.
      </remarks>
    </member>
    <member name="P:VO.EditWindow.TextLimit">
      <summary>
        A numeric value representing the maximum number of characters the edit window can hold.
      </summary>
      <value>A numeric value representing the maximum number of characters the edit window can hold.</value>
      <remarks>
        A numeric value representing the maximum number of characters the edit window can hold.  A value of 0 indicates that there is no limit being imposed.  If the limit specified is less than the size of the text already in the buffer, the existing text is truncated.
      </remarks>
    </member>
    <member name="P:VO.EditWindow.TextValue">
      <summary>
        A string representing the value held in the edit window.
      </summary>
      <value>A string representing the value held in the edit window.</value>
      <remarks>
        A string representing the value held in the edit window.  For example, the value can be "Jones" or "$14,683.00".
      </remarks>
    </member>
    <member name="M:VO.EditWindow.Undo">
      <summary>
        Undo the last modification to the text in this edit window.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method only undoes the last change — undos are not nested.
      </remarks>
    </member>
    <member name="P:VO.EditWindow.Value">
      <summary>
        The value held in the edit field in whatever data type the edit window holds.
      </summary>
      <value>The value held in the edit field in whatever data type the edit window holds.</value>
      <remarks>
        The value held in the edit field in whatever data type the edit window holds.  For example, the value can be the string "Jones" or the number 14683.
        The data type of the edit window is determined by its field specification; in turn, edit windows linked to a data server inherit the field specification — and hence data type — from the field of the server.
      </remarks>
    </member>
    <member name="T:VO.EllipseObject">
      <summary>
        Create an EllipseObject object; this type of entity is part of the DrawObject hierarchy, which provides a means of displaying and manipulating various objects.
      </summary>
      <example>
        To draw an EllipseObject object, call Window:Draw() with the EllipseObject object as its argument.  The window does the drawing by asking each object to draw itself — for example:
        <code language="X#">
          METHOD Expose(oEvent) CLASS MyWindow
          LOCAL oEllipse AS OBJECT
          oEllipse := EllipseObject{Point{10,10},;
          Dimension{20,40}}
          SELF:Draw(oEllipse)
        </code></example>
    </member>
    <member name="M:VO.EllipseObject.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct an EllipseObject object.
      </summary>
      <param name="oPoint">The position of the EllipseObject object in canvas coordinates.</param>
      <param name="oDimension">The dimension of the EllipseObject object in canvas coordinates.</param>
      <param name="oPen">The pen used to draw the EllipseObject object.  By default, the current pen is used.</param>
      <param name="oBrush">The brush used to fill the EllipseObject object.  By default, the current brush is used.</param>
    </member>
    <member name="M:VO.EllipseObject.Draw">
      <summary>
        Draw this EllipseObject object.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <remarks>
        This method should not be invoked directly in the application code — it is invoked in X# by Window:Draw().  Refer to the EllipseObject class description for an example using the Draw() method.
      </remarks>
    </member>
    <member name="T:VO.Error">
      <summary>
        Create an Error object, which contains information about runtime errors.
      </summary>
      <remarks>
        An Error object is a simple object that contains information pertaining to a runtime error.  Error objects have no methods, only exported instance variables.
        When a runtime error occurs, X# creates a new Error object and passes it as an argument to the error handler block specified with the ErrorBlock() function.  Within the error handler, the Error object can then be queried to determine the nature of the error condition.
        Error objects can also be returned to the RECOVER statement of a BEGIN SEQUENCE construct with a BREAK statement.  Similarly, Error objects are also be passed to error methods of DataServer or DataWindow objects.  Here, the Error object can be queried for local error handling.  For more detailed information and examples, see "Error and Exception Handling" in the Programmer's Guide.
      </remarks>
    </member>
    <member name="T:VO.ErrorBox">
      <summary>
        Present the user with an error message box.
      </summary>
      <remarks>
        An error message box is a window that contains the text "Error" in the title bar, the text of the message, and a warning icon.
        Error boxes are application modal — the user must acknowledge them before continuing with the application.  When the error box closes, focus is returned to its owner window.
      </remarks>
      <example>
        The following example creates and shows an error message box (whose owner is oMyWin) that displays the text "Oops, We have an error!" to the user:
        <code language="X#">
          METHOD Start() CLASS App
          oMyWin := TopAppWindow{}
          oMyWin:Show()
          oErrBox := ErrorBox{oMyWin,;
          "Oops, We have an error!"}
          oErrBox:Show()
          SELF:Exec()
        </code></example>
    </member>
    <member name="M:VO.ErrorBox.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct an error message box.
      </summary>
      <param name="uParent">The window that owns the error box.  If no owner is specified, the error box is application modal (i.e., the application is suspended until the user acknowledges the error box).</param>
      <param name="uText">The description to be displayed in the error box.  If no text is specified, the system-defined 'Error!' error message text is used.</param>
      <param name="oHyperLabel">The hyperlabel containing a description (HyperLabel:Description) to be displayed in the error box.</param>
    </member>
    <member name="T:VO.Event">
      <summary>
        Provide the base class from which all X# events are subclassed.
      </summary>
      <remarks>
        The system dispatcher dispatches events to the event handler in the appropriate window.  The Event class always maps onto the GUI's event or message structure.
        Events are transient objects that carry information to windows indicating that a system event has occurred.  For example, the information that a window has been uncovered is passed to that window's Expose() event handler as an Event object.
      </remarks>
    </member>
    <member name="M:VO.Event.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct an event.
      </summary>
      <remarks>
        <note type="Warning"> X# instantiates events.</note>
      </remarks>
      <param name="_hWnd">The handle of the window for which the event occurred, or an Event Object. The runtime checks to see if _hWnd is a pointer. When not then it assumes it is an event object and it clones the values from this object.</param>
      <param name="_uMsg">The message (WM_..) that occurred</param>
      <param name="_wParam">The WPARAM of the message</param>
      <param name="_lParam">The LPARAM of the message</param>
      <param name="_oWindow">The Window object that was associated with the event.</param>
    </member>
    <member name="P:VO.Event.Handle">
      <summary>
        The pointer to the window where the event occurred
      </summary>
      <value>The pointer to the window where the event occurred</value>
    </member>
    <member name="F:VO.Event.hWnd">
      <summary>
        The pointer to the window where the event occurred
      </summary>
      <value>The pointer to the window where the event occurred</value>
    </member>
    <member name="F:VO.Event.lParam">
      <summary>
        A long integer representing the LPARAM of the Windows API message associated with the given event.
      </summary>
      <value>A long integer representing the LPARAM of the Windows API message associated with the given event.</value>
      <remarks>
        A long integer representing the LPARAM of the Windows API message associated with the given event.
        This can be used in the Dispatch() method of the EventContext class for processing of custom messages.
      </remarks>
    </member>
    <member name="P:VO.Event.Message">
      <summary>
        A dword representing the Windows API message associated with the given event.
      </summary>
      <value>A dword representing the Windows API message associated with the given event.</value>
      <remarks>
        A dword representing the Windows API message associated with the given event.
        This can be used in the Dispatch() method of EventContext class for processing of custom messages.
      </remarks>
    </member>
    <member name="F:VO.Event.oWindow">
      <summary>
        An object indicating the window or control in which the event occurred.  This is helpful, for example, for distinguishing between similar menu events coming from the same context menu attached to different controls.
      </summary>
      <value>An object indicating the window or control in which the event occurred.  This is helpful, for example, for distinguishing between similar menu events coming from the same context menu attached to different controls.</value>
    </member>
    <member name="F:VO.Event.uMsg">
      <summary>
        A dword representing the Windows API message associated with the given event.
      </summary>
      <value>A dword representing the Windows API message associated with the given event.</value>
      <remarks>
        A dword representing the Windows API message associated with the given event.
        This can be used in the Dispatch() method of EventContext class for processing of custom messages.
      </remarks>
    </member>
    <member name="P:VO.Event.Window">
      <summary>
        An object indicating the window or control in which the event occurred.  This is helpful, for example, for distinguishing between similar menu events coming from the same context menu attached to different controls.
      </summary>
      <value>An object indicating the window or control in which the event occurred.  This is helpful, for example, for distinguishing between similar menu events coming from the same context menu attached to different controls.</value>
    </member>
    <member name="F:VO.Event.wParam">
      <summary>
        A dword representing the WPARAM of the Windows API message associated with the given event.
      </summary>
      <value>A dword representing the WPARAM of the Windows API message associated with the given event.</value>
      <remarks>
        A dword representing the WPARAM of the Windows API message associated with the given event.
        This can be used in the Dispatch() method of the EventContext class for processing of custom messages.
      </remarks>
    </member>
    <member name="T:VO.EventContext">
      <summary>
        Provide the base class from which all X# event-handling classes are subclassed, embodying the elements needed by any objects that receive events.
      </summary>
      <remarks>
        The EventContext class provides:
        A dispatcher
        A default event handler
        A method enabling the dispatcher
      </remarks>
    </member>
    <member name="M:VO.EventContext.#ctor">
      <summary>
        Construct an event context.
      </summary>
    </member>
    <member name="M:VO.EventContext.Destroy">
      <summary>
        Destroy the event context permanently.
      </summary>
      <remarks>
        This method can be used when an EventContext object is no longer needed.  EventContext:Destroy() de-instantiates the Event Context object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.EventContext.Override">
      <summary>This is a compatibility method that is no longer used or needed.</summary>
    </member>
    <member name="P:VO.EventContext.SelfPtrStruc">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.ExplorerWindow">
      <summary>
        Create an explorer window.
      </summary>
      <remarks>
        An explorer window is a two- or four-pane split window that mimics the functionality of Microsoft Windows application windows, such as File Manager or Explorer.  The explorer window contains a list view control and a tree view control, as well as optional fixed text controls.  The programming interfaces for these controls can be used directly to manipulate the window.
        A two-pane explorer window contains a list view and a tree view side-by-side, separated by a vertical split bar that can be dragged.  A four-pane explorer window contains a list view and a tree view side-by-side, with fixed text that serves as a label above each.  The list view and tree view are separated by a vertical split bar that can be dragged.  The fixed text labels are separated from the list view and tree view by a horizontal split bar that cannot be dragged.  Panes are aligned vertically.
      </remarks>
    </member>
    <member name="M:VO.ExplorerWindow.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct an ExplorerWindow object.
      </summary>
      <param name="oOwner">The window that owns the explorer window.</param>
      <param name="lLabels">A logical value that is TRUE if you want to create a four-pane explorer window (a four-pane explorer window contains 'labels', or fixed text controls) and FALSE if you want to create a two-pane explorer window.  If omitted, the default is TRUE.</param>
      <param name="symTreeViewClassName">The symbolic name of the TreeView class.</param>
      <param name="symListViewClassName">The symbolic name of the ListView class.</param>
    </member>
    <member name="M:VO.ExplorerWindow.Destroy">
      <inheritdoc />
    </member>
    <member name="P:VO.ExplorerWindow.LabelLeft">
      <summary>
        The left fixed text control in a four-pane explorer window.  In a two-pane explorer window, this returns NULL_OBJECT.
      </summary>
      <value>The left fixed text control in a four-pane explorer window.  In a two-pane explorer window, this returns NULL_OBJECT.</value>
    </member>
    <member name="P:VO.ExplorerWindow.LabelRight">
      <summary>
        The right fixed text control in a four-pane explorer window.  In a two-pane explorer window, this returns NULL_OBJECT.
      </summary>
      <value>The right fixed text control in a four-pane explorer window.  In a two-pane explorer window, this returns NULL_OBJECT.</value>
    </member>
    <member name="P:VO.ExplorerWindow.ListView">
      <summary>
        The list view control in a two- or four-pane explorer window.
      </summary>
      <value>The list view control in a two- or four-pane explorer window.</value>
    </member>
    <member name="M:VO.ExplorerWindow.ListViewColumnClick(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ExplorerWindow.TreeView">
      <summary>
        The tree view control in a two- or four-pane explorer window.
      </summary>
      <value>The tree view control in a two- or four-pane explorer window.</value>
    </member>
    <member name="T:VO.ExposeEvent">
      <summary>
        Provide information about an ExposeEvent, used to notify a window that it may need to be repainted.
      </summary>
      <remarks>
        An ExposeEvent occurs when a window is:
        First shown
        Moved or closed
        Moving or closing a window exposes the area underneath the window; if any other windows are in this newly exposed area, they need to be repainted.  The system automatically sends these window(s) an ExposeEvent to notify them that they must repaint the area that was uncovered.
        Resized
        The ExposeEvent goes to the Window:Expose() event handler with the responsibility for repainting the exposed area.  You should place your own code in this event handler if you want your application to do something when its window is exposed.
      </remarks>
      <example>
        The following example prints different messages, depending on what part of the window has been exposed:
        <code language="X#">
          METHOD Expose(oEE) CLASS MyWindow
          LOCAL oBB AS BOUNDINGBOX
          oBB := oEE:ExposedArea
          IF oBB:Bottom() &lt; 20
          SELF:TextPrint("In the 20's",Point{0,20})
          ENDIF
          IF oBB:Bottom() &gt; 40
          SELF:TextPrint("In the 40's",Point{0,40})
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.ExposeEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ExposeEvent.ExposedArea">
      <summary>
        A bounding box — in canvas coordinates — representing the exposed area that caused this expose event.
        Use this method to optimize your repainting routines so that they paint only the area which requires refreshing.
      </summary>
      <value>
        A bounding box — in canvas coordinates — representing the exposed area that caused this expose event.
        Use this method to optimize your repainting routines so that they paint only the area which requires refreshing.
      </value>
    </member>
    <member name="T:VO.FieldSpec">
      <summary>
        Create a field specification, which holds general data type information about data elements, such as database fields and window controls.
      </summary>
      <remarks>
        A FieldSpec object holds a number of properties which relate to fields.  Specifically, a FieldSpec object can be defined for:
        Because both types ultimately apply to fields, a field specification's properties are described in terms of fields only (i.e., not window controls).
        <note type="tip">A field specification corresponds to what is sometimes referred to as an "element definition," a "domain," or an "abstract data type."</note>
        The field specification holds the following properties:
        <list type="table"><listheader><term>Property</term><description>Description</description></listheader><item><term>Decimals</term><description>The number of decimals in a field (numeric only)</description></item><item><term>Diagnostics</term><description>Hyperlabels for each of the validation rules.  Note that a hyperlabel contains not only a diagnostic message, but also a help context to provide for context sensitive help after a validation failure.</description></item><item><term>HyperLabel</term><description>Information about a field: its name, caption, description, and help context</description></item><item><term>Length</term><description>The length of a field</description></item><item><term>Min,Max</term><description>The data range allowed in a field</description></item><item><term>MinLength</term><description>The minimum number of characters allowed in a field (for example, a STATE field can be defined with a Length and MinLength of 2, while a PASSWORD might have a Length of 10 and a MinLength of 4)</description></item><item><term>Picture</term><description>A picture clause used to format a field.  This is a standard Xbase picture clause, such as @! or 999-99-9999.</description></item><item><term>Status</term><description>A HyperLabel object that describes the results of a validation test (it is NIL if the validation passed)</description></item><item><term>Type</term><description>The underlying storage type of a field (number, string, logic, date, or memo)</description></item><item><term>Validation</term><description>A code block that sets validation rule to be used for a field (i.e., required fields, data type compliance, range compliance, and so on) Also note that a FieldSpec subclass can be given a Validation() method, which overrides this code block.</description></item></list></remarks>
    </member>
    <member name="M:VO.FieldSpec.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a field specification.
      </summary>
      <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new field specification.</param>
      <param name="uType">The data type of the new field specification.  It can be specified either as a one-character string or as a constant (See FieldSpec:ValType and FieldSpec:UsualType for valid strings and constants, respectively).</param>
      <param name="uLength">The length of the field.  This argument is required for numeric and string data types, but is optional for all others.</param>
      <param name="uDecimals">The number of decimals in the field.  This argument is used for numeric data types only.  The default is 0.</param>
    </member>
    <member name="M:VO.FieldSpec.AsString">
      <summary>
        Return the caption defined to this field specification's hyperlabel; if no caption is defined, return the name defined to the hyperlabel.
      </summary>
    </member>
    <member name="P:VO.FieldSpec.Decimals Access">
      <summary>
        A numeric value representing the number of decimals defined to this field specification.
      </summary>
      <value>A numeric value representing the number of decimals defined to this field specification.</value>
      <remarks>
        A numeric value representing the number of decimals defined to this field specification.  This argument is used for numeric data types only.  The default is 0.
      </remarks>
    </member>
    <member name="P:VO.FieldSpec.HyperLabel">
      <summary>
        The hyperlabel connected to this field specification.
      </summary>
      <value>The hyperlabel connected to this field specification.</value>
      <remarks>
        The hyperlabel connected to this field specification.  From the hyperlabel, you can retrieve additional information about the field specification — for example:
        <code language="X#">
          cCaption := oFieldSpec:HyperLabel:Caption
          cDescription := oFieldSpec:HyperLabel:Description
          cHelpContext := oFieldSpec:HyperLabel:HelpContext
        </code></remarks>
    </member>
    <member name="P:VO.FieldSpec.Length">
      <summary>
        A numeric value representing the length defined to this field specification.
      </summary>
      <value>A numeric value representing the length defined to this field specification.</value>
    </member>
    <member name="P:VO.FieldSpec.Maximum">
      <summary>
        A numeric value representing the maximum value in the range validation for this field specification.
      </summary>
      <value>A numeric value representing the maximum value in the range validation for this field specification.</value>
    </member>
    <member name="P:VO.FieldSpec.Minimum">
      <summary>
        A numeric value representing the minimum value in the range validation for this field specification.
      </summary>
      <value>A numeric value representing the minimum value in the range validation for this field specification.</value>
    </member>
    <member name="P:VO.FieldSpec.MinLength">
      <summary>
        A numeric value representing the new minimum length validation for this field specification.
      </summary>
      <value>A numeric value representing the new minimum length validation for this field specification.</value>
    </member>
    <member name="P:VO.FieldSpec.MinLengthHL">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="P:VO.FieldSpec.Nullable">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.FieldSpec.PerformValidations(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Test a specified value to see if it passes all of this field specification's validation rules.
      </summary>
      <param name="uValue">The value to test.</param>
      <param name="arg">A second argument that is passed to the FieldSpec:Validate() method.</param>
      <returns>
        TRUE if the validation succeeded; otherwise, FALSE.
        <note type="tip">If FALSE, the system sets FieldSpec:Status to the appropriate hyperlabel for the validation rule that failed; if TRUE, FieldSpec:Status is set to NULL_OBJECT.</note></returns>
      <example>
        The following example performs a validation and assigns the resulting status to a status bar message variable:
        <code language="X#">
          IF !oFS:PerformValidations(x)
          SELF:StatusBarMessage := oFS:Status
          ENDIF
        </code></example>
    </member>
    <member name="P:VO.FieldSpec.Picture">
      <summary>
        A string representing the picture clause defined to this field specification.  It is used by the FieldSpec:Transform() method.
      </summary>
      <value>A string representing the picture clause defined to this field specification.  It is used by the FieldSpec:Transform() method.</value>
    </member>
    <member name="P:VO.FieldSpec.RangeHL">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="P:VO.FieldSpec.Required">
      <summary>
        Logical value indicating whether the field is required (TRUE) or not (FALSE).
      </summary>
      <value>Logical value indicating whether the field is required (TRUE) or not (FALSE).</value>
    </member>
    <member name="P:VO.FieldSpec.RequiredHL">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.FieldSpec.SetLength(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a new length for this field specification and new hyperlabel diagnostics for the length check.
      </summary>
      <param name="w">The new length.  If omitted, the current value is not changed.</param>
      <param name="oHL">The hyperlabel that contains the new diagnostics for the length check (caption, description, and help context).  If omitted, the current value is not changed.</param>
      <remarks>
        A field specification's length is typically set during instantiation, and should not normally be changed later.
      </remarks>
    </member>
    <member name="M:VO.FieldSpec.SetMinLength(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a new minimum length validation for this field specification and new hyperlabel diagnostics for the minimum length check.
      </summary>
      <param name="w">The new minimum length (if 0, the minimum length check is removed).  If omitted, the current value is not changed.</param>
      <param name="oHL">The hyperlabel that contains the new diagnostics for the minimum length check (caption, description, and help context).  If omitted, the current value is not changed.</param>
    </member>
    <member name="M:VO.FieldSpec.SetRange(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a new range validation for this field specification and new hyperlabel diagnostics for the range check.
      </summary>
      <param name="uMinimum">The new minimum value.  If omitted, the current value is not changed.</param>
      <param name="uMaximum">The new maximum value.  If omitted, the current value is not changed.</param>
      <param name="oHL">The hyperlabel that contains the new diagnostics for the range check (caption, description, and help context).  If omitted, the current value is not changed.</param>
    </member>
    <member name="M:VO.FieldSpec.SetRequired(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a new required validation for this field specification and new hyperlabel diagnostics for the required check.
      </summary>
      <param name="lReq">TRUE if the field should be required; otherwise, FALSE.  If omitted, TRUE is assumed.</param>
      <param name="oHL">The hyperlabel that contains the new diagnostics for the required check (caption, description, and help context).  If omitted, the current value is not changed.</param>
    </member>
    <member name="M:VO.FieldSpec.SetType(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a new data type for this field specification and new hyperlabel diagnostics for the data type check.
      </summary>
      <param name="uType">The new data type.  It can be specified either as a one-character string or as a constant (See FieldSpec:ValType and FieldSpec:UsualType for valid strings and constants, respectively).  If omitted, the current value is not changed.</param>
      <param name="oHL">The hyperlabel that contains the new diagnostics for the data type check (caption, description, and help context).  If omitted, the current value is not changed.</param>
      <remarks>
        A field specification's data type is typically set during instantiation, and should not normally be changed later.
      </remarks>
    </member>
    <member name="M:VO.FieldSpec.SetValidation(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a new validation rule for this field specification and new hyperlabel diagnostics for the validation rule check.
      </summary>
      <param name="cb">The new validation rule.  If omitted, the current value is not changed.</param>
      <param name="oHL">The hyperlabel that contains the new diagnostics for the validation rule check (caption, description, and help context).  If omitted, the current value is not changed.</param>
    </member>
    <member name="P:VO.FieldSpec.Status">
      <summary>
        After a validation request (see FieldSpec:PerformValidations() for details), this contains a HyperLabel object that describes the results of the validation or NULL_OBJECT if the validation passed.
      </summary>
      <value>After a validation request (see FieldSpec:PerformValidations() for details), this contains a HyperLabel object that describes the results of the validation or NULL_OBJECT if the validation passed.</value>
      <example>
        The following example performs a validation and assigns the resulting status to a status bar message variable:
        <code language="X#">
          IF !oFS:PerformValidations(x)
          SELF:StatusBarMessage := oFS:Status
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.FieldSpec.Transform(XSharp.__Usual)">
      <summary>
        Convert a specified value into a string, formatted according to this field specification's picture clause.
      </summary>
      <param name="uValue">The value to format.  It should be of a type compliant with the underlying data type of this field specification.  If not, the method returns NIL and sets FieldSpec:Status accordingly (note that FieldSpec:Transform() performs no other validations).</param>
    </member>
    <member name="P:VO.FieldSpec.UsualType">
      <summary>
        A constant, representing the data type defined to this field specification:
      </summary>
      <value>A constant, representing the data type defined to this field specification:</value>
      <remarks>
        <para>One of the following constants, representing the data type defined to this field specification:</para>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Meaning</description>
          </listheader>
          <item>
            <term>BYTE</term>
            <description>Byte</description>
          </item>
          <item>
            <term>DATE</term>
            <description>Date</description>
          </item>
          <item>
            <term>DWORD</term>
            <description>Double word</description>
          </item>
          <item>
            <term>FLOAT</term>
            <description>Float</description>
          </item>
          <item>
            <term>INT</term>
            <description>Integer, long integer</description>
          </item>
          <item>
            <term>LOGIC</term>
            <description>Logical</description>
          </item>
          <item>
            <term>OBJECT</term>
            <description>Object</description>
          </item>
          <item>
            <term>REAL4</term>
            <description>Real4</description>
          </item>
          <item>
            <term>REAL8</term>
            <description>Real8</description>
          </item>
          <item>
            <term>SHORT</term>
            <description>Short integer</description>
          </item>
          <item>
            <term>STRING</term>
            <description>String</description>
          </item>
          <item>
            <term>TYPE_BITMAP</term>
            <description>Bitmap</description>
          </item>
          <item>
            <term>WORD</term>
            <description>Word</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:VO.FieldSpec.Val(XSharp.__Usual)">
      <summary>
        Convert a string to a value, according to this field specification's defined data type.
      </summary>
      <param name="cString">The string to convert.  If the string cannot be converted to the appropriate value, this method returns NIL and sets FieldSpec:Status to indicate the reason for the failure (note that FieldSpec:Val() performs no other validations).</param>
      <remarks>
        The FieldSpec:Val() method acts as the inverse of the FieldSpec:Transform() method, converting a transformed string back to its original value.
      </remarks>
    </member>
    <member name="M:VO.FieldSpec.Validate(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        A replaceable method for performing validations.  The standard implementation evaluates the code block specified through FieldSpec:SetValidation().
      </summary>
      <param name="uValue">The value to be validated.</param>
      <param name="arg">A second argument that is passed to the code block specified from FieldSpec:SetValidation().  During FieldSpec:PerformValidations(), executed from a data window or data browser, this argument is the Control object or Column object.</param>
      <returns>
        TRUE if the value is valid; otherwise, FALSE.
      </returns>
      <remarks>
        This method is called by FieldSpec:PerformValidations(), and should not normally be called by the developer.  It is provided as a way for the developer to optionally use a customized validation technique.
        The standard implementation is:
        <code language="X#">
          METHOD Validate(uValue, uArg) CLASS FieldSpec
          RETURN cbValidation = NULL_CODEBLOCK;
          .OR. EVAL(cbValidation, uValue)
        </code></remarks>
    </member>
    <member name="P:VO.FieldSpec.Validation">
      <summary>
        A code block that sets the validation rule for this field specification.
      </summary>
      <value>A code block that sets the validation rule for this field specification.</value>
    </member>
    <member name="P:VO.FieldSpec.ValidationHL">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="P:VO.FieldSpec.ValType">
      <summary>
        A one-character string representing the data type defined to this field specification:
        <list type="table"><listheader><term>Character</term><description>Meaning</description></listheader><item><term>C</term><description>String</description></item><item><term>D</term><description>Date</description></item><item><term>L</term><description>Logic</description></item><item><term>M</term><description>Memo</description></item><item><term>N</term><description>Long integer, float, byte, short integer, word, double word, Real4, Real8</description></item></list></summary>
      <value>
        A one-character string representing the data type defined to this field specification:
        CharacterMeaningCStringDDateLLogicMMemoNLong integer, float, byte, short integer, word, double word, Real4, Real8
      </value>
    </member>
    <member name="T:VO.FileSpec">
      <summary>
        Create a file specification, which provides a useful framework for managing file names and paths.
      </summary>
      <remarks>
        A file specification is intended as a way of storing and managing name- and path-related information for a file.  It provides some methods for copying, moving, deleting and renaming files, as well as access methods for retrieving information about the file.  If the path is not specified using the assign methods provided by the FileSpec class, it is obtained by the SetDefault() and SetPath() functions.
        This class allows you to manage this data for all different types of files in a common way.  Because of this, it does not provide any methods for processing a file, such as reading and writing it, as such methods would depend on the type of file it is.  For example, .DBF files can be processed with the DBServer object; other files can be processed with either functions or customized FileSpec subclasses that have been customized for handling different types of files.
      </remarks>
      <example>
        File specifications are often used as arguments to DBServer objects and methods.  For example, to copy selected records from one file to another:
        <code language="X#">
          // Source file
          oFSSource := FileSpec{"c:\data\customer"}
          // For the target file, use path of source file
          oFSTarget := FileSpec{oFSSource:FullPath}
          // Change file name for target file
          oFSTarget:FileName := "nycust"
          // Open source file in server object
          oDBSource := DBServer{oFSSource}
          // Copy records to target file
          oDBSource:CopyDB(oFSTarget,,{||STATE="NY"})
        </code>
        A FileSpec object is also a convenient way to find the current directory and then search in subdirectories according to a logical structure:
        <code language="X#">
          oFileSpec := FileSpec{}
          oFileSpec:Path := CurDir()
          oFileSpec:AppendToPath("data")
          oFileSpec:FileName := "custdata"
          oDB := DBServer{oFileSpec}
        </code></example>
    </member>
    <member name="M:VO.FileSpec.#ctor(XSharp.__Usual)">
      <summary>
        Construct a file specification.
      </summary>
      <param name="cFullPath">The file name containing either a full or partial path name.  If omitted, you should specify this file's path using the assign methods of the FileSpec class before the object is used.</param>
    </member>
    <member name="M:VO.FileSpec.AppendToPath(XSharp.__Usual)">
      <summary>
        Append a subdirectory to the end of this file specification's path.
      </summary>
      <param name="cDirectory">
        The subdirectory to be appended, with or without leading and trailing slashes.  A list of subdirectories separated by slashes can also be appended.
      </param>
      <remarks>
        <note type="tip">If the path was previously unknown (NIL), &lt;cDirectory&gt; becomes the new path.</note>
      </remarks>
      <returns>
        The resulting path.
      </returns>
      <example>
        The following examples illustrate the use of FileSpec:AppendToPath():
        <code language="X#">
          // d:\data\cust
          oFS:Path := "d:\data"
          oFS:AppendToPath("cust")
          // d:\data\cust
          oFS:Path := "d:\data"
          oFS:AppendToPath("\cust\")
          // \data
          oFS:Path := "\"
          oFS:AppendToPath("data")
          // \cust
          oFS:Path := NIL
          oFS:AppendToPath("cust")
          // d:\data\cust\1993\budget
          oFS:Path := "d:\data"
          oFS:AppendToPath("cust\1993\budget")
        </code></example>
    </member>
    <member name="P:VO.FileSpec.Attributes">
      <summary>
        One or more of the following characters concatenated into a string, indicating the attributes of the file represented by this file specification:
      </summary>
      <value>One or more of the following characters concatenated into a string, indicating the attributes of the file represented by this file specification:</value>
      <remarks>
        One or more of the following characters concatenated into a string, indicating the attributes of the file represented by this file specification:
        <list type="table"><listheader><term>Character</term><description>Description</description></listheader><item><term>A</term><description>File whose archive bit is set</description></item><item><term>H</term><description>Hidden file</description></item><item><term>NULL_STRING</term><description>Normal read/write file</description></item><item><term>R</term><description>Read only file</description></item><item><term>S</term><description>System file</description></item></list><note type="tip">You can use the At() function to determine if a particular property is set.</note></remarks>
      <example>
        This example checks if the file "abc.dbf" is read only:
        <code language="X#">
          oFileSpec := FileSpec("abc.dbf")
          IF AT("R", oFileSpec:Attributes) &gt; 0
          // Attribute string contains "R" therefore, the file is read only
          ...
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.FileSpec.Copy(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Make a copy of the file represented by this file specification.
      </summary>
      <param name="oFSTarget">The name of the target file, including an optional drive, directory, and extension.  The file is created following operating system rules.</param>
      <param name="lName">Logical parameter.  TRUE causes an auto-rename of the target file if a file conflict occurs during the copy.  The default is FALSE.</param>
      <returns>
        TRUE, if the file was successfully copied; otherwise, FALSE.
      </returns>
      <example>
        This example defines a file specification and then copies it to a target file:
        <code language="X#">
          // Define original file
          oFSSource := FileSpec{"c:\data\customer.dbf"}
          // Copy the file
          oFSSource:Copy("a:\custdata")
        </code></example>
    </member>
    <member name="P:VO.FileSpec.DateChanged">
      <summary>
        A date value denoting when the file was created or last changed.  If the file is not found, NULL_DATE is returned.
      </summary>
      <value>A date value denoting when the file was created or last changed.  If the file is not found, NULL_DATE is returned.</value>
    </member>
    <member name="M:VO.FileSpec.Delete">
      <summary>
        Delete the file represented by this file specification.
      </summary>
      <returns>
        TRUE if the file was successfully deleted; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.FileSpec.Drive">
      <summary>
        A string representing the drive defined to this file specification.
      </summary>
      <value>A string representing the drive defined to this file specification.</value>
      <remarks>
        A string representing the drive defined to this file specification.  The drive may have been assigned explicitly or as part of a longer file specification (assigned either as an instantiation parameter or as part of the file name or full path).
        When accessing FileSpec:Drive, the requested drive is returned with a trailing colon.
        When assigning FileSpec:Drive, you can specify a drive with or without a colon.  Assigning a NULL_STRING (or NIL) to the drive means that the drive is unknown or unspecified; the various functions and objects that use the file specification to locate the file looks on whatever default drive would apply if a file name without a drive is specified.
      </remarks>
      <example>
        To copy selected records from a file from one disk drive to another — using the same file name and directory — you could do this:
        <code language="X#">
          // Define original file
          oFSSource := FileSpec{"c:\data\customer"}
          // Copy path for target file
          oFSTarget := FileSpec{oFSSource:FullPath}
          // Change drive for target file
          oFSTarget:Drive := "d"
          // Open original file
          oDBSource := DBServer{oFSSource}
          // Copy selected records to target file
          oDBSource:CopyDB(oFSTarget,,{||STATE="NY"})
        </code></example>
    </member>
    <member name="P:VO.FileSpec.ErrInfo">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.FileSpec.Error(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Provide a method for handling error conditions raised during FileSpec processing.  This is an event handler: it is automatically called by other methods; the developer does not normally need to call the error method, but might want to replace or amend it.
      </summary>
      <param name="oError">An Error object describing the error condition.</param>
      <param name="symMethod">The symbolic name of the method that originated the error.</param>
      <remarks>
        All methods of the FileSpec trap serious errors with a recover statement and send them to this method.  Ordinary failures, such as file-not-found, do not raise error conditions; they are simply indicated through failure return values.
        The standard Error() handling method fills in some more information about the errors and about the FileSpec object that originates the error and sets the status value for the server object, in its standard Error() handling method.  The method passes it up the call stack by issuing a BREAK with the same Error object.
      </remarks>
    </member>
    <member name="P:VO.FileSpec.Extension">
      <summary>
        A string representing the extension defined to this file specification.
      </summary>
      <value>A string representing the extension defined to this file specification.</value>
      <remarks>
        A string representing the extension defined to this file specification.  The extension may have been assigned explicitly or as part of a longer file specification (assigned either as an instantiation parameter or as part of the file name or full path).
        When accessing FileSpec:Extension, the requested extension is returned with a leading period.
        When assigning FileSpec:Extension, you can specify an extension with or without a leading period.  Assigning a NULL_STRING (or NIL) to the extension means that the extension is unknown or unspecified; the various functions and objects that use the file specification to locate the file uses whatever default extension applies to them.
        <note type="tip">Assigning just a single period as extension explicitly specifies an "empty" extension.</note></remarks>
    </member>
    <member name="P:VO.FileSpec.FileName">
      <summary>
        A string representing the file name defined to this file specification.
      </summary>
      <value>A string representing the file name defined to this file specification.</value>
      <remarks>
        A string representing the file name defined to this file specification.  The file name may have been assigned explicitly or as part of a longer file specification (assigned either as an instantiation parameter or as part of a full path assignment).
        When accessing FileSpec:FileName, the requested file name is returned without a path and extension.
        When assigning FileSpec:FileName, you can specify a simple file name, a file name with an extension, or a full path complete with drive.  The information given is parsed and assigned to the appropriate components; in addition, only those parts that are specified are changed in the file specification.
        Assigning a NULL_STRING (or NIL) means that the file name is unknown or unspecified.
      </remarks>
      <example>
        Here are some examples that use FileSpec:FileName:
        <code language="X#">
          // Changes only the file name
          oFS:FileName := "cust"
          // Changes file name and extension
          oFS:FileName := "cust.dbx"
          // Changes path and file name
          oFS:FileName := "data\cust"
          // Changes path and file name
          oFS:FileName:="\data\cust"
          // Changes drive, path, file name
          oFS:FileName:="d:cust"
        </code></example>
    </member>
    <member name="M:VO.FileSpec.Find">
      <summary>
        Search the disk for the file represented by this file specification, indicate if it exists, and if so, store its full path information in this file specification for future reference.
      </summary>
      <returns>
        TRUE if the file was found; otherwise, FALSE.
      </returns>
      <remarks>
        This method searches for the file subject to all the standard settings of the SetPath() and SetDefault() functions.  If the file is found, its full path information is stored for future reference, which is useful since the initial search starts from the current directory and the same file can later be used in a DBServer, for example, when the current directory may not be the same.
      </remarks>
      <example>
        The following example, part of a method in a hypothetical data window, defines a generic file, searches for it, and then displays its full path if found:
        <code language="X#">
          oFileSpec := FileSpec{"custfile"}
          IF oFileSpec:Find()
          SELF:Caption := oFileSpec:FullPath d:\data\custfile.dbf
          ...
          SELF:Use(DBServer{oFileSpec})
          ENDIF
        </code></example>
    </member>
    <member name="P:VO.FileSpec.FullPath">
      <summary>
        A string representing the full path name defined to this file specification.
      </summary>
      <value>A string representing the full path name defined to this file specification.</value>
      <remarks>
        A string representing the full path name defined to this file specification.  The individual components of the full path name may have been assigned explicitly or as part of a longer file specification (assigned either as an instantiation parameter or as part of a file name or full path assignment).
        When accessing FileSpec:FullPath, the requested path name is returned with drive, path, file name, and extension.
        However, if the file was not fully specified and the file has not been found since, parts of the path can be unknown.  Any part that is not known is omitted from the return value.
        When assigning FileSpec:FullPath, you can specify a simple file name, a file name with an extension, or a full path complete with drive.  The information given is parsed and assigned to the appropriate components; in addition, when assigning a string to FileSpec:FullPath, those parts that are omitted in the string are stored as unknown or unspecified.
        <note type="tip">FileSpec does not distinguish between a file with no extension and a subdirectory (e.g., C:\CAVOxx, in which the directory "CAVOxx" appears to be a file with no extension).</note></remarks>
      <example>
        Here are some examples of strings that are returned by FileSpec:FullPath, with an explanation of what they indicate:
        <code language="X#">
          // All known
          c:\data\customer\custdata.dbf
          // Drive unknown
          \data\customer\custdata.dbf
          // Path is ROOT
          c:\custdata.dbf
          // Drive and path unknown
          custdata.dbf
          // Drive unknown, path is ROOT
          \custdata.dbf
          // Extension unknown
          c:\data\customer\custdata
          // Only file name is known
          custdata
        </code>
        Here are some examples of assigning strings to FileSpec:FullPath, with an explanation of the results:
        <code language="X#">
          // Assign and display FileSpec:FullPath
          oFS:FileSpec := ("String")
          ? oFS:FullPath
          // All but file name marked unknown
          oFS:FullPath := "cust"
          // All but file name and extension marked unknown
          oFS:FullPath:= "cust.dbx"
          // Sets path and file name, marks drive and
          // extension as unknown
          oFS:FullPath := "data\cust"
          // Same thing
          oFS:FullPath := "\data\cust"
          // Changes drive, path, file name;
          // sets extension unknown
          oFS:FullPath := "d:cust"
        </code></example>
    </member>
    <member name="M:VO.FileSpec.Move(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Move the file represented by this file specification to a new location.
      </summary>
      <param name="oFSTarget">The name of the target file, including an optional drive, directory, and extension.  The file is created following operating system rules.  Note that a file can be moved across volumes.</param>
      <param name="lName">Logical parameter.  TRUE causes an auto-rename of the target file if a file conflict occurs during the move.  The default is FALSE.</param>
      <returns>
        TRUE, if the file was successfully moved; otherwise, FALSE.
      </returns>
      <example>
        This examples moves and also renames a file:
        <code language="X#">
          // Define original file
          oFSSource := FileSpec{"c:\data\customer.dbf"}
          // Move the file
          oFSSource:Move("a:\custdata\customer.bak")
        </code></example>
    </member>
    <member name="P:VO.FileSpec.Path">
      <summary>
        A string representing the path defined to this file specification.
      </summary>
      <value>A string representing the path defined to this file specification.</value>
      <remarks>
        A string representing the path defined to this file specification.  The path may have been assigned explicitly or as part of a longer file specification (assigned either as an instantiation parameter or as part of a file name or full path assignment).
        When accessing FileSpec:Path, the requested path is returned with a leading slash and when applicable a trailing slash.
        When assigning FileSpec:Path, you can specify a path with or without leading or trailing slashes.  To specify the root, assign a single slash.  Assigning a NULL_STRING (or NIL) to the drive means that the drive is unknown or unspecified; the various functions and objects that use the file specification to locate the file looks on whatever default drive would apply if a file name without a drive is specified.
        Assigning a value to the path normally does not affect the drive, file name, or extension.  If a drive is included in the path, it is assigned to the path.
      </remarks>
      <example>
        Here are some examples of strings that are returned by FileSpec:Path, with an explanation of what they indicate:
        <code language="X#">
          \data\customer					// Path is \data\customer
          \							// Path is ROOT
          &lt;EmptyString&gt;					// Path unknown
        </code>
        Here are some examples of assigning strings to FileSpec:Path, with an explanation of the results:
        <code language="X#">
          oFS:Path := NIL				// Unknown
          oFS:Path := ""				// Unknown
          oFS:Path := "\"				// Root
          oFS:Path := "data"			// \data
          oFS:Path := "\data"			// \data
          oFS:Path := "data\"			// \data
          oFS:Path := "\data"			// \data
          oFS:Path := "data\cust"		// \data\CUST
          oFS:Path := "\data\cust"		// \data\CUST
          oFS:Path := "d:data"			// Drive = d:
          // Path = \data
          oFS:Path := "d:\data"			// Drive = d:
          // Path = \data
          oFS:Path := "d:\"			// Drive = d:
          // Path = root
          oFS:Path := "d:"				// Drive = d:
          // Path = root
        </code></example>
    </member>
    <member name="M:VO.FileSpec.PathUp">
      <summary>
        Remove the last subdirectory from the end of this file specification's path.
      </summary>
      <returns>
        The resulting path.
      </returns>
      <remarks>
        If the path was previously the root or unknown (NIL), PathUp() does not change the path.  Other components — drive, file name, and extension — are not affected.
      </remarks>
      <example>
        For example, to store selected data in a backup directory at a peer level to the actual data directory:
        <code language="X#">
          oFSCust := FileSpec{"c:\data\cust.dbf"}
          oFSCustBackup := FileSpec{oFSCust:FullPath}
          oFSCustBackup:PathUp()
          oFSCustBackup:AppendToPath("backup")
        </code></example>
    </member>
    <member name="M:VO.FileSpec.Rename(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Rename the file represented by this file specification.
      </summary>
      <param name="oFSTarget">The new file name.</param>
      <param name="lName">** missing parameter documentation **</param>
      <returns>
        TRUE if the file was successfully renamed; otherwise, FALSE.
      </returns>
      <example>
        The following examples renames a file:
        <code language="X#">
          oFSSource := FileSpec{"c =:\data\customer.dbf"}
          // Rename the file
          oFSSource:Rename("customer.bak")
        </code></example>
    </member>
    <member name="P:VO.FileSpec.Size">
      <summary>
        A numeric value representing the size, in bytes, of the file represented by this file specification.
      </summary>
      <value>A numeric value representing the size, in bytes, of the file represented by this file specification.</value>
    </member>
    <member name="P:VO.FileSpec.TimeChanged">
      <summary>
        A string indicating the time when the file was created or last changed.
      </summary>
      <value>A string indicating the time when the file was created or last changed.</value>
      <remarks>
        A string indicating the time when the file was created or last changed.  If the file is not found, "00:00:00" is returned.
      </remarks>
    </member>
    <member name="T:VO.FixedBitmap">
      <summary>
        Create a FixedBitmap object.  Unlike the bitmaps created by the Bitmap class, fixed bitmaps are static — they do not need to be redisplayed every time an ExposeEvent occurs.  FixedBitmap objects can be created dynamically or from a resource entity.
      </summary>
      <example>
        This example creates a fixed bitmap from a resource entity and changes its position to the lower-left corner of a dialog window:
        <code language="X#">
          CLASS MyDialogWindow INHERIT DialogWindow
          HIDDEN OMyFBitmap AS OBJECT
          METHOD Init(oWindow) CLASS MyDialogWIndow
          SUPER:Init(oWindow,ID_MYDIALOG)
          OMyFBitmap := FixedBitmap{SELF,MYBITMAP}
          OMyFBitmap:Origin := Point{10,10}
          SELF:Show()
        </code>

        In Windows, a fixed bitmap is equivalent to a static object with the SS_BITMAP style.  These are normally specified in the resource entity as follows:
        <code language="X#">
          RESOURCE IDI_FIXEDBITMAP BITMAP fixed.bmp
          RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 80
          STYLE WS_POPUP | WS_DLGFRAME
          BEGIN
          BITMAP IDI_FIXEDBITMAP -1, 8, 8, 0, 0
          END
        </code></example>
    </member>
    <member name="M:VO.FixedBitmap.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a FixedBitmap object.
      </summary>
      <param name="uOwner">The window that owns the fixed bitmap.</param>
      <param name="uID">The ID of the fixed bitmap.</param>
      <param name="uPoint">The origin of the fixed bitmap in canvas coordinates.</param>
      <param name="uDimension">The dimension of the fixed bitmap in canvas coordinates.</param>
      <param name="uResID">Resource ID object or numeric resource ID for the bitmap image to be associated with this FixedBitmap static control.</param>
      <param name="oResourceID">The ResourceID object of the fixed bitmap or the resource ID of the fixed bitmap.</param>
    </member>
    <member name="M:VO.FixedBitmap.AsString">
      <summary>
        Return the identifying label of the fixed bitmap.
      </summary>
    </member>
    <member name="M:VO.FixedBitmap.SetBitmap(XSharp.__Usual)">
      <summary>
        Associate a bitmap image with the FixedBitmap static control.
      </summary>
      <param name="oBitmap">The bitmap object to associate with this static control.</param>
    </member>
    <member name="T:VO.FixedIcon">
      <summary>
        Create a FixedIcon object.  Unlike the icons created by the Icon class, fixed icons are static — they do not need to be redisplayed every time an ExposeEvent occurs.  FixedIcon objects can be created dynamically or from a resource entity.
      </summary>
      <example>
        This example creates a fixed icon from a resource entity and changes its position to the lower-left corner of a dialog window:
        <code language="X#">
          CLASS MyDialogWindow INHERIT DialogWindow
          HIDDEN OMyFIcon AS OBJECT
          METHOD Init(oWindow) CLASS MyDialogWIndow
          SUPER:Init(oWindow,ID_MYDIALOG)
          OMyFIcon := FixedIcon{SELF,MYICON}
          OMyFIcon:Origin := Point{10,10}
          SELF:Show()
        </code>

        In Windows, a fixed icon is equivalent to a static object with the SS_ICON style.  These are normally specified in the resource entity as follows:
        <code language="X#">
          RESOURCE IDI_FIXEDICON ICON fixed.ico
          RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 80
          STYLE WS_POPUP | WS_DLGFRAME
          BEGIN
          ICON IDI_FIXEDICON -1, 8, 8, 0, 0
          END
        </code></example>
    </member>
    <member name="M:VO.FixedIcon.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a FixedIcon object.
      </summary>
      <param name="uOwner">The window that owns the fixed icon.</param>
      <param name="uID">The ID of the fixed icon.</param>
      <param name="uPoint">The origin of the fixed icon in canvas coordinates.</param>
      <param name="uResID">The ResourceID object of the fixed icon or the resource ID of the fixed icon.</param>
    </member>
    <member name="M:VO.FixedIcon.AsString">
      <summary>
        Return the identifying label of the fixed icon.
      </summary>
    </member>
    <member name="M:VO.FixedIcon.Destroy">
      <summary>
        Provide a method to de-instantiate a FixedIcon object.
      </summary>
      <remarks>
        This method can be used when a FixedIcon object is no longer needed.  FixedIcon:Destroy() de-instantiates the FixedIcon object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.FixedIcon.SetIcon(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oIcon">** missing parameter documentation **</param>
    </member>
    <member name="T:VO.FixedImage">
      <summary>
        Provide the base class from which FixedBitmap and FixedIcon are subclassed.
      </summary>
      <remarks>
        FixedImage is the base class for the FixedBitmap and FixedIcon subclasses.
      </remarks>
    </member>
    <member name="M:VO.FixedImage.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a FixedImage control.
      </summary>
      <param name="uOwner">The window that owns the control.</param>
      <param name="uID">The unique ID of the control (between 1 and 8000).</param>
      <param name="uPoint">The origin of the control in canvas coordinates.</param>
      <param name="uDimension">The dimension of the control in canvas coordinates.</param>
      <param name="uResID">The resource ID of the control.</param>
    </member>
    <member name="M:VO.FixedImage.Destroy">
      <summary>
        Provide a method to de-instantiate a FixedImage object.
      </summary>
      <remarks>
        This method can be used when a FixedImage object is no longer needed.  FixedImage:Destroy() de-instantiates the FixedImage object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="T:VO.FixedText">
      <summary>
        Create a FixedText object.
      </summary>
      <remarks>
        Unlike text displayed with Window:TextPrint(), fixed text from a FixedText object is static — they do not need to be redisplayed every time an ExposeEvent occurs.  FixedText objects can be created dynamically or from a resource entity.
        <note type="tip">The text in a FixedText object can be changed by assigning TextControl:TextValue.  In such a case, it may be necessary to resize the FixedText object because the size of the control dictates the clipping region for the displayed text.</note><note type="tip">
          As of Visual Obejcts version 2.7 the FixedText control supports the DrawText and Transparent options. These are on by default.
          If the old behaviour is required, set the EXPORTed variable lUseDrawText to FALSE. It is TRUE by default.
          If WinXP Themes are enabled and you want to stop the drawing of the theme behind the FixedText control, set the EXPORTed variable lDrawThemeBackground to FALSE. It is TRUE by default.
        </note></remarks>
      <example>
        This example places some fixed text on a window:
        <code language="X#">
          CLASS MyWindow INHERIT TopAppWindow
          HIDDEN MyFT AS OBJECT
          METHOD Init() CLASS MyWindow
          p := Point{10,10}
          d := Dimension{10,10}
          MyFT:= FixedText{SELF,1,p,d,"The text"}
          SELF:Show()
          MyFT:Show()
        </code>

        In Windows, fixed text is equivalent to a static object with one of the SS_LEFT, SS_CENTER, SS_RIGHT styles.
        These are normally specified in the resource entity as follows:
        <code language="X#">
          RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 80
          STYLE WS_POPUP | WS_DLGFRAME
          BEGIN
          LTEXT "Left justified"  -1, 8,  8, 120, 12
          CTEXT "Centered"        -1, 8, 24, 120, 12
          RTEXT "Right justified" -1, 8, 36, 120, 12
          DEFPUSHBUTTON "OK"      IDB_OK, 64, 60, 32, 14, WS_GROUP
          END
        </code></example>
    </member>
    <member name="M:VO.FixedText.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a FixedText object.
      </summary>
      <param name="oOwner">The window that owns the FixedText object.</param>
      <param name="xID">The unique ID of the FixedText object.</param>
      <param name="oPoint">The origin of the FixedText object in canvas coordinates.</param>
      <param name="oDimension">The dimension of the FixedText object in canvas coordinates.</param>
      <param name="cText">The informational text to be printed in the FixedText object.  The default is NULL_STRING.</param>
      <param name="lDataAware">A logical value specifying whether the FixedText object is data aware.</param>
      <param name="nResourceID">The resource ID of the FixedText object.</param>
    </member>
    <member name="M:VO.FixedText.Destroy">
      <summary>
        Provide a method to de-instantiate a FixedText object.
      </summary>
      <remarks>
        This method can be used when a FixedText object is no longer needed.  FixedText:Destroy() de-instantiates the FixedText object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.FixedText.Dispatch(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="F:VO.FixedText.lDrawThemeBackground">
      <exclude />
    </member>
    <member name="F:VO.FixedText.lUseDrawText">
      <exclude />
    </member>
    <member name="M:VO.FixedText.SetDrawStyle(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the alignment style for the text in a FixedText object.
      </summary>
      <param name="dwDrawStyle">The style to set. See table in the remarks section.</param>
      <param name="lEnable">A logical value to set the style. TRUE sets the style on, FALSE turns it off.</param>
      <remarks>
        <list>
          <listheader>
            <term>Value</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>DT_BOTTOM</term>
            <description>Justifies the text to the bottom of the rectangle. This value must be combined with DT_SINGLELINE.</description>
          </item>
          <item>
            <term>DT_CALCRECT</term>
            <description>
              Determines the width and height of the rectangle. If there are multiple lines of text,
              DrawText uses the width of the rectangle pointed to by the lpRect parameter and extends the base of the
              rectangle to bound the last line of text. If there is only one line of text,
              DrawText modifies the right side of the rectangle so that it bounds the last character in the line.
              In either case, DrawText returns the height of the formatted text but does not draw the text.
            </description>
          </item>
          <item>
            <term>DT_CENTER</term>
            <description>Centers text horizontally in the rectangle.</description>
          </item>
          <item>
            <term>DT_EDITCONTROL</term>
            <description>
              Duplicates the text-displaying characteristics of a multiline edit control.
              Specifically, the average character width is calculated in the same manner as for an edit control,
              and the function does not display a partially visible last line.
              Replaces part of the given string with ellipses, if necessary, so that the result fits in the specified  rectangle.
              The given string is not modified unless the DT_MODIFYSTRING flag is specified.You can specify DT_END_ELLIPSIS to
              replace characters at the end of the string, or DT_PATH_ELLIPSIS to replace characters in the middle of the string.
              If the string contains backslash (\) characters, DT_PATH_ELLIPSIS preserves as much as possible of the text after the last backslash.
            </description>
          </item>
          <item>
            <term>DT_EXPANDTABS</term>
            <description>
              Expands tab characters. The default number of characters per tab is eight.
              Includes the font external leading in line height. Normally, external leading is not included in the height of a line of text.
            </description>
          </item>
          <item>
            <term>DT_LEFT</term>
            <description>Aligns text to the left.</description>
          </item>
          <item>
            <term>DT_MODIFYSTRING</term>
            <description>
              Modifies the given string to match the displayed text.
              This flag has no effect unless the DT_END_ELLIPSIS or DT_PATH_ELLIPSIS flag is specified.
            </description>
          </item>
          <item>
            <term>DT_NOCLIP</term>
            <description>Draws without clipping. DrawText is somewhat faster when DT_NOCLIP is used.</description>
          </item>
          <item>
            <term>DT_NOPREFIX</term>
            <description>
              Turns off processing of prefix characters.
              Normally, DrawText interprets the mnemonic-prefix character &amp; as a directive to underscore the character
              that follows, and the mnemonic-prefix characters &amp;&amp; as a directive to print a single &amp;.
              By specifying DT_NOPREFIX, this processing is turned off.
            </description>
          </item>
          <item>
            <term>DT_RIGHT</term>
            <description>Aligns text to the right.</description>
          </item>
          <item>
            <term>DT_RTLREADING</term>
            <description>
              Layout in right to left reading order for bi-directional text when the font selected into the hdc
              is a Hebrew or Arabic font. The default reading order for all text is left to right.
            </description>
          </item>
          <item>
            <term>DT_SINGLELINE</term>
            <description>Displays text on a single line only. Carriage returns and linefeeds do not break the line.</description>
          </item>
          <item>
            <term>DT_TABSTOP</term>
            <description>
              Sets tab stops. Bits 15-8 (high-order byte of the low-order word) of the uFormat
              parameter specify the number of characters for each tab. The default number of characters per tab is eight.
            </description>
          </item>
          <item>
            <term>DT_TOP</term>
            <description>Top-justifies text (single line only).</description>
          </item>
          <item>
            <term>DT_VCENTER</term>
            <description>Centers text vertically (single line only).</description>
          </item>
          <item>
            <term>DT_WORDBREAK</term>
            <description>
              Breaks words. Lines are automatically broken between words if a word would extend past the edge of the rectangle
              specified by the lpRect parameter. A carriage return-linefeed sequence also breaks the line.
            </description>
          </item>
          <item>
            <term></term>
            <description></description>
          </item>
          <item>
            <term></term>
            <description></description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:VO.FixedText.SetStandardStyle(XSharp.__Usual)">
      <summary>
        Set the alignment style for the text in a FixedText object.
      </summary>
      <param name="kTextStyle">
        The text alignment style, specified as one of the following constants:
        <list type="Table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>FT_CENTERED</term><description>Centered text</description></item><item><term>FT_LEFTALIGN</term><description>Left-aligned text (This is the default.)</description></item><item><term>FT_RIGHTALIGN</term><description>Right-aligned text</description></item></list></param>
    </member>
    <member name="T:VO.FocusChangeEvent">
      <summary>
        Provide information about a FocusChangeEvent, used to indicate a change in window focus (i.e., gaining or losing focus).
      </summary>
      <remarks>
        When a window comes in or out of focus, the dispatcher generates a FocusChangeEvent and sends it to Window:FocusChange().  When the input focus changes, the window losing the focus gets a FocusChangeEvent (telling it that it is losing the focus) and the window gaining the focus receives a FocusChangeEvent (telling it that it is gaining the focus).
        A window that has focus gets KeyEvents when the user hits the keyboard.  This is similar to an active window, but an active window receives MouseEvents instead of KeyEvents.
        Tip:  Applications using cursors should use FocusChangeEvent to determine whether to create or destroy the cursor.
      </remarks>
      <example>
        The following example locks the attached data server when the window gets focus:
        <code language="X#">
          METHOD FocusChange(oFCE) CLASS TopAppWindow
          IF(oFCE:GotFocus)
          Server:RLock()
          ELSE
          Server:Unlock()
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.FocusChangeEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.FocusChangeEvent.GotFocus">
      <summary>
        A logical value determining whether a window has either gained keyboard focus (TRUE) or is about to lose it (FALSE).
      </summary>
      <value>A logical value determining whether a window has either gained keyboard focus (TRUE) or is about to lose it (FALSE).</value>
    </member>
    <member name="T:VO.Font">
      <summary>
        Create a font, which describes how characters are displayed on a window.
      </summary>
      <remarks>
        X# provides a set of predefined fonts, defined with the Font:Init() method.  In addition, if desired, you can also create a font by specifying a particular size and style.)
        Although you supply specifics for a new font, the GUI actually picks an actual font which best fits the description provided.
        Each window has a currently selected font.  Window:TextPrint() and Window:SizeText() use this font when they are printing or sizing text.
        <note type="tip">
          Deselecting a Font:	In Windows, the current font should be deselected before destroying the window.  To do this, use Window:Font to assign the previous font, for example.  However, this is only necessary if there is a font other than the default one currently selected.
          Font Pitch:	A font's pitch can be either variable or fixed.  In variable pitch fonts, characters are proportionally spaced (for example, a variable pitch font uses more space to print an "M" than an "i").  In fixed pitch fonts, the same amount of space is used by each character, regardless of the character width.  Fixed pitch fonts are most commonly used by terminals and typewriters or to display program text.
          Variable pitched fonts are not always supported.  This is dependent on the individual font.
        </note></remarks>
      <example>
        The following text illustrates how to write some text in italics:
        <code language="X#">
          ...
          oMyFont := Font{FONTROMAN10}
          oMyFont:Italic := TRUE
          oOldFont := oMyWindow:Font
          oMyWindow:Font := oMyFont
          oMyWindow:TextPrint("Italic text",Point{10,10})
          oMyWindow:Font := oOldFont
        </code></example>
    </member>
    <member name="M:VO.Font.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a font.
      </summary>
      <param name="kFont">The standard font to be created, specified as one of the constants in the table in the remarks section or the 
        constant that indicates the font family.  Specify one of the following constants:</param>
      <param name="oDimension">The dimension of the font in canvas coordinates or the windows point size for the font.</param>
      <param name="sTypeFace">The specific font name.</param>
      <remarks>
        <list type="table">
          <listheader>
            <term>kStandardFont</term>
            <description>Point Size/Font</description>
          </listheader>
          <item>
            <term>FONTMODERN8</term>
            <description>8 point Courier</description>
          </item>
          <item>
            <term>FONTMODERN10</term>
            <description>10 point Courier</description>
          </item>
          <item>
            <term>FONTMODERN12</term>
            <description>12 point Courier</description>
          </item>
          <item>
            <term>FONTROMAN8</term>
            <description>8 point Times Roman</description>
          </item>
          <item>
            <term>FONTROMAN10</term>
            <description>10 point Times Roman</description>
          </item>
          <item>
            <term>FONTROMAN12</term>
            <description>12 point Times Roman</description>
          </item>
          <item>
            <term>FONTROMAN14</term>
            <description>14 point Times Roman</description>
          </item>
          <item>
            <term>FONTROMAN18</term>
            <description>18 point Times Roman</description>
          </item>
          <item>
            <term>FONTROMAN24</term>
            <description>24 point Times Roman</description>
          </item>
          <item>
            <term>FONTSWISS8</term>
            <description>8 point Helvetica</description>
          </item>
          <item>
            <term>FONTSWISS10</term>
            <description>10 point Helvetica</description>
          </item>
          <item>
            <term>FONTSWISS12</term>
            <description>12 point Helvetica</description>
          </item>
          <item>
            <term>FONTSWISS14</term>
            <description>14 point Helvetica</description>
          </item>
          <item>
            <term>FONTSWISS18</term>
            <description>18 point Helvetica</description>
          </item>
          <item>
            <term>FONTSWISS24</term>
            <description>24 point Helvetica</description>
          </item>
          <item>
            <term>FONTSYSTEM8</term>
            <description>8 point default system font</description>
          </item>
          <item>
            <term></term>
            <description></description>
          </item>
        </list>
        <list type="table">
          <listheader>
            <term>kFamiliy</term>
            <description>Font Family</description>
          </listheader>
          <item>
            <term>FONTANY</term>
            <description>Any displayable font.  This is the default.   </description>
          </item>
          <item>
            <term>FONTDECORATIVE</term>
            <description>A system-dependent decorative font, e.g. FormalScrp421 BT.</description>
          </item>
          <item>
            <term>FONTMODERN</term>
            <description>Similar to Courier. </description>
          </item>
          <item>
            <term>FONTROMAN</term>
            <description>Similar to Times Roman</description>
          </item>
          <item>
            <term>FONTSCRIPT</term>
            <description>Similar to script handwriting,e.g. BrushScript</description>
          </item>
          <item>
            <term>FONTSWISS</term>
            <description>Similar to Helvetica.</description>
          </item>
        </list>

        Defining what font you want is potentially complicated, for two reasons:  different computers may have different sets of
        fonts installed and the same font may have different names on different computers.  For
        example, the Helvetica font family which looks like this: Helvetica, is known as Helv, Helvetica, Arial, Swiss or MS Sans Serif,
        depending on what system you are using.  The standard name for this font here is FontSwiss.
        To ensure that a program will work, regardless of what fonts are available on each computer, the Font class provides automatic methods
        for finding a reasonable match to the font you specify.
        In practice, however, as long as you use the most common names you will not have a problem since all versions of Windows
        contain the standard fonts.
        For example, to create a font of 10 pt Times New Roman and one of 8 pt Helvetica:
        <code language="X#">
          oFontRoman := Font{FONTROMAN10}	//
          oFontSwiss := Font{FONTSWISS8}		//
        </code>
        The system allows you to reference any font installed on the machine.  For example, to create a font of 12 pt Palatino,
        <code language="X#">oMyFont := Font{,Dimension{12,12},"Palatino"}	// </code>
        Or a font of 16 pt Arial:
        <code language="X#">oMyFont := Font{, 16, "Arial"}   // </code>
        That approach, of course, is vulnerable to the font not being available.  If Palatino is not available, the system would choose a reasonable facsimile, and if it had never heard of Palatino, this might not be a good match.  To help the system come up with a reasonable match, you can specify what font family Palatino belongs to:
        <code language="X#">oMyFont := Font{FONTROMAN, Dimension{12,12},"Palatino"}</code>
        In this case, we would get Times Roman if Palatino was not available.
        You can specify the family only.  For example, to create a 10 pt font in whatever is available in the script family:
        <code language="X#">oMyFont := Font{FONTSCRIPT,Dimension{10,10}}</code></remarks>
    </member>
    <member name="P:VO.Font.Bold">
      <summary>
        A logical value determining whether a font is displayed in a bold typeface (TRUE if yes; otherwise, FALSE).
      </summary>
      <value>A logical value determining whether a font is displayed in a bold typeface (TRUE if yes; otherwise, FALSE).</value>
      <remarks>
        <note type="tip">Only one of Font:Light, Font:Normal, and Font:Bold properties can be TRUE for any font.</note>
      </remarks>
    </member>
    <member name="P:VO.Font.CharSet">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Font.ClipPrecision">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.Font.ConvPntToDim(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Convert a specified point size for the font into a Dimension object.
      </summary>
      <param name="nPntSize">Windows font point size.</param>
      <param name="hDCConv">Handle of the device-context for which to convert the point size.  If omitted, defaults to the window canvas.</param>
      <returns>
        The Dimension object representing the specified point size.
      </returns>
      <remarks>
        This method converts a Windows font point size to the appropriate X# Dimension object for drawing on a window canvas.
      </remarks>
    </member>
    <member name="M:VO.Font.Create(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="lPrinter">** missing parameter documentation **</param>
      <param name="hdc">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.Font.Destroy">
      <summary>
        Provide a method to de-instantiate a Font object.
      </summary>
      <remarks>
        This method can be used when a Font object is no longer needed.  Font:Destroy() de-instantiates the Font object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="P:VO.Font.Escapement">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Font.FaceName">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.Font.Handle">
      <summary>
        Return the handle for a font.
      </summary>
      <param name="nHandleType">The type of handle required.  0 is the only supported option and is the default if &lt;nHandleType&gt; is omitted.</param>
      <returns>
        A handle describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
      </remarks>
    </member>
    <member name="P:VO.Font.Height">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Font.Italic">
      <summary>
        A logical value determining whether a font is displayed in a italic typeface (TRUE if yes; otherwise, FALSE).
      </summary>
      <value>A logical value determining whether a font is displayed in a italic typeface (TRUE if yes; otherwise, FALSE).</value>
    </member>
    <member name="P:VO.Font.Light">
      <summary>
        A logical value determining whether a font is displayed in a light typeface (TRUE if yes; otherwise, FALSE).  Light is the opposite of bold.
      </summary>
      <value>A logical value determining whether a font is displayed in a light typeface (TRUE if yes; otherwise, FALSE).  Light is the opposite of bold.</value>
      <remarks>
        <note type="tip">Only one of Font:Light, Font:Normal, and Font:Bold properties can be TRUE for any font.</note>
      </remarks>
    </member>
    <member name="P:VO.Font.Normal">
      <summary>
        A logical value determining whether a font is displayed in a normal typeface (TRUE if yes; otherwise, FALSE).
      </summary>
      <value>A logical value determining whether a font is displayed in a normal typeface (TRUE if yes; otherwise, FALSE).</value>
      <remarks>
        <note type="tip">Only one of Font:Light, Font:Normal, and Font:Bold properties can be TRUE for any font.</note>
      </remarks>
    </member>
    <member name="P:VO.Font.Orientation">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Font.OutPrecision">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Font.PitchAndFamily">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Font.PitchFixed">
      <summary>
        A logical value determining whether a font is displayed in a fixed pitch typeface (TRUE if yes; otherwise, FALSE).
      </summary>
      <value>A logical value determining whether a font is displayed in a fixed pitch typeface (TRUE if yes; otherwise, FALSE).</value>
      <remarks>
        <note type="tip">Either the Font:PitchFixed or Font:PitchVariable property can be TRUE for any font, but not both properties.</note>
      </remarks>
    </member>
    <member name="P:VO.Font.PitchVariable">
      <summary>
        A logical value determining whether a font is displayed in a variable pitch typeface (TRUE if yes; otherwise, FALSE).
      </summary>
      <value>A logical value determining whether a font is displayed in a variable pitch typeface (TRUE if yes; otherwise, FALSE).</value>
      <remarks>
        <note type="tip">Either the Font:PitchFixed or Font:PitchVariable property can be TRUE for any font, but not both properties.</note>
      </remarks>
    </member>
    <member name="P:VO.Font.PointSize">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Font.Quality">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Font.Size">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.Font.SizeText(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="cString">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.Font.Strikethru">
      <summary>
        A logical value determining whether a font is displayed in a strikethrough typeface (TRUE if yes; otherwise, FALSE).  A strikethough typeface places a line through every character.
      </summary>
      <value>A logical value determining whether a font is displayed in a strikethrough typeface (TRUE if yes; otherwise, FALSE).  A strikethough typeface places a line through every character.</value>
    </member>
    <member name="P:VO.Font.Underline">
      <summary>
        A logical value determining whether a font is displayed in an underline typeface (TRUE if yes; otherwise, FALSE).
      </summary>
      <value>A logical value determining whether a font is displayed in an underline typeface (TRUE if yes; otherwise, FALSE).</value>
    </member>
    <member name="P:VO.Font.Weight">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Font.Width">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.FormattedTextObject">
      <summary>
        Provide a way to format a string specifying position (origin), font, and color.
      </summary>
      <remarks>
        A FormattedTextObject object has the same behavior as a TextObject object with the exception that it recognizes characters like tab (Chr(9)), carriage return (Chr(13)), and newline (Chr(10)), and is able to translate them appropriately.
        You can use FormattedTextObject:TabSize to change the default tab of a FormattedTextObject object and the Window:Draw() method to display it.
      </remarks>
      <example>
        This example uses a formatted text object to print "World" underneath "Hello":
        <code language="X#">
          oFT := FormattedTextObject{Point{10,10},"Hello" + Chr(10) + "World"}
          ?oFT
        </code></example>
    </member>
    <member name="M:VO.FormattedTextObject.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a FormattedTextObject object.
      </summary>
      <param name="oPoint">The origin of the FormattedTextObject object in canvas coordinates.  The default is Point{16, 16}.</param>
      <param name="cText">The text to be displayed in the FormattedTextObject object.</param>
      <param name="oFont">The font to be used by the FormattedTextObject object.  The default is the system font.</param>
      <param name="oColor">The color to be used by the FormattedTextObject object.  The default is the current window's color selection.  (Refer to the Color:Init() method for details on specifying a color.)</param>
    </member>
    <member name="M:VO.FormattedTextObject.Draw">
      <summary>
        Draw a FormattedTextObject object on a window.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <remarks>
        This method is invoked inside the system by Window:Draw().
      </remarks>
    </member>
    <member name="P:VO.FormattedTextObject.TabSize">
      <summary>
        A numeric value representing the tab size — in characters — for a FormattedTextObject object.  The default tab size is 8.
      </summary>
      <value>A numeric value representing the tab size — in characters — for a FormattedTextObject object.  The default tab size is 8.</value>
    </member>
    <member name="T:VO.FSError">
      <exclude />
    </member>
    <member name="M:VO.FSError.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <exclude />
    </member>
    <member name="T:VO.GroupBox">
      <summary>
        Create a group box, which can be used to group related controls together.
      </summary>
      <remarks>
        A group box is a single-line box with an appropriate title to identify the nature of the group.  It should be drawn around the related controls on the surface of a window and can contain a single or several sets of choices.
        Use the Init() method from TextControl to create a group box.  Also, the title of a group box can be changed using the TextValue assign method of TextControl.
        <note type="tip">
          CUA Style:  According to CUA guidelines, you should not use group boxes for a set of one or more push buttons or list boxes.  Rather, a group box would be more useful in a "Print File" dialog, for example, where a number of options — like a "Copies" edit control and a "Print Color" check box — can be grouped together.
        </note></remarks>
    </member>
    <member name="M:VO.GroupBox.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a group box.
      </summary>
      <param name="oOwner">The window that owns the group box.</param>
      <param name="xID">The unique ID of the group box (between 1 and 8000).</param>
      <param name="oPoint">The origin of the group box in canvas coordinates.</param>
      <param name="oDimension">The dimension of the group box in canvas coordinates.</param>
      <param name="cText">The caption of the group box.  The default is NULL_STRING.</param>
      <param name="lDataAware">A logical value specifying whether the group box is data aware.</param>
      <param name="nResourceID">The resource ID of the group box.</param>
    </member>
    <member name="M:VO.GroupBox.AsString">
      <summary>
        Return an identifying label for the group box.
      </summary>
      <remarks>
        GroupBox:AsString() presents the group box control as a recognizable string of the form &lt;ClassName&gt; - &lt;Caption&gt;.
      </remarks>
    </member>
    <member name="P:VO.GroupBox.CurrentText">
      <summary>
        This property is provided to override the inherited functionality from the TextControl class, as it does not apply to group boxes.
      </summary>
      <value>This property is provided to override the inherited functionality from the TextControl class, as it does not apply to group boxes.</value>
    </member>
    <member name="M:VO.GroupBox.Destroy">
      <summary>
        Provide a method to de-instantiate a GroupBox object.
      </summary>
      <remarks>
        This method can be used when a GroupBox object is no longer needed.  GroupBox:Destroy() de-instantiates the GroupBox object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="T:VO.HelpDisplay">
      <summary>
        Create a link to the help system in use.
      </summary>
      <remarks>
        The HelpDisplay class allows you to easily provide online help for your applications.  The help system resource provided by the GUI can remain in memory until the HelpDisplay object is deleted.  Therefore, before the application terminates, ensure that the HelpDisplay object is either deleted or goes out of scope.

        HelpDisplay provides a way to display help on a given topic.  However, the application still needs a means of determining which topic help is required.
        For large applications, most GUI style guides recommend that help commands be made available from the menu bar.  These commands can be trapped using the MenuCommandEvent handler, and the appropriate help information displayed in response.
        Another approach is to use push buttons to obtain help on specific topics.  Using a push button and the ButtonClick() event handler, you can program the application to display the relevant help information when the Help button is pressed.
        In practice, an application's Help facility should combine menu commands and buttons to provide help.

        Context-sensitive help means the user receives help specific to the current activity when the help key or mouse sequence is chosen.  For example, when responding to a dialog window, the user can want help for the control with the focus.
        X# applications can provide context-sensitive help for:
        Particular areas of the screen (such as the caption bar and canvas area)
        Menu commands
        Controls (like push buttons, edit controls, and toolbar buttons)
        To support a portable context-sensitive help system, X# provides the HelpRequestEvent class, the Window:HelpDisplay property, and the Window:HelpRequest() event handler method.  (HelpRequest() determines the source of the help trigger — that is, the particular item for which help is requested — and passes this information on to the GUI's help system.)
        Refer to the "GUI Classes" chapter in the Programmer's Guide for more information on programming an online help system for your application.
        <note type="tip">
          The EXPORTed variable DefaultPageOnContents is a LOGIC which defaults to TRUE. It is used to determine whether the default page should be shown when HelpContents is requested. If set to FALSE, 'HelpContents' will display the Contents tab but leave the current topic displayed. For HTML Help only.
        </note></remarks>
      <example>
        The following example handles two common menu commands, Help Index and Help Using Help:
        <code language="X#">
          CLASS MyWindow INHERIT TopAppWindow
          METHOD Init() CLASS MyWindow
            SUPER:Init()
            SELF:HelpDisplay := HelpDisplay{"mywind.hlp"}
          METHOD MenuCommand(oMCE) CLASS MyWindow
            LOCAL nItemID := oMCE:ItemID
            DO CASE
            CASE nItemID = IDM_MENU_HELP_INDEX_ID
               SELF:HelpDisplay:Show("HelpIndex")
            CASE nItemID = IDM_MENU_HELP_USINGHELP_ID
               SELF:HelpDisplay:Show("HelpOnHelp")
            OTHERWISE
               SUPER:MenuCommand(oMCE)
            ENDCASE
        </code></example>
    </member>
    <member name="M:VO.HelpDisplay.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a help display to be used for a specified help database.
      </summary>
      <param name="cFileName">The file name of the help database to which this help display should be connected.</param>
      <param name="oOwnerWindow">The window object which owns this help display, if any.</param>
      <param name="lWin32Processing">When TRUE this will tell X# to use the standard WIN32 help processing </param>
      <remarks>
        X#  2.8 has added support for the use of Standard Win32 help processing which is based on the WM_HELP message since Windows95. The default VO like online help is disabled in this mode. This means, that SHIFT-F1 and mouse help don’t work.
        On the other hand the Windows standard help cursor is full supported and the help button on a caption bar too. See: Window:EnableHelpButton() and Window:EnableHelpCursor()
        Also text popups are supported only in this mode.
      </remarks>
    </member>
    <member name="F:VO.HelpDisplay.DefaultPageOnContents">
      <exclude />
    </member>
    <member name="M:VO.HelpDisplay.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.HelpDisplay.EnableHTMLHelp(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="lEnable">** missing parameter documentation **</param>
      <param name="cPopUpTopic">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.HelpDisplay.HelpError">
      <summary>
        Determine if the previous HelpDisplay operation was successful.
      </summary>
      <returns>
        <para>One of the following constants, indicating the success or failure of the previously called HelpDisplay:</para>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>HDCANTOPENFILE</term>
            <description>The help operation could not open the help database.</description>
          </item>
          <item>
            <term>HDINVALIDKEY</term>
            <description>An invalid key was used for HelpDisplay:Show().</description>
          </item>
          <item>
            <term>HDOK</term>
            <description>The operation was successful.</description>
          </item>
          <item>
            <term>HDOUTOFMEMORY</term>
            <description>
              The operation failed due to insufficient memory or other system resources.
            </description>
          </item>
          <item>
            <term>HDUNKNOWN</term>
            <description>It was not possible to determine why the last operation failed.</description>
          </item>
        </list>
      </returns>
    </member>
    <member name="M:VO.HelpDisplay.Show(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Instruct the help system to provide the help topic associated with a given keyword.
      </summary>
      <param name="cKeyword">
        The keyword to look up in the application help file.  See table in the remarks section.
      </param>
      <param name="symLookupType">
        Controls the lookup type. The default is HH_KEYWORD_LOOKUP.  
        Is used to call up Associative links in the help file. Associative Links are not displayed in the index, keywords are. For HTML Help only.
        The second parameter symLookupType can also be a PTR to a _winHelpInfo structure, which is sent with a WM_HELP message.
      </param>
      <remarks>

        The following reserved keywords do not correspond to anything coded in your application help file.
        Instead, they are provided by the system to give you access to certain standard help features:


        <list><listheader><term>Reserved Keyword</term><description>Description</description></listheader><term>HelpIndex</term><description>Displays the Contents or Index topic (whichever was displayed last) as defined in the application help file.</description><term>HelpOnHelp</term><description>
            Displays the Contents topic as defined in your Windows help file (normally WINHELP.HLP, in which the Contents topic is How to Use Help).
            This is not available with .CHM help.
          </description><term>HelpSearch</term><description>
            Displays the Search tab in the help navigation pane.For HTML Help only.
          </description><term># followed by a number.</term><description>
            The number represents the ID for a test popup help. For HTML Help only and Win32Processing mode have to enabled.
          </description><term>~ followed by a keyword.</term><description>
            This forces a HH_ALINK_LOOKUP. Is used to call up Associative links in the help file. Associative Links are not displayed in the index, keywords are. For HTML Help only.
          </description></list></remarks>
      <returns>
        TRUE if the lookup action took place correctly; otherwise, FALSE.
        <note type="tip">A TRUE value does not imply the key was found.</note></returns>
      <remarks>
        GUIs behave differently when an invalid or unknown key is looked up.  Although most present an alert message to the user (something to the effect that the key could not be found), you should assume this behavior is undefined and ensure that the key being looked up exists in the help database.
      </remarks>
    </member>
    <member name="F:VO.HelpDisplay.Win32Processing">
      <exclude />
    </member>
    <member name="T:VO.HelpRequestEvent">
      <summary>
        Provide information about a HelpRequestEvent, used to describe the context and item combinations for which help is requested.  (This can be help for controls, menu commands, and specific areas of a window.)
      </summary>
    </member>
    <member name="M:VO.HelpRequestEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.HelpRequestEvent.HelpContext">
      <summary>
        A string representing the help context ID of the control that generated this control event.  This
      </summary>
      <value>A string representing the help context ID of the control that generated this control event.  This</value>
      <remarks>
        A string representing the help context ID of the control that generated this control event.  This ID is contained in the control's hyperlabel.
        <note type="tip">A help context ID indicates the place in the hypertext system where the system looks for help concerning this control.</note></remarks>
    </member>
    <member name="P:VO.HelpRequestEvent.HelpInfo">
      <summary>
        A pointer to a _winHelpInfo structure if the help request is generated from a WM_HELP message otherwise Null_Ptr.
      </summary>
      <value>A pointer to a _winHelpInfo structure if the help request is generated from a WM_HELP message otherwise Null_Ptr.</value>
    </member>
    <member name="P:VO.HelpRequestEvent.HelpType">
      <summary>
        A constant, indicating the type of item — menu, control, or window area — for which help was requested:
      </summary>
      <value>A constant, indicating the type of item — menu, control, or window area — for which help was requested:</value>
      <remarks>
        One of the following constants, indicating the type of item — menu, control, or window area — for which help was requested:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>HELPCONTROL</term><description>Help is requested for a control.</description></item><item><term>HELPMENU</term><description>Help is requested for a menu command.</description></item><item><term>HELPWINDOW</term><description>Help is requested for a window area or point on the canvas.</description></item><item><term>HELPINFO</term><description>Help request is generated from a WM_HELP message.</description></item></list></remarks>
    </member>
    <member name="P:VO.HelpRequestEvent.HyperLabel">
      <summary>
        The hyperlabel connected to the help request event.
      </summary>
      <value>The hyperlabel connected to the help request event.</value>
      <remarks>
        The hyperlabel connected to the help request event.  From the hyperlabel, you can retrieve additional information about the help request event — for example:
        <code language="X#">
          cCaption	:= oHelpRequestEvent:HyperLabel:Caption
          cDescription	:= oHelpRequestEvent:HyperLabel:Description
          cHelpContext	:= oHelpRequestEvent:HyperLabel:HelpContext
        </code></remarks>
    </member>
    <member name="P:VO.HelpRequestEvent.ItemID">
      <summary>
        A numeric value representing the ID of the item that the user has requested help on.
      </summary>
      <value>A numeric value representing the ID of the item that the user has requested help on.</value>
      <remarks>
        A numeric value representing the ID of the item that the user has requested help on.
        The exact meaning of this ID depends on the type of item:
        <list type="table"><listheader><term>Constant</term><description>ID Returned</description></listheader><item><term>HELPCONTROL</term><description>A unique ID for the control.</description></item><item><term>HELPMENU</term><description>A unique ID for the menu command.</description></item><item><term>HELPWINDOW</term><description>
              A unique ID for the window area. The HelpRequestEvent:WindowRegion access determines which area of the window the help pointer was
              located (could be system menu, border, canvas, unknown, etc.).
            </description></item></list></remarks>
    </member>
    <member name="P:VO.HelpRequestEvent.Position">
      <summary>
        The location of the mouse pointer in canvas coordinates.
      </summary>
      <value>The location of the mouse pointer in canvas coordinates.</value>
      <remarks>
        The location of the mouse pointer in canvas coordinates.
        This method is provided to support help requests of type HelpWindow (refer to the HelpRequestEvent:HelpType assign) to allow particular areas of the canvas to have distinct displays of help information.
        The HelpRequestEvent:WindowRegion access should be used to determine if the help pointer was on the canvas at the time.  The point returned is not relevant in other cases.
      </remarks>
    </member>
    <member name="P:VO.HelpRequestEvent.WindowRegion">
      <summary>
        A constant, indicating in which window area the help pointer was located when this HelpRequestEvent was generated:
      </summary>
      <value>A constant, indicating in which window area the help pointer was located when this HelpRequestEvent was generated:</value>
      <remarks>
        One of the following constants, indicating in which window area the help pointer was located when this HelpRequestEvent was generated:
        <note type="tip">The return value is only defined for HelpRequestEvents of type HelpWindow (refer to HelpRequestEvent:ItemID access).</note><list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>REGIONBORDER</term><description>The window border</description></item><item><term>REGIONCANVAS</term><description>A window area or point on the canvas</description></item><item><term>REGIONCAPTION</term><description>The caption of the window</description></item><item><term>REGIONMAXBOX</term><description>The maximize box</description></item><item><term>REGIONMENUBAR</term><description>A menu command</description></item><item><term>REGIONMINBOX</term><description>The minimize box</description></item><item><term>REGIONSIZEBOX</term><description>The size box</description></item><item><term>REGIONSYSTEMMENUBOX</term><description>The system menu</description></item><item><term>REGIONUNKNOWN</term><description>The help system cannot determine a localized context</description></item></list></remarks>
    </member>
    <member name="T:VO.HLError">
      <exclude />
    </member>
    <member name="M:VO.HLError.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <exclude />
    </member>
    <member name="T:VO.HorizontalScrollBar">
      <summary>
        Create a horizontal scroll bar that is independent of its owner window.
      </summary>
      <remarks>
        There are two types of horizontal scroll bars in X#: regular (created with CLASS HorizontalScrollBar) and window (created with the AppWindow:EnableHorizontalScroll() method).
        Both types have an owner window and can be manipulated using Window:HorizontalScroll().  However, a window horizontal scroll bar differs in that it automatically appears aligned along the bottom of its owner window's canvas area and also resizes itself according to the size of its owner window.
        A horizontal scroll bar allows the user to update a short integer numeric value by either moving the thumb position, clicking on the button at either end of the scroll bar to change the number by the designated ScrollBar:UnitSize, or by clicking in the interior of the scroll bar to change the number by the designated ScrollBar:BlockSize.  The minimum and maximum allowable numeric values are indicated by the Min and Max values for the Range object associated with the scroll bar.  The ScrollBar:Value access indicates the currently selected numeric value.  A scroll bar may be bound to a numeric field in a server.
        <note type="tip">By default, Window:HorizontalScroll() updates the thumb position (the marker on the scroll bar that can be dragged up or down, left or right) in the scroll bar.  If desired, you can change this by using your own implementation of this handler.</note>

        In Windows, horizontal scroll bars are equivalent to a scroll bar with the SBS_HORZ style.  They are normally specified in the resource entity as follows:
        <code language="X#">
          RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 120
          STYLE WS_POPUP | WS_DLGFRAME
          BEGIN
          CONTROL "", IDS_RED,   "scrollbar", SBS_HORZ, 10, 16, 100, 20
          CONTROL "", IDS_BLUE,  "scrollbar", SBS_HORZ, 10, 46, 100, 20
          CONTROL "", IDS_GREEN, "scrollbar", SBS_HORZ, 10, 76, 100, 20
          END
        </code></remarks>
    </member>
    <member name="M:VO.HorizontalScrollBar.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a horizontal scroll bar.
      </summary>
      <param name="oOwner">The window that owns the horizontal scroll bar.</param>
      <param name="xID">The unique ID of the horizontal scroll bar (between 1 and 8000).</param>
      <param name="oPoint">The origin of the horizontal scroll bar in canvas coordinates.</param>
      <param name="oDimension">The dimension of the horizontal scroll bar in canvas coordinates.</param>
      <param name="nResourceID">The resource ID of the horizontal scroll bar.</param>
    </member>
    <member name="M:VO.HorizontalScrollBar.Destroy">
      <summary>
        Provide a method to de-instantiate a HorizontalScrollBar object.
      </summary>
      <remarks>
        This method can be used when a HorizontalScrollBar object is no longer needed.  HorizontalScrollBar:Destroy() de-instantiates the HorizontalScrollBar object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="T:VO.HorizontalSelectionSlider">
      <summary>
        Create a horizontal selection slider control.
      </summary>
      <remarks>
        A horizontal selection slider is a control that contains a thumb, optional tick marks, and a selection bar.  The user can move the horizontal selection slider's thumb using either the mouse or the Direction keys.
      </remarks>
    </member>
    <member name="M:VO.HorizontalSelectionSlider.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a horizontal selection slider.
      </summary>
      <param name="oOwner">The window that owns the horizontal selection slider.</param>
      <param name="xID">The unique ID of the horizontal selection slider (between 1 and 8000).</param>
      <param name="nResourceID">The resource ID of horizontal selection slider.</param>
      <param name="oPoint">The origin of the horizontal selection slider in canvas coordinates.</param>
      <param name="oDimension">The dimension of the horizontal selection slider in canvas coordinates.</param>
    </member>
    <member name="T:VO.HorizontalSlider">
      <summary>
        Create a horizontal slider control.
      </summary>
      <remarks>
        A horizontal slider is a control that contains a thumb and optional tick marks.  The user can move the horizontal slider's thumb using either the mouse or the Direction keys.
      </remarks>
    </member>
    <member name="M:VO.HorizontalSlider.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a horizontal slider.
      </summary>
      <param name="oOwner">The window that owns the horizontal slider.</param>
      <param name="xID">The unique ID of the horizontal slider (between 1 and 8000).</param>
      <param name="nResourceID">The resource ID of horizontal slider.</param>
      <param name="oPoint">The origin of the horizontal slider in canvas coordinates.</param>
      <param name="oDimension">The dimension of the horizontal slider in canvas coordinates.</param>
    </member>
    <member name="T:VO.HorizontalSpinner">
      <summary>
        Create a spinner with horizontal arrow buttons.
      </summary>
      <remarks>
        A horizontal spinner is a pair of left- and right-pointing arrow buttons that can be clicked to change a value, such as a number displayed in another control.  A horizontal spinner can exist independently but is most often used with another control, referred to as the client.
      </remarks>
    </member>
    <member name="M:VO.HorizontalSpinner.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a horizontal spinner.
      </summary>
      <param name="oOwner">The window that owns the horizontal spinner.</param>
      <param name="xID">The unique ID of the horizontal spinner (between 1 and 8000).</param>
      <param name="nResourceID">The resource ID of the horizontal spinner.</param>
      <param name="oPoint">The origin of the horizontal spinner in canvas coordinates.</param>
      <param name="oDimension">The dimension of the horizontal spinner in canvas coordinates.</param>
      <param name="kStyle">The style of the horizontal spinner.</param>
    </member>
    <member name="T:VO.HotKey">
      <summary>
        Create a hot key.
      </summary>
      <remarks>
        A hot key is an object that can be applied to a hot key edit control to set a valid key combination for a window.  When the key combination is pressed, the given window is activated by the system.
      </remarks>
    </member>
    <member name="M:VO.HotKey.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a hot key.
      </summary>
      <param name="bKey">The virtual key code for the hot key.</param>
      <param name="lAlt">Specifies that the Alt key is to be used for the hot key.</param>
      <param name="lCtl">Specifies that the Ctl key is to be used for the hot key.</param>
      <param name="lShift">Specifies that the Shift key is to be used for the hot key.</param>
      <param name="lExt">Specifies that the extended key — the keys on the numeric key pad — is to be used for the hot key.  </param>
    </member>
    <member name="P:VO.HotKey.AltKey">
      <summary>
        A logical value that is TRUE if the Alt key is valid for the hot key.
      </summary>
      <value>A logical value that is TRUE if the Alt key is valid for the hot key.</value>
    </member>
    <member name="P:VO.HotKey.CtrlKey">
      <summary>
        A logical value that is TRUE if the Ctrl key is valid for the hot key.
      </summary>
      <value>A logical value that is TRUE if the Ctrl key is valid for the hot key.</value>
    </member>
    <member name="P:VO.HotKey.ExtendedKey">
      <summary>
        A logical value that is TRUE if an extended key is valid for the hot key.
      </summary>
      <value>A logical value that is TRUE if an extended key is valid for the hot key.</value>
    </member>
    <member name="P:VO.HotKey.Key">
      <summary>
        A virtual key code for the hot key.
      </summary>
      <value>A virtual key code for the hot key.</value>
    </member>
    <member name="P:VO.HotKey.ShiftKey">
      <summary>
        A logical value that is TRUE if the Shift key is valid for the hot key.
      </summary>
      <value>A logical value that is TRUE if the Shift key is valid for the hot key.</value>
    </member>
    <member name="T:VO.HotKeyEdit">
      <summary>
        Create a hot key edit.
      </summary>
      <remarks>
        A hot key edit is a control that can be used to apply a key combination to a window such that the window can be activated by the system when the combination is pressed.
      </remarks>
    </member>
    <member name="M:VO.HotKeyEdit.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a hot key edit.
      </summary>
      <param name="oOwner">The window that owns the hot key edit.</param>
      <param name="xID">The unique ID of the hot key edit (between 1 and 8000).</param>
      <param name="nResourceID">The resource ID of the hot key edit.</param>
      <param name="oPoint">The origin of the hot key edit in canvas coordinates.</param>
      <param name="oDimension">The dimension of the hot key edit in canvas coordinates.</param>
      <param name="kStyle">The style of the hot key edit.</param>
    </member>
    <member name="M:VO.HotKeyEdit.ApplyHotKey(XSharp.__Usual)">
      <summary>
        Apply the HotKey object associated with this control to a particular window.
      </summary>
      <param name="oWindow">The window to which the HotKey object will be applied.</param>
      <returns>
        A numeric value indicating the result of applying the HotKey object to the window.  The result can be one of the following values:
        <list><listheader><term>Value</term><description>Result</description></listheader><item><term>-1</term><description>The operation was unsuccessful because the HotKey object is invalid.</description></item><item><term>0</term><description>The operation was unsuccessful because the window is invalid.</description></item><item><term>1</term><description>The operation was successful, and no other window has the same HotKey object.</description></item><item><term>2</term><description>The operation was successful, but another window already has the same HotKey object.</description></item></list></returns>
    </member>
    <member name="M:VO.HotKeyEdit.Create">
      <summary>
        Creates the underlying window control for a X# hot key edit object.
      </summary>
      <returns>
        The window handle of the control, if successful.  A null handle (NULL_PTR) is returned if the control creation failed.
      </returns>
      <remarks>
        The Create() method creates the underlying window control for controls not loaded from a resource (i.e., designed with the Window Editor) but created at runtime.  Normally, it is not necessary to call Create() directly — CA-X# will create the object internally as soon as a window handle is needed.
      </remarks>
      <example>
        <code language="X#">
          Method CreateHotKeyEdit() class MyDataWindow
           local oHK as HotKeyEdit
          // Init creates the X# HotKeyEdit Object
           oHK := HotKeyEdit{self, 100, Point{10,10}, Dimension{100,20}}
          // Calling Create forces the Windows control to be created
           oHK:Create()
        </code>
      </example>
    </member>
    <member name="P:VO.HotKeyEdit.HotKey">
      <summary>
        The HotKey object associated with this hot key edit.
      </summary>
      <value>The HotKey object associated with this hot key edit.</value>
    </member>
    <member name="P:VO.HotKeyEdit.Rule">
      <summary>
        The HotKeyRule object associated with this hot key edit.
      </summary>
      <value>The HotKeyRule object associated with this hot key edit.</value>
    </member>
    <member name="T:VO.HotKeyRule">
      <summary>
        Create a hot key rule.
      </summary>
      <remarks>
        A hot key rule is an object that can be applied to a hot key edit control to define invalid key combinations for a window.  The hot key rule also defines how to modify the key combination when it is invalid.
      </remarks>
    </member>
    <member name="M:VO.HotKeyRule.#ctor">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.HotKeyRule.AltKeyInvalid">
      <summary>
        A logical value that is TRUE if the Alt key is invalid for the HotKey object.
      </summary>
      <value>A logical value that is TRUE if the Alt key is invalid for the HotKey object.</value>
    </member>
    <member name="P:VO.HotKeyRule.CtrlAltKeysInvalid">
      <summary>
        A logical value that is TRUE if the Ctrl+Alt key combination is invalid for the HotKey object.
      </summary>
      <value>A logical value that is TRUE if the Ctrl+Alt key combination is invalid for the HotKey object.</value>
    </member>
    <member name="P:VO.HotKeyRule.CtrlKeyInvalid">
      <summary>
        A logical value that is TRUE if the Ctrl key is invalid for the HotKey object.
      </summary>
      <value>A logical value that is TRUE if the Ctrl key is invalid for the HotKey object.</value>
    </member>
    <member name="P:VO.HotKeyRule.ShiftAltKeysInvalid">
      <summary>
        A logical value that is TRUE if the Shift+Alt key combination is invalid for the HotKey object.
      </summary>
      <value>A logical value that is TRUE if the Shift+Alt key combination is invalid for the HotKey object.</value>
    </member>
    <member name="P:VO.HotKeyRule.ShiftCtrlAltKeysInvalid">
      <summary>
        A logical value that is TRUE if the Shift+Alt+Ctrl key combination is invalid for the HotKey object.
      </summary>
      <value>A logical value that is TRUE if the Shift+Alt+Ctrl key combination is invalid for the HotKey object.</value>
    </member>
    <member name="P:VO.HotKeyRule.ShiftCtrlKeysInvalid">
      <summary>
        A logical value that is TRUE if the Shift+Ctrl key combination is invalid for the HotKey object.
      </summary>
      <value>A logical value that is TRUE if the Shift+Ctrl key combination is invalid for the HotKey object.</value>
    </member>
    <member name="P:VO.HotKeyRule.ShiftKeyInvalid">
      <summary>
        A logical value that is TRUE if the Shift key is invalid for the HotKey object.
      </summary>
      <value>A logical value that is TRUE if the Shift key is invalid for the HotKey object.</value>
    </member>
    <member name="P:VO.HotKeyRule.UnmodifiedKeysInvalid">
      <summary>
        A logical value that is TRUE if unmodified key combinations (no Shift, Alt, or Ctrl keys) are invalid for the HotKey object.
      </summary>
      <value>A logical value that is TRUE if unmodified key combinations (no Shift, Alt, or Ctrl keys) are invalid for the HotKey object.</value>
    </member>
    <member name="P:VO.HotKeyRule.UseAltKeyOnInvalid">
      <summary>
        A logical value that is TRUE if the Alt key is to be used when an invalid key combination is entered into the hot key edit.
      </summary>
      <value>A logical value that is TRUE if the Alt key is to be used when an invalid key combination is entered into the hot key edit.</value>
    </member>
    <member name="P:VO.HotKeyRule.UseCtrlKeyOnInvalid">
      <summary>
        A logical value that is TRUE if the Ctrl key is to be used when an invalid key combination is entered into the hot key edit.
      </summary>
      <value>A logical value that is TRUE if the Ctrl key is to be used when an invalid key combination is entered into the hot key edit.</value>
    </member>
    <member name="P:VO.HotKeyRule.UseExtendedKeyOnInvalid">
      <summary>
        A logical value that is TRUE if an extended key is to be used when an invalid key combination is entered into the hot key edit.
      </summary>
      <value>A logical value that is TRUE if an extended key is to be used when an invalid key combination is entered into the hot key edit.</value>
    </member>
    <member name="P:VO.HotKeyRule.UseShiftKeyOnInvalid">
      <summary>
        A logical value that is TRUE if the Shift key is to be used when an invalid key combination is entered into the hot key edit.
      </summary>
      <value>A logical value that is TRUE if the Shift key is to be used when an invalid key combination is entered into the hot key edit.</value>
    </member>
    <member name="T:VO.HTTPCgiContext">
      <summary>
        Create HTTP server applications that use the Common Gateway Interface (CGI).
      </summary>
    </member>
    <member name="M:VO.HTTPCgiContext.#ctor">
      <summary>
        Construct an HTTPCgiContext object.
      </summary>
    </member>
    <member name="M:VO.HTTPCgiContext.Close">
      <summary>
        Close a CGI session and do all necessary cleanup.
      </summary>
      <remarks>
        This method frees up all file handles and detaches the CGI process from its console.
      </remarks>
      <example>
        See the HTTPCgiContext:Write() example.
      </example>
    </member>
    <member name="M:VO.HTTPCgiContext.ReadClient">
      <summary>
        Read data from the body of a client's HTTP request.
      </summary>
      <param name="pBuffer">Pointer to the buffer area which is to receive the requested information. </param>
      <param name="nSize">Numeric value indicating the number of bytes available in the buffer. </param>
      <returns>
        TRUE, if the read operation was successful; otherwise, FALSE.
      </returns>
      <remarks>
        ReadClient() reads information from the body of the Web client's HTTP request.  It can be used to read data from an HTML form that uses the POST method.  The Init() method uses ReadClient() internally to read data for a POST request and stores them into the property, aArgs, which can be retrieved by the GetParams() method.
      </remarks>
    </member>
    <member name="M:VO.HTTPCgiContext.Write">
      <summary>
        Send the raw HTTP entity data to the client.
      </summary>
      <param name="cHTTPEntity">String containing data that has to be sent to the client's Internet browser.  If omitted, a line break, '&lt;br&gt;', is sent.</param>
      <returns>
        TRUE, if the write operation was successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sends data present in the given buffer to the client that made the request.
      </remarks>
      <example>
        The following CGI application displays the string, "Hello World", to the client's Internet browser:
        <code language="X#">
          FUNCTION Start
          LOCAL oCGI      AS HTTPCGIContext
          LOCAL cHtml     AS STRING
          LOCAL cValue  AS STRING
          oCGI := HTTPCGIContext{}
          cHtml := oCGI:HTTPMsg("Hello World")
          oCGI:Write(cHtml)
          oCGI:Close()
          RETURN
        </code></example>
    </member>
    <member name="M:VO.HTTPCgiContext.WriteClient">
      <summary>
        Send the raw HTTP entity data to the client.
      </summary>
      <param name="cHTTPEntity">String containing data that has to be sent to the client's Internet browser.</param>
      <returns>
        TRUE, if the write operation was successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sends data present in the given buffer to the client that made the request.
      </remarks>
    </member>
    <member name="M:VO.HTTPCgiContext.WriteContentFile">
      <summary>
        Send the raw HTTP header and data for the specified content type to the client.
      </summary>
      <param name="cFile">File name, including drive letter and path.</param>
      <param name="cType">Content type (e.g., 'image', 'text', or 'application').</param>
      <param name="cSubType">Content subtype (e.g., 'jpeg' or 'gif' if &lt;cType&gt; is 'image', 'zip' if &lt;cType&gt; is 'application', or 'html' if &lt;cType&gt; is 'text').</param>
      <returns>
        File size in bytes if the file has been found; otherwise, 0.
      </returns>
      <remarks>
        This method sends the specified content file and appropriate reply header to the client that made the request.
      </remarks>
      <example>
        The following CGI application can be used to create a download link for the client's Internet browser.  The appropriate HTML file might look like the following:
        <code language="X#">
          &lt;html&gt;
          &lt;body&gt;
          &lt;h1&gt;CGI Download Test&lt;/h1&gt;
          &lt;p&gt;&lt;a href="/voscript/votest.exe"&gt;
          Download file test.zip
          &lt;/a&gt;&lt;/p&gt;
          &lt;/body&gt;
          &lt;/html&gt;
        </code>
        Source code for votest.exe:
        <code language="X#">
          FUNCTION Start
          LOCAL oCGI      AS HTTPCGIContext
          LOCAL cFile     AS STRING
          LOCAL cRet	     AS STRING
          oCGI := HTTPCGIContext{}
          cFile := oCGI:GetServerVariable("PATH_TRANSLATED");
          + "\downloads\test.zip"
          IF File(cFile)
          oCGI:WriteContentFile(cFile, "application", "zip")
          ELSE
          cFile := FPathName()
          cRet  := "File " + cFile + "not found"
          oCGI:Write(oCGI:HTTPMsg(cRet))
          ENDIF
          oCGI:Close()
          RETURN
        </code>
        To test this application, simply type the following command line into the browser URL:
        <code language="X#">http://localhost/scripts/votest.exe</code></example>
    </member>
    <member name="M:VO.HTTPCgiContext.WriteImage">
      <summary>
        Send the raw HTTP header and data for a specified image file to the client.
      </summary>
      <param name="cFile">Image file name, including drive letter and path.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        WriteImage() sends the specified image file and appropriate reply header to the client that made the request.
      </remarks>
      <example>
        The following CGI application displays the image, "vo.jpg", to the client's Internet browser.  It can be tested by typing the following command line into the browser URL:
        <code language="X#">http://localhost/scripts/votest.exe</code>
        To hook the application into an HTML file, you can use following code:
        <code language="X#">
          &lt;html&gt;
          &lt;body&gt;
          &lt;h1&gt;CGI Application Test&lt;/h1&gt;
          &lt;img src="/scripts/votest.exe"&gt;
          &lt;/body&gt;
          &lt;/html&gt;
        </code>
        Source code for votest.exe:
        <code language="X#">
          FUNCTION Start
          LOCAL oCGI     AS HTTPCGIContext
          LOCAL cFile    AS STRING
          LOCAL cRet	     AS STRING
          oCGI := HTTPCGIContext{}
          cFile:=oCGI:GetServerVariable("PATH_TRANSLATED");
          +"\images\vo.jpg"
          IF File(cFile)
          oCGI:WriteImage(cFile)
          ELSE
          cFile := FPathName()
          cRet  := "File " + cFile + " not found"
          oCGI:Write(SELF:HTTPMsg(cRet))
          ENDIF
          oCGI:Close()
          RETURN
        </code></example>
    </member>
    <member name="T:VO.HTTPContextAbstract">
      <summary>
        Provide the base class from which Internet server applications can be created, using CGI (Common Gateway Interface) or ISAPI (Internet Server API).
      </summary>
    </member>
    <member name="M:VO.HTTPContextAbstract.#ctor">
      <summary>
        Construct an HTTPContextAbstract object.
      </summary>
    </member>
    <member name="P:VO.HTTPContextAbstract.BinRoot">
      <summary>
        The fully qualified directory of the Internet application (DLL or EXE).
      </summary>
      <value>The fully qualified directory of the Internet application (DLL or EXE).</value>
    </member>
    <member name="M:VO.HTTPContextAbstract.DelParamValue">
      <summary>
        Delete a specified parameter from an argument list passed to that request.
      </summary>
      <param name="cValueName">String containing the name of the parameter that has to be removed.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method removes the specified parameter from the argument list that was created based upon the current query string.
      </remarks>
    </member>
    <member name="P:VO.HTTPContextAbstract.Error">
      <summary>
        Number of the last error that occurred in the running application.
      </summary>
      <value>Number of the last error that occurred in the running application.</value>
    </member>
    <member name="M:VO.HTTPContextAbstract.GetBinRoot">
      <summary>
        Determine the absolute path name for the current CGI application.
      </summary>
      <returns>
        String containing the path name.
      </returns>
      <remarks>
        GetBinRoot() determines the fully specified path name, including drive letter, for the current CGI application.
      </remarks>
      <example>
        The following CGI application can be used as a spy program to retrieve the actual path name of the server:
        <code language="X#">
          FUNCTION Start
          LOCAL oCGI      AS HTTPCGIContext
          LOCAL cHtml     AS STRING
          LOCAL cValue    AS STRING
          oCGI := HTTPCGIContext{}
          cValue := oCGI:GetBinRoot()
          cHtml := oCGI:HTTPMsg("CGI script is started
          from: ";
          + cValue)
          oCGI:Write(cHtml)
          oCGI:Close()
          RETURN
        </code></example>
    </member>
    <member name="M:VO.HTTPContextAbstract.GetParams">
      <summary>
        Return arguments of the HTTP request.
      </summary>
      <returns>
        Array containing values and their names.
      </returns>
      <remarks>
        This method can be used to retrieve all arguments of the HTTP request as a two-dimensional array wherein each element contains a value pair of the following format:
        {&lt;cValueName&gt;, &lt;cValue&gt;}
      </remarks>
    </member>
    <member name="M:VO.HTTPContextAbstract.GetParamValue">
      <summary>
        Retrieve a specified parameter from an argument list passed to that request.
      </summary>
      <param name="cValueName">String containing the name of the sought after parameter.</param>
      <param name="nPosition">Integer value determining the occurrence of the parameter within the query string.  The default value is 1, if &lt;nPosition&gt; is not specified.</param>
      <returns>
        String containing the specified value, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        GetParamValue() parses all values of the query string and returns the value of &lt;nPosition&gt;, i.e., the nth occurrence of &lt;cValueName&gt; within the query string.
      </remarks>
      <example>
        The following CGI application can be used as a script for HTML form processing in order to display the value, "value1", within the Internet browser:
        <code language="X#">
          FUNCTION Start
          LOCAL oCGI      AS HTTPCGIContext
          LOCAL cHtml     AS STRING
          LOCAL cValue    AS STRING
          oCGI := HTTPCGIContext{}
          cValue := oCGI:GetParamValue("value1")
          cHtml := oCGI:HTTPMsg("Value1 is :" + cValue)
          oCGI:Write(cHtml)
          oCGI:Close()
          RETURN
        </code></example>
    </member>
    <member name="M:VO.HTTPContextAbstract.GetServerVariable">
      <summary>
        Retrieve a specified environment value of the current Internet server.
      </summary>
      <param name="cValueName">String containing the name of the sought after environment variable.</param>
      <returns>
        String containing the specified value, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        GetServerVariable() returns the current environment setting specified by &lt;cValueName&gt;.
      </remarks>
      <example>
        The following CGI application can be used to display the environment value, PATH_TRANSLATED:
        <code language="X#">
          FUNCTION Start
          LOCAL oCGI      AS HTTPCGIContext
          LOCAL cHtml     AS STRING
          LOCAL cValue    AS STRING
          oCGI := HTTPCGIContext{}
          cValue := oCGI:GetServerVariable("PATH_TRANSLATED")
          cHtml:=oCGI:HTTPMsg("PATH_TRANSLATED is :" + ;
          Value)
          oCGI:Write(cHtml)
          oCGI:Close()
          RETURN
        </code></example>
    </member>
    <member name="M:VO.HTTPContextAbstract.HTTPErrorMessage">
      <summary>
        Create HTML code to display all values of a  error object.
      </summary>
      <param name="oError">Current error object instance.</param>
      <returns>
        String containing HTML code for displaying the error within an Internet browser.
      </returns>
      <remarks>
        This method creates HTML code based on the values of a X# error object.
      </remarks>
      <example>
        The following example demonstrates how to catch runtime errors and display them within the browser:
        <code language="X#">
          FUNC Start()
          LOCAL oCGI      AS HTTPCGIContext
          LOCAL cHtml     AS STRING
          LOCAL cValue	AS STRING
          LOCAL oOldError AS USUAL
          LOCAL oError    AS USUAL
          LOCAL x
          oCGI := HTTPCgiContext{}
          oOldError := ErrorBlock( {|oErr| ;	__MyError(oErr)} )
          BEGIN SEQUENCE
          x := 0
          cHtml += x // error occurs here
          RECOVER USING oError
          cHtml := oCGI:HTTPErrorMessage(oError)
          END SEQUENCE
          ErrorBlock( oOldError )
          oCGI:Write(cHtml)
          oCGI:Close()
          RETURN
          STATIC FUNC __MyError   (oError)
          LOCAL cRepl AS STRING
          cRepl := "Module " + ProcName(1)
          cRepl += ", line " + NTrim(ProcLine(1))
          IF SLen(oError:Description)&gt; 0
          oError:Description += "(" + cRepl + ")"
          ELSE
          oError:Description := cRepl
          ENDIF
          _Break(oError)
        </code></example>
    </member>
    <member name="M:VO.HTTPContextAbstract.HTTPMsg">
      <summary>
        Create HTML code to display a specified message.
      </summary>
      <param name="cMsg">Message to be displayed.</param>
      <returns>
        String containing HTML code for displaying a message within an Internet browser.
      </returns>
      <remarks>
        HTTPMsg() creates HTML code to display a specified message.
      </remarks>
      <example>
        See the HTTPContextAbstract:GetServerVariable() example.
      </example>
    </member>
    <member name="M:VO.HTTPContextAbstract.HTTPRequestItems">
      <summary>
        Create HTML code to display all items of an query string.
      </summary>
      <returns>
        String containing HTML code for displaying all items of the query string.
      </returns>
      <remarks>
        HTTPRequestItems() creates HTML code to display all items of the query string.
      </remarks>
      <example>
        The following CGI application can be used to debug the items for a form-processing request:
        <code language="X#">
          FUNCTION Start
          LOCAL oCGI      AS HTTPCGIContext
          LOCAL cHtml     AS STRING
          oCGI := HTTPCGIContext{}
          cHtml := oCGI:HTTPRequestItems()
          oCGI:Write(cHtml)
          oCGI:Close()
          RETURN
        </code></example>
    </member>
    <member name="M:VO.HTTPContextAbstract.HTTPServerVariables">
      <summary>
        Create HTML code to display all environment variables of the Internet server.
      </summary>
      <returns>
        String containing HTML code to display all environment variables.
      </returns>
      <example>
        The following CGI application can be used to display the server's environment:
        <code language="X#">
          FUNCTION Start
          LOCAL oCGI      AS HTTPCGIContext
          LOCAL cHtml     AS STRING
          oCGI := HTTPCGIContext{}
          cHtml := oCGI:HTTPServerVariables()
          oCGI:Write(cHtml)
          oCGI:Close()
          RETURN
        </code>

        HTTPContextAbstract:HTTPErrorMessage(), HTTPContextAbstract:HTTPMsg(), HTTPContextAbstract:HTTPRequestItems()
      </example>
    </member>
    <member name="P:VO.HTTPContextAbstract.QueryString">
      <summary>
        Query string of the HTTP request.
      </summary>
      <value>Query string of the HTTP request.</value>
    </member>
    <member name="P:VO.HTTPContextAbstract.ServerPath">
      <summary>
        The fully qualified directory name of the server's home directory.
      </summary>
      <value>The fully qualified directory name of the server's home directory.</value>
    </member>
    <member name="M:VO.HTTPContextAbstract.SetParamValue">
      <summary>
        Change or add a specified parameter of the argument list passed to that request.
      </summary>
      <param name="cValueName">String containing the name of the parameter.</param>
      <param name="cValue">New value.</param>
      <param name="nPosition">Integer value determining the occurrence of the parameter within the query string.  The default value is 1, if &lt;nPosition&gt; is not specified.</param>
      <returns>
        TRUE, if the value has been changed; otherwise, FALSE.
      </returns>
      <remarks>
        This method parses all values of the query string and changes the value of &lt;nPosition&gt;, i.e., the nth occurrence of &lt;cValueName&gt; within the query string.  If the appropriate value name is not found, a new value is added to that list.
      </remarks>
      <example>
        The following CGI application can be used as a script for HTML form processing in order to display the value, "value1", within the Internet browser:
        <code language="X#">
          FUNCTION Start
          LOCAL oCGI      AS HTTPCGIContext
          LOCAL cHtml     AS STRING
          LOCAL cValue    AS STRING
          oCGI := HTTPCGIContext{}
          IF oCGI:SetParamValue("xyz", "123")
          CValue := oCGI:GetParamValue("xyz")
          cHtml:=oCGI:HTTPMsg("Value xyz changed" + ;
          "to :" + cValue)
          ELSE
          CValue := oCGI:GetParamValue("xyz")
          CHtml := oCGI:HTTPMsg("New value is :" ;
          + cValue)
          ENDIF
          oCGI:Write(cHtml)
          oCGI:Close()
          RETURN
        </code></example>
    </member>
    <member name="T:VO.HTTPExtensionContext">
      <summary>
        Create HTTP server applications that use Microsoft's Internet Information Server API (ISAPI).
      </summary>
      <remarks>
        This class defines the common protocol -- properties and behavior — for the various X# HTTP server applications that use ISAPI (Internet Server API).
      </remarks>
    </member>
    <member name="M:VO.HTTPExtensionContext.#ctor">
      <summary>
        Construct an HTTPExtensionContext object.
      </summary>
      <param name="pExtControlBlock">Pointer to a _WINEXTENSION_CONTROL_BLOCK structure containing all data for the request to an ISAPI DLL.</param>
      <remarks>
        An HTTPExtensionContext object can only be created within the entry point function, HttpExtensionProc(), of an ISAPI extension DLL.  The Init() method requires a valid &lt;pExtControlBlock&gt; pointer, because the HTTPExtensionContext class is a layer for the ISAPI callback functions contained in the _WINEXTENSION_CONTROL_BLOCK structure.
      </remarks>
      <example>
        The following function can be used to create an ISAPI DLL (votest.dll) for displaying the string, "Hello World", to the client's Internet browser:
        <code language="X#">
          FUNC HttpExtensionProc( pECB AS ;
          WINEXTENSION_CONTROL_BLOCK);
          AS DWORD PASCAL
          //
          //  Entry point for all ISAPI requests
          //
          LOCAL cHtml     AS STRING
          LOCAL nRet      AS DWORD
          LOCAL oISAPI    AS StdHTTPContext
          oISAPI:= StdHTTPContext{pECB}
          cHtml := oISAPI:HTTPMsg("Hello World")
          IF oISAPI:Write(cHtml)
          nRet := HSE_STATUS_SUCCESS
          ELSE
          nRet := oISAPI:StatusCode
          ENDIF
          RETURN nRet
        </code>
        The appropriate HTML file might look like the following:
        <code language="X#">
          &lt;html&gt;
          &lt;body&gt;
          &lt;h1&gt;ISAPI DLL Test&lt;/h1&gt;
          &lt;p&gt;&lt;a href="/voscript/votest.dll"&gt;
          Click here to start the DLL
          &lt;/a&gt;&lt;/p&gt;
          &lt;/body&gt;
          &lt;/html&gt;
        </code></example>
    </member>
    <member name="P:VO.HTTPExtensionContext.ECB">
      <summary>
        Pointer to a _WINEXTENSION_CONTROL_BLOCK structure.
      </summary>
      <value>Pointer to a _WINEXTENSION_CONTROL_BLOCK structure.</value>
    </member>
    <member name="M:VO.HTTPExtensionContext.GetServerVariable">
      <summary>
        Retrieve a specified environment value from the current Internet server.
      </summary>
      <param name="cValueName">String containing the name of the sought after environment variable.</param>
      <returns>
        String containing the specified value if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        GetServerVariable() returns the current environment setting specified by &lt;cValueName&gt;.
      </remarks>
      <example>
        See the HTTPContextAbstract:GetServerVariable() example.
      </example>
    </member>
    <member name="M:VO.HTTPExtensionContext.ReadClient">
      <summary>
        Read data from the body of a client's HTTP request.
      </summary>
      <param name="pBuffer">Pointer to the buffer area which is to receive the requested information. </param>
      <param name="nSize">Numeric value indicating the number of bytes available in the buffer. </param>
      <returns>
        TRUE, if the read operation was successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.HTTPExtensionContext.ServerSupportFunction">
      <summary>
        Provide auxiliary functionality to the HTTP response DLL.
      </summary>
      <param name="nRequest">A DWORD value containing the HTTP Server Extension Request (HSER) type, which indicates the requested functions by the ISAPI application.  Valid values are:</param>
      <param name="pBuffer">Pointer to the buffer that contains the primary argument required for the requested support function.</param>
      <param name="nSize">Numeric value indicating the number of bytes available in the buffer.  Defaults to the length of &lt;pBuffer&gt;.</param>
      <param name="cData">String containing data for secondary arguments.</param>
      <returns>
        TRUE, if the value has been changed; otherwise, FALSE.
      </returns>
      <remarks>
        This method provides several support functions that are not covered directly by the standard callback functions of the _WINEXTENSION_CONTROL_BLOCK structure.
      </remarks>
      <example>
        The following function can be used to create an ISAPI DLL (votest.dll) for displaying translated path names for different alias names:
        <code language="X#">
          FUNC HttpExtensionProc(pECB AS ;
          WINEXTENSION_CONTROL_BLOCK);
          AS DWORD PASCAL
          //
          //  Entry point for all ISAPI requests
          //
          LOCAL cHtml     		AS STRING
          LOCAL nRet      		AS DWORD
          LOCAL oISAPI    		AS StdHTTPContext
          LOCAL DIM abTemp[256] 	AS BYTE
          LOCAL cTemp		AS STRING
          oISAPI:= StdHTTPContext{pECB}
          cTemp := oISAPI:QueryString
          MemCopy(@abTemp[1], PTR(_CAST, cTemp),;
          SLen(cTemp) + 1)
          IF oISAPI:ServerSupportFunction( ;
          HSE_REQ_MAP_URL_TO_PATH, @abTemp[1], 256, "")
          cHtml := "The path for " + cTemp + " is " + ;
          Psz2String(@abTemp[1])
          ELSE
          cHtml:="Error calling ServerSupportFunction()"
          ENDIF
          cHtml := oISAPI:HTTPMsg(cHtml)
          IF oISAPI:Write(cHtml)
          nRet := HSE_STATUS_SUCCESS
          ELSE
          nRet := oISAPI:StatusCode
          ENDIF
          RETURN nRet
        </code>
        The appropriate HTML file might look like the following:
        <code language="X#">
          &lt;html&gt;
          &lt;body&gt;
          &lt;h1&gt;ISAPI DLL Test&lt;/h1&gt;
          &lt;p&gt;&lt;a href="/voscript/votest.dll&amp;/scripts"&gt;
          Display translated name for scripts
          &lt;/a&gt;&lt;/p&gt;
          &lt;/body&gt;
          &lt;/html&gt;
        </code></example>
    </member>
    <member name="P:VO.HTTPExtensionContext.StatusCode">
      <summary>
        Numeric value representing the HTTP status code.
      </summary>
      <value>Numeric value representing the HTTP status code.</value>
    </member>
    <member name="M:VO.HTTPExtensionContext.Write">
      <summary>
        Send the HTTP entity, including the response header, to the client.
      </summary>
      <param name="cHTTPEntity">String containing data that has to be sent to the client's Internet browser.</param>
      <returns>
        TRUE, if the write operation was successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sends a complete HTTP server response header — including the status, server version, message time, and MIME version — to the client followed by HTTP data specified by &lt;cHTTPEntity&gt;.
      </remarks>
      <example>
        See the HTTPExtensionContext:WriteClient() example.
      </example>
    </member>
    <member name="M:VO.HTTPExtensionContext.WriteClient">
      <summary>
        Send the raw HTTP entity data to a client.
      </summary>
      <param name="cHTTPEntity">String containing data that has to be sent to the client's Internet browser.</param>
      <param name="nFlag">
        A numeric value indicating how the I/O operation should be handled.  The following flags are supported:
        The I/O operation should be done synchronously.  This is the default value.
        The I/O operation should be done asynchronously.  The ISAPI application should have made a call to the ServerSupportFunction(HSE_REQ_IO_COMPLETION) method, and submitted a callback function and context value for handling completion of asynchronous operations.
      </param>
      <returns>
        TRUE, if the write operation was successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sends data present in the given buffer to the client that made the request.
      </remarks>
      <example>
        The following function can be used to create an ISAPI DLL (votest.dll) for displaying a specified image file:
        <code language="X#">
          FUNC HttpExtensionProcx( pECB AS ;
          WINEXTENSION_CONTROL_BLOCK) AS DWORD PASCAL
          LOCAL cHtml		AS STRING
          LOCAL nRet			AS DWORD
          LOCAL oISAPI		AS StdHTTPContext
          LOCAL cTemp		AS STRING
          LOCAL cContent		AS STRING
          LOCAL nSize		AS INT
          oISAPI:= StdHTTPContext{pECB}
          cTemp := oISAPI:QueryString
          IF File(cTemp)
          cContent := MemoRead(cTemp)
          nSize    := SLen(cContent)
          cHtml := "Content-type: image/" +;
          Lower(Right(cTemp,3)) + CRLF
          cHtml   += "Content-length: " + NTrim(nSize)
          Html   += CRLF + CRLF
          IF oISAPI:Write(cHtml)
          ISAPI:WriteClient(cContent)
          Ret := HSE_STATUS_SUCCESS
          ELSE
          nRet := oISAPI:StatusCode
          ENDIF
          ELSE
          cTemp  := FPathName()
          cHtml  := "File " + cTemp + " not found"
          cHtml  := oISAPI:HTTPMsg(cHtml)
          IF oISAPI:Write(cHtml)
          nRet := HSE_STATUS_SUCCESS
          ELSE
          nRet := oISAPI:StatusCode
          ENDIF
          ENDIF
          RETURN nRet
        </code>
        The appropriate HTML file might look like the following:
        <code language="X#">
          &lt;html&gt;
          &lt;body&gt;
          &lt;h1&gt;DLL Image Test&lt;/h1&gt;
          ...
          &lt;img src="/scripts/votest.dll?/vosample/vo.jpg"&gt;
          &lt;/body&gt;
          &lt;/html&gt;
        </code></example>
    </member>
    <member name="M:VO.HTTPExtensionContext.WriteContentFile">
      <summary>
        Send the HTTP header and data for a specified content type to the client.
      </summary>
      <param name="cFile">File name, including drive letter and path.</param>
      <param name="cType">Content type (e.g., 'image', 'text', or 'application').</param>
      <param name="cSubType">Content subtype (e.g., 'jpeg' or 'gif' if &lt;cType&gt; is 'image', 'zip' if &lt;cType&gt; is 'application', or 'html' if &lt;cType&gt; is 'text').</param>
      <returns>
        File size in bytes if the file has been found; otherwise, 0.
      </returns>
      <remarks>
        This method sends the specified content file and appropriate reply header to the client that made the request.
      </remarks>
      <example>
        See the HTTPCgiContext:WriteContentFile() example.
      </example>
    </member>
    <member name="M:VO.HTTPExtensionContext.WriteImage">
      <summary>
        Send the raw HTTP header and data for a specified image file to the client.
      </summary>
      <param name="cFile">Image file name, including drive letter and path.</param>
      <returns>
        File size in bytes if the file has been found; otherwise, 0.
      </returns>
      <remarks>
        This method sends the specified image file and appropriate reply header to the client that made the request.
      </remarks>
      <example>
        See the HTTPCgiContext:WriteImage() example.
      </example>
    </member>
    <member name="T:VO.HTTPFilterContext">
      <summary>
        Provide low-level access to the HTTP communication server.
      </summary>
      <remarks>
        The HTTPFilterContext class provides low-level access to the HTTP communication stream.  This class can be used, for example, to filter the data sent by a Web server to a client and exchange certain parts of that data in order to implement a page counter.
      </remarks>
    </member>
    <member name="M:VO.HTTPFilterContext.#ctor">
      <summary>
        Construct an HTTPFilterContext object.
      </summary>
      <param name="pFilterContext">Pointer to a _WINHTTP_FILTER_CONTEXT structure containing all data for the request to an ISAPI DLL.</param>
      <remarks>
        An HTTPFilterContext object can only be created within the entry point function, HttpFilterProc(), of an ISAPI extension DLL.  The Init() method requires a valid &lt;pFilterContext&gt; pointer, because the HTTPFilterContext class is a layer for ISAPI Filter Callback functions contained in the _WINHTTP_FILTER_CONTEXT structure.
      </remarks>
      <example>
        The following function can be used to create an ISAPI filter DLL:
        <code language="X#">
          CLASS MyFilter INHERIT HTTPFilterContext
          FUNC HttpFilterProc(pFCB  AS ;
          WINHTTP_FILTER_CONTEXT,;
          dwNotify AS DWORD,;
          pData AS PTR)  AS DWORD PASCAL
          LOCAL nRet      AS DWORD
          LOCAL oFilter   AS MyFilter
          oFilter := MyFilter{pFCB}
          DO CASE
          CASE dwNotify == SF_NOTIFY_URL_MAP
          nRet := oFilter:OnUrlMap(pData)
          CASE dwNotify == SF_NOTIFY_SEND_RAW_DATA
          nRet := oFilter:OnSendRawData(pData)
          CASE dwNotify == SF_NOTIFY_END_OF_NET_SESSION
          nRet := oFilter:OnEndSession(pFCB)
          CASE dwNotify == SF_NOTIFY_READ_RAW_DATA
          nRet := oFilter:OnReadRawData(pData)
          CASE dwNotify == SF_NOTIFY_PREPROC_HEADERS
          nRet :=oFilter:OnPreprocHeaders(pData)
          CASE dwNotify == SF_NOTIFY_LOG
          nRet := oFilter:OnLog(pData)
          CASE dwNotify == SF_NOTIFY_AUTHENTICATION
          nRet := oFilter:OnAuthentication(pData)
          OTHERWISE
          nRet := SF_STATUS_REQ_NEXT_NOTIFICATION
          ENDCASE
          RETURN nRet
        </code>
        The filter will be implemented by overwriting the OnUrlMap() and OnRawSendData() event handlers of the HTTPFilterContext class by the MyFilter class.
      </example>
    </member>
    <member name="M:VO.HTTPFilterContext.AddResponseHeaders">
      <summary>
        Add a header to an HTTP response.
      </summary>
      <param name="cNewHeader">String containing the headers to be added.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This call method is used to add a header to an HTTP response.
      </remarks>
    </member>
    <member name="M:VO.HTTPFilterContext.AllocMem">
      <summary>
        Allocate memory that has not been freed when the communication terminates.
      </summary>
      <param name="nBytes">Size of the memory buffer to allocate in bytes.</param>
      <returns>
        Pointer to an allocated buffer, if successful; otherwise, NULL_PTR.
      </returns>
      <remarks>
        This method allocates memory that has not been freed when the communication terminates.  The memory buffer will be freed automatically by the Internet Information Server (IIS) when the end-of-net-session occurs.
      </remarks>
    </member>
    <member name="P:VO.HTTPFilterContext.Error">
      <summary>
        Number of the last error that occurred in the running application.
      </summary>
      <value>Number of the last error that occurred in the running application.</value>
    </member>
    <member name="P:VO.HTTPFilterContext.FCB">
      <summary>
        Pointer to the _WINHTTP_FILTER_CONTEXT structure.
      </summary>
      <value>Pointer to the _WINHTTP_FILTER_CONTEXT structure.</value>
    </member>
    <member name="P:VO.HTTPFilterContext.FilterContext">
      <summary>
        Pointer to the pFilterContext member of the _WINHTTP_FILTER_CONTEXT structure.
      </summary>
      <value>Pointer to the pFilterContext member of the _WINHTTP_FILTER_CONTEXT structure.</value>
    </member>
    <member name="M:VO.HTTPFilterContext.GetServerVariable">
      <summary>
        Retrieve a specified environment value from the current Internet server.
      </summary>
      <param name="cValueName">String containing the name of the sought after environment variable.</param>
      <returns>
        String containing the specified value, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        This method returns the current environment setting specified by &lt;cValueName&gt;.
      </remarks>
      <example>
        See the HTTPContextAbstract:GetServerVariable() example.
      </example>
    </member>
    <member name="M:VO.HTTPFilterContext.OnAuthentication">
      <summary>
        Event handler method called by the filter DLL to authenticate the client.
      </summary>
      <param name="pFCB">Pointer to a _WINHTTP_FILTER_CONTEXT structure.</param>
      <returns>
        One of the following notification types:
        SF_STATUS_REQ_FINISHED
        The filter has handled the HTTP request.  The server should disconnect the session.
        SF_STATUS_REQ_FINISHED_KEEP_CONN
        Same as SF_STATUS_REQ_FINISHED, except the server should keep the TCP session open if the option was negotiated.
        SF_STATUS_REQ_NEXT_NOTIFICATION
        The next filter in the notification chain should be called.
        SF_STATUS_REQ_ERROR
        An error occurred.  The server should use the Win32 API SetLastError() function to indicate the error to the client.
        SF_STATUS_REQ_READ_NEXT
        The filter is an opaque stream filter; eegotiate the session parameters.  Only valid for raw read notification.
      </returns>
      <remarks>
        Override this method to implement your own authentication.  The default setting is inactive.
      </remarks>
    </member>
    <member name="M:VO.HTTPFilterContext.OnEndSession">
      <summary>
        Event handler method called by the filter DLL to notify the filter that the session is ending.
      </summary>
      <param name="pFilterContext">Pointer to a _WINHTTP_FILTER_CONTEXT structure.</param>
      <returns>
        One of the following notification types:
        SF_STATUS_REQ_FINISHED
        The filter has handled the HTTP request.  The server should disconnect the session.
        SF_STATUS_REQ_FINISHED_KEEP_CONN
        Same as SF_STATUS_REQ_FINISHED except the server should keep the TCP session open if the option was negotiated.
        SF_STATUS_REQ_NEXT_NOTIFICATION
        The next filter in the notification chain should be called.
        SF_STATUS_REQ_ERROR
        An error occurred.  The server should use the Win32 API SetLastError() function to indicate the error to the client.
        SF_STATUS_REQ_READ_NEXT
        The filter is an opaque stream filter; negotiate the session parameters.  Only valid for raw read notification.
        If unsuccessful, the notification type SF_STATUS_REQ_ERROR should be returned.  In this case, the server should use the Windows function, SetLastError(), to indicate the error to the client.
      </returns>
      <remarks>
        Override this method to provide your own end-of-session implementation.  The default setting is inactive.
      </remarks>
      <example>
        The following event handler writes an output debug string to the Win32 Debug Messages Window when the filter receives an SF_NOTIFY_END_OF_NET_SESSION notification:
        <code language="X#">
          METHOD  OnEndSession (pData)  CLASS MyFilter
          LOCAL nRet      AS DWORD
          LOCAL pContext  AS _WINHTTP_FILTER_CONTEXT
          nRet := SF_STATUS_REQ_NEXT_NOTIFICATION
          IF IsPtr(pData)
          pContext := pData
          ELSE
          RETURN nRet
          ENDIF
          DebOut32("Session ended " + AsString(pContext) )
          RETURN nRet
        </code></example>
    </member>
    <member name="M:VO.HTTPFilterContext.OnLog">
      <summary>
        Event handler method called by the filter DLL to notify the filter that the server is writing information to the server log.
      </summary>
      <param name="pFilterLog">Pointer to a _WINHTTP_FILTER_LOG structure.</param>
      <returns>
        One of the following notification types:
        SF_STATUS_REQ_FINISHED
        The filter has handled the HTTP request.  The server should disconnect the session.
        SF_STATUS_REQ_FINISHED_KEEP_CONN
        Same as SF_STATUS_REQ_FINISHED except the server should keep the TCP session open if the option was negotiated.
        SF_STATUS_REQ_NEXT_NOTIFICATION
        The next filter in the notification chain should be called.
        SF_STATUS_REQ_ERROR
        An error occurred.  The server should use the Win32 API SetLastError() function to indicate the error to the client.
        SF_STATUS_REQ_READ_NEXT
        The filter is an opaque stream filter; negotiate the session parameters.  Only valid for raw read notification.
        If unsuccessful, the notification type SF_STATUS_REQ_ERROR should be returned.  In this case, the server should use the Windows function, SetLastError(), to indicate the error to the client.
      </returns>
      <remarks>
        Override this method to provide your own method for logging information to the server file.  The default setting is inactive.
      </remarks>
    </member>
    <member name="M:VO.HTTPFilterContext.OnPreprocHeaders">
      <summary>
        Event handler method called by the filter DLL to notify the filter that the server has preprocessed the client headers.
      </summary>
      <param name="pHeaders">Pointer to a _WINHTTP_FILTER_PREPROC_HEADERS structure.</param>
      <returns>
        One of the following notification types:
        SF_STATUS_REQ_FINISHED
        The filter has handled the HTTP request.  The server should disconnect the session.
        SF_STATUS_REQ_FINISHED_KEEP_CONN
        Same as SF_STATUS_REQ_FINISHED except the server should keep the TCP session open if the option was negotiated.
        SF_STATUS_REQ_NEXT_NOTIFICATION
        The next filter in the notification chain should be called.
        SF_STATUS_REQ_ERROR
        An error occurred.  The server should use the Win32 API SetLastError() function to indicate the error to the client.
        SF_STATUS_REQ_READ_NEXT
        The filter is an opaque stream filter; negotiate the session parameters.  Only valid for raw read notification.
        If unsuccessful, the notification type SF_STATUS_REQ_ERROR should be returned.  In this case, the server should use the Windows function, SetLastError(), to indicate the error to the client.
      </returns>
      <remarks>
        Override this method to provide your own method for processing client headers.  The default setting is inactive.
      </remarks>
    </member>
    <member name="M:VO.HTTPFilterContext.OnReadRawData">
      <summary>
        Event handler method called by the filter DLL to allow the filter to see the raw data.  The data returned will contain both headers and data.
      </summary>
      <param name="pRawData">Pointer to a _WINHTTP_FILTER_RAW_DATA structure.</param>
      <returns>
        One of the following notification types:
        SF_STATUS_REQ_FINISHED
        The filter has handled the HTTP request.  The server should disconnect the session.
        SF_STATUS_REQ_FINISHED_KEEP_CONN
        Same as SF_STATUS_REQ_FINISHED except the server should keep the TCP session open if the option was negotiated.
        SF_STATUS_REQ_NEXT_NOTIFICATION
        The next filter in the notification chain should be called.
        SF_STATUS_REQ_ERROR
        An error occurred.  The server should use the Win32 API SetLastError() function to indicate the error to the client.
        SF_STATUS_REQ_READ_NEXT
        The filter is an opaque stream filter; negotiate the session parameters.  Only valid for raw read notification.
        If unsuccessful, the notification type SF_STATUS_REQ_ERROR should be returned.  In this case, the server should use the Windows function, SetLastError(), to indicate the error to the client.
      </returns>
      <remarks>
        Override this method to process raw data differently.
      </remarks>
    </member>
    <member name="M:VO.HTTPFilterContext.OnSendRawData">
      <summary>
        Event handler method called by the filter DLL to allow the filter to send the raw data.  The data returned will contain both headers and data.
      </summary>
      <param name="pRawData">Pointer to a _WINHTTP_FILTER_RAW_DATA structure.</param>
      <returns>
        One of the following notification types:
        SF_STATUS_REQ_ERROR
        An error occurred.  The server should use the Win32 API SetLastError() function to indicate the error to the client.
        SF_STATUS_REQ_NEXT_NOTIFICATION
        The next filter in the notification chain should be called.
        If unsuccessful, the notification type SF_STATUS_REQ_ERROR should be returned.  In this case, the server should use the Windows function, SetLastError(), to indicate the error to the client.
      </returns>
      <remarks>
        Override this method to change the default notification handler and to process raw data differently.
      </remarks>
    </member>
    <member name="M:VO.HTTPFilterContext.OnUrlMap">
      <summary>
        Event handler method called by the filter DLL when the server is mapping a logical URL to a physical path.
      </summary>
      <param name="pURLMap">Pointer to a _WINHTTP_FILTER_URL_MAP structure.</param>
      <returns>
        One of the following notification types:
        SF_STATUS_REQ_ERROR
        An error occurred.  The server should use the Win32 API SetLastError() function to indicate the error to the client.
        SF_STATUS_REQ_NEXT_NOTIFICATION
        The next filter in the notification chain should be called.
        If unsuccessful, the notification type SF_STATUS_REQ_ERROR should be returned.  In this case, the server should use the Windows function, SetLastError(), to indicate the error to the client.
      </returns>
      <remarks>
        Override this method to handle URL mapping differently.  The default setting is inactive.
      </remarks>
      <example>
        The following event handler writes the translated URL to the Win32 Debug Messages Window when the filter receives an SF_NOTIFY_END_OF_NET_SESSION notification:
        <code language="X#">
          METHOD  OnUrlMap (pData)  CLASS MyFilter
          LOCAL nRet   AS DWORD
          LOCAL pFUM   AS _WINHTTP_FILTER_URL_MAP
          nRet := SF_STATUS_REQ_NEXT_NOTIFICATION
          IF IsPtr(pData)
          pFUM := pData
          ELSE
          RETURN nRet
          ENDIF
          DebOut32(pFUM.pszPhysicalPath)
          RETURN nRet
        </code></example>
    </member>
    <member name="M:VO.HTTPFilterContext.ServerSupportFunction">
      <summary>
        Method to extend the filter's functionality.
      </summary>
      <param name="nRequest">A DWORD value containing the Filter Request type, which indicates the requested functions.  Valid values are:</param>
      <param name="pBuffer">Pointer to the buffer that contains the primary argument required for the requested support function.</param>
      <param name="nSize">Numeric value indicating the number of bytes available in the buffer.  Defaults to the size of &lt;pBuffer&gt; + 1.</param>
      <param name="cData">String containing data for secondary arguments.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method provides several support functions that are not covered directly by the standard callback functions of the _WINHTTP_FILTER_CONTEXT structure.
      </remarks>
    </member>
    <member name="M:VO.HTTPFilterContext.WriteClient">
      <summary>
        Send the raw HTTP entity data to the client.
      </summary>
      <param name="cHTTPEntity">String containing data that has to be sent to the client's Internet browser.  If not specified, defaults to a line break, '&lt;br&gt;'.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sends data present in the given buffer to the client that made the request.
      </remarks>
    </member>
    <member name="T:VO.HyperLabel">
      <summary>
        Create a hyperlabel, which stores information about another object.
      </summary>
      <remarks>
        The HyperLabel class stores prompts and instructions for context-sensitive help information about another object — the host object.  The purpose of the class is to collect this kind of information in a standard way so that the various help systems (status, exception, and error management functions) within the system can process the hyperlabel without knowing anything about the host object, just as a mailing system routes packages without knowing their content.
        Hyperlabels also record the symbolic name of the host.  For example, the system uses this name to match fields with controls when linking a data window to a data source and, in the case of menu commands, to decide which method of the menu's owner to dispatch when the user commands that menu command to execute.
        Individual database columns have hyperlabels, as do data types, data windows, controls, and menu commands.  Objects delegate hyperlabels to one another.  In fact a large part of good programming with X# consists in providing full and helpful hyperlabels.  Much of the automatic behavior of the system depends for its progress on the quality of information in the hyperlabels.
        It is called a hyperlabel because the system's hypertext help system navigates by hyperlabels.
        <note type="tip">You first create a hyperlabel and then affix it to its host object by assigning to the host's hyperlabel pseudo-variable.</note></remarks>
    </member>
    <member name="M:VO.HyperLabel.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a hyperlabel.
      </summary>
      <param name="uName">The symbolic name that the program uses to refer to the object to which the hyperlabel attaches.  For example, if the hyperlabel attaches to a menu command, the symbolic name is the method (of the window that owns the menu) that the system invokes when the user executes that menu command.  If the hyperlabel attaches to a field, the symbol is the field's name.  In other words, the symbolic name is only useful to the program.  The other items, by contrast, are meaningful to the user.</param>
      <param name="uCaption">The name of the object to which the hyperlabel attaches, as recognized by the user.  If the object is a control, the caption is the name shown beside, or on, the control.  If you supply the resource ID of a string, HyperLabel:Init() extracts the string.  if not specified, the default is the same as &lt;symName&gt;, if provided; otherwise, NULL_STRING.</param>
      <param name="uDescription">The purpose of the host object.  For a control, the purpose tells the user what the control is for.  By default, when a control gets focus, the system displays the control's hyperlabel's description upon the status bar.  Similarly, when the user drags the mouse across the menu, each time a new command is highlighted, its hyperlabel's description appears in the status bar.  If you supply the resource ID of a string, HyperLabel:Init() extracts the string.  If not specified, the default is NULL_STRING.</param>
      <param name="uHelpContext">The string that uniquely identifies the place to jump in the hypertext help system.  In the case of Windows, this is just the context name.  The system uses the object's hyperlabel's help context to decide where to jump when the user asks for in-context help about the host object.  If you supply the resource ID of a string, HyperLabel:Init() extracts the string.  If not specified, the default is NULL_STRING.</param>
    </member>
    <member name="M:VO.HyperLabel.AsString">
      <summary>
        Return the caption of the hyperlabel.
      </summary>
      <remarks>
        This method returns the same as HyperLabel:Caption and presents the hyperlabel as a recognizable string.
      </remarks>
    </member>
    <member name="P:VO.HyperLabel.Caption">
      <summary>
        A string representing the short name or caption by which the user refers to the host object (to which the hyperlabel is attached).  For a menu command, this would be the text appearing in the menu itself.
      </summary>
      <value>A string representing the short name or caption by which the user refers to the host object (to which the hyperlabel is attached).  For a menu command, this would be the text appearing in the menu itself.</value>
    </member>
    <member name="P:VO.HyperLabel.Description">
      <summary>
        A string representing the purpose of the host object (to which the hyperlabel is attached).  Typically, the system uses this as a prompt to the user or as a faster substitute for hypertext help.
      </summary>
      <value>A string representing the purpose of the host object (to which the hyperlabel is attached).  Typically, the system uses this as a prompt to the user or as a faster substitute for hypertext help.</value>
    </member>
    <member name="M:VO.HyperLabel.Error(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Provide a method for handling error conditions raised during hyperlabel processing.
      </summary>
      <param name="oError">An Error object describing the error condition.</param>
      <param name="symMethod">The symbolic name of the method that originated the error.</param>
      <remarks>
        <note type="tip">This is an event handler and is automatically called by other methods; the developer does not normally need to call the HyperLabel:Error() method, but might want to replace or amend it.</note>

        The standard Error() handling method fills in some more information about the errors and about the HyperLabel object that originates the error, sets the status value for the object, and passes the problem to its client, if there is one, in its standard Error() handling method.  If there is no client who wants to deal with the problem, the method passes it up the call stack by issuing a BREAK with the same Error object.
        <note type="tip">If an error comes in while one is being handled, the Error() method immediately breaks.</note></remarks>
    </member>
    <member name="P:VO.HyperLabel.HelpContext">
      <summary>
        A string representing the key or ID for the place in the hypertext system where the system looks for help concerning the host object (to which the hyperlabel is attached).
      </summary>
      <value>A string representing the key or ID for the place in the hypertext system where the system looks for help concerning the host object (to which the hyperlabel is attached).</value>
    </member>
    <member name="P:VO.HyperLabel.Name">
      <summary>
        A string representing the name of the host object to which the hyperlabel is attached.
      </summary>
      <value>A string representing the name of the host object to which the hyperlabel is attached.</value>
    </member>
    <member name="P:VO.HyperLabel.NameSym">
      <summary>
        A symbol representing the name of the host object to which the hyperlabel is attached.
      </summary>
      <value>A symbol representing the name of the host object to which the hyperlabel is attached.</value>
    </member>
    <member name="T:VO.HyperLink">
      <summary>
        Create a HyperLink control.
      </summary>
      <remarks>
        The intention of this class is that the text would appear as a HyperLink to a www address or as an @ email address and therefore the cursor will appear as the normal hand.
        When the control is clicked on, it will attempt to "open" the text of the control using the OpenLink callback method. If the text is a www address it will open the default browser and attempt to navigate to the address. If the text contains an @ it will be taken as an email address and open the default email client.
        <note type="tip">
          The difference between the HyperLink and the SysLink classes is in the way that the text is used.
          In a HyperLink control, ALL of the text is passed as the hyperlink where as in the SysLink control you can mix display text and hyperlink text.
          Also, in the HyperLink control, ALL of the displayed text is passed through to the ShellExecute method and you must make sure that there is nothing in it which could cause this to fail.
        </note></remarks>
      <example>
        <code language="X#">
          oFont1 := Font{,8,"Microsoft Sans Serif"}
          oFont1:Underline := TRUE
          oHL1 := HyperLink{ SELF, -1, Point{190, 25 }, ;
          Dimension{0, 0 }, "http://www.grafxsoft.com" }
          oHL1:font := oFont1
          oHL1:size := Dimension{150,20}
          oHL1:textcolor := Color{ COLORBLUE }
          oHL1:font:underline := TRUE
          oHL1:Show( )
        </code>
      </example>
    </member>
    <member name="M:VO.HyperLink.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a HyperLink control.
      </summary>
      <param name="oOwner">The window that owns the HyperLink.</param>
      <param name="xID">The unique ID of the HyperLink control (between 1 and 8000).</param>
      <param name="oPoint">The origin of the HyperLink control in canvas coordinates.</param>
      <param name="oDimension">The dimension of the HyperLink control in canvas coordinates.</param>
      <param name="cText">The string that is to be displayed on screen.</param>
    </member>
    <member name="M:VO.HyperLink.Dispatch(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.HyperLink.OpenLink">
      <summary>
        Is the method that is invoked whenever the mouse is clicked over the HyperLink control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <remarks>
        This method is automatically called whenever the mouse is clicked over the HyperLink control.
      </remarks>
    </member>
    <member name="T:VO.IApplicationObject">
      <summary>
        Share information among all users of an ASP application.
      </summary>
      <remarks>
        By using an IApplication object, you are able to share information among all users of a given application.  An ASP-based application contains all the .ASP files in a virtual directory and its subdirectories.  Because the IApplication object can be shared by more than one user, there are _Lock() and _Unlock() methods to ensure that multiple users accesses.
      </remarks>
    </member>
    <member name="M:VO.IApplicationObject.#ctor">
      <summary>
        Construct an IApplicationObject object instance.
      </summary>
      <param name="oIScrContext">An IScriptingContext object.</param>
      <param name="pIAppObj">Pointer to an IApplication Interface object structure.</param>
      <remarks>
        An IApplicationObject instance is automatically created by the IScriptingContext:OnStartPage() method when the appropriate .ASP file is loaded by the Internet Information Server (IIS).  Therefore, you do not have to create this object yourself.  Rather, use it for an ASP Component application via the IScriptingContext:Application property.
      </remarks>
    </member>
    <member name="M:VO.IApplicationObject._Lock">
      <summary>
        Lock all variables of an IApplicationObject instance.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Prevents other clients from accessing the variables stored in an IApplicationObject object until the _Unlock() method has been called.
      </remarks>
      <example>
        See the IApplicationObject:GetValue() example.
      </example>
    </member>
    <member name="M:VO.IApplicationObject._UnLock">
      <summary>
        Release all variables of an IApplicationObject instance.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Releases variables stored in an IApplicationObject object previously locked by the _Lock() method.
      </remarks>
      <example>
        See the IApplicationObject:GetValue() example.
      </example>
    </member>
    <member name="M:VO.IApplicationObject.GetValue">
      <summary>
        Retrieve the value of a variable stored in an IApplication object.
      </summary>
      <param name="cVarName">Name of the wanted variable.</param>
      <returns>
        Value of type USUAL, if successful; otherwise, NIL.
      </returns>
      <remarks>
        This method retrieves the value of a variable stored in the IApplication object.
      </remarks>
      <example>
        The following source code can be used to display the application-wide value, "GlobalVar":
        <code language="X#">
          GLOBAL goASPComponent 	AS ASPComponent
          PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}
          CLASS ASPComponent INHERIT IScriptingContext
        </code><code language="X#">
          METHOD	HTTPResponse 	CLASS ASPComponent
          LOCAL cRet	AS STRING
             IF SELF:Application:_Lock()
             	cRet := SELF:Application:GetValue("GlobalVar")
                SELF:Application:_UnLock()
             ENDIF
          RETURN SELF:Response:_Write(cRet)
        </code>
        ASP code:
        <code language="X#">
          &lt;%
          Set oComp = Server.CreateObject("VoAsp.Component")
          Application("GlobalVar") = "Hello world"
          oComp.HTTPResponse()
          %&gt;
        </code></example>
    </member>
    <member name="M:VO.IApplicationObject.PutValue">
      <summary>
        Store the value of a variable into an IApplication object.
      </summary>
      <param name="cVarName">Name of the desired variable.</param>
      <param name="xValue">The new value to assign to &lt;cVarName&gt;.</param>
      <returns>
        TRUE, if the value has been changed; otherwise, FALSE.
      </returns>
      <remarks>
        This method assigns the value of a variable stored in the IApplication object.
      </remarks>
    </member>
    <member name="T:VO.Icon">
      <summary>
        Create an icon, which is a small bitmap that the system displays for a window when it is iconized in its owner window.
      </summary>
      <remarks>
        X# provides a set of predefined icons, defined in Icon:Init().  Use the AppWindow:Icon property to assign an icon for each application window.
        Visual Object includes an Icon Editor which produces standard system icon files.  There is also a large library of system icons.  These icon files are compatible with the standard format on the system, so any other icon file or Icon Editor may also be used.  To use such an icon file, create an icon resource with the RESOURCE statement and reference it when instantiating an icon.  Refer to the IDE User Guide for more information on using and editing the standard icons.
        <note type="tip">An icon's size and color range is system-dependent.</note></remarks>
      <example>
        The following example demonstrates the use of one of the standard icons:
        <code language="X#">
          CLASS MyWindow INHERIT TopAppWindow
          METHOD Init() CLASS MyWindow
          SUPER:Init()
          SELF:Icon := Icon{ICONASTERISK}
        </code>
        This code fragment emphasizes three things:
        Any Init() method of a class that inherits must call SUPER:Init().
        The pseudo-variable Icon is an access/assign pair in class AppWindow.
        ICONASTERISK identifies one of the standard icons.
        The following example provides an application window with a custom icon:
        <code language="X#">
          CLASS MyTopAppWin INHERIT TopAppWindow
          METHOD Init CLASS MyTopAppWin
          SUPER:Init()
          SELF:Icon := Icon{IDI_APPICON}
          RESOURCE IDI_APPICON ICON app.ico
        </code>

        In Windows, icons are defined in a resource entity using the keyword ICON, referencing the name of the file created by the Icon Editor.
      </example>
    </member>
    <member name="M:VO.Icon.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct an icon.
      </summary>
      <param name="xResourceID">The resource ID of the desired icon, a handle of an existing Icon object or one of the icon constants from the table below</param>
      <param name="kLoadOption">The optional constant representing the load option. The default is LR_DEFAULTCOLOR.</param>
      <param name="iWidth">The optional width of the bitmap. The default is the width of the bitmap.</param>
      <param name="iHeight">The optional height of the bitmap. The default is the height of the bitmap.</param>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constant	Icon</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>ICONASTERISK</term>
            <description>An icon used to indicate "note that."</description>
          </item>
          <item>
            <term>ICONEXCLAMATION</term>
            <description>An icon used to indicate warnings.</description>
          </item>
          <item>
            <term>ICONHAND</term>
            <description>An icon used to indicate error conditions.</description>
          </item>
          <item>
            <term>ICONQUESTIONMARK</term>
            <description>An icon used to indicate that more information is required.</description>
          </item>
          <item>
            <term>ICONSTANDARD</term>
            <description>A blank, square icon.  This is the default.</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:VO.Icon.Destroy">
      <summary>
        Provide a method to de-instantiate an Icon object.
      </summary>
      <remarks>
        This method can be used when an Icon object is no longer needed.  Icon:Destroy() de-instantiates the Icon object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.Icon.Handle">
      <summary>
        Return the handle for an icon.
      </summary>
      <param name="nHandleType">The type of handle required.  Zero (0) is the only supported option and is the default if &lt;nHandleType&gt; is omitted.</param>
      <returns>
        A handle describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
      </remarks>
    </member>
    <member name="P:VO.Icon.Size">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.IDispatch">
      <summary>
        Provide a helper class for turning a returned OLE automation interface into an OLEAutoObject.
      </summary>
      <remarks>
        <br />Important!  This class is used for internal implementation only and is not intended to be used directly.
      </remarks>
    </member>
    <member name="T:VO.ImageList">
      <summary>
        Create an image list.
      </summary>
      <remarks>
        An image list is an object that is essentially a collection of icons and/or bitmaps of the same size.  Image lists provide a way to manage icons and bitmaps in groups rather than as individual objects.  They are typically used by tab, list view, and tree view controls, which refer to particular images in the list by their sequential index.  Image lists are used by controls for image manipulation; as a result, methods such as BeginDrag(), DragMove(), EndDrag(), and Handle() are used by the system and should generally not be used directly.
      </remarks>
    </member>
    <member name="M:VO.ImageList.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct an image list object.
      </summary>
      <param name="nImages">The number of images this image list will contain.</param>
      <param name="oDimension">A Dimension object representing the size of the images in the image list.</param>
      <param name="oImage">Add an Icon or Bitmap object to the ImageList.</param>
      <param name="wColor">The color mask to use. This is a Set of bit flags that specify the type of image list to create. This parameter can be a combination of the following values, but it can include only one of the ILC_COLOR values. </param>
      <param name="nGrow">This is the number of images by which the image list can grow when the system needs to make room for new images.</param>
      <remarks>
        <list type="table">
          <listheader>
            <term>Value</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>ILC_COLOR</term>
            <description>Use the default behavior if none of the other ILC_COLOR* flags is specified. Typically, the default is ILC_COLOR4, but for older display drivers, the default is ILC_COLORDDB.</description>
          </item>
          <item>
            <term>ILC_COLOR4</term>
            <description>Use a 4-bit (16-color) device-independent bitmap (DIB) section as the bitmap for the image list. </description>
          </item>
          <item>
            <term>ILC_COLOR8</term>
            <description>Use an 8-bit DIB section. The colors used for the color table are the same colors as the halftone palette. </description>
          </item>
          <item>
            <term>ILC_COLOR16</term>
            <description>Use a 16-bit (32/64k-color) DIB section.</description>
          </item>
          <item>
            <term>ILC_COLOR24</term>
            <description>Use a 24-bit DIB section.</description>
          </item>
          <item>
            <term>ILC_COLOR32</term>
            <description>Use a 32-bit DIB section.</description>
          </item>
          <item>
            <term>ILC_COLORDDB</term>
            <description>Use a device-dependent bitmap.</description>
          </item>
          <item>
            <term>ILC_MASK</term>
            <description>Use a mask. The image list contains two bitmaps, one of which is a monochrome bitmap used as a mask. If this value is not included, the image list contains only one bitmap.</description>
          </item>
          <item>
            <term>ILC_MIRROR</term>
            <description>Version 6.00. Microsoft Windows can be mirrored to display languages such as Hebrew or Arabic that read right-to-left. If the image list is created on a mirrored version of Windows, then the images in the lists are mirrored, that is, they are flipped so they display from right to left. Use this flag on a mirrored version of Windows to instruct the image list not to automatically mirror images. </description>
          </item>
          <item>
            <term>ILC_PERITEMMIRROR</term>
            <description>Version 6.00. Specify this flag if ILC_MIRROR is used on an image list that contains a strip of images. ILC_MIRROR must be specified for this flag to have any effect. </description>
          </item>
        </list>
        NOTE: If you pass the fourth parameter you should always include ICL_MASK in the value.
      </remarks>
    </member>
    <member name="M:VO.ImageList.Add(XSharp.__Usual)">
      <summary>
        Add an icon or bitmap to the image list.
      </summary>
      <param name="oImage">The icon or bitmap to add to the image list.</param>
      <returns>
        The image list index of the added image.
      </returns>
    </member>
    <member name="M:VO.ImageList.AddMask(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Adds an image or images to an image list and generates a mask from the specified bitmap.
      </summary>
      <param name="oBitmap">The bitmap object to use for the ImageList mask.</param>
      <param name="oMaskColor">The color of the mask.</param>
      <returns>
        The index of the first new image, if successful; otherwise, -1.
      </returns>
    </member>
    <member name="M:VO.ImageList.BeginDrag(XSharp.__Usual)">
      <summary>
        Begin a drag operation on an image list.
      </summary>
      <param name="nIndex">The image list index of the image to be dragged.  If omitted, the first image in the image list is used.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ImageList.CreateOverlayImage(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Create an overlay image from an image in an image list.
      </summary>
      <param name="nListIndex">The image list index of the image from which to create an overlay image.</param>
      <param name="nImageIndex">The index of the new overlay image.  This can be a value from 1 to 4.  If omitted, the new overlay image will be the first in the list.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        An overlay image is an image drawn over another image.  This technique is commonly used in list view and tree view controls.  An image list can have up to four overlay images.
      </remarks>
    </member>
    <member name="M:VO.ImageList.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.ImageList.DragEnter(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Starts a drag-and-drop operation at the given position in the given window.
      </summary>
      <param name="oPoint">** missing parameter documentation **</param>
      <param name="oWindow">** missing parameter documentation **</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ImageList.DragLeave">
      <summary>
        Ends a drag-and-drop operation.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ImageList.DragMove(XSharp.__Usual)">
      <summary>
        Drag an image list to the specified position.
      </summary>
      <param name="oPoint">The point to which to drag the image list.</param>
      <param name="oWindow">The window over which the image list is to be dragged.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ImageList.EndDrag">
      <summary>
        End a drag operation on an image list.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ImageList.Handle">
      <summary>
        Return the Windows handle of the image list, which can be used in Windows.
      </summary>
      <returns>
        The handle (a pointer) of the image list.
      </returns>
    </member>
    <member name="P:VO.ImageList.ImageCount">
      <summary>
        The number of images in the ImageList object.
      </summary>
      <value>The number of images in the ImageList object.</value>
    </member>
    <member name="P:VO.ImageList.ImageSize">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.InfoBox">
      <summary>
        Present the user with informational message box.
      </summary>
      <remarks>
        An informational message box is a window that displays a user-defined caption in the title bar, the text of the informational message, and an information icon.  These boxes are typically used to provide useful information to the user.  When the information box disappears, focus is returned to the owner window.
        <note type="tip">An information box is application modal — the user must acknowledge it before continuing with the application.</note></remarks>
      <example>
        The following example displays an information box:
        <code language="X#">
          METHOD Start() CLASS App
          oMyWin := TopAppWindow{}
          oMyWin:Show()
          oSomeInfo := InfoBox{oMyWin, "Info", "Message box"}
          oSomeInfo:Show()
          SELF:Exec()
        </code></example>
    </member>
    <member name="M:VO.InfoBox.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct an information message box.
      </summary>
      <param name="uParent">The window that owns the information box.  If omitted, the default owner is the Windows desktop.</param>
      <param name="uCaption">The caption text to be displayed in the title bar of the information box.  If omitted, the default is 'Info Box'.</param>
      <param name="uText">
        The informational text to be printed in the information box when it is shown or the hyperlabel containing a caption and description for the information box.
        If omitted, the default is NULL_STRING.
      </param>
    </member>
    <member name="T:VO.IntegerFS">
      <summary>
        Create an integer field specification, which holds integer data type information.
      </summary>
    </member>
    <member name="M:VO.IntegerFS.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct an integer field specification.
      </summary>
      <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new integer field specification.</param>
      <param name="uLength">The length of the field.  If not specified, the default is 10.</param>
    </member>
    <member name="T:VO.IPAddress">
      <summary>
        Edit control to edit an IP address that consists of 4 numbers
      </summary>
    </member>
    <member name="M:VO.IPAddress.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct an IPAddress object.
      </summary>
      <param name="oOwner">The window that owns the IPAddress object.</param>
      <param name="xID">The unique ID for the IPAddress object (between 1 and 8000).</param>
      <param name="oPoint">The origin of the IPAddress object in canvas coordinates.</param>
      <param name="oDimension">The dimension of the IPAddress object in canvas coordinates.</param>
      <param name="dwStyle">
        Constant representing the style of the IPAddress object, specified either by a X# style constant or a Windows API style constant.  Styles can be combined using the _Or() operator.
      </param>
      <param name="lDataAware">A logical value that is TRUE if the IPAddress object is data-aware; otherwise, FALSE.  If omitted, defaults to TRUE.</param>
      <param name="nResourceID">The resource ID of the IPAddress object.</param>
      <remarks>
        <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular style constant.</note>
      </remarks>
    </member>
    <member name="P:VO.IPAddress.Address">
      <summary>
        A long value representing the current IP address.  This equals the IP address interpreted as a 4-byte integer.
      </summary>
      <value>A long value representing the current IP address.  This equals the IP address interpreted as a 4-byte integer.</value>
    </member>
    <member name="P:VO.IPAddress.EditHandle">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.IPAddress.Field1">
      <summary>
        A numeric value representing the first field of the current IP Address.  For the IP Address "130.119.121.147", this access would return 130.
      </summary>
      <value>A numeric value representing the first field of the current IP Address.  For the IP Address "130.119.121.147", this access would return 130.</value>
    </member>
    <member name="P:VO.IPAddress.Field2">
      <summary>
        A numeric value representing the second field of the current IP address.  For the IP address "130.119.121.147", this access would return 119.
      </summary>
      <value>A numeric value representing the second field of the current IP address.  For the IP address "130.119.121.147", this access would return 119.</value>
    </member>
    <member name="P:VO.IPAddress.Field3">
      <summary>
        A numeric value representing the third field of the current IP address.  For the IP address "130.119.121.147", this access would return 121.
      </summary>
      <value>A numeric value representing the third field of the current IP address.  For the IP address "130.119.121.147", this access would return 121.</value>
    </member>
    <member name="P:VO.IPAddress.Field4">
      <summary>
        A numeric value representing the fourth field of the current IP address.  For the IP address "130.119.121.147", this access would return 147.
      </summary>
      <value>A numeric value representing the fourth field of the current IP address.  For the IP address "130.119.121.147", this access would return 147.</value>
    </member>
    <member name="M:VO.IPAddress.SetRange(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the allowable entry range per field.
      </summary>
      <param name="iFieldIndex">Index of the field for which the range is being set (between 1 and 4).</param>
      <param name="iLower">Lower limit of the range.</param>
      <param name="iUpper">Upper limit of the range.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        SetRange allows you to set the allowed range of the four input fields individually.
      </remarks>
    </member>
    <member name="P:VO.IPAddress.TextValue">
      <summary>
        String representing the IP address.
      </summary>
      <value>String representing the IP address.</value>
      <example>
        The following example demonstrates the IP address being set and read back:
        <code language="X#">
          oDCIPAddress1:TextValue := '192.168.0.1'
          ? oDCIPAddress1:TextValue  //	'192.168.0.1'
        </code></example>
    </member>
    <member name="P:VO.IPAddress.Value">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.IpcClient">
      <summary>
        Register an application as a client able to request and receive data from a designated server application.
      </summary>
      <remarks>
        In X#, the IPC... classes provides a means of implementing DDE conversations between DDE-compatible applications.  DDE (Dynamic Data Exchange) is a type of interprocess communication (IPC) that uses shared memory to exchange data between applications.  IPC is governed by a DDE management library, an underlying DLL in Windows.
        In such a conversation, there is a client and a server.  The client requests data from the server about particular topics and items, and the server supplies the requested data.  The applications, after requesting to be a client or server (or both), then exchange updates as soon as new data becomes available.  These exchanges are not necessarily initiated by the user.
        Each IPC client must uniquely identify the server with which it wishes to communicate, and then request data updates.  After the initial transfer, the client is informed of any changes to the transferred data in the server by means of an IpcDataUpdateEvent.
      </remarks>
    </member>
    <member name="M:VO.IpcClient.#ctor(XSharp.__Usual)">
      <summary>
        Construct an IpcClient object.
      </summary>
      <param name="cServerName">The server with which to communicate.</param>
    </member>
    <member name="M:VO.IpcClient.ChangeData(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Tell the remote server that some data value has changed.  This results in the server receiving an IpcDataUpdateEvent.  It is then the responsibility of the server to update itself.
      </summary>
      <param name="cTopic">The name of the IPC topic whose data has changed.  This method causes the system to notify the IPC server of the change by sending it an IpcDataUpdateEvent.  When the server asks that event which topic has changed, the event answers with the value you gave to this argument.</param>
      <param name="cItem">The name of the item to change.</param>
      <param name="cStringData">The data that has changed.</param>
    </member>
    <member name="M:VO.IpcClient.ClientError(XSharp.__Usual)">
      <summary>
        Handle ClientErrorEvent, if one occurs.  Provide this event handler in your derived IpcClient class if you require special handling of errors.
      </summary>
      <param name="oIpcClientErrorEvent">The type of error that occurred.  Refer to the IpcClientErrorEvent class for a list of error types.</param>
      <returns>
        TRUE if the DDE conversation is to continue; otherwise, FALSE.
      </returns>
      <example>
        The following example demonstrates how a client error event is handled by the ClientError() method:
        <code language="X#">
          METHOD ClientError(oICEE) CLASS MyClient
          LOCAL Err := oICEE:ErrorType
          DO CASE
            CASE Err == IPCSERVERNOTFOUND
          ...
        </code></example>
    </member>
    <member name="M:VO.IpcClient.DataUpdate(XSharp.__Usual)">
      <summary>
        Called whenever the requested data changes.  It is invoked after the IpcServer calls its UpdateTopic() method.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oIpcDataUpdateEvent">Stores the topic name, item name, and the changed data as a string.</param>
    </member>
    <member name="M:VO.IpcClient.Destroy">
      <summary>
        Provide a method to de-instantiate an IpcClient object.
      </summary>
      <remarks>
        This method can be used when an IpcClient object is no longer needed.  IpcClient:Destroy() de-instantiates the IpcClient object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.IpcClient.Dispatch(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.IpcClient.Execute(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Send a message to the server telling it to execute the command string remotely.  As a result of this call, the server receives an IpcExecuteRequestEvent.
      </summary>
      <remarks>
        <note type="tip">In Windows, the item is not passed to the server.</note>
      </remarks>
      <param name="cTopic">The name of the IPC topic for which the server executes a command.</param>
      <param name="cItem">The name of the IPC item for which the server executes a command.</param>
      <param name="cCommand">The command to be executed by the server.</param>
    </member>
    <member name="P:VO.IpcClient.IdInst">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.IpcClient.RequestData(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Request updates on a particular topic from the server.
      </summary>
      <param name="oIpcTopic">The IPC topic on which data is being requested.</param>
      <param name="continuous">If set to TRUE, the server sends data to the client each time it changes; if FALSE, the server sends only one update.The default is FALSE.</param>
    </member>
    <member name="T:VO.IpcClientErrorEvent">
      <summary>
        Provide information about an IpcClientErrorEvent, used to indicate what type of error event occurred in an IPC server.
      </summary>
      <remarks>
        IpcClientErrorEvent events are sent to IpcClient:ClientError().
      </remarks>
    </member>
    <member name="M:VO.IpcClientErrorEvent.#ctor(XSharp.__Usual)">
      <exclude />
    </member>
    <member name="P:VO.IpcClientErrorEvent.ErrorType">
      <summary>
        The type of error event that occurred, as defined by the one of the constants in the table below:
      </summary>
      <value>The type of error event that occurred, as defined by the one of the constants in the table below:</value>
      <remarks>
        The type of error event that occurred, as defined by the following constants:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>IPCITEMNOTFOUND</term><description>The server does not have an item of that name.</description></item><item><term>IPCOUTOFMEMORY</term><description>The system is out of memory so the action cannot be completed.</description></item><item><term>IPCSERVERNOTFOUND</term><description>The indicated server or topic is not found.</description></item></list></remarks>
    </member>
    <member name="T:VO.IpcDataRequestEvent">
      <summary>
        Provide information about an IpcDataRequestEvent, used to store the topic name (and length) and the item name (and length) for which data has been requested.
      </summary>
      <remarks>
        IpcDataRequestEvent events are sent to IpcServer:DataRequest().
      </remarks>
    </member>
    <member name="M:VO.IpcDataRequestEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <exclude />
    </member>
    <member name="P:VO.IpcDataRequestEvent.Item">
      <summary>
        A string representing the item name for which data has been requested.
      </summary>
      <value>A string representing the item name for which data has been requested.</value>
    </member>
    <member name="P:VO.IpcDataRequestEvent.Topic">
      <summary>
        A string representing the topic name for which data has been requested.
      </summary>
      <value>A string representing the topic name for which data has been requested.</value>
    </member>
    <member name="T:VO.IpcDataUpdateEvent">
      <summary>
        Provide information about an IpcDataUpdateEvent, used to store information about the topic name, item name, and the new data.
      </summary>
      <remarks>
        IpcDataUpdateEvent events are sent to IpcServer:DataUpdate() and IpcClient:DataUpdate().
      </remarks>
    </member>
    <member name="M:VO.IpcDataUpdateEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <exclude />
    </member>
    <member name="P:VO.IpcDataUpdateEvent.AsString">
      <summary>
        A string containing the data that has changed.
      </summary>
      <value>A string containing the data that has changed.</value>
    </member>
    <member name="M:VO.IpcDataUpdateEvent.GetData">
      <summary>
        Enable the program to handle the data that has changed.
      </summary>
      <returns>
        A string containing the data that has changed.
      </returns>
    </member>
    <member name="P:VO.IpcDataUpdateEvent.Item">
      <summary>
        A string representing the item name for which a data update has been requested.
      </summary>
      <value>A string representing the item name for which a data update has been requested.</value>
    </member>
    <member name="P:VO.IpcDataUpdateEvent.Topic">
      <summary>
        A string representing the topic name for which data update has been requested.
      </summary>
      <value>A string representing the topic name for which data update has been requested.</value>
    </member>
    <member name="T:VO.IpcEvent">
      <summary>
        Provide the base class from which all Ipc event classes are subclassed.
      </summary>
    </member>
    <member name="M:VO.IpcEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <exclude />
    </member>
    <member name="F:VO.IpcEvent.dwData1">
      <exclude />
    </member>
    <member name="F:VO.IpcEvent.dwData2">
      <exclude />
    </member>
    <member name="F:VO.IpcEvent.dwFmt">
      <exclude />
    </member>
    <member name="F:VO.IpcEvent.dwType">
      <exclude />
    </member>
    <member name="F:VO.IpcEvent.hConv">
      <exclude />
    </member>
    <member name="F:VO.IpcEvent.hData">
      <exclude />
    </member>
    <member name="F:VO.IpcEvent.hsz1">
      <exclude />
    </member>
    <member name="F:VO.IpcEvent.hsz2">
      <exclude />
    </member>
    <member name="P:VO.IpcEvent.Item">
      <summary>
        A string representing the item name for which the event has been requested.
      </summary>
      <value>A string representing the item name for which the event has been requested.</value>
    </member>
    <member name="F:VO.IpcEvent.oIPCObject">
      <exclude />
    </member>
    <member name="P:VO.IpcEvent.Topic">
      <summary>
        A string representing the topic name for which the event has been requested.
      </summary>
      <value>A string representing the topic name for which the event has been requested.</value>
    </member>
    <member name="T:VO.IpcExecuteRequestEvent">
      <summary>
        Provide information about an IpcExecuteRequestEvent, used to store information about the topic, item, and command string.
      </summary>
      <remarks>
        <note type="tip">In Windows, the item string is always empty and should not be used.</note>
        IpcExecuteRequestEvent events are sent to IpcServer:ExecuteRequest().
      </remarks>
    </member>
    <member name="M:VO.IpcExecuteRequestEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <exclude />
    </member>
    <member name="P:VO.IpcExecuteRequestEvent.Command">
      <summary>
        A string representing the command name.
      </summary>
      <value>A string representing the command name.</value>
    </member>
    <member name="P:VO.IpcExecuteRequestEvent.Item">
      <summary>
        A string representing the item name.
        There is no item in Windows.  The access is provided for compatibility with other environments.
      </summary>
      <value>
        A string representing the item name.
        There is no item in Windows.  The access is provided for compatibility with other environments.
      </value>
    </member>
    <member name="P:VO.IpcExecuteRequestEvent.Topic">
      <summary>
        A string representing the topic name.
      </summary>
      <value>A string representing the topic name.</value>
    </member>
    <member name="T:VO.IpcServer">
      <summary>
        Register an application as a server able to access data on specific topics and update registered topics and update registered client applications.
      </summary>
      <remarks>
        In X#, the IPC... classes provides a means of implementing DDE conversations between DDE-compatible applications.  DDE (Dynamic Data Exchange) is a type of interprocess communication (IPC) that uses shared memory to exchange data between applications.  IPC is governed by a DDE management library, an underlying DLL in Windows.
        In such a conversation, there is a client and a server.  The client requests data from the server about particular topics and items, and the server supplies the requested data.  The applications, after requesting to be a client or server (or both), then exchange updates as soon as new data becomes available.  These exchanges are not necessarily initiated by the user.
        Each IPC client must uniquely identify the server with which it wishes to communicate, and then request data updates.  After the initial transfer, the client is informed of any changes to the transferred data in the server by means of an IpcDataUpdateEvent object.
      </remarks>
    </member>
    <member name="M:VO.IpcServer.#ctor(XSharp.__Usual)">
      <summary>
        Construct an IpcServer object.
      </summary>
      <param name="cServName">The name uniquely identifying the server, which the clients use.</param>
    </member>
    <member name="M:VO.IpcServer.AddTopic(XSharp.__Usual)">
      <summary>
        Add a topic to the list of topics supported by the server.
      </summary>
      <param name="oIpcTopic">The IPC topic to add to the list supported by the server.</param>
      <remarks>
        This should be invoked once for every topic supported.
      </remarks>
    </member>
    <member name="M:VO.IpcServer.DataRequest(XSharp.__Usual)">
      <summary>
        Called whenever a client makes a request for data or when the IpcServer:UpdateTopic() is called.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oIpcDataRequestEvent">Stores the topic name and item name.</param>
      <returns>
        An object containing a pointer to the data and the length of the data string (it created as a global memory object by Windows DDE management library and it passes a data handle back to the application).
      </returns>
    </member>
    <member name="M:VO.IpcServer.DataUpdate(XSharp.__Usual)">
      <summary>
        Called whenever a client calls IpcClient:ChangeData().
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oIpcDataUpdateEvent">Stores the topic name, item name, and the changed data as a string.</param>
      <remarks>
        When this method is called, the server should update itself.  This functionality is provided by the developer in the overridden method, not by X#.
      </remarks>
    </member>
    <member name="M:VO.IpcServer.Destroy">
      <summary>
        Provide a method to de-instantiate an IpcServer object.
      </summary>
      <remarks>
        This method can be used when an IpcServer object is no longer needed.  IpcServer:Destroy() de-instantiates the IpcServer object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.IpcServer.Dispatch(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.IpcServer.ExecuteRequest(XSharp.__Usual)">
      <summary>
        Called when the client calls IpcClient:Execute(). The server should take the appropriate action to execute the command locally.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oIpcExecuteRequestEvent">Stores the topic name, item name, and the command name to be executed.</param>
    </member>
    <member name="P:VO.IpcServer.idInst">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.IpcServer.UpdateTopic(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Request that the server update a particular topic and item.
      </summary>
      <param name="cTopic">The IPC topic to be updated.</param>
      <param name="cItem">The IPC item to be updated.</param>
      <remarks>
        This results in the invocation of IpcServer:DataRequest().  Then the clients associated with the topic and item pair are updated with the new value.
      </remarks>
    </member>
    <member name="T:VO.IpcTopic">
      <summary>
        Create topic (and items) to be supported by an IPC server and which IPC clients can request.  These objects are used by IpcServer:AddTopic() and IpcClient:RequestData().
      </summary>
    </member>
    <member name="M:VO.IpcTopic.#ctor(XSharp.__Usual)">
      <summary>
        Construct an IpcTopic object.
      </summary>
      <param name="cTopicString">The IPC topic to be created.</param>
    </member>
    <member name="M:VO.IpcTopic.AddItem(XSharp.__Usual)">
      <summary>
        Add an item to the list of items associated with the topic.
      </summary>
      <param name="cItemString">The IPC item to be added to the list of items associated with the topic.</param>
    </member>
    <member name="F:VO.IpcTopic.aItemList">
      <exclude />
    </member>
    <member name="F:VO.IpcTopic.cTopicName">
      <exclude />
    </member>
    <member name="M:VO.IpcTopic.DeleteItem(XSharp.__Usual)">
      <summary>
        Delete an item from the list of items associated with the topic.
      </summary>
      <param name="cItemString">The IPC item to be deleted.</param>
    </member>
    <member name="M:VO.IpcTopic.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.IpcTopicData">
      <summary>
        Create a global memory object and pass a data handle back to the application.
      </summary>
      <remarks>
        The IpcTopicData object contains a pointer to the data and the length of the data string (it is created as a global memory object by Windows DDE management library and it passes a data handle back to the application).
      </remarks>
    </member>
    <member name="M:VO.IpcTopicData.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct an IpcTopicData object.
      </summary>
      <param name="ptrString">A pointer to the data string.</param>
      <param name="nLength">The number of characters to transfer.  If not specified, the entire length of the data string is used.</param>
      <remarks>
        An IpcTopicData object is used for transferring data in response to a data request call on an IpcServer object.
      </remarks>
    </member>
    <member name="P:VO.IpcTopicData.Data">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.IpcTopicData.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.IpcTopicData.Length">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="F:VO.IpcTopicData.liLen">
      <exclude />
    </member>
    <member name="F:VO.IpcTopicData.ptrData">
      <exclude />
    </member>
    <member name="T:VO.IReadCookie">
      <summary>
        Provide a class for retrieving the values of the cookies sent in an HTTP request.
      </summary>
      <remarks>
        The IReadCookie class enables you to retrieve the values of the cookies sent in an HTTP request.
      </remarks>
    </member>
    <member name="M:VO.IReadCookie.#ctor">
      <summary>
        Construct an IReadCookie object instance.
      </summary>
      <param name="pICookie">Pointer to an IReadCookie Interface object structure.</param>
      <param name="oIServer">The IServer object instance.</param>
      <remarks>
        An IReadCookie object instance can be created by the IRequest:GetCookies() method because it is directly associated with an HTTP request.  Therefore, you do not have to create this object yourself.  Rather, use it for an ASP Component application via the IScriptingContext:Request:GetCookies() method.
      </remarks>
      <example>
        See the IReadCookie:GetItem() example.
      </example>
    </member>
    <member name="M:VO.IReadCookie.GetEnum">
      <summary>
        Retrieve the number of items from a cookie object.
      </summary>
      <returns>
        Number of cookie items (type INT), if successful; otherwise, 0.
      </returns>
      <remarks>
        This method retrieves the number of stored items for a cookie object.
      </remarks>
      <example>
        See the IReadCookie:GetItem() example.
      </example>
    </member>
    <member name="M:VO.IReadCookie.GetHasKeys">
      <summary>
        Indicate whether or not a cookie object has keys.
      </summary>
      <returns>
        TRUE, if the current cookie has keys; otherwise, FALSE.
      </returns>
      <remarks>
        This method returns a logical value which indicates whether or not the cookie has keys.
      </remarks>
    </member>
    <member name="M:VO.IReadCookie.GetItem">
      <summary>
        Retrieve the specified item from a cookie object.
      </summary>
      <param name="cItemName">The name of the variable (item) to to be retrieved.</param>
      <returns>
        A string value, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        This method retrieves the specified item, &lt;cItemName&gt;, from the cookie object.
      </remarks>
      <example>
        The following sample displays the cookie collection of an appropriate request:
        <code language="X#">
          GLOBAL goASPComponent 	AS ASPComponent
          PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}
          CLASS ASPComponent INHERIT IScriptingContext
        </code><code language="X#">
          METHOD	HTTPResponse 	CLASS ASPComponent
             LOCAL oCookie	AS IReadCookie
             LOCAL aTemp	AS ARRAY
             LOCAL aRet	AS ARRAY
             LOCAL n,i		AS INT
             LOCAL cName	AS STRING
             LOCAL cRet	AS STRING
             oCookie := SELF:Request:GetCookies()
             IF oCookie == NULL_OBJECT
             	n     := oCookie:GetEnum()
             	aRet  := ArrayCreate(n)
          FOR i := 1 TO n
          aTemp  := ArrayCreate(2)
          cName  := oCookie:GetName(i)
          aTemp[1] := cName
          aTemp[2] := oCookie:GetItem(cName)
          aRet[i]  := aTemp
          NEXT
          ENDIF
        </code><code language="X#">
          cRet := GetHTTPValueTable(aTemp)
          RETURN SELF:Response:_Write(cRet)
        </code></example>
    </member>
    <member name="M:VO.IReadCookie.GetName">
      <summary>
        Retrieve the name of the specified item from a cookie object.
      </summary>
      <param name="nItem">The number (position) of the item within the cookie item collection.</param>
      <returns>
        Item name (type STRING), if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        This method retrieves the name of the specified item, &lt;nItem&gt;, from the cookie object.
      </remarks>
      <example>
        See the IReadCookie:GetItem() example.
      </example>
    </member>
    <member name="T:VO.IRequest">
      <summary>
        Class to retrieve the values that the client browser passed to the server during an HTTP request.
      </summary>
      <remarks>
        The IRequest class retrieves the values that the client browser passed to the server during an HTTP request.  The variables are internally stored by collections in the following order:
        1.	QueryString
        2.	Form
        3.	Cookies
        4.	ClientCertificate
        5.	ServerVariables
        The IRequest class provides the following kinds of methods:
        Methods to retrieve these collections as arrays containing value {name, value} pairs for each collection (e.g., GetForms()).
        Methods to retrieve a certain value of one of these collections (e.g., GetForm("firstname")).
        Methods to retrieve the value without the knowledge about to what collection it belongs (e.g., GetItem("firstname")).
      </remarks>
    </member>
    <member name="M:VO.IRequest.#ctor">
      <summary>
        Construct an IRequest object instance.
      </summary>
      <param name="oIScrContext">An IScriptingContext object.</param>
      <param name="pIRequest">Pointer to an IRequest Interface object structure.</param>
      <remarks>
        An IRequest object instance is automatically created by the IScriptingContext:OnStartPage() method when the appropriate .ASP file is loaded by the Internet Information Server (IIS).  Therefore, you do not have to create this object yourself.  Rather, use it for an ASP Component application via the IScriptingContext:Request property.
      </remarks>
    </member>
    <member name="M:VO.IRequest.GetClientCertificate">
      <summary>
        Retrieve a value of the client certificate collection of an IRequest object.
      </summary>
      <param name="cVarName">Name of the certificate field.</param>
      <param name="n">Position, if more than one variable with the same name, &lt;cVarName&gt;, exists within the collection. </param>
      <returns>
        A string value, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        The GetClientCertificate() method retrieves a certification field (specified in the X.509 standard) from the request issued by the Web browser.  If a Web browser uses the SSL3.0/PCT1 protocol (i.e., URL starts with "https://" instead of "http://") to connect to a server and the server requests certification, the browser sends the certification field.  If no certificate is sent, the collection array is empty and the return value is NULL_STRING.
      </remarks>
    </member>
    <member name="M:VO.IRequest.GetClientCertificates">
      <summary>
        Retrieve the certification fields as a two-dimensional array.
      </summary>
      <returns>
        Two-dimensional array with name-value pairs, if successful; otherwise, an empty array.
      </returns>
      <remarks>
        The GetClientCertificates() method retrieves all certification fields (specified in the X.509 standard) as a two-dimensional array.  If a Web browser uses the SSL3.0/PCT1 protocol (i.e., URL starts with "https://" instead of "http://") to connect to a server and the server requests certification, the browser sends the certification fields.  If no certificate is sent, the collection array is empty.
      </remarks>
    </member>
    <member name="M:VO.IRequest.GetCookies">
      <summary>
        Retrieve the cookie collection of an IRequest object.
      </summary>
      <returns>
        The IReadCookie object instance.
      </returns>
      <remarks>
        This method retrieves an IReadCookie object instance of the IRequest object.
      </remarks>
      <example>
        The following example demonstrates the use of this method:
        <code language="X#">
          GLOBAL goASPComponent 	AS ASPComponent
          PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}
          CLASS ASPComponent INHERIT IScriptingContext
        </code><code language="X#">
          METHOD	HTTPResponse 	CLASS ASPComponent
             LOCAL oCookie	AS IReadCookie
             LOCAL aTemp	AS ARRAY
             LOCAL aRet	AS ARRAY
             LOCAL n,i		AS INT
             LOCAL cName	AS STRING
             LOCAL cRet	AS STRING
             oCookie := SELF:Request:GetCookies()
          IF oCookie == NULL_OBJECT
             ELSE
             	n     := oCookie:GetEnum()
             	aRet  := ArrayCreate(n)
          FOR i := 1 UPTO n
          aTemp  := ArrayCreate(2)
          cName  := oCookie:GetName(i)
          aTemp[1] := cName
          aTemp[2] := oCookie:GetItem(cName)
          aRet[i]  := aTemp
          NEXT
          ENDIF
        </code><code language="X#">
          cRet := GetHTTPValueTable(aTemp)
          RETURN SELF:Response:_Write(cRet)
        </code>
        ASP code:
        <code language="X#">
          &lt;%
          Response.Cookies("mycookie")("value1") = "Hello"
          Response.Cookies("mycookie")("value2") = "World"
          Response.Cookies("value1") = "X#"
          Response.Cookies("value2") = "rules"
          Set oComp = Server.CreateObject("VoAsp.Component")
          oComp.HTTPResponse()
          %&gt;
        </code>
        The result would be:

      </example>
    </member>
    <member name="M:VO.IRequest.GetForm">
      <summary>
        Retrieve a form value of an IRequest object.
      </summary>
      <param name="cVarName">Name of the form field.</param>
      <param name="n">Position, if more than one variable with the same name, &lt;cVarName&gt;, exists within the collection. </param>
      <returns>
        A string value, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        The GetForm() method retrieves a form value posted to the HTTP request body by a form using the POST method.  If no form value is sent, the collection array is empty and the return value is NULL_STRING.
      </remarks>
      <example>
        The following example demonstrates the use of this method:
        <code language="X#">
          GLOBAL goASPComponent  AS ASPComponent
          PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}
          CLASS ASPComponent INHERIT IScriptingContext
          METHOD	HTTPResponse 	CLASS ASPComponent
          LOCAL cRet  AS STRING
          cRet := SELF:Request:GetForm("Value1")
          RETURN SELF:Response:_Write("Value1=" + cRet)
        </code>
        HTML code:
        <code language="X#">
          &lt;form action="response.asp?Action=FORM" method="post"&gt;
           &lt;p&gt;Value1: &lt;input type="text" name="Value1" size="4"&gt;&lt;/p&gt;
           &lt;p&gt;&lt;input type="submit" value="Execute POST Request"&gt; &lt;/p&gt;
          &lt;/form&gt;
        </code>
        ASP code (response.asp):
        <code language="X#">
          &lt;%
          Set oComp = Server.CreateObject("VoAsp.Component")
          oComp.HTTPResponse()
          %&gt;
        </code></example>
    </member>
    <member name="M:VO.IRequest.GetForms">
      <summary>
        Retrieve all form values of an IRequest object.
      </summary>
      <returns>
        Two-dimensional array with name-value pairs, if successful; otherwise, an empty array.
      </returns>
      <remarks>
        The GetForms() method retrieves all values posted to the HTTP request body by a form (via POST method) as a two-dimensional array.  If no form values are sent, the collection array is empty.
      </remarks>
      <example>
        The following example demonstrates the use of this method:
        <code language="X#">
          GLOBAL goASPComponent 	AS ASPComponent
          PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}
          CLASS ASPComponent INHERIT IScriptingContext
        </code><code language="X#">
          METHOD	HTTPResponse 	CLASS ASPComponent
          LOCAL aTemp     AS ARRAY
          LOCAL cRet      AS STRING

             aTemp := SELF:Request:GetForms()
             cRet := GetHTTPValueTable(aTemp)
          RETURN SELF:Response:_Write(cRet)
        </code>
        HTML code:
        <code language="X#">
          &lt;form action="response.asp?Action=FORM" method="post"&gt;
           &lt;p&gt;Value1: &lt;input type="text" name="Value1" size="4"&gt;&lt;/p&gt;
           &lt;p&gt;Value2: &lt;input type="text" name="Value2"  size="5"&gt;&lt;/p&gt;
           &lt;p&gt;Value2: &lt;input type="text" name="Value2"  size="5"&gt;&lt;/p&gt;
           &lt;p&gt;&lt;input type="submit" value="Execute POST Request"&gt; &lt;/p&gt;
          &lt;/form&gt;
        </code>
        ASP code (response.asp):
        <code language="X#">
          &lt;%
          Set oComp = Server.CreateObject("VoAsp.Component")
          oComp.HTTPResponse()
          %&gt;
        </code></example>
    </member>
    <member name="M:VO.IRequest.GetItem">
      <summary>
        Retrieve any value of the HTTP request body.
      </summary>
      <param name="cVarName">Name of the variable.</param>
      <returns>
        A string value, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        This method returns a value posted to the HTTP request body.  The collections are searched in the following order: QueryString, Form, Cookies, ClientCertificate, ServerVariables.
      </remarks>
      <example>
        The following example demonstrates the use of this method:
        <code language="X#">
          GLOBAL goASPComponent 	AS ASPComponent
          PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}
          CLASS ASPComponent INHERIT IScriptingContext
        </code><code language="X#">
          METHOD	HTTPResponse 	CLASS ASPComponent
          LOCAL cRet      AS STRING
             cRet := SELF:Request:GetItem("Value1")
             RETURN SELF:Response:_Write("Value1=" + cRet)
        </code>
        HTML code:
        <code language="X#">
          &lt;form action="response.asp?Action=FORM" method="post"&gt;
           &lt;p&gt;Value1: &lt;input type="text" name="Value1" size="4"&gt;&lt;/p&gt;
           &lt;p&gt;&lt;input type="submit" value="Execute POST Request"&gt; &lt;/p&gt;
          &lt;/form&gt;
        </code>
        ASP code (response.asp):
        <code language="X#">
          &lt;%
          Set oComp = Server.CreateObject("VoAsp.Component")
          oComp.HTTPResponse()
          %&gt;
        </code></example>
    </member>
    <member name="M:VO.IRequest.GetQueryString">
      <summary>
        Retrieve a value of the HTTP request's query string.
      </summary>
      <param name="cVarName">Name of the variable.</param>
      <param name="n">Position, if more than one variable with the same name, &lt;cVarName&gt;, exists within the collection. </param>
      <returns>
        A string value, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        The GetQueryString() method retrieves a value of the variables in the HTTP query string (i.e., the values encoded after the question mark (?) in an HTTP request).
      </remarks>
      <example>
        The following example demonstrates the use of this method:
        <code language="X#">
          GLOBAL goASPComponent 	AS ASPComponent
          PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}
          CLASS ASPComponent INHERIT IScriptingContext
        </code><code language="X#">
          METHOD	HTTPResponse 	CLASS ASPComponent
          LOCAL cRet      AS STRING
             cRet := SELF:Request:GetQueryString("Action")
             RETURN SELF:Response:_Write("Action=" + cRet)
        </code>
        HTML code:
        <code language="X#">
          &lt;html&gt;
          &lt;p&gt;
          &lt;a href="response.asp?Action=TEST&amp;Display=Yes"&gt;
          Start
          &lt;/a&gt;&lt;/p&gt;
          ...
          &lt;/html&gt;
        </code>
        ASP code (response.asp):
        <code language="X#">
          &lt;%
          Set oComp = Server.CreateObject("VoAsp.Component")
          oComp.HTTPResponse()
          %&gt;
        </code></example>
    </member>
    <member name="M:VO.IRequest.GetQueryStrings">
      <summary>
        Retrieve all values of the variables in the HTTP query string.
      </summary>
      <returns>
        Two-dimensional array with name-value pairs, if successful; otherwise, an empty array.
      </returns>
      <remarks>
        The GetQueryStrings() method retrieves all values of the variables in the HTTP query string (i.e., the values encoded after the question mark (?) via GET method) as a two-dimensional array.  If no values are sent, the array is empty.
      </remarks>
      <example>
        The following example demonstrates the use of this method:
        <code language="X#">
          GLOBAL goASPComponent 	AS ASPComponent
          PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}
          CLASS ASPComponent INHERIT IScriptingContext
        </code><code language="X#">
          METHOD	HTTPResponse 	CLASS ASPComponent
          LOCAL aTemp     AS ARRAY
          LOCAL cRet      AS STRING

             aTemp := SELF:Request:GetQueryStrings()
             cRet := GetHTTPValueTable(aTemp)
          RETURN SELF:Response:_Write(cRet)
        </code>
        HTML code:
        <code language="X#">
          &lt;html&gt;
          &lt;p&gt;
          &lt;a href="response.asp?Action=TEST&amp;Display=Yes"&gt;
            Start
          &lt;/a&gt;&lt;/p&gt;
          ...
          &lt;/html&gt;
        </code>
        ASP code (response.asp):
        <code language="X#">
          &lt;%
          Set oComp = Server.CreateObject("VoAsp.Component")
          oComp.HTTPResponse()
          %&gt;
        </code></example>
    </member>
    <member name="M:VO.IRequest.GetServerVariable">
      <summary>
        Retrieve a value from the environment variables collection of an IRequest object.
      </summary>
      <param name="cVarName">
        The name of the environment variable.
        Valid names are:
      </param>
      <param name="AUTH_TYPE">REMOTE_HOST</param>
      <param name="CONTENT_LENGTH">REQUEST_METHOD</param>
      <param name="CONTENT_TYPE">SCRIPT_MAP</param>
      <param name="GATEWAY_INTERFACE">SCRIPT_NAME</param>
      <param name="HTTP_HeaderName">SERVER_NAME</param>
      <param name="LOGON_USER">SERVER_PORT</param>
      <param name="PATH_INFO">SERVER_PORT_SECURE</param>
      <param name="PATH_TRANSLATED">SERVER_PROTOCOL</param>
      <param name="QUERY_STRING">SERVER_SOFTWARE</param>
      <param name="REMOTE_ADDR">URL</param>
      <returns>
        Value of type STRING, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        The GetServerVariable() method retrieves a value from the environment variables collection of the IRequest object.
      </remarks>
      <example>
        The following example demonstrates the use of this method:
        <code language="X#">
          GLOBAL goASPComponent 	AS ASPComponent
          PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}
          CLASS ASPComponent INHERIT IScriptingContext
        </code><code language="X#">
          METHOD	HTTPResponse 	CLASS ASPComponent
          LOCAL cRet      AS STRING
             cRet := ;
             SELF:Request:GetServerVariable("PATH_TRANSLATED")
             RETURN SELF:Response:_Write("Path name: " + cRet)
        </code>
        HTML code:
        <code language="X#">
          &lt;html&gt;
          &lt;p&gt;
          &lt;a href="response.asp"&gt;
            Display Path
          &lt;/a&gt;&lt;/p&gt;
          ...
          &lt;/html&gt;
        </code>
        ASP code (response.asp):
        <code language="X#">
          &lt;%
          Set oComp = Server.CreateObject("VoAsp.Component")
          oComp.HTTPResponse()
          %&gt;
        </code></example>
    </member>
    <member name="M:VO.IRequest.GetServerVariables">
      <summary>
        Retrieve all environment variables of an IRequest object.
      </summary>
      <returns>
        Two-dimensional array with name-value pairs, if successful; otherwise, an empty array.
      </returns>
      <remarks>
        The GetServerVariables() method retrieves all values of the server's environment as a two-dimensional array.
      </remarks>
      <example>
        The following example demonstrates the use of this method:
        <code language="X#">
          GLOBAL goASPComponent 	AS ASPComponent
          PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}
          CLASS ASPComponent INHERIT IScriptingContext
        </code><code language="X#">
          METHOD	HTTPResponse 	CLASS ASPComponent
          LOCAL aTemp     AS ARRAY
          LOCAL cRet      AS STRING

             aTemp := SELF:Request:GetServerVariables()
             cRet := GetHTTPValueTable(aTemp)
          RETURN SELF:Response:_Write(cRet)
        </code>
        HTML code:
        <code language="X#">
          &lt;html&gt;
          &lt;p&gt;
          &lt;a href="response.asp"&gt;
            Display Server Environment
          &lt;/a&gt;&lt;/p&gt;
          ...
          &lt;/html&gt;
        </code>
        ASP code (response.asp):
        <code language="X#">
          &lt;%
          Set oComp = Server.CreateObject("VoAsp.Component")
          oComp.HTTPResponse()
          %&gt;
        </code></example>
    </member>
    <member name="T:VO.IResponse">
      <summary>
        Send output to the client.
      </summary>
      <remarks>
        The IResponse class is used to send output to the client.
      </remarks>
    </member>
    <member name="M:VO.IResponse.#ctor">
      <summary>
        Construct an IResponse object instance.
      </summary>
      <param name="oIScrContext">An IScriptingContext object.</param>
      <param name="pIRequest">Pointer to an IResponse Interface object structure.</param>
      <remarks>
        An IResponse object instance is automatically created by the IScriptingContext:OnStartPage() method when the appropriate .ASP file is loaded by the Internet Information Server (IIS).  Therefore, you do not have to create this object yourself.  Rather, use it for an ASP Component application via the IScriptingContext:Request property.
      </remarks>
    </member>
    <member name="M:VO.IResponse._AddHeader">
      <summary>
        Add an HTML header to an HTTP response.
      </summary>
      <param name="cHeaderName">String containing the name of the HTTP header.</param>
      <param name="cHeader">String containing the HTTP header.</param>
      <returns>
        TRUE, if the value has been added; otherwise, FALSE.
      </returns>
      <remarks>
        This method adds an HTML header to the HTTP response.
      </remarks>
    </member>
    <member name="M:VO.IResponse._AppendToLog">
      <summary>
        Add a string to the end of the Web server log entry for the current request.
      </summary>
      <param name="cMessage">String to append to the log entry.</param>
      <returns>
        TRUE, if the value has been appended; otherwise, FALSE.
      </returns>
      <remarks>
        This method appends a string to the end of the Web server log entry for the current request.  The log entry can contain a maximum of 80 bytes.
      </remarks>
    </member>
    <member name="M:VO.IResponse._Clear">
      <summary>
        Erase any buffered HTML output of the current response.
      </summary>
      <returns>
        TRUE, if the value has been changed; otherwise, FALSE.
      </returns>
      <remarks>
        This method erases any buffered HTML output of the current response.
      </remarks>
    </member>
    <member name="M:VO.IResponse._End">
      <summary>
        Cause the server to stop processing the script and to return the current response.
      </summary>
      <returns>
        TRUE, if the value has been changed; otherwise, FALSE.
      </returns>
      <remarks>
        This method causes the server to stop processing the script and to return the current response.
      </remarks>
    </member>
    <member name="M:VO.IResponse._Flush">
      <summary>
        Send buffered output immediately.
      </summary>
      <returns>
        TRUE, if the value has been changed; otherwise, FALSE.
      </returns>
      <remarks>
        This method sends buffered output immediately to the client.
      </remarks>
    </member>
    <member name="M:VO.IResponse._Redirect">
      <summary>
        Cause the browser to attempt to connect to a different URL.
      </summary>
      <param name="cNewURL">A new URL value as STRING.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method stops the server from processing the current script and then causes the browser to attempt to connect to &lt;cNewURL&gt;.
      </remarks>
    </member>
    <member name="M:VO.IResponse._Write">
      <summary>
        Write a specified string the HTTP output.
      </summary>
      <param name="cOut">String containing the HTTP output.</param>
      <param name="nSize">Number of bytes to write.  If omitted, defaults to the length of &lt;cOut&gt;.</param>
      <returns>
        TRUE, if the value has been changed; otherwise, FALSE.
      </returns>
      <remarks>
        This method writes data to the HTTP output.
      </remarks>
    </member>
    <member name="M:VO.IResponse.GetBuffer">
      <summary>
        Retrieve the current value of the Buffer flag property of an IResponse object.
      </summary>
      <returns>
        TRUE, if the value of the current HTTP output is buffered; otherwise, FALSE.
      </returns>
      <remarks>
        This method retrieves the current value of the Buffer flag property of the IResponse object.
      </remarks>
    </member>
    <member name="M:VO.IResponse.GetContentType">
      <summary>
        Retrieve the current value of the ContentType property of an IResponse object.
      </summary>
      <returns>
        The content type of the IResponse object as STRING, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        This method retrieves the current value of the ContentType property of the IResponse object.
      </remarks>
    </member>
    <member name="M:VO.IResponse.GetCookies">
      <summary>
        Retrieve the cookie collection of an IResponse object.
      </summary>
      <returns>
        An IWriteCookie object instance.
      </returns>
      <remarks>
        This method retrieves the write-only cookie collection as an IWriteCookie object instance of the IResponse object.
      </remarks>
    </member>
    <member name="M:VO.IResponse.GetExpires">
      <summary>
        Retrieve the current value of the Expires property of an IResponse object.
      </summary>
      <returns>
        The expires value of the IResponse object in minutes (type LONG).
      </returns>
      <remarks>
        This method retrieves the current value of the Expires property of the IResponse object.  This property specifies the length of time before a page cached on a browser expires.  If the user returns to the same page before it expires, the cached version is displayed.
      </remarks>
    </member>
    <member name="M:VO.IResponse.GetExpiresAbsolute">
      <summary>
        Retrieve the current value of the ExpiresAbsolute property of an IResponse object.
      </summary>
      <returns>
        The expires value of the IResponse object as a DATE value.
      </returns>
      <remarks>
        This method retrieves the current value of the ExpiresAbsolute property of the IResponse object.  This property specifies the date at which a page cached on a browser expires.  If the user returns to the same page before that date and time, the cached version is displayed.  If a time is not specified, the page expires at midnight of that day.  If a date is not specified, the page expires at the given time on the day that the script is run.
      </remarks>
    </member>
    <member name="M:VO.IResponse.GetStatus">
      <summary>
        Retrieve the current value of the Status property of an IResponse object.
      </summary>
      <returns>
        The current value of the Status property as STRING.
      </returns>
      <remarks>
        This method retrieves the current value of the Status property of the IResponse object.  The status specifies the value of the status line returned by the server.  Status values are defined in the HTTP specification.
      </remarks>
    </member>
    <member name="M:VO.IResponse.PutBuffer">
      <summary>
        Set the current value of the Buffer flag property of an IResponse object.
      </summary>
      <param name="lNew">New value of the Buffer flag property.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sets the value of the Buffer flag property of the IResponse object.
      </remarks>
    </member>
    <member name="M:VO.IResponse.PutContentType">
      <summary>
        Set the current value of the ContentType property of an IResponse object.
      </summary>
      <param name="cType">The general content category.</param>
      <param name="cSubType">A specific content type.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sets the value of the ContentType property of the IResponse object as a string describing the content type.  This string is usually formatted, type/subtype where type is the general content category and subtype is the specific content type.  For a full list of supported content types, see your Web browser documentation or the current HTTP specification.
      </remarks>
      <example>
        The following example demonstrates the use of this method:
        <code language="X#">
          GLOBAL goASPComponent 	AS ASPComponent
          PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}
          CLASS ASPComponent INHERIT IScriptingContext
        </code><code language="X#">
          METHOD	HTTPResponse 	CLASS ASPComponent
          LOCAL aTemp     AS ARRAY
          LOCAL cRet      AS STRING
          ...
             SELF:Response:PutContentType(/gif
             SELF:Response:PutContentType(text/html
        </code><code language="X#">	RETURN SELF:Response:_Write("Hello world")</code></example>
    </member>
    <member name="M:VO.IResponse.PutExpires">
      <summary>
        Set the current value of the Expires property of an IResponse object.
      </summary>
      <param name="nMinutes">New expires value expressed in minutes.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sets the current value of the Expires property of the IResponse object.  This property specifies the length of time before a page cached on a browser expires.  If the user returns to the same page before it expires, the cached version is displayed.
      </remarks>
    </member>
    <member name="M:VO.IResponse.PutExpiresAbsolute">
      <summary>
        Set the current value of the Expires property of an IResponse object.
      </summary>
      <param name="dNew">New expires value as DATE.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sets the new value for the ExpiresAbsolute property of the IResponse object.  This property specifies the date at which a page cached on a browser expires.  If the user returns to the same page before that date, the cached version is displayed.  If a time is not specified, the page expires at midnight of that day.  If a date is not specified, the page expires at the given time on the day that the script is run.
      </remarks>
    </member>
    <member name="M:VO.IResponse.PutStatus">
      <summary>
        Set a new value for the Status property of an IResponse object.
      </summary>
      <param name="cNew">New status value as STRING.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sets a new value to the Status property of the IResponse object.  The status specifies the value of the status line returned by the server.  Status values are defined in the HTTP specification.
      </remarks>
    </member>
    <member name="T:VO.IScriptingContext">
      <summary>
        Retrieve the Active Server Pages (ASP) built-in objects.
      </summary>
      <remarks>
        This class exposes methods that your component can use to retrieve the Active Server Pages (ASP) built-in objects.
      </remarks>
    </member>
    <member name="M:VO.IScriptingContext.#ctor">
      <summary>
        Construct an IScriptingContext object instance.
      </summary>
    </member>
    <member name="P:VO.IScriptingContext.Application">
      <summary>
        An IApplicationObject object instance.
      </summary>
      <value>An IApplicationObject object instance.</value>
    </member>
    <member name="P:VO.IScriptingContext.ASPApp">
      <summary>
        An ASPAppAbstract object instance.
      </summary>
      <value>An ASPAppAbstract object instance.</value>
    </member>
    <member name="M:VO.IScriptingContext.GetApplication">
      <summary>
        Retrieve the build in an IApplicationObject instance.
      </summary>
      <returns>
        An IApplicationObject instance, if successful; otherwise, NULL_OBJECT.
      </returns>
      <remarks>
        The GetApplication() method creates a new IApplicationObject instance based on the build in the IApplicationObject interface pointer.  This method is called internally by the OnStartPage() method when the appropriate ASP script file is loaded by the Internet Information Server.  You can access the created instance, &lt;oIAppObj&gt;, by means of the Application property.
      </remarks>
    </member>
    <member name="M:VO.IScriptingContext.GetRequest">
      <summary>
        Retrieve the build in an IRequest instance.
      </summary>
      <returns>
        An IRequest instance, if successful; otherwise, NULL_OBJECT.
      </returns>
      <remarks>
        This method creates a new IRequest instance based on the build in the IRequest interface pointer.  The method is called internally by the OnStartPage() method when the appropriate ASP script file is loaded by the Internet Information Server.  You can access the created instance, &lt;oIRequest&gt;, by means of the Request property.
      </remarks>
    </member>
    <member name="M:VO.IScriptingContext.GetResponse">
      <summary>
        Retrieve the build in an IResponse object instance.
      </summary>
      <returns>
        An IResponse instance, if successful; otherwise, NULL_OBJECT.
      </returns>
      <remarks>
        This method creates a new IResponse instance based on the build in the IResponse interface pointer.  The method is called internally by the OnStartPage() method when the appropriate ASP script file is loaded by the Internet Information Server.  You can access the created instance, &lt;oIResponse&gt;, by means of the Response property.
      </remarks>
    </member>
    <member name="M:VO.IScriptingContext.GetServer">
      <summary>
        Retrieve the build in an IServer object instance.
      </summary>
      <returns>
        An IServer instance, if successful; otherwise, NULL_OBJECT.
      </returns>
      <remarks>
        This method creates a new IServer instance based on the build in the IServer interface pointer.  The method is called internally by the OnStartPage() method when the appropriate ASP script file is loaded by the Internet Information Server.  You can access the created instance, &lt;oIServer&gt;, by means of the Server property.
      </remarks>
    </member>
    <member name="M:VO.IScriptingContext.GetSession">
      <summary>
        Retrieve the build in an ISessionObject instance.
      </summary>
      <returns>
        An ISessionObject instance, if successful; otherwise, NULL_OBJECT.
      </returns>
      <remarks>
        This method creates a new ISessionObject instance based on the build in the ISessionObject interface pointer.  The method is called internally by the OnStartPage() method when the appropriate ASP script file is loaded by the Internet Information Server.  You can access the created instance, &lt;oISessionObject&gt;, by means of the Session property.
      </remarks>
    </member>
    <member name="M:VO.IScriptingContext.GetVariantString">
      <summary>
        Helper method to convert a VARIANT string to a X# string.
      </summary>
      <param name="pString">Pointer to an IDispatch object.</param>
      <returns>
        A converted X# STRING, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        This method converts a VARIANT to a dynamic X# string value.  This method can be used to implement ASSIGN methods with STRING arguments.
      </remarks>
      <example>
        The following sample is a typical implementation of the STRING property, Action, for an ASP Component:
        <code language="X#">
          CLASS ASPComponent INHERIT IScriptingContext
          PROTECT  cAction  AS STRING
        </code><code language="X#">
          ASSIGN Action(cNew)  CLASS ASPComponent
          SELF:cAction := SELF:GetVariantString(cNew)
          RETURN SELF:cAction
          ACCESS Action  CLASS ASPComponent
          RETURN SELF:cAction
        </code></example>
    </member>
    <member name="M:VO.IScriptingContext.HTTPErrorMessage">
      <summary>
        Create HTML code to display all values of a X# Error object.
      </summary>
      <param name="oError">The current Error object instance.</param>
      <returns>
        String containing HTML code for displaying the error within an Internet browser.
      </returns>
      <remarks>
        This method creates HTML code based on the values of a X# Error object, and will be automatically invoked if a runtime error occurs.  If you want to modify the default error message design, just overload this method.
      </remarks>
      <example>
        The following sample demonstrates how to overload the default error handling method to create a customized HTML output:
        <code language="X#">
          GLOBAL goASPComponent  AS ASPComponent
          PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}
          CLASS ASPComponent INHERIT IScriptingContext
          METHOD HTTPErrorMessage(oError)  CLASS ASPComponent
          LOCAL cRet  AS STRING
          IF IsObject(oError)
          cRet := SUPER:HTTPErrorMessage(oError)
          ENDIF
          RETURN cRet
          METHOD  HTTPGoBackLink (cCaption)  CLASS ASPComponent
          LOCAL cRef  AS STRING
          LOCAL cRet  AS STRING
          IF !IsString(cCaption)
          cCaption := "Back"
          ENDIF
          cRef := ;
          SELF:oRequest:GetServerVariable("HTTP_REFERER")
          cRet += '&lt;p&gt;&lt;a href="'
          cRet += cRef + '"&gt;'
          cRet += cCaption
          cRet += '&lt;/a&gt;&lt;/p&gt;'
          RETURN cRet
        </code></example>
    </member>
    <member name="M:VO.IScriptingContext.HTTPQueryString">
      <summary>
        Create HTML code to display all query string items.
      </summary>
      <returns>
        String containing HTML code for displaying all items of the query string.
      </returns>
      <remarks>
        The HTTPRequestItems() method creates HTML code to display all query string items.
      </remarks>
      <example>
        The following source code can be used to create an ASP component for displaying the query string items:
        <code language="X#">
          GLOBAL goASPComponent  AS ASPComponent
          PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}
          CLASS ASPComponent INHERIT IScriptingContext
        </code><code language="X#">
          METHOD	HTTPResponse 	CLASS ASPComponent
          LOCAL cRet	AS STRING
          cRet := SELF:HTTPQueryString()
          RETURN SELF:Response:_Write(cRet)
        </code>
        ASP code:
        <code language="X#">
          &lt;%
          Set oComp = Server.CreateObject("VoAsp.Component")
          oComp.HTTPResponse()
          %&gt;
        </code></example>
    </member>
    <member name="M:VO.IScriptingContext.HTTPServerVariables">
      <summary>
        Create HTML code to display all environment variables of an Internet server.
      </summary>
      <returns>
        String containing HTML code to display all environment variables.
      </returns>
      <remarks>
        The HTTPServerVariables() method creates HTML code to display all environment variables of the Internet server.
      </remarks>
      <example>
        The following source code can be used to create an ASP component for displaying the server environment:
        <code language="X#">
          GLOBAL goASPComponent  AS ASPComponent
          PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}
          CLASS ASPComponent INHERIT IScriptingContext
        </code><code language="X#">
          METHOD	HTTPResponse 	CLASS ASPComponent
          LOCAL cRet	AS STRING
          cRet := SELF:HTTPServerVariables()
          RETURN SELF:Response:_Write(cRet)
        </code>
        ASP code:
        <code language="X#">
          &lt;%
          Set oComp = Server.CreateObject("VoAsp.Component")
          oComp.HTTPResponse()
          %&gt;
        </code></example>
    </member>
    <member name="M:VO.IScriptingContext.OnEndPage">
      <summary>
        Clean up (exit) method for ASP components.
      </summary>
      <remarks>
        When the server finishes processing the script on an ASP page, it calls the OnEndPage() method for all components that have implemented OnEndPage().  The server calls this method after processing the script on that page.
        <note type="tip">If you want to overload this method for your own de-initialization operation, call the SUPER method first.</note></remarks>
    </member>
    <member name="M:VO.IScriptingContext.OnStartPage">
      <summary>
        Entry point for ASP components.
      </summary>
      <param name="pDispatch">Pointer to an IDispatch Interface object.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        When a user requests a Web page in an ASP-based application, the server calls the OnStartPage() method for all components on that page (except those with application scope).  This method creates object instances for following built-in interfaces:
        ISessionObject
        IApplicationObject
        IRequest
        IResponse
        IServer
        <note type="tip">If you want to overload this method for your own initialization operation, call the SUPER method first.</note></remarks>
      <example>
        The following source code shows how to overload OnStartPage() for your own purposes:
        <code language="X#">
          GLOBAL goASPComponent  AS ASPComponent
          PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}
          CLASS ASPComponent INHERIT IscriptingContext
             LOCAL p AS PTR  
        </code><code language="X#">
          METHOD	OnStartPage(pDispatch)	CLASS ASPComponent
             IF SUPER:OnStartPage(pDispatch)
                 SELF:p := MemAlloc(100)
             ENDIF
          METHOD	OnEndPage()		CLASS ASPComponent
             SUPER:OnEndPage()
             IF SELF:p != NULL_PTR
                 MemFree(SELF:p)
                 SELF:p := NULL_PTR
             ENDIF
        </code>
        ASP code:
        <code language="X#">
          &lt;%
          Set oComp = Server.CreateObject("VoAsp.Component")
          oComp.HTTPResponse()
          %&gt;
        </code></example>
    </member>
    <member name="P:VO.IScriptingContext.Request">
      <summary>
        An IRequest object instance.
      </summary>
      <value>An IRequest object instance.</value>
    </member>
    <member name="P:VO.IScriptingContext.Response">
      <summary>
        An IResponse object instance.
      </summary>
      <value>An IResponse object instance.</value>
    </member>
    <member name="P:VO.IScriptingContext.Server">
      <summary>
        An IServer object instance.
      </summary>
      <value>An IServer object instance.</value>
    </member>
    <member name="P:VO.IScriptingContext.Session">
      <summary>
        An ISession object instance.
      </summary>
      <value>An ISession object instance.</value>
    </member>
    <member name="M:VO.IScriptingContext.WriteImage">
      <summary>
        Create HTML code to display images for ASP components.
      </summary>
      <param name="cFile">Image file name, including drive letter and path.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        WriteImage() creates HTML code for displaying images in ASP components.
      </remarks>
    </member>
    <member name="T:VO.IServer">
      <summary>
        Provide utility methods on the server.
      </summary>
      <remarks>
        The IServer class provides methods on the server that serve as utility functions.
      </remarks>
    </member>
    <member name="M:VO.IServer.#ctor">
      <summary>
        Construct an IServer object instance.
      </summary>
      <param name="oIScrContext">An IScriptingContext object.</param>
      <param name="pIServer">Pointer to an IServer Interface object structure.</param>
      <remarks>
        An IServer object instance is automatically created by the IScriptingContext:OnStartPage() method when the appropriate .ASP file is loaded by an Internet Information Server (IIS).  Therefore, you do not have to create this object yourself.  Rather, use it for an ASP Component application via the IScriptingContext:Server property.
      </remarks>
    </member>
    <member name="M:VO.IServer._HTMLEncode">
      <summary>
        Apply HTML encoding to a specified string.
      </summary>
      <param name="cHTML">The HTML string to be encoded.</param>
      <returns>
        An encoded HTML text as STRING, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        This method applies HTML encoding to the specified string, &lt;cHTML&gt;.
      </remarks>
      <example>
        The following call to method _HTMLEncode()
        <code language="X#">
          CLASS ASPComponent INHERIT IScriptingContext
          METHOD	HTTPResponse 	CLASS ASPComponent
             LOCAL cEncode	AS STRING
             ...
          cEncode := SELF:Server:_HTMLEncode("&lt;/html&gt;")
           	...
        </code>
        produces the output (cEncode):
        <code language="X#">&amp;lt;/html&amp;gt;</code></example>
    </member>
    <member name="M:VO.IServer._MapPath">
      <summary>
        Map the specified relative or virtual path to the corresponding physical directory on the server.
      </summary>
      <param name="cPath">The alias name of the path.</param>
      <returns>
        The full specified path including drive letter, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        The _MapPath() method maps the specified relative or virtual path, &lt;cPath&gt;, to the corresponding physical directory on the server.  If &lt;cPath&gt; starts with either a forward (/) or backward (\) slash, this method returns a path as if &lt;cPath&gt; is a full virtual path.  If &lt;cPath&gt; does not start with a slash, _MapPath() returns a path relative to the directory of the .ASP file being processed.
      </remarks>
      <example>
        The following call to method _MapPath(),
        <code language="X#">
          CLASS ASPComponent INHERIT IScriptingContext
          METHOD	HTTPResponse 	CLASS ASPComponent
             LOCAL cPath	AS STRING
             ...
          cPath := SELF:Server:_MapPath("/cgi-bin")
           	...
        </code>
        produces the output (cPath):
        <code language="X#">c:\inetsrv\scripts</code>
        However, the call to
        <code language="X#">cPath := SELF:Server:_MapPath("test")</code>
        produces the output (cPath):
        <code language="X#">c:\inetsrv\wwwroot\vosample\test</code></example>
    </member>
    <member name="M:VO.IServer._URLEncode">
      <summary>
        Apply URL encoding to a specified string.
      </summary>
      <param name="cURL">The URL string to be encoded.</param>
      <returns>
        The encoded URL text as STRING, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        This method applies URL encoding to the specified string, &lt;cURL&gt;.
      </remarks>
      <example>
        The following call to method _URLEncode(),
        <code language="X#">
          CLASS ASPComponent INHERIT IScriptingContext
          METHOD	HTTPResponse 	CLASS ASPComponent
             LOCAL cEncode	AS STRING
             ...
          cEncode := SELF:Server:_URLEncode( ;
          "X#")
           	...
        </code>
        produces the output (cEncode):
        <code language="X#">Visual+Objects</code></example>
    </member>
    <member name="M:VO.IServer.GetScriptTimeOut">
      <summary>
        Retrieve the script time-out value of an IServer object.
      </summary>
      <returns>
        Timeout value in minutes (type LONG), if successful; otherwise, 0.
      </returns>
      <remarks>
        This method retrieves the script time-out value of the IServer object in seconds.
      </remarks>
    </member>
    <member name="M:VO.IServer.PutScriptTimeOut">
      <summary>
        Set the script time-out value of an IServer object.
      </summary>
      <param name="nValue">New time-out value in seconds.</param>
      <returns>
        TRUE, if the value has been changed; otherwise, FALSE.
      </returns>
      <remarks>
        This method sets the script time-out value of the IServer object in seconds.
        <note type="tip">This property cannot be set to a value less than that specified in the registry settings.  For example, if it is set to 60 and the registry setting contains the default value of 120 seconds, scripts will time out after 120 seconds.  However, if &lt;nValue&gt; were set to 200, the scripts would time out after 200 seconds.</note></remarks>
    </member>
    <member name="T:VO.ISessionObject">
      <summary>
        Store information needed for a particular user session.
      </summary>
      <remarks>
        An ISessionObject object instance can be used to store information needed for a particular user session.  Variables stored in the ISessionObject instance persist for the entire user session.  They will not be discarded when the user switches between pages in the application.
      </remarks>
    </member>
    <member name="M:VO.ISessionObject.#ctor">
      <summary>
        Construct an ISessionObject object instance.
      </summary>
      <param name="oIScrContext">An IScriptingContext object.</param>
      <param name="pISessObj">Pointer to an ISession Interface object structure.</param>
      <remarks>
        An ISessionObject object instance is automatically created by the IScriptingContext:OnStartPage() method when the appropriate .ASP file is loaded by the Internet Information Server (IIS).  Therefore, you do not have to create this object yourself.  Rather, use it for an ASP Component application via the IScriptingContext:Session property.
      </remarks>
    </member>
    <member name="M:VO.ISessionObject.Abandon">
      <summary>
        Destroy all of the objects stored in the current session and release their resources.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method destroys all of the objects stored in the current session and releases their resources.
      </remarks>
    </member>
    <member name="M:VO.ISessionObject.GetSessionID">
      <summary>
        Retrieve the session's ID value.
      </summary>
      <returns>
        Value of type STRING, if successful; otherwise, NULL_STRING.
      </returns>
      <remarks>
        The GetSessionID() method retrieves the value of a session's ID as STRING.
      </remarks>
    </member>
    <member name="M:VO.ISessionObject.GetTimeout">
      <summary>
        Retrieve the time-out value of a user session.
      </summary>
      <returns>
        Timeout value in minutes (type LONG), if successful; otherwise, 0.
      </returns>
      <remarks>
        The GetTimeout() method retrieves the time-out value of the ISessionObject object instance.
      </remarks>
    </member>
    <member name="M:VO.ISessionObject.GetValue">
      <summary>
        Retrieve the value of a variable stored in an ISessionObject object instance.
      </summary>
      <param name="cVarName">Name of the desired variable.</param>
      <returns>
        Value of type USUAL, if successful; otherwise, NIL.
      </returns>
      <remarks>
        This method retrieves the value of a variable stored in the ISessionObject object instance.
      </remarks>
      <example>
        The following source code can be used to display the session value, "SessionVar":
        <code language="X#">
          GLOBAL goASPComponent  AS ASPComponent
          PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}
          CLASS ASPComponent INHERIT IScriptingContext
        </code><code language="X#">
          METHOD	HTTPResponse 	CLASS ASPComponent
          LOCAL cRet  AS STRING
          cRet := SELF:Session:GetValue("SessionVar")
          RETURN SELF:Response:_Write(cRet)
        </code>
        ASP code:
        <code language="X#">
          &lt;%
          Set oComp = Server.CreateObject("VoAsp.Component")
          Session("SessionVar") = 111
          oComp.HTTPResponse()
          %&gt;
        </code></example>
    </member>
    <member name="M:VO.ISessionObject.PutTimeout">
      <summary>
        Set the time-out value of a user session.
      </summary>
      <param name="nValue">New time-out value expressed in minutes.</param>
      <returns>
        TRUE, if the value has been changed; otherwise, FALSE.
      </returns>
      <remarks>
        This method sets the time-out value of the ISessionObject object instance.
      </remarks>
    </member>
    <member name="M:VO.ISessionObject.PutValue">
      <summary>
        Store the value of a variable into an ISessionObject instance.
      </summary>
      <param name="cVarName">Name of the desired variable.</param>
      <param name="xValue">New value.</param>
      <returns>
        TRUE, if the value has been changed; otherwise, FALSE.
      </returns>
      <remarks>
        This method assigns the value of a variable stored in the ISessionObject object instance.
      </remarks>
    </member>
    <member name="T:VO.IUnknown">
      <summary>
        Provide a helper class for the internal implementation of OLE automation.
      </summary>
      <remarks>
        <br />Important!  This class is used for internal implementation only and is not intended to be used directly.
      </remarks>
    </member>
    <member name="M:VO.IUnknown.#ctor">
      <summary>
        Provide a helper method for the internal implementation of OLE automation.
        <br />Important!  This method is used for internal implementation only and is not intended to be used directly.
      </summary>
    </member>
    <member name="M:VO.IUnknown.AddRef">
      <summary>
        Provide a helper method for the internal implementation of OLE automation.
        <br />Important!  This method is used for internal implementation only and is not intended to be used directly.
      </summary>
    </member>
    <member name="M:VO.IUnknown.Destroy">
      <summary>
        Provide a helper method for the internal implementation of OLE automation.
        <br />Important!  This method is used for internal implementation only and is not intended to be used directly.
      </summary>
    </member>
    <member name="M:VO.IUnknown.Release">
      <summary>
        Provide a helper method for the internal implementation of OLE automation.
        <br />Important!  This method is used for internal implementation only and is not intended to be used directly.
      </summary>
    </member>
    <member name="T:VO.IWriteCookie">
      <summary>
        Provide a class for altering values and attributes of the cookies stored in the write-only cookie collection of an HTTP response.
      </summary>
      <remarks>
        The IWriteCookie class enables you to alter values and attributes of the cookies stored in the write-only cookie collection of an HTTP response.
      </remarks>
    </member>
    <member name="M:VO.IWriteCookie.#ctor">
      <summary>
        Construct an IWriteCookie object instance.
      </summary>
      <param name="pICookie">Pointer to an IWriteCookie Interface object structure.</param>
      <param name="oIServer">An IServer object instance.</param>
      <remarks>
        An IWriteCookie object instance can be created by the IResponse:GetCookies() method because it is directly associated with an HTTP request.  Therefore, you do not have to create this object yourself.  Rather, use it for an ASP Component application via the IScriptingContext:Response:GetCookies() method.
      </remarks>
    </member>
    <member name="M:VO.IWriteCookie.PutDomain">
      <summary>
        Set the Domain attribute of a cookie object.
      </summary>
      <param name="cDomain">New domain value as STRING.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sets the new value for the Domain attribute of the IWriteCookie object.  This attribute determines whether the cookie is sent only to requests to this domain.
      </remarks>
    </member>
    <member name="M:VO.IWriteCookie.PutExpires">
      <summary>
        Set the current value of the Expires property of a cookie object.
      </summary>
      <param name="dNew">New expires value as DATE.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sets the new value for the Expires property of the IWriteCookie object.  This property specifies the date at which a cookie expires.
      </remarks>
    </member>
    <member name="M:VO.IWriteCookie.PutItem">
      <summary>
        Add a specified cookie to a write-only cookie collection.
      </summary>
      <param name="cName">Name of the item to add to the cookie as STRING.</param>
      <param name="cValue">Value of the item to add to the cookie as STRING.</param>
      <param name="aValue">Array with item values to add to the cookie.  &lt;cName&gt; is treated as the key name and the cookie as a dictionary cookie.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method adds a new item to the IWriteCookie object.  If the second argument is a STRING, then the cookie is treated as a simple cookie and &lt;cValue&gt; is the cookie's value.  Otherwise, the cookie is treated as a dictionary cookie and &lt;aValues&gt; contains the values for the cookie's key, &lt;cName&gt;.
      </remarks>
    </member>
    <member name="M:VO.IWriteCookie.PutPath">
      <summary>
        Set the Path attribute of a cookie object.
      </summary>
      <param name="cPath">New Path value as STRING.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sets the new value for the Path attribute of the IWriteCookie object.  This attribute determines whether the cookie is sent only to requests to this path.  If this attribute is not set, the application path is used.
      </remarks>
    </member>
    <member name="M:VO.IWriteCookie.PutSecure">
      <summary>
        Set the Secure attribute of a cookie object.
      </summary>
      <param name="lSecure">Logical value with new Secure attribute.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method sets the new value for the Secure attribute of the IWriteCookie object.  This attribute specifies whether the cookie is secure.
      </remarks>
    </member>
    <member name="T:VO.KeyEvent">
      <summary>
        Provide information about a KeyEvent, used to encapsulate information about the key that was pressed.
      </summary>
      <remarks>
        KeyEvent events occur when the keyboard is used and are sent to Window:KeyDown() and Window:KeyUp().
      </remarks>
      <example>
        This example moves the text cursor down one line when the user presses the Enter key.  &lt;oCursorPoint&gt; defines the current location of the text cursor.
        <code language="X#">
          METHOD KeyDown(aKeyEvt) CLASS TopAppWindow
          IF(aKeyEvt:KeyCode() = KeyEnter)
          ts := SELF:TextSize('A'):Height() + 2
          oCursorPoint := Point{10,oCursorPoint:Y() - ts}
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.KeyEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.KeyEvent.ASCIIChar">
      <summary>
        A numeric value representing the normal ASCII code for the key that caused this KeyEvent.
      </summary>
      <value>A numeric value representing the normal ASCII code for the key that caused this KeyEvent.</value>
      <remarks>
        A numeric value representing the normal ASCII code for the key that caused this KeyEvent.  (This includes all printable characters, as well as the Control key combinations from Ctrl+A to Ctrl+Z).
        This value is NIL if a non-printable and non-Control key was pressed — you should then call KeyEvent:KeyCode() to examine the key.  (Keys that generate NIL include function keys, editing keys, and the Direction keys.)
      </remarks>
    </member>
    <member name="P:VO.KeyEvent.KeyCode">
      <summary>
        A constant, indicating the code for the key that was pressed:
      </summary>
      <value>A constant, indicating the code for the key that was pressed:</value>
      <remarks>
        One of the following constants, indicating the code for the key that was pressed:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>KEYALT</term><description>Alt key</description></item><item><term>KEYARROWDOWN</term><description>Down arrow key</description></item><item><term>KEYARROWLEFT</term><description>Left arrow key</description></item><item><term>KEYARROWRIGHT</term><description>Right arrow key</description></item><item><term>KEYARROWUP</term><description>Up arrow key</description></item><item><term>KEYBACKSPACE</term><description>Backspace key</description></item><item><term>KEYCANCEL</term><description>Cancel key</description></item><item><term>KEYCAPSLOCK</term><description>Capitals Lock key</description></item><item><term>KEYCONTROL</term><description>Control key</description></item><item><term>KEYDELETE</term><description>Delete key</description></item><item><term>KEYEND</term><description>End key</description></item><item><term>KEYENTER</term><description>Enter key</description></item><item><term>KEYESCAPE</term><description>Escape key</description></item><item><term>KEYF1...KEYF16</term><description>Function keys 1-16</description></item><item><term>KEYHOME</term><description>Home key</description></item><item><term>KEYINSERT</term><description>Insert key</description></item><item><term>KEYNUMLOCK</term><description>Numeric Lock key</description></item><item><term>KEYPAGEDOWN</term><description>PgDn key</description></item><item><term>KEYPAGEUP</term><description>PgUp key</description></item><item><term>KEYPAUSE</term><description>Pause key</description></item><item><term>KEYPRINT</term><description>Print key</description></item><item><term>KEYRETURN</term><description>Return key</description></item><item><term>KEYSHIFT</term><description>Shift key</description></item><item><term>KEYSPACE</term><description>Spacebar</description></item><item><term>KEYTAB</term><description>Tab key</description></item></list><note type="tip">KeyEvent:KeyCode provides access to the underlying keyboard hardware.  Use this property if the KeyEvent:ASCIIChar access method returns NIL.</note></remarks>
    </member>
    <member name="P:VO.KeyEvent.RepeatCount">
      <summary>
        A numeric value determining whether a user depressed a key repeatedly or held it down for an extended period of time.
      </summary>
      <value>A numeric value determining whether a user depressed a key repeatedly or held it down for an extended period of time.</value>
      <remarks>
        A numeric value determining whether a user depressed a key repeatedly or held it down for an extended period of time.
        If a key is repeatedly depressed, the number of times the key is depressed is returned; otherwise, a value of 1 is returned.
        When the user holds down a key for a duration, multiple KeyEvents can be translated into a single KeyEvent with a RepeatCount greater than 1.
      </remarks>
    </member>
    <member name="P:VO.KeyEvent.System">
      <summary>
        A logical value determining whether the Alt key was pressed at the same time as another key (TRUE if yes, FALSE if no).
      </summary>
      <value>A logical value determining whether the Alt key was pressed at the same time as another key (TRUE if yes, FALSE if no).</value>
      <remarks>
        A logical value determining whether the Alt key was pressed at the same time as another key (TRUE if yes, FALSE if no).
      </remarks>
    </member>
    <member name="T:VO.LineObject">
      <summary>
        Create a LineObject object; this type of entity is part of the DrawObject hierarchy, which provides a means of displaying and manipulating various objects.
      </summary>
      <example>
        To draw a LineObject object, call Window:Draw() with the LineObject object as its argument.  The window does the drawing by asking each object to draw itself — for example:
        <code language="X#">
          METHOD Expose(oEvent) CLASS MyWindow
          LOCAL oLine AS OBJECT
          oLine := LineObject{Point{10,10},Point{20,20}}
          SELF:Draw(oLine)
        </code></example>
    </member>
    <member name="M:VO.LineObject.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a LineObject object.
      </summary>
      <param name="oPoint1">The point representing the start of the line.</param>
      <param name="oPoint2">The point representing the end of the line.</param>
      <param name="oPen">The pen to be used for drawing the LineObject object.  If omitted, the current pen is used.</param>
      <remarks>
        The pen specified by &lt;oPen&gt; should not be deleted while it is selected.
      </remarks>
    </member>
    <member name="P:VO.LineObject.BoundingBox">
      <summary>
        A bounding box representing the smallest rectangle that completely encloses this LineObject object.
      </summary>
      <value>A bounding box representing the smallest rectangle that completely encloses this LineObject object.</value>
    </member>
    <member name="M:VO.LineObject.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.LineObject.Draw">
      <summary>
        Draw the LineObject object on a window.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <remarks>
        This method should not be invoked directly in the application code — it is invoked in X# by Window:Draw().  Refer to the class description for an example using the Draw() method.
      </remarks>
    </member>
    <member name="P:VO.LineObject.Origin">
      <summary>
        A point, in canvas coordinates, representing the starting coordinate of the LineObject object on its owner window.
      </summary>
      <value>A point, in canvas coordinates, representing the starting coordinate of the LineObject object on its owner window.</value>
    </member>
    <member name="P:VO.LineObject.Pen">
      <summary>
        A pen associated with this LineObject object.
      </summary>
      <value>A pen associated with this LineObject object.</value>
      <remarks>
        A pen associated with this LineObject object.
        The most common reason to change the pen is to redraw an existing line temporarily in a different color to highlight the fact that the user has selected that line.
        In Windows, the pen specified by &lt;oPen&gt; should not be deleted while it is selected.
      </remarks>
    </member>
    <member name="P:VO.LineObject.Size">
      <summary>
        A dimension representing the size of this LineObject object.
      </summary>
      <value>A dimension representing the size of this LineObject object.</value>
    </member>
    <member name="T:VO.ListBox">
      <summary>
        Create a list box.
      </summary>
      <remarks>
        List boxes and combo boxes display a list of items or choices to the user.  The list box methods will allow you to add, arrange, remove, and interrogate the list of items.  When one of the items is selected, ListBox:CurrentItem, ListBox:CurrentItemNo, ListBox:TextValue, and ListBox:Value are updated.  Either a one-dimensional or two-dimensional array is specified in the FillUsing() method, with a row for each of the items available for selection.  With a two-dimensional array, the first element is called the display value, and the second element is called the return value.  When an item is selected, ListBox:TextValue contains the first element (the display value), and ListBox:Value contains the second element (the return value).  If no item is selected, ListBox:TextValue is NULL_STRING and ListBox:Value is NIL.
        A list box may be bound to a field (character, date, logical, numeric, or memo) in a server.  The field's data value is stored in ListBox:Value.  The list box compares the data value to the second element values specified in the FillUsing() array, and if a match is found, the first element (the display value) is stored in ListBox:TextValue.  In a "no-match" situation, the list box shows no item selected, ListBox:CurrentItem is NULL_STRING, ListBox:CurrentItemNo is set to 0, and ListBox:TextValue and ListBox:Value reflect the field contents.  If an item is selected, ListBox:CurrentItemNo is set to a number between 1 and ListBox:ItemCount, and the corresponding second element is stored as ListBox:Value and as the field's data value.
        <note type="tip">All array index references start at 1.</note>
        You can also create a multiple selection list box, which allows you to manage multiple items within a list box.  Any number of items in a list box can be selected together (referred to as multiple selection).  Each item is toggled on/off each time the user clicks on it.
        A multiple selection list box is created by selecting the LBOXMULTIPLESEL style when creating a ListBox object.  Certain properties and methods of this class apply specifically to multiple selection list boxes, including SelectedCount access, ChangeSelected(), ClearSelection(), DeselectItem(), FirstSelected(), NextSelected(), and SelectItem().
      </remarks>
      <example>
        This example creates and fills a list box with a list of animals:
        <code language="X#">
          CLASS MyWindow INHERIT TopAppWindow
          HIDDEN oLB AS OBJECT
          METHOD Init() CLASS MyWindow
          SUPER:Init()
          oLB := ListBox{SELF,42,Point{10,10},;
          Dimension{100,40}}
          oLB:AddItem("Pig")
          oLB:AddItem("Cow")
          oLB:AddItem("Horse")
          oLB:Show()
        </code>

        A X# list box is equivalent to a Windows list box with the LBS_NOTIFY and LBS_SORT styles.
        List boxes are normally specified in the resource entity like this:
        <code language="X#">
          RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 80
          STYLE WS_POPUP | WS_DLGFRAME
          BEGIN
          LISTBOX  IDL_ITEMLIST, 10, 10, 90, 40
          END
        </code></example>
    </member>
    <member name="M:VO.ListBox.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a list box.
      </summary>
      <param name="oOwner">The window that owns the list box.</param>
      <param name="xID">The unique ID of the list box (between 1 and 8000).</param>
      <param name="oPoint">The origin of the list box in canvas coordinates.</param>
      <param name="oDimension">The dimension of the list box in canvas coordinates.</param>
      <param name="kStyle">The style of the list box, specified as one of the following constants listed below:</param>
      <param name="nResourceID">The resource ID of the list box.</param>
      <remarks>
        <pre>
          Constant	            	Windows API Constant
          LBOXDISABLENOSCROLL	  	LBS_DISABLENOSCROLL
          LBOXEXTENDEDSEL	      	LBS_EXTENDEDSEL
          LBOXHASSTRINGS	      	LBS_HASSTRINGS
          LBOXMULTICOLUMN	      	LBS_MULTICOLUMN
          LBOXMULTIPLESEL	      	LBS_MULTIPLESEL
          LBOXNOINTEGRALHEIGHT		LBS_NOINTEGRALHEIGHT
          LBOXNOREDRAW	        	LBS_NOREDRAW
          LBOXNOTIFY	          	LBS_NOTIFY
          LBOXOWNERDRAWFIXED	  	LBS_OWNERDRAWFIXED
          LBOXOWNERDRAWVARIABLE		LBS_OWNERDRAWVARIABLE
          LBOXSORT	            	LBS_SORT
          LBOXSTANDARD	        	LBS_STANDARD
          LBOXUSETABSTOPS	      	LBS_USETABSTOPS
          LBOXWANTKEYBOARDINPUT		LBS_WANTKEYBOARDINPUT
        </pre>
      </remarks>
    </member>
    <member name="M:VO.ListBox.AddItem(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Add a new item to a list box at a specified position.
      </summary>
      <param name="cItem">The item to be inserted.</param>
      <param name="nItemNumber">The position in the list box at which to insert the new item.  Specify one of the values listed below.</param>
      <param name="uRetValue">The value associated with the specified item.  The default is &lt;cItem&gt;.</param>
      <returns>
        If the item was added, its position in the list box is returned (a value of 1 refers to the first position in the list box).  If the item could not be added, 0 is returned.
      </returns>
      <remarks>
        Value	Position
        0	In an unsorted list box, adds the new item at the end of the list; if sorted, inserts the new item at a position determined by the list box.  This is the default.
        1	The first position in the list box.
        n	The nth position in the list box.
      </remarks>
    </member>
    <member name="P:VO.ListBox.Caption">
      <summary>
        The string representing the caption of the list box.
      </summary>
      <value>The string representing the caption of the list box.</value>
    </member>
    <member name="M:VO.ListBox.ChangeSelected(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Change a range of items in a multiple selection list box to a specified selection.
      </summary>
      <param name="oRange">The Range object representing the selected items.</param>
      <param name="lEnabled">The state of the selected items.  If not specified, the default is TRUE.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method is intended for use with a multiple selection list box (i.e., a list box created using the LBOXMULTIPLESEL style).
      </remarks>
    </member>
    <member name="M:VO.ListBox.ClearSelection">
      <summary>
        Clear a multiple selection list box of all selections.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method is intended for use with a multiple selection list box (i.e., a list box created using the LBOXMULTIPLESEL style).
      </remarks>
    </member>
    <member name="M:VO.ListBox.Create">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.ListBox.CurrentItem">
      <summary>
        A string representing the displayed list box or combo box item selected.
      </summary>
      <value>A string representing the displayed list box or combo box item selected.</value>
      <remarks>
        A string representing the displayed list box or combo box item selected.  The ListBox:CurrentItem access also changes ListBox:CurrentItemNo, ListBox:CurrentText, ListBox:TextValue, and ListBox:Value, if there is a match with the available display items.
      </remarks>
    </member>
    <member name="P:VO.ListBox.CurrentItemNo">
      <summary>
        A numeric value, between 1 and the ListBox:ItemCount, indicating which item is currently selected.
      </summary>
      <value>A numeric value, between 1 and the ListBox:ItemCount, indicating which item is currently selected.</value>
      <remarks>
        A numeric value, between 1 and the ListBox:ItemCount, indicating which item is currently selected.  If no item is selected, it is 0.The ListBox:CurrentItemNo assign also changes ListBox:CurrentItem, ListBox:TextValue, and ListBox:Value.
        If the assigned ListBox:CurrentItemNo is zero (0), or if it exceeds the ListBox:ItemCount, then no item will be selected.  If the ListBox:CurrentItemNo assign represents a change, then ListBox:ValueChanged will be set to TRUE.
      </remarks>
    </member>
    <member name="P:VO.ListBox.CurrentText">
      <summary>
        ListBox:CurrentText is set to the NULL_STRING, since there is no text editing for list boxes.
      </summary>
      <value>ListBox:CurrentText is set to the NULL_STRING, since there is no text editing for list boxes.</value>
    </member>
    <member name="M:VO.ListBox.DeleteItem(XSharp.__Usual)">
      <summary>
        Remove an item from a list box.
      </summary>
      <param name="uItemNumber">The number of the item to be deleted.  Specify one of values listed below</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Value	Position
        0	The currently selected item.  This is the default.
        1	The first item.
        n	The nth item.
      </remarks>
    </member>
    <member name="M:VO.ListBox.DeselectItem(XSharp.__Usual)">
      <summary>
        Turn off the selection of a specified item in a list box.
      </summary>
      <param name="nItemId">The item number to be deselected.  Zero (0) represents the current item.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Normally, the user turns selections off, but this method enables the program to do so also.
        This method is intended for use with a multiple selection list box (i.e., a list box created using the LBOXMULTIPLESEL style).
      </remarks>
    </member>
    <member name="M:VO.ListBox.Destroy">
      <summary>
        Provide a method to de-instantiate a ListBox object.
      </summary>
      <remarks>
        This method can be used when a ListBox object is no longer needed.  ListBox:Destroy() de-instantiates the ListBox object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.ListBox.EnableItemDrag">
      <summary>
        Turn the list box into a drag list box.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ListBox.FillUsing(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Specify the set of values to be displayed in the list box, using an array or a data server.  These values act as a constraint on the values that may be entered in the list box, and optionally as a translation between program values and display values.
      </summary>
      <param name="aContents">
        An array containing the values to be placed in the list box.  A two-dimensional array may be used to define the values to be returned to the program when a list item is selected, separately from the text strings shown in the list; this 'other' value is what is returned in the ListBox:Value property, and what is stored in the database if the control is associated with a database field.
        Thus, the array may be specified in one of two formats:
      <pre>
      1. One-dimensional array containing the list of values. 
      2.  Array of two-element arrays, each containing the string to display in the list and the corresponding value returned to the program.
        Note that the two dimensional array has the same structure as that returned by DBServer:GetLookupTable(), and the 
        one-dimensional array matches that returned by DBServer:GetArray(). or The data server that is to be used to provide the set of values.
        </pre></param>
      <param name="symField1">The symbolic name of the field that is to be used for the display values.  If not specified, the values of the first field are used.</param>
      <param name="symField2">The symbolic name of the field that is to be used for the values that are returned to the program.  If not specified, the values of the first field are used.</param>
      <remarks>
        A list box shows the set of valid values for a field.  Depending on what type of list box is used, the set of values may act as a constraint on the values that may be retrieved or only as a suggestion.  Two sets of values may be specified, allowing for translation of values between the displayed, "human-readable" representation and the internal, programmatic value.
        The FillUsing() method provides a way of specifying the values to be included in the list all at once, instead of constructing the list item by item with the AddItem() method.
        <note type="tip">The list box control may be associated with a database field, just like any other control.  Do not confuse this primary field linkage with the possibility of linking the list box to a secondary server used for populating the list.</note></remarks>
      <example>
        Create a list box with different currencies, showing an explicit representation to the user but using a different representation internally:
        <code language="X#">
          METHOD Init(...) CLASS OrderWindow
          ...
          oLBCurrency := ListBox{SELF,LBCURRENCY_ID}
          oLBCurrency:FillUsing({;
          {"U.S. Dollars","USD"},;
          {"Can. Dollars","CDN"},;
          {"Mexican Pesos","MEX"},;
          {"Yen","YEN"},;
          {"British Pounds","UK"},;
          {"German Marks","DM"};
          })
          oLBCurrency:Show()
        </code>
        Create a list box that shows the products available in the product table:
        <code language="X#">
          METHOD Init(...) CLASS OrderWindow
          ...
          oLBProducts := ListBox{SELF,LBPRODUCTS_ID}
          oLBProducts:FillUsing(oDBProducts,#ProdName,#ProdNo)
          oLBProducts:Show()
        </code></example>
    </member>
    <member name="M:VO.ListBox.FirstSelected">
      <summary>
        Returns the position of the first item selected in a multiple selection list box, or 0 if no item is selected.
      </summary>
      <remarks>
        ListBox:FirstSelected() positions an imaginary cursor on the first item of the selection.
        This method is intended for use with a multiple selection list box (i.e., a list box created using the LBOXMULTIPLESEL style).
      </remarks>
    </member>
    <member name="M:VO.ListBox.GetItemValue(XSharp.__Usual)">
      <summary>
        Retrieve the value of a specified list box item.
      </summary>
      <param name="nItemNumber">The number of the desired item.  Specify one of the values listed below:</param>
      <returns>
        The value associated with the specified item.
      </returns>
      <remarks>
        Value	Position
        0	The currently selected item.
        1	The first item.
        n	The nth item.
      </remarks>
      <example>
        <code language="X#">
          METHOD ListBoxClick(oControlEvent) CLASS EmailWindow
          LOCAL oControl := oControlEvent:Control AS Control
          SUPER:ListBoxClick(oControlEvent)
          IF IsInstanceOf(oControl, #ListBox)
          SELF:DialClient(oControl:GetItemValue(0))
          ENDIF
          RETURN NIL
        </code>
      </example>
    </member>
    <member name="M:VO.ListBox.IsSelected(XSharp.__Usual)">
      <summary>
        Determine if the list box item at the specified index position is selected.
      </summary>
      <param name="iIdx">Index position of the list box item.</param>
      <returns>
        TRUE if selected; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.ListBox.ItemCount">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.ListBox.ListFiles(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Fill a list box with the names of all files that match the specified path or file name.
      </summary>
      <param name="sStartDir">The path or file name of the starting directory.</param>
      <param name="oFixedText">Set automatically to the fixed text of the drive/directory of &lt;sStartDir&gt;.</param>
      <param name="FileTypes">One of the following constants indicating the attributes of the files to be displayed:</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <list type="table">
          <listheader>
            <term>Windows API Constant </term>
            <description>Description</description>
          </listheader>
          <item>
            <term>DDL_ARCHIVE</term>
            <description>Includes archived files.</description>
          </item>
          <item>
            <term>DDL_DIRECTORY</term>
            <description>Includes subdirectories, enclosed in square brackets ([ ]).</description>
          </item>
          <item>
            <term>DDL_DRIVES</term>
            <description>Includes drives, listed in the form [-x-] where x is the drive letter.</description>
          </item>
          <item>
            <term>DDL_EXCLUSIVE</term>
            <description>Includes only files with the specified attributes.  </description>
          </item>
          <item>
            <term></term>
            <description>
              <note type="tip">Read-write files are included by default even if DDL_READWRITE is not specified.</note>
            </description>
          </item>
          <item>
            <term>DDL_HIDDEN</term>
            <description>Includes hidden files.</description>
          </item>
          <item>
            <term>DDL_READONLY</term>
            <description>Includes read-only files.</description>
          </item>
          <item>
            <term>DDL_READWRITE</term>
            <description>Includes read-write files with no additional attributes specified.</description>
          </item>
          <item>
            <term>DDL_SYSTEM</term>
            <description>Includes system files.</description>
          </item>
          <item>
            <term>DDL_POSTMSGS</term>
            <description>Posts messages to the application's message queue. </description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:VO.ListBox.Modified">
      <summary>
        A logical value that is set to FALSE for a list box, since it does not contain text that can be edited.
      </summary>
      <value>A logical value that is set to FALSE for a list box, since it does not contain text that can be edited.</value>
    </member>
    <member name="P:VO.ListBox.MultiSelection">
      <summary>
        Used to identify if the ListBox supports multiple selections.
      </summary>
      <value>Used to identify if the ListBox supports multiple selections.</value>
    </member>
    <member name="M:VO.ListBox.NextSelected">
      <summary>
        After calling ListBox:FirstSelected(), this method is used to cycle through the remaining items selected in a multiple selection list box.
      </summary>
      <returns>
        Position of the next selected item in the list box, or 0 if no item is selected or if  there are no remaining items.
      </returns>
      <remarks>
        This method is intended for use with a multiple selection list box (i.e., a list box created using the LBOXMULTIPLESEL style).
      </remarks>
    </member>
    <member name="P:VO.ListBox.SelectedCount">
      <summary>
        A numeric value representing the total number of items that are currently selected in a multiple selection list box.
        <note type="tip">This property is intended for use with a multiple selection list box (i.e., a list box created using the LBOXMULTIPLESEL style).</note></summary>
      <value>
        A numeric value representing the total number of items that are currently selected in a multiple selection list box.
        This property is intended for use with a multiple selection list box (i.e., a list box created using the LBOXMULTIPLESEL style).
      </value>
    </member>
    <member name="P:VO.ListBox.SelectedFiles">
      <summary>
        The string representing the selected file in a list box previously filled by the ListFiles() method.
      </summary>
      <value>The string representing the selected file in a list box previously filled by the ListFiles() method.</value>
    </member>
    <member name="M:VO.ListBox.SelectItem(XSharp.__Usual)">
      <summary>
        Turn on the selection of an item in a list box.
      </summary>
      <param name="nItemId">The item number to be selected.  Zero (0) represents the current item.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Normally, the user turns selections on and off, but this method enables the program to do so also.
        This method is intended for use with a multiple selection list box (i.e., a list box created using the LBOXMULTIPLESEL style).
      </remarks>
    </member>
    <member name="M:VO.ListBox.SetTabs(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="aTabs">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.ListBox.TextValue">
      <summary>
        A string representing the display value (first array's element) for the currently selected item.
      </summary>
      <value>A string representing the display value (first array's element) for the currently selected item.</value>
      <remarks>
        A string representing the display value (first array's element) for the currently selected item, formatted according to the picture clause of the field specification attached to the list box (or combo box).  For example the ListBox:TextValue can be "Jones", "01/15/95", or "8".  The ListBox:TextValue assign also changes ListBox:CurrentItem, ListBox:CurrentItemNo, ListBox:Modified, ListBox:Value, and ListBox:ValueChanged.
        If the assign does not match one of the display items, then ListBox:TextValue and ListBox:Value are set to the text that could not be matched, and ListBox:CurrentItemNo is set to 0.  If the control is bound to a field in a server and the field data value does not match one of the array's second elements, ListBox:TextValue and ListBox:Value contain the field's data value.
      </remarks>
    </member>
    <member name="P:VO.ListBox.Value">
      <summary>
        A value (second element in the FillUsing() array) representing the currently selected item, formatted according to the picture clause of the field specification attached to the list box (or combo box).  For example the TextValue can be "Jones", "01/15/95", or "8".  If there is no selected item and the list box is not bound to a field in a server, the ListBox:Value is set to NIL.  The ListBox:Value assign also changes ListBox:CurrentItem, ListBox:CurrentItemNo, ListBox:TextValue, and ListBox:ValueChanged.
        If the assigned text does not match one of the return value choices, ListBox:CurrentItemNo is set to 0, and ListBox:TextValue and ListBox:Value are set to the assigned text.  In a list box, the ListBox:Value is generally one of the return values, unless the control is bound to a field where the actual contents is not one of the allowable choices, and there is a no-match situation; in this case ListBox:TextValue and ListBox:Value contain the field's data value.
        The data type for ListBox:Value is determined by the field specification of the list box; in turn, controls linked to a data server inherit the field specification — and hence data type — from the field of the server.  When the control is made data-aware, by setting its name to the name of a field in the server attached to the data window, ListBox:Value is able to automatically read from and write to this field.
        <note type="tip">ListBox:Value may not always be consistent with what the state of the control, as indicated to the end user.  For example, if the data value for the field is not one of the allowed choices for a list box return value, the control will be in a "no-match" situation.  In this case the list box will revert to its initial unselected state with ListBox:CurrentItemNo set to 0.</note></summary>
      <value>
        A value (second element in the FillUsing() array) representing the currently selected item, formatted according to the picture clause of the field specification attached to the list box (or combo box).  For example the TextValue can be "Jones", "01/15/95", or "8".  If there is no selected item and the list box is not bound to a field in a server, the ListBox:Value is set to NIL.  The ListBox:Value assign also changes ListBox:CurrentItem, ListBox:CurrentItemNo, ListBox:TextValue, and ListBox:ValueChanged.
        If the assigned text does not match one of the return value choices, ListBox:CurrentItemNo is set to 0, and ListBox:TextValue and ListBox:Value are set to the assigned text.  In a list box, the ListBox:Value is generally one of the return values, unless the control is bound to a field where the actual contents is not one of the allowable choices, and there is a no-match situation; in this case ListBox:TextValue and ListBox:Value contain the field's data value.
        The data type for ListBox:Value is determined by the field specification of the list box; in turn, controls linked to a data server inherit the field specification — and hence data type — from the field of the server.  When the control is made data-aware, by setting its name to the name of a field in the server attached to the data window, ListBox:Value is able to automatically read from and write to this field.
        ListBox:Value may not always be consistent with what the state of the control, as indicated to the end user.  For example, if the data value for the field is not one of the allowed choices for a list box return value, the control will be in a "no-match" situation.  In this case the list box will revert to its initial unselected state with ListBox:CurrentItemNo set to 0.
      </value>
    </member>
    <member name="P:VO.ListBox.ValueChanged">
      <summary>
        A logical value representing whether the list box Value has been changed from the previously selected item during the selection process.  TRUE indicates that it has been changed from the prior choice, while FALSE indicates it has been not changed from the prior choice.  The list box Value may be changed by clicking on a different item, or via the ListBox:TextValue or ListBox:Value assigns.
      </summary>
      <value>A logical value representing whether the list box Value has been changed from the previously selected item during the selection process.  TRUE indicates that it has been changed from the prior choice, while FALSE indicates it has been not changed from the prior choice.  The list box Value may be changed by clicking on a different item, or via the ListBox:TextValue or ListBox:Value assigns.</value>
    </member>
    <member name="T:VO.ListView">
      <summary>
        Create a list view control.
        Important - Microsoft Note - Under visual styles GridLines are not always displayed correctly.
      </summary>
      <remarks>
        A list view is a control that displays a collection of list view items, each item consisting of images and a text label.  List views provide several ways of arranging items and displaying individual items.
      </remarks>
    </member>
    <member name="M:VO.ListView.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a list view.
      </summary>
      <param name="oOwner">The window that owns the list view.</param>
      <param name="xID">The unique ID for the list view (between 1 and 8000).</param>
      <param name="oPoint">The origin of the list view in canvas coordinates.</param>
      <param name="oDimension">The dimension of the list view in canvas coordinates.</param>
      <param name="kStyle">The style of the list view.</param>
      <param name="nResourceID">The resource ID of the list view.</param>
    </member>
    <member name="M:VO.ListView.AddColumn(XSharp.__Usual)">
      <summary>
        Add a new ListViewColumn object to the end of the list view's list of columns.
      </summary>
      <param name="oListViewColumn">The ListViewColumn object to add to the list view.</param>
      <returns>
        TRUE if the column was added successfully; otherwise, FALSE.
      </returns>
      <example>
        <code language="X#">SELF:oDClvPlayers:AddColumn( ListViewColumn{15, HyperLabel{ String2Symbol( "cName" ), "Recipient"}})</code>
      </example>
    </member>
    <member name="M:VO.ListView.AddGroup(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set an image as the background to the list view.
      </summary>
      <param name="iGroupId">The number of the group.</param>
      <param name="cGroupName">group name</param>
      <param name="dwAlign">
        The group alignment. Available options are -
        <pre>
          LVGA_HEADER_LEFT
          LVGA_HEADER_RIGHT
          LVGA_HEADER_CENTER
        </pre></param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">
          Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
          If group view is enabled only items belonging to groups are displayed.
        </note>
      </remarks>
    </member>
    <member name="M:VO.ListView.AddItem(XSharp.__Usual)">
      <summary>
        Add a new ListViewItem object as the last item in the list view.
      </summary>
      <param name="oListViewItem">The ListViewItem object to add to the list view.</param>
      <returns>
        TRUE if the item was added successfully; otherwise, FALSE.
      </returns>
      <example>
        The example below shows how to populate a ListView control.  Note that it is also storing the record number with each item also for later retrieval when any given item is selected:
        <code language="X#">
          LOCAL cCoachName	 AS string
          LOCAL oItem 		AS ListViewItem
          DO WHILE !SELF:oCoachesServer:eof
          cCoachName	:= 	Trim( SELF:oCoachesServer:FIELDGET( #LastName ) ) ;
          + ", " + ;
          Trim( SELF:oCoachesServer:FIELDGET( #FirstName ) ) + " " + ;
          SELF:oCoachesServer:FIELDGET( #MiddleInit )
          oItem:SetText( SELF:oCoachesServer:FIELDGET( #Season ), #cSeason )
          oItem:SetValue( SELF:oCoachesServer:RecNo, #cCoachName )
          oItem:SetText( CoachName, #cCoachName )
          oItem:SetText( SELF:oCoachesServer:FIELDGET( #Gender ), #cGender )
          oItem:SetText( SELF:oCoachesServer:FIELDGET( #ClubCode ), #cClubCode )
          oItem:SetText( SELF:oCoachesServer:FIELDGET( #TeamNr ), #cTeamNr )
          oItem:SetText( SELF:oCoachesServer:FIELDGET( #HomePhone ),	#cHomePhone )
          oItem:SetText( SELF:oCoachesServer:FIELDGET( #WorkPhone ),	#cWorkPhone )
        </code><code language="X#">
          SELF:oDClvCoaches:AddItem( oItem )
          SELF:oCoachesServer:skip()
          ENDDO
        </code></example>
    </member>
    <member name="M:VO.ListView.Arrange(XSharp.__Usual)">
      <summary>
        Align list view items while in icon view.
      </summary>
      <param name="kAlignment">One of the following constants describing how to align the list view items:</param>
      <returns>
        TRUE if the item was arranged successfully; otherwise, FALSE.
      </returns>
      <remarks>
        <pre>
          Constant			Description
          LVA_ALIGNLEFT		Aligns items along the left edge of the window.
          LVA_ALIGNTOP		Aligns items along the top edge of the window.
          LVA_DEFAULT		Aligns items according to the list view's current alignment styles (the default setting).
          LVA_SNAPTOGRID	Items are snapped to the nearest grid position.
        </pre>
      </remarks>
    </member>
    <member name="P:VO.ListView.BackgroundColor">
      <summary>
        A Color object used to paint the background in the list view.
      </summary>
      <value>A Color object used to paint the background in the list view.</value>
    </member>
    <member name="P:VO.ListView.CheckBoxes">
      <summary>
        A logical value determining whether check boxes are used in the list view.
      </summary>
      <value>A logical value determining whether check boxes are used in the list view.</value>
    </member>
    <member name="P:VO.ListView.ColumnCount">
      <summary>
        A numeric value representing the number of columns in the list view.
      </summary>
      <value>A numeric value representing the number of columns in the list view.</value>
    </member>
    <member name="P:VO.ListView.ColumnOrderArray">
      <summary>
        An array of ListViewColumn object symbolic names representing the order of the columns in the list view.
      </summary>
      <value>An array of ListViewColumn object symbolic names representing the order of the columns in the list view.</value>
    </member>
    <member name="P:VO.ListView.CurrentView">
      <summary>
        A symbolic name representing the current view of the list view.
      </summary>
      <value>A symbolic name representing the current view of the list view.</value>
      <remarks>
        A symbolic name representing the current view of the list view.  The following are valid views:
        <list type="bullet"><item>#IconView</item><item>#SmallIconView</item><item>#ListView</item><item>#ReportView</item></list></remarks>
    </member>
    <member name="M:VO.ListView.DeleteAll">
      <summary>
        Delete all items of the list view.
      </summary>
      <returns>
        TRUE if all items were deleted successfully; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ListView.DeleteAll Method (COPY)">
      <summary>
        Delete all items of the list view.
      </summary>
      <returns>
        TRUE if all items were deleted successfully; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ListView.DeleteAllColumns">
      <summary>
        Delete all columns from a list view.
      </summary>
      <returns>
        TRUE if all items were deleted successfully; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ListView.DeleteColumn(XSharp.__Usual)">
      <summary>
        Delete a ListViewColumn object from the list view.
      </summary>
      <param name="oListViewColumn">The ListViewColumn object to delete from the list view.</param>
      <returns>
        TRUE if the column was deleted successfully; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ListView.DeleteItem(XSharp.__Usual)">
      <summary>
        Delete a ListViewItem object from the list view.
      </summary>
      <param name="nItem">The index of the ListViewItem object to delete from the list view.</param>
      <returns>
        TRUE if the item was deleted successfully; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ListView.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.ListView.DragDropEnabled">
      <summary>
        A logical value that is TRUE if drag and drop is enabled for the list view.  If drag and drop is enabled, items can be dragged within, as well as outside, the control.
      </summary>
      <value>A logical value that is TRUE if drag and drop is enabled for the list view.  If drag and drop is enabled, items can be dragged within, as well as outside, the control.</value>
    </member>
    <member name="P:VO.ListView.DragImageList">
      <summary>
        An image list containing a single image displayed during a drag and drop operation for the list view.
      </summary>
      <value>An image list containing a single image displayed during a drag and drop operation for the list view.</value>
    </member>
    <member name="M:VO.ListView.EditItemLabel(XSharp.__Usual)">
      <summary>
        Begins in-place label editing of an item in the list view.
      </summary>
      <param name="nItem">The index of the ListViewItem object whose label you want to edit.</param>
    </member>
    <member name="M:VO.ListView.EnableDragDrop(XSharp.__Usual)">
      <summary>
        Enable or disable drag and drop of items for the list view.
      </summary>
      <param name="lEnable">A value of TRUE indicates that drag and drop is enabled, while FALSE indicates that it is disabled.  The default value is TRUE.</param>
      <returns>
        TRUE if drag and drop could be enabled or disabled; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ListView.EnableGroupView(XSharp.__Usual)">
      <summary>
        Set Group View on or off in a ListView control.
      </summary>
      <param name="lSetting">A logical value. TRUE turns Group View on, FALSE turns it off. The default is TRUE.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">
          Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
          If group view is enabled only items belonging to groups are displayed.
        </note>
      </remarks>
    </member>
    <member name="M:VO.ListView.EnableSort(XSharp.__Usual)">
      <summary>
        Register a user-defined method to use for sorting items in the list view.
      </summary>
      <param name="symMethodName">The symbolic name of the user-defined method that will be used to sort items in the list view.  When called, this method receives two ListViewItem objects as arguments.  The method should determine which of the two list view items should come first in the list view.  If the first item precedes the second, this method should return -1; if the second item precedes the first, this method should return 1; if the items are equivalent, this method should return 0.</param>
      <returns>
        The symbolic name of the user-defined method to perform the sort.
      </returns>
    </member>
    <member name="M:VO.ListView.EnsureVisible(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Ensure that an item is visible in the list view, scrolling if necessary.
      </summary>
      <param name="nItem">The index of the list view item to make visible.</param>
      <param name="lPartiallyVisible">A value of TRUE indicates that the specified item can be only partially visible.  Specify FALSE if you want the item to be fully visible.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.ListView.FullRowSelect">
      <summary>
        A logical value determining whether the entire row is highlighted when a list view item is selected.
      </summary>
      <value>A logical value determining whether the entire row is highlighted when a list view item is selected.</value>
    </member>
    <member name="M:VO.ListView.GetAllItems">
      <summary>
        Get an array with all the Listview Items
      </summary>
      <returns>
        An array with all Listview Items
      </returns>
    </member>
    <member name="M:VO.ListView.GetAllSelectedItems">
      <summary>
        Get an array with all the selected Listview Items
      </summary>
      <returns>
        An array with all selected Listview Items
      </returns>
    </member>
    <member name="M:VO.ListView.GetColumn(XSharp.__Usual)">
      <summary>
        Return a particular ListViewColumn object.
      </summary>
      <param name="xColumnID">The numeric position of the list view column in the list view.  Columns are numbered from left to right, 
        or the symbolic name of the list view column.</param>
      <returns>
        The ListViewColumn object.
      </returns>
    </member>
    <member name="M:VO.ListView.GetExLVStyle(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="kExStyle">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.ListView.GetExStyle">
      <summary>
        A logical value determining whether the specified extended list view style is enabled or disabled.
      </summary>
      <param name="kExStyle">Extended list view style to query.  (See the Microsoft Win32 Software Development Kit documentation for a list of valid constants.)</param>
      <returns>
        TRUE, if the extended ListView style is set; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ListView.GetGroupTextColor">
      <summary>
        Get the text color used for the headings when displaying a ListView control by group.
      </summary>
      <returns>
        The color object.
      </returns>
      <remarks>
        <note type="tip">
          Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
          If group view is enabled only items belonging to groups are displayed.
        </note>
      </remarks>
    </member>
    <member name="M:VO.ListView.GetItemAtPosition(XSharp.__Usual)">
      <summary>
        Return a ListViewItem object at a particular position, if one exists.
      </summary>
      <param name="oPoint">The point at which to find a list view item.</param>
      <returns>
        The ListViewItem object at the specified point.
      </returns>
    </member>
    <member name="M:VO.ListView.GetItemAttributes(XSharp.__Usual)">
      <summary>
        Return a ListViewItem object given its item index.
      </summary>
      <param name="nItem">The index of the list view item to be returned.</param>
      <returns>
        The ListViewItem object specified by the item index.
      </returns>
      <example>
        <code language="X#">
          nCount := SELF:oDClvClaims:ItemCount
          FOR x := 1 UPTO nCount
             oLVI := SELF:oDClvClaims:GetItemAttributes(x)
             IF oLVI != NULL_OBJECT
                 IF oLVI:Checked	// Using the "checkbox" property of a ListView set to YES
                       nValue := oLVI:GetValue( #dSvcDate )
                       SELF:oBillingsServer:GoTo( nValue )
                        // do some processing here        
                 DO CASE
                 CASE cClaims == "P"
                        oLVI:StateImageIndex := 1	// ImageList was predefined in a PostInit() method
                 CASE cClaims == "X"
                        oLVI:StateImageIndex := 2
                 CASE cClaims == "S"
                        oLVI:StateImageIndex := 6
                 ENDCASE
                 SELF:oDClvClaims:SetItemAttributes(oLVI)
                 ENDIF
              ENDIF
          NEXT x
        </code>
      </example>
    </member>
    <member name="M:VO.ListView.GetItemBoundingBox(XSharp.__Usual)">
      <summary>
        Return the bounding box of a ListViewItem object given its item index.
      </summary>
      <param name="nItem">The index of the list view item whose bounding box you want to obtain.</param>
      <returns>
        The bounding box of the ListViewItem object specified by the item index.
      </returns>
    </member>
    <member name="M:VO.ListView.GetItemPosition(XSharp.__Usual)">
      <summary>
        Return the origin of a ListViewItem object given its item index.
      </summary>
      <param name="nItem">The index of the list view item whose origin you want to obtain.</param>
      <returns>
        The origin of the list view item specified by the item index.
      </returns>
    </member>
    <member name="M:VO.ListView.GetItemSpacing(XSharp.__Usual)">
      <summary>
        Return the spacing between list view items in icon view or small icon view.
      </summary>
      <param name="symView">The symbolic name of the view whose spacing you want to obtain.  This value can be #IconView or #SmallIconView.  If omitted, the spacing of icon view is reported.</param>
      <returns>
        The amount of spacing between items.
      </returns>
    </member>
    <member name="M:VO.ListView.GetNextItem(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Retrieve the next list view item that possesses all of the specified properties.
      </summary>
      <param name="kRelationship">One of the following constants describing the physical relationship to the specified item. See table below for possible values</param>
      <param name="lDisabled">A value of TRUE indicates that the list view item's image should be disabled.  If omitted, the default is FALSE.</param>
      <param name="lDropTarget">A value of TRUE indicates that the list view item should be a drag and drop target.  If omitted, the default is FALSE.</param>
      <param name="lFocused">A value of TRUE indicates that the list view item should be focused.  If omitted, the default is FALSE.</param>
      <param name="lSelected">A value of TRUE indicates that the list view item should be selected.  If omitted, the default is FALSE.</param>
      <param name="nItemStart">Index of the item with which to begin searching.  If omitted, searching starts from the beginning.</param>
      <returns>
        The list view item returned as a result of the search.
      </returns>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>LV_GNIABOVE</term>
            <description>Searches for an item that is above the specified item</description>
          </item>
          <item>
            <term>LV_GNIBELOW</term>
            <description>Searches for an item that is below the specified item</description>
          </item>
          <item>
            <term>LV_GNIBYITEM</term>
            <description>Searches for a subsequent item by index (the default value)</description>
          </item>
          <item>
            <term>LV_GNILEFT</term>
            <description>Searches for an item to the left of the specified item</description>
          </item>
          <item>
            <term>LV_GNIRIGHT</term>
            <description>Searches for an item to the right of the specified item</description>
          </item>
        </list>
      </remarks>
      <example>
        The example below shows how to traverse all items in a ListView for further processing.  Note that the GetNextItem() method's last parameter is zero-based:
        <code language="X#">
          LOCAL oLVI	AS ListViewItem
          nCount		:= SELF:oDClvPlayers:ItemCount
          FOR x := 1 UPTO nCount
          oLVI		:= SELF:oDClvPlayers:GetNextItem( LV_GNIBYITEM,,,,,x-1 )
          cID		:= AllTrim( oLVI:GetText( #cPlayerID ) )
          nRecNo	:=  oLVI:GetValue( #cPlayerID )
          NEXT x
        </code></example>
    </member>
    <member name="M:VO.ListView.GetSelectedColumn">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.ListView.GetSelectedItem">
      <summary>
        Retrieve the currently selected ListViewItem object.
      </summary>
      <returns>
        The currently selected ListViewItem object.
      </returns>
    </member>
    <member name="P:VO.ListView.GridLines">
      <summary>
        A logical value determining whether gridlines are shown in the list view.
      </summary>
      <value>A logical value determining whether gridlines are shown in the list view.</value>
      <remarks>
        A logical value determining whether gridlines are shown in the list view.
        Important - Microsoft Note - Under visual styles GridLines are not always displayed correctly.
        See http://support.microsoft.com/default.aspx?scid=kb;en-us;813791 for more info.
      </remarks>
    </member>
    <member name="M:VO.ListView.HasGroup(XSharp.__Usual)">
      <summary>
        A logical value to determine if the group with the specified ID exists in a ListView control.
      </summary>
      <param name="iGroupId">The number of the group.</param>
      <returns>
        TRUE if it exists; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">
          Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
          If group view is enabled only items belonging to groups are displayed.
        </note>
      </remarks>
    </member>
    <member name="P:VO.ListView.HeaderDragDrop">
      <summary>
        A logical value determining whether columns can be rearranged in the list view by dragging and dropping the column headers.
      </summary>
      <value>A logical value determining whether columns can be rearranged in the list view by dragging and dropping the column headers.</value>
    </member>
    <member name="M:VO.ListView.InsertColumn(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Insert a new ListViewColumn object after a particular column index in the list view.
      </summary>
      <param name="oListViewColumn">The ListViewColumn object to insert in the list view.</param>
      <param name="nInsertAfter">The position after which to insert the new column.  If omitted, the new column is added to the end of the column list.</param>
      <returns>
        TRUE if the column was inserted successfully; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ListView.InsertItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Insert a new ListViewItem object after a particular item index in the list view.
      </summary>
      <param name="oListViewItem">The ListViewItem object to insert in the list view.</param>
      <param name="nInsertAfter">The position after which to insert the new item.  If omitted, the new item is added as the last item.</param>
      <returns>
        TRUE if the item was inserted successfully; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.ListView.IsGroupViewEnabled">
      <summary>
        A logical value to identify if ListView groups are enabled.
      </summary>
      <value>A logical value to identify if ListView groups are enabled.</value>
      <remarks>
        A logical value to identify if ListView groups are enabled.
        <note type="tip">
          Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
          If group view is enabled only items belonging to groups are displayed.
        </note></remarks>
    </member>
    <member name="P:VO.ListView.ItemCount">
      <summary>
        A numeric value representing the number of items in the list view.
      </summary>
      <value>A numeric value representing the number of items in the list view.</value>
    </member>
    <member name="P:VO.ListView.ItemsPerPage">
      <summary>
        A numeric value representing the number of items that can fit vertically in the visible area of the list view.
      </summary>
      <value>A numeric value representing the number of items that can fit vertically in the visible area of the list view.</value>
    </member>
    <member name="P:VO.ListView.LargeImageList">
      <summary>
        An image list containing large images to display for each item when the list view is displayed in icon view.
      </summary>
      <value>An image list containing large images to display for each item when the list view is displayed in icon view.</value>
      <example>
        This example would typically occur in a PostInit() method of a window.  In the example below, when the ListView is populated, each item will be assigned an image index, in this case depending upon whether the player in question is active or not.
        <code language="X#">
          LOCAL oImageList 	AS ImageList
          oImageList := ImageList{2, Dimension{32, 32}}
          oImageList:Add(SmIconCheck{})
          oImageList:Add(SmIconCross{})
          SELF:oDClvPlayers:LargeImageList := oImageList
        </code></example>
    </member>
    <member name="M:VO.ListView.RedrawRange(XSharp.__Usual)">
      <summary>
        Redraw a range of list view items.
      </summary>
      <param name="oRange">The range of list view item indexes to redraw.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ListView.RemoveAllGroups">
      <summary>
        Remove all groups from a ListView control.
      </summary>
      <remarks>
        <note type="tip">
          Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
          If group view is enabled only items belonging to groups are displayed.
        </note>
      </remarks>
    </member>
    <member name="M:VO.ListView.RemoveGroup(XSharp.__Usual)">
      <summary>
        Remove the group with the specified ID from a ListView control.
      </summary>
      <param name="iGroupId">The number of the group.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">
          Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
          If group view is enabled only items belonging to groups are displayed.
        </note>
      </remarks>
    </member>
    <member name="M:VO.ListView.Scroll(XSharp.__Usual)">
      <summary>
        Scroll the contents of a list view.
      </summary>
      <param name="oDimension">The dimension representing the amount to scroll the list view.  Positive width values scroll to the right, while negative width values scroll to the left.  In addition, positive height values scroll upwards, while negative height values scroll downwards.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.ListView.SearchString">
      <summary>
        The incremental search string associated with the list view.
      </summary>
      <value>The incremental search string associated with the list view.</value>
      <remarks>
        The incremental search string associated with the list view.  The incremental search string is the character sequence that the user types while the list view has the input focus.  When the user types a character, the character is appended to the search string and a matching item is sought.  If the system finds a match, it selects the item.  A timeout period is associated with the search string; if the timeout period elapses before the user types another character, the string is reset.
      </remarks>
    </member>
    <member name="M:VO.ListView.Seek(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Search the list view for a particular list view item.
      </summary>
      <param name="uValue">The value to seek.  &lt;kSeekType&gt; must be LV_SEEKVALUE.</param>
      <param name="cText">The string to seek.  &lt;kSeekType&gt; must be LV_SEEKTEXT.</param>
      <param name="oPoint">The point in the client area of the list view at which the seek begins.  The nearest list view item to this point in the direction specified by &lt;kSeekType&gt; will be returned.</param>
      <param name="kSeekType">A constant that specifies what type of seek to perform.  LV_SEEKVALUE causes a seek on a usual value.  LV_SEEKTEXT causes a seek on a text string.   If the seek is on a Point object, this argument can be LV_SEEKUP or LV_SEEKDOWN to specify a search in the respective directions.  In this case, if the argument is omitted, LV_SEEKDOWN is assumed.</param>
      <param name="nStart">The index of the list view item at which to begin the search.  If omitted, the seek begins at the first item.</param>
      <param name="lWrap">A value of TRUE continues the search at the first list view item if no match is found.  If omitted, the default is FALSE, which disables wrapping.</param>
      <param name="lPartial">A value of TRUE produces a match if the list view item label begins with &lt;cText&gt;.  If omitted, the default is FALSE, which disables partial seeking.</param>
      <returns>
        The list view item returned as a result of the seek.
      </returns>
    </member>
    <member name="P:VO.ListView.SelectedCount">
      <summary>
        A numeric value representing the number of items that are selected in the list view.
      </summary>
      <value>A numeric value representing the number of items that are selected in the list view.</value>
    </member>
    <member name="M:VO.ListView.SelectItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Select or deselect a specific item in a list view.
      </summary>
      <param name="nItem">Index of the list view items in the list view to be selected or deselected.</param>
      <param name="lSelect">Select (TRUE) or deselect (FALSE) the item in the list view.  The default setting is TRUE.</param>
      <returns>
        TRUE if the list view item was selected; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ListView.SelectNextItem">
      <summary>
        Select the next list view item after the currently selected item.
      </summary>
      <returns>
        TRUE if the selection was successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ListView.SetBackgroundImage(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set an image as the background to the list view.
      </summary>
      <param name="uImage">
        The image to use as the background in one of the following four types.
        Object	A BitMap object
        PTR	An image handle
        String	A URL or filename as a string
        NIL	If you want to remove the background
      </param>
      <param name="dwFlags">
        Flags that can be set to create the required style. More than one style can be used by combining them with _Or()
        _Or( LVBKIF_SOURCE_HBITMAP, LVBKIF_STYLE_TILE )
        _Or( LVBKIF_SOURCE_URL, LVBKIF_STYLE_TILE )
      </param>
      <param name="xOffSet">controls the x placement of the image.</param>
      <param name="yOffSet">controls the y placement of the image.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">
          The use of this method requires either the OLE library to be linked in or a call to CoInitialize().
          If CoInitialize() is called it will also require a call to CoUnitialize() later.
        </note>
      </remarks>
    </member>
    <member name="M:VO.ListView.SetColumnFormat(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the desired extended style for a list view.
      </summary>
      <param name="nCol">The column index number.</param>
      <param name="dwFlag">
        Flags that can be set to create the required style. More than one style can be used by combining them with _Or()
        Available styles are -
        HDF_CENTER	Allign the column to the center.
        HDF_LEFT	Allign the column to the left. This is the default.
        HDF_RIGHT	Allign the column to the right.
        HDF_BITMAP	Add a bitmap to the left of the column.
        HDF_BITMAP_ON_RIGHT	Add a bitmap to the right of the column.
        HDF_SORTDOWN	down arrow in header - For visual themes only
        HDF_SORTUP	up arrow in header - For visual themes only
      </param>
      <param name="nImage">the number of the image in the image list to display in the column header. The default is no image.</param>
      <returns>
        TRUE, if the style was enabled; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ListView.SetExLVStyle(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="kExStyle">** missing parameter documentation **</param>
      <param name="lEnable">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.ListView.SetExStyle(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the desired extended style for a list view.
      </summary>
      <param name="kExStyle">The extended list view style to be set.  (See the Microsoft Win32 Software Development Kit documentation for a list of valid constants.)</param>
      <param name="lNewVal">A logical value determining whether the specified extended style should be enabled (TRUE) or disabled (FALSE).</param>
      <returns>
        TRUE, if the extended style was enabled; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ListView.SetGroupName(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the name of a list view group.
      </summary>
      <param name="iGroupId">The number of the group.</param>
      <param name="cGroupName">group name</param>
      <param name="dwAlign">
        The group alignment.
        Available options are -
        LVGA_HEADER_LEFT
        LVGA_HEADER_RIGHT
        LVGA_HEADER_CENTER
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">
          Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
          If group view is enabled only items belonging to groups are displayed.
        </note>
      </remarks>
    </member>
    <member name="M:VO.ListView.SetGroupTextColor(XSharp.__Usual)">
      <summary>
        Set the text color to be used for the headings when displaying a ListView control by group.
      </summary>
      <param name="oColor">The color object required.</param>
      <remarks>
        <note type="tip">
          Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
          If group view is enabled only items belonging to groups are displayed.
        </note>
      </remarks>
    </member>
    <member name="M:VO.ListView.SetItemAttributes(XSharp.__Usual)">
      <summary>
        Update a ListViewItem object with new attributes.
      </summary>
      <param name="oListViewItem">The list view item whose attributes you want to change.</param>
      <example>
        <code language="X#">
          nCount := SELF:oDClvClaims:ItemCount
          FOR x := 1 UPTO nCount
             oLVI := SELF:oDClvClaims:GetItemAttributes(x)
             IF oLVI != NULL_OBJECT
                 IF oLVI:Checked	// Using the "checkbox" property of a ListView set to YES
                       nValue := oLVI:GetValue( #dSvcDate )
                       SELF:oBillingsServer:GoTo( nValue )
                         // do some processing here        
                 DO CASE
                 CASE cClaims == "P"
                        oLVI:StateImageIndex := 1	// ImageList was predefined in a PostInit() method
                 CASE cClaims == "X"
                        oLVI:StateImageIndex := 2
                 CASE cClaims == "S"
                        oLVI:StateImageIndex := 3
                 ENDCASE
                 SELF:oDClvClaims:SetItemAttributes(oLVI)
                 ENDIF
              ENDIF
          NEXT x
        </code>
      </example>
    </member>
    <member name="M:VO.ListView.SetItemGroupId(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        A logical value to determine if the group with the specified ID exists in a ListView control.
      </summary>
      <param name="uLVI">The item index or ListViewItem.</param>
      <param name="nId">The number of the group.</param>
      <remarks>
        <note type="tip">
          Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
          If group view is enabled only items belonging to groups are displayed.
        </note>
      </remarks>
    </member>
    <member name="M:VO.ListView.SetItemPosition(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Move a list view item to a new position in icon view or small icon view.
      </summary>
      <param name="nItem">The index of the list view item whose position you want to change.</param>
      <param name="oPoint">The new position of the list view item.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ListView.SetSelectedColumn(XSharp.__Usual)">
      <summary>
        Show column as selected.
      </summary>
      <param name="nIndex">The column index number.</param>
    </member>
    <member name="P:VO.ListView.SmallImageList">
      <summary>
        An image list containing small images to display for each item when the list view is displayed in list view, report view, or small icon view.  The icons in this list must be defined elsewhere in
      </summary>
      <value>An image list containing small images to display for each item when the list view is displayed in list view, report view, or small icon view.  The icons in this list must be defined elsewhere in</value>
      <example>
        This example would typically occur in a PostInit() method of a window.  In the example below, when the ListView is populated, each item will be assigned an image index, in this case depending upon whether the player in question is active or not.
        <code language="X#">LOCAL oImageList 	AS ImageList</code><code language="X#">
          oImageList := ImageList{2, Dimension{16, 16}}
          oImageList:Add(SmIconCheck{})
          oImageList:Add(SmIconCross{})
          SELF:oDClvPlayers:SmallImageList := oImageList
        </code></example>
    </member>
    <member name="M:VO.ListView.SortItems">
      <summary>
        Sort the list view items using the user-defined sort method specified by EnableSort().
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.ListView.StateImageList">
      <summary>
        An image list containing state images to display for each item in the list view.
      </summary>
      <value>An image list containing state images to display for each item in the list view.</value>
    </member>
    <member name="P:VO.ListView.TextBackgroundColor">
      <summary>
        A Color object used to paint the text background in the list view.
      </summary>
      <value>A Color object used to paint the text background in the list view.</value>
    </member>
    <member name="P:VO.ListView.TextColor">
      <summary>
        A Color object used to paint the text in the list view.
      </summary>
      <value>A Color object used to paint the text in the list view.</value>
    </member>
    <member name="P:VO.ListView.TopItem">
      <summary>
        A numeric value representing the index of the topmost visible item when the list view is in list view or report view.
      </summary>
      <value>A numeric value representing the index of the topmost visible item when the list view is in list view or report view.</value>
    </member>
    <member name="P:VO.ListView.TrackSelection">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.ListView.Update(XSharp.__Usual)">
      <summary>
        Update a list view item.
      </summary>
      <param name="nItem">The index of the list view item to update.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ListView.ViewAs(XSharp.__Usual)">
      <summary>
        Change the current view of the list view.
      </summary>
      <param name="symView">The symbolic name of the new view for the list view.  It can be one of the following values:</param>
    </member>
    <member name="P:VO.ListView.ViewBoundingBox">
      <summary>
        The bounding box that encloses all of a list view's items when in icon view or small icon view.
      </summary>
      <value>The bounding box that encloses all of a list view's items when in icon view or small icon view.</value>
    </member>
    <member name="P:VO.ListView.ViewOrigin">
      <summary>
        The Point object representing the current view origin of a list view when in icon view or small icon view.
      </summary>
      <value>The Point object representing the current view origin of a list view when in icon view or small icon view.</value>
    </member>
    <member name="M:VO.ListView_CompareDelegate.#ctor(System.Object,System.IntPtr)">
      <exclude />
    </member>
    <member name="M:VO.ListView_CompareDelegate.BeginInvoke(System.Int32,System.Int32,System.Int32,System.AsyncCallback,System.Object)">
      <exclude />
    </member>
    <member name="M:VO.ListView_CompareDelegate.EndInvoke(System.IAsyncResult)">
      <exclude />
    </member>
    <member name="M:VO.ListView_CompareDelegate.Invoke(System.Int32,System.Int32,System.Int32)">
      <exclude />
    </member>
    <member name="T:VO.ListViewColumn">
      <summary>
        Create a list view column.
      </summary>
      <remarks>
        A list view column is an object that is added to a list view control.  Although a list view control does not have to be displayed in column or report view, at least one column must be added in order to add items to the control.
      </remarks>
    </member>
    <member name="M:VO.ListViewColumn.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a list view column.
      </summary>
      <param name="nWidth">The character width of the list view column.  If omitted, the width is 16 characters.</param>
      <param name="xColumnID">The HyperLabel object for the column or the symbolic or string name of the column.</param>
      <param name="kAlignment">Optional constant representing the alignment of the list view column.  If omitted, defaults to left-alignment.  </param>
      <remarks>
        Valid constants are:
        LVCFMT_RIGHT
        LVCFMT_CENTER
        LVCFMT_LEFT
      </remarks>
    </member>
    <member name="P:VO.ListViewColumn.Alignment">
      <summary>
        A constant representing the alignment of the list view column.  One of the following values can be used:
        LVCFMT_LEFT
        LVCFMT_CENTER
        LVCFMT_RIGHT
      </summary>
      <value>
        A constant representing the alignment of the list view column.  One of the following values can be used:
        LVCFMT_LEFT
        LVCFMT_CENTER
        LVCFMT_RIGHT
      </value>
    </member>
    <member name="P:VO.ListViewColumn.Caption">
      <summary>
        The caption displayed in the list view column header.
      </summary>
      <value>The caption displayed in the list view column header.</value>
    </member>
    <member name="M:VO.ListViewColumn.Destroy">
      <inheritdoc />
    </member>
    <member name="P:VO.ListViewColumn.FieldSpec">
      <summary>
        The FieldSpec object for the list view column.
      </summary>
      <value>The FieldSpec object for the list view column.</value>
    </member>
    <member name="M:VO.ListViewColumn.GetPixWidth">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.ListViewColumn.HyperLabel">
      <summary>
        The HyperLabel object for the list view column.
      </summary>
      <value>The HyperLabel object for the list view column.</value>
    </member>
    <member name="P:VO.ListViewColumn.NameSym">
      <summary>
        The symbolic name of the list view column.
      </summary>
      <value>The symbolic name of the list view column.</value>
    </member>
    <member name="P:VO.ListViewColumn.Owner">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.ListViewColumn.SetPixWidth(System.Int32)">
      <param name="dwPixWidth">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.ListViewColumn.Width">
      <summary>
        A numeric value that represents the character width of the list view column.
      </summary>
      <value>A numeric value that represents the character width of the list view column.</value>
      <remarks>
        <para>For autosizing, one of the following values can be used:</para>
        <list type="table">
          <item>
            <term>LVCSW_AUTOSIZE</term>
            <description>The list view column is automatically sized to the entry with the maximum width (-1).</description>
          </item>
          <item>
            <term>LVCSW_AUTOSIZE_HEADER</term>
            <description>The list view column is automatically sized to the width of its header (-2)..</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="T:VO.ListViewColumnClickEvent">
      <summary>
        Provide information about a list view column click event, which is generated when the header of a column in a list view control is clicked.
      </summary>
      <remarks>
        The list view control must be in report view in order for this event to be generated because this is the only view in which column headers are displayed.  This event returns the ListViewColumn object which was clicked.  A common action to take in response to this event is to sort the items in the column.

      </remarks>
    </member>
    <member name="M:VO.ListViewColumnClickEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ListViewColumnClickEvent.ListViewColumn">
      <summary>
        The ListViewColumn object whose header was clicked.
      </summary>
      <value>The ListViewColumn object whose header was clicked.</value>
    </member>
    <member name="T:VO.ListViewDeleteEvent">
      <summary>
        Provide information about a list view delete event, which is generated when an item in a list view control is deleted.
      </summary>
      <remarks>
        The list view control generates this event whenever one of its items is deleted.  The information packaged with this Event object includes which item was deleted so that the application can process any information stored in the ListViewItem object.

      </remarks>
    </member>
    <member name="M:VO.ListViewDeleteEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ListViewDeleteEvent.ListViewItem">
      <summary>
        The ListViewItem object which was deleted.
      </summary>
      <value>The ListViewItem object which was deleted.</value>
    </member>
    <member name="T:VO.ListViewDragEvent">
      <summary>
        Provide information about a list view drag event, which is generated when an item in a list view control is dragged.
      </summary>
      <remarks>
        The list view control generates this event whenever one of its items is dragged.  The user can use either the right or the left mouse button to generate the event and can take different courses of action depending on which mouse button is currently being used.

      </remarks>
    </member>
    <member name="M:VO.ListViewDragEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ListViewDragEvent.IsLeftButton">
      <summary>
        A logical value that is TRUE if this is a left-button drag.
      </summary>
      <value>A logical value that is TRUE if this is a left-button drag.</value>
    </member>
    <member name="P:VO.ListViewDragEvent.IsRightButton">
      <summary>
        A logical value that is TRUE if this is a right-button drag.
      </summary>
      <value>A logical value that is TRUE if this is a right-button drag.</value>
    </member>
    <member name="P:VO.ListViewDragEvent.ListViewItem">
      <summary>
        The ListViewItem object which is being dragged.
      </summary>
      <value>The ListViewItem object which is being dragged.</value>
    </member>
    <member name="P:VO.ListViewDragEvent.Position">
      <summary>
        A Point object that describes the initial position of the drag in list view control coordinates.
      </summary>
      <value>A Point object that describes the initial position of the drag in list view control coordinates.</value>
    </member>
    <member name="T:VO.ListViewEditEvent">
      <summary>
        Provide information about a list view edit event, which is generated when the label of an item in a list view control is edited.
      </summary>
      <remarks>
        The list view control generates this event whenever the label of one of its items is edited.  The event is actually generated twice for any edit operation: once at the beginning of the edit and once at the end.  Properties of this object can determine whether the edit is beginning or ending.

      </remarks>
    </member>
    <member name="M:VO.ListViewEditEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ListViewEditEvent.EditBeginning">
      <summary>
        A logical value that is TRUE if the edit is beginning.
      </summary>
      <value>A logical value that is TRUE if the edit is beginning.</value>
    </member>
    <member name="P:VO.ListViewEditEvent.EditEnding">
      <summary>
        A logical value that is TRUE if the edit is ending.
      </summary>
      <value>A logical value that is TRUE if the edit is ending.</value>
    </member>
    <member name="P:VO.ListViewEditEvent.EditText">
      <summary>
        String value containing the new label text of a list view item after that item's label has been edited.
      </summary>
      <value>String value containing the new label text of a list view item after that item's label has been edited.</value>
    </member>
    <member name="P:VO.ListViewEditEvent.ListViewItem">
      <summary>
        The ListViewItem object which is being edited.
      </summary>
      <value>The ListViewItem object which is being edited.</value>
    </member>
    <member name="T:VO.ListViewItem">
      <summary>
        Create a list view item.
      </summary>
      <remarks>
        A list view item describes an item in a list view control.
      </remarks>
    </member>
    <member name="M:VO.ListViewItem.#ctor">
      <summary>
        Construct a list view item.
      </summary>
    </member>
    <member name="P:VO.ListViewItem.Checked">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.ListViewItem.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.ListViewItem.Disabled">
      <summary>
        A logical value that is TRUE if the image of a list view item is displayed in a disabled fashion.
      </summary>
      <value>A logical value that is TRUE if the image of a list view item is displayed in a disabled fashion.</value>
    </member>
    <member name="P:VO.ListViewItem.DropTarget">
      <summary>
        A logical value that is TRUE if the list view item is highlighted as the target of a drag and drop operation.
      </summary>
      <value>A logical value that is TRUE if the list view item is highlighted as the target of a drag and drop operation.</value>
    </member>
    <member name="P:VO.ListViewItem.Focused">
      <summary>
        A logical value that is TRUE if the list view item is focused.
      </summary>
      <value>A logical value that is TRUE if the list view item is focused.</value>
    </member>
    <member name="M:VO.ListViewItem.GetText(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Retrieve the text label of a column.
      </summary>
      <param name="symColumnName">The symbolic name of the column whose text you want to retrieve.</param>
      <param name="nRefImageIndex">If this is a reference to a numeric variable, it gets the image index of this column.</param>
      <returns>
        The text label of the specified column.
      </returns>
      <example>
        <code language="X#">
          oLVI := SELF:oDClvClaims:GetItemAttributes( nItemNr )
          IF oLVI != NULL_OBJECT
              cCity := oLVI:GetText( #cCity )
          ENDIF
        </code>
      </example>
    </member>
    <member name="M:VO.ListViewItem.GetValue(XSharp.__Usual)">
      <summary>
        Retrieve the value of a column.
      </summary>
      <param name="symColumnName">The symbolic name of the column whose value you want to retrieve.</param>
      <returns>
        The value of the specified column.
      </returns>
      <example>
        <code language="X#">
          nCount := SELF:oDClvClaims:ItemCount
          FOR x := 1 UPTO nCount
             oLVI := SELF:oDClvClaims:GetItemAttributes(x)
             IF oLVI != NULL_OBJECT
                  nValue := oLVI:GetValue( #nItems )
           nTotal  += nValue
             ENDIF
          NEXT x
        </code>
      </example>
    </member>
    <member name="P:VO.ListViewItem.ImageIndex">
      <summary>
        A numeric value that represents the index of the list view item's image in the image list.
      </summary>
      <value>A numeric value that represents the index of the list view item's image in the image list.</value>
    </member>
    <member name="P:VO.ListViewItem.Indent">
      <summary>
        Sets the indentation of a ListView item.
      </summary>
      <value>Sets the indentation of a ListView item.</value>
      <remarks>
        <note type="tip">
          This is only available in detail view, and then only if the item has an associated image.
        </note>
      </remarks>
    </member>
    <member name="P:VO.ListViewItem.ItemIndex">
      <summary>
        A numeric value that represents the index of the list view item in the list view control.
      </summary>
      <value>A numeric value that represents the index of the list view item in the list view control.</value>
    </member>
    <member name="P:VO.ListViewItem.OverlayImageIndex">
      <summary>
        A numeric value that represents the index of the list view item's overlay image in the image list.
      </summary>
      <value>A numeric value that represents the index of the list view item's overlay image in the image list.</value>
      <remarks>
        A numeric value that represents the index of the list view item's overlay image in the image list.  Overlay images are images that are drawn over the item's main image.  A list view can have up to four overlay images, so this value can be in the range of 1 to 4.
      </remarks>
    </member>
    <member name="P:VO.ListViewItem.Selected">
      <summary>
        A logical value that is TRUE if the list view item is selected.
      </summary>
      <value>A logical value that is TRUE if the list view item is selected.</value>
    </member>
    <member name="M:VO.ListViewItem.SetText(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the text label of a column.
      </summary>
      <param name="cNewText">The text to be added to the column.</param>
      <param name="symColumnName">The symbolic name of the column whose text you want to set.</param>
      <param name="nImageIndex">A numeric value that represents the index of the list view’s column image in the image list.</param>
      <remarks>
        <note type="tip">
          SubItemImages only work if the ListView control has the style LVS_EX_SUBITEMIMAGES. You can set this style with ListView:SetExLVStyle(LVS_EX_SUBITEMIMAGES).
        </note>
      </remarks>
      <example>
        See the ListView:AddItem() method for sample syntax.
      </example>
    </member>
    <member name="M:VO.ListViewItem.SetValue(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the value of a column.
      </summary>
      <param name="uNewValue">The value to be added to the column.</param>
      <param name="symColumnName">The symbolic name of the column whose value you want to set.</param>
      <example>
        See the ListView:AddItem() method for sample syntax.
      </example>
    </member>
    <member name="P:VO.ListViewItem.StateImageIndex">
      <summary>
        A numeric value that represents the index of the list view item's state image in the state image list.
      </summary>
      <value>A numeric value that represents the index of the list view item's state image in the state image list.</value>
      <remarks>
        A numeric value that represents the index of the list view item's state image in the state image list.  State images are images that are drawn next to the item's main image.
      </remarks>
      <example>
        <code language="X#">
          nCount := SELF:oDClvClaims:ItemCount
          FOR x := 1 UPTO nCount
             oLVI := SELF:oDClvClaims:GetItemAttributes(x)
             IF oLVI != NULL_OBJECT
                 IF oLVI:Checked	// Using the "checkbox" property of a ListView set to YES
                       nValue := oLVI:GetValue( #dSvcDate )
                       SELF:oBillingsServer:GoTo( nValue )
                         // do some processing here        
                 DO CASE
                 CASE cClaims == "P"
                        oLVI:StateImageIndex := 1	// ImageList was predefined in a PostInit() method
                 CASE cClaims == "X"
                        oLVI:StateImageIndex := 2
                 CASE cClaims == "S"
                        oLVI:StateImageIndex := 3
                 ENDCASE
                 SELF:oDClvClaims:SetItemAttributes(oLVI)
                 ENDIF
              ENDIF
          NEXT x
        </code>
      </example>
    </member>
    <member name="T:VO.ListViewItemEvent">
      <summary>
        Provide information about events generated when operations with list view items are taking place.
      </summary>
      <remarks>
        ListViewItem events are generated by ListView controls whenever an ListViewItem is changed, deleted or dragged.
      </remarks>
    </member>
    <member name="M:VO.ListViewItemEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ListViewItemEvent.ListViewItem">
      <summary>
        The ListViewItem object affected by the list view item event.
      </summary>
      <value>The ListViewItem object affected by the list view item event.</value>
    </member>
    <member name="T:VO.ListViewKeyEvent">
      <summary>
        Provide information about a list view key event, which is generated when a key is pressed while the list view control has the input focus.
      </summary>
      <remarks>
        The list view control generates this event whenever a key is pressed while the list view control has the input focus.  Information packaged with this event includes the virtual key code of the pressed key.

      </remarks>
    </member>
    <member name="M:VO.ListViewKeyEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ListViewKeyEvent.KeyCode">
      <summary>
        The virtual key code of the key that was pressed.
      </summary>
      <value>The virtual key code of the key that was pressed.</value>
    </member>
    <member name="T:VO.ListViewMouseEvent">
      <summary>
        Provide information about a list view mouse event, which is generated when a mouse button in a list view control is clicked or double-clicked.
      </summary>
      <remarks>
        This event occurs when a mouse click or double-click occurs within the list view control.  Properties of the event determine not only the position where the event occurred physically but also the event's relationship to items in the control.

      </remarks>
    </member>
    <member name="M:VO.ListViewMouseEvent.#ctor(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ListViewMouseEvent.ButtonID">
      <summary>
        A constant representing which mouse button was clicked.  The value can be either BUTTONLEFT or BUTTONRIGHT.
      </summary>
      <value>A constant representing which mouse button was clicked.  The value can be either BUTTONLEFT or BUTTONRIGHT.</value>
    </member>
    <member name="P:VO.ListViewMouseEvent.IsLeftButton">
      <summary>
        A logical value that is TRUE if this is a left-button event.
      </summary>
      <value>A logical value that is TRUE if this is a left-button event.</value>
    </member>
    <member name="P:VO.ListViewMouseEvent.IsRightButton">
      <summary>
        A logical value that is TRUE if this is a right-button event.
      </summary>
      <value>A logical value that is TRUE if this is a right-button event.</value>
    </member>
    <member name="P:VO.ListViewMouseEvent.ListViewItem">
      <summary>
        The ListViewItem object which was clicked, if the mouse click occurred on an item; otherwise, a null object.
      </summary>
      <value>The ListViewItem object which was clicked, if the mouse click occurred on an item; otherwise, a null object.</value>
    </member>
    <member name="P:VO.ListViewMouseEvent.PointAboveClientArea">
      <summary>
        A logical value that is TRUE if the click occurred above the list view control's client area.
      </summary>
      <value>A logical value that is TRUE if the click occurred above the list view control's client area.</value>
    </member>
    <member name="P:VO.ListViewMouseEvent.PointBelowClientArea">
      <summary>
        A logical value that is TRUE if the click occurred below the list view control's client area.
      </summary>
      <value>A logical value that is TRUE if the click occurred below the list view control's client area.</value>
    </member>
    <member name="P:VO.ListViewMouseEvent.PointLeftOfClientArea">
      <summary>
        A logical value that is TRUE if the click occurred to the left of the list view control's client area.
      </summary>
      <value>A logical value that is TRUE if the click occurred to the left of the list view control's client area.</value>
    </member>
    <member name="P:VO.ListViewMouseEvent.PointNowhere">
      <summary>
        A logical value that is TRUE if the click occurred inside the list view control but not on an item.
      </summary>
      <value>A logical value that is TRUE if the click occurred inside the list view control but not on an item.</value>
    </member>
    <member name="P:VO.ListViewMouseEvent.PointOnItem">
      <summary>
        A logical value that is TRUE if the click occurred on a list view item in the list view control.
      </summary>
      <value>A logical value that is TRUE if the click occurred on a list view item in the list view control.</value>
    </member>
    <member name="P:VO.ListViewMouseEvent.PointOnItemImage">
      <summary>
        A logical value that is TRUE if the click occurred on a list view item's image in the list view control.
      </summary>
      <value>A logical value that is TRUE if the click occurred on a list view item's image in the list view control.</value>
    </member>
    <member name="P:VO.ListViewMouseEvent.PointOnItemLabel">
      <summary>
        A logical value that is TRUE if the click occurred on a list view item's label in the list view control.
      </summary>
      <value>A logical value that is TRUE if the click occurred on a list view item's label in the list view control.</value>
    </member>
    <member name="P:VO.ListViewMouseEvent.PointOnItemStateImage">
      <summary>
        A logical value that is TRUE if the click occurred on a list view item's state image in the list view control.
      </summary>
      <value>A logical value that is TRUE if the click occurred on a list view item's state image in the list view control.</value>
    </member>
    <member name="P:VO.ListViewMouseEvent.PointRightOfClientArea">
      <summary>
        A logical value that is TRUE if the click occurred to the right of the list view control's client area.
      </summary>
      <value>A logical value that is TRUE if the click occurred to the right of the list view control's client area.</value>
    </member>
    <member name="P:VO.ListViewMouseEvent.Position">
      <summary>
        A Point object that describes the position where the click occurred in list view control coordinates.
      </summary>
      <value>A Point object that describes the position where the click occurred in list view control coordinates.</value>
    </member>
    <member name="T:VO.LogFile">
      <summary>
        Provide logging facilities to Internet server applications.
      </summary>
      <remarks>
        The LogFile class provides log output and error protocol capabilities.
      </remarks>
    </member>
    <member name="M:VO.LogFile.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a LogFile object instance.
      </summary>
      <param name="cName">Log file name.  If not specified, the log file name is identical to the application name.  The extension is .LOG.</param>
      <param name="lWinLogPath">Specifies whether the log file should be created within the directory specified as LogFileDirectory by Windows (TRUE), or if the log file should be created within the application's directory (FALSE).  The default is FALSE.</param>
      <param name="lAppend">Flag determining whether log messages should be appended to the end of an existing log file (TRUE), or if any existing log file should be overwritten by log messages of that object (FALSE).  The default is TRUE.</param>
    </member>
    <member name="P:VO.LogFile.Append">
      <summary>
        A logical value that determinds whether text should be appended to the end of the file or not.
      </summary>
      <value>A logical value that determinds whether text should be appended to the end of the file or not.</value>
    </member>
    <member name="M:VO.LogFile.DebugMsg(System.String)">
      <summary>
        Add a message to the log file.
      </summary>
      <param name="cMsg">String containing the message.</param>
      <remarks>
        This method adds a message to the log file.
      </remarks>
    </member>
    <member name="M:VO.LogFile.DumpError(XSharp.__Usual)">
      <summary>
        Add the runtime error description to the log file.
      </summary>
      <param name="oError">Error object instance.</param>
      <remarks>
        This method adds the error description to the log file.
      </remarks>
      <example>
        The following common framework for CGI applications uses the LogFile class to log error messages and application progress information:
        <code language="X#">
          CLASS MyFilter INHERIT LogFile
          CLASS StdHTTPContext        INHERIT HTTPCGIContext
          FUNCTION Start
          LOCAL oCGI      AS StdHTTPContext
          LOCAL cHtml     AS STRING
          LOCAL oOldError AS USUAL
          LOCAL oError    AS USUAL
          LOCAL oLogFile  AS  LogFile
          oLogFile := LogFile{}
          #IFDEF __DEBUG__
          oCGI:DebugMsg("CGI application started")
          #ENDIF
          oCGI := StdHTTPContext{}
          oOldError := ErrorBlock( {|oErr|__MyError(oErr)} )
          BEGIN SEQUENCE
          cHtml := oCGI:HTTPResponse()
          IF SLen(cHtml) &gt; 0
          //
          //  Default behavior, return a HTML
          //
          oCGI:Write(cHtml)
          ENDIF
          RECOVER USING oError
          cHtml := oCGI:HTTPErrorMessage(oError)
          oCGI:Write(cHtml)
          oLogFile:DumpError(oError)
          END SEQUENCE
          ErrorBlock( oOldError )
          oCGI:Close()
          #IFDEF __DEBUG__
          oCGI:DebugMsg("CGI application finished")
          #ENDIF
          RETURN
          STATIC FUNC __MyError   (oError)
          LOCAL cRepl AS STRING
          cRepl := "Module " + ProcName(1)
          cRepl += ", line " + NTrim(ProcLine(1))
          IF SLen(oError:Description) &gt; 0
          oError:Description += "(" + cRepl + ")"
          ELSE
          oError:Description := cRepl
          ENDIF
          BREAK(oError)
        </code></example>
    </member>
    <member name="P:VO.LogFile.FName">
      <summary>
        String representing the file name for log messages.
      </summary>
      <value>String representing the file name for log messages.</value>
    </member>
    <member name="P:VO.LogFile.Log2File">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="P:VO.LogFile.ServerPath">
      <summary>
        String representing the full path specification of the Internet server application.
      </summary>
      <value>String representing the full path specification of the Internet server application.</value>
    </member>
    <member name="T:VO.LogicFS">
      <summary>
        Create a logic field specification, which holds logic data type information.
      </summary>
    </member>
    <member name="M:VO.LogicFS.#ctor(XSharp.__Usual)">
      <summary>
        Construct a logic field specification.
      </summary>
      <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new logic field specification.</param>
    </member>
    <member name="T:VO.Menu">
      <summary>
        Create a menu.  Menus consist of items which the user selects for execution; a menu item can be a string, a bitmap, or another menu.
      </summary>
      <remarks>
        Menus provide the highest level of user control within an application.  At the most basic level, a menu is series of items that are displayed in the menu bar (for example, the strings "OpenFile", a question mark bitmap to indicate help, and so on.)  When selected, these items perform an action — for example, open a file, exit the application, or get help.
        The items in a menu bar might also contain a submenu as another type of item.  When creating a submenu, you generally specify a title (this is the text that appears in the menu bar) and the set of items that belong to that submenu (the items are displayed when the title is activated in the menu bar).  For example, a submenu might have the title "File" and items named "Open," "Save," and "Exit."
        Like menus, submenus can contain strings, bitmaps, and other menus.  Using submenus allows you to have multi-dimensional menus.  In addition, just like any menu, they can be created from a resource entity.
        Each item on a menu is identified by a unique ID.  You can then use that ID to refer to the item later in your program (for example, to disable or delete an item).
        Menu commands can be selected with the mouse or with an accelerator key, and can be added, deleted, inserted, and appended as required.
        Items on a menu can be dimmed (or grayed) to indicate that they are disabled, and they can be checked to indicate that they are enabled/selected.  You can also add separators to a menu.  (A separator is a single line inserted between items on a submenu to group similar commands together.)
        A menu is usually associated with an accelerator table that defines shortcuts (like Ctrl+S for File Save) and a toolbar that provides certain buttons issuing commonly used menu commands.  The toolbar and accelerators are usually carried by the menu;  assigning a menu to a window automatically assigns the toolbar and accelerators as well.

        Menus in X# generate the following events — MenuInitEvent, MenuSelectEvent, and MenuCommandEvent.  They are dispatched to the window that owns the menu that generated the event.
        The event handler methods for these events are as follows:
        Window:MenuInit() is called before a menu is displayed.
        Window:MenuSelect() is called when a menu command is highlighted.
        When the user selects a menu command for execution, the window method that matches the menu command's name is called, if any.  If there is no matching method, Window:MenuCommand() is called.  Menu commands are also propagated up the window ownership hierarchy.  For an in depth discussion of how command events are used, refer to the Programmer's Guide.

        In the Windows, menus are normally created in resource entities.  (You can also construct menus dynamically using the Append... or Insert... methods of Menu.)
        For example, in Windows, menus can be created in a resource entity as follows:
        <code language="X#">
          RESOURCE IDM_DEMO MENU
          BEGIN
          POPUP "&amp;File"
          BEGIN
          MENUITEM "&amp;New",			IDMI_NEW
          MENUITEM "&amp;Open...",		IDMI_OPEN
          MENUITEM "&amp;Save",			IDMI_SAVE
          MENUITEM "Save &amp;As...",		IDMI_SAVEAS
          MENUITEM SEPARATOR
          MENUITEM "E&amp;xit",			IDMI_EXIT
          MENUITEM "A&amp;bout Demo...",	IDMI_ABOUT
          END
          END
        </code>
        The easiest way to construct a menu is by using the Menu Editor.  It generates the resource, as illustrated in the example above, as well as the subclass used to instantiate the menu, the accelerator table, and the toolbar.
      </remarks>
    </member>
    <member name="M:VO.Menu.#ctor(XSharp.__Usual)">
      <summary>
        Construct a menu.
      </summary>
      <param name="xResourceID">The resource ID of the menu.  If not specified, the system creates an empty menu.</param>
    </member>
    <member name="P:VO.Menu.Accelerator">
      <summary>
        The accelerator table to be used with this menu.
      </summary>
      <value>The accelerator table to be used with this menu.</value>
      <remarks>
        The accelerator table to be used with this menu.  The Menu Editor generates code that creates an accelerator and assigns it to the menu;
        when the menu is assigned to a window, the corresponding accelerator is assigned also.
      </remarks>
    </member>
    <member name="M:VO.Menu.AddChild(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oMenu">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.Menu.AppendItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Add a string to the end of this menu.
      </summary>
      <param name="nItemID">
        The ID of the new menu item.
      </param>
      <param name="xNewItem">
        One of the following:oBitmap, cNewItem, oHyperLabel, oSubmenu
      </param>
      <remarks>
        &lt;oBitmap&gt;	The bitmap to appear for the new menu item.
        &lt;cNewItem&gt;	The text to appear as the new menu item.
        &lt;oHyperLabel&gt;	The hyperlabel containing the caption to appear as the new menu item.
        &lt;oSubMenu&gt;	The menu to appear for the new menu item.  It is added as a submenu; this is how to construct hierarchical menus.
        <note type="tip">If &lt;nItemID&gt; is specified as MENUSEPARATOR, the second parameter is not needed.</note></remarks>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        After adding a new item to a menu, you must reassign the menu to the owner window's Menu property for the change to take effect.
      </remarks>
    </member>
    <member name="M:VO.Menu.CheckItem(XSharp.__Usual)">
      <summary>
        Place a check mark to the left of a specified menu item.
      </summary>
      <param name="nItemID">The ID of the menu command.</param>
      <returns>
        MF_CHECKED if checked, MF_UNCHECKED if unchecked
      </returns>
      <remarks>
        Placing a check mark next to a menu item indicates its state.  The state of such a command is usually indicated to the user by the check mark, which does or does not appear depending on whether the command is on or off.
        You can later use the Menu:UncheckItem() method to remove the check mark.
        <note type="tip">You can also use this method to check a menu item on a submenu.</note></remarks>
    </member>
    <member name="P:VO.Menu.Children">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.Menu.DeleteChild(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oMenu">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.Menu.DeleteItem(XSharp.__Usual)">
      <summary>
        Delete an item from this menu, removing it from memory.  (To delete a bitmap or string, specify an ID; to delete a submenu, specify the Menu object.)
      </summary>
      <param name="xItemIdOrMenu">The ID of the menu item to be deleted or the submenu to be deleted.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.Menu.Destroy">
      <summary>
        Provide a method to de-instantiate a Menu object.
      </summary>
      <remarks>
        This method can be used when a Menu object is no longer needed.  Menu:Destroy() de-instantiates the Menu object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.Menu.DisableAutoUpdate">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.Menu.DisableItem(XSharp.__Usual)">
      <summary>
        Disable a specified menu item (until a subsequent call to Menu:EnableItem()).
      </summary>
      <param name="nItemID">The ID of the menu item to be disabled.</param>
      <returns>
        A LONG indicating the previous state of the item. If the item does not exist the return value is -1.
      </returns>
      <remarks>
        Disabled menu items are not active and, therefore, they do not send events to their owner windows.  Note that under Windows, a disabled menu command is dimmed.
        <note type="tip">You can also use this method to disable a menu item on a submenu.</note></remarks>
    </member>
    <member name="M:VO.Menu.EnableItem(XSharp.__Usual)">
      <summary>
        Enable a specified menu item that was previously disabled.
      </summary>
      <param name="nItemID">The ID of the menu item to be enabled.</param>
      <returns>
        A LONG indicating the previous state of the item. If the item does not exist the return value is -1.
      </returns>
      <remarks>
        Enabling a menu item allows it to generate events and to send the events to its owner window when the user manipulates the menu command.  The dimming of disabled menu item is removed, and the menu item is restored to its normal appearance.
        By default, menu item are enabled until disabled, so there is no need to call this EnableItem() method unless DisableItem() was previously called.
        <note type="tip">You can also use this method to enable a menu item on a submenu of a menu.</note></remarks>
    </member>
    <member name="M:VO.Menu.GetAutoUpdate">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.Menu.GetSubMenu(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="nIndex">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.Menu.Handle">
      <summary>
        Return the handle for a menu.
      </summary>
      <param name="nHandleType">The type of handle required.  Zero (0) is the only supported option and is the default if &lt;nHandleType&gt; is omitted.</param>
      <returns>
        A handle describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
      </remarks>
    </member>
    <member name="M:VO.Menu.HyperLabel(XSharp.__Usual)">
      <summary>
        Return the hyperlabel attached to the menu item, or NIL if it has none.
      </summary>
      <param name="nItemID">The unique ID of the menu item.</param>
    </member>
    <member name="M:VO.Menu.InsertItem(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Insert a new menu item before a specified menu item.
      </summary>
      <param name="nItemID">The ID of the new menu item or the sub-menu to add (simply another Menu object).  This is how to construct hierarchical menus.</param>
      <param name="xNewItem">
        One of the following:
        &lt;cNewItem&gt;	The caption of the new menu item.
        &lt;oHyperLabel&gt;	The hyperlabel containing the caption to appear as the new menu item.
        &lt;oBitmap&gt;	The bitmap to appear for the new menu item.
      </param>
      <param name="nBeforeID">The ID of the menu item before which the new item should be inserted.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        After inserting a new item to a menu, you must reassign the menu to the owner window's Menu property for the change to take effect.
      </remarks>
    </member>
    <member name="P:VO.Menu.Items">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.Menu.MakeMenuRtol(XSharp.__Usual)">
      <summary>
        Reverse the order of the menu items in a menu.  This is only necessary if you are using an International, bi-directional version of Windows.
      </summary>
      <param name="lRToL">If TRUE, the menu items appear from right to left; if FALSE, they appear from left to right.  If omitted, the default value is TRUE.</param>
      <remarks>
        This method is only functional if you are using an International, bi-directional version of Windows.
      </remarks>
    </member>
    <member name="P:VO.Menu.MenuItems">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.Menu.Name(XSharp.__Usual)">
      <summary>
        Return the name, as a string, stored in the hyperlabel attached to the menu command, or NIL if there is none.
      </summary>
      <param name="nItemID">The ID of the menu item.</param>
    </member>
    <member name="M:VO.Menu.Name(XSharp.__Usual)">
      <summary>
        Return the symbolic name stored in the hyperlabel attached to the menu item, or NIL if there is none.
      </summary>
      <param name="nItemID">The ID of the menu item.</param>
    </member>
    <member name="M:VO.Menu.NameSym(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="nItemID">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.Menu.PostInit">
      <summary>
        Implement customized initialization code for the window.
      </summary>
      <remarks>
        This method is used to customize the initialization code for a dataserver.  
        The customized initialization code will not be overridden by the generated default initialization code.
        A call to PostInit() is automatically generated at the end of the Init() method.
      </remarks>
    </member>
    <member name="M:VO.Menu.PreInit">
      <summary>
        Implement customized initialization code for the server.
      </summary>
      <remarks>
        This method is used to customize the initialization code for a server.  
        The customized initialization code will not be overridden by the generated default initialization code.
        A call to PreInit() is automatically generated at the beginning of the Init() method.  
        The default implementation of PostInit() in this class is empty.
        <note type="tip">
          In .Net it is normally not allowed or recommended to run code in a class before the parent constructor is called.
          The generated code in the Window editor does this (it calls PreInit before the SUPER() call). We advise you to
          be very careful not to touch protected instance variables inherited from parent classes, since these may not be
          initialized and/or values that you assign to them may be overwritten in the constructor of the parent class.
        </note></remarks>
    </member>
    <member name="M:VO.Menu.RegisterItem(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Register the hyperlabel for this menu item.
      </summary>
      <param name="nItemID">The ID of the menu item.</param>
      <param name="oHyperLabel">The hyperlabel to be registered for the menu item.</param>
      <param name="hParentMenu">The handle of the menu item being registered.  This parameter is only required if the registered item contains a submenu.</param>
      <param name="nPosition">
        The offset of menu item being registered.
        The offset of the submenu of the menu item being registered.  (For example, if a menu contains the items 'File', 'Edit', and 'View' and the offset is 1, the Edit submenu will be registered with the Edit menu item.)  This parameter is only required if the registered item contains a submenu.
      </param>
    </member>
    <member name="M:VO.Menu.SetAutoUpdate(XSharp.__Usual)">
      <summary>
        Append a section to a specified submenu on a menu.  This section automatically keeps track of what MDI child windows are currently open and displays their names on the submenu.
      </summary>
      <param name="nMenuNumber">The offset of the submenu to which the new section should be appended.  (For example, if a menu contains the items 'File', 'Edit' and 'View' and the offset is 1, the new section is appended to the 'Edit' submenu.)  The default is 0 (the first menu item).</param>
      <remarks>
        In MDI applications, there is typically one menu which contains the titles of any currently open MDI child windows.
        After updating a new section, you must reassign the menu to the owner window's Menu property for the change to take effect.
      </remarks>
    </member>
    <member name="M:VO.Menu.SetParent(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oMenu">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.Menu.ShowAsPopup(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Display menu as a local pop-up menu.
      </summary>
      <param name="oOwner">The window that owns the local pop-up menu.</param>
      <param name="oPoint">The point, relative to the client area, at which to display the menu.  If omitted, the menu is displayed at the current mouse cursor position.</param>
      <param name="kButton">The button constant that indicates which button the menu will track.  Values can be PM_LEFTBUTTON and PM_RIGHTBUTTON.  If omitted, the menu tracks the left mouse button.</param>
      <param name="kAlignment">The alignment constant that indicates how the menu will be aligned with respect to the display position of the menu.  Values can be PM_ALIGNCENTER, PM_ALIGNLEFT, and PM_ALIGNRIGHT.  If omitted, the menu is aligned to the left of the display position.</param>
      <param name="oNotOverlap">** missing parameter documentation **</param>
      <returns>
        TRUE if the menu was displayed successfully; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.Menu.ToolBar">
      <summary>
        The toolbar that corresponds to the menu.
      </summary>
      <value>The toolbar that corresponds to the menu.</value>
      <remarks>
        The toolbar that corresponds to the menu.  The Menu Editor generates code that creates a toolbar and assigns it to the menu; when the menu is assigned to a window, the corresponding toolbar is assigned also.
      </remarks>
    </member>
    <member name="M:VO.Menu.UncheckItem(XSharp.__Usual)">
      <summary>
        Remove the check mark (that the user sees) from the menu item.  Typically, you do this in response to a MenuCommandEvent on that item.
      </summary>
      <param name="nItemID">The ID of the menu item.</param>
      <returns>
        TRUE if removed successfully; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.Menu.UnregisterItem(XSharp.__Usual)">
      <summary>
        Unregister the hyperlabel for this menu item.
      </summary>
      <param name="nItemID">The ID of the menu item.</param>
    </member>
    <member name="T:VO.MenuCommandEvent">
      <summary>
        Provide information about a MenuCommandEvent, generated when the user executes a menu item, either directly or through the use of accelerator keys.
      </summary>
      <remarks>
        MenuCommandEvent events are passed to Window:MenuCommand(), which dispatches the method indicated in the menu item's hyperlabel.
      </remarks>
    </member>
    <member name="M:VO.MenuCommandEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.MenuCommandEvent.AsString">
      <summary>
        Return the caption of the selected menu item.
      </summary>
      <remarks>
        The caption is provided by the menu item resource.
      </remarks>
    </member>
    <member name="P:VO.MenuCommandEvent.HyperLabel">
      <summary>
        The hyperlabel connected to the menu item that generated this MenuCommandEvent.
      </summary>
      <value>The hyperlabel connected to the menu item that generated this MenuCommandEvent.</value>
      <remarks>
        The hyperlabel connected to the menu item that generated this MenuCommandEvent.  From the hyperlabel, you can retrieve additional information about the menu item.
      </remarks>
    </member>
    <member name="P:VO.MenuCommandEvent.ItemID">
      <summary>
        A numeric value representing the ID of the menu item that generated this MenuCommandEvent.
      </summary>
      <value>A numeric value representing the ID of the menu item that generated this MenuCommandEvent.</value>
    </member>
    <member name="P:VO.MenuCommandEvent.Menu">
      <summary>
        The Menu object that generated this MenuCommandEvent.
      </summary>
      <value>The Menu object that generated this MenuCommandEvent.</value>
    </member>
    <member name="P:VO.MenuCommandEvent.Name">
      <summary>
        A string representing the name stored in the hyperlabel of the menu item that generated this MenuCommandEvent.
      </summary>
      <value>A string representing the name stored in the hyperlabel of the menu item that generated this MenuCommandEvent.</value>
    </member>
    <member name="P:VO.MenuCommandEvent.NameSym">
      <summary>
        A symbol representing the name stored in the hyperlabel of the menu item that generated this MenuCommandEvent.
      </summary>
      <value>A symbol representing the name stored in the hyperlabel of the menu item that generated this MenuCommandEvent.</value>
    </member>
    <member name="T:VO.MenuInitEvent">
      <summary>
        Provide information about a MenuInitEvent, generated when the user first activates a menu for the first time.
      </summary>
      <remarks>
        The system generates MenuInitEvent objects before displaying a pull-down menu, allowing the application to initialize items before they are displayed.  For example, you can want to dim items that the program is not yet in a position to handle, or you may want to check or uncheck certain items.  MenuInitEvent events are passed to Window:MenuInit().
        If you change the menu using the Menu access, you do not need to call the window's Menu assign.  When the menu is displayed, it is the modified version.
        Accelerator keys generate MenuInitEvent events if the accelerator invokes a submenu.
      </remarks>
    </member>
    <member name="M:VO.MenuInitEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.MenuInitEvent.Menu">
      <summary>
        The Menu object that generated this MenuInitEvent (and is about to be displayed for initialization).
      </summary>
      <value>The Menu object that generated this MenuInitEvent (and is about to be displayed for initialization).</value>
    </member>
    <member name="T:VO.MenuSelectEvent">
      <summary>
        Provide information about a MenuSelectEvent, generated whenever a menu item is highlighted on a menu (menu items are highlighted as the user moves either the mouse or the highlight bar up or down a menu).
      </summary>
      <remarks>
        MenuSelectEvent events enable the program to anticipate that the user can activate an item or to provide status information.
        <note type="tip">When a menu item is actually selected (and therefore executed), the system generates a MenuCommandEvent.</note>
        When an accelerator key is executed, a MenuSelectEvent, immediately followed by a MenuCommandEvent, is generated to simulate the mouse route — the various selections that you have to pass over to choose the option.  (Thus, the accelerator generates the same event as those generated with a mouse.)
      </remarks>
      <example>
        The following example prints a different help line in the status bar, depending on which command is currently selected:
        <code language="X#">
          CLASS MyWindow INHERIT TopAppWindow
          METHOD MenuSelect(oMSE) CLASS MyWindow
          LOCAL j := oMSE:ItemID
          DO CASE
          CASE j = IDMI_RED
          TextPrint("Select the Red Pen", Point{10,10})
          CASE j = IDMI_GREEN
          TextPrint("Select the Green Pen", Point{10,10})
          CASE j = IDMI_BLUE
          TextPrint("Select the Blue Pen", Point{10,10})
          ENDCASE
        </code></example>
    </member>
    <member name="M:VO.MenuSelectEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.MenuSelectEvent.AsString">
      <summary>
        Return the caption of the selected menu item.
      </summary>
      <remarks>
        The caption is provided by the menu item resource.
      </remarks>
    </member>
    <member name="P:VO.MenuSelectEvent.HyperLabel">
      <summary>
        The hyperlabel connected to the menu that generated this MenuSelectEvent.  From the hyperlabel, you can retrieve additional information about the menu.
      </summary>
      <value>The hyperlabel connected to the menu that generated this MenuSelectEvent.  From the hyperlabel, you can retrieve additional information about the menu.</value>
    </member>
    <member name="P:VO.MenuSelectEvent.ItemID">
      <summary>
        A numeric value representing the ID of the menu item that generated this MenuSelectEvent.
      </summary>
      <value>A numeric value representing the ID of the menu item that generated this MenuSelectEvent.</value>
    </member>
    <member name="P:VO.MenuSelectEvent.Menu">
      <summary>
        The Menu object that generated this MenuSelectEvent.
      </summary>
      <value>The Menu object that generated this MenuSelectEvent.</value>
    </member>
    <member name="P:VO.MenuSelectEvent.Name">
      <summary>
        A string representing the name stored in the hyperlabel of the menu items that generated this MenuSelectEvent.
      </summary>
      <value>A string representing the name stored in the hyperlabel of the menu items that generated this MenuSelectEvent.</value>
    </member>
    <member name="P:VO.MenuSelectEvent.NameSym">
      <summary>
        A symbol representing the name stored in the hyperlabel of the menu items that generated this MenuSelectEvent.
      </summary>
      <value>A symbol representing the name stored in the hyperlabel of the menu items that generated this MenuSelectEvent.</value>
    </member>
    <member name="T:VO.MinMaxInfoEvent">
      <summary>
        Provide information about a MinMaxInfoEvent, generated whenever the size or position of a window is about to change. The MinMaxInfoEvent object describes the maximised width, height and position of the maximised window in addition to the minimum and maximum height and width of the window.
      </summary>
      <remarks>
        The MinMaxInfoEvent event contains information about the size and placement of a window. It also allows these default values to be overridden by assigning new values.
      </remarks>
    </member>
    <member name="M:VO.MinMaxInfoEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.MinMaxInfoEvent.MaxPosition">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.MinMaxInfoEvent.MaxSize">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.MinMaxInfoEvent.MaxTrackSize">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.MinMaxInfoEvent.MinTrackSize">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.ModelessDialog">
      <summary>
        Create a modeless dialog window (also commonly referred to as a dialog box), which are used to present a collection of controls for user input and output.
      </summary>
    </member>
    <member name="M:VO.ModelessDialog.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Create a modeless dialog box.
      </summary>
      <param name="oOwner">The window that owns the modeless dialog box.</param>
      <param name="xResourceID">The resource ID of the modeless dialog box.</param>
    </member>
    <member name="M:VO.ModelessDialog.Destroy">
      <summary>
        Provide a method to de-instantiate a ModelessDialog object.
      </summary>
      <remarks>
        This method can be used when a ModelessDialog object is no longer needed.  ModelessDialog:Destroy() de-instantiates the ModelessDialog object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="T:VO.MoneyFS">
      <summary>
        Create a money field specification, which holds money data type information.
      </summary>
    </member>
    <member name="M:VO.MoneyFS.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a money field specification.
      </summary>
      <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new money field specification.</param>
      <param name="uLength">The length of the field.  If not specified, the default is 12.</param>
      <param name="uDecimals">The number of decimals in the field.  If not specified, the default is 2.</param>
    </member>
    <member name="T:VO.MonthCalendar">
      <summary>
        Encapsulate a standalone MonthCalendar control.
      </summary>
      <remarks>
        The MonthCalendar control displays a month calendar allowing the user to browse through months and to select a specific date.
        <note type="tip">Version 4.70 or higher of COMCTL32.DLL is needed to use the MonthCalendar control.</note></remarks>
    </member>
    <member name="M:VO.MonthCalendar.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a MonthCalendar object.
      </summary>
      <param name="oOwner">The window that owns the MonthCalendar object.</param>
      <param name="xID">The unique ID for the MonthCalendar object (between 1 and 8000).</param>
      <param name="oPoint">The origin of the MonthCalendar object in canvas coordinates.</param>
      <param name="oDimension">The dimension of the MonthCalendar object in canvas coordinates.</param>
      <param name="dwStyle">
        Constant representing the style of the MonthCalendar object, specified either by a X# style constant or a Windows API style constant.  Styles can be combined using the _Or() operator.
      </param>
      <param name="lDataAware">A logical value that is TRUE if the MonthCalendar object is data-aware; otherwise, FALSE.  The default is TRUE.</param>
      <param name="nResourceID">The resource ID of the MonthCalendar object.</param>
      <remarks>
        <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular style constant.</note>
      </remarks>
    </member>
    <member name="P:VO.MonthCalendar.BackgroundColor">
      <summary>
        A Color object describing the background color (between the months) of the MonthCalendar control.
      </summary>
      <value>A Color object describing the background color (between the months) of the MonthCalendar control.</value>
    </member>
    <member name="M:VO.MonthCalendar.Dispatch(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.MonthCalendar.FirstDayOfWeek">
      <summary>
        An integer specifying the first day of the week (Monday=0, Tuesday=1, etc.).
      </summary>
      <value>An integer specifying the first day of the week (Monday=0, Tuesday=1, etc.).</value>
    </member>
    <member name="P:VO.MonthCalendar.MaxSelCount">
      <summary>
        The maximum number of days that can be selected in the MonthCalendar control.
      </summary>
      <value>The maximum number of days that can be selected in the MonthCalendar control.</value>
      <remarks>
        The maximum number of days that can be selected in the MonthCalendar control.
        <note type="tip">This property is only valid for MonthCalendar controls that have the MultiSelect style (MCS_MULTISELECT) turned on.</note></remarks>
    </member>
    <member name="P:VO.MonthCalendar.MonthBackgroundColor">
      <summary>
        A Color object describing the background color (within the month area) of the MonthCalendar control.
      </summary>
      <value>A Color object describing the background color (within the month area) of the MonthCalendar control.</value>
    </member>
    <member name="P:VO.MonthCalendar.MonthDelta">
      <summary>
        The number of months the control scrolls when the user clicks the scroll button.
      </summary>
      <value>The number of months the control scrolls when the user clicks the scroll button.</value>
    </member>
    <member name="P:VO.MonthCalendar.Range">
      <summary>
        A DateRange object setting the minimum and maximum allowable dates for the MonthCalendar control.
      </summary>
      <value>A DateRange object setting the minimum and maximum allowable dates for the MonthCalendar control.</value>
    </member>
    <member name="P:VO.MonthCalendar.Selection">
      <summary>
        The currently selected date.  In the case of a multiple selection, the starting date is returned.
      </summary>
      <value>The currently selected date.  In the case of a multiple selection, the starting date is returned.</value>
    </member>
    <member name="P:VO.MonthCalendar.SelectionRange">
      <summary>
        A DateRange object representing the currently selected date range.
      </summary>
      <value>A DateRange object representing the currently selected date range.</value>
    </member>
    <member name="P:VO.MonthCalendar.TextColor">
      <summary>
        A Color object specifying the text color of the MonthCalendar control.
      </summary>
      <value>A Color object specifying the text color of the MonthCalendar control.</value>
    </member>
    <member name="P:VO.MonthCalendar.TextValue">
      <summary>
        The current date selection in string format.
      </summary>
      <value>The current date selection in string format.</value>
      <remarks>
        The current date selection in string format.  This is needed internally to allow the binding of a MonthCalendar control to a database field.
      </remarks>
    </member>
    <member name="P:VO.MonthCalendar.TitleBackgroundColor">
      <summary>
        A Color object specifying the title background color of the MonthCalendar control.
      </summary>
      <value>A Color object specifying the title background color of the MonthCalendar control.</value>
    </member>
    <member name="P:VO.MonthCalendar.TitleTextColor">
      <summary>
        A Color object specifying the title text color of the MonthCalendar control.
      </summary>
      <value>A Color object specifying the title text color of the MonthCalendar control.</value>
    </member>
    <member name="P:VO.MonthCalendar.Today">
      <summary>
        The date specified as "today" for the MonthCalendar control.
      </summary>
      <value>The date specified as "today" for the MonthCalendar control.</value>
    </member>
    <member name="P:VO.MonthCalendar.TrailingTextColor">
      <summary>
        A Color object describing the color of the trailing and leading days, i.e., those not belonging to the current month, of the MonthCalendar control.
      </summary>
      <value>A Color object describing the color of the trailing and leading days, i.e., those not belonging to the current month, of the MonthCalendar control.</value>
    </member>
    <member name="P:VO.MonthCalendar.Value">
      <summary>
        The currently selected date.
      </summary>
      <value>The currently selected date.</value>
    </member>
    <member name="T:VO.MonthCalSelectionEvent">
      <summary>
        Provide information about a monthcalendar selection event, which is generated when a user selects a date in a MonthCalendar control.
      </summary>
      <remarks>
        This event occurs when a date is selected in a MonthCalendar control

      </remarks>
    </member>
    <member name="M:VO.MonthCalSelectionEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.MonthCalSelectionEvent.Explicit">
      <summary>
        A Logic value indicating when the user made an explicit date selection within a month calendar control
      </summary>
      <value>A Logic value indicating when the user made an explicit date selection within a month calendar control</value>
    </member>
    <member name="P:VO.MonthCalSelectionEvent.Selection">
      <summary>
        A date value indicating the date the user selected in the control
      </summary>
      <value>A date value indicating the date the user selected in the control</value>
    </member>
    <member name="T:VO.MouseEvent">
      <summary>
        Provide information about the location of the mouse, as well as which mouse button was pressed, when a MouseEvent occurred.
      </summary>
      <remarks>
        MouseEvent events are passed to the following event handlers of class Window:  MouseButtonDown(), MouseButtonUp(), MouseButtonDoubleClick(), MouseMove(), and MouseDrag().
      </remarks>
    </member>
    <member name="M:VO.MouseEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.MouseEvent.ButtonID">
      <summary>
        One of the following constants indicating the mouse button the user pressed when a MouseEvent was generated:
      </summary>
      <value>One of the following constants indicating the mouse button the user pressed when a MouseEvent was generated:</value>
      <remarks>
        One of the following constants indicating the mouse button the user pressed when a MouseEvent was generated:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>BUTTONCONTROL</term><description>The Control key on the keyboard was being used.</description></item><item><term>BUTTONLEFT</term><description>The left mouse button was being used.</description></item><item><term>BUTTONMIDDLE</term><description>The middle mouse button was being used.</description></item><item><term>BUTTONRIGHT</term><description>The right mouse button was being used.</description></item><item><term>BUTTONSHIFT</term><description>The Shift key on the keyboard was being pressed.</description></item><item><term>BUTTONX1</term><description>The ButtonX1 on a five button mouse was being used.</description></item><item><term>BUTTONX2</term><description>The ButtonX2 on a five button mouse was being used.</description></item></list>
        The MouseEvent:ButtonID access method does not work in Window:MouseDrag() event handlers if the user presses more than one mouse button simultaneously.  To handle with multiple buttons, invoke the methods of MouseEvent (like IsLeftButton() and IsRightButton()), which report on individual buttons.
      </remarks>
    </member>
    <member name="P:VO.MouseEvent.Height">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.MouseEvent.IsControlButton">
      <summary>
        A logical value indicating whether the user pressed the Control key when a MouseEvent was generated.
      </summary>
      <value>A logical value indicating whether the user pressed the Control key when a MouseEvent was generated.</value>
      <remarks>
        A logical value indicating whether the user pressed the Control key when a MouseEvent was generated.  If yes, TRUE is returned; otherwise, FALSE.
      </remarks>
    </member>
    <member name="P:VO.MouseEvent.IsLeftButton">
      <summary>
        A logical value indicating whether the user pressed the left mouse button when a MouseEvent was generated.
      </summary>
      <value>A logical value indicating whether the user pressed the left mouse button when a MouseEvent was generated.</value>
      <remarks>
        A logical value indicating whether the user pressed the left mouse button when a MouseEvent was generated.  If yes, TRUE is returned; otherwise, FALSE.
      </remarks>
    </member>
    <member name="P:VO.MouseEvent.IsMiddleButton">
      <summary>
        A logical value indicating whether the user pressed the middle mouse button when a MouseEvent was generated.
      </summary>
      <value>A logical value indicating whether the user pressed the middle mouse button when a MouseEvent was generated.</value>
      <remarks>
        A logical value indicating whether the user pressed the middle mouse button when a MouseEvent was generated.  If yes, TRUE is returned; otherwise, FALSE.
      </remarks>
    </member>
    <member name="P:VO.MouseEvent.IsRightButton">
      <summary>
        A logical value indicating whether the user pressed the right mouse button when a MouseEvent was generated.
      </summary>
      <value>A logical value indicating whether the user pressed the right mouse button when a MouseEvent was generated.</value>
      <remarks>
        A logical value indicating whether the user pressed the right mouse button when a MouseEvent was generated.  If yes, TRUE is returned; otherwise, FALSE.
      </remarks>
    </member>
    <member name="P:VO.MouseEvent.IsShiftButton">
      <summary>
        A logical value indicating whether the user pressed the Shift key when a MouseEvent was generated.
      </summary>
      <value>A logical value indicating whether the user pressed the Shift key when a MouseEvent was generated.</value>
      <remarks>
        A logical value determining whether the user pressed the Shift key when a MouseEvent was generated.  If yes, TRUE is returned; otherwise, FALSE
      </remarks>
    </member>
    <member name="P:VO.MouseEvent.IsXButton1">
      <summary>
        A logical value determining whether the user pressed the XButton1 causing the MouseEvent to be generated.
      </summary>
      <value>A logical value determining whether the user pressed the XButton1 causing the MouseEvent to be generated.</value>
      <remarks>
        Five button mice have Left, Middle, Right, XButton1and XButton2.
        A logical value determining whether the user pressed the XButton1 causing the MouseEvent to be generated.  If yes, TRUE is returned; otherwise, FALSE
      </remarks>
    </member>
    <member name="P:VO.MouseEvent.IsXButton2">
      <summary>
        A logical value determining whether the user pressed the XButton2 causing the MouseEvent to be generated.
      </summary>
      <value>A logical value determining whether the user pressed the XButton2 causing the MouseEvent to be generated.</value>
      <remarks>
        Five button mice have Left, Middle, Right, XButton1and XButton2.
        A logical value determining whether the user pressed the XButton2 causing the MouseEvent to be generated.  If yes, TRUE is returned; otherwise, FALSE
      </remarks>
    </member>
    <member name="P:VO.MouseEvent.Position">
      <summary>
        A point, in canvas coordinates, representing the position of the mouse pointer on the window when this MouseEvent was generated.
      </summary>
      <value>A point, in canvas coordinates, representing the position of the mouse pointer on the window when this MouseEvent was generated.</value>
    </member>
    <member name="P:VO.MouseEvent.Size">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.MouseEvent.Width">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.MoveEvent">
      <summary>
        Provide information about a MoveEvent, used to notify the program that the user is in the process of moving a window.
      </summary>
      <remarks>
        MoveEvent events are generated when the user or a program moves a window around on the screen.  MoveEvent events are passed to Window:Move().
        Although most programs are not interested in MoveEvent events; although it would be rather unusual behavior, a program might wish to anchor the window in some specific area of the screen, for instance.
      </remarks>
    </member>
    <member name="M:VO.MoveEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.MoveEvent.Origin">
      <summary>
        A point representing the new location of a window after a MoveEvent was generated.
      </summary>
      <value>A point representing the new location of a window after a MoveEvent was generated.</value>
      <remarks>
        A point representing the new location of a window after a MoveEvent was generated.
        For top application windows and shell windows, the point is given in desktop coordinates.  For all other windows, it is given in the owner window's canvas coordinates.  In this sense, the desktop owns the top window.
      </remarks>
    </member>
    <member name="T:VO.MultiLineEdit">
      <summary>
        Create a multiline edit control for displaying and entering information to a variable or field in a server.  Multiline edit controls may be bound to a data server field of any type (character, date, logical, numeric, or memo).
      </summary>
      <remarks>
        Some of the features provided by multiline edit controls include scrolling lines and pages and retrieving specified lines (in addition to the simple editing primitives inherited from the Edit class).
      </remarks>
      <example>
        This example creates and initializes a multiline edit control:
        <code language="X#">
          CLASS MyWindow INHERIT TopAppWindow
          HIDDEN oMyMLE AS OBJECT
          METHOD Init() CLASS MyWindow
          SUPER:Init()
          p := Point{10, 10}
          d := Dimension{100, 100}
          oMyMLE := MultiLineEdit{SELF,100,p,d}
          SELF:Show()
          oMyMLE:Show()
          oMyMLE:TextValue := "New York" + _CHR(10) + "Boston"
        </code>

        In Windows, multiline edit controls are equivalent to an edit control created with the ES_MULTILINE style.  These are normally specified in the resource entity like this:
        <code language="X#">
          RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 80
          STYLE WS_POPUP | WS_DLGFRAME
          BEGIN
          EDITTEXT	IDE_TEXT,10,10,90,45, ES_MULTILINE
          DEFPUSHBUTTON "OK"	 IDB_OK,64,60,32,14, WS_GROUP
          END
        </code></example>
    </member>
    <member name="M:VO.MultiLineEdit.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a multiline edit control.
      </summary>
      <param name="oOwner">The window that owns the multiline edit control.</param>
      <param name="xID">The unique ID of the multiline edit control (between 1 and 8000).</param>
      <param name="oPoint">The origin of the multiline edit control in canvas coordinates.</param>
      <param name="oDimension">The dimension of the multiline edit control in canvas coordinates.</param>
      <param name="kStyle">The style of the multiline edit control, specified as one of the following constants listed below.</param>
      <param name="nResourceID">The resource ID of the multiline edit control.</param>
      <remarks>
        <pre>
          Constant	Windows API Constant
          EDITAUTOHSCROLL	ES_AUTOHSCROLL
          EDITAUTOVSCROLL	ES_AUTOVSCROLL
          EDITBORDERED	WS_BORDER
          EDITCENTER	ES_CENTER
          EDITLEFT	ES_LEFT
          EDITLOWERCASE	ES_LOWERCASE
          EDITMULTILINE	ES_MULTILINE
          EDITNOHIDESEL	ES_NOHIDESEL
          EDITOEMCONVERT	ES_OEMCONVERT
          EDITPASSWORD	ES_PASSWORD
          EDITREADONLY	ES_READONLY
          EDITRIGHT	ES_RIGHT
          EDITUPPERCASE	ES_UPPERCASE
          EDITWANTRETURN	ES_WANTRETURN
        </pre>
      </remarks>
    </member>
    <member name="P:VO.MultiLineEdit.CurrentText">
      <summary>
        A string representing the text currently appearing in the edit box.  The MultiLineEdit:CurrentText assign also changes the MultiLineEdit:TextValue and MultiLineEdit:Value when the focus shifts to another control.
      </summary>
      <value>A string representing the text currently appearing in the edit box.  The MultiLineEdit:CurrentText assign also changes the MultiLineEdit:TextValue and MultiLineEdit:Value when the focus shifts to another control.</value>
    </member>
    <member name="M:VO.MultiLineEdit.Destroy">
      <summary>
        Provide a method to de-instantiate a MultiLineEdit object.
      </summary>
      <remarks>
        This method can be used when a MultiLineEdit object is no longer needed.  MultiLineEdit:Destroy() de-instantiates the MultiLineEdit object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.MultiLineEdit.Dispatch(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.MultiLineEdit.GetLine(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Get a line of text — specified by position — in a multiline edit control.
      </summary>
      <param name="nLineNumber">
        The position in the multiline edit control at which the desired string is located.  Specify one of the following values:
        Value	Position
        0	The current line in the multiline edit control (that is, the line currently containing the text cursor).  This is the default.
        1	The first line in the multiline edit control.
        n	The nth line in the multiline edit control.
      </param>
      <param name="nMaxLength">The maximum number of characters to extract from the specified line.  The default is to return the entire line, including any actual blanks in the text but excluding any blanks displayed due to word-wrapping.</param>
      <returns>
        The text of the specified line.
      </returns>
    </member>
    <member name="M:VO.MultiLineEdit.GetLineLength(XSharp.__Usual)">
      <summary>
        Get the length of a line of text — specified by position — in a multiline edit control.
      </summary>
      <param name="nLineNumber">
        The position in the multiline edit control at which the desired string is located.  Specify one of the following values:
        Value	Position
        0	The current line in the multiline edit control (that is, the line currently containing the text cursor).  This is the default.
        1	The first line in the multiline edit control.
        n	The nth line in the multiline edit control.
      </param>
      <returns>
        The length of the specified line.
      </returns>
    </member>
    <member name="P:VO.MultiLineEdit.LineCount">
      <summary>
        A numeric value representing the number of lines in a multiline edit control.
      </summary>
      <value>A numeric value representing the number of lines in a multiline edit control.</value>
    </member>
    <member name="M:VO.MultiLineEdit.LineDown">
      <summary>
        Move the cursor from its current position in a multiline edit control down a single line.
      </summary>
    </member>
    <member name="M:VO.MultiLineEdit.LineUp">
      <summary>
        Move the cursor from its current position in a multiline edit control up a single line.
      </summary>
    </member>
    <member name="M:VO.MultiLineEdit.PageDown">
      <summary>
        Move the cursor from its current position in a multiline edit control down a single page length.
      </summary>
      <remarks>
        A page is the number of lines that fits in the current multiline edit control in the current font.
      </remarks>
    </member>
    <member name="M:VO.MultiLineEdit.PageUp">
      <summary>
        Move the cursor from its current position in a multiline edit control up a single page length.
      </summary>
      <remarks>
        A page is the number of lines that fits in the current multiline edit control in the current font.
      </remarks>
    </member>
    <member name="M:VO.MultiLineEdit.ScrollHorizontal(XSharp.__Usual)">
      <summary>
        Scroll the text in a multiline edit control a specified number of characters to the right or left.
      </summary>
      <param name="nChars">The number of characters to scroll.  Positive values move the cursor to the right; negative values to the left.  The default is no movement.</param>
    </member>
    <member name="M:VO.MultiLineEdit.ScrollVertical(XSharp.__Usual)">
      <summary>
        Scroll the text in a multiline edit control a specified number of characters up or down.
      </summary>
      <param name="nLines">The number of lines to scroll.  Positive values move the cursor up; negative values down.  The default is no movement, or zero (0) lines.</param>
    </member>
    <member name="P:VO.MultiLineEdit.Value">
      <summary>
        MultiLineEdit:Value contains the text stored after the previous edit operation.  The MultiLineEdit:TextValue assign also changes the MultiLineEdit:CurrentText, MultiLineEdit:TextValue, and MultiLineEdit:ValueChanged.
      </summary>
      <value>MultiLineEdit:Value contains the text stored after the previous edit operation.  The MultiLineEdit:TextValue assign also changes the MultiLineEdit:CurrentText, MultiLineEdit:TextValue, and MultiLineEdit:ValueChanged.</value>
    </member>
    <member name="T:VO.MultiMediaContainer">
      <summary>
        Implement a container window for displaying multimedia data.
      </summary>
      <remarks>
        The MultiMediaContainer class displays a child window that is capable of displaying various types of multimedia data, such as bitmaps, video, and audio files.  MultiMediaContainer objects can be used data-bound, displaying multimedia data from a database, such as Jasmine.  They can also be used standalone.
      </remarks>
    </member>
    <member name="M:VO.MultiMediaContainer.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Instantiate a MultiMediaContainer control.
      </summary>
      <param name="oOwner">The window that owns the control.</param>
      <param name="xID">The unique ID of the control (between 1 and 8000).</param>
      <param name="oPoint">The origin of the control in canvas coordinates.</param>
      <param name="oDimension">The dimension of the control in canvas coordinates.</param>
      <param name="nResourceID">The resource ID of the control.</param>
      <remarks>
        This method instantiates a MultiMediaContainer object.  Depending on the file assigned to it, the MultiMediaContainer object tries to display the multimedia data.  In the case of video or audio data, it creates an MCI child window.  For images, X# image support attempts to display the image in the control's client area.
      </remarks>
    </member>
    <member name="M:VO.MultiMediaContainer.Destroy">
      <summary>
        Provide a method to de-instantiate a MultiMediaContainer object.
      </summary>
      <remarks>
        This method can be used when a MultiMediaContainer object is no longer needed.  MultiMediaContainer:Destroy() de-instantiates the MultiMediaContainer object, and allows you to close and free any resources that were opened or created by the object without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.MultiMediaContainer.Dispatch(XSharp.__Usual)">
      <summary>
        Provide the prototype dispatcher for events within the system when the control has focus, routing various events to their appropriate event handlers.
        <br />Important!  This is a callback method used by X#.
      </summary>
      <param name="oEvent">The event to be handled.</param>
      <seealso cref="T:VO.Event" />
      <returns>
        A numeric value representing the event handler that handled the event.
      </returns>
      <remarks>
        MultiMediaContainer:Dispatch() serves as an internal callback method, dispatching events to various event handlers.  It should never be necessary to call this method directly.  Instead you should write your own Dispatch() method for derived classes, if you want to handle additional events.  Usually the derived class Dispatch() method should call SUPER:Dispatch() to support the inherited event handling.
      </remarks>
    </member>
    <member name="P:VO.MultiMediaContainer.FileName">
      <summary>
        The name of the file containing the multimedia data as a string.  Major and minor MIME types are derived from the file extension.
      </summary>
      <value>The name of the file containing the multimedia data as a string.  Major and minor MIME types are derived from the file extension.</value>
    </member>
    <member name="P:VO.MultiMediaContainer.MajorType">
      <summary>
        The major MIME type of the current multimedia file, e.g., "image".
      </summary>
      <value>The major MIME type of the current multimedia file, e.g., "image".</value>
    </member>
    <member name="M:VO.MultiMediaContainer.MCISendMessage(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Send an MCIWNDM_XXX message to the contained MCI window.
      </summary>
      <param name="dwMsg">The message ID.</param>
      <param name="wParam">The first SendMessage parameter as DWORD.  The default is 0.</param>
      <param name="lParam">The second SendMessage parameter as LONG.  The default is 0.</param>
      <returns>
        The result value (as LONG).
      </returns>
      <remarks>
        If the associated file contains video or audio information (for example, an .AVI or .WAV file), the MultiMediaContainer class creates an MCI window.  Using the MCISendMessage() method, you can send any of the MCIWNDM_XXX messages documented in the Win32 SDK help to this window.  Using these messages, you can programmatically change the look and behavior of the window, play the multimedia data, etc.
        <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about MCIWNDM_XXX messages and commands.</note></remarks>
      <example>
        This code snippet starts the playback of a video or audio file:
        <code language="X#">oDCMM:MCISendMessage(MCIWNDM_PLAYFROM)</code>
        This code snippet advances the data step by step:
        <code language="X#">oDCMM:MCISendMessage(MCI_STEP, 0, 1)</code>
        This code snippet removes the toolbar from the window:
        <code language="X#">
          oDCMM:MCISendMessage(MCIWNDM_CHANGESTYLES, MCIWNDF_NOPLAYBAR, ;
          MCIWNDF_NOPLAYBAR)
        </code></example>
    </member>
    <member name="P:VO.MultiMediaContainer.MinorType">
      <summary>
        The minor MIME type of the current multimedia file, e.g., "x-msvideo".
      </summary>
      <value>The minor MIME type of the current multimedia file, e.g., "x-msvideo".</value>
    </member>
    <member name="P:VO.MultiMediaContainer.Size">
      <summary>
        A Dimension object defining the size of the control.
      </summary>
      <value>A Dimension object defining the size of the control.</value>
    </member>
    <member name="T:VO.NamedArg">
      <summary>
        Provide a class to support OLE named arguments.
      </summary>
      <remarks>
        OLE supports the concept of named arguments.  On method invocation, an argument name that is defined by the OLE automation server can be attached to the actual parameter value.  This allows you to pass parameters in any order and to omit parameters because the server can uniquely identify the parameters using their names.  The NamedArg class is used to model this way of parameter passing.
      </remarks>
      <example>
        The following example shows how Named Arguments are used to simplify calling the PrintOut method of the Word.Application class that has lots of arguments.
        <code language="X#">
          FUNCTION Start
          LOCAL oApp AS OBJECT
          LOCAL oDocs	AS OBJECT
          LOCAL oDoc	AS OBJECT
          ?
          oApp  OleAutoObject{}
          oAppVisible  TRUE
          oDocs  oAppDocuments
          ?
          oDoc  oDocsOpen
          ?
          oAppPrintOutNamedArg{#Background TRUE} ;
          NamedArg{#PrintToFile TRUE} ;
          NamedArg{#OutputFileName “C}
          DO WHILE oAppBackgroundPrintingStatus  
          ?
          DoEvents
          ENDDO
          ?
          oDocCloseFALSE
          oAppQuit
          wait  
        </code><code language="X#">RETURN NIL</code></example>
    </member>
    <member name="M:VO.NamedArg.#ctor">
      <summary>
        Construct a NamedArg object.
      </summary>
      <param name="symArgName">A symbol representing the OLE argument name.</param>
      <param name="uValue">The value of the specified argument.</param>
      <example>
        This example shows how to pass only the Point parameter to the FormatFont() method, which otherwise takes more than 15 parameters:
        <code language="X#">
          LOCAL o AS OLEAutoObject
          o: = OLEAutoObject{"Word.Basic"}
          o:FormatFont(NamedArg{#Points, 18})
        </code></example>
    </member>
    <member name="P:VO.NamedArg.ArgName">
      <summary>
        A symbol representing the name of a named argument.
      </summary>
      <value>A symbol representing the name of a named argument.</value>
    </member>
    <member name="P:VO.NamedArg.Value">
      <summary>
        The value of a named argument.
      </summary>
      <value>The value of a named argument.</value>
    </member>
    <member name="T:VO.NumberFS">
      <summary>
        Create a number field specification, which holds numeric data type information.
      </summary>
    </member>
    <member name="M:VO.NumberFS.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a numeric field specification.
      </summary>
      <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new number field specification.</param>
      <param name="uLength">The length of the field.  If not specified, the default is 12.</param>
      <param name="uDecimals">The number of decimals in the field.  If not specified, the default is 2.</param>
    </member>
    <member name="T:VO.ObjCodeBlock">
      <exclude />
    </member>
    <member name="M:VO.ObjCodeBlock.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <exclude />
    </member>
    <member name="M:VO.ObjCodeBlock.Eval(XSharp.__Usual)">
      <exclude />
    </member>
    <member name="T:VO.OLEAppDocStorage">
      <summary>
        Provide an encapsulation of an Application Doc File storage for an OLE object.
      </summary>
      <remarks>
        Whenever an OLEObject is inserted into a form inside the Window Editor, the OLE object's persistent information is stored in an Application Doc File.  The OLEAppDocStorage class encapsulates an Application Doc File.
      </remarks>
    </member>
    <member name="M:VO.OLEAppDocStorage.#ctor">
      <summary>
        Construct an OLEAppDocStorage object.
      </summary>
      <param name="cDocFile">The name of the Application Doc File.</param>
      <param name="cForm">The name of the form.</param>
      <param name="cObject">The name of the OLEObject.</param>
      <remarks>
        All OLE objects inserted into a form inside the Window Editor are saved inside a special file called the Application Doc File.  When the OLE object is recreated at runtime, the persistent information is loaded from the Application Doc File using OLEObject:CreateFromAppDocStorage().
      </remarks>
      <example>
        The following code is generated by the Window Editor to load the OLE object from the associated Application Doc File:
        <code language="X#">
          oDCOLEObject1:CreateFromAppDocStorage(OLEAppDocStorage{;
          "C:\CAVO2x\DATA\Application 5.MDF", "dw", "OLEObject1"}
        </code></example>
    </member>
    <member name="P:VO.OLEAppDocStorage.DocFile">
      <summary>
        A string representing the name of the Application Doc File.
      </summary>
      <value>A string representing the name of the Application Doc File.</value>
    </member>
    <member name="P:VO.OLEAppDocStorage.Form">
      <summary>
        A string representing the name of the form.
      </summary>
      <value>A string representing the name of the form.</value>
    </member>
    <member name="P:VO.OLEAppDocStorage.OLEObject">
      <summary>
        A string representing the name of the OLEObject.
      </summary>
      <value>A string representing the name of the OLEObject.</value>
    </member>
    <member name="T:VO.OLEAutoObject">
      <summary>
        Provide a class to define an OLE automation server.
      </summary>
      <remarks>
        An OLE automation server is represented through an instance of this class in a X# application.  An OLE automation server can be created at runtime using this class without having any information available about the particular server at compile time.  All methods, properties, and variables of the automation server are available through the OLEAutoObject object.  OLE automation server methods map to X# methods, get properties and variables with read access to Access methods, and set properties and variables with write access to Assign methods.
        While it is often very convenient to create automation servers at runtime on the fly, you might also want to consider generating base classes for specific automation servers using the Automation Server generator in the IDE.  Generated OLE automation server base classes inherit from OLEAutoObject and provide compile-time information about the particular server, thereby introducing compile-time checking and speeding up method invocations at runtime.
        Internally this class uses an array of method description objects (type cOleMethod) to store the descriptions of the properties and methods that an OleAutomation server supports.
      </remarks>
    </member>
    <member name="M:VO.OLEAutoObject.#ctor">
      <summary>
        Construct an OLE automation server.
      </summary>
      <param name="ObjId">A string, IDispatch object, Interface Pointer or OleAutoObject specifying the automation server.</param>
      <param name="nLangID">The language ID for automation servers that support multiple language.  The default value is zero.</param>
      <param name="lNoFuncArray">Reserved.  The default value is FALSE.</param>
      <param name="fROTCheck">Should X# return a reference to an already running server (TRUE) or create a new instance of the server (FALSE). The default value is FALSE.</param>
      <remarks>
        Init() initializes an OLEAutoObject and tries to link it to the specified automation server.
        Usually, you will specify the automation server (OLE defined PROGID) using its name as a string (i.e., &lt;cServer&gt;).  You can, however, specify it as an object of the IDispatch class (i.e., &lt;oIDispatch&gt;).  This is required to handle interface hierarchies in OLE automation.  A method, property, or variable might return an OLE interface, that in turn represents an automation object with its own methods, properties, and variables.  The invoke logic of the automation class will automatically turn a returned OLE automation interface in a new OLEAutoObject object, by first creating an IDispatch object, then creating a new OLEAutoObject object and passing the IDispatch object to its Init() method.
        Alternate parameters are an IDispatch pointer or an OleAutoObject.  IDispatch Pointers are handled just like IDispatch objects. When you pass in an OleAutoObject X# will create a second OleAutoObject that points to the same COM Interface. X# will make sure that the reference counting is adjusted to reflect the fact that TWO VO Objects are passing to the same OLE Object.
        The invoke logic in generated subclasses of OLEAutoObject handles return OLE automation interfaces in this manner, so that normally there is no need for the user to pass IDispatch objects to OLEAutoObject:Init().
        OLE automation servers might support different languages for the names of methods, properties, and variables.  The desired language is specified through the &lt;nLangID&gt; argument.  The value zero tells the server to use its default language.  For details about the supported languages, their identifiers, and the default language, refer to the documentation for your specific automation server.
        The &lt;lNoFuncArray&gt; parameter has to be considered reserved.  It is only used by generated subclasses of OLEAutoObject to prevent the Init() method from creating OLEAutoObject:aFuncDesc (an array containing descriptions for all methods, properties, and variables of the automation server).  Because this array is not needed by generated subclasses of OLEAutoObject, they call the Init() method using a value of TRUE for this argument.  The default value, and the value that is normally used, is FALSE.
        The &lt;fROTCheck&gt; parameter determines if X# will create a new instance of the server or if it will try to see if the server is already running. The default behavior is to create a new server (fROTCheck = FALSE). When you specify a TRUE for this parameter,  X#will inspect the OLE Running Objects Table and try to attach to an already running server by calling the GetActiveObject() API function. When that fails, X# will create a new server
      </remarks>
      <example>
        This example creates a Word Application automation server:
        <code language="X#">
          FUNCTION Start()
          LOCAL oApp AS OBJECT
          LOCAL oDocs AS OBJECT
          LOCAL oDoc AS OBJECT
          ? "Starting Word"
          oApp := OleAutoObject{"Word.Application"}
          oApp:Visible := TRUE
          oDocs := oApp:Documents
          ? "Loading Document"
          oDoc := oDocs:Open("C:\Cavo28\whatsnew.rtf")
          ? "Printing Document"
          oApp:PrintOut(NamedArg{#Background, TRUE}, ;
            NamedArg{#PrintToFile, TRUE}, ;
            NamedArg{#OutputFileName, "C:\TEST.TXT"})
          DO WHILE oApp:BackgroundPrintingStatus != 0
            ? "."
            DoEvents()
          ENDDO
          ? "Closing WORD"
          oDoc:Close(FALSE)
          oApp:Quit()
          wait "Done"
          RETURN NIL
        </code></example>
    </member>
    <member name="P:VO.OLEAutoObject.aFuncDesc">
      <summary>
        Note 	This access is no longer available in X# 2.7b1.
      </summary>
      <value>Note 	This access is no longer available in X# 2.7b1.</value>
      <remarks>
        An array containing descriptions of the methods, properties, and variables of the OLE automation server represented by the OLEAutoObject.  This array is only intended for use by the OLEAutoObject class — the user must not manipulate it.
        This array exists only for instances of the OLEAutoObject class.  Generated automation server classes that inherit from OLEAutoObject do not need this array since the method information is generated and expanded into code.
        The array is used as a kind of Hash table. The position in the array is calculated from the name of the methods or properties. The elements in the array are objects of the class cOleMethod. This class is used to describe the methods from a OleAutoObject.
      </remarks>
    </member>
    <member name="P:VO.OLEAutoObject.DateTimeAsDate">
      <summary>
        An OLE date is actually a DateTime combination, often known as a timestamp in SQL databases. This combination of DateTime can not be stored in a DBF Date field and is not recognised by the Date FieldSpec as being a valid date.
        When an OLE date field is returned it is an instance of the OleDateTime class and the values can be extracted from this.
        However, by setting the DateTimeAsDate to TRUE, all OLE dates will be returned as VO dates in the standard format.
      </summary>
      <value>
        An OLE date is actually a DateTime combination, often known as a timestamp in SQL databases. This combination of DateTime can not be stored in a DBF Date field and is not recognised by the Date FieldSpec as being a valid date.
        When an OLE date field is returned it is an instance of the OleDateTime class and the values can be extracted from this.
        However, by setting the DateTimeAsDate to TRUE, all OLE dates will be returned as VO dates in the standard format.
      </value>
    </member>
    <member name="M:VO.OLEAutoObject.Destroy">
      <summary>
        Provide a method to de-instantiate an OLE automation server.
      </summary>
      <remarks>
        OLEAutoObject:Destroy() shuts down an OLE automation session and releases all the data associated with it.  This method is  called automatically by OLEAutoObject:Axit(), which is triggered by the garbage collector, but you can also call OLEAutoObject:Destroy() directly, as illustrated in the example below.
      </remarks>
      <example>
        This example shows how to destroy an automation server after you are finished working with it:
        <code language="X#">
          LOCAL o AS OLEAutoObject
          o := OLEAutoObject{"Word.Basic"}
          //
          // Work with automation object
          //
          // Shut down
          o:Destroy()
        </code></example>
    </member>
    <member name="P:VO.OLEAutoObject.dwFuncs">
      <summary>
        The number of methods defined for the OLE automation server.
      </summary>
      <value>The number of methods defined for the OLE automation server.</value>
    </member>
    <member name="P:VO.OLEAutoObject.dwVars">
      <summary>
        The number of properties and variables  for the OLE automation server.
      </summary>
      <value>The number of properties and variables  for the OLE automation server.</value>
    </member>
    <member name="P:VO.OLEAutoObject.fInit">
      <summary>
        The instantiation of an OLEAutoObject object does not mean that the OLE automation has been successfully started.  For example, moving an automation application from one PC to another will cause the application to malfunction if the OLE automation server is not installed on the new PC.  In this case trying to use the OLEAutoObject after instantiation would cause runtime error.
        After creating the object, OLEAutoObject:fInit lets you check to see if the OLE automation server has been successfully initialized.  It returns TRUE if the OLE automation server has been initialized properly; otherwise, it returns FALSE.
      </summary>
      <value>
        The instantiation of an OLEAutoObject object does not mean that the OLE automation has been successfully started.  For example, moving an automation application from one PC to another will cause the application to malfunction if the OLE automation server is not installed on the new PC.  In this case trying to use the OLEAutoObject after instantiation would cause runtime error.
        After creating the object, OLEAutoObject:fInit lets you check to see if the OLE automation server has been successfully initialized.  It returns TRUE if the OLE automation server has been initialized properly; otherwise, it returns FALSE.
      </value>
      <example>
        This example displays an error message if the automation server could not be successfully initialized after instantiation:
        <code language="X#">
          LOCAL o AS OLEAutoObject
          o := OLEAutoObject{"Word.Basic"}
          IF !o:fInit
          MessageBox(0, "Error initializing automation server", ;
          "Error", 0)
          RETURN
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.OLEAutoObject.No">
      <summary>
        Provide a general error interception that is automatically called whenever a reference is made to a non-existent method.
        <br />Important!  NoMethod() should not be called directly; it is called by the system for handling invalid references.
      </summary>
    </member>
    <member name="M:VO.OLEAutoObject.NoIVarGet">
      <summary>
        Provide a general error interception that is automatically called whenever an access reference is made to a non-existent access property.
        <br />Important!  NoIVarGet() should not be called directly; it is called by the system for handling invalid references.
      </summary>
      <param name="symIVar">The symbolic name of the variable that was referenced.</param>
    </member>
    <member name="M:VO.OLEAutoObject.NoIVarPut">
      <summary>
        Provide a general error interception that is automatically called whenever an assignment reference is made to a non-existent assign property.
        <br />Important!  NoIVarPut() should not be called directly; it is called by the system for handling invalid references.
      </summary>
      <param name="symIVar">The symbolic name of the variable that was referenced.</param>
      <param name="uValue">The value to be assigned.</param>
    </member>
    <member name="T:VO.OLEAutoObjectFromFile">
      <summary>
        Provide a class to create an OLE automation server from a file.
      </summary>
      <remarks>
        <br />Important!  In order for this class to work the automation server must implement the IPersistFile interface — most automation servers do not.
        The OLEAutoObjectFromFile class lets you create an automation server object from a file.  OLE will determine which automation server a particular file belongs to and automatically start the server and open the file inside it.
      </remarks>
    </member>
    <member name="M:VO.OLEAutoObjectFromFile.#ctor">
      <summary>
        Create an OLE automation server from a file.
      </summary>
      <param name="cFName">The name of file from which to create the OLE automation server.</param>
      <param name="nLangID">The language ID for automation servers that support multiple language.  The default value is zero.</param>
      <remarks>
        Init() initializes an OLEAutoObjectFromFile and tries to link it to the automation server that is registered for the file &lt;cFName&gt;.
        OLE automation servers might support different languages for the names of methods, properties, and variables.  The desired language is specified through the &lt;nLangID&gt; argument.  The value zero tells the server to use its default language.  For details about the supported languages, their identifiers, and the default language, refer to the documentation for your specific automation server.
        <br />Important!  In order for this class to work the automation server must implement the IPersistFile interface — most automation servers do not.
      </remarks>
    </member>
    <member name="P:VO.OLEAutoObjectFromFile.cFileName">
      <summary>
        A string representing the file name to which the automation server is bound.
      </summary>
      <value>A string representing the file name to which the automation server is bound.</value>
    </member>
    <member name="M:VO.OLEAutoObjectFromFile.Destroy">
      <summary>
        Provide a method to de-instantiate an OLE automation server.
      </summary>
      <remarks>
        OLEAutoObjectFromFile:Destroy() shuts down an OLE automation session and releases all the data associated with it.  This method is called automatically by OLEAutoObject:Axit(), which is triggered by the garbage collector, but you can also call OLEAutoObjectFromFile:Destroy() directly.
      </remarks>
    </member>
    <member name="T:VO.OleBinary">
      <summary>
        Provide a class to support passing Binary Information to Ole Server
      </summary>
      <remarks>
        This class is used to pass binary information to an OleServer, such as the contents of a file. In most cases the Ole Server will expect an array of butes. VO will generate an array of bytes for each OleBinary Argument.
        <note type="tip">
          VO 2.8 SP2 introduces this class. However: this patch does not come with a new repository, so you cannot directly reference the class but must use the CreateInstance() syntax in stead.
        </note></remarks>
      <example>
        The following example shows how an OleBinary object is used to pass the contents of a binary file to a server
        <code language="X#">
          LOCAL oServer AS OBJECT
            LOCAL cData AS STRING
            oServer := OleAutoObject{"Some.Server"}
            cData := MemoRead("MyFile.bin")
            oServer:Upload("MyFile.bin", CreateInstance(#OleBinary, cData))
        </code></example>
    </member>
    <member name="M:VO.OleBinary.#ctor">
      <summary>
        Construct a NamedArg object.
      </summary>
      <param name="uValue">This can be a string. SafeArray or another OleBinary object.If you pass in a SafeArray, then the class creates a clone of the SafeArray. You remain the owner of the original SafeArray. If you pass in an OleBinary then it clones that object.</param>
    </member>
    <member name="M:VO.OleBinary.AsString">
      <summary>
        Returns the string representation of the OleBinary Object
        When the type is known, it can be a text such as ‘Word Document’ or ‘Bitmap’. Otherwise it is a hex dump from the contents
      </summary>
    </member>
    <member name="P:VO.OleBinary.ProgId">
      <summary>
        When the class can determine the contents of the binary info then this access returns the ProgId from the contents.
      </summary>
      <value>When the class can determine the contents of the binary info then this access returns the ProgId from the contents.</value>
    </member>
    <member name="P:VO.OleBinary.SafeArray">
      <summary>
        This sets/returns a copy of the SafeArray stored in this object.
      </summary>
      <value>This sets/returns a copy of the SafeArray stored in this object.</value>
      <remarks>
        <note type="tip">
          If you call the access, you become responsible for destroying the SafeArray
          If you assign a new SafeArray then the object creates a clone of this SafeArray. You remain the owner of the original SafeArray.
        </note>
      </remarks>
    </member>
    <member name="P:VO.OleBinary.Value">
      <summary>
        Reads/Updates the contents of the object as a string.
      </summary>
      <value>Reads/Updates the contents of the object as a string.</value>
    </member>
    <member name="T:VO.OLEControl">
      <summary>
        Provide a container and wrapper for an OLE control (OCX).
      </summary>
      <remarks>
        The OLEControl class implements a wrapper and container for an OLE control (OCX, ActiveX).  An OLE control is basically an OLE object with an added automation interface, by which you can program the OCX and set up event handlers to handle events instantiated by the OLE control.  To cover the first requirement, OLEControl is derived from OLEObject and, therefore, inherits all of the OLEObject's functionality.  The automation interface is provided by an OLEAutoObject, which is a protected member variable of OLEControl initialized using OLEControl:InitAutoObject().
      </remarks>
    </member>
    <member name="M:VO.OLEControl.CreateEmbedding">
      <summary>
        Create an OLE control from a program ID.
      </summary>
      <param name="cProgID">The OLE control's program ID.</param>
      <param name="cLicKey">The license key for the OLE control's program.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Each object provided by an OLE server is uniquely identified by its program ID.  These program IDs are stored in the system Registry as described in the OLE server's documentation.  OLEControl:CreateEmbedding() creates an embedded OLE control from its program ID and loads it into an OLEControl container.
      </remarks>
      <example>
        The following code responds to a button click by creating an object with the program ID Word.Document.6 within an already existing OLEControl container sitting on a data window:
        <code language="X#">
          METHOD PushButton1() CLASS dw
          oDCOLEControl1:CreateEmbedding("Word.Document.6")
        </code></example>
    </member>
    <member name="M:VO.OLEControl.CreateFromAppDocStorage">
      <summary>
        Create an OLEControl from an Application Doc File storage.
      </summary>
      <param name="oOLEAppDocStorage">The OLEAppDocStorage object containing the object.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        All OLE controls inserted into a form inside the Window Editor are saved inside a special file called the Application Doc File.  When the OLE control is recreated at runtime, the persistent information, including the OLEAutoObject, is loaded from the Application Doc File using OLEControl:CreateFromAppDocStorage().
      </remarks>
    </member>
    <member name="M:VO.OLEControl.Destroy">
      <summary>
        Provide a method to de-instantiate an OLEControl object.
      </summary>
      <param name="oEvent">The event to be handled.</param>
      <seealso cref="T:VO.Event" />
      <remarks>
        This method can be used when an OLEControl object is no longer needed.  OLEControl:Destroy() de-instantiates the OLEControl object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.  The associated OLE control is automatically closed and the OLE control's server is shut down, unless it is serving other clients.
      </remarks>
    </member>
    <member name="M:VO.OLEControl.Dispatch">
      <summary>
        Provide the prototype dispatcher for events within the system when the control has focus;  routing various events to their appropriate event handlers.
      </summary>
      <param name="oEvent">The event to be handled.</param>
      <seealso cref="T:VO.Event" />
      <returns>
        TRUE if the event was handled; otherwise, FALSE.
      </returns>
      <remarks>
        OLEControl:Dispatch() serves as an internal callback, dispatching events to various event handlers.  It should never be necessary to call this method directly.  Instead, you can write your own Dispatch() method for derived classes if you want to handle additional events.  Usually the derived class Dispatch() should call SUPER:Dispatch() to support the inherited event handling.
      </remarks>
    </member>
    <member name="M:VO.OLEControl.InitAutoObject">
      <summary>
        Initialize the OLEAutoObject.
      </summary>
      <returns>
        SELF
      </returns>
      <remarks>
        The OLEAutoObject must be initialized after the OLE control is created.  OLEControl:CreateFromAppDocStorage() does this automatically.  If you use one of the other Create methods, however, make sure to initialize the OLEAutoObject properly using OLEControl:InitAutoObject().
      </remarks>
    </member>
    <member name="M:VO.OLEControl.No">
      <summary>
        Provide a general error interception that is automatically called whenever a reference is made to a non-existent method.
        <br />Important!  NoMethod() should not be called directly; it is called by the system for handling invalid references.
      </summary>
    </member>
    <member name="T:VO.OLEDataWindow">
      <summary>
        Create a data window capable of hosting OLE objects.
      </summary>
      <remarks>
        Note 	The functionality in the methods of this class has now been incorporated into the DataWindow Class and the Window Class. The class name is retained for backward compatibility only, but all its methods have been moved to one of the parent classes
        An OLE data window is a regular data window enhanced by some features to support OLE objects.
      </remarks>
    </member>
    <member name="M:VO.OLEDataWindow.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Note 	The functionality in this method has now been incorporated into the Window Class.

        Construct an OLE data window.
      </summary>
      <param name="oOwner">
        The window that owns the OLE data window.  The following window types can be owners: App, ShellWindow, TopAppWindow, ChildAppWindow, DialogWindow, DataDialog, or another DataWindow.
        The behavior of the OLE data window is determined by the type of its owner.
      </param>
      <param name="oSource">The ID of the resource that defines the layout of the OLE data window.  or the resource ID that specifies the location and size of the sub-data window.
      Specifying this argument creates the new OLE data window as a sub-data window on its owner data window (only data window owners can have sub-data windows).
      It should refer to a control defined in the resource entity of the owner data window.
        If &lt;oSource&gt; is omitted or if &lt;oOwner&gt; is not a data window, the data window is created as a modal DialogWindow.
      </param>
      <param name="nResourceID">** missing parameter documentation **</param>
      <remarks>
        An OLE data window is an enhanced data window which can be used to host OLE objects.  It provides the additional functionality needed for OLE objects.  For more details, please see the specific methods for the OLEDataWindow class.
      </remarks>
    </member>
    <member name="M:VO.OLEDataWindow.DeActivate(XSharp.__Usual)">
      <summary>
        Note 	The functionality in this method has now been incorporated into the Window Class.

        Provide a method that is invoked when the OLE data window is deactivated.
        <br />Important!  Deactivate() is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oEvent">An empty event required to maintain the protocol that all event handlers have exactly one event as their argument.</param>
      <seealso cref="T:VO.Event" />
      <remarks>
        This event handler is normally invoked when another application or window becomes activated.  By default, all OLE objects on the OLEDataWindow will be deactivated.  If Window:MouseTrapOn() is left on, MouseEvent events cannot be directed to other applications or windows.
      </remarks>
    </member>
    <member name="M:VO.OLEDataWindow.DeactivateAllOLEObjects(XSharp.__Usual)">
      <summary>
        Note 	The functionality in this method has now been incorporated into the Window Class.

        Deactivate all currently active OLE objects.
      </summary>
      <remarks>
        The DeactivateAllOLEObjects() method deactivates any currently (in-place) active OLE objects.  The method is called automatically whenever the data window itself is deactivated.
      </remarks>
    </member>
    <member name="M:VO.OLEDataWindow.MouseButtonDown(XSharp.__Usual)">
      <summary>
        Note 	The functionality in this method has now been incorporated into the Window Class.

        Provide an event handler that is invoked when the mouse pointer is positioned over the window and a mouse button is clicked.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oMouseEvent">The MouseEvent object that contains information about the state of the mouse when the button was clicked.</param>
      <remarks>
        By default, this method will deactivate all OLE object controls on the window before processing the MouseEvent.
        Use the Window:MouseTrapOn() method to force MouseEvents generated outside the canvas area to be directed to this window.
      </remarks>
    </member>
    <member name="M:VO.OLEDataWindow.Notify(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Note 	The functionality in this method has now been incorporated into the DataWindow Class.

        Provide an event handler that reflects events that have occurred in the server connected to an OLE data window.
        <br />Important!  Notify() is automatically called by the server, and should normally not be called by application code.
      </summary>
      <param name="kNotifyName">Identifies the event, specified as one of the constants listed below.</param>
      <param name="uDescription">Used only with some notification types, as described above.</param>
      <returns>
        SELF, except if NOTIFYINTENTTOMOVE is specified for &lt;kNotifyName&gt;.  In this case, the return value is TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <include file="VOSDK_Classes.xml" path="doc/commonblocks/notify/*" />
      </remarks>
    </member>
    <member name="M:VO.OLEDataWindow.UpdateActiveObject">
      <summary>
        Note 	The functionality in this method has now been incorporated into the DataWindow Class.

        Update the toolbars of any in-place active OLE objects.
      </summary>
      <remarks>
        OLEDataWindow:UpdateActiveObject() calls the UpdateTools() method of any currently activated OLE object that the OLE data window contains.  It first determines which OLE object control is in-place active, and then replaces the X# container application's toolbars with the OLE server's toolbars.  In response to a resizing of the container application, this method causes the OLE object server to rearrange its toolbars.
      </remarks>
    </member>
    <member name="M:VO.OLEDataWindow.ViewAs(XSharp.__Usual)">
      <summary>
        Note 	The functionality in this method has now been incorporated into the DataWindow Class.

        Specify the view mode of the OLE data window as either browse view or form view.
      </summary>
      <param name="symViewMode">
        Specifies which view mode is to be used.  Use one of these symbols:
        Symbol	Description
        #BrowseView	Several records are displayed at the same time, as rows in a spreadsheet-like table with each field corresponding to a column.
        #FormView	A single record is viewed at a time, with its fields displayed in individual controls.
      </param>
      <remarks>
        When a window is switched to a new view mode, a layout is automatically generated if one had not been defined previously.
        Because it takes an argument, OLEDataWindow:ViewAs() is rarely connected directly with a push button or menu command; instead, the OLEDataWindow:ViewForm() and OLEDataWindow:ViewTable() methods (inherited from DataWindow) are used.
        In addition to the functionality provided by the DataWindow base class, the implementation for the OLEDataWindow class also deactivates any activated OLE objects before changing the view.
      </remarks>
    </member>
    <member name="T:VO.OleDateTime">
      <summary>
        Provide an encapsulation of a DateTime value as used by OLE objects.
      </summary>
      <remarks>
        OLE dates are a combination of the date and time which is sometimes known as a timestamp in SQL databases. The OleDateTime class provides a way for X# to encapsulate this type of value.
      </remarks>
    </member>
    <member name="M:VO.OleDateTime.#ctor">
      <summary>
        Construct an OleDateTime object.
      </summary>
      <param name="uDate">This can be passed as a number or as a VO date.</param>
      <remarks>
        The OleDateTime class can be initialized in two ways:
        - With a VO Date, in which case the time portion is set to 00:00:00.00
        - With a number, in which case the Integer is taken as the number of days from December 30th 1899 to make the date. The fraction is then taken as a fraction of a day to make the time portion of the object.
      </remarks>
    </member>
    <member name="M:VO.OleDateTime.AsReal8">
      <summary>
        Returns the DateTime value as Real8 (the format that is used in COM).
      </summary>
    </member>
    <member name="M:VO.OleDateTime.AsString">
      <summary>
        Returns the dateTime value as a String.
      </summary>
    </member>
    <member name="P:VO.OleDateTime.DateVal">
      <summary>
        The value of the date part of the DateTime object as a Date.
      </summary>
      <value>The value of the date part of the DateTime object as a Date.</value>
    </member>
    <member name="P:VO.OleDateTime.TimeString">
      <summary>
        The value of the timee part of the DateTime object as a String.
      </summary>
      <value>The value of the timee part of the DateTime object as a String.</value>
    </member>
    <member name="P:VO.OleDateTime.TimeVal">
      <summary>
        The numeric value of the time part of the DateTime object as a Float.
      </summary>
      <value>The numeric value of the time part of the DateTime object as a Float.</value>
    </member>
    <member name="T:VO.OLEDBStorage">
      <summary>
        Provide an encapsulation of a database storage for an OLE object.
      </summary>
      <remarks>
        X# supports the ability to store an OLE object in a DBF database.  To assign a new value to the OLEObject container, you pass an OLEDBStorage object to OLEObject:CreateFromDBStorage().  To save an OLE object in the database, you pass an OLEDBStorage object to OLEObject:SaveToDBStorage().  You usually get the OLEDBStorage object as a result of a FieldGet() call.
      </remarks>
    </member>
    <member name="M:VO.OLEDBStorage.#ctor">
      <summary>
        Construct an OLEDBStorage object.
      </summary>
      <param name="ptrRootStg">A pointer to the root storage.</param>
      <param name="cSubStgName">A string representing the substorage name.</param>
      <remarks>
        OLEDBStorage objects are usually a result of a FieldGet() call.  It should never be necessary to call this method directly.
      </remarks>
    </member>
    <member name="P:VO.OLEDBStorage.RootStorage">
      <summary>
        A pointer to the root storage object.
      </summary>
      <value>A pointer to the root storage object.</value>
      <remarks>
        <br />Important!  This property is used for internal purposes and is not intended to be used directly.
      </remarks>
    </member>
    <member name="P:VO.OLEDBStorage.SubStorageName">
      <summary>
        A string representing the name of the object's substorage.
      </summary>
      <value>A string representing the name of the object's substorage.</value>
      <remarks>
        <br />Important!  This property is used for internal purposes and is not intended to be used directly.
      </remarks>
    </member>
    <member name="T:VO.OLEDragEvent">
      <summary>
        Store information about an OLE drag and drop event.
      </summary>
      <remarks>
        A window that is registered as an OLE drop target using ChildAppWindow:EnableOLEDropTarget() can handle OLE drag and drop events and create new OLE objects in response to such events.  In the associated handlers, an OLEDragEvent object is passed as a parameter that can be used to create a new OLE object by calling OLEObject:CreateFromOLEDragEvent().
      </remarks>
    </member>
    <member name="M:VO.OleDragEvent.#ctor(XSharp.__Usual)">
      <summary>
        Construct an OLEDragEvent.
      </summary>
      <param name="DragInfo">A pointer to a DRAGINFO structure.</param>
    </member>
    <member name="P:VO.OleDragEvent.DataObject">
      <summary>
        A pointer to the OLE object data.
      </summary>
      <value>A pointer to the OLE object data.</value>
    </member>
    <member name="P:VO.OleDragEvent.Effect">
      <summary>
        A constant indicating the effect of the drag and drop operation:
      </summary>
      <value>A constant indicating the effect of the drag and drop operation:</value>
      <remarks>
        One of the following constants indicating the effect of the drag and drop operation:
        <pre>
          Constant	      	Meaning
          DROPEFFECT_COPY	Copy operation
          DROPEFFECT_LINK	Create a new link
          DROPEFFECT_MOVE	Move operation
          DROPEFFECT_NONE	No effect
        </pre>
        OLEDragEvent:Effect controls the appearance of the drag and drop mouse cursor and can be set during the handling of an OLEDragEvent.
      </remarks>
    </member>
    <member name="P:VO.OleDragEvent.ObjectName">
      <summary>
        A string representing the OLE object name.  By examining the object and/or server name, the container application can selectively allow or disallow a particular object or server as a drag and drop source.
      </summary>
      <value>A string representing the OLE object name.  By examining the object and/or server name, the container application can selectively allow or disallow a particular object or server as a drag and drop source.</value>
    </member>
    <member name="P:VO.OleDragEvent.Position">
      <summary>
        A Point object specifying the position of the event.
      </summary>
      <value>A Point object specifying the position of the event.</value>
    </member>
    <member name="P:VO.OleDragEvent.ServerName">
      <summary>
        A string representing the OLE server name.  By examining the object and/or server name, the container application can selectively allow or disallow a particular object or server as a drag and drop source.
      </summary>
      <value>A string representing the OLE server name.  By examining the object and/or server name, the container application can selectively allow or disallow a particular object or server as a drag and drop source.</value>
    </member>
    <member name="T:VO.OLEInterface">
      <summary>
        Provide the base class for the internal implementation of OLE automation.
      </summary>
      <remarks>
        <br />Important!  This class is used for internal implementation only and is not intended to be used directly.
      </remarks>
    </member>
    <member name="T:VO.OLEObject">
      <summary>
        Provide a container and wrapper for an OLE object.
      </summary>
      <remarks>
        The OLEObject class serves as the container and wrapper for an OLE object, provided and managed by an OLE server.  The OLEObject alone is simply a windowed control that can take exactly one OLE object.  The OLE object is created via one of the Create methods, such as OLEObject:CreateFromPasteDialog() or OLEObject:CreateFromAppDocStorage().  Several properties, such as OLEObject:AllowInPlace, control the basic behavior of the OLEObject.
        Note the distinction between OLEObject, which is a class provided by X#, and an OLE object, which is provided by its server and "lives" inside the OLEObject container.  Using OLEObject:DetachFromServer(), the current OLE object can be destroyed, but the same OLEObject container can be reused by calling one of the Create methods again.
      </remarks>
    </member>
    <member name="M:VO.OLEObject.#ctor">
      <summary>
        Construct an OLEObject.
      </summary>
      <param name="oOwner">The window that owns the OLEObject.</param>
      <param name="nID">The unique ID between 1 and 8000 of the OLEObject.</param>
      <param name="nResourceID">The resource ID of OLEObject.</param>
      <param name="oPoint">The origin of the OLEObject in canvas coordinates.</param>
      <param name="oDimension">The dimension of the OLEObject in canvas coordinates.</param>
      <param name="lDataAware">A logical value that is TRUE if the OLEObject is data-aware and otherwise FALSE.</param>
      <example>
        The following code is generated by the Window Editor.  It first creates an OLEObject container from a resource, then a HyperLabel is assigned, and finally the OLE object is loaded from the Application Doc File:
        <code language="X#">
          oDCOLEObject1 := OLEObject{SELF, ;
          ResourceID{DW_OLEOBJECT1, _GetInst()}}
          oDCOLEObject1:HyperLabel := HyperLabel{#OLEObject1, ;
          NULL_STRING, NULL_STRING, NULL_STRING}
          oDCOLEObject1:CreateFromAppDocStorage(OLEAppDocStorage{ ;
          "C:\CAVO2x\DATA\Application 5.MDF", "dw", "OLEObject1"})
        </code></example>
    </member>
    <member name="M:VO.OLEObject.Activate">
      <summary>
        Activate the OLE object.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        The method puts the associated OLE object into the active state, which usually allows the user to edit the object.
      </remarks>
      <example>
        The following code shows a push button's click event handler, which activates an OLEObject located on the same data window:
        <code language="X#">
          METHOD PushButton1() CLASS dw
          oDCOLEObject1:Activate("Word.Document.6")
        </code></example>
    </member>
    <member name="P:VO.OLEObject.ActivateOnDblClk">
      <summary>
        A logical value that is TRUE if the OLE object is activated by double-clicking on it and FALSE otherwise.  The default value for this property is TRUE.
      </summary>
      <value>A logical value that is TRUE if the OLE object is activated by double-clicking on it and FALSE otherwise.  The default value for this property is TRUE.</value>
    </member>
    <member name="M:VO.OLEObject.AddVerbMenu">
      <summary>
        Insert the OLE object's verb menu into an existing menu.
      </summary>
      <param name="hMenu">The handle of the existing menu.</param>
      <param name="iPos">The position at which the menu should be inserted.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        A OLE object usually supports several actions (called verbs) which a user can perform on the object.  An AVI object, for example, can support a Play and an Edit verb.  The object's verbs can be invoked via its verb menu, which is added using OLEObject:AddVerbMenu() into an existing menu and is fully managed by the object.
      </remarks>
      <example>
        The following code inserts the verb menu at position two of the pop-up menu with ID one of the container application.  Note that the system menu of an MDI child window counts as separate pop-up menu, in case the MDI child window is maximized:
        <code language="X#">
          LOCAL hObjMenu AS PTR
          IF oParent:IsZoomed()
          hObjMenu := oParent:Menu:GetSubMenu(2)
          ELSE
          hObjMenu := oParent:Menu:GetSubMenu(1)
          ENDIF
          SELF:AddVerbMenu(hObjMenu, 2)
        </code></example>
    </member>
    <member name="P:VO.OLEObject.AllowInPlace">
      <summary>
        If an OLE object is activated — either by calling OLEObject:Activate() or by double-clicking on the object — the server usually puts the object into edit mode.  This editing can happen either inside the X# container application (in-place activation) or in a separate window managed by the server (out-of-place activation).  During in-place activation, the server's and the container's menus and toolbars are merged, and the object can be edited inside the container's user interface context.
        OLEObject:AllowInPlace is a logical value that is TRUE if the object is allowed to be activated in-place and FALSE otherwise.  The default value for this property is FALSE.
        <note type="tip"> The server can deny in-place activation even if OLEObject:AllowInPlace is TRUE.</note></summary>
      <value>
        If an OLE object is activated — either by calling OLEObject:Activate() or by double-clicking on the object — the server usually puts the object into edit mode.  This editing can happen either inside the X# container application (in-place activation) or in a separate window managed by the server (out-of-place activation).  During in-place activation, the server's and the container's menus and toolbars are merged, and the object can be edited inside the container's user interface context.
        OLEObject:AllowInPlace is a logical value that is TRUE if the object is allowed to be activated in-place and FALSE otherwise.  The default value for this property is FALSE.
         The server can deny in-place activation even if OLEObject:AllowInPlace is TRUE.
      </value>
    </member>
    <member name="P:VO.OLEObject.AllowResize">
      <summary>
        A logical value that is TRUE if the OLE object is resizable and movable at runtime.  The default value for this property is FALSE.
      </summary>
      <value>A logical value that is TRUE if the OLE object is resizable and movable at runtime.  The default value for this property is FALSE.</value>
    </member>
    <member name="P:VO.OLEObject.AutoSizeOnCreate">
      <summary>
        A logical value that determines if the initial size of the OLE object is controlled by the object's server.  If OLEObject:AutoSizeOnCreate is TRUE, the Create methods ask the object's server for a preferred object size.  If this size is meaningful the OLEObject container resizes itself.  The default value for this property is TRUE.
      </summary>
      <value>A logical value that determines if the initial size of the OLE object is controlled by the object's server.  If OLEObject:AutoSizeOnCreate is TRUE, the Create methods ask the object's server for a preferred object size.  If this size is meaningful the OLEObject container resizes itself.  The default value for this property is TRUE.</value>
    </member>
    <member name="M:VO.OLEObject.CreateEmbedding">
      <summary>
        Create an OLE object from a program ID.
      </summary>
      <param name="cProgID">The OLE object's program ID.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Each object provided by an OLE server is uniquely identified by its program ID.  These program IDs are stored in the system Registry as described in the OLE server's documentation.  OLEObject:CreateEmbedding() creates an embedded OLE object from its program ID and loads it into an OLEObject container.
      </remarks>
      <example>
        The following code responds to a button click by creating an object with the program ID Word.Document.6 within an already existing OLEObject container sitting on a data window:
        <code language="X#">
          METHOD PushButton1() CLASS dw
          oDCOLEObject1:CreateEmbedding("Word.Document.6")
        </code></example>
    </member>
    <member name="M:VO.OLEObject.CreateEmbeddingFromFile">
      <summary>
        Create an OLE object from a file.
      </summary>
      <param name="cFileName">The file containing the object.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        If an OLE object is given as a file (such as a saved document). you use OLEObject:CreateEmbeddingFromFile() to create an embedded OLE object and load it into its OLEObject container.
      </remarks>
      <example>
        The following code responds to a button click by creating an object from the file \WINWORD\SAMPLE.DOC:
        <code language="X#">
          METHOD PushButton1() CLASS dw
          oDCOLEObject1:CreateEmbeddingFromFile("\WINWORD\SAMPLE.DOC")
        </code></example>
    </member>
    <member name="M:VO.OLEObject.CreateFromAppDocStorage">
      <summary>
        Create an OLE object from an Application Doc File storage.
      </summary>
      <param name="oOLEAppDocStorage">The OLEAppDocStorage object containing the object.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        All OLE objects inserted into a form inside the Window Editor are saved inside a special file called the Application Doc File.  When the OLE object is recreated at runtime, the persistent information is loaded from the Application Doc File using OLEObject:CreateFromAppDocStorage().
      </remarks>
      <example>
        The following code is generated by the Window Editor to load the OLE object from the associated Application Doc File.
        <code language="X#">
          oDCOLEObject1:CreateFromAppDocStorage(OLEAppDocStorage{ ;
          "C:\CAVO25\DATA\Application 5.MDF", "dw", "OLEObject1"}
        </code></example>
    </member>
    <member name="M:VO.OLEObject.CreateFromDBStorage">
      <summary>
        Create an OLE object from a database storage.
      </summary>
      <param name="oOLEDBStorage">The OLEDBStorage object describing the database storage.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        X# supports the ability to store an OLE object in a DBF database.  To assign a new value to the OLEObject container, you pass an OLEDBStorage object to OLEObject:CreateFromDBStorage().  To save the persistent information of an OLE object in the database, you pass an OLEDBStorage object to OLEObject:SaveToDBStorage().  You usually get the OLEDBStorage object as a result of a FieldGet() call.
      </remarks>
      <example>
        The following code shows how an OLEDBStorage object received from the FieldGet() call is used to create an OLE object and insert it into the OLEObject container:
        <code language="X#">
          LOCAL oDBStg AS OLEDBStorage
          oDBStg := FieldGet(FieldPos(#PaintObject))
          oOLEContainer:CreateFromDBStorage(oDBStg)
        </code></example>
    </member>
    <member name="M:VO.OLEObject.CreateFromInsertDialog">
      <summary>
        Create an OLE object from the standard Insert Object dialog.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        OLEObject:CreateFromInsertDialog() brings up the standard Insert Object dialog, allowing the user to select an object type which is then used to create a new OLE object for this OLEObject container.
      </remarks>
      <example>
        The following code first instantiates a new OLEObject container then uses OLEObject:CreateFromInsertDialog() to create an OLE object for the container.  The OLEObject container is destroyed in case the OLE object creation failed — for example, because the user clicked on the dialog's Cancel button:
        <code language="X#">
          LOCAL oOLE AL OLEObject
          oOLE := DraggableOLEObject{SELF}
          oOLE:AllowInPlace := TRUE
          oOLE:AllowResize := TRUE
          IF oOLE:CreateFromInsertDialog()
          oOLE:Show()
          oOLE:SetFocus()
          ELSE
          oOLE:Destroy()
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.OLEObject.CreateFromOLEDragEvent">
      <summary>
        Create an OLE object from an OLEDragEvent.
      </summary>
      <param name="oOLEDragEvent">The OLEDragEvent object.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        A window that is registered as an OLE drop target using ChileAppWindow:EnableOLEDropTarget() can handle OLE drag and drop events and create new OLE objects in response to such events.  In the associated handlers, an OLEDragEvent object is passed as a parameter that can be used to create a new OLE object by calling OLEObject:CreateFromOLEDragEvent().
      </remarks>
      <example>
        The following code enables a data window as a drop target and creates a new OLE object inside its OLEDrop handler.  It also checks the name of the OLE object to allow only WordPad documents:
        <code language="X#">
          METHOD EnableOLEDropTarget CLASS DropTargetDataWindow
          SELF:EnableOLEDropTarget(TRUE)
          METHOD OLEDrop(oOLEDragEvent) CLASS MyChild
          LOCAL oOLE AS OLEObject
          LOCAL lRet AS LOGIC
          IF oOLEDragEvent:ObjectName == "WordPad Document"
          oOLE := OLEObject{SELF}
          oOLE:AllowInPlace := TRUE
          oOLE:AllowResize := TRUE
          IF oOLE:CreateFromOLEDragEvent(oOLEDragEvent)
          oOLE:Origin := oOLEDragEvent:Position
          oOLE:Show()
          oOLE:SetFocus()
          ENDIF
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.OLEObject.CreateFromPasteDialog">
      <summary>
        Create an OLE object from the standard Paste Special dialog.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        OLEObject:CreateFromPasteDialog() brings up the standard Paste Special dialog, allowing the user to select an object from the Clipboard which is then used to create a new OLE object for this OLEObject container.
      </remarks>
      <example>
        The following code first instantiates a new OLEObject container then uses OLEObject:CreateFromPasteDialog() to create an OLE object for the container.  The OLEObject container is destroyed in case the OLE object creation failed — for example, because the user clicked on the dialog's Cancel button:
        <code language="X#">
          LOCAL oOLE AS OLEObject
          oOLE := DraggableOLEObject{SELF}
          oOLE:AllowInPlace := TRUE
          oOLE:AllowResize := TRUE
          IF oOLE:CreateFromPasteDialog()
          oOLE:Show()
          oOLE:SetFocus()
          ELSE
          oOLE:Destroy()
          ENDIF
        </code>

        DataWindow:PasteSpecial(), OLEObject:CreateEmbedding(), OLEObject:CreateEmbeddingFromFile(), OLEObject:CreateFromAppDocStorage(), OLEObject:CreateFromDBStorage(), OLEObject:CreateFromInsertDialog(), OLEObject:CreateFromOLEDragEvent(), OLEObject:CreateLink()
      </example>
    </member>
    <member name="M:VO.OLEObject.CreateLink">
      <summary>
        Create an OLE object as a link to a file.
      </summary>
      <param name="cFileName">The name of file containing the OLE object.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        A linked OLE object is stored outside the container's storage.  This allows other applications to use and change the OLE object as well.  OLEObject:CreateLink() creates a new linked OLE object and loads it into the OLEObject container.
      </remarks>
      <example>
        The following code creates a linked OLE object from a text document into an OLEObject:
        <code language="X#">oMyTextObject:CreateLink("\WINWORD\SAMPLE.DOC")</code></example>
    </member>
    <member name="M:VO.OLEObject.Deactivate">
      <summary>
        Deactivate an OLE object.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <example>
        The following code shows a push button's click event handler, which deactivates an OLEObject located on the same data window:
        <code language="X#">
          METHOD PushButton1() CLASS dw
          oDCOLEObject1:Deactivate("Word.Document.6")
        </code></example>
    </member>
    <member name="M:VO.OLEObject.Destroy">
      <summary>
        Provide a method to de-instantiate an OLEObject.
      </summary>
      <remarks>
        This method can be used when an OLEObject object is no longer needed.  OLEObject:Destroy() de-instantiates the OLEObject object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.  The associated OLE object is automatically closed and the OLE object's server is shut down, unless it is serving other clients.
      </remarks>
    </member>
    <member name="M:VO.OLEObject.DetachFromServer">
      <summary>
        Remove a contained OLE object and cut the link to its server.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Since OLEObject serves as a container for any OLE object, it is possible to remove the current object, cut the link to its server, and load a new OLE object into the container by using one of the Create methods.  In the process, OLEObject:DetachFromServer() removes the current OLE object and cuts the link to the object's server.
      </remarks>
    </member>
    <member name="M:VO.OLEObject.Dispatch">
      <summary>
        Provide the prototype dispatcher for events within the system when the control has focus;  routing various events to their appropriate event handlers.
      </summary>
      <param name="oEvent">The event to be handled.</param>
      <seealso cref="T:VO.Event" />
      <returns>
        TRUE if the event was handled; otherwise, FALSE.
      </returns>
      <remarks>
        OLEObject:Dispatch() serves as an internal callback, dispatching events to various event handlers.  It should never be necessary to call this method directly.  Instead, you can write your own Dispatch() method for derived classes if you want to handle additional events.  Usually the derived class Dispatch() should call SUPER:Dispatch() to support the inherited event handling.
      </remarks>
    </member>
    <member name="M:VO.OLEObject.DoVerb">
      <summary>
        Exercise an OLE object's verb.
      </summary>
      <param name="iVerb">The verbs numerical ID.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        A OLE object usually supports several actions (called verbs) which a user can perform on the object.  An AVI object, for example, can support a Play and an Edit verb.  The object's verbs can be invoked via the objects verb menu or directly by calling OLEObject:DoVerb().
      </remarks>
    </member>
    <member name="M:VO.OLEObject.ExportToStorage">
      <summary>
        Exports an OLE object to a user-managed storage file.
      </summary>
      <param name="cFileName">The name of the storage file.</param>
      <param name="cStorageName">The name of the storage.</param>
      <example>
        The following example is from the OLE Container application in \CAVO25\SAMPLES\OLE\CONT:
        <code language="X#">
          METHOD FileSave() CLASS Container
           LOCAL oOle AS OBJECT
           LOCAL oOD AS SaveAsDialog
           LOCAL i AS INT
           LOCAL s AS STRING
           (oOD := SaveAsDialog{SELF, "*.CDF"}):Show()
           s := oOD:FileNAme
          IF !Empty(oOD:FileName)
          SELF:Caption := oOD:FileName
          FOR i:= 1 TO ALen(aOLEObjects)
               oOle := aOLEObjects[i]
               oOle:ExportToStorage(oOd:FileName, "CONTAINEROBJECT_"+AllTrim(AsString(i)))
             NEXT
           ENDIF
        </code></example>
    </member>
    <member name="P:VO.OLEObject.HyperLabel">
      <summary>
        The HyperLabel object for the OLE object.
      </summary>
      <value>The HyperLabel object for the OLE object.</value>
    </member>
    <member name="M:VO.OLEObject.ImportFromStorage">
      <summary>
        Imports an OLE object from a user-managed storage file.
      </summary>
      <param name="cFileName">The name of the storage file.</param>
      <param name="cStorageName">The name of the storage.</param>
      <example>
        The following example is from the OLE Container application in \CAVO25\SAMPLES\OLE\CONT:
        <code language="X#">
          METHOD FileLoad() CLASS ContainerShell
           LOCAL oOle AS DraggableOleObject
           LOCAL oOD AS OpenDialog
           LOCAL aStgNames AS ARRAY
           LOCAL i AS INT
           LOCAL oCont AS Container
          (oOD := OpenDialog{SELF, "*.CDF"}):Show()
          aStgNames := {}
          IF (!Empty(oOD:FileName) .and. GetStorageNames(oOD:FileName, aStgNames))
           oCont := SELF:FileNew()
           oCont:Caption := oOD:FileName
             IF (oCont != NULL_OBJECT)
           FOR i:=1 TO ALen(aStgNames)
           	    oOle := DraggableOleObject{oCont}
                 IF (oOle:ImportFromStorage(oOD:Filename, aStgNames[i]))
           	      oCont:SetupOLEObject(oOle, NIL, TRUE)
           		  ELSE
                 oOle:Destroy()
                 ENDIF
           	  NEXT
           	ENDIF
           ENDIF
        </code></example>
    </member>
    <member name="P:VO.OLEObject.IsInPlaceActive">
      <summary>
        A logical value indicating the activation status of the associated OLE object.
      </summary>
      <value>A logical value indicating the activation status of the associated OLE object.</value>
    </member>
    <member name="P:VO.OLEObject.LongName">
      <summary>
        The container application can ask the OLE object for long and short versions of the object's name, as well as its server's name.  OLEObject:LongName returns the long version of the object's name.
      </summary>
      <value>The container application can ask the OLE object for long and short versions of the object's name, as well as its server's name.  OLEObject:LongName returns the long version of the object's name.</value>
    </member>
    <member name="M:VO.OLEObject.No">
      <summary>
        Provide a general error interception that is automatically called whenever a reference is made to a non-existent method.
        <br />Important!  NoMethod() should not be called directly; it is called by the system for handling invalid references.
      </summary>
    </member>
    <member name="M:VO.OLEObject.NoIVarGet">
      <summary>
        Provide a general error interception that is automatically called whenever an access reference is made to a non-existent access property.
        <br />Important!  NoIVarGet() should not be called directly; it is called by the system for handling invalid references.
      </summary>
      <param name="symIVar">The symbolic name of the variable that was referenced.</param>
    </member>
    <member name="M:VO.OLEObject.NoIVarPut">
      <summary>
        Provide a general error interception that is automatically called whenever an assignment reference is made to a non-existent assign property.
        <br />Important!  NoIVarPut() should not be called directly; it is called by the system for handling invalid references.
      </summary>
      <param name="symIVar">The symbolic name of the variable that was referenced.</param>
      <param name="uValue">The value to be assigned.</param>
    </member>
    <member name="P:VO.OLEObject.ReadOnly">
      <summary>
        A logical value that is TRUE if the OLE object is read-only.  A read-only object cannot be edited by the user at runtime.  The default value for this property is FALSE.
      </summary>
      <value>A logical value that is TRUE if the OLE object is read-only.  A read-only object cannot be edited by the user at runtime.  The default value for this property is FALSE.</value>
    </member>
    <member name="M:VO.OLEObject.Redraw">
      <summary>
        Cause the OLE object to redraw itself.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.OLEObject.Repaint">
      <summary>
        Invalidate the OLE object so that an ExposeEvent is sent to the object.
      </summary>
      <remarks>
        The ExposeEvent triggers a redraw of the OLEObject container and its contained OLE object.
      </remarks>
    </member>
    <member name="M:VO.OLEObject.SaveToDBStorage">
      <summary>
        Save an OLE object into a database storage.
      </summary>
      <param name="oOLEDBStorage">The OLEDBStorage object to use for the save operation.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        X# supports the ability to store an OLE object in a DBF database.  To assign a new value to the OLEObject container, you pass an OLEDBStorage object to OLEObject:CreateFromDBStorage().  To save the persistent information of an OLE object in the database, you pass an OLEDBStorage object to OLEObject:SaveToDBStorage().  You usually get the OLEDBStorage object as a result of a FieldGet() call.
      </remarks>
      <example>
        The following code shows how to load an OLE object form a database and save it back again:
        <code language="X#">
          LOCAL oDBStg AS OLEDBStorage
          oDBStg := FieldGet(FieldPos(#PaintObject))
          oOLEContainer:CreateFromDBStorage(oDBStg)
          // do some editing with the OLE object
          oOLEContainer:SaveToDBStorage(oDBStg)
        </code></example>
    </member>
    <member name="P:VO.OLEObject.ServerName">
      <summary>
        The container application can ask the OLE object for long and short versions of the object's name, as well as its servers name.  OLEObject:ServerName returns the name of the OLE object's server.
      </summary>
      <value>The container application can ask the OLE object for long and short versions of the object's name, as well as its servers name.  OLEObject:ServerName returns the name of the OLE object's server.</value>
    </member>
    <member name="M:VO.OLEObject.SetHostNames">
      <summary>
        Set the name of the container application and the current document.
      </summary>
      <param name="cApp">The name of the container application.</param>
      <param name="cDoc">The name of the current document.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        These names are used during out-of-place editing in the server's window to identify the OLE object container application and the document in which it is located.
      </remarks>
    </member>
    <member name="P:VO.OLEObject.ShortName">
      <summary>
        The container application can ask the OLE object for long and short versions of the object's name, as well as its servers name.  OLEObject:ShortName returns the short version of the object's name.
      </summary>
      <value>The container application can ask the OLE object for long and short versions of the object's name, as well as its servers name.  OLEObject:ShortName returns the short version of the object's name.</value>
    </member>
    <member name="M:VO.OLEObject.UpdateTools">
      <summary>
        Update the container's toolbars.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Whenever an OLE object is in-place active, the server's toolbars can replace the X# container application's toolbars.  In response to a resizing of the container application, OLEObject:UpdateToolbars() causes the OLE object server to rearrange its toolbars.
      </remarks>
      <example>
        The following code shows how a X# container application uses OLEObject:UpdateToolbars() in response to a resize event:
        <code language="X#">
          METHOD Resize(oResizeEvent) CLASS MyShell
          LOCAL oOLE AS OBJECT
          LOCAL oChild AS MyChild
          SUPER:Resize(oResizeEvent)
          oChild := SELF:GetActiveMDIChildObject()
          IF oChild != NULL_OBJECT
          oOLE := oChild:GetActiveOLEObject()
          IF oOLE != NULL_OBJECT
          oOLE:UpdateTools()
          ENDIF
          ENDIF
        </code></example>
    </member>
    <member name="T:VO.OLEShellWindow">
      <summary>
        Create a specialized shell window that includes support for in-place active OLE objects.
      </summary>
      <remarks>
        Note 	The functionality in the methods of this class has now been incorporated into the ShellWindow Class. The class name is retained for backward compatibility only.
      </remarks>
    </member>
    <member name="M:VO.OLEShellWindow.#ctor(XSharp.__Usual)">
      <summary>
        Note -

        Construct an OLE shell window.
      </summary>
      <param name="oOwner">The window that owns the OLE shell window.</param>
    </member>
    <member name="M:VO.OLEShellWindow.Dispatch(XSharp.__Usual)">
      <summary>
        Note -

        Provide the prototype dispatcher for events within the system when the OLE shell window has focus, routing various events to their appropriate event handlers.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oEvent">The event to be handled.</param>
      <seealso cref="T:VO.Event" />
      <returns>
        TRUE if the event was handled; otherwise, FALSE.
      </returns>
      <remarks>
        This method serves as an internal callback, dispatching events to various event handlers.  It should never be necessary to call this method directly.  Instead, you can write your own Dispatch() method for derived classes if you want to handle additional events.  Usually the derived class Dispatch() should call SUPER:Dispatch() to support the inherited event handling.
        In addition to the functionality provided by the ShellWindow base class, the implementation for the OLEShellWindow class also includes support for handling in-place active OLE objects. For example, whenever the shell window is resized, it automatically asks the activated OLE objects to update their toolbars.
      </remarks>
    </member>
    <member name="T:VO.OpenDialog">
      <summary>
        Present the user with a standard "file open" dialog box.
      </summary>
      <remarks>
        This type of dialog box presents the user with a list of file names.  It allows the user to select a name from the list (or type the name of an existing file), and provides the ability to specify drive and/or directory if necessary.
        If a user enters a file name that does not already exist, Windows displays a modal dialog box indicating that the file name does not exist for the specified drive, directory, and file type.
      </remarks>
    </member>
    <member name="M:VO.OpenDialog.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a standard "file open" dialog box.
      </summary>
      <param name="oOwnWnd">The window that owns the dialog box.</param>
      <param name="cInitPath">The name of the file that is initially selected when the dialog is first shown (i.e., *.* or *.TXT).  The default is *.*, which means all files and their extensions.</param>
      <param name="dwFlag">Reserved for future use.</param>
      <remarks>
        <note type="tip">
          If the :SetFilter( ) method is going to be used, cFileName must be specified as "" because without this the filter will have no effect and the default of "*.*" will take effect so as to show all files.
        </note>
      </remarks>
    </member>
    <member name="T:VO.OrderSpec">
      <summary>
        OrderSpec class was designed to model index information at the order level — not file level — and complement the DBFileSpec class.
      </summary>
      <remarks>
        Instantiation requires a DBFileSpec object.  Each order will require a separate OrderSpec object.  
        For single-order index formats such as DBFNTX, this is equivalent to one OrderSpec object per physical file.   
        For multi-order index formats such as DBFCDX, this would mean multiple OrderSpec objects for one physical file. 
        For more information on the conditional index order instance variables, refer to the OrdCondSet() function.
      </remarks>
    </member>
    <member name="M:VO.OrderSpec.#ctor(XSharp.__Usual)">
      <summary>
        Instantiates an OrderSpec object using an existing DBFileSpec object.
      </summary>
      <param name="oDBFS">An existing DBFileSpec object.</param>
      <returns>
        An OrderSpec object.
      </returns>
      <example>
        <code language="X#">
          oDB := DBFileSpec{"C:\TEST\CUSTOMER.DBF"}
          oOrd1 := OrderSpec{oDB}
        </code>
      </example>
    </member>
    <member name="P:VO.OrderSpec.Add">
      <summary>
        A logical value specifying whether open orders should remain open while the new order is being created.
      </summary>
      <value>A logical value specifying whether open orders should remain open while the new order is being created.</value>
      <remarks>
        A logical value specifying whether open orders should remain open while the new order is being created.  TRUE specifies that they should remain open.  FALSE specifies that all open orders should be closed.  The default is FALSE.
      </remarks>
    </member>
    <member name="P:VO.OrderSpec.All">
      <summary>
        A logical value determining whether the record scope is for all records in the DBF (TRUE)
      </summary>
      <value>A logical value determining whether the record scope is for all records in the DBF (TRUE)</value>
      <remarks>
        Used for a conditional index.  A logical value determining whether the record scope is for all records in the DBF (TRUE).  Defaults to FALSE so that OrderSpec:Records and OrderSpec:Interval can be used.
      </remarks>
    </member>
    <member name="P:VO.OrderSpec.AutoOpen">
      <summary>
        Determines if this index file will open when the DBF file is opened.
      </summary>
      <value>Determines if this index file will open when the DBF file is opened.</value>
    </member>
    <member name="P:VO.OrderSpec.AutoOrder">
      <summary>
        Determines if this index file will set the first order when it is opened.
      </summary>
      <value>Determines if this index file will set the first order when it is opened.</value>
    </member>
    <member name="P:VO.OrderSpec.AutoShare">
      <summary>
        Determines if this index file will be opened in the same share mode as the DBF file.
      </summary>
      <value>Determines if this index file will be opened in the same share mode as the DBF file.</value>
    </member>
    <member name="P:VO.OrderSpec.Current">
      <summary>
        A logical value determining whether only those records in the controlling order and in the scope are included in this order.  Defaults to FALSE so that all records in DBF are included.
      </summary>
      <value>A logical value determining whether only those records in the controlling order and in the scope are included in this order.  Defaults to FALSE so that all records in DBF are included.</value>
    </member>
    <member name="P:VO.OrderSpec.Custom">
      <summary>
        A logical value determining if this is to be a custom order.  Valid for RDDs that support custom orders.  Defaults to FALSE for a non-custom order.
      </summary>
      <value>A logical value determining if this is to be a custom order.  Valid for RDDs that support custom orders.  Defaults to FALSE for a non-custom order.</value>
    </member>
    <member name="P:VO.OrderSpec.DBF">
      <summary>
        The DBFileSpec object with which this OrderSpec object is associated.
      </summary>
      <value>The DBFileSpec object with which this OrderSpec object is associated.</value>
    </member>
    <member name="P:VO.OrderSpec.Descend">
      <summary>
        A logical value determining if this is to be a descending order.  Defaults to FALSE for ascending order.
      </summary>
      <value>A logical value determining if this is to be a descending order.  Defaults to FALSE for ascending order.</value>
    </member>
    <member name="P:VO.OrderSpec.EvalBlock">
      <summary>
        The code block to be evaluated based upon OrderSpec:Interval.  The code block should return a TRUE value.
      </summary>
      <value>The code block to be evaluated based upon OrderSpec:Interval.  The code block should return a TRUE value.</value>
    </member>
    <member name="P:VO.OrderSpec.FileName">
      <summary>
        The drive, path and file name of the order.  The drive and path default to either the current window's drive and path or to the drive and path used in SetDefault(), if omitted.
      </summary>
      <value>The drive, path and file name of the order.  The drive and path default to either the current window's drive and path or to the drive and path used in SetDefault(), if omitted.</value>
    </member>
    <member name="P:VO.OrderSpec.ForBlock">
      <summary>
        The FOR condition code block to build this order.
      </summary>
      <value>The FOR condition code block to build this order.</value>
    </member>
    <member name="P:VO.OrderSpec.ForCond">
      <summary>
        The FOR condition string used to build this order.
      </summary>
      <value>The FOR condition string used to build this order.</value>
    </member>
    <member name="P:VO.OrderSpec.HPLock">
      <summary>
        A logical value determining whether the DBFNTX RDD will use the HPLocking scheme for building this order.  The default is FALSE, i.e., no HPLocking.
      </summary>
      <value>A logical value determining whether the DBFNTX RDD will use the HPLocking scheme for building this order.  The default is FALSE, i.e., no HPLocking.</value>
    </member>
    <member name="P:VO.OrderSpec.Interval">
      <summary>
        An integer determining the interval for the execution of OrderSpec:EvalBlock during order building.
      </summary>
      <value>An integer determining the interval for the execution of OrderSpec:EvalBlock during order building.</value>
    </member>
    <member name="P:VO.OrderSpec.IsCond">
      <summary>
        A logical value indicating whether this is a conditional order.  This is assigned TRUE internally when any of the conditional ASSIGNs are assigned values and is not required to be assigned manually to create a conditional order.
      </summary>
      <value>A logical value indicating whether this is a conditional order.  This is assigned TRUE internally when any of the conditional ASSIGNs are assigned values and is not required to be assigned manually to create a conditional order.</value>
    </member>
    <member name="P:VO.OrderSpec.KeyInfo">
      <summary>
        The 1-D, 4-element array containing the structure of the OrderSpec object.
      </summary>
      <value>The 1-D, 4-element array containing the structure of the OrderSpec object.</value>
      <remarks>
        The 1-D, 4-element array containing the structure of the OrderSpec object.
        Each subarray is comprised of four elements, which contain the following order key information:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>ORD_KEYTYPE</term><description>Data type of index key.</description></item><item><term>ORD_KEYCOUNT</term><description>Number of keys included in this order.</description></item><item><term>ORD_KEYSIZE</term><description>Length of this order key.</description></item><item><term>ORD_KEYDEC</term><description>Number of decimals in this order</description></item></list></remarks>
    </member>
    <member name="P:VO.OrderSpec.LockOffSet">
      <summary>
        The current NTX locking offset as a numeric value.
      </summary>
      <value>The current NTX locking offset as a numeric value.</value>
    </member>
    <member name="P:VO.OrderSpec.NoOptimize">
      <summary>
        A logical value determining whether the FOR condition used to build this order should be optimized.  Valid for RDDs that support query optimizations.  Defaults to FALSE for no optimization.
      </summary>
      <value>A logical value determining whether the FOR condition used to build this order should be optimized.  Valid for RDDs that support query optimizations.  Defaults to FALSE for no optimization.</value>
    </member>
    <member name="M:VO.OrderSpec.OrderAdd(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Adds order information from an existing index file to the OrderSpec object and associates this OrderSpec object with the DBFileSpec object used for instantiation.
      </summary>
      <param name="oFS">The full path to the index file or a FileSpec object of the index file.</param>
      <param name="uOrder">The order name or numeric position if using multi-order files.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <example>
        The following examples illustrate several different types of orders you can add:
        <code language="X#">
          // add orders from a multi-order file:
          oDB := DBFileSpec{, "DBFCDX"}
          IF oDB:Find()
          oOrd1 := OrderSpec{oDB}
          oOrd2 := OrderSpec{oDB}
          oOrd3 := OrderSpec{oDB}
          oOrd1:OrderAdd("C:\TEST\customer.cdx", "FirstName")
          oOrd2:OrderAdd("C:\TEST\customer.cdx", "LastName")
          oOrd3:OrderAdd("C:\TEST\customer.cdx", "CustNum")
          ENDIF
          // add orders from single-order files:
          oDB := DBFileSpec{, "DBFNTX"}
          IF oDB:Find()
          oOrd1 := OrderSpec{oDB}
          oOrd2 := OrderSpec{oDB}
          oOrd3 := OrderSpec{oDB}
          oOrd1:OrderAdd("C:\TEST\cust1.ntx")
          oOrd2:OrderAdd("C:\TEST\cust2.ntx")
          oOrd3:OrderAdd("C:\TEST\cust3.ntx")
          ENDIF
        </code></example>
    </member>
    <member name="P:VO.OrderSpec.OrderBlock">
      <summary>
        The code block of the index key expression used to create this order.
      </summary>
      <value>The code block of the index key expression used to create this order.</value>
    </member>
    <member name="M:VO.OrderSpec.OrderCreate(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Create new orders, and if empty, fills in OrderSpec information and associates the created order with the DBFileSpec object.
      </summary>
      <param name="oFS">The full path to the target file or a FileSpec object of the target file.</param>
      <param name="cOrder">The order name.  Used for multi-order index files.</param>
      <param name="cKeyValue">A string of the index key expression.</param>
      <param name="cbKeyValue">A code block of the index key expression.</param>
      <param name="lUnique">A logical to determine if this is to be a unique order.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <example>
        The following examples illustrate several different types of orders you can create:
        <code language="X#">
          // create orders for a multi-order file:
          oDB := DBFileSpec{, "DBFCDX"}
          IF oDB:Find()
          oOrd1 := OrderSpec{oDB}
          oOrd2 := OrderSpec{oDB}
          oOrd3 := OrderSpec{oDB}
          oOrd1:OrderCreate("C:\TEST\customer.cdx", "FirstName", "FirstName")
          oOrd2:OrderCreate("C:\TEST\customer.cdx", "LastName", "LastName")
          oOrd3:OrderCreate("C:\TEST\customer.cdx", "CustNum", "CustNum")
          ENDIF
          // create orders for single-order files:
          oDB := DBFileSpec{, "DBFNTX"}
          IF oDB:Find()
          oOrd1 := OrderSpec{oDB}
          oOrd2 := OrderSpec{oDB}
          oOrd3 := OrderSpec{oDB}
          oOrd1:OrderCreate("C:\TEST\cust1.ntx", , "FirstName")
          oOrd2:OrderCreate("C:\TEST\cust2.ntx", , "LastName")
          oOrd3:OrderCreate"C:\TEST\cust3.ntx", , "CustNum")
          ENDIF
          // create some orders using instance variables for a multi-order file:
          oDB := DBFileSpec{, "DBFCDX"}
          IF oDB:Find()
          oOrd1 := OrderSpec{oDB}
          oOrd2 := OrderSpec{oDB}
          oOrd3 := OrderSpec{oDB}
          // create an order starting from record 3 and display the progress.
          oOrd1:FileName := "customer"
          oOrd1:OrderName := "FirstName"
          oOrd1:OrderExpr := "FirstName"
          oOrd1:OrderBlock := {| | _Field-&gt;FirstName }
          oOrd1:All := FALSE
          oOrd1:EvalBlock := {| | _Field-&gt;FirstName, Qout(RECNO()), TRUE}
          oOrd1:Start := 3
          oOrd1:Rest := TRUE
          // create a unique, descending order on lastname field
          oOrd2:FileName := "customer"
          oOrd2:OrderName := "LastName"
          oOrd2:OrderExpr := "LastName"
          oOrd2:OrderBlock := {| | _Field-&gt;LastName }
          oOrd2:Unique := TRUE
          oOrd2:DESCEND := TRUE
          // create a FOR condition based on firstnames with starting letter &gt; "M"
          oOrd3:FileName := "customer"
          oOrd3:OrderName := "FirstName"
          oOrd3:OrderExpr := "FirstName"
          oOrd3:OrderBlock := {| | _Field-&gt;FirstName }
          oOrd3:ForCond := "SubStr(_Field-&gt;FirstName, 1, 1) &gt; 'M'"
          oOrd3:ForBlock := {| | SUBSTR(_Field-&gt;FirstName, 1, 1) &gt; 'M' }
          oOrd1:OrderCreate( )
          oOrd2:OrderCreate( )
          oOrd3:OrderCreate( )
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.OrderSpec.OrderDelete(XSharp.__Usual)">
      <summary>
        Deletes orders from a multi-order file or a physical index file of a single-order file.  NULLs out OrderSpec object information in the OrderSpec object and the DBFileSpec object specific to this order.
      </summary>
      <param name="uOrder">The numeric position or order name of the order to be deleted.  Use order names unless the actual order position is known.  The default is the first order of the index file.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <example>
        <code language="X#">
          RDDSetDefault("DBFNTX")
          oDB := DBFileSpec{"C:\TEST\CUSTOMER.DBF"}
          oOrd1 := OrderSpec{oDB}
          oOrd2 := OrderSpec{oDB}
          oOrd3 := OrderSpec{oDB}
          oOrd1:OrderAdd("C:\TEST\CUST1.NTX")
          oOrd2:OrderAdd("C:\TEST\CUST2.NTX")
          oOrd3:OrderAdd("C:\TEST\CUST3.NTX")
          oOrd1:OrderDelete( )
          oOrd2:OrderDelete( )
          oOrd3:OrderDelete( )
        </code>
      </example>
    </member>
    <member name="P:VO.OrderSpec.OrderExpr">
      <summary>
        The string of the index key expression used to create this order.
      </summary>
      <value>The string of the index key expression used to create this order.</value>
    </member>
    <member name="P:VO.OrderSpec.OrderName">
      <summary>
        The order (tag) name for this order.  Used for creating multi-order order files (bags).
      </summary>
      <value>The order (tag) name for this order.  Used for creating multi-order order files (bags).</value>
    </member>
    <member name="P:VO.OrderSpec.Recno">
      <summary>
        The individual record number to be processed.  Defaults to zero (0) for all records.
      </summary>
      <value>The individual record number to be processed.  Defaults to zero (0) for all records.</value>
    </member>
    <member name="P:VO.OrderSpec.Records">
      <summary>
        The number of records to be processed starting from OrderSpec:Start.
      </summary>
      <value>The number of records to be processed starting from OrderSpec:Start.</value>
    </member>
    <member name="P:VO.OrderSpec.Rest">
      <summary>
        A logical value indicating that records are to be processed starting from OrderSpec:Start (TRUE).  Defaults to FALSE to process all records from the beginning of file.
      </summary>
      <value>A logical value indicating that records are to be processed starting from OrderSpec:Start (TRUE).  Defaults to FALSE to process all records from the beginning of file.</value>
    </member>
    <member name="P:VO.OrderSpec.Start">
      <summary>
        Determines the starting record number from which to start building this order.
      </summary>
      <value>Determines the starting record number from which to start building this order.</value>
    </member>
    <member name="P:VO.OrderSpec.StrictRead">
      <summary>
        A logical value determining whether the records will be read directly from disk during order creation.
      </summary>
      <value>A logical value determining whether the records will be read directly from disk during order creation.</value>
    </member>
    <member name="P:VO.OrderSpec.Unique">
      <summary>
        A logical value determining whether this order is to be a unique order (no duplicate keys).
      </summary>
      <value>A logical value determining whether this order is to be a unique order (no duplicate keys).</value>
    </member>
    <member name="P:VO.OrderSpec.WhileBlock">
      <summary>
        A WHILE condition code block used during the building of this order.
      </summary>
      <value>A WHILE condition code block used during the building of this order.</value>
    </member>
    <member name="T:VO.Pair">
      <summary>
        Provide the base class from which all X# objects containing ordered pairs of values are subclassed.
      </summary>
      <remarks>
        <br />Important!  Pair is an abstract class and should not be used directly — instead, use one of its subclasses, which include Dimension, Point, Range, and Selection.
      </remarks>
      <example>
        In this example, fractions are represented as ordered pairs of integers:
        <code language="X#">
          CLASS Fraction INHERIT Pair
          HIDDEN Num
          HIDDEN Denom
          METHOD Init(nVal1,nVal2) CLASS Fraction
          SUPER:Init(nVal1,nVal2)
          Num := nVal1
          Denom := nVal2
          METHOD Numerator() CLASS Fraction
          RETURN SELF:Num
          METHOD Denominator() CLASS Fraction
          RETURN SELF:Denom
        </code></example>
    </member>
    <member name="M:VO.Pair.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a pair.
      </summary>
      <param name="uInt1">The first value of the pair.  The default is 0.</param>
      <param name="uInt2">The second value of the pair.  The default is 0.</param>
    </member>
    <member name="T:VO.PaletteDialog">
      <summary>
        Present the user with a standard color palette dialog box, allowing the user to define custom colors.
      </summary>
      <remarks>
        This type of dialog box presents the user with a palette of available colors as a series of "boxes," allowing the user to select a color by clicking a box.  It also allows the user to create and select their own custom colors.
      </remarks>
    </member>
    <member name="M:VO.PaletteDialog.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a standard color palette dialog.
      </summary>
      <param name="uOwner">The window that owns the palette dialog.</param>
      <param name="oColor">The color initially selected for the PaletteDialog object.  The default is black.  (Refer to the Color:Init() method for details on specifying a color.)</param>
    </member>
    <member name="T:VO.Pen">
      <summary>
        Create a pen, which can be used to draw lines in a particular color, style, and width.  Pens are used by the Window:LineTo() method and the DrawObject hierarchy.
      </summary>
      <remarks>
        X# provides a set of predefined pens, which are specified in the Pen:Init() method (the default color and width is used).  In addition, if desired, you can also create a brush by specifying a color, line style, and width.
        Each window has a current pen, which can be set or changed using the Window:Pen property.  A window's pen is used in subsequent line and rectangle drawing operations, and should not be deleted while it is the current selection.
      </remarks>
      <example>
        The following example creates a pen and draws a line:
        <code language="X#">
          oMyPen := Pen{Color{COLORRED}, LINESOLID, 1}
          oOldPen := oMyWin:Pen
          oMyWin:Pen := oMyPen
          oMyWin:MoveTo(Point{100,100})
          oMyWin:LineTo(Point{200,100})
          oMyWin:Pen := oOldPen
        </code></example>
    </member>
    <member name="M:VO.Pen.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a pen.
      </summary>
      <param name="uColor">The pen's color.  The default is black.  (Refer to the Color:Init() method for details on specifying a color.)</param>
      <param name="uLineStyle">
        The pen's style, specified as one of the following constants:
      </param>
      <param name="uWidth">The pen's width, in canvas coordinates.  The default is 1.</param>
      <remarks>
        <pre>
          Constant			Description
          LINECLEAR			Invisible, which can be used to simplify the program logic.  
          This is a shortcut to changing a point position without calling the MoveTo() and LineTo()
          functions (as in the code example under Pen class).
          LINEDASHDOT		Alternating dash/dot pattern.
          LINEDASHDOTDOT	A repeating sequence of a dash followed by two dots.
          LINEDASHED		Dashes.
          LINEDOTTED		Dots.
          LINESOLID			A continuous line.  This is the default.
        </pre>
      </remarks>
    </member>
    <member name="M:VO.Pen.Destroy">
      <summary>
        Provide a method to de-instantiate a Pen object.
      </summary>
      <remarks>
        This method can be used when a Pen object is no longer needed.  Pen:Destroy() de-instantiates the Pen object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.Pen.Handle(XSharp.__Usual)">
      <summary>
        Return the handle for a pen.
      </summary>
      <param name="uType">The type of handle required.  0 is the only supported option and is the default if &lt;nHandleType&gt; is omitted.</param>
      <returns>
        A handle describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
      </remarks>
    </member>
    <member name="T:VO.PieObject">
      <summary>
        Construct a PieObject object.
      </summary>
    </member>
    <member name="M:VO.PieObject.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a PieObject object.
      </summary>
      <param name="oPoint">The position of the PieObject object in canvas coordinates.</param>
      <param name="oDimension">The dimension of the PieObject object in canvas coordinates.</param>
      <param name="oPen">The pen used to draw the PieObject object.  By default, the current pen is used.</param>
      <param name="oBrush">The brush used to fill the PieObject object.  By default, the current brush is used.</param>
      <param name="iStartAngle">The starting angle of the pie shape in degrees (0 to 360).</param>
      <param name="iEndAngle">The ending angle of the pie shape in degrees (0 to 360).</param>
    </member>
    <member name="M:VO.PieObject.Draw">
      <summary>
        Draw a PieObject object which represents a pie-shaped portion of an ellipse.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <remarks>
        This method should not be invoked directly in the application code--it is invoked in X# by Window:Draw().
      </remarks>
      <example>
        To draw a PieObject object, call Window:Draw() with the PieObject object as its argument.  The window does the drawing by asking each object to draw itself--for example:
        <code language="X#">
          METHOD Expose(oEvent) CLASS MyWindow
          LOCAL oPie AS OBJECT
          oPie := PieObject{Point{10,10},;
          Dimension{20,40},;
          Pen{Color{COLORBLACK}},;
          Brush{Color{COLORRED}}, 0, 180}
          SELF:Draw(oPie)
        </code></example>
    </member>
    <member name="T:VO.Point">
      <summary>
        Create a point, which is used to describe a location on the canvas of a window.  
      </summary>
      <remarks>
        The Point class does not interpret the coordinates — whether they are screen or canvas coordinates is context-dependent.
      </remarks>
      <example>
        For an example using the Point class, refer to the ResourceFile class example.
      </example>
    </member>
    <member name="M:VO.Point.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a point.
      </summary>
      <param name="nX">The x coordinate of the point.  The default is 0.</param>
      <param name="nY">The y coordinate of the point.  The default is 0.</param>
    </member>
    <member name="M:VO.Point.ConvertToScreen(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oWindow">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.Point.X">
      <summary>
        An integer representing this point's x coordinate.
      </summary>
      <value>An integer representing this point's x coordinate.</value>
    </member>
    <member name="P:VO.Point.Y">
      <summary>
        An integer representing this point's y coordinate.
      </summary>
      <value>An integer representing this point's y coordinate.</value>
    </member>
    <member name="T:VO.Pointer">
      <summary>
        Create a mouse cursor, which is used to visually represent the  mouse in a window.
      </summary>
      <remarks>
        X# provides a set of predefined pointers, defined in Pointer:Init().  In addition, if desired, you can also create pointers from resource entities.
        Each window can have its own pointer, and various pointer characteristics can be set, changed, or interrogated.  As the pointer moves from the canvas area of one window to another, the GUI changes the pointer representation to that of the new window.
        Tip:  In X#, the class Pointer corresponds to a mouse cursor; use class Cursor to create text cursors.
      </remarks>
      <example>
        The following example provides an application window with a custom cursor:
        <code language="X#">
          CLASS MyTopAppWin INHERIT TopAppWindow
          METHOD Init CLASS MyTopAppWin
          SUPER:Init()
          SELF:Pointer := Pointer{IDC_APPCURSOR}
          RESOURCE IDC_APPCURSOR CURSOR app.cur
        </code>

        In Windows, pointers are sometimes called cursors.  You can create a pointer in a resource entity.
      </example>
    </member>
    <member name="M:VO.Pointer.#ctor(XSharp.__Usual)">
      <summary>
        Load a pointer from a resource entity.
      </summary>
      <param name="xResourceID">
        The resource ID of the desired pointer.
        If &lt;kResourceID&gt; is specified, use one of the constants listed below:
      </param>
      <remarks>
        <list>
          <item>
            <term>Pointer</term>
            <description>Description</description>
          </item>
          <item>
            <term>POINTERARROW</term>
            <description>A pointer commonly used for selecting and pointing at objects.  This is the default.</description>
          </item>
          <item>
            <term>POINTERCROSSHAIRS</term>
            <description>A pointer commonly used for selecting and drawing graphic objects.</description>
          </item>
          <item>
            <term>POINTERFOURARROW</term>
            <description>A pointer commonly used for moving objects.</description>
          </item>
          <item>
            <term>POINTERHOURGLASS</term>
            <description>A pointer commonly used to indicate a delay.</description>
          </item>
          <item>
            <term>POINTERIBEAM</term>
            <description>A pointer commonly used for text entry.</description>
          </item>
          <item>
            <term>POINTERICON</term>
            <description>A pointer used for moving icons.</description>
          </item>
          <item>
            <term>POINTERUPARROW</term>
            <description>A pointer commonly used to drag a selection to a new location and "drop" or insert it.</description>
          </item>
        </list>
        <note type="tip">The icon specified by the POINTERICON resource ID takes on the appearance of the icon being moved.</note>
      </remarks>
    </member>
    <member name="M:VO.Pointer.Confine(XSharp.__Usual)">
      <summary>
        Confine the movement of this pointer to a given set of screen coordinates.
      </summary>
      <param name="oRect">The bounding box representing the set of screen coordinates in which the pointer can move.</param>
    </member>
    <member name="M:VO.Pointer.Destroy">
      <summary>
        Provide a method to de-instantiate a Pointer object.
      </summary>
      <remarks>
        This method can be used when a Pointer object is no longer needed.  Pointer:Destroy() de-instantiates the Pointer object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.Pointer.Handle">
      <summary>
        Return the handle for a pointer.
      </summary>
      <param name="nHandleType">The type of handle required.  0 is the only supported option and is the default if &lt;nHandleType&gt; is omitted.</param>
      <returns>
        A handle describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
      </remarks>
    </member>
    <member name="M:VO.Pointer.Hide">
      <summary>
        Hide this pointer so it is not visible.  Hide a control so it is not visible (until a subsequent call to Pointer:Show()).
      </summary>
      <remarks>
        Multiple calls to Pointer:Hide() require multiple calls to Pointer:Show() before the pointer is redisplayed.
      </remarks>
    </member>
    <member name="P:VO.Pointer.Position">
      <summary>
        A point representing the position of this pointer on the window, in screen coordinates.
      </summary>
      <value>A point representing the position of this pointer on the window, in screen coordinates.</value>
      <remarks>
        A point representing the position of this pointer on the window, in screen coordinates.
        Alternatively, you can use the MouseMove() or MouseDrag() event handlers of class Window and use Where() to get the location of the pointer in screen coordinates.
      </remarks>
    </member>
    <member name="M:VO.Pointer.Show">
      <summary>
        Display a pointer so it is visible.
      </summary>
      <remarks>
        By default, pointers are always visible until hidden, so there is no need to call the Pointer:Show() method unless Pointer:Hide() was previously called.
        <note type="tip">Multiple calls to Pointer:Hide() require multiple calls to Pointer:Show() before the pointer is redisplayed.</note></remarks>
    </member>
    <member name="T:VO.Printer">
      <summary>
        Create an object that represents a single print job.
      </summary>
      <remarks>
        It is essential to check the validity of a Printer object — using Printer:IsValid() — before using it.
        To use a printer, the application should call Printer:Start(), which repeatedly calls Printer:PrinterExpose() for each page printed until the final page, in which it returns FALSE.  Printer:Start() returns when the print job is finished.
        You can also:
        Determine the size of the page using Window:CanvasArea and Window:WindowArea to return the size of the printable area and total page size, respectively
        Scale the printout using Window:Size
        Determine the origin using Window:Origin (for example, to create margins)
        X# will only print the correct font if it exists for your printer; otherwise, the font that is most similar is used.
        Printing is done in printer coordinates, which are device dependent.  Use the methods described here to scale and size your printout.  Also note that for business printing, such as management reports, invoices, and notification letters, it is usually more convenient to design a report with the Report Editor and then run the report using the ReportQueue class.  For more information, refer to the Programmer's Guide.
      </remarks>
      <example>
        The following example prints the text "Hello World":
        <code language="X#">
          METHOD PrinterExpose(oPEE) CLASS PrinterClass
          SELF:TextPrint("Hello World",Point{30,30})
          RETURN FALSE			// Nothing more to print
          CLASS PrinterClass INHERIT Printer
          METHOD Init() CLASS PrinterClass
          SUPER:Init()
          RETURN SELF
          METHOD MenuCommand(oMCE) CLASS StandardShellWindow
          LOCAL oPrinter  AS PrinterClass
          IF(oMCE:ItemID = ;
          IDM_EMPTYSHELLMENU_FILE_PRINT_ID)
          // File Print menu item ID
          oPrinter := PrinterClass{}
          IF(oPrinter:IsValid())
          oPrinter:Start()
          oPrinter:Destroy()
          ENDIF
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.Printer.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a printer job.
      </summary>
      <param name="cJobname">The name passed to Print Manager, a Windows application, to identify the print job.  If omitted, the default is NULL_STRING.</param>
      <param name="oDevice">The printing device to use.  If omitted, the default is the currently selected printer installed by the user through Windows.</param>
    </member>
    <member name="M:VO.Printer.Abort">
      <summary>
        Instruct the printer to abort the current print job.
      </summary>
      <remarks>
        Typically, you would create and display a dialog before starting the print job.  If the user presses a push button on the dialog window to cancel the job, the Window:ButtonClick() event handler would invoke this method.
      </remarks>
      <example>
        This example displays a dialog and starts a print job.  If the Abort push button is pressed, the Window:ButtonClick() event handler aborts the job:
        <code language="X#">
          CLASS AbortDialog INHERIT DialogWindow
          HIDDEN oPrintJob AS OBJECT
          METHOD Init(oWindow,oPrinter) CLASS AbortDialog
          SUPER:Init(oWindow,ResourceID{IDD_ABORT})
          oPrintJob := oPrinter
          METHOD ButtonClick(oControlEvent) CLASS AbortDialog
          oPrintJob:Abort()
          SELF:EndDialog(1)
          METHOD FilePrint() CLASS TopAppWindow
          oPrinter := Printer{}
          IF(oPrinter:IsValid())
          oDialog := AbortDialog{SELF,oPrinter}
          oDialog:Show()
          oPrinter:Start()
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.Printer.Aborted">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.Printer.BeginDoc">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Printer.CanvasArea">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.Printer.Destroy">
      <summary>
        Provide a method to de-instantiate a Printer object.
      </summary>
      <remarks>
        This method can be used when a Printer object is no longer needed.  Printer:Destroy() de-instantiates the Printer object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.Printer.Handle(XSharp.__Usual)">
      <summary>
        Return the handle for a printer.
      </summary>
      <param name="ServiceID">The type of handle required.  0 is the only supported option and is the default if &lt;ServiceID&gt; is omitted.</param>
      <returns>
        A handle describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
      </remarks>
    </member>
    <member name="M:VO.Printer.Idle">
      <summary>
        Instruct the system to process events while printing.
      </summary>
      <remarks>
        Printer:Idle() causes the system to continually check for other messages and process them, thus providing "background printing" functionality.  If this method is not called, the system halts until the print operation is complete.
      </remarks>
    </member>
    <member name="M:VO.Printer.IsValid">
      <summary>
        Determine if a printer is valid.
      </summary>
      <returns>
        TRUE if valid; otherwise, FALSE.
      </returns>
      <remarks>
        It is essential to check the validity of a Printer object before using it.
      </remarks>
    </member>
    <member name="F:VO.Printer.lprAbort">
      <exclude />
    </member>
    <member name="M:VO.Printer.NewPage">
      <summary>
        Direct the attached printer to eject to a new page.
      </summary>
    </member>
    <member name="M:VO.Printer.PrinterError(XSharp.__Usual)">
      <summary>
        Called if a printer error occurs.  PrintErrorEvent is interrogated to identify the type of error has occurred.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oPerr">The printer error event that is being handled.</param>
      <returns>
        TRUE if the print job is to be retried (i.e., the error is to be ignored); FALSE if the print job is to be canceled.
      </returns>
    </member>
    <member name="M:VO.Printer.PrinterExpose(XSharp.__Usual)">
      <summary>
        Invoked for each page (or part of a page) of the print job whenever it needs repainting.
      </summary>
      <param name="oPrinterExposeEvt">The expose event that describes which page (or part of a page) of the print job needs painting.</param>
      <returns>
        TRUE if there is another page (or part of a page) to print;  FALSE if the last page has been printed.
      </returns>
    </member>
    <member name="M:VO.Printer.Start(XSharp.__Usual)">
      <summary>
        Start a print job or contiguous portion of a print job.
      </summary>
      <param name="oRange">The range of pages to be printed.  For example, to print pages 5 to 10 inclusive, specify Start(Range{5,10}).  If omitted, Printer:PrinterExpose() is called until FALSE is returned.</param>
    </member>
    <member name="P:VO.Printer.WindowArea">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.PrinterErrorEvent">
      <summary>
        Provide information about a PrinterErrorEvent, used to describe errors that occur during a print job (for example, insufficient memory or disk space).
      </summary>
      <remarks>
        By default, the event handler displays a text box for the "no disk space" message.  The error handler does not abort automatically, but prompts the user to abort or retry.  If the user retries, the system returns control to the Print Manager.  However, the device drivers of some printers can prohibit such a message.
        All other errors should cause a printer abort.
      </remarks>
    </member>
    <member name="M:VO.PrinterErrorEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.PrinterErrorEvent.ErrorType">
      <summary>
        One of the following events that are passed to the Printer:Expose() method, when the system requires another page to be painted and sent to the Print Manager:
      </summary>
      <value>One of the following events that are passed to the Printer:Expose() method, when the system requires another page to be painted and sent to the Print Manager:</value>
      <remarks>
        One of the following events that are passed to the Printer:Expose() method, when the system requires another page to be painted and sent to the Print Manager:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>PRINTERERRORFATALDEVICEERROR</term><description>The printer device could not be created or initialized correctly.</description></item><item><term>PRINTERERRORGENERALERROR</term><description>A general unidentifiable (system-specific) error has occurred.</description></item><item><term>PRINTERERRORNODISKSPACE</term><description>The Window's Print Manager has run out of disk space to complete the job.  This is not necessarily fatal.</description></item><item><term>PRINTERERRORNOMEMSPACE</term><description>Insufficient memory to complete the job.</description></item><item><term>PRINTERERRORUSERABORT</term><description>The user or application has aborted the job.</description></item></list></remarks>
    </member>
    <member name="T:VO.PrinterExposeEvent">
      <summary>
        Provides facilities for determining the number of the page to be painted, as well as the area of the page to be painted.
      </summary>
      <remarks>
        Some printer drivers may request the page to be painted in segments ("banding printer").  PrinterExposeEvent:ExposedArea defines the area of the page to be painted, in the form of a BoundingBox object, in printer coordinates.  If the full page is requested, the bounding box is equal to the full page size.
      </remarks>
    </member>
    <member name="M:VO.PrinterExposeEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.PrinterExposeEvent.ExposedArea">
      <summary>
        A bounding box representing the area of the page to be printed, in printer coordinates.
      </summary>
      <value>A bounding box representing the area of the page to be printed, in printer coordinates.</value>
      <remarks>
        A bounding box representing the area of the page to be printed, in printer coordinates.  Windows measures the size or portion of the page to be printed as what is contained in a bounding box.  This is usually a full page, but on printers with limited memory (that can't print a full page), it is the area of the page to be printed.
      </remarks>
    </member>
    <member name="P:VO.PrinterExposeEvent.PageNo">
      <summary>
        A numeric value representing the number of the page to be painted.
      </summary>
      <value>A numeric value representing the number of the page to be painted.</value>
    </member>
    <member name="T:VO.PrintingDevice">
      <summary>
        Create an object that allows you to set up the printing device for an application.  It also allows you to invoke the standard dialog box to configure a default printer and change values, such as changing the page orientation or paper source.
      </summary>
    </member>
    <member name="M:VO.PrintingDevice.#ctor(XSharp.__Usual)">
      <summary>
        Construct a PrintingDevice object.
      </summary>
      <param name="uName">
        The comma-separated string indicating the printer driver to be used.  In Windows, this string should be given in the following form:
        &lt;PrinterInfo&gt;,&lt;PrinterDriver&gt;,&lt;Port&gt;
        For example, you might specify:
        'PostScript Printer,PSSCRIPT,LPT1:'
        If omitted, the default printer driver is used.
        NOTE: There are no spaces at the beginning or end of each part of this string. Spaces should only be used where they appear in the parameter.
      </param>
    </member>
    <member name="P:VO.PrintingDevice.Copies">
      <summary>
        Specifies the number of copies printed if the device supports multiple-page copies.
      </summary>
      <value>Specifies the number of copies printed if the device supports multiple-page copies.</value>
    </member>
    <member name="M:VO.PrintingDevice.Destroy">
      <summary>
        Provide a method to de-instantiate a PrintingDevice object.
      </summary>
      <remarks>
        This method can be used when a PrintingDevice object is no longer needed.  PrintingDevice:Destroy() de-instantiates the PrintingDevice object, and allows you to close and free any resources that were opened or created by the object without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="P:VO.PrintingDevice.Device">
      <summary>
        Specifies the printer device to be used.
      </summary>
      <value>Specifies the printer device to be used.</value>
    </member>
    <member name="M:VO.PrintingDevice.DeviceCapabilities(XSharp.__Usual)">
      <summary>
        Obtain information about the capabilities printing device.
      </summary>
      <param name="wCapability">
        The capability to be queried, specified by a Windows API device capability constant.  For example, you might specify:
        'DC_PAPERNAMES'
        If omitted, the default capability is used.
      </param>
      <returns>
        A usual variable containing a X# dynamic array or WORD.  A value represented by the constant CAPABILITY_NOT_AVAILABLE indicates that the attempt to retrieve the value was unsuccessful.  The return value varies according to the &lt;kCapability&gt;.  Refer to the Windows SDK topic on DeviceCapabilites for return values.  If the SDK indicates that the return value is an array or a point structure then the return value will contain a VO dynamic array; otherwise it will contain a word.
      </returns>
      <remarks>
        This method provides information about the capabilities of a printing device object.
      </remarks>
      <example>
        This is an example of a ListBox FillUsing method to populate the list box with a two dimensional  array containing available paper sizes.  The first dimension contains the display  values and the second the return values.
        <code language="X#">
          SELF:oPrint is assumed to be a Printer object
          METHOD FillPaperSizesListBox() CLASS; MyPrintReportWindow
          LOCAL aDisplayValues, aReturnValues, aListBoxValues;
          := {} AS ARRAY
          LOCAL 	i, wALen AS DWORD
          aDisplayValues :=;
          SELF:oPrint:PrintingDevice:DeviceCapabilities;
          (DC_PAPERNAMES)
          aReturnValues	:=;
          SELF:oPrint:PrintingDevice:DeviceCapabilities;
          (DC_PAPERS)
          wALen :=  ALen(aDisplayValues)
          FOR i := 1 UPTO wALen
          aAdd(aListBoxValues,;
          {aDisplayValues[i],;
          aReturnValues[i]})
          NEXT
          RETURN aListBoxValues
        </code>
        This example creates a Printer object using the default device driver.  Various device capabilities are queried and displayed.
        <code language="X#">
          LOCAL uValue			AS USUAL
          LOCAL oP, oPD	     AS OBJECT
          // Create Printer object using default device and
          // get reference to  PrintingDevice object
          oP := Printer{}
          oPD := oP:PrintingDevice
          // List names of available paper sizes
          uValue := oPD:DeviceCapabilities(DC_PAPERNAMES)
          QOut("Show "+"DC_PAPERNAMES")
          ShowValue(uValue)
          InKey(0)
          // List names of available bins
          uValue := oPD:DeviceCapabilities(DC_PAPERNAMES)
          QOut("Show "+"DC_PAPERNAMES")
          ShowValue(uValue)
          InKey(0)
          // Destroy printer object (reclaim GDI resources)
          oP:Destroy()
          FUNCTION ShowValue(uValue)
          IF IsArray(uValue)
          AEval(uValue, {|u| ShowValue(u)});
          // recurse until single element found
          ELSEIF IsNumeric(uValue) .AND.;
          uValue = CAPABILITY_NOT_AVAIALBLE
          QOut ("Device capability not available;
          from driver")
          ELSE
          QOut(uValue)
          ENDIF
        </code></example>
    </member>
    <member name="P:VO.PrintingDevice.Driver">
      <summary>
        A string representing the printer driver to be used.
      </summary>
      <value>A string representing the printer driver to be used.</value>
    </member>
    <member name="M:VO.PrintingDevice.GetDevMode">
      <summary>
        Retrieve a pointer to the DevMode structure.
      </summary>
      <returns>
        A pointer to the DevMode structure or 0 if the structure is inaccessible.  You should store this pointer in a variable typed "AS _WINDEVMODE".
      </returns>
      <remarks>
        The DevMode structure is documented in the Win32 SDK and is defined in the X# Win32 API Library.  This structure resides in the underlying PrintingDevice object and is created by using the device driver associated with the object.
        Updates to members of this structure are applied via the PrintingDevice:UpdateDevMode() method.
      </remarks>
      <example>
        This example accesses and displays various information from the DevMode structure:
        <code language="X#">
          oPD is assumed to be a PrintingDevice object.
          LOCAL structDevMode	AS _WINDEVMODE
          LOCAL i		AS DWORD
          LOCAL cDeviceName	AS STRING
          LOCAL cOrientation	AS STRING
          structDevMode := oPD:GetDevMode()
          FOR i := 1 TO CCHDEVICENAME
          cDeviceName:=cDeviceName+Chr(structDevMode.dmDeviceName[i])
          NEXT
          ?"Device name is "
          ??cDeviceName
          cOrientation := StringdmOrientation(structDevMode.dmOrientation)
          ?"Orientation is "
          ??cOrientation
          ?"PaperLength is "
          ??AllTrim(Str(structDevMode.dmPaperLength))
          ?"PaperWidth is "
          ??AllTrim(Str(structDevMode.dmPaperWidth))
          ?"Number of copies is "
          ??AllTrim(Str(structDevMode.dmCopies))
          ? "dmDefaultSource "
          ?structDevMode.dmDefaultSource
          Wait
          FUNCTION StringdmOrientation(nO AS SHORTINT) AS STRING
          IF nO = DMORIENT_LANDSCAPE
          RETURN "Landscape"
          ELSEIF nO = DMORIENT_PORTRAIT
          RETURN "Portrait"
          ELSE
          RETURN "Unknown"
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.PrintingDevice.IsValid">
      <summary>
        Determine if a printing device is valid.
      </summary>
      <returns>
        TRUE if valid; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.PrintingDevice.Orientation">
      <summary>
        Specifies whether the orientation of the paper is portrait or landscape.
      </summary>
      <value>Specifies whether the orientation of the paper is portrait or landscape.</value>
    </member>
    <member name="P:VO.PrintingDevice.PaperHeight">
      <summary>
        Specifies paper length, in tenths of a millimeter.
      </summary>
      <value>Specifies paper length, in tenths of a millimeter.</value>
      <remarks>
        Specifies paper length, in tenths of a millimeter.  This parameter overrides the paper length specified by the member of the DevMode structure, PaperSize, either for custom paper sizes or for such devices as dot-matrix printers that can print on a variety of page sizes.
      </remarks>
    </member>
    <member name="P:VO.PrintingDevice.PaperSize">
      <summary>
        Specifies the size of the paper to print on.
      </summary>
      <value>Specifies the size of the paper to print on.</value>
      <remarks>
        Specifies the size of the paper to print on.  This member may be set to zero if the length and width of the paper are specified by the members of the DevMode structure, PaperLength and PaperWidth, respectively.  Otherwise, the dmPaperSize member can be set to one of the following predefined values:
        Value	Desription
        DMPAPER_FIRST	DMPAPER_LETTER
        DMPAPER_LETTER	Letter, 8 1/2 x 11 in.
        DMPAPER_LETTERSMALL	Letter Small, 8 1/2 x 11 in.
        DMPAPER_TABLOID	Tabloid, 11 x 17 in.
        DMPAPER_LEDGER	Ledger, 17 x 11 in.
        DMPAPER_LEGAL	Legal, 8 1/2 x 14 in.
        DMPAPER_STATEMENT	Statement, 5 1/2 x 8 1/2 in.
        DMPAPER_EXECUTIVE	Executive, 7 1/2 x 10 1/2 in.
        DMPAPER_A3	A3, 297 x 420 mm
        DMPAPER_A4	A4, 210 x 297 mm
        DMPAPER_A4SMALL	A4 Small, 210 x 297 mm
        DMPAPER_A5	A5, 148 x 210 mm
        DMPAPER_B4	B4, 250 x 354 mm
        DMPAPER_B5	B5, 182 x 257 mm
        DMPAPER_FOLIO	Folio, 8 1/2 x 13 in.
        DMPAPER_QUARTO	Quarto, 215 x 275 mm
        DMPAPER_10X14	10 x 14 in.
        DMPAPER_11X17	11 x 17 in.
        DMPAPER_NOTE	Note, 8 1/2 x 11 in.
        DMPAPER_ENV_9	Envelope #9, 3 7/8 x 8 7/8 in.
        DMPAPER_ENV_10	Envelope #10, 4 1/8 x 9 1/2 in.
        DMPAPER_ENV_11	Envelope #11, 4 1/2 x 10 3/8 in.
        DMPAPER_ENV_12	Envelope #12, 4 1/2 x 11 in.
        DMPAPER_ENV_14	Envelope #14, 5 x 11 1/2 in.
        DMPAPER_CSHEET	C size sheet
        DMPAPER_DSHEET	D size sheet
        DMPAPER_ESHEET	E size sheet
        DMPAPER_ENV_DL	Envelope DL, 110 x 220 mm
        DMPAPER_ENV_C3	Envelope C3, 324 x 458 mm
        DMPAPER_ENV_C4	Envelope C4, 229 x 324 mm
        DMPAPER_ENV_C5	Envelope C5, 162 x 229 mm
        DMPAPER_ENV_C6	Envelope C6, 114 x 162 mm
        DMPAPER_ENV_C65	Envelope C65, 114 x 229 mm
        DMPAPER_ENV_B4	Envelope B4, 250 x 353 mm
        DMPAPER_ENV_B5	Envelope B5, 176 x 250 mm
        DMPAPER_ENV_B6	Envelope B6, 176 x 125 mm
        DMPAPER_ENV_ITALY	Envelope, 110 x 230 mm
        DMPAPER_ENV_MONARCH	Envelope Monarch, 3 7/8 x 7 1/2 in.
        DMPAPER_ENV_PERSONAL	Envelope, 3 5/8 x 6 1/2 in.
        DMPAPER_FANFOLD_US	U.S. Standard Fanfold, 14 7/8 x 11 in.
        DMPAPER_FANFOLD_STD_GERMAN	German Standard Fanfold, 8 1/2 x 12 in.
        DMPAPER_FANFOLD_LGL_GERMAN	German Legal Fanfold, 8 1/2 x 13 in.
        DMPAPER_LAST	German Legal Fanfold, 8 1/2 x 13 in.
        DMPAPER_USER	User-defined
      </remarks>
    </member>
    <member name="P:VO.PrintingDevice.PaperWidth">
      <summary>
        Specifies paper width, in tenths of a millimeter.  This parameter overrides the paper width specified by the dmPaperSize member.
      </summary>
      <value>Specifies paper width, in tenths of a millimeter.  This parameter overrides the paper width specified by the dmPaperSize member.</value>
    </member>
    <member name="P:VO.PrintingDevice.Port">
      <summary>
        Specifies the default port setting for the printer.
      </summary>
      <value>Specifies the default port setting for the printer.</value>
    </member>
    <member name="M:VO.PrintingDevice.SetUp">
      <summary>
        Display the standard Windows Printer Setup dialog box, which allows the user to configure or change a default printer and set page orientation, paper size, and paper source (e.g., Manual Feed, Upper Tray, etc.).
      </summary>
      <returns>
        Returns TRUE, if the OK button is pressed; or FALSE, if the Cancel button is pressed, thus closing the Windows Printer Setup dialog box.
      </returns>
    </member>
    <member name="M:VO.PrintingDevice.UpdateDevMode">
      <summary>
        Apply changes made to the DevMode structure to the associated device driver.
      </summary>
      <returns>
        A logic indicating the success of the update.
      </returns>
      <remarks>
        UpdateDevMode() copies the information in the PrintingDevice objects DevMode structure to the printer driver.  Access to the structure is provide via the PrintingDevice:GetDevMode() method.
        You must first use this method to obtain a pointer to the structure.  This structure resides in the underlying PrintingDevice object.
      </remarks>
      <example>
        This example changes the orientation to landscape and sets the number of copies to be printed to 10.
        <code language="X#">
          oPD is assumed to be a PrintingDevice object.
          LOCAL structDevMode	AS _WINDEVMODE	// AS allocates memory for
          // the pointer not the structure
          structDevMode := oPD:GetDevMode()	// map printing devices devmode
          // structure
          structDevMode.dmCopies	:= 10
          structDevMode.dmOrientation	:= DMORIENT_PORTRAIT
          lSuccess := oPD:UpdateDevMode()
          IF !lSuccess
          ? "Error updating devmode"
          ELSE
          ? "devmode updated successfully"
          ENDIF
          InKey(0)
          // destroy printer object (reclaim GDI resources)
          oP:Destroy()
          FUNCTION ShowValue(uValue)
          IF IsArray(uValue)
          AEval(uValue, {|u| ShowValue(u)})	// recurse until
          // single element found
          ELSEIF IsNumeric(uValue) .AND. uValue  = CAPABILITY_NOT_AVAIALBLE
          QOut("Device capability not available from driver")
          ELSE
          QOut(uValue)
          ENDIF
        </code></example>
    </member>
    <member name="T:VO.ProgressBar">
      <summary>
        Create a progress bar.
      </summary>
      <remarks>
        A progress bar is a control that can be used to indicate the progress of an operation.  It is a horizontal bar filled from left to right with the system highlight color as an operation progresses.
      </remarks>
    </member>
    <member name="M:VO.ProgressBar.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a progress bar.
      </summary>
      <param name="oOwner">The window that owns the progress bar.</param>
      <param name="xID">The unique ID of the progress bar (between 1 and 8000).</param>
      <param name="oPoint">The origin of the progress bar in canvas coordinates.</param>
      <param name="oDimension">The dimension of the progress bar in canvas coordinates.</param>
      <param name="kStyle">The style of the progress bar.</param>
      <param name="lDataAware">A logical value specifying whether the progress bar is data aware.</param>
      <param name="nResourceID">The resource ID of the progress bar.</param>
    </member>
    <member name="M:VO.ProgressBar.Advance(XSharp.__Usual)">
      <summary>
        Advance the progress bar to a new position.
      </summary>
      <param name="dwNewPosition">The amount by which the progress bar is advanced.  If omitted, the progress bar is advanced by the unit size.</param>
      <returns>
        The amount by which the progress bar is advanced.
      </returns>
    </member>
    <member name="P:VO.ProgressBar.BackgroundColor">
      <summary>
        A Color object specifying the background color for the progress bar.
      </summary>
      <value>A Color object specifying the background color for the progress bar.</value>
    </member>
    <member name="P:VO.ProgressBar.BarColor">
      <summary>
        A Color object specifying the bar color for the progress bar control.
      </summary>
      <value>A Color object specifying the bar color for the progress bar control.</value>
    </member>
    <member name="P:VO.ProgressBar.OldPosition">
      <summary>
        A numeric value representing the previous position of the progress bar.
      </summary>
      <value>A numeric value representing the previous position of the progress bar.</value>
    </member>
    <member name="P:VO.ProgressBar.Position">
      <summary>
        A numeric value representing the current position of the progress bar.
      </summary>
      <value>A numeric value representing the current position of the progress bar.</value>
    </member>
    <member name="P:VO.ProgressBar.Range">
      <summary>
        A Range object representing the minimum and maximum values currently in use for the progress bar.
      </summary>
      <value>A Range object representing the minimum and maximum values currently in use for the progress bar.</value>
    </member>
    <member name="P:VO.ProgressBar.UnitSize">
      <summary>
        A numeric value representing the unit size currently associated with the progress bar.
      </summary>
      <value>A numeric value representing the unit size currently associated with the progress bar.</value>
    </member>
    <member name="T:VO.PushButton">
      <summary>
        Create a push button, which can be used to initiate an event and associated action when clicked on by the user.
      </summary>
      <remarks>
        Unlike check boxes and radio buttons, which have an identifiable state, push buttons have no state; they are always ready to be clicked.  However, you can specify one of the push buttons on a window to be the default button, in which case it can be activate by pressing the Enter key; the default push button is indicated by its heavy border.

        In Windows, push buttons are the equivalent to a button with the BS_PUSHBUTTON style.  The style BS_DEFPUSHBUTTON is also very useful because the button automatically gets focus in a dialog box.
        In Windows, push buttons can be created in a resource entity as follows:
        <code language="X#">
          RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 120
          STYLE WS_POPUP | WS_DLGFRAME
          BEGIN
          PUSHBUTTON "Cancel"  IDB_CANCEL, 64, 50, 32, 14
          DEFPUSHBUTTON "OK" IDB_OK, 64, 80, 32, 14,; 	WS_GROUP
          END
        </code></remarks>
    </member>
    <member name="M:VO.PushButton.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a push button.
      </summary>
      <param name="oOwner">The window that owns the push button.</param>
      <param name="xID">The unique ID of the push button (between 1 and 8000).</param>
      <param name="oPoint">The origin of the push button in canvas coordinates.</param>
      <param name="oDimension">The dimension of the push button in canvas coordinates.</param>
      <param name="cText">The text that appears in the push button.  The default is NULL_STRING.</param>
      <param name="kStyle">
        The style of the push button, specified by a Windows API style constant.
      </param>
      <param name="nResourceID">The resource ID of the push button.</param>
      <remarks>
        <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular Windows API style constant.</note>
      </remarks>
    </member>
    <member name="M:VO.PushButton.Destroy">
      <summary>
        Provide a method to de-instantiate a PushButton object.
      </summary>
      <remarks>
        This method can be used when a PushButton object is no longer needed.  PushButton:Destroy() de-instantiates the PushButton object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="P:VO.PushButton.TextValue">
      <summary>
        PushButton:TextValue is set to the PushButton:Caption text.
      </summary>
      <value>PushButton:TextValue is set to the PushButton:Caption text.</value>
    </member>
    <member name="P:VO.PushButton.Value">
      <summary>
        PushButton:Value always returns FALSE, since it has a single state.
      </summary>
      <value>PushButton:Value always returns FALSE, since it has a single state.</value>
    </member>
    <member name="T:VO.RadioButton">
      <summary>
        Create a radio button.
      </summary>
      <remarks>
        Radio buttons are typically presented in related groups and provide mutually exclusive responses to a condition where only one choice is appropriate.  (For example, a group of radio buttons might allow you to choose Inches, Centimeters, or Picas.)
        Only one radio button can be on in each radio button group.  When a different button is pressed, the previously selected button is turned off.  In the Window Editor, the Group style setting is checked for each radio button group, to designate the first control in each group.  If you do not explicitly create two or more groups, then there will be only one group for the entire window and only one radio button may be selected at a time.
        A radio button is said to be "pressed" when it is filled in, and the RadioButton:Pressed access is TRUE.  Like check boxes, radio buttons maintain their state between events.  When you create a radio button group using the Window Editor, code is generated so that it functions automatically.  The caption is used to indicate which button in the group is pressed, and the selected button's group value is stored in the RadioButton:Value.
        Radio buttons may not be bound to a field in a server, like other controls.  Instead, a radio button group may be bound to a field.

        In Windows, radio buttons are equivalent to a button with the BS_RADIOBUTTON style.  The style BS_AUTORADIOBUTTON is also very useful because the button is automatically turned on and off without any code being written in the system's Window:ButtonClick() event handler.
        In Windows, radio buttons can be created in a resource entity as follows:
        <code language="X#">
          RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 120
          STYLE WS_POPUP | WS_DLGFRAME
          BEGIN
          RADIOBUTTON "&amp;Black" IDB_BLACK, 10, 20, 40, 12
          RADIOBUTTON "&amp;Gray"  IDB_GRAY,  10, 35, 40, 12
          RADIOBUTTON "&amp;White" IDB_WHITE, 10, 50, 40, 12
          CONTROL "&amp;Auto",IDB_AUTO, "button"; 	BS_AUTORADIOBUTTON, 10,65,40,12
          END
        </code></remarks>
    </member>
    <member name="M:VO.RadioButton.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a radio button.
      </summary>
      <param name="oOwner">The window that owns the radio button.</param>
      <param name="xID">The unique ID of the radio button (between 1 and 8000).</param>
      <param name="oPoint">The origin of the radio button in canvas coordinates.</param>
      <param name="oDimension">The dimension of the radio button in canvas coordinates.</param>
      <param name="cText">The caption text of the radio button.  If omitted, the default is NULL_STRING.</param>
      <param name="kStyle">
        The style of the radio button, specified by a Windows API style constant.
      </param>
      <remarks>
        <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular Windows API style constant.</note>
      </remarks>
      <param name="nResourceID">The resource ID of the radio button.</param>
    </member>
    <member name="M:VO.RadioButton.Destroy">
      <summary>
        Provide a method to de-instantiate a RadioButton object.
      </summary>
      <remarks>
        This method can be used when a RadioButton object is no longer needed.  RadioButton:Destroy() de-instantiates the RadioButton object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="P:VO.RadioButton.Pressed">
      <summary>
        A logical value representing the current state of the radio button (TRUE if it is on, FALSE if it is off).
      </summary>
      <value>A logical value representing the current state of the radio button (TRUE if it is on, FALSE if it is off).</value>
      <remarks>
        A logical value representing the current state of the radio button (TRUE if it is on, FALSE if it is off).  RadioButton:Pressed is only modified by clicking on the button.
      </remarks>
    </member>
    <member name="P:VO.RadioButton.TextValue">
      <summary>
        RadioButton:TextValue is set to the RadioButton:Caption text.
      </summary>
      <value>RadioButton:TextValue is set to the RadioButton:Caption text.</value>
      <remarks>
        RadioButton:TextValue is set to the RadioButton:Caption text.  The RadioButton:TextValue assign also changes the RadioButton:Caption.
      </remarks>
    </member>
    <member name="P:VO.RadioButton.Value">
      <summary>
        RadioButton:Value contains TRUE if the radio button is in the pressed (ON) state or FALSE if it is not pressed (OFF).
      </summary>
      <value>RadioButton:Value contains TRUE if the radio button is in the pressed (ON) state or FALSE if it is not pressed (OFF).</value>
    </member>
    <member name="T:VO.RadioButtonGroup">
      <summary>
        A group of radio buttons considered as a combination control, presenting a set of options and returning a single value.
      </summary>
      <remarks>
        Radio buttons are commonly used to allow selection of one among a specific list of options.  However, treating several radio buttons as individual controls requires explicit management of the behavior of the buttons:  when one is selected, the program must turn off the other buttons in the group.  Individual radio buttons are also not suited for linking to a database:  databases typically do not have several fields representing linked properties, but rather a single field that can take on different values.
        The radio button group is a higher level control that automatically handles the interlinking of the buttons.  It also links to database fields in a more intelligent way than individual radio buttons:  the group as a whole is considered as one control that takes one of a number of specific values.
        Since the radio button group is the control that you deal with, and its constituent radio buttons are not directly referenced by the program, properties such as the hyperlabel, field specification, caption, value, and text value are attached to the group.  The value is either the number of the radio button which is currently selected in the sequence or one of the values specified for a radio button in a two-dimensional array through FillUsing().  The text value is the same value formatted according to the picture clause of the field specification attached to the group (to get the caption displayed next to the radio buttons, retrieve the selected button and reference its caption property.  Note that the data type and picture of the group's field specification are used and the field specs of the individual radio buttons are ignored.
        The radio button group behaves similarly to a list box or combo box and may be used as an alternative to any constrained single-selection list box when the number of options is small and fixed.  (Although the radio button group supports variable caption strings for the individual buttons, a list box is usually a better choice for very dynamic data.)
        A radio button group is created empty and radio buttons are associated with it through the FillUsing() method.  If you create a radio button using the Window Editor, the FillUsing( ) method in the generated source code defines a two-dimensional array, with one row for each button.  The first element contains the caption of the radio button and the second element contains its group value.   When a button is pressed, the radio button group's TextValue contains the first element (the button caption), and Value contains the second element (the group value).  If no button is pressed, RadioButtonGroup:TextValue is NULL_STRING and RadioButtonGroup:Value is NIL.
        A radio button group may be bound to a field in a server.  The field's data value is stored in RadioButtonGroup:Value.  The radio button group compares the field's data value to the second element values specified in the FillUsing() array, and if a match is found, the first element (the button caption) is stored in RadioButtonGroup:TextValue.  If there is no match, RadioButtonGroup:TextValue is NULL_STRING.  If a button is pressed, the corresponding second element is stored as RadioButtonGroup:Value, and this value is written to the server.
      </remarks>
    </member>
    <member name="M:VO.RadioButtonGroup.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a radio button group.
      </summary>
      <param name="oOwner">The window that owns the radio button group.</param>
      <param name="xID">The unique ID of the radio button group (between 1 and 8000) or the resource ID of the radio button group.</param>
      <param name="uPoint">The origin of the group box in canvas coordinates.</param>
      <param name="uDimension">The dimension of the group box in canvas coordinates.</param>
      <param name="cText">The caption text displayed when the group box containing the radio button group is shown.  By default, this value is the caption in the dialog template, defined when the dialog is initialized.</param>
      <remarks>
        Note that after instantiation, the radio button group is "empty:" it doesn't contain any radio buttons.  Visually, it may be drawn to surround the radio buttons, but logically it doesn't contain them.  To relate the group to its radio buttons, use the FillUsing() method.
      </remarks>
    </member>
    <member name="M:VO.RadioButtonGroup.Button(XSharp.__Usual)">
      <summary>
        Retrieve a specific radio button.
      </summary>
      <param name="nButtonPosition">The position of the radio button in the array that was used to set up the group (in FillUsing()).</param>
      <returns>
        The RadioButton object at the specified position in the array. Note that the radio button position in the array may not correspond to the order the radio buttons are displayed in the group box.  NIL is returned if there is no radio button at the indicated position.
      </returns>
    </member>
    <member name="P:VO.RadioButtonGroup.Buttons">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.RadioButtonGroup.Caption">
      <summary>
        A string representing the text that is displayed adjacent to the radio button in a radio button group that is currently pressed.
      </summary>
      <value>A string representing the text that is displayed adjacent to the radio button in a radio button group that is currently pressed.</value>
      <remarks>
        A string representing the text that is displayed adjacent to the radio button in a radio button group that is currently pressed.  The RadioButtonGroup:Caption assign also changes RadioButtonGroup:CurrentText for the radio button.
      </remarks>
    </member>
    <member name="M:VO.RadioButtonGroup.Disable">
      <summary>
        Disable a radio button group (until a subsequent call to RadioButtonGroup:Enable()).
      </summary>
      <remarks>
        Disabled radio button groups are not active (that is, radio button cannot be clicked) and, therefore, they do not send events to their owner windows.  Note that under Windows, a disabled radio button group is dimmed.
      </remarks>
    </member>
    <member name="M:VO.RadioButtonGroup.Enable">
      <summary>
        Enable a radio button group that was previously disabled.
      </summary>
      <remarks>
        Enabling a radio button group allows it to generate events and to send the events to its owner window when the user manipulates the radio button group.  The dimming of disabled radio button groups is removed, and it is restored to its normal appearance.
        By default, radio button groups are enabled until disabled, so there is no need to call this Enable() method unless Disable() was previously called.
      </remarks>
    </member>
    <member name="M:VO.RadioButtonGroup.FillUsing(XSharp.__Usual)">
      <summary>
        Specify the radio buttons that make up the group and the set of values corresponding to these buttons, using an array.
      </summary>
      <param name="aContents">
        The array containing existing radio buttons or the values that should be used to create radio buttons.  A two-dimensional array may be used to define the values to be returned to the program when a radio button is selected; this 'other' value is what is returned in the RadioButtonGroup:Value property, and what is stored in the database if the control is associated with a database field.  If a one-dimensional array is specified, the values are returned as 1, 2, 3...
        Thus, the array may be specified in one of two formats:
        1.	One-dimensional array containing radio button objects that are to be linked to the group
        2.	Two-dimensional arrays, each element containing a RadioButton object and the corresponding value returned to the program
        Note: the two dimensional array has the same structure as that returned by DBServer:GetLookupTable().
      </param>
      <remarks>
        For fixed structures, the individual radio buttons may be created as regular controls, either dynamically or through a resource entity, and assigned to the group through the FillUsing() method.
        <note type="tip">The radio button group may be associated with a database field, just like any other control.</note></remarks>
      <example>
        Create a radio button group with different currencies, showing an explicit representation to the user but using a different representation internally.
        This example, shown below, with the radio buttons explicitly created through a resource entity.  The code simply links the radio buttons to the group:
        <code language="X#">
          RESOURCE OrderWindow DIALOG 7,11,239,196
          STYLE WS_CHILD
          FONT 8,"MS Sans Serif"
          BEGIN
          CONTROL "Currency",;
          ORDERWINDOW_CURRENCY,"Button";
          BS_GROUPBOX|WS_GROUP|WS_CHILD,;
          27,33,85,122
          CONTROL "U.S. Dollars",;
          ORDERWINDOW_THERADIOBUTTON1,"Button";
          BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
          38,45,57,11
          CONTROL "Can. Dollars",;
          ORDERWINDOW_THERADIOBUTTON2,"Button";
          BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
          38,63,69,11
          CONTROL "Mexican Pesos",;
          ORDERWINDOW_THERADIOBUTTON3,"Button";
          BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
          38,82,69,11
          CONTROL "Yen",;
          ORDERWINDOW_THERADIOBUTTON4,"Button";
          BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
          38,100,68,11
          CONTROL "British Pounds",;
          ORDERWINDOW_THERADIOBUTTON5,"Button";
          BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
          38,118,68,11
          CONTROL "German Marks",;
          ORDERWINDOW_THERADIOBUTTON6,"Button";
          BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
          38,137,69,11
          METHOD Init(oWindow,iCtlID,oServer) CLASS OrderWindow
          SUPER:Init(oWindow,ResourceID{"OrderWindow"},iCtlID)
          oCCTheRadioButton1 := RadioButton{SELF,;
          ResourceID{ORDERWINDOW_THERADIOBUTTON1}}
          RadioButton1:HyperLabel := {#TheRadioButton1,;
          "U.S. Dollars",,}
          oCCTheRadioButton2 := RadioButton{SELF,;
          ResourceID{ORDERWINDOW_THERADIOBUTTON2}}
          RadioButton2:HyperLabel := {#TheRadioButton2,;
          "Can. Dollars",,}
          oCCTheRadioButton3 := RadioButton{SELF,;
          ResourceID{ORDERWINDOW_THERADIOBUTTON3}}
          RadioButton3:HyperLabel := {#TheRadioButton3,;
          "Mexican Pesos",,}
          oCCTheRadioButton4 := RadioButton{SELF,;
          ResourceID{ORDERWINDOW_THERADIOBUTTON4}}
          RadioButton4:HyperLabel := {#TheRadioButton4,;
          "Yen",,}
          oCCTheRadioButton5 := RadioButton{SELF,;
          ResourceID{ORDERWINDOW_THERADIOBUTTON5}}
          RadioButton5:HyperLabel := {#TheRadioButton5,;
          "British Pounds",,}
          oCCTheRadioButton6 := RadioButton{SELF,;
          ResourceID{ORDERWINDOW_THERADIOBUTTON6}}
          RadioButton6:HyperLabel := {#TheRadioButton6,;
          "German Marks",,}
          oDCCCurrency := RadioButtonGroup{SELF,;
          ResourceID{ORDERWINDOW_CURRENCY}}
          oDCCCurrency:FieldSpec := ;
          FieldSpec{#Currency,STRING,3,0}
          oDCCurrency:FillUsing({;
          {oCCTheRadioButton1,"USD"},;
          {oCCTheRadioButton2,"CDN"},;
          {oCCTheRadioButton3,"MEX"},;
          {oCCTheRadioButton4,"YEN"},;
          {oCCTheRadioButton5,"UK"},;
          {oCCTheRadioButton6,"DM"};
          })
          oDCCurrency:HyperLabel := {#Currency,"Currency",,}
        </code></example>
    </member>
    <member name="M:VO.RadioButtonGroup.Hide">
      <summary>
        Hide a radio button group so it is not visible (until a subsequent call to RadioButtonGroup:Show()).
      </summary>
    </member>
    <member name="M:VO.RadioButtonGroup.SetFocus">
      <summary>
        Pass input focus to the selected radio button within the radio button group.
      </summary>
    </member>
    <member name="M:VO.RadioButtonGroup.Show">
      <summary>
        Display a radio button group so it is visible.
      </summary>
      <remarks>
        RadioButtonGroup:Show() is usually called to redisplay a radio button group that was hidden with the RadioButtonGroup:Hide() method.
      </remarks>
    </member>
    <member name="P:VO.RadioButtonGroup.TextValue">
      <summary>
        RadioButtonGroup:TextValue holds the first element of the FillUsing() array
      </summary>
      <value>RadioButtonGroup:TextValue holds the first element of the FillUsing() array</value>
      <remarks>
        RadioButtonGroup:TextValue holds the first element of the FillUsing() array (typically, the caption text of the radio button) for the currently selected button; if none is selected, RadioButtonGroup:TextValue is set to NULL_STRING.
      </remarks>
    </member>
    <member name="P:VO.RadioButtonGroup.Value">
      <summary>
        Contains the group value setting (specified on the Window Editor Property Window) associated with the radio button within the group that is selected.
      </summary>
      <value>Contains the group value setting (specified on the Window Editor Property Window) associated with the radio button within the group that is selected.</value>
      <remarks>
        Contains the group value setting (specified on the Window Editor Property Window) associated with the radio button within the group that is selected.
        The data type of the control's Value is determined by its field specification; in turn, controls linked to a data server inherit the field specification — and hence data type — from the field of the server.  When the control is made data-aware, by setting its name to the name of a field in the server attached to the data window, Value is able to automatically read from and write to this field.
        <note type="tip">RadioButtonGroup:Value may not always be consistent with what the state of the control, as indicated to the end-user.  For example, if the data value for the field is not among the group value settings for the radio buttons in a radio button group, the control will be in a "no-match" situation.  In this case the control will revert to its initial unselected state.</note></remarks>
    </member>
    <member name="P:VO.RadioButtonGroup.Values">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.Range">
      <summary>
        Create a range, representing the minimum and maximum values of the coordinates (or scroll units) that the thumb position on a scroll bar can move — up or down, left or right.
      </summary>
    </member>
    <member name="M:VO.Range.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a range.
      </summary>
      <param name="nMin">The minimum value in the range.  The default is 0.</param>
      <param name="nMax">The maximum value in the range.  The default is 0.</param>
    </member>
    <member name="M:VO.Range.IsInRange(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="nValue">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.Range.Max">
      <summary>
        A numeric value representing the maximum value in this range.
      </summary>
      <value>A numeric value representing the maximum value in this range.</value>
    </member>
    <member name="P:VO.Range.Min">
      <summary>
        A numeric value representing the minimum value in this range.
      </summary>
      <value>A numeric value representing the minimum value in this range.</value>
    </member>
    <member name="T:VO.RectangleObject">
      <summary>
        Create a RectangleObject object; this class is part of the DrawObject hierarchy, which provides a means of displaying and manipulating various geometric objects.
      </summary>
      <example>
        To draw a RectangleObject object, call Window:Draw() with the RectangleObject object as its argument.  The window does the drawing by asking each object to draw itself — for example:
        <code language="X#">
          METHOD Expose(oEvent) CLASS MyWindow
          LOCAL oRectangle AS OBJECT
          oRectangle := RectangleObject{Point{10,10},;
          Dimension{20,40}}
          SELF:Draw(oRectangle)
        </code></example>
    </member>
    <member name="M:VO.RectangleObject.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a rectangle.
      </summary>
      <param name="oPoint">The origin of the rectangle, in canvas coordinates.</param>
      <param name="oDimension">The dimension of the rectangle, in canvas coordinates.</param>
      <param name="oPen">The pen to be used to draw the rectangle.  By default, &lt;oPen&gt; is set to NIL, which causes the current pen to be used.</param>
      <param name="oBrush">The brush to be used to fill the rectangle.  If omitted, the default is NIL, which causes the current brush to be used.</param>
    </member>
    <member name="M:VO.RectangleObject.Draw">
      <summary>
        Draw the rectangle on the window.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <remarks>
        This method should not be invoked directly in the application code — it is invoked in X# by Window:Draw().  Refer to the class description for an example using the Draw() method.
      </remarks>
    </member>
    <member name="T:VO.ReportQueue">
      <summary>
        Manage Report Editor reporting activities, as well as the appearance of the Report Editor window.
      </summary>
      <remarks>
        The ReportQueue class allows an application to create, edit, print, preview, and save reports using report definition files (*.RET) created and formatted using the Report Editor.
      </remarks>
    </member>
    <member name="M:VO.ReportQueue.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a report queue.
      </summary>
      <param name="oOwner">The window that owns the ReportQueue object.</param>
      <param name="cServerName">
        The Report Editor server to be used.  If not specified, the default value is 'Report Editor', which is the Report Editor runtime engine.
      </param>
      <remarks>
        <note type="tip">Report Editor is the only server that is supported.</note>
        ReportQueue:Init() creates a ReportQueue object owned by a window.  This object can then be used for sequential reporting tasks.
      </remarks>
      <example>
        This example creates a shell window containing a ReportQueue object:
        <code language="X#">
          CLASS MyShellWindow INHERIT ShellWindow
          HIDDEN oRQ AS OBJECT
          METHOD Start() CLASS App
          LOCAL oSW := MyShellWind{}
          oSW:Show()
          SELF:Exec()
          METHOD Init() CLASS MyShellWind
          SUPER:Init()
          // Initializes the server
          oRQ := ReportQueue{SELF,"Report Editor"}
        </code></example>
    </member>
    <member name="P:VO.ReportQueue.ActiveFile">
      <summary>
        The report definition file the Report Editor server was just using.  This information can be used within an AppWindow:ReportNotification() method.
      </summary>
      <value>The report definition file the Report Editor server was just using.  This information can be used within an AppWindow:ReportNotification() method.</value>
    </member>
    <member name="M:VO.ReportQueue.Close">
      <summary>
        Close a report.
      </summary>
      <remarks>
        When a program has finished with a report, it should close the report to reduce the Report Editor's memory usage.  This does not close the Report Editor; only the open report within it.
        The ReportQueue keeps a stack of the reports it opened by calls to the ReportQueue:Open() method (but it does not have visibility to the extra files the user opens via the Report Editor's menu).  Once all reports are closed (via the ReportQueue:Close() method or the Report Editor menu), the ReportQueue knows of no reports that are open and rejects any further calls to print, preview, or export "the current report," until the next ReportQueue:Open() call.
        ReportQueue:Close() displays its status in the owner window's status bar.
        Even if the ReportQueue believes that the Report Editor has no report open, the Close() method still sends the FILE.CLOSE command to the Report Editor.  This command is quietly ignored by the Report Editor, so it is always safe to call ReportQueue:Close().
        The ReportQueue:Close() method totally closes a report.  The ReportQueue:Close() method closes a preview (if open), and/or closes the report definition, depending on which window type is open.
        The Report Editor advises the ReportQueue whenever a report or view is closed (whether the close was initiated by ReportQueue or the user).
      </remarks>
      <example>
        The following example closes a report definition:
        <code language="X#">
          LOCAL oReportQueue := ReportQueue{SELF,;
          "Report Editor"}
          oReportQueue:Open("one.ret")
          oReportQueue:Close()
        </code></example>
    </member>
    <member name="M:VO.ReportQueue.CloseAll">
      <summary>
        Close all reports.
      </summary>
      <remarks>
        CloseAll() displays its status in the owner window's status bar.  It leaves both the Report Editor server and your program running.  CloseAll() can be called safely at any time, and is probably useful both in exception handlers and in clean-up routines.
      </remarks>
    </member>
    <member name="M:VO.ReportQueue.ConnectToDB(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Connect to an ODBC data source.
      </summary>
      <param name="cDataSourceName">The name of the ODBC data source to connect to. If no data source is specified, a dialog box will appear so that one can be selected.</param>
      <param name="cUserName">The ODBC user name for this data source.</param>
      <param name="cPassword">The ODBC password or authorization string for this data source.</param>
      <returns>
        TRUE is successful; otherwise, FALSE.

        TRUE if successful; otherwise FALSE.
      </returns>
      <remarks>
        The Report Editor requires an active database connection.  Before opening a report, you must create a data source for the report database.
      </remarks>
      <example>
        The following example connects to a "CA Xbase" data source:
        <code language="X#">oRQ:ConnectToDB("CA Xbase")</code></example>
    </member>
    <member name="M:VO.ReportQueue.DataUpdate(XSharp.__Usual)">
      <summary>
        Handle DataUpdateEvent, if one occurs.  Provide this event handler in your derived ReportQueue class if you require special handling of events.
        <br />Important!  You should neither attempt to call nor provide alternative implementations to this method.  Instead, you can provide extra handling of  events in your derived version of AppWindow:ReportNotification().
      </summary>
      <param name="oIpcDataUpdateEvent">Stores the topic name, item name, and the changed data as a string.</param>
      <remarks>
        This method executes outstanding ReportQueue methods (either commands, like Print() and SaveToFile() or Report Editor appearance methods).  Once a report is opened, subsequent command methods can take an array of report parameters to be inserted into the Report Editor report text and/or database query.  The Report Editor's appearance can be changed synchronously, but the Report Editor performs commands asynchronously and all subsequent commands and appearance changes are queued within the ReportQueue until the Report Editor advises that it has finished the previous command.
        The ReportQueue methods post messages on their owner window's status bar whenever they send a command to the Report Editor and replace it with a confirmation on completing each command.
      </remarks>
    </member>
    <member name="M:VO.ReportQueue.Edit">
      <summary>
        Load a report into the Report Editor for editing.
      </summary>
      <remarks>
        This method allows the user to edit the report definition (.RET) file and provides the same environment as the IDE.
      </remarks>
      <example>
        The following example opens the "sales.ret" report file and allows the user to edit the file:
        <code language="X#">
          oRQ:Open("sales.ret")
          oRQ:Edit()
        </code></example>
    </member>
    <member name="P:VO.ReportQueue.EventType">
      <summary>
        One of the following constants representing an event:
        <pre>
          Constant					Description
          REPORTCLOSEEVENT			Current report has been closed.
          REPORTCOMPLETEERROREVENT	A print or export task has aborted.
          REPORTCOMPLETEEVENT		A print or export task has completed.
          REPORTFILESAVEEVENT		A report definition has been closed.
          REPORTOPENEVENT			Requested report has been opened.
          REPORTSERVERCLOSEEVENT	Report Editor has been closed.
          REPORTVIEWCLOSEEVENT		A report preview has been closed (but the report itself remains open).
        </pre>
        It should be used only in any AppWindow:ReportNotification() method you add to your window class that owns this ReportQueue object.
      </summary>
      <value>
        A constant representing an event
      </value>
    </member>
    <member name="P:VO.ReportQueue.Filename">
      <summary>
        The name of the .RET file that defines the report.  This access is unlikely to be used within the function that opened the report — as the file name string should already be local to the function.  It would be useful if one method opens a report and another method needs to use that open file.
        Note that this accesses the name of the report that is open when the next command method gets around to executing on the Report Editor, as opposed to the ReportQueue:ActiveFile which might be an earlier report now being processed by the Report Editor.
      </summary>
      <value>
        The name of the .RET file that defines the report.  This access is unlikely to be used within the function that opened the report — as the file name string should already be local to the function.  It would be useful if one method opens a report and another method needs to use that open file.
        Note that this accesses the name of the report that is open when the next command method gets around to executing on the Report Editor, as opposed to the ReportQueue:ActiveFile which might be an earlier report now being processed by the Report Editor.
      </value>
    </member>
    <member name="M:VO.ReportQueue.Hide">
      <summary>
        Hide the Report Editor window and icon so that they are not visible.
      </summary>
    </member>
    <member name="M:VO.ReportQueue.NEW(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Create a new report definition in the Report Editor for editing.
      </summary>
      <param name="cSQLSelectStatement">The SQL Select statement string that defines the report.</param>
      <param name="kReportStyle">
        One of the following constants representing the report style for the new report:
      </param>
      <remarks>
        <pre>
          Constant				Description
          RPTSTYLE_CROSSTAB		Creates a cross-tabular report.
          RPTSTYLE_FORM			Creates a form-based report
          RPTSTYLE_FREESTYLE	Creates a free-style report
          RPTSTYLE_LABEL		Creates a label report
          RPTSTYLE_LETTER		Creates a letter report
          RPTSTYLE_TABULAR		Creates a tabular report
          If no report style is specified, a dialog box containing all the above report styles will appear.
        </pre>
        This method allows the user to edit the report definition (.RET) file and provides the same environment as the IDE.
      </remarks>
      <example>
        The following example creates a new report definition file and allows the user to edit the file:
        <code language="X#">oRQ:New("SELECT CUSTOMERS * FROM C:\CAVO2x\SAMPLES\CUSTOMER")</code></example>
    </member>
    <member name="M:VO.ReportQueue.Open(XSharp.__Usual)">
      <summary>
        Open a report.
      </summary>
      <param name="cReportName">An existing Report Editor report definition file.  If no extension is given, .RET is appended to the file name specified.</param>
      <remarks>
        Open() must be called before calling ReportQueue command methods like Print() or Preview().
        Before opening a second report, we recommend you close the first, in order to save memory, although it is not required.
        Open() displays its status in the owner window's status bar.
        <note type="tip">The Report Editor requires an active database connection.  Before opening a report, you must create a data source for the report database and connect to it using ReportQueue:ConnectToDB().</note></remarks>
      <example>
        This example opens a report definition:
        <code language="X#">
          LOCAL od AS OBJECT
          LOCAL ReportFile AS STRING
          od := OpenDialog{SELF,"*.ret"}
          od:Show()
          ReportFile := od:FileName
          od:Destroy()
          oRQ:ConnectToDB(...)
          oRQ:Open(ReportFile)
        </code></example>
    </member>
    <member name="P:VO.ReportQueue.Origin">
      <summary>
        A point defining where the top left corner of the Report Editor window is shown, in canvas coordinates.  The Report Editor is shown from this point downward.  This is in contrast to the coordinate system used by X# applications, which consider their window's origin at the bottom-left corner and show windows in an upward direction.
      </summary>
      <value>A point defining where the top left corner of the Report Editor window is shown, in canvas coordinates.  The Report Editor is shown from this point downward.  This is in contrast to the coordinate system used by X# applications, which consider their window's origin at the bottom-left corner and show windows in an upward direction.</value>
    </member>
    <member name="P:VO.ReportQueue.owner">
      <summary>
        The window that owns the ReportQueue object.  This access allows code using a ReportQueue to call methods of the owner (ultimately derived from AppWindow).
      </summary>
      <value>The window that owns the ReportQueue object.  This access allows code using a ReportQueue to call methods of the owner (ultimately derived from AppWindow).</value>
    </member>
    <member name="M:VO.ReportQueue.Preview(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Cause a report to be previewed on screen.
      </summary>
      <param name="aParams">An array of report parameters, as understood by the Report Editor report file.  These report parameters can be inserted by the Report Editor into the report text, and/or can be used as selection criteria in the report query.  Use commas to default any unused parameters or to re-use previously provided parameters.</param>
      <param name="cPreviewTitle">String representing the title for the Preview window.  If omitted, no title will appear in the window title bar.</param>
      <param name="lMDIChild">Logical value indicating whether the preview window will be an MDI child (TRUE) or not (FALSE).  If omitted, the default value is FALSE.</param>
      <remarks>
        The status of the method is sent to the owner window's status bar, displaying "&lt;ServerName&gt; has completed report."
        The parameters are transmitted to the Report Editor before the Preview() method, and would be used by subsequent Print() methods.  You can prefer to leave the decision whether to print the report with the person previewing, rather than have the program request a print.
      </remarks>
      <example>
        The following example previews a file on the screen before printing it:
        <code language="X#">
          oRQ:ConnectToDB(...)
          oRQ:Open("sales.ret")
          oRQ:Preview({"Spain","1993"})
          oRQ:Print()
        </code></example>
    </member>
    <member name="M:VO.ReportQueue.Print(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Print a report to the Report Editor's selected printer.
      </summary>
      <param name="aParams">An array of report parameters, as understood by the Report Editor report file.  These report parameters can be inserted by the Report Editor into the report text, and/or can be used as selection criteria in the report query.  Use commas to default any unused parameters or to re-use previously provided parameters.</param>
      <param name="oRange">The range of page numbers to print.  Omit this parameter to print all pages of the report.  A Range:Min parameter of zero means 'from start,' while a Range:Max parameter of zero means 'to end.'</param>
      <remarks>
        The report parameters are transmitted to the Report Editor before the print command, and is used by subsequent Print() methods.
      </remarks>
      <example>
        This example prints three different reports from the same report definition:
        <code language="X#">
          // Print all
          oRQ:ConnectToDB(...)
          oRQ:Open{"sales.ret"}
          // Default to 1992 again
          oRQ:Print({"Spain","1992"})
          oRQ:Print({"Ireland"})
          // Second &amp; third pages
          oRQ:Print({,"1993"},Range{2,3})
          oRQ:Close()
        </code></example>
    </member>
    <member name="M:VO.ReportQueue.ReportExit">
      <summary>
        Exit the Report Editor.
      </summary>
    </member>
    <member name="P:VO.ReportQueue.ReportServer">
      <summary>
        The Report Editor server currently in use by this ReportQueue.  The value is set in the ReportQueue:Init() method.
      </summary>
      <value>The Report Editor server currently in use by this ReportQueue.  The value is set in the ReportQueue:Init() method.</value>
      <remarks>
        <note type="tip">The only supported server is "Report Editor."</note>
      </remarks>
    </member>
    <member name="M:VO.ReportQueue.SaveToFile(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Save a report to the given file name.
      </summary>
      <param name="cTarget">The file to which a report is saved.</param>
      <param name="cFormat">Another string defining the save format to be either RTF or TEXT.  Rich Text Format maintains all the spacing, table alignments, fonts, and such characteristics.  The default is RTF.</param>
      <param name="aParams">An array of string parameters, which are report parameters as understood by the Report Editor report file.  See the discussion under the ReportQueue:Preview() method.</param>
      <example>
        This example stores two files in RTF format to disk:
        <code language="X#">
          oRQ:Print({"Spain","1992"})
          oRQ:SaveToFile("spain92.rtf","RTF")
          oRQ:SaveToFile("spain93.rtf",,{,"1993"})
        </code></example>
    </member>
    <member name="M:VO.ReportQueue.SetPapersize(XSharp.__Usual)">
      <summary>
        Set the paper size for the report.
      </summary>
      <param name="iSize">
        Integer representing one of the predefined paper sizes (see below).
        If omitted, the default is 1 (Letter 8 1/2 x 11 in).
      </param>
      <remarks>
        Paper Size	&lt;&gt;
        A3 297 x 420 mm	  8
        A4 210 x 297 mm	  9
        A4 Small 210 x 297 mm	10
        A5 148 x 210 mm	11
        B4 250 x 354	12
        B5 182 x 257 mm	13
        C size sheet	24
        D size sheet	25
        E size sheet	26
        Envelope B4  250 x 353 mm	33
        Envelope B5  176 x 250 mm	34
        Envelope B6  176 x 125 mm	35
        Envelope C5 162 x 229 mm	28
        Envelope C3  324 x 458 mm	29
        Envelope C4  229 x 324 mm	30
        Envelope C6  114 x 162 mm	31
        Envelope C65 114 x 229 mm	32
        Envelope DL 110 x 220 mm	27
        Envelope 110 x 230 mm	36
        Envelope Monarch 3.875 x 7.5 in	37
        6 3/4 Envelope 3 5/8 x 6 1/2 in	38
        Envelope #9 3 7/8 x 8 7/8	19
        Envelope #10 4 1/8 x 9 1/2	20
        Envelope #11 4 1/2 x 10 3/8	21
        Envelope #12 4 \276 x 11	22
        Envelope #14 5 x 11 1/2	23
        Executive 7 1/4 x 10 1/2 in	  7
        Folio 8 1/2 x 13 in	14
        German Std Fanfold 8 1/2 x 12 in	40
        German Legal Fanfold 8 1/2 x 13 in	41
        Ledger 17 x 11 in	  4
        Legal 8 1/2 x 14 in	  5
        Letter 8 1/2 x 11 in	  1
        Letter Small 8 1/2 x 11 in	  2
        Note 8 1/2 x 11 in	18
        Quarto 215 x 275 mm	15
        Statement 5 1/2 x 8 1/2 in	  6
        Tabloid 11 x 17 in	  3
        US Std Fanfold 14 7/8 x 11 in	39
        10x14 in	16
        11x17 in	17
        The paper size should be set before calling Print() or Preview().
        <note type="tip">Not all paper sizes are supported on all printers.  Consult your printer documentation for supported paper sizes.</note></remarks>
      <example>
        <code language="X#">oRQ:SetPrinterPaperSize(5)    // Sets paper size to Legal 8 1/2 x 14in</code>
      </example>
    </member>
    <member name="M:VO.ReportQueue.SetPrinterOrientation(XSharp.__Usual)">
      <summary>
        Set the printer orientation for the report.
      </summary>
      <param name="bOrientation">Binary value value indicating whether the printer orientation will be portrait (0) or landscape (1).  If omitted, default is 0 (portrait).</param>
      <remarks>
        The paper orientation should be set before calling Print() or Preview().
      </remarks>
      <example>
        <code language="X#">oRQ:SetPrinterOrientation(1)	// Set orientation to landscape</code>
      </example>
    </member>
    <member name="M:VO.ReportQueue.SetReportQuery(XSharp.__Usual)">
      <summary>
        Set the query to be used for the report.
      </summary>
      <param name="sQueryName">Name of the query to use for the report.</param>
      <remarks>
        For reports that contain multiple queries, this method can be used to select which query is used when running a report.  To view what queries are available, go into the Report Editor and select the Query, Set Report Query menu item.  If that menu item is disabled, then only the default query (QUERY1) is defined.  Otherwise a Set Report Query dialog box will appear and the available queries will be listed.
        The report query should be set before calling Print() or Preview().
      </remarks>
      <example>
        <code language="X#">oRQ:SetReportQuery("QUERY2")	//Set the report query to QUERY2</code>
      </example>
    </member>
    <member name="M:VO.ReportQueue.SetSQLFile(XSharp.__Usual)">
      <summary>
        Load an SQL query file as the active SQL query for the report.
      </summary>
      <param name="sQueryFile">Name of the query file to load.</param>
      <remarks>
        Loads an SQL query file from disk to be used as the active query for this report.  The SQL query file should be loaded before calling Print() or Preview().
        <note type="tip">Query-By-Example (.QBE) query files are not supported by the X# Report Writer.</note></remarks>
      <example>
        <code language="X#">oRQ:SetSQLFile("QUERY6.SQL")</code>
      </example>
    </member>
    <member name="M:VO.ReportQueue.SetSQLText(XSharp.__Usual)">
      <summary>
        Set a text string as the active SQL query for the report.
      </summary>
      <param name="sQuery">The query string to use as the active SQL query.</param>
      <remarks>
        The query text should be set before calling Print() or Preview().
      </remarks>
      <example>
        <code language="X#">
          oRQ:SetSQLText("SELECT Customer.* FROM " + ;
          "C:\CAVO2x\Samples\Explorer\Customer WHERE " + ;
          "Customer.CustNum = 8")
        </code>
      </example>
    </member>
    <member name="M:VO.ReportQueue.Show(XSharp.__Usual)">
      <summary>
        Minimize or maximize the Report Editor window.
      </summary>
      <param name="kShowState">
        The state in which the Report Editor window area should be displayed.  Specify one of the following constants:
      </param>
      <remarks>
        <pre>
          Constant		Description
          SHOWICONIZED	Iconizes or minimizes the Report Editor window.
          SHOWNORMAL	Normalizes the Report Editor window.  This is the default.
          SHOWZOOMED	Maximizes the Report Editor window to a full screen.
        </pre>
      </remarks>
    </member>
    <member name="P:VO.ReportQueue.Size">
      <summary>
        A dimension representing the current size of the Report Editor window, in canvas coordinates.
      </summary>
      <value>A dimension representing the current size of the Report Editor window, in canvas coordinates.</value>
    </member>
    <member name="T:VO.ResizeEvent">
      <summary>
        Provide information about the ResizeEvent, used to indicate that a window has been resized.
      </summary>
      <remarks>
        When the size of a window changes, the system generates ResizeEvents and sends them to the Window:Resize() event handler.
      </remarks>
    </member>
    <member name="M:VO.ResizeEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ResizeEvent.Height">
      <summary>
        A numeric value representing the new height of the canvas area of the window that generated this resize event, in canvas coordinates.
      </summary>
      <value>A numeric value representing the new height of the canvas area of the window that generated this resize event, in canvas coordinates.</value>
    </member>
    <member name="P:VO.ResizeEvent.Size">
      <summary>
        A dimension representing the new size of the canvas area of the window that generated this resize event, in canvas coordinates.
      </summary>
      <value>A dimension representing the new size of the canvas area of the window that generated this resize event, in canvas coordinates.</value>
    </member>
    <member name="P:VO.ResizeEvent.Width">
      <summary>
        A numeric value representing the new width, in canvas coordinates, of the canvas area of the window that generated this resize event.
      </summary>
      <value>A numeric value representing the new width, in canvas coordinates, of the canvas area of the window that generated this resize event.</value>
    </member>
    <member name="T:VO.ResourceFile">
      <summary>
        Identify a file containing resource information.
      </summary>
      <remarks>
        This class is used to create objects that can be used to identify resource entities.
      </remarks>
      <example>
        The following example uses various methods of the ResourceFile, ResourceID, and the ResourceString classes to display resource strings embedded in an .EXE file:
        <code language="X#">
          CLASS MyMenu INHERIT Menu
          CLASS MyResFile INHERIT ResourceFile
          CLASS MyTopAppWin INHERIT TopAppWindow
          DEFINE IDM_MYMENU := "MyMenu"
          DEFINE IDM_MYMENU_GETSTR1_ID := 1001
          DEFINE IDM_MYMENU_GETSTR2_ID := 1002
          DEFINE IDM_MYMENU_QUIT_ID := 1003
          DEFINE IDT_STR1 := 2001
          DEFINE IDT_STR2 := 2002
          RESOURCE IDM_MYMENU MENU
          BEGIN
          POPUP "&amp;Menu1"
          BEGIN
          MENUITEM "Get String &amp;1", 	;
          IDM_MYMENU_GETSTR1_ID
          MENUITEM "Get String &amp;2", ;
          IDM_MYMENU_GETSTR2_ID
          MENUITEM SEPARATOR
          MENUITEM "&amp;QUIT", IDM_MYMENU_QUIT_ID
          END
          END
          RESOURCE STRINGTABLE
          BEGIN
          IDT_STR1 "The 1st String"
          IDT_STR2 "The second string is 35 chars long."
          END
          METHOD Start() CLASS App
          LOCAL oWin AS Window
          oWin := MyTopAppWin{SELF}
          oWin:Show()
          SELF:Exec()
          METHOD Init(oOwnerApp) CLASS MyTopAppWin
          LOCAL lRetVal AS LONG
          SUPER:Init(oOwnerApp)
          SELF:Menu := MyMenu{SELF}
          SELF:Caption := "Resource File Demo Application"
          METHOD Init(oOwner) CLASS MyMenu
          SUPER:Init(ResourceID{IDM_MYMENU})
          SELF:RegisterItem(IDM_MYMENU_GETSTR1_ID,;
          HyperLabel{#GetStr1,,,})
          SELF:RegisterItem(IDM_MYMENU_GETSTR2_ID,;
          HyperLabel{#GetStr2,,,})
          SELF:RegisterItem(IDM_MYMENU_QUIT_ID,;
          HyperLabel{#GoQuit,,,})
          METHOD Init(fName) CLASS MyResFile
          IF fName == NIL
          SUPER:Init()
          ELSE
          SUPER:Init(fName)
          ENDIF
          METHOD GetStr1() CLASS MyTopAppWin
          SELF:GetStrX(IDT_STR1, 0)
          METHOD GetStr2() CLASS MyTopAppWin
          SELF:GetStrX(IDT_STR2, 100)
          METHOD GetStrX(nStrX,dy) CLASS MyTopAppWin
          LOCAL oResFile, oResID, oResString AS OBJECT
          oResFile := MyResFile{"c:\cavo\mytstprg.exe"}
          oResID := ResourceID{nStrX ,oResFile}
          oResString := ResourceString{oResID}
          SELF:TextPrint(AsString(nStrX),Point{10, 10+dy})
          SELF:TextPrint(AsString(oResString:Length),;
          Point{10, 30 + dy})
          SELF:TextPrint(AsString(oResString:Value),;
          Point{10, 50 + dy})
          SELF:TextPrint(AsString(oResString:AsString()),;
          Point{10, 70 + dy})
          METHOD GoQuit() CLASS MyTopAppWin
          SELF:Owner:Quit()
        </code></example>
    </member>
    <member name="M:VO.ResourceFile.#ctor(XSharp.__Usual)">
      <summary>
        Construct a resource file object.
      </summary>
      <param name="sName">The name of the resource file, either an .EXE or .DLL file.  If omitted, the default is the executable (.EXE) program file name.</param>
    </member>
    <member name="M:VO.ResourceFile.Destroy">
      <summary>
        Provide a method to de-instantiate a ResourceFile object.
      </summary>
      <remarks>
        This method can be used when a ResourceFile object is no longer needed.  ResourceFile:Destroy() de-instantiates the ResourceFile object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.ResourceFile.Handle">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.ResourceID">
      <summary>
        Identify and create a ResourceID using a numeric resource ID.
      </summary>
      <remarks>
        This class is used to identify application resources stored as numeric values in a resource entity.  A resource may be a cursor, icon, bitmap, string, or a font.
      </remarks>
      <example>
        For an example using the ResourceID class, refer to the ResourceFile class example.
      </example>
    </member>
    <member name="M:VO.ResourceID.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a ResourceID object.
      </summary>
      <param name="xID">The unique ID between 1 and 8000 of the resource ID or a string describing the resource.  
        Strings can only identify resource blocks, such as dialogs or menus.  For individual controls, you must use numeric IDs.</param>
      <param name="xResourceFile">The resource file that includes the resource.  The default is the current executable file.</param>
    </member>
    <member name="M:VO.ResourceID.Address">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.ResourceID.Handle">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.ResourceID.ID">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.ResourceString">
      <summary>
        Extract strings from a resource entity.
      </summary>
      <remarks>
        You can use this facility to provide language-independent applications (for example, substitute French text for German text and recompile the resource entity).
      </remarks>
      <example>
        For an example using the ResourceString class, refer to the ResourceFile class example.
      </example>
    </member>
    <member name="M:VO.ResourceString.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Load a resource string from the resource entity.
      </summary>
      <param name="xResourceID">The resource ID of the desired string.</param>
      <param name="nMaxLen">The maximum length that you expect the string to be in any language.  For example, if the string is translated into French, it can be longer than in English.  The default is 255.  If you set it too low, Windows truncates the resource string.</param>
    </member>
    <member name="M:VO.ResourceString.AsString">
      <summary>
        Return the text stored in a resource string.
      </summary>
    </member>
    <member name="M:VO.ResourceString.Destroy">
      <summary>
        Provide a method to de-instantiate a ResourceString object.
      </summary>
      <remarks>
        This method can be used when a ResourceString object is no longer needed.  ResourceString:Destroy() de-instantiates the ResourceString object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="P:VO.ResourceString.Length">
      <summary>
        A numeric value representing the length — the number of characters — of a ResourceString object.
      </summary>
      <value>A numeric value representing the length — the number of characters — of a ResourceString object.</value>
    </member>
    <member name="P:VO.ResourceString.Value">
      <summary>
        The value held in the ResourceString object.
      </summary>
      <value>The value held in the ResourceString object.</value>
    </member>
    <member name="T:VO.RichEdit">
      <summary>
        Create a rich edit control.
      </summary>
      <remarks>
        A rich edit is a control in which the user can enter and edit text.  The text can be assigned character and paragraph formatting, as well as background and foreground color.  The rich edit provides a programming interface for printing and searching for text and word breaks.
      </remarks>
    </member>
    <member name="M:VO.RichEdit.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a rich edit.
      </summary>
      <param name="oOwner">The window that owns the rich edit.</param>
      <param name="xID">The unique ID of the rich edit (between 1 and 8000).</param>
      <param name="nResourceID">The resource ID of the rich edit.</param>
      <param name="oPoint">The origin of the rich edit in canvas coordinates.</param>
      <param name="oDimension">The dimension of the rich edit in canvas coordinates.</param>
      <param name="kStyle">The style of the rich edit.</param>
    </member>
    <member name="P:VO.RichEdit.Alignment">
      <summary>
        A constant representing the paragraph alignment of the rich edit:
      </summary>
      <value>A constant representing the paragraph alignment of the rich edit:</value>
      <remarks>
        One of the following constants representing the paragraph alignment of the rich edit:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>REPARA_CENTER</term><description>Text is centered</description></item><item><term>REPARA_LEFT</term><description>Text is left-aligned</description></item><item><term>REPARA_RIGHT</term><description>Text is right-aligned</description></item></list></remarks>
    </member>
    <member name="P:VO.RichEdit.BackgroundColor">
      <summary>
        A Color object representing the background color of the rich edit
      </summary>
      <value>A Color object representing the background color of the rich edit</value>
    </member>
    <member name="M:VO.RichEdit.CanPaste(XSharp.__Usual)">
      <summary>
        Determine whether the rich edit can paste the specified clipboard format.
      </summary>
      <param name="dwClipboardFormat">
        The specified Clipboard format.  If not specified, it defaults to 0, meaning that the rich edit object will try any format currently on the Clipboard.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">Refer to the SetClipboardData() function in your Microsoft Win32 Software Development Kit documentation for definitions of valid format constants.</note>
      </remarks>
    </member>
    <member name="P:VO.RichEdit.ControlFont">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.RichEdit.EnableAdvancedTypography(XSharp.__Usual)">
      <summary>
        Sets the ability for advanced line breaking and line formatting.
      </summary>
      <param name="lEnable">TRUE turns this on, False turns this off.</param>
    </member>
    <member name="P:VO.RichEdit.Font(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        A Font object representing the font selection for the text or a portion of the text in the rich edit.
      </summary>
      <value>A Font object representing the font selection for the text or a portion of the text in the rich edit.</value>
    </member>
    <member name="M:VO.RichEdit.GetOption(XSharp.__Usual)">
      <summary>
        Determine the status of a particular option for the rich edit.
      </summary>
      <param name="kOption">One of the following constants representing the option whose status you want to check:</param>
      <returns>
        TRUE if the option is enabled; otherwise, FALSE.
      </returns>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>REOPT_AUTOWORD</term>
            <description>Automatic selection of a word on double-click</description>
          </item>
          <item>
            <term>REOPT_AUTOVSCROLL</term>
            <description>Automatic vertical scrolling</description>
          </item>
          <item>
            <term>REOPT_AUTOHSCROLL</term>
            <description>Automatic horizontal scrolling</description>
          </item>
          <item>
            <term>REOPT_NOHIDESEL</term>
            <description>Selection is not hidden when focus is lost</description>
          </item>
          <item>
            <term>REOPT_READONLY</term>
            <description>Editing of text is not permitted</description>
          </item>
          <item>
            <term>REOPT_WANTRETURN</term>
            <description>Captures carriage return keystrokes</description>
          </item>
          <item>
            <term>REOPT_SAVESEL</term>
            <description>Selection is saved focus is lost</description>
          </item>
          <item>
            <term>REOPT_SELBAR</term>
            <description>Has a selection bar</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:VO.RichEdit.GetTabStops">
      <summary>
        Set the TabStops for a rich edit control.
      </summary>
      <returns>
        An array of tab values.
      </returns>
      <remarks>
        The tab array that is returned contains the tab-values. Each tab-value is a subarray with two values.
        The first one is the tab-position in cm.
        The second is the tab-alignment defined by one of these constants -
        RICHTAB_CENTER
        RICHTAB_DECIMAL
        RICHTAB_NORMAL
        RICHTAB_RIGHT
      </remarks>
    </member>
    <member name="M:VO.RichEdit.GetTextRange(XSharp.__Usual)">
      <summary>
        Retrieve a range of characters from the rich edit.
      </summary>
      <param name="oRange">The range of characters to retrieve.</param>
      <returns>
        A string representing the retrieved range of characters.
      </returns>
    </member>
    <member name="M:VO.RichEdit.GetWordBreak(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Locate a particular type of word break in the rich edit.
      </summary>
      <param name="nCharPos">The character position from which to find the work break.</param>
      <param name="kWordBreakType">One of the following constants representing the type of word break to retrieve:</param>
      <returns>
        If &lt;kWordBreakType&gt; is REGWB_ISDELIMITER this function returns a logical value that is TRUE if the specified character is a delimiter and FALSE otherwise.  If &lt;kWordBreakType&gt; is any other value, the function returns a numeric value representing the character position of the word break.
      </returns>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>REGWB_ISDELIMITER</term>
            <description>Determines whether the specified character is a delimiter.  This option causes a logical return value.</description>
          </item>
          <item>
            <term>REGWB_LEFT</term>
            <description>Finds the nearest character before the specified position that begins a word.</description>
          </item>
          <item>
            <term>REGWB_LEFTBREAK</term>
            <description>Finds the next word end before the specified position.</description>
          </item>
          <item>
            <term>REGWB_MOVEWORDLEFT</term>
            <description>Finds the next character that begins a word before the specified position.</description>
          </item>
          <item>
            <term>REGWB_RIGHT</term>
            <description>Finds the nearest character after the specified position that begins a word.</description>
          </item>
          <item>
            <term>REGWB_RIGHTBREAK</term>
            <description>Finds the next word end after the specified position.</description>
          </item>
          <item>
            <term>REGWB_MOVEWORDRIGHT</term>
            <description>Finds the next character that begins a word after the specified position.</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:VO.RichEdit.HideSelection(XSharp.__Usual)">
      <summary>
        Hide the selection in the rich edit.
      </summary>
      <param name="lTemporary">A logical value that is TRUE if the selection will be hidden temporarily and FALSE otherwise.  If omitted, the default is TRUE.</param>
    </member>
    <member name="M:VO.RichEdit.LineFromCharacter(XSharp.__Usual)">
      <summary>
        Determine the line number of the rich edit from the specified character position.
      </summary>
      <param name="nCharacterPos">A numeric value specifying the character position whose line number you want to obtain.</param>
      <returns>
        The line number of the specified character position.
      </returns>
    </member>
    <member name="M:VO.RichEdit.LoadFromFile(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Load data from an RTF file into the rich edit control.
      </summary>
      <param name="cFileName">The name of the file you wish to load.</param>
      <param name="dwFormat">** missing parameter documentation **</param>
      <returns>
        TRUE, if successful; otherwise FALSE.
      </returns>
      <remarks>
        If successful, the current contents of the rich edit control will be replaced with the contents of the RTF file.
      </remarks>
    </member>
    <member name="M:VO.RichEdit.Margin(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the margins for the currently selected text in the rich edit control.
      </summary>
      <param name="nStart">Integer representing the indentation of the first line in the paragraph.</param>
      <param name="nRight">Integer representing the right margin of the paragraph.</param>
      <param name="nOffset">Integer representing the indentation of the second line and subsequent lines, relative to &lt;nStart&gt;.  If this value is positive, a hanging indent is created (first line is 'outdented' and the subsequent lines are indented).  If this value is negative, the first line is indented and the subsequent lines are outdented.</param>
      <returns>
        TRUE, if successful; otherwise FALSE.
      </returns>
      <remarks>
        This method is equivalent to setting the RichEdit:PrimaryIndent, RichEdit:RightMargin, and RichEdit:SecondaryIndent properties.
      </remarks>
    </member>
    <member name="P:VO.RichEdit.Numbering">
      <summary>
        A constant representing the type of paragraph numbering currently associated with the rich edit:
      </summary>
      <value>A constant representing the type of paragraph numbering currently associated with the rich edit:</value>
      <remarks>
        One of the following constants representing the type of paragraph numbering currently associated with the rich edit:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>REPARA_NUMBER</term><description>Paragraphs are numbered</description></item><item><term>REPARA_BULLET</term><description>Paragraphs are bulleted</description></item></list></remarks>
    </member>
    <member name="M:VO.RichEdit.PasteSpecial(XSharp.__Usual)">
      <summary>
        Paste a particular clipboard format in the rich edit.
      </summary>
      <param name="dwClipboardFormat">The specified clipboard format.  Refer to the SetClipboardData() function in your Microsoft Win32 Software Development Kit documentation for definitions of valid format constants.</param>
    </member>
    <member name="P:VO.RichEdit.PrimaryIndent">
      <summary>
        A numeric value representing the indent of the first line of a paragraph in the rich edit.
      </summary>
      <value>A numeric value representing the indent of the first line of a paragraph in the rich edit.</value>
    </member>
    <member name="M:VO.RichEdit.Print(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Print the contents of the rich edit.
      </summary>
      <param name="oPrintingDevice">The PrintingDevice object or printing device name that will receive the output.  If omitted, a print dialog box is raised for the user to choose a print destination.</param>
      <param name="oRange">The range of characters to print.  If omitted, the entire range of characters is printed.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.RichEdit.Protected">
      <summary>
        A logical value that is TRUE if the text in the rich edit is protected from modification.
      </summary>
      <value>A logical value that is TRUE if the text in the rich edit is protected from modification.</value>
    </member>
    <member name="P:VO.RichEdit.RightMargin">
      <summary>
        A numeric value representing the right margin of the rich edit.
      </summary>
      <value>A numeric value representing the right margin of the rich edit.</value>
    </member>
    <member name="M:VO.RichEdit.SaveToFile(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Save the current contents of the control to an RTF file.
      </summary>
      <param name="cFileName">The name of the file to which you wish to save.</param>
      <param name="dwFormat">** missing parameter documentation **</param>
      <returns>
        TRUE, if successful; otherwise FALSE.
      </returns>
    </member>
    <member name="P:VO.RichEdit.SecondaryIndent">
      <summary>
        A numeric value representing the indent of the second and subsequent lines of a paragraph in the rich edit.
      </summary>
      <value>A numeric value representing the indent of the second and subsequent lines of a paragraph in the rich edit.</value>
    </member>
    <member name="M:VO.RichEdit.Seek(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Search the rich edit for the specified text.
      </summary>
      <param name="cText">The text for which to search.</param>
      <param name="oRange">The range of characters in which to search.</param>
      <param name="lMatchCase">A logical value that is TRUE if the search is case-sensitive.  If omitted, the default is FALSE.</param>
      <param name="lWholeWord">A logical value that is TRUE if the search must match on a whole word.  If omitted, the default is FALSE.</param>
      <param name="lReturnRange">A logical value that is FALSE if the return value will be the numeric character position of the found text or TRUE if it will be a Range object representing the range of characters in which the text was found.  If omitted, the default is FALSE.</param>
      <param name="lSearchUp">
        If lSearchUp is TRUE, the search is from the end of the current selection to the beginning of the document. If lSearchUp is FALSE, the search is from the end of the current selection to the end of the document. If omitted the default is FALSE.
        For Rich Edit 1.0 the lSearchUp parameter is ignored. The search is always from the end of the current selection to the end of the document.
      </param>
      <returns>
        If &lt;lReturnRange&gt; is TRUE, the range of characters in which the text was found.  If &lt;lReturnRange&gt; is FALSE, the character position where the text was found.
      </returns>
    </member>
    <member name="P:VO.RichEdit.SelectedText">
      <summary>
        A string representing the currently selected text in the rich edit.
      </summary>
      <value>A string representing the currently selected text in the rich edit.</value>
    </member>
    <member name="P:VO.RichEdit.Selection">
      <summary>
        A Selection object representing the currently selected text in the rich edit.
      </summary>
      <value>A Selection object representing the currently selected text in the rich edit.</value>
    </member>
    <member name="P:VO.RichEdit.SelectionType">
      <summary>
        A constant representing the type of the current selection in the rich edit:
      </summary>
      <value>A constant representing the type of the current selection in the rich edit:</value>
      <remarks>
        One of the following constants representing the type of the current selection in the rich edit:

        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>RESEL_EMPTY</term><description>Current selection is empty</description></item><item><term>RESEL_TEXT</term><description>Current selection is text</description></item></list></remarks>
    </member>
    <member name="M:VO.RichEdit.SetOption(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set an option for the rich edit.
      </summary>
      <param name="kOption">One of the following constants representing the option you want to set:</param>
      <param name="symOperation">
        One of the following symbolic names representing the operation to perform:
        <pre>
          Operation		Description
          #Add			Add this option to the current options. This is the default.
          #Change		Change to this option, removing all other options
          #Keep			Keep only this option
          #Remove		Remove only this option
        </pre></param>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>REOPT_AUTOWORD</term>
            <description>Automatic selection of a word on double-click</description>
          </item>
          <item>
            <term>REOPT_AUTOVSCROLL</term>
            <description>Automatic vertical scrolling</description>
          </item>
          <item>
            <term>REOPT_AUTOHSCROLL</term>
            <description>Automatic horizontal scrolling</description>
          </item>
          <item>
            <term>REOPT_NOHIDESEL</term>
            <description>Selection is not hidden when focus is lost</description>
          </item>
          <item>
            <term>REOPT_READONLY</term>
            <description>Editing of text is not permitted</description>
          </item>
          <item>
            <term>REOPT_WANTRETURN</term>
            <description>Captures carriage return keystrokes</description>
          </item>
          <item>
            <term>REOPT_SAVESEL</term>
            <description>Selection is saved focus is lost</description>
          </item>
          <item>
            <term>REOPT_SELBAR</term>
            <description>Has a selection bar</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:VO.RichEdit.SetTabStops(XSharp.__Usual)">
      <summary>
        Set the TabStops for a rich edit control.
      </summary>
      <param name="aTabStops">An array of values.</param>
      <remarks>
        The Tab array contains the tab-values. Each tab-value is a subarray with two values.
        The first one is the tab-position in cm.
        The second is the tab-alignment defined by one of these constants -
        RICHTAB_CENTER
        RICHTAB_DECIMAL
        RICHTAB_NORMAL
        RICHTAB_RIGHT
      </remarks>
    </member>
    <member name="M:VO.RichEdit.ShowSelection(XSharp.__Usual)">
      <summary>
        Show the selection in the rich edit.
      </summary>
      <param name="lTemporary">A logical value that is TRUE if the selection will be shown temporarily and FALSE otherwise.  If omitted, the default is TRUE.</param>
    </member>
    <member name="P:VO.RichEdit.TabStopCount">
      <summary>
        A numeric value representing the number of tab stops in the rich edit.
      </summary>
      <value>A numeric value representing the number of tab stops in the rich edit.</value>
    </member>
    <member name="P:VO.RichEdit.TextColor">
      <summary>
        A Color object representing the text color of the rich edit.
      </summary>
      <value>A Color object representing the text color of the rich edit.</value>
    </member>
    <member name="P:VO.RichEdit.TextLimit">
      <summary>
        A numeric value representing the maximum amount of text in the rich edit.  The default is 32 KB.
      </summary>
      <value>A numeric value representing the maximum amount of text in the rich edit.  The default is 32 KB.</value>
    </member>
    <member name="P:VO.RichEdit.Value">
      <summary>
        A string representing the text contents of the rich edit
      </summary>
      <value>A string representing the text contents of the rich edit</value>
    </member>
    <member name="P:VO.RichEdit.ValueAsText">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.RichEditCallback.#ctor(System.Object,System.IntPtr)">
      <exclude />
    </member>
    <member name="M:VO.RichEditCallback.BeginInvoke(System.UInt32,System.Byte*,System.Int32,System.Int32*,System.AsyncCallback,System.Object)">
      <exclude />
    </member>
    <member name="M:VO.RichEditCallback.EndInvoke(System.IAsyncResult)">
      <exclude />
    </member>
    <member name="M:VO.RichEditCallback.Invoke(System.UInt32,System.Byte*,System.Int32,System.Int32*)">
      <exclude />
    </member>
    <member name="T:VO.RichEditProtectEvent">
      <summary>
        Provide information about a rich edit protection event, which is generated when the user attempts to edit protected text in a rich edit control.
      </summary>
      <remarks>
        The rich edit generates this message when an attempt is made to edit protected text in the rich edit.  Text is protected by calling RichEdit:Protect().

      </remarks>
    </member>
    <member name="M:VO.RichEditProtectEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <exclude />
    </member>
    <member name="P:VO.RichEditProtectEvent.Selection">
      <summary>
        A selection object representing the selection range in the rich edit.
      </summary>
      <value>A selection object representing the selection range in the rich edit.</value>
    </member>
    <member name="P:VO.RichEditProtectEvent.SelectionRange">
      <summary>
        A Range object representing the selection range in the rich edit.
      </summary>
      <value>A Range object representing the selection range in the rich edit.</value>
    </member>
    <member name="T:VO.RichEditSelectionEvent">
      <summary>
        Provide information about a rich edit selection event, which is generated when the selection in a rich edit control is changed.
      </summary>
      <remarks>
        The rich edit generates this message when the selection is changed in a rich edit.  Properties of the event include the type of the new selection and the new selection range.

      </remarks>
    </member>
    <member name="M:VO.RichEditSelectionEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <exclude />
    </member>
    <member name="P:VO.RichEditSelectionEvent.Selection">
      <summary>
        A selection object representing the selection range in the rich edit.
      </summary>
      <value>A selection object representing the selection range in the rich edit.</value>
    </member>
    <member name="P:VO.RichEditSelectionEvent.SelectionRange">
      <summary>
        A Range object representing the new selection range in the rich edit.
      </summary>
      <value>A Range object representing the new selection range in the rich edit.</value>
    </member>
    <member name="P:VO.RichEditSelectionEvent.SelectionType">
      <summary>
        A constant representing the type of the newly changed selection in the rich edit:
      </summary>
      <value>A constant representing the type of the newly changed selection in the rich edit:</value>
      <remarks>
        One of the following constants representing the type of the newly changed selection in the rich edit:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>RESEL_EMPTY</term><description>Current selection is empty</description></item><item><term>RESEL_TEXT</term><description>Current selection is text</description></item></list></remarks>
    </member>
    <member name="T:VO.SaveAsDialog">
      <summary>
        Provide standard save-file dialog facilities.
      </summary>
    </member>
    <member name="M:VO.SaveAsDialog.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a standard SaveAs dialog box.
      </summary>
      <param name="oOwnWnd">The window that owns the SaveAsDialog object.</param>
      <param name="cInitPath">The preset file name to display in the dialog.  Use this, for example, to prompt the user with the current name of the file.  You can also specify wild-cards, such as *.TXT.  The default is a NULL_STRING.</param>
      <param name="dwFlag">Reserved for future use.</param>
    </member>
    <member name="T:VO.ScrollBar">
      <summary>
        Provide the base class from which all X# scroll bars are subclassed.
      </summary>
      <remarks>
        Scroll bars have a marker, called a thumb, which can be dragged up and down (or left and right) within a range of values.  The thumb can be dragged to different positions on the scroll bar, or it can step up or down in blocks or units.
        GUI scroll bars automatically maintain block and unit operations.  When a block or unit operation takes place, a ScrollEvent is generated with both the actual thumb position and the position the thumb would assume if the scroll bar is updated.  The block and unit amounts are added or subtracted from the current position according to the scroll type that occurs.
        By default, a scroll bar has a range of (0,99), a unit size of 1, a block size of 10, and an initial thumb position of 0.
      </remarks>
    </member>
    <member name="P:VO.ScrollBar.">
      <summary>
        A numeric value representing the thumb position of the scroll bar.
      </summary>
      <value>A numeric value representing the thumb position of the scroll bar.</value>
      <remarks>
        A numeric value representing the thumb position of the scroll bar.  For example, the value can be the number 42.  The ScrollBar:Value assign also changes ScrollBar:TextValue and ScrollBar:ThumbPosition.  If the value to be assigned is outside the allowable Min-Max range associated with the scroll bar, the value is modified so it is either the Min or Max value.
      </remarks>
    </member>
    <member name="M:VO.ScrollBar.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a scroll bar.
      </summary>
      <param name="oOwner">The window that owns the scroll bar.</param>
      <param name="xID">The unique ID between 1 and 8000 of the scroll bar.</param>
      <param name="oPoint">The origin of the scroll bar, in canvas coordinates.</param>
      <param name="oDimension">The dimension of the scroll bar, in canvas coordinates.</param>
      <param name="oResourceID">The resource ID of the scroll bar.</param>
      <param name="lDataAware">A logical value specifying whether the list box is data aware.</param>
    </member>
    <member name="P:VO.ScrollBar.BlockSize">
      <summary>
        A numeric value representing the block size of the scroll bar
      </summary>
      <value>A numeric value representing the block size of the scroll bar</value>
      <remarks>
        A numeric value representing the block size of the scroll bar.  
        The block size is used to calculate the new position of the thumb when a BLOCKINCREMENT or BLOCKDECREMENT ScrollEvent occurs,
        which is one of the event types recognized by the ScrollEvent:Type access.
        The BlockSize is initially set to 10, but may be modified at runtime to change the behavior of the scroll bar.
      </remarks>
    </member>
    <member name="M:VO.ScrollBar.Create">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.ScrollBar.Destroy">
      <summary>
        Provide a method to de-instantiate a ScrollBar object.
      </summary>
      <remarks>
        This method can be used when a ScrollBar object is no longer needed.  ScrollBar:Destroy() de-instantiates the ScrollBar object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.ScrollBar.Hide">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.ScrollBar.Modified">
      <summary>
        A logical value that is set to FALSE for a scroll bar since it does not contain text that can be edited.
      </summary>
      <value>A logical value that is set to FALSE for a scroll bar since it does not contain text that can be edited.</value>
    </member>
    <member name="P:VO.ScrollBar.PageSize">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.ScrollBar.Range">
      <summary>
        A range object representing the minimum and maximum values currently in use for the thumb of a scroll bar.
      </summary>
      <value>A range object representing the minimum and maximum values currently in use for the thumb of a scroll bar.</value>
    </member>
    <member name="M:VO.ScrollBar.SetInfo(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set all scrollbar properties with one method call.
      </summary>
      <param name="oScrollRange">Specifies the minimum and maximum scrolling position.</param>
      <param name="nThumbPosition">Specifies the position of the scroll box.</param>
      <param name="nPageSize">Specifies the page size. A scroll bar uses this value to determine the appropriate size of the proportional scroll box. </param>
      <param name="lDisableNoScroll">Disables the scroll bar instead of removing it, if the scroll bar's new parameters make the scroll bar unnecessary.</param>
    </member>
    <member name="M:VO.ScrollBar.SetThumbPosition(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the thumb position of the scrollbar
      </summary>
      <param name="nPosition">New position of the thumb.</param>
      <param name="lNotifyOwner">Should the owner be notified? When TRUE then the owner receives a WM_HSCROLL or WM_VSCROLL with a wParam SB_THUMBTRACK and lParam contains the scrollbar handle.</param>
    </member>
    <member name="M:VO.ScrollBar.Show">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.ScrollBar.TextValue">
      <summary>
        A string representing the thumb position of the scroll bar.
      </summary>
      <value>A string representing the thumb position of the scroll bar.</value>
      <remarks>
        A string representing the thumb position of the scroll bar.  For example, the value can be "42".  
        The ScrollBar:TextValue assign also changes ScrollBar:ThumbPosition and ScrollBar:Value.  
        If the value to be assigned is outside the allowable Min-Max range associated with the scroll bar, the value is modified so it is either the Min or Max value.
      </remarks>
    </member>
    <member name="P:VO.ScrollBar.ThumbPosition">
      <summary>
        A numeric value (short integer) representing the current thumb position of the scroll bar.
      </summary>
      <value>A numeric value (short integer) representing the current thumb position of the scroll bar.</value>
      <remarks>
        A numeric value (short integer) representing the current thumb position of the scroll bar.  
        For example, the value can be the number 42.  The ThumbPosition assign also changes ScrollBar:TextValue and ScrollBar:Value.  
        If the value to be assigned is outside the allowable range associated with the scroll bar, the value is modified so it is either the Min or Max value defined for the Range object.  When the scroll bar is created, the ThumbPosition is initialized to 99, or if 99 exceeds the Max value, to the Max value.
      </remarks>
    </member>
    <member name="P:VO.ScrollBar.UnitSize">
      <summary>
        A numeric value representing the unit size currently associated with the scroll bar.
      </summary>
      <value>A numeric value representing the unit size currently associated with the scroll bar.</value>
      <remarks>
        A numeric value representing the unit size currently associated with the scroll bar.  
        The unit size is used to calculate the new thumb position when a UNITINCREMENT or UNITDECREMENT ScrollEvent occurs.
        When a scroll bar is created, ScrollBar:UnitSize is initialized to 1.  The ScrollBar:UnitSize can be changed at runtime to alter the behavior of the scroll bar.
      </remarks>
    </member>
    <member name="P:VO.ScrollBar.Value">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.ScrollEvent">
      <summary>
        Provide information about a ScrollEvent, generated when a scroll bar is manipulated.
      </summary>
      <remarks>
        ScrollEvent events go to either Window:VerticalScroll() or Window:HorizontalScroll(), depending on whether a vertical or horizontal scroll bar generated the event.
        A ScrollEvent reports the following:  what scroll bar caused the event, what type of scroll movement is requested, and whether the scroll bar is a window or a free-standing scroll bar.
        It also reports the old scroll bar position and the desired position.  The old position is where the thumb was located before being manipulated by the user; the desired position is where the user has newly positioned the thumb (if the thumb is manipulated directly or calculated from the block and unit sizes).
      </remarks>
      <example>
        Normally, when you receive a ScrollEvent, you would update the scroll bar's thumb position with code similar to the following:
        <code language="X#">aScrollEvt:ScrollBar:ThumbPosition := aScrollEvt:Position</code></example>
    </member>
    <member name="M:VO.ScrollEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ScrollEvent.IsWindowScroll">
      <summary>
        A logical value indicating whether the scroll bar which generated this ScrollEvent was a window scroll bar or a free-standing scroll bar.
      </summary>
      <value>A logical value indicating whether the scroll bar which generated this ScrollEvent was a window scroll bar or a free-standing scroll bar.</value>
      <remarks>
        A logical value indicating whether the scroll bar which generated this ScrollEvent was a window scroll bar or a free-standing scroll bar.
        If a window scroll bar generated this ScrollEvent, TRUE is returned; if it was a free-standing scroll bar, FALSE is returned.
      </remarks>
    </member>
    <member name="P:VO.ScrollEvent.OldPosition">
      <summary>
        A numeric value representing the old position of the thumb in a scroll bar when this ScrollEvent occurred (that is, where the thumb was located before being manipulated by the user).
      </summary>
      <value>A numeric value representing the old position of the thumb in a scroll bar when this ScrollEvent occurred (that is, where the thumb was located before being manipulated by the user).</value>
      <remarks>
        A numeric value representing the old position of the thumb in a scroll bar when this ScrollEvent occurred (that is, where the thumb was located before being manipulated by the user).
        By subtracting ScrollEvent:Position from ScrollEvent:OldPosition, the relative difference can be used for scrolling the thumb.
      </remarks>
    </member>
    <member name="P:VO.ScrollEvent.Position">
      <summary>
        A numeric value representing the desired position of the thumb in a scroll bar when this ScrollEvent occurred (that is, where the user has newly positioned the thumb).
      </summary>
      <value>A numeric value representing the desired position of the thumb in a scroll bar when this ScrollEvent occurred (that is, where the user has newly positioned the thumb).</value>
      <remarks>
        A numeric value representing the desired position of the thumb in a scroll bar when this ScrollEvent occurred (that is, where the user has newly positioned the thumb).
        By subtracting ScrollEvent:Position from ScrollEvent:OldPosition, the relative difference can be used for scrolling the thumb.
      </remarks>
    </member>
    <member name="P:VO.ScrollEvent.ScrollBar">
      <summary>
        The scroll bar that generated this ScrollEvent.
      </summary>
      <value>The scroll bar that generated this ScrollEvent.</value>
    </member>
    <member name="P:VO.ScrollEvent.ScrollBarID">
      <summary>
        The ID of the scroll bar that generated this ScrollEvent.
      </summary>
      <value>The ID of the scroll bar that generated this ScrollEvent.</value>
    </member>
    <member name="P:VO.ScrollEvent.TYPE">
      <summary>
        A string representing the type of scrolling action that took place when this ScrollEvent occurred.
      </summary>
      <value>A string representing the type of scrolling action that took place when this ScrollEvent occurred.</value>
      <remarks>
        A string representing the type of scrolling action that took place when this ScrollEvent occurred.
        One of the following values are returned:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>BLOCKDECREMENT</term><description>
              The thumb position has been decremented by one block. In Windows, one mouse click on the shaded area to the left of the thumb position on a horizontal scroll bar,
              or above the thumb position on a vertical scroll bar, is a block decrement.
            </description></item><item><term>BLOCKINCREMENT</term><description>
              The thumb position has been incremented by one block. In Windows, one mouse click on the shaded area to the right of the thumb position on a horizontal scroll bar,
              or below the thumb position on a vertical scroll bar, is a block increment.
            </description></item><item><term>SCROLLEND</term><description>Scrolling has finished.</description></item><item><term>SCROLLTHUMBDRAG</term><description>The thumb is being dragged (up or down).</description></item><item><term>UNITDECREMENT</term><description>
              The thumb position has been decremented by one unit. In Windows, one mouse click on the left arrow of a horizontal scroll bar,
              or on the up arrow for a vertical scroll bar, is a unit decrement.
            </description></item><item><term>UNITINCREMENT</term><description>
              The thumb position has been incremented by one unit. In Windows, one mouse click on the right arrow of a horizontal scroll bar,
              or on the down arrow of a vertical scroll bar, is a unit increment.
            </description></item></list></remarks>
    </member>
    <member name="T:VO.SelectDialog">
      <summary>
        Present the user with a standard color palette dialog box.
      </summary>
      <remarks>
        This type of dialog box presents the user with a palette of available colors as a series of "boxes," allowing the user to select a color by clicking a box.  The user is not allowed to create or select custom colors.
      </remarks>
    </member>
    <member name="M:VO.SelectDialog.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a standard color selection dialog.
      </summary>
      <param name="uOwner">The window that owns the SelectDialog object.</param>
      <param name="oColor">The color initially selected for the SelectDialog object.  The default is the color currently being used.  (Refer to the Color:Init() method for details on specifying a color.)</param>
    </member>
    <member name="T:VO.Selection">
      <summary>
        Create a selection, which represents the start and end of a text selection in an edit control as an ordered pair.
      </summary>
      <remarks>
        Selections are used in edit controls (i.e., by the Edit and EditWindow classes).  The start of a selection is the position in the edit control of the first character that is included in the selection.  The finish is the position of the first character not in the selection.  For example, to specify the text from position 5 through 9 inclusive, you would give a value of Selection{5,10}.
        To select all the characters in an edit control (such as a single-line edit control), you would specify a value of Selection{0,-1}.
        If the start and finish points are the same, the selection refers to a cursor position.  For example, the cursor position in front of the fifth character would be referred to as Selection{5,5}.
      </remarks>
    </member>
    <member name="M:VO.Selection.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a selection.
      </summary>
      <param name="nStart">The selection's start.  If omitted, the default is {0,0}.</param>
      <param name="nFinish">The selection's end.  If omitted, the default is {0,0}.</param>
    </member>
    <member name="P:VO.Selection.Finish">
      <summary>
        A numeric value representing the finish value in a selection.
      </summary>
      <value>A numeric value representing the finish value in a selection.</value>
    </member>
    <member name="P:VO.Selection.Start">
      <summary>
        A numeric value representing the start value in a selection.
      </summary>
      <value>A numeric value representing the start value in a selection.</value>
    </member>
    <member name="T:VO.SelectionSlider">
      <summary>
        Create a selection slider.
      </summary>
      <remarks>
        A selection slider is a control that contains a thumb, optional tick marks, and a selection bar.  The user can move the selection slider's thumb using either the mouse or the Direction keys.
      </remarks>
    </member>
    <member name="M:VO.SelectionSlider.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a selection slider.
      </summary>
      <param name="oOwner">The window that owns the selection slider.</param>
      <param name="xID">The unique ID between 1 and 8000 of the selection slider.</param>
      <param name="nResourceID">The resource ID of selection slider.</param>
      <param name="oPoint">The origin of the selection slider in canvas coordinates.</param>
      <param name="oDimension">The dimension of the selection slider in canvas coordinates.</param>
    </member>
    <member name="M:VO.SelectionSlider.ClearSelection">
      <summary>
        Clear the selection bar of the selection slider.
      </summary>
    </member>
    <member name="P:VO.SelectionSlider.SelectionRange">
      <summary>
        A Range object representing the minimum and maximum values currently in use for the selection bar of the slider.
      </summary>
      <value>A Range object representing the minimum and maximum values currently in use for the selection bar of the slider.</value>
    </member>
    <member name="T:VO.SelfPtr">
      <exclude />
    </member>
    <member name="F:VO.SelfPtr.ptrSelf">
      <exclude />
    </member>
    <member name="T:VO.ShapeObject">
      <summary>
        Provide an intermediate class from which all X# two-dimensional objects are subclassed.
      </summary>
      <remarks>
        <br />Important!  ShapeObject is an abstract class and should not be used directly — instead, use one of its subclasses, which include BitmapObject, EllipseObject, and RectangleObject.
      </remarks>
    </member>
    <member name="M:VO.ShapeObject.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a ShapeObject object.
      </summary>
      <param name="oPoint">The origin of the ShapeObject object, in canvas coordinates.</param>
      <param name="oDimension">The dimension of the ShapeObject object, in canvas coordinates.</param>
      <param name="oPen">The pen to be used in Draw().  If omitted, the currently selected pen is used.</param>
      <param name="oBrush">The brush to be used in Draw().  If omitted, the currently selected brush is used.</param>
    </member>
    <member name="P:VO.ShapeObject.BoundingBox">
      <summary>
        A bounding box representing the smallest rectangle that fully encloses the ShapeObject object.
      </summary>
      <value>A bounding box representing the smallest rectangle that fully encloses the ShapeObject object.</value>
    </member>
    <member name="P:VO.ShapeObject.Brush">
      <summary>
        A brush currently in use by the ShapeObject object to draw itself.
      </summary>
      <value>A brush currently in use by the ShapeObject object to draw itself.</value>
    </member>
    <member name="M:VO.ShapeObject.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.ShapeObject.Pen">
      <summary>
        A pen currently in use by the ShapeObject object to draw itself.
      </summary>
      <value>A pen currently in use by the ShapeObject object to draw itself.</value>
    </member>
    <member name="P:VO.ShapeObject.Size">
      <summary>
        A dimension representing the current size of the ShapeObject object, in canvas coordinates.
      </summary>
      <value>A dimension representing the current size of the ShapeObject object, in canvas coordinates.</value>
    </member>
    <member name="T:VO.ShellWindow">
      <summary>
        Create a shell window, which provides MDI support for your applications.
      </summary>
      <remarks>
        A shell window is similar to a top application window except that it acts as an MDI client window and all children of this window act as MDI child windows.

        The style of a child window is determined by the type of its owner.  By default, a child application window whose owner is a shell window automatically functions as an MDI child window.  If you do not desire this behavior, you can inhibit it using the ChildAppWindow:Init().

        When a child window is activated, its menu is automatically placed on the parent window.  When there are no open child windows, the parent's menu is used.  MenuCommand events are sent to any currently active child window.  If there is no active child window, the default event handler sends events to the parent.  For an in-depth discussion on event propagation, refer to the Programmer's Guide.

        With MDI applications, there is typically one pull-down menu which contains the captions of currently open MDI child windows.  The name of the currently active MDI window is checked on the menu; also, when the user selects one of the names on this menu, the system activates the corresponding MDI window.
        Use the Menu:SetAutoUpdate() method to specify which pull-down menu to use.
      </remarks>
    </member>
    <member name="M:VO.ShellWindow.#ctor(XSharp.__Usual)">
      <summary>
        Construct a shell window.
      </summary>
      <param name="oOwner">The window that owns the shell window.</param>
    </member>
    <member name="M:VO.ShellWindow.Arrange(XSharp.__Usual)">
      <summary>
        Tile, iconize, or cascade all the child windows that are currently open in this shell window.
      </summary>
      <param name="kArrangeStyle">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.ShellWindow.Background">
      <summary>
        This method is inherited from the Window class but does not apply to ShellWindow.
      </summary>
      <value>This method is inherited from the Window class but does not apply to ShellWindow.</value>
    </member>
    <member name="M:VO.ShellWindow.CanvasErase">
      <summary>
        This method is inherited from the Window class but does not apply to ShellWindow.
      </summary>
    </member>
    <member name="P:VO.ShellWindow.ChildToolBarLocation">
      <summary>
        Specifies the position of a child window's toolbar.
      </summary>
      <value>Specifies the position of a child window's toolbar.</value>
      <remarks>
        Specifies the position of a child window's toolbar.  Valid values are:
        TBL_CHILD
        The child's toolbar is displayed in the child window.  This is the <b>default</b> setting.
        TBL_SHELL
        The child's toolbar is displayed in the shell window and replaces the shell window's toolbar.
      </remarks>
    </member>
    <member name="M:VO.ShellWindow.CloseAllChildren">
      <summary>
        Send a close message to all open MDI child windows.
      </summary>
    </member>
    <member name="M:VO.ShellWindow.Default(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.ShellWindow.Destroy">
      <summary>
        Provide a method to free memory resources allocated for a ShellWindow object and its derived objects.
      </summary>
      <remarks>
        This method immediately frees resources for ShellWindow objects created explicitly in your application.
        ShellWindow:Destroy() also takes care of resources allocated to derived classes and deallocates them in the necessary order.
      </remarks>
    </member>
    <member name="M:VO.ShellWindow.Dispatch(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.ShellWindow.Draw(XSharp.__Usual)">
      <summary>
        This method is inherited from the Window class but does not apply to ShellWindow.
      </summary>
    </member>
    <member name="M:VO.ShellWindow.EnableOleStatusMessages(XSharp.__Usual)">
      <summary>
        Control the status message display of an in-place active OLE object.
      </summary>
      <param name="lEnable">A logical value specifying whether to enable (TRUE) or disable (FALSE) the status message display.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        After calling ShellWindow:EnableOLEStatusMessage(TRUE), browsing through the menu items of an in-place active OLE object will call ShellWindow:OnOLEStatusMessage() with the status string as a parameter.  By default, ShellWindow:OnOLEStatusMessage() displays the status string inside the shell window's status bar.
      </remarks>
    </member>
    <member name="P:VO.ShellWindow.Foreground">
      <summary>
        This method is inherited from the Window class but does not apply to ShellWindow.
      </summary>
      <value>This method is inherited from the Window class but does not apply to ShellWindow.</value>
    </member>
    <member name="M:VO.ShellWindow.GetActiveChild">
      <summary>
        Return the window object for the currently active MDI child window.
      </summary>
    </member>
    <member name="M:VO.ShellWindow.Handle(XSharp.__Usual)">
      <summary>
        Return the handle for a shell window.
      </summary>
      <param name="nHandleType">The type of handle required.  Specify 0 for the window handle and 2 for the window device context.  If omitted, 0 is the default.</param>
      <returns>
        A handle to the window, describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the window, which can then be used by Windows API calls.
      </remarks>
    </member>
    <member name="M:VO.ShellWindow.HelpRequest(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the user requests help from the application using one of the available context-sensitive help mechanisms.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oHelpRequestEvent">The HelpRequestEvent object that describes which item help is being requested for.</param>
      <remarks>
        This event handler is invoked only if the help mechanism has been enabled for the current window (or one of its owners).
        The help mechanism is enabled by assigning a HelpDisplay object to the windows HelpDisplay property.
        The default implementation of this event handler is to display the help topic that is associated with the control, menu command, or window region with focus when the HelpRequestEvent was generated.  This is accomplished using HelpDisplay:Show(&lt;cKeyword&gt;), where &lt;cKeyword&gt; is either a HyperLabel:HelpContext property or a default keyword generated by this event handler in cases where a hyperlabel is not available.
        If there is no hyperlabel for an item, the keyword generated is as follows:
        A HELPCONTROL request generates the keyword Control_xxxx, where xxxx is the numeric ID of the control, in decimal.  For example, an OK push button might generate the keyword Control_101.
        A HELPMENU request generates the keyword Menu_xxxx, where xxxx is the "cleaned" text of the menu command.  The cleaned text has all leading and trailing spaces and the ampersand character (&amp;) removed.  In addition, all sequences of spaces are replaced by a single underscore, and the string is truncated at the first tab character.
        For example, the keyword generated for the menu command:
        Save &amp;As\tF3
        is
        Menu_Save_As
        A HELPWINDOW request generates one of the keywords listed in the table below, depending on the window region that has focus.
        Keyword	Window Region
        Window_Border	Border
        Window_Caption	Title bar
        Window_MaxBox	Maximize button
        Window_MinBox	Minimize button
        Window_SysMenuBox	System menu button
        Window_Unknown	Any area of the window not explicitly identified in this table
        Window_WindowCanvas	Canvas area
        <note type="tip">If the Window_Unknown keyword is generated, the default behavior of HelpRequest() is to display the Contents topic as defined in the HelpDisplay (that is, HelpDisplay:Show("HelpIndex")).</note>
        If a HELPWINDOW request is received, while Window:HelpContext is defined, Window:HelpRequest() uses the HelpContext property, regardless of the window region that has focus.
        Refer to the "GUI Classes" chapter in the Programmer's Guide for more information on programming an online help system for your application.
      </remarks>
    </member>
    <member name="M:VO.ShellWindow.LineTo(XSharp.__Usual)">
      <summary>
        This method is inherited from the Window class but does not apply to ShellWindow.
      </summary>
    </member>
    <member name="M:VO.ShellWindow.MoveTo(XSharp.__Usual)">
      <summary>
        This method is inherited from the Window class but does not apply to ShellWindow.
      </summary>
    </member>
    <member name="M:VO.ShellWindow.OnOleStatusMessage(XSharp.__Usual)">
      <summary>
        Provide a handler routine called with an OLE object's status message.
      </summary>
      <param name="cMsgString">The status string to be displayed.</param>
      <remarks>
        ShellWindow:OnOLEStatusMessage() is called whenever an in-place active OLE object's menu is browsed by the user.  The default implementation displays the status string inside the shell window's status bar.
        It should never be necessary to call this method directly.  Instead, you can write your own OnOLEStatusMessage() method for derived classed if you want to change the default implementation.
      </remarks>
    </member>
    <member name="P:VO.ShellWindow.Owner">
      <summary>
        The owner of the shell window, either a Window or App object.
      </summary>
      <value>The owner of the shell window, either a Window or App object.</value>
    </member>
    <member name="M:VO.ShellWindow.PaintBoundingBox(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        This method is inherited from the Window class but does not apply to ShellWindow.
      </summary>
    </member>
    <member name="P:VO.ShellWindow.Pen">
      <summary>
        This method is inherited from the Window class but does not apply to ShellWindow.
      </summary>
      <value>This method is inherited from the Window class but does not apply to ShellWindow.</value>
    </member>
    <member name="M:VO.ShellWindow.RePaint">
      <summary>
        This method is inherited from the Window class but does not apply to ShellWindow.
      </summary>
    </member>
    <member name="M:VO.ShellWindow.RepaintBoundingBox(XSharp.__Usual)">
      <summary>
        This method is inherited from the Window class but does not apply to ShellWindow.
      </summary>
    </member>
    <member name="M:VO.ShellWindow.Resize(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.ShellWindow.TextColor">
      <summary>
        This method is inherited from the Window class but does not apply to ShellWindow.
      </summary>
      <value>This method is inherited from the Window class but does not apply to ShellWindow.</value>
    </member>
    <member name="M:VO.ShellWindow.TextPrint(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        This method is inherited from the Window class but does not apply to ShellWindow.
      </summary>
    </member>
    <member name="M:VO.ShellWindow.ToolBarHeightChanged(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="T:VO.SingleLineEdit">
      <summary>
        Create a single-line edit control for displaying and entering information to a variable or field in a server.
        Single-line edit controls may be bound to a data server field of any type (character, date, logical, numeric, or memo).
      </summary>
    </member>
    <member name="M:VO.SingleLineEdit.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a single-line edit control.
      </summary>
      <param name="oOwner">The window that owns the single-line edit control.</param>
      <param name="xID">The unique ID of the single-line edit control (between 1 and 8000).</param>
      <param name="oPoint">The origin of the single-line edit control in canvas coordinates.</param>
      <param name="oDimension">The dimension of the single-line edit control in canvas coordinates.</param>
      <param name="kStyle">The style of the single-line edit control, specified as one of the following constants:</param>
      <param name="nResourceID">The resource ID of the single-line edit control.</param>
      <remarks>
        <pre>
          Constant			Windows API Constant
          EDITAUTOHSCROLL	ES_AUTOHSCROLL
          EDITBORDERED		WS_BORDER
          EDITLOWERCASE		ES_LOWERCASE
          EDITNOHIDESEL		ES_NOHIDESEL
          EDITOEMCONVERT	ES_OEMCONVERT
          EDITPASSWORD		ES_PASSWORD
          EDITREADONLY		ES_READONLY
          EDITUPPERCASE		ES_UPPERCASE
        </pre>
        <note type="tip">In addition to the style constants specified above, you can use any Windows API style constant.  Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular constant.</note>
      </remarks>
    </member>
    <member name="P:VO.SingleLineEdit.AutoFocusChange">
      <summary>
        A logical value controlling whether the cursor should skip to the next control in the tab order if it reaches the end of the edit control.  The default is FALSE.
      </summary>
      <value>A logical value controlling whether the cursor should skip to the next control in the tab order if it reaches the end of the edit control.  The default is FALSE.</value>
    </member>
    <member name="M:VO.SingleLineEdit.CreateFormattedString(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Create formatted text according to the parameters provided.
      </summary>
      <param name="cPicture">The picture clause as a string.</param>
      <param name="cType">The unique ID of the single-line edit control (between 1 and 8000).</param>
      <param name="cDefTempl">The origin of the single-line edit control in canvas coordinates.</param>
      <remarks>
        This method allows the developer to create formatted text in a way other than by using the internal class __FormattedString and prevents the need for using an internal class to do a direct assignment.
      </remarks>
    </member>
    <member name="P:VO.SingleLineEdit.CurrentText">
      <summary>
        A string representing the text currently appearing in the edit box.
      </summary>
      <value>A string representing the text currently appearing in the edit box.</value>
      <remarks>
        A string representing the text currently appearing in the edit box.  The SingleLineEdit:CurrentText assign also changes SingleLineEdit:TextValue and SingleLineEdit:Value when the focus shifts to another control.
      </remarks>
    </member>
    <member name="M:VO.SingleLineEdit.Destroy">
      <summary>
        Provide a method to de-instantiate a SingleLineEdit object.
      </summary>
      <remarks>
        This method can be used when a SingleLineEdit object is no longer needed.  SingleLineEdit:Destroy() de-instantiates the SingleLineEdit object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.SingleLineEdit.Dispatch(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.SingleLineEdit.FocusChange(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oFocusChangeEvent">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.SingleLineEdit.FocusSelect">
      <summary>
        Controls the selection when the edit control gets focus.
      </summary>
      <value>Controls the selection when the edit control gets focus.</value>
      <remarks>
        <para>Valid values are:</para>
        <list type="table">
          <item>
            <term>FSEL_ALL</term>
            <description>All of the edit control's contents are selected.</description>
          </item>
          <item>
            <term>FSEL_TRIM</term>
            <description>
              The trimmed content is selected. This is the <b>default</b>.
            </description>
          </item>
          <item>
            <term>FSEL_HOME</term>
            <description>Nothing is selected; the cursor is positioned at the beginning of the edit control.</description>
          </item>
          <item>
            <term>FSEL_END</term>
            <description>Nothing is selected; the cursor is positioned at the end of the edit control.</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:VO.SingleLineEdit.OverWrite">
      <summary>
        A constant representing the overwrite mode for a single-line edit control.
      </summary>
      <value>A constant representing the overwrite mode for a single-line edit control.</value>
      <remarks>
        A constant representing the overwrite mode for a single-line edit control.  This property affects only an edit control with an active PICTURE clause.  Valid values are:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>OVERWRITE_NEVER</term><description>Edit control is always in INSERT mode.</description></item><item><term>OVERWRITE_ONKEY</term><description>The mode depends on the state of the INSERT key.</description></item><item><term>OVERWRITE_ALWAYS</term><description>Edit control is always in OVERWRITE mode.</description></item></list></remarks>
    </member>
    <member name="P:VO.SingleLineEdit.Picture">
      <summary>
        A picture string for a single-line edit control.
      </summary>
      <value>A picture string for a single-line edit control.</value>
      <remarks>
        A picture string for a single-line edit control.  If there is a field specification attached to the single-line edit control, the picture should be provided in the field specification and not via the Properties window in the window editor.
        The use of the SingleLineEdit:Picture assign will overwrite the field specification's picture string.
      </remarks>
    </member>
    <member name="P:VO.SingleLineEdit.ScrollMode">
      <summary>
        Specifies the scrolling behavior (e.g., when the Delete key is pressed).
      </summary>
      <value>Specifies the scrolling behavior (e.g., when the Delete key is pressed).</value>
      <remarks>
        <para>Specifies the scrolling behavior (e.g., when the Delete key is pressed). Valid values are:</para>
        <list type="table">
          <item>
            <term>
              SCRMODE_FULL
            </term>
            <description>
              Scrolls through all of the edit control's contents. This is the <b>default</b>.
            </description>
          </item>
          <item>
            <term>
              SCRMODE_PART
            </term>
            <description>Partial scrolling stops at non-edit template characters.</description>
          </item>
          <item>
            <term>SCRMODE_NO</term>
            <description>No scrolling.</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:VO.SingleLineEdit.TextValue">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.SingleLineEdit.Undo">
      <inheritdoc />
    </member>
    <member name="P:VO.SingleLineEdit.Value">
      <summary>
        SingleLineEdit:Value contains the text stored after the previous edit operation.  The SingleLineEdit:Value assign also changes the SingleLineEdit:CurrentText, SingleLineEdit:TextValue, and SingleLineEdit:ValueChanged.
      </summary>
      <value>SingleLineEdit:Value contains the text stored after the previous edit operation.  The SingleLineEdit:Value assign also changes the SingleLineEdit:CurrentText, SingleLineEdit:TextValue, and SingleLineEdit:ValueChanged.</value>
    </member>
    <member name="T:VO.Slider">
      <summary>
        Create a slider control.
      </summary>
      <remarks>
        A slider is a control that contains a thumb and optional tick marks.  The user can move the slider's thumb using either the mouse or the Direction keys.
      </remarks>
    </member>
    <member name="M:VO.Slider.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a slider.
      </summary>
      <param name="oOwner">The window that owns the slider.</param>
      <param name="xID">The unique ID between 1 and 8000 of the slider.</param>
      <param name="nResourceID">The resource ID of slider.</param>
      <param name="oPoint">The origin of the slider in canvas coordinates.</param>
      <param name="oDimension">The dimension of the slider in canvas coordinates.</param>
    </member>
    <member name="P:VO.Slider.BlockSize">
      <summary>
        A numeric value determining the block size (or page size) of the slider control.
      </summary>
      <value>A numeric value determining the block size (or page size) of the slider control.</value>
      <remarks>
        A numeric value determining the block size (or page size) of the slider control. The block size affects how much the slider moves when the user clicks next to the thumb.
      </remarks>
    </member>
    <member name="P:VO.Slider.ChannelBoundingBox">
      <summary>
        A BoundingBox object determining the size and position of the bounding rectangle for a slider control's channel.
      </summary>
      <value>A BoundingBox object determining the size and position of the bounding rectangle for a slider control's channel.</value>
      <remarks>
        A BoundingBox object determining the size and position of the bounding rectangle for a slider control's channel. (The channel is the area over which the thumb moves and which contains the highlight when a range is selected.)
      </remarks>
    </member>
    <member name="M:VO.Slider.ClearTicks">
      <summary>
        Clear the slider of all ticks.
      </summary>
    </member>
    <member name="M:VO.Slider.Create">
      <summary>
        Creates the underlying window control for a X# slider object.
      </summary>
      <returns>
        The window handle of the control, if successful.  A null handle (NULL_PTR) is returned if the control creation failed.
      </returns>
      <remarks>
        The Create() method creates the underlying window control for controls not loaded from a resource (i.e., designed with the Window Editor) but created at runtime.  Normally, it is not necessary to call Create() directly — CA-X# will create the object internally as soon as a window handle is needed.
      </remarks>
      <example>
        <code language="X#">
          Method CreateSlider() class MyDataWindow
           local oSLDR as Slider
          // Init creates the X# Slider Object
           oSLDR := Slider{self, 100, Point{10,10}, Dimension{100,20}}
          // Calling Create forces the Windows control to be created
           oSLDR:Create()
        </code>
      </example>
    </member>
    <member name="M:VO.Slider.GetTickPos(XSharp.__Usual)">
      <summary>
        Retrieves the position of a tick mark in a slider control.
      </summary>
      <param name="nIndex">Zero-based index identifying the tick mark.</param>
      <returns>
        The position of the specified tick mark or -1 if &lt;nIndex&gt; does not specify a valid index.
      </returns>
    </member>
    <member name="P:VO.Slider.Range">
      <summary>
        A Range object representing the minimum and maximum values currently in use for the thumb of the slider.
      </summary>
      <value>A Range object representing the minimum and maximum values currently in use for the thumb of the slider.</value>
    </member>
    <member name="M:VO.Slider.SetTickPos(XSharp.__Usual)">
      <summary>
        Sets the position of a tick mark in a slider control.
      </summary>
      <param name="nPosition">** missing parameter documentation **</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.Slider.ThumbBoundingBox">
      <summary>
        A BoundingBox object determining the size and position of the bounding rectangle for the thumb in a slider control.
      </summary>
      <value>A BoundingBox object determining the size and position of the bounding rectangle for the thumb in a slider control.</value>
    </member>
    <member name="P:VO.Slider.ThumbLength">
      <summary>
        A numeric value determining the length of the thumb in a slider control
      </summary>
      <value>A numeric value determining the length of the thumb in a slider control</value>
    </member>
    <member name="P:VO.Slider.ThumbPosition">
      <summary>
        A numeric value determining the current position of the thumb in a slider control.
      </summary>
      <value>A numeric value determining the current position of the thumb in a slider control.</value>
    </member>
    <member name="P:VO.Slider.TickAlignment">
      <summary>
        <para>A symbol that describes the alignment of ticks on the slider.</para>
        <para>Valid values for a horizontal slider are</para>
        <list type="bullet">
          <item>#Top</item>
          <item>#Bottom</item>
          <item>#Both</item>
        </list>
        <para>Valid values for a vertical slider are</para>
        <list type="bullet">
          <item>#Left</item>
          <item>#Right</item>
          <item>#Both</item>
        </list>
      </summary>
      <value>A symbol that describes the alignment of ticks on the slider.Valid values for a horizontal slider are#Top#Bottom#BothValid values for a vertical slider are#Left#Right#Both</value>
    </member>
    <member name="P:VO.Slider.TickCount">
      <summary>
        A numeric value representing the number of ticks on the slider.
      </summary>
      <value>A numeric value representing the number of ticks on the slider.</value>
    </member>
    <member name="P:VO.Slider.UnitSize">
      <summary>
        A numeric value determining the unit size (or line size) of the slider control.
      </summary>
      <value>A numeric value determining the unit size (or line size) of the slider control.</value>
      <remarks>
        A numeric value determining the unit size (or line size) of the slider control. The unit size affects how much the slider moves when the user presses the cursor left or cursor right key on the keyboard.
      </remarks>
    </member>
    <member name="T:VO.SliderEvent">
      <summary>
        Provide information about a slider event, which is generated when the thumb of a slider is dragged with the mouse or moved by pressing the Direction keys.
      </summary>
      <remarks>
        A slider event is generated when the thumb of a slider is moved either by mouse or by keyboard.  This event is generated for both horizontal and vertical sliders.
      </remarks>
    </member>
    <member name="M:VO.SliderEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.SliderEvent.IsWindowScroll">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.SliderEvent.Slider">
      <summary>
        The slider control object that generated this event.
      </summary>
      <value>The slider control object that generated this event.</value>
    </member>
    <member name="T:VO.Spinner">
      <summary>
        Create a spinner.
      </summary>
      <remarks>
        A spinner is a pair of arrow buttons that can be clicked to change a value, such as a number displayed in another control.  A spinner can exist independently but is most often used with another control, referred to as the client.
      </remarks>
    </member>
    <member name="M:VO.Spinner.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a spinner.
      </summary>
      <param name="oOwner">The window that owns the spinner.</param>
      <param name="xID">The unique ID of the spinner (between 1 and 8000).</param>
      <param name="oPoint">The origin of the spinner in canvas coordinates.</param>
      <param name="oDimension">The dimension of the spinner in canvas coordinates.</param>
      <param name="kStyle">The style of the spinner.</param>
      <param name="lDataAware">A logical value specifying whether the spinner is data aware.</param>
      <param name="nResourceID">The resource ID of the spinner.</param>
    </member>
    <member name="P:VO.Spinner.Client">
      <summary>
        The client control of the spinner.
      </summary>
      <value>The client control of the spinner.</value>
    </member>
    <member name="P:VO.Spinner.IsHexBased">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Spinner.Position">
      <summary>
        The numeric value of the spinner.
      </summary>
      <value>The numeric value of the spinner.</value>
    </member>
    <member name="P:VO.Spinner.Range">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.Spinner.ThumbPosition">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.SpinnerEvent">
      <summary>
        Provide information about a spinner event, which is generated when either of the spinner's arrow buttons is clicked.
      </summary>
      <remarks>
        A spinner event is generated when an arrow button of a spinner control is clicked.  This event is generated for both horizontal and vertical spinners.
      </remarks>
    </member>
    <member name="M:VO.SpinnerEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.SpinnerEvent.OldPosition">
      <summary>
        A numeric value representing the position of the spinner associated with this event immediately before the event occurred.
      </summary>
      <value>A numeric value representing the position of the spinner associated with this event immediately before the event occurred.</value>
    </member>
    <member name="P:VO.SpinnerEvent.OldValue">
      <summary>
        The value of the spinner associated with this event immediately before the event occurred.
      </summary>
      <value>The value of the spinner associated with this event immediately before the event occurred.</value>
    </member>
    <member name="P:VO.SpinnerEvent.Position">
      <summary>
        A numeric value representing the new position of the spinner associated with this event.
      </summary>
      <value>A numeric value representing the new position of the spinner associated with this event.</value>
    </member>
    <member name="P:VO.SpinnerEvent.Spinner">
      <summary>
        The spinner control object that generated this event.
      </summary>
      <value>The spinner control object that generated this event.</value>
    </member>
    <member name="P:VO.SpinnerEvent.SpinnerID">
      <summary>
        The numeric ID of the spinner control object that generated this event.
      </summary>
      <value>The numeric ID of the spinner control object that generated this event.</value>
    </member>
    <member name="P:VO.SpinnerEvent.Type">
      <summary>
        One of the following constants representing the type of action that took place when this event occurred:
      </summary>
      <value>One of the following constants representing the type of action that took place when this event occurred:</value>
      <remarks>
        One of the following constants representing the type of action that took place when this event occurred:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>UNITDECREMENT</term><description>The position has been decremented by a single unit.</description></item><item><term>UNITINCREMENT</term><description>The position has been incremented by a single unit.</description></item><item><term>SCROLLTOTOPLEFT</term><description>Spinning has reached the top-most position in a vertical spinner or the left-most position in a horizontal spinner.</description></item><item><term>SCROLLTOBOTTOMRIGHT</term><description>Spinning has reached the bottom-most position in a vertical spinner or the right-most position in a horizontal spinner.</description></item><item><term>SCROLLEND</term><description>Spinning has finished.</description></item></list></remarks>
    </member>
    <member name="P:VO.SpinnerEvent.Value">
      <summary>
        The new value of the spinner associated with this event.
      </summary>
      <value>The new value of the spinner associated with this event.</value>
    </member>
    <member name="T:VO.SplitWindow">
      <summary>
        Create a split window.
      </summary>
      <remarks>
        A split window provides a simple and easy way to create a window that can be split into several pane windows separated by split bars that can be dragged to resize the panes.  Each pane can specify a client window or control, which is automatically sized to fit into the pane.
        A Dimension object is used to configure the layout of the split window panes.  The width specifies the number of panes across (horizontally), and the height specifies the number of panes up and down (vertically).  Panes are numbered from left to right and top to bottom.  For example, a split window with a layout of Dimension{4, 3} is arranged as follows:
        1	2	3	4
        5	6	7	8
        9	10	11	12
        The maximum total number of panes is 16.
        <note type="tip">Static dependencies to the CATO3*.DLL files, which contain the DataBrowser and SplitWindow functionality, have been removed in this version of X#.  Applications not using a data browser and/or split window no longer need these .DLLs.  This leads to a smaller memory footprint, faster application startup, and smaller installations.</note></remarks>
    </member>
    <member name="M:VO.SplitWindow.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SplitWindow object.
      </summary>
      <param name="oOwner">The window that owns the split window.</param>
      <param name="lHorizontalDrag">A logical value that is TRUE if horizontal split bars can be dragged.  If omitted, the default is FALSE, which indicates that horizontal split bar dragging is disabled.</param>
      <param name="lVerticalDrag">A logical value that is TRUE if vertical split bars can be dragged.  If omitted, the default is FALSE, which indicates that vertical split bar dragging is disabled.</param>
      <param name="kAlignment">
        One of the following constants specifying how to align split bars in the split window:
      </param>
      <remarks>
        <pre>
          Constant			Description
          SPLIT_HORZALIGN	Split bars are horizontally aligned
          SPLIT_VERTALIGN	Split bars are vertically aligned
        </pre>
        If omitted, the default alignment is vertical (SPLIT_VERTALIGN).  Split bars can be aligned either horizontally or vertically, but not both.

      </remarks>
    </member>
    <member name="P:VO.SplitWindow.Background">
      <summary>
        The background brush currently in use by the split window.
      </summary>
      <value>The background brush currently in use by the split window.</value>
    </member>
    <member name="M:VO.SplitWindow.ChangeBackground(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Change the background brush of a particular component of the split window.
      </summary>
      <param name="oBrush">The new Brush object to apply.</param>
      <param name="kWhere">One of the following constants specifying the portion of the split window where the new brush will be applied:</param>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>SPLIT_COLORWINDOW</term>
            <description>Split window background brush</description>
          </item>
          <item>
            <term>SPLIT_COLORBAR</term>
            <description>Split bar background brush</description>
          </item>
          <item>
            <term>SPLIT_COLORFRAME</term>
            <description>Split bar frame background brush</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:VO.SplitWindow.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.SplitWindow.Dispatch(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.SplitWindow.EnableStatusBar(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.SplitWindow.GetAllChildren">
      <inheritdoc />
    </member>
    <member name="M:VO.SplitWindow.GetPaneClient(XSharp.__Usual)">
      <summary>
        Get the client window or control associated with a split window pane index.
      </summary>
      <param name="nPane">The index of the split window pane.</param>
      <returns>
        An object representing the split window pane's client window.
      </returns>
    </member>
    <member name="M:VO.SplitWindow.GetPaneSize(XSharp.__Usual)">
      <summary>
        Get a Dimension object that represents the current size of a pane.
      </summary>
      <param name="nPane">The index of the split window pane.</param>
      <returns>
        A Dimension object representing the split window pane's size.
      </returns>
    </member>
    <member name="M:VO.SplitWindow.HidePane(XSharp.__Usual)">
      <summary>
        Hide a particular pane or all panes of a split window.
      </summary>
      <param name="nPane">The index of the split window pane to hide.  If omitted, all panes are hidden.</param>
    </member>
    <member name="P:VO.SplitWindow.HorizontalAlign">
      <summary>
        A logical value that is TRUE if horizontal split bars are aligned in the split window.
      </summary>
      <value>A logical value that is TRUE if horizontal split bars are aligned in the split window.</value>
    </member>
    <member name="P:VO.SplitWindow.HorizontalDrag">
      <summary>
        A logical value that is TRUE if dragging of horizontal split bars is enabled in the split window.
      </summary>
      <value>A logical value that is TRUE if dragging of horizontal split bars is enabled in the split window.</value>
    </member>
    <member name="P:VO.SplitWindow.Layout">
      <summary>
        A Dimension object that represents the number and visual layout of the panes in the split window.
      </summary>
      <value>A Dimension object that represents the number and visual layout of the panes in the split window.</value>
      <remarks>
        A Dimension object that represents the number and visual layout of the panes in the split window.  The width of the dimension represents the number of horizontally aligned panes, while the height of the dimension represents the number of vertically aligned panes.
      </remarks>
    </member>
    <member name="M:VO.SplitWindow.Resize(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.SplitWindow.RestoreUpdate">
      <summary>
        Decrement the buffered paint count maintained by the split window.
      </summary>
      <remarks>
        Every call to RestoreUpdate() should be paired with a call to SuspendUpdate().  If the paint count is zero, deferred painting is ended.
      </remarks>
    </member>
    <member name="M:VO.SplitWindow.SetPaneClient(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the client window or control associated with a split window pane index.
      </summary>
      <param name="oWindow">The client window or control to be associated with the specified pane.</param>
      <param name="nPane">The index of the split window pane.</param>
    </member>
    <member name="M:VO.SplitWindow.SetPaneSize(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a Dimension object representing the current size of a pane.
      </summary>
      <param name="oDimension">A Dimension object representing the new size of the specified split window pane.</param>
      <param name="nPane">The index of the split window pane.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.SplitWindow.Show(XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.SplitWindow.ShowPane(XSharp.__Usual)">
      <summary>
        Show a particular pane or all panes of a split window.
      </summary>
      <param name="nPane">The index of the split window pane to show.  If omitted, all panes are shown.</param>
    </member>
    <member name="P:VO.SplitWindow.SplitBarBackground">
      <summary>
        The background brush currently in use by split bars in the split window.
      </summary>
      <value>The background brush currently in use by split bars in the split window.</value>
    </member>
    <member name="P:VO.SplitWindow.SplitBarFrameBackground">
      <summary>
        The background brush currently in use by split bar frames in the split window.
      </summary>
      <value>The background brush currently in use by split bar frames in the split window.</value>
    </member>
    <member name="M:VO.SplitWindow.SuspendUpdate">
      <summary>
        Increment the buffered paint count maintained by the split window.
      </summary>
      <remarks>
        Every call to SuspendUpdate() should be paired with a call to RestoreUpdate().  If the paint count is zero, deferred painting is ended.
      </remarks>
    </member>
    <member name="M:VO.SplitWindow.ToolBarHeightChanged(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.SplitWindow.VerticalAlign">
      <summary>
        A logical value that is TRUE if vertical split bars are aligned in the split window.
      </summary>
      <value>A logical value that is TRUE if vertical split bars are aligned in the split window.</value>
    </member>
    <member name="P:VO.SplitWindow.VerticalDrag">
      <summary>
        A logical value that is TRUE if dragging of vertical split bars is enabled in the split window.
      </summary>
      <value>A logical value that is TRUE if dragging of vertical split bars is enabled in the split window.</value>
    </member>
    <member name="T:VO.SQLCatalogQuery">
      <summary>
        Provide the base class from which all X# catalog classes are subclassed.
      </summary>
      <remarks>
        <br />Important!  This is an abstract class and should never be used directly — instead, use one of its subclasses, which include SQLListColumnPrivileges, SQLListColumns, SQLListForeignKeys, SQLListPrimaryKeys, SQLListProcedureColumns, SQLListProcedures, SQLListSpecialColumns, SQLListStatistics, SQLListTablePrivileges, SQLListTables, or SQLListTypeInfo.
      </remarks>
    </member>
    <member name="M:VO.SQLCatalogQuery.#ctor(XSharp.__Usual)">
      <summary>
        Construct an SQLCatalogQuery object.
      </summary>
      <param name="oSQLConnection">The SQL connection indicating where the table can be found.  If not specified, the current default connection is used, if any; if none is defined, the system asks the end user to log on to a database.</param>
    </member>
    <member name="P:VO.SQLCatalogQuery.CursorName">
      <summary>
        This property is provided to override the inherited functionality from the SQLSelect class, as it does not apply to SQLCatalogQuery.
      </summary>
      <value>This property is provided to override the inherited functionality from the SQLSelect class, as it does not apply to SQLCatalogQuery.</value>
    </member>
    <member name="M:VO.SQLCatalogQuery.Delete">
      <summary>
        This method is provided to override the inherited functionality from the SQLSelect class, as it does not apply to SQLCatalogQuery; therefore it generates an error and returns FALSE.
      </summary>
    </member>
    <member name="M:VO.SQLCatalogQuery.FIELDPUT">
      <summary>
        This method is provided to override the inherited functionality from the SQLSelect class, as it does not apply to SQLCatalogQuery; therefore it generates an error and returns FALSE.
      </summary>
    </member>
    <member name="P:VO.SQLCatalogQuery.TableName">
      <summary>
        This property is provided to override the inherited functionality from the SQLSelect class, as it does not apply to SQLCatalogQuery.
      </summary>
      <value>This property is provided to override the inherited functionality from the SQLSelect class, as it does not apply to SQLCatalogQuery.</value>
    </member>
    <member name="M:VO.SQLCatalogQuery.Update">
      <summary>
        This method is provided to override the inherited functionality from the SQLSelect class, as it does not apply to SQLCatalogQuery; therefore it generates an error and returns FALSE.
      </summary>
    </member>
    <member name="T:VO.SQLColumn">
      <summary>
        Describe an SQL column.
      </summary>
    </member>
    <member name="M:VO.SQLColumn.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct an SQL column.
      </summary>
      <param name="oHyperLabel">The hyperlabel for the SQL column.</param>
      <param name="oFieldSpec">The field specification for the SQL column.</param>
      <param name="nODBCType">The ODBC data type of the SQL column (for example, SQL_INTEGER, SQL_CHAR, and SQL_FLOAT).  Refer to your ODBC documentation for a complete list of ODBC data types that are available.</param>
      <param name="nScale">The decimal precision of the SQL column.  This is specified only when the ODBC data type is numeric.</param>
      <param name="lNullable">Specify TRUE if the value can be NULL; otherwise, FALSE.</param>
      <param name="nIndex">The SQL column number.</param>
      <param name="cColName">The SQL column name.</param>
      <param name="cAlias">The SQL column alias name.</param>
    </member>
    <member name="F:VO.SQLColumn.AliasName">
      <summary>
        The alias name of the SQL column.
      </summary>
      <value>The alias name of the SQL column.</value>
    </member>
    <member name="F:VO.SQLColumn.ColName">
      <summary>
        A string representing the SQL column name.
      </summary>
      <value>A string representing the SQL column name.</value>
    </member>
    <member name="F:VO.SQLColumn.Index">
      <summary>
        A numeric value representing the SQL column number.
      </summary>
      <value>A numeric value representing the SQL column number.</value>
    </member>
    <member name="T:VO.SQLColumnAttributes">
      <summary>
        Describe the attributes of an SQL column.
      </summary>
    </member>
    <member name="M:VO.SQLColumnAttributes.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct an SQLColumnAttributes object.
      </summary>
      <param name="oHyperLabel">The hyperlabel for the SQLColumnAttributes object.</param>
      <param name="oFieldSpec">The field specification for the SQLColumnAttributes object.</param>
      <param name="nODBCType">The ODBC data type of the SQL column(for example, SQL_INTEGER, SQL_CHAR, and SQL_FLOAT)</param>
      <param name="nScale">The decimal precision of the SQL value.  This is specified only when the ODBC data type is numeric.</param>
      <param name="lNullable">TRUE if the value can be NULL; otherwise, FALSE.</param>
      <param name="nIndex">The SQL column number.</param>
      <param name="cColName">The SQL column name.</param>
      <param name="cAliasName">The SQL column alias name.</param>
      <remarks>
        <note type="tip">Refer to your ODBC documentation for a complete list of ODBC data types that are available.</note>
      </remarks>
    </member>
    <member name="F:VO.SQLColumnAttributes.AutoIncrement">
      <summary>
        A logical value of TRUE if the column is automatically incremented or FALSE if it is either not automatically incremented or non-numeric.
      </summary>
      <value>A logical value of TRUE if the column is automatically incremented or FALSE if it is either not automatically incremented or non-numeric.</value>
    </member>
    <member name="F:VO.SQLColumnAttributes.CaseSensitive">
      <summary>
        A logical value of TRUE if collating sequences are case sensitive; otherwise, FALSE.
      </summary>
      <value>A logical value of TRUE if collating sequences are case sensitive; otherwise, FALSE.</value>
    </member>
    <member name="F:VO.SQLColumnAttributes.DisplaySize">
      <summary>
        A numeric value representing the maximum number of characters required to display the SQL column data.
      </summary>
      <value>A numeric value representing the maximum number of characters required to display the SQL column data.</value>
    </member>
    <member name="F:VO.SQLColumnAttributes.Length">
      <summary>
        A numeric value representing the length — in bytes — of the SQL data value.
      </summary>
      <value>A numeric value representing the length — in bytes — of the SQL data value.</value>
    </member>
    <member name="F:VO.SQLColumnAttributes.Money">
      <summary>
        A logical value of TRUE if the SQL column is a money data type; otherwise, FALSE.
      </summary>
      <value>A logical value of TRUE if the SQL column is a money data type; otherwise, FALSE.</value>
    </member>
    <member name="F:VO.SQLColumnAttributes.Searchable">
      <summary>
        A constant (four standard values) representing how the column can be used in searches:
      </summary>
      <value>A constant (four standard values) representing how the column can be used in searches:</value>
      <remarks>
        One of the following constants (four standard values) representing how the column can be used in searches:
        <pre>
          Constant				Meaning
          SQL_ALL_EXCEPT_LIKE	The column can be used in a WHERE clause with all comparison operators except LIKE.
          SQL_LIKE_ONLY			The column can be used in a WHERE clause only with the LIKE predicate.
          SQL_SEARCHABLE		The column can be used in a WHERE clause with any comparison operator.
          SQL_UNSEARCHABLE		The column cannot be used in a WHERE clause.
        </pre></remarks>
    </member>
    <member name="F:VO.SQLColumnAttributes.Unsigned">
      <summary>
        A logical value of TRUE if the column is unsigned or non-numeric; otherwise, FALSE.
      </summary>
      <value>A logical value of TRUE if the column is unsigned or non-numeric; otherwise, FALSE.</value>
    </member>
    <member name="F:VO.SQLColumnAttributes.Updatable">
      <summary>
        A logical value of TRUE if the column can be updated; otherwise, FALSE.
      </summary>
      <value>A logical value of TRUE if the column can be updated; otherwise, FALSE.</value>
    </member>
    <member name="T:VO.SQLConnection">
      <summary>
        Manage an SQL connection to an ODBC data source.  A SQLConnection object is needed before any database operations can be performed.
      </summary>
      <remarks>
        An SQLConnection object represents the connection to an ODBC data source.  The data source (associated with a particular database) is set-up using the Microsoft ODBC administrator.
      </remarks>
      <example>
        The following example demonstrates how to establish a connection to a source named SAMPLE:
        <code language="X#">
          FUNCTION Start()
          LOCAL oConn AS SQLConnection
          oConn := SQLConnection{}
          // SAMPLE source has been set up to connect to 	// WATCOM
          oConn:Connect("sample","dba","sql")
          // Check for errors
          IF IsNil(oConn:ErrInfo)
          oConn:Disconnect()
          ELSE
          oConn:ErrInfo:ShowErrorMsg()
          ENDIF
        </code></example>
    </member>
    <member name="M:VO.SQLConnection.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct an SQL connection.
      </summary>
      <param name="cDataSourceName">The ODBC data source name.  If not specified, the default is NULL_STRING.</param>
      <param name="cUserID">The ODBC user ID.  If not specified, the default is NULL_STRING.</param>
      <param name="cPassword">The ODBC password (authorization string).  If not specified, the default is NULL_STRING.</param>
      <remarks>
        If a data source is provided to this method, an attempt to connect will occur; otherwise, use the SQLConnection:Connect() method.  Another option is to use SQLConnection:DataSource to name the source.
      </remarks>
    </member>
    <member name="P:VO.SQLConnection.AccessMode">
      <summary>
        A constant representing the SQL connection's access mode.
      </summary>
      <value>A constant representing the SQL connection's access mode.</value>
      <remarks>
        <note type="tip">
          The access mode can only be changed if the current connection is not busy.  If an invalid value is specified, the access mode remains unchanged.
          Possible values include SQL_MODE_READ_ONLY and SQL_MODE_READ_WRITE (default for most drivers).
        </note>
        <note type="tip"> Refer to your ODBC documentation for a description of these constants.</note>
      </remarks>
    </member>
    <member name="M:VO.SQLConnection.Connect(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Connect a user to an ODBC data source.
      </summary>
      <param name="cDataSource">The ODBC data source name.  If not specified, the default is NULL_STRING.</param>
      <param name="cUserID">The ODBC user ID.  If not specified, the default is NULL_STRING.</param>
      <param name="cPassword">The ODBC password (authorization string).  If not specified, the default is NULL_STRING.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        If the connection fails, a message box will display the error.  To suppress the message box, call the SQLConnectErrorMsg(FALSE) function.
      </remarks>
    </member>
    <member name="P:VO.SQLConnection.Connected">
      <summary>
        A logical value representing whether the SQL connection object is connected.
      </summary>
      <value>A logical value representing whether the SQL connection object is connected.</value>
    </member>
    <member name="P:VO.SQLConnection.ConnectString">
      <summary>
        A string representing the connection parameters (for example, "DSN=&lt;Source&gt;;UID=&lt;UserID&gt;;PWD=&lt;Authorization&gt;").  This string is initialized during the SQLConnection:Connect() or SQLConnection:DriverConnect() methods.
      </summary>
      <value>A string representing the connection parameters (for example, "DSN=&lt;Source&gt;;UID=&lt;UserID&gt;;PWD=&lt;Authorization&gt;").  This string is initialized during the SQLConnection:Connect() or SQLConnection:DriverConnect() methods.</value>
    </member>
    <member name="P:VO.SQLConnection.ConnHandle">
      <summary>
        A long integer representing the connection handle.
      </summary>
      <value>A long integer representing the connection handle.</value>
    </member>
    <member name="P:VO.SQLConnection.DataSource">
      <summary>
        A string representing the ODBC data source name.
      </summary>
      <value>A string representing the ODBC data source name.</value>
      <remarks>
        <note type="tip">This string cannot be assigned if the connection is open.</note>
      </remarks>
    </member>
    <member name="M:VO.SQLConnection.Disconnect">
      <summary>
        Disconnect the current user from an ODBC data source.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.SQLConnection.DriverConnect(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Display a dialog box prompting for a source; after a source is selected, displays the driver's connection dialog box; then connects to the selected data source.
      </summary>
      <param name="nHandle">The handle of the application window.  If not specified, the active window handle is used.</param>
      <param name="kDriverCompletion">The driver completion type, represented by one of the following constants:</param>
      <param name="cConnStrIn">A string representing an input connection.  If omitted, the SQL_DRIVER_PROMPT option should be used to prompt for the driver.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.

        Level 1
      </returns>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>SQL_DRIVER_PROMPT</term>
            <description>The driver presents a dialog box listing all sources that have been installed.  The user can choose which one to connect to.  This is the default.</description>
          </item>
          <item>
            <term>SQL_DRIVER_ COMPLETE</term>
            <description>If the connection string (&lt;cConnStrIn&gt;) contains enough information, the driver will connect to that source; otherwise, a dialog box will be presented to prompt for information.</description>
          </item>
        </list>
        SQL_DRIVER_ COMPLETE_REQUIRED
        Behaves like SQL_DRIVER_COMPLETE, except that the driver disables the controls for any information that is not required to connect.
        SQL_DRIVER_ NOPROMPT	If the connection string (&lt;cConnStrIn&gt;) contains enough information, the driver will connect to that source; otherwise, it returns an error.
        If &lt;cConnStrIn&gt; is omitted, the SQL_DRIVER_PROMPT option should be used, which prompts for the driver.  If some of the &lt;cConnectStrIn&gt; information is present, SQL_DRIVER_COMPLETE should be used.  If all of the information is passed, then there is no need to prompt for the driver; therefore, the SQL_DRIVER_NOPROMPT option can be used.
        If the connection fails, a message box will display the error.  To suppress the message box, call the SQLConnectErrorMsg(FALSE) function.
      </remarks>
    </member>
    <member name="P:VO.SQLConnection.EnvHandle">
      <summary>
        A long integer representing the environment handle.
      </summary>
      <value>A long integer representing the environment handle.</value>
    </member>
    <member name="M:VO.SQLConnection.GetConnectOption(XSharp.__Usual)">
      <summary>
        Return current setting for a connection option.
      </summary>
      <param name="kOption">The connection option (for example, SQL_ACCESS_MODE or SQL_AUTOCOMMIT).  Refer to SQLGetConnectOption() in your ODBC documentation for a complete list of ODBC connection options that are available.</param>
    </member>
    <member name="P:VO.SQLConnection.HyperLabel">
      <summary>
        The hyperlabel of the connection containing the name of the data source, or NIL, if there is no data source name.
      </summary>
      <value>The hyperlabel of the connection containing the name of the data source, or NIL, if there is no data source name.</value>
    </member>
    <member name="P:VO.SQLConnection.IdentifierQuoteChar">
      <summary>
        A string used to surround a delimited identifier for this connection.
      </summary>
      <value>A string used to surround a delimited identifier for this connection.</value>
    </member>
    <member name="M:VO.SQLConnection.Info(XSharp.__Usual)">
      <summary>
        Return current setting for connection information.
      </summary>
      <param name="kInfoType">The connection information type (for example, SQL_ODBC_API_CONFORMANCE and SQL_DRIVER_NAME).  Refer to SQLGetInfo() — a method of the SQLConnection class — in your ODBC documentation for a complete list of ODBC information types that are available.</param>
    </member>
    <member name="M:VO.SQLConnection.isFunction(XSharp.__Usual)">
      <summary>
        Determine whether an ODBC function is supported by the driver.
      </summary>
      <param name="kFunction">The ODBC function (for example, SQL_API_SQLTABLES and SQL_API_SQLCOLUMNS).  Refer to your ODBC documentation for a complete list of ODBC functions that are available.</param>
      <returns>
        TRUE if the function is supported; otherwise, FALSE.

        Level 1
      </returns>
    </member>
    <member name="P:VO.SQLConnection.IsolationOption">
      <summary>
        A constant representing the isolation level of the SQL connection.
      </summary>
      <value>A constant representing the isolation level of the SQL connection.</value>
      <remarks>
        A constant representing the isolation level of the SQL connection.
        <note type="tip">The isolation option can only be changed if the current connection is not busy.  If an invalid value is specified, the isolation option remains unchanged.</note><para>Possible values include:</para><list type="table"><item><term>SQL_CUR_USE_IF NEEDED (default for most drivers)</term></item><item><term>SQL_CUR_USE_ODBC</term></item><item><term>SQL_CUR_USE_DRIVER</term></item></list><note type="tip">Refer to your ODBC documentation for a description of these constants.</note></remarks>
    </member>
    <member name="P:VO.SQLConnection.ODBCCursors">
      <summary>
        A constant representing the cursor type for the SQL connection.
      </summary>
      <value>A constant representing the cursor type for the SQL connection.</value>
      <remarks>
        <note type="tip">The cursor type can only be changed if the current connection is not busy.  If an invalid value is specified, the cursor type remains unchanged.</note>
        Possible values include:
        SQL_CUR_USE_IF NEEDED  (default for most drivers)
        SQL_CUR_USE_ODBC
        SQL_CUR_USE_DRIVER
        <note type="tip">Refer to your ODBC documentation for a description of these constants.</note><note type="tip">
          Please note that the default for this option has changed from SQL_CUR_USE_ODBC in the past to SQL_CUR_USE_IF NEEDED in the latest versions of X#.
        </note></remarks>
    </member>
    <member name="P:VO.SQLConnection.Password">
      <summary>
        A string containing the ODBC password (authorization string).
      </summary>
      <value>A string containing the ODBC password (authorization string).</value>
      <remarks>
        <note type="tip">This string cannot be assigned if the connection is open.</note>
      </remarks>
    </member>
    <member name="P:VO.SQLConnection.PositionOps">
      <summary>
        A logical value representing whether the driver supports positioned operations
      </summary>
      <value>A logical value representing whether the driver supports positioned operations</value>
      <remarks>
        A logical value representing whether the driver supports positioned operations (i.e., the use of the cursor in positioned updates and delete statements).  If the driver doesn't respond to the inquiry about positioned operations, the default setting is TRUE.
      </remarks>
    </member>
    <member name="M:VO.SQLConnection.Reconnect">
      <summary>
        Disconnect the current user from a data source; if connected; then, connect.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.SQLConnection.ScrollConcurrency">
      <summary>
        A constant representing the concurrency level of the SQL connection.
      </summary>
      <value>A constant representing the concurrency level of the SQL connection.</value>
      <remarks>
        A constant representing the concurrency level of the SQL connection.  If an invalid value is specified, the concurrency level remains unchanged.
        Valid values include:
        SQL_CONCUR_LOCK
        SQL_CONCUR_READ_ONLY
        SQL_CONCUR_TIMESTAMP	(equivalent to SQL_CONCUR_ROWVER)
        SQL_CONCUR_VALUES	(default for most drivers)
        <note type="tip">Refer to your ODBC documentation for a description of these constants.</note></remarks>
    </member>
    <member name="P:VO.SQLConnection.ScrollCsr">
      <summary>
        A logical value representing whether the driver supports scrollable cursors.
      </summary>
      <value>A logical value representing whether the driver supports scrollable cursors.</value>
      <remarks>
        A logical value representing whether the driver supports scrollable cursors.
        <note type="tip">If a driver supports scrollable cursors, the SQLSelect will use the extended positioning operations of the driver; otherwise, it will be simulated by repositioning in the buffer.</note></remarks>
    </member>
    <member name="M:VO.SQLConnection.SetConnectOption(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the value of a connection option.
      </summary>
      <param name="kOption">The connection option to set (for example, SQL_ACCESS_MODE and SQL_AUTOCOMMIT).  Refer to SQLGetConnectOption() in your ODBC documentation for a complete list of ODBC connection options that are available.</param>
      <param name="uNewValue">The new value of the connection option.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.

        Level 1
      </returns>
    </member>
    <member name="P:VO.SQLConnection.SQLErrInfo">
      <summary>
        An SQL error information (SQLErrorInfo) object, or NIL, if no error has occurred.
      </summary>
      <value>An SQL error information (SQLErrorInfo) object, or NIL, if no error has occurred.</value>
    </member>
    <member name="P:VO.SQLConnection.Status">
      <summary>
        A hyperlabel of the SQLConnection object containing the error message, or NULL_OBJECT, if no error has occurred.
      </summary>
      <value>A hyperlabel of the SQLConnection object containing the error message, or NULL_OBJECT, if no error has occurred.</value>
    </member>
    <member name="P:VO.SQLConnection.UserID">
      <summary>
        A string representing the ODBC user ID.
      </summary>
      <value>A string representing the ODBC user ID.</value>
      <remarks>
        <note type="tip">This string cannot be assigned if the connection is open.</note>
      </remarks>
    </member>
    <member name="T:VO.SQLData">
      <summary>
        Represent an SQL data value; used internally by SQL classes.
      </summary>
    </member>
    <member name="M:VO.SQLData.#ctor">
      <summary>
        Construct an SQLData object.
      </summary>
      <param name="uValue">The data value to be assigned to the SQLData object.  If not specified, the default is NIL.</param>
      <param name="lNull">Specify TRUE if the data value is NULL; otherwise, FALSE.  If not specified, the default is FALSE.</param>
      <param name="lChanged">Specify TRUE if the data value has changed; otherwise, FALSE.  If not specified, the default is FALSE.</param>
      <example>
        The following example creates an SQLData object and prints the values of SQLData:Null, SQLData:Value, and SQLData:ValueChanged, respectively:
        <code language="X#">
          LOCAL oSQLData
          oSQLData := SQLData{"Test",TRUE,TRUE}
          ?oSQLData:Null					// Returns TRUE
          ?oSQLData:Value				// Returns "Test"
          ?oSQLData:ValueChanged			// Returns TRUE
        </code></example>
    </member>
    <member name="F:VO.SQLData.Null">
      <summary>
        A logical value representing whether the SQL value is a NULL value.  If it is NULL, TRUE is returned; otherwise, FALSE
      </summary>
      <value>A logical value representing whether the SQL value is a NULL value.  If it is NULL, TRUE is returned; otherwise, FALSE</value>
    </member>
    <member name="F:VO.SQLData.Value">
      <summary>
        A usual value representing the SQL data value.
      </summary>
      <value>A usual value representing the SQL data value.</value>
    </member>
    <member name="F:VO.SQLData.ValueChanged">
      <summary>
        A logical value indicating whether the SQL data value has been changed since it was last set.  TRUE indicates that it has been changed; FALSE indicates that it has not.
      </summary>
      <value>A logical value indicating whether the SQL data value has been changed since it was last set.  TRUE indicates that it has been changed; FALSE indicates that it has not.</value>
    </member>
    <member name="T:VO.SQLErrorInfo">
      <summary>
        Describe a SQL error.
      </summary>
      <remarks>
        An SQLErrorInfo object will be automatically created by the SQL classes (SQLConnection, SQLStatement, SQLSelect, SQLTable, and so on) whenever an error occurs.  To retrieve the error, use the SQLSelect:ErrInfo access.
      </remarks>
      <example>
        The following traps an error that is received and creates an SQLErrorInfo object:
        <code language="X#">
          LOCAL oSQLErrorInfo AS OBJECT
          LOCAL oConnection AS OBJECT
          LOCAL oSelect AS OBJECT
          // Create the object for SQLConnection
          oConnection := SQLConnection{"sample", "dba",;
          "sql"}
          // Create the object for SQLSelect
          oSelect := SQLSelect{"SELECT * FROM lab",
          oConnection}
          // Test for invalid argument
          IF SQLGetStmtOption(oSelect:StatementHandle,;
          30000, NULL_PTR) # SQLSuccess
          // Now, create SQLErrorInfo object to pick up
          // last error. The first two parameters are
          // optional, followed by the environment handle,
          // the connection handle, followed by the
          // statement handle from SQLSelect.
          oSQLErrorInfo := SQLErrorInfo{ , , ;
          oConnection:EnvHandle,;
          oConnection:ConnHandle,;
          oSelect:StatementHandle}
          ENDIF
          ?oSQLErrorInfo:ErrorFlag
          ?oSQLErrorInfo:ErrorMessage
          ?oSQLErrorInfo:NativeError
          ?oSQLErrorInfo:SQLState
        </code></example>
    </member>
    <member name="M:VO.SQLErrorInfo.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SQLErrorInfo object.
      </summary>
      <param name="oOriginator">The object in which the error occurred.</param>
      <param name="symMethod">The name of the method of the object in which the error occurred.</param>
      <param name="hEnv">The environment handle.</param>
      <param name="hDbc">The connection handle.</param>
      <param name="hStmt">The statement handle.</param>
    </member>
    <member name="P:VO.SQLErrorInfo.ErrorFlag">
      <summary>
        A logical value representing whether a SQL error has just occurred.
      </summary>
      <value>A logical value representing whether a SQL error has just occurred.</value>
    </member>
    <member name="P:VO.SQLErrorInfo.ErrorMessage">
      <summary>
        A string that contains the SQL error message.
      </summary>
      <value>A string that contains the SQL error message.</value>
    </member>
    <member name="P:VO.SQLErrorInfo.ErrorMessageLen">
      <summary>
        A numeric value that represents the SQL error message length.
      </summary>
      <value>A numeric value that represents the SQL error message length.</value>
    </member>
    <member name="P:VO.SQLErrorInfo.NativeError">
      <summary>
        A numeric value that represents the native SQL error.
      </summary>
      <value>A numeric value that represents the native SQL error.</value>
    </member>
    <member name="P:VO.SQLErrorInfo.ReturnCode">
      <summary>
        A numeric value that represents the SQL return code value (for example, SQL_ERROR, SQL_SUCCESS_WITH_INFO, etc.).
      </summary>
      <value>A numeric value that represents the SQL return code value (for example, SQL_ERROR, SQL_SUCCESS_WITH_INFO, etc.).</value>
      <remarks>
        <note type="tip">Refer to your ODBC documentation for a complete list of SQL return codes that are available.</note>
      </remarks>
    </member>
    <member name="M:VO.SQLErrorInfo.ShowErrorMsg">
      <summary>
        Display an SQL error message.
      </summary>
      <remarks>
        When an SQL error occurs, the error message is formatted and displayed in a message box.
      </remarks>
    </member>
    <member name="P:VO.SQLErrorInfo.SQLState">
      <summary>
        A string that contains the SQL error state (for example, S1000, which is a general error).
      </summary>
      <value>A string that contains the SQL error state (for example, S1000, which is a general error).</value>
      <remarks>
        <note type="tip">Refer to SQLState in your ODBC documentation for a complete list of ODBC error states that are available.</note>
      </remarks>
    </member>
    <member name="T:VO.SQLListColumnPrivileges">
      <summary>
        List the columns and associated privileges for one or more tables.
      </summary>
    </member>
    <member name="M:VO.SQLListColumnPrivileges.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SQLListColumnPrivileges object.
      </summary>
      <param name="cQualifier">The search string or name of the table qualifier.</param>
      <param name="cOwner">The search string or name of the table owner.</param>
      <param name="cTableName">The search string or name of the table.</param>
      <param name="cColName">The search string or column name.</param>
      <param name="oSQLConnection">The SQL connection indicating where the table can be found.  If not specified, the current default connection is used, if any; if none is defined, the system asks the end user to log on to a database.</param>
    </member>
    <member name="F:VO.SQLListColumnPrivileges.ColName">
      <summary>
        A string representing the name of the column.
      </summary>
      <value>A string representing the name of the column.</value>
    </member>
    <member name="M:VO.SQLListColumnPrivileges.Execute">
      <summary>
        Retrieve the list of column privileges.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.

        Level 2
      </returns>
    </member>
    <member name="F:VO.SQLListColumnPrivileges.Owner">
      <summary>
        A string representing the owner of the table.
      </summary>
      <value>A string representing the owner of the table.</value>
    </member>
    <member name="F:VO.SQLListColumnPrivileges.Qualifier">
      <summary>
        A string representing the name of the qualifier for the table.
      </summary>
      <value>A string representing the name of the qualifier for the table.</value>
    </member>
    <member name="F:VO.SQLListColumnPrivileges.TableName">
      <summary>
        A string representing the name of the table.
      </summary>
      <value>A string representing the name of the table.</value>
    </member>
    <member name="T:VO.SQLListColumns">
      <summary>
        List the column names in specified tables.
      </summary>
    </member>
    <member name="M:VO.SQLListColumns.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SQLListColumns object.
      </summary>
      <param name="cQualifier">The search string or name of the table qualifier.</param>
      <param name="cOwner">The search string or name of the table owner.</param>
      <param name="cTableName">The search string or name of the table.</param>
      <param name="cColName">The search string or column name.</param>
      <param name="oSQLConnection">The SQL connection indicating where the table can be found.  If not specified, the current default connection is used, if any; if none is defined, the system asks the end user to log on to a database.</param>
    </member>
    <member name="F:VO.SQLListColumns.ColName">
      <summary>
        A string representing the name of the column.
      </summary>
      <value>A string representing the name of the column.</value>
    </member>
    <member name="M:VO.SQLListColumns.Execute">
      <summary>
        Retrieve the list of columns.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.

        Level 1
      </returns>
    </member>
    <member name="F:VO.SQLListColumns.Owner">
      <summary>
        A string representing the owner of the table.
      </summary>
      <value>A string representing the owner of the table.</value>
    </member>
    <member name="F:VO.SQLListColumns.Qualifier">
      <summary>
        A string representing the name of the qualifier for the table.
      </summary>
      <value>A string representing the name of the qualifier for the table.</value>
    </member>
    <member name="F:VO.SQLListColumns.TableName">
      <summary>
        A string representing the name of the table.
      </summary>
      <value>A string representing the name of the table.</value>
    </member>
    <member name="T:VO.SQLListForeignKeys">
      <summary>
        List the column names that comprise foreign keys, if they exist for a specified table.
      </summary>
    </member>
    <member name="M:VO.SQLListForeignKeys.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SQLListForeignKeys object.
      </summary>
      <param name="cPQualifier">The search string or name of the primary key table qualifier.</param>
      <param name="cpOwner">The search string or name of the primary key table owner.</param>
      <param name="cPTableName">The search string or name of the primary key table.</param>
      <param name="cFQualifier">The search string or name of the foreign key table qualifier.</param>
      <param name="cFOwner">The search string or name of the foreign key table owner.</param>
      <param name="cFTableName">The search string or name of the foreign key table.</param>
      <param name="oSQLConnection">The SQL connection indicating where the table can be found.  If not specified, the current default connection is used, if any; if none is defined, the system asks the end user to log on to a database.</param>
    </member>
    <member name="M:VO.SQLListForeignKeys.Execute">
      <summary>
        Retrieve the list of columns representing foreign keys.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.

        Level 2
      </returns>
    </member>
    <member name="F:VO.SQLListForeignKeys.FOwner">
      <summary>
        A string representing the owner of the foreign key table.
      </summary>
      <value>A string representing the owner of the foreign key table.</value>
    </member>
    <member name="F:VO.SQLListForeignKeys.FQualifier">
      <summary>
        A string representing the name of the qualifier for a foreign key table.
      </summary>
      <value>A string representing the name of the qualifier for a foreign key table.</value>
    </member>
    <member name="F:VO.SQLListForeignKeys.FTableName">
      <summary>
        A string representing the name of a foreign key table.
      </summary>
      <value>A string representing the name of a foreign key table.</value>
    </member>
    <member name="F:VO.SQLListForeignKeys.POwner">
      <summary>
        A string representing the name of the owner of a primary key table.
      </summary>
      <value>A string representing the name of the owner of a primary key table.</value>
    </member>
    <member name="F:VO.SQLListForeignKeys.PQualifier">
      <summary>
        A string representing the name of the qualifier for a primary key table.
      </summary>
      <value>A string representing the name of the qualifier for a primary key table.</value>
    </member>
    <member name="F:VO.SQLListForeignKeys.PTableName">
      <summary>
        A string representing the name of a primary key table.
      </summary>
      <value>A string representing the name of a primary key table.</value>
    </member>
    <member name="T:VO.SQLListPrimaryKeys">
      <summary>
        List the column names that comprise the primary key for a table.
      </summary>
    </member>
    <member name="M:VO.SQLListPrimaryKeys.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SQLListPrimaryKeys object.
      </summary>
      <param name="cQualifier">The search string or name of the primary key table qualifier.</param>
      <param name="cOwner">The search string or name of the primary key table owner.</param>
      <param name="cTableName">The search string or name of the primary key table.</param>
      <param name="oSQLConnection">The SQL connection indicating where the table can be found.  If not specified, the current default connection is used, if any; if none is defined, the system asks the end user to log on to a database.</param>
    </member>
    <member name="M:VO.SQLListPrimaryKeys.Execute">
      <summary>
        Retrieve the list of primary keys.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.

        Level 2
      </returns>
    </member>
    <member name="F:VO.SQLListPrimaryKeys.Owner">
      <summary>
        A string representing the owner of the primary key table.
      </summary>
      <value>A string representing the owner of the primary key table.</value>
    </member>
    <member name="F:VO.SQLListPrimaryKeys.Qualifier">
      <summary>
        A string representing the name of the qualifier for the primary key table.
      </summary>
      <value>A string representing the name of the qualifier for the primary key table.</value>
    </member>
    <member name="F:VO.SQLListPrimaryKeys.TableName">
      <summary>
        A string representing the name of the primary key table.
      </summary>
      <value>A string representing the name of the primary key table.</value>
    </member>
    <member name="T:VO.SQLListProcedureColumns">
      <summary>
        List the input and output procedure parameters and columns that make up the result set for the specified procedures.
      </summary>
    </member>
    <member name="M:VO.SQLListProcedureColumns.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SQLListProcedureColumns object.
      </summary>
      <param name="cQualifier">The search string or name of the procedure qualifier.</param>
      <param name="cOwner">The search string or name of the procedure owner.</param>
      <param name="cProcName">The search string or name of the procedure.</param>
      <param name="cColName">The search string or name of the column.</param>
      <param name="oSQLConnection">The SQL connection indicating where the table can be found.  If not specified, the current default connection is used, if any; if none is defined, the system asks the end user to log on to a database.</param>
    </member>
    <member name="F:VO.SQLListProcedureColumns.ColName">
      <summary>
        A string representing the name of the procedure column.
      </summary>
      <value>A string representing the name of the procedure column.</value>
    </member>
    <member name="M:VO.SQLListProcedureColumns.Execute">
      <summary>
        Retrieve a list of procedure columns.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.

        Level 2
      </returns>
    </member>
    <member name="F:VO.SQLListProcedureColumns.Owner">
      <summary>
        A string representing the owner of the procedure.
      </summary>
      <value>A string representing the owner of the procedure.</value>
    </member>
    <member name="F:VO.SQLListProcedureColumns.ProcName">
      <summary>
        A string representing the name of the procedure.
      </summary>
      <value>A string representing the name of the procedure.</value>
    </member>
    <member name="F:VO.SQLListProcedureColumns.Qualifier">
      <summary>
        A string representing the qualifier for the procedure.
      </summary>
      <value>A string representing the qualifier for the procedure.</value>
    </member>
    <member name="T:VO.SQLListProcedures">
      <summary>
        List the procedure names stored in a specific data source.
      </summary>
    </member>
    <member name="M:VO.SQLListProcedures.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SQLListProcedures object.
      </summary>
      <param name="cQualifier">The search string or name of the procedure qualifier.</param>
      <param name="cOwner">The search string or name of the procedure owner.</param>
      <param name="cProcName">The search string or name of the procedure.</param>
      <param name="oSQLConnection">The SQL connection indicating where the table can be found.  If not specified, the current default connection is used, if any; if none is defined, the system asks the end user to log on to a database.</param>
    </member>
    <member name="M:VO.SQLListProcedures.Execute">
      <summary>
        Retrieve the list of procedure names in a specific data source.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.

        Level 2
      </returns>
    </member>
    <member name="F:VO.SQLListProcedures.Owner">
      <summary>
        A string representing the name of the owner of the procedure.
      </summary>
      <value>A string representing the name of the owner of the procedure.</value>
    </member>
    <member name="F:VO.SQLListProcedures.ProcName">
      <summary>
        A string representing the name of the procedure.
      </summary>
      <value>A string representing the name of the procedure.</value>
    </member>
    <member name="F:VO.SQLListProcedures.Qualifier">
      <summary>
        A string representing the name of the qualifier of the procedure.
      </summary>
      <value>A string representing the name of the qualifier of the procedure.</value>
    </member>
    <member name="T:VO.SQLListSpecialColumns">
      <summary>
        List information about the optimal set of columns that uniquely identifies a row in a specified table or the columns that are updated automatically when any value in the row is updated by a transaction.
      </summary>
    </member>
    <member name="M:VO.SQLListSpecialColumns.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct an SQLListSpecialColumns object.
      </summary>
      <param name="nColType">A search string or one of the following constants representing the type of column to return:</param>
      <param name="cQualifier">The search string or name of the table qualifier.</param>
      <param name="cOwner">The search string or name of the table owner.</param>
      <param name="cTableName">The search string or name of the table.</param>
      <param name="nScope">One of the following constants representing the minimum required scope of the current row ID (the returned row ID can be of greater scope.):</param>
      <param name="nNullable">One of the following constants representing whether to return special columns that can have a NULL value:</param>
      <param name="oSQLConnection">The SQL connection indicating where the table can be found.  If not specified, the current default connection is used, if any; if none is defined, the system asks the end user to log on to a database.</param>
      <remarks>
        kColumnType possible values
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SQL_BEST_ROWID</term><description>Returns the optimal column or set of columns that, by retrieving values from the column(s), allows any row in the specified tables to be uniquely identified.</description></item><item><term>SQL_ROWVER</term><description>Returns the column(s) in the specified table, if any, that are automatically updated by the data source when any value in the row is updated by any transaction.</description></item></list>
        kScope possible values
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SQL_SCOPE_CURROW</term><description>The row ID is guaranteed to be valid only while positioned on that row.  A later reselect using row ID may not return a row if the row was updated or deleted by another transaction.</description></item><item><term>SQL_SCOPE_SESSION</term><description>The row ID is guaranteed to be valid for the duration of the session (across transaction boundaries).</description></item><item><term>SQL_SCOPE_TRANSACTION</term><description>The row ID is guaranteed to be valid for the duration of the current transaction.</description></item></list>
        kNullable possible values
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SQL_NO_NULLS</term><description>Exclude special columns that can have NULL values.</description></item><item><term>SQL_NULLABLE</term><description>Return special columns, even if they can have NULL values.</description></item></list>

        Level 1
      </remarks>
    </member>
    <member name="F:VO.SQLListSpecialColumns.ColType">
      <summary>
        A constant representing the type of column to return:
      </summary>
      <value>A constant representing the type of column to return:</value>
      <remarks>
        One of the following constants representing the type of column to return:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SQL_BEST_ROWID</term><description>Returns the optimal column or set of columns that, by retrieving values from the column(s), allows any row in the specified tables to be uniquely identified.</description></item><item><term>SQL_ROWVER</term><description>Returns the column(s) in the specified table, if any, that are automatically updated by the data source when any value in the row is updated by any transaction.</description></item></list></remarks>
    </member>
    <member name="M:VO.SQLListSpecialColumns.Execute">
      <summary>
        Initiate the retrieval of the list of special columns.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.

        Level 1
      </returns>
    </member>
    <member name="F:VO.SQLListSpecialColumns.Nullable">
      <summary>
        A constant representing whether to return special columns that can have a NULL value:
      </summary>
      <value>A constant representing whether to return special columns that can have a NULL value:</value>
      <remarks>
        One of the following constants representing whether to return special columns that can have a NULL value:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SQL_NO_NULLS</term><description>Exclude special columns that can have NULL values.</description></item><item><term>SQL_NULLABLE</term><description>Return special columns, even if they can have NULL values.</description></item></list></remarks>
    </member>
    <member name="F:VO.SQLListSpecialColumns.Owner">
      <summary>
        A string representing the name of the special column table owner.
      </summary>
      <value>A string representing the name of the special column table owner.</value>
    </member>
    <member name="F:VO.SQLListSpecialColumns.Qualifier">
      <summary>
        A string representing the qualifier name for the special column table.
      </summary>
      <value>A string representing the qualifier name for the special column table.</value>
    </member>
    <member name="F:VO.SQLListSpecialColumns.Scope">
      <summary>
        A constant representing the minimum required scope of the current row ID (the returned row ID can be of greater scope.):
      </summary>
      <value>A constant representing the minimum required scope of the current row ID (the returned row ID can be of greater scope.):</value>
      <remarks>
        One of the following constants representing the minimum required scope of the current row ID (the returned row ID can be of greater scope.):
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SQL_SCOPE_CURROW</term><description>The row ID is guaranteed to be valid only while positioned on that row.  A later reselect using row ID may not return a row if the row was updated or deleted by another transaction.</description></item><item><term>SQL_SCOPE_SESSION</term><description>The row ID is guaranteed to be valid for the duration of the session (across transaction boundaries).</description></item><item><term>SQL_SCOPE_TRANSACTION</term><description>The row ID is guaranteed to be valid for the duration of the current transaction.</description></item></list></remarks>
    </member>
    <member name="F:VO.SQLListSpecialColumns.TableName">
      <summary>
        A string representing the name of the special column table.
      </summary>
      <value>A string representing the name of the special column table.</value>
    </member>
    <member name="T:VO.SQLListStatistics">
      <summary>
        List the table statistics and the indexes.
      </summary>
    </member>
    <member name="M:VO.SQLListStatistics.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SQLListStatistics object.
      </summary>
      <param name="cQualifier">The search string or name of the table qualifier.</param>
      <param name="cOwner">The search string or name of the table owner.</param>
      <param name="cTableName">The search string or name of the table.</param>
      <param name="nUnique">One of the following constants representing the type of index associated with the table:</param>
      <param name="nAccuracy">One of the following constants representing the importance of the CARDINALITY and PAGES columns in the result set:</param>
      <param name="oSQLConnection">The SQL connection indicating where the table can be found.  If not specified, the current default connection is used, if any; if none is defined, the system asks the end user to log on to a database.</param>
      <remarks>
        To specify a search pattern, you can use the underscore (_)  or percent (%) wildcard characters in the search string.  An _ will match a single character and a % will match any sequence of 0 or more characters.  The ESCAPE character (driver-defined) permits the _ and % characters to be used as literals.  To obtain the ESCAPE character, you can call SQLConnection:Info(SQL_SEARCH_PATTERN_ESCAPE).
        nUnique possible values:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SQL_INDEX_ALL</term><description>Return all indexes.</description></item><item><term>SQL_INDEX_UNIQUE</term><description>Return only the indexes that are unique.</description></item></list>
        nAccuracy possible values:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SQL_ENSURE</term><description>Requests that the driver unconditionally retrieves the statistics.</description></item><item><term>SQL_QUICK</term><description>Requests that the driver retrieves results only if they are readily available from the server.  In this case, the driver does not ensure that the values are current.</description></item></list></remarks>
    </member>
    <member name="F:VO.SQLListStatistics.Accuracy">
      <summary>
        A constant representing the importance of the CARDINALITY and PAGES columns in the result set:
      </summary>
      <value>A constant representing the importance of the CARDINALITY and PAGES columns in the result set:</value>
      <remarks>
        One of the following constants representing the importance of the CARDINALITY and PAGES columns in the result set:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SQL_ENSURE</term><description>Requests that the driver unconditionally retrieves the statistics.</description></item><item><term>SQL_QUICK</term><description>Requests that the driver retrieves results only if they are readily available from the server.  In this case, the driver does not ensure that the values are current.</description></item></list><note type="tip">Refer to your ODBC documentation for more information on CARDINALITY and PAGES.</note></remarks>
    </member>
    <member name="M:VO.SQLListStatistics.Execute">
      <summary>
        Retrieve the list of statistics about a table and indexes associated with the table.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.

        Level 1
      </returns>
    </member>
    <member name="F:VO.SQLListStatistics.Owner">
      <summary>
        A string representing the owner of the table to which the statistic or index applies.  NULL is not applicable to the data source.
      </summary>
      <value>A string representing the owner of the table to which the statistic or index applies.  NULL is not applicable to the data source.</value>
    </member>
    <member name="F:VO.SQLListStatistics.Qualifier">
      <summary>
        A string representing the qualifier of the table to which the statistic or index applies.
      </summary>
      <value>A string representing the qualifier of the table to which the statistic or index applies.</value>
    </member>
    <member name="F:VO.SQLListStatistics.TableName">
      <summary>
        A string representing the name of the table to which the statistic or index applies.
      </summary>
      <value>A string representing the name of the table to which the statistic or index applies.</value>
    </member>
    <member name="F:VO.SQLListStatistics.Unique">
      <summary>
        A constant representing the type of index associated with the table:
      </summary>
      <value>A constant representing the type of index associated with the table:</value>
      <remarks>
        One of the following constants representing the type of index associated with the table:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SQL_INDEX_ALL</term><description>Return all indexes.</description></item><item><term>SQL_INDEX_UNIQUE</term><description>Return only the indexes that are unique.</description></item></list></remarks>
    </member>
    <member name="T:VO.SQLListTablePrivileges">
      <summary>
        List the tables and associated privileges.
      </summary>
    </member>
    <member name="M:VO.SQLListTablePrivileges.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SQLListTablePrivileges object.
      </summary>
      <param name="cQualifier">The search string or name of the table qualifier.</param>
      <param name="cOwner">The search string or name of the table owner.</param>
      <param name="cTable">The search string or name of the table.</param>
      <param name="oSQLConnection">The SQL connection indicating where the table can be found.  If not specified, the current default connection is used, if any; if none is defined, the system asks the end user to log on to a database.</param>
    </member>
    <member name="M:VO.SQLListTablePrivileges.Execute">
      <summary>
        Retrieve the list of table privileges.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.

        Level 2
      </returns>
    </member>
    <member name="F:VO.SQLListTablePrivileges.Owner">
      <summary>
        A string representing the name of the owner of the table.
      </summary>
      <value>A string representing the name of the owner of the table.</value>
    </member>
    <member name="F:VO.SQLListTablePrivileges.Qualifier">
      <summary>
        A string representing the name of the qualifier for the table.
      </summary>
      <value>A string representing the name of the qualifier for the table.</value>
    </member>
    <member name="F:VO.SQLListTablePrivileges.TableName">
      <summary>
        A string representing the name of the table.
      </summary>
      <value>A string representing the name of the table.</value>
    </member>
    <member name="T:VO.SQLListTables">
      <summary>
        List the table names stored in a specific data source.
      </summary>
    </member>
    <member name="M:VO.SQLListTables.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SQLListTables object.
      </summary>
      <param name="cQualifier">The search string or name of the table qualifier.</param>
      <param name="cOwner">The search string or name of the table owner.</param>
      <param name="cTableName">The search string or name of the table.</param>"
      <param name="cTableType">The list of table types to match (for example, ''Table', 'View', 'Synonym', 'System Table', 'Alias'').  Refer to your driver documentation for a complete list of table types that are available.</param><param name="oSQLConnection">The SQL connection indicating where the table can be found.  If not specified, the current default connection is used, if any; if none is defined, the system asks the end user to log on to a database.</param></member>
    <member name="M:VO.SQLListTables.Execute">
      <summary>
        Retrieve the list of tables.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.

        Level 1
      </returns>
    </member>
    <member name="F:VO.SQLListTables.Owner">
      <summary>
        A string representing a list of names of table owners.
      </summary>
      <value>A string representing a list of names of table owners.</value>
    </member>
    <member name="F:VO.SQLListTables.Qualifier">
      <summary>
        A string representing a list of names of table qualifiers.
      </summary>
      <value>A string representing a list of names of table qualifiers.</value>
    </member>
    <member name="F:VO.SQLListTables.TableName">
      <summary>
        A string representing a list of names of tables.
      </summary>
      <value>A string representing a list of names of tables.</value>
    </member>
    <member name="F:VO.SQLListTables.TableType">
      <summary>
        A string representing a list of table types.
      </summary>
      <value>A string representing a list of table types.</value>
    </member>
    <member name="T:VO.SQLListTypeInfo">
      <summary>
        List the ODBC data types that are supported by this connection.
      </summary>
    </member>
    <member name="M:VO.SQLListTypeInfo.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SQLListTypeInfo object.
      </summary>
      <param name="nSqlType">The ODBC data type of the SQLListTypeInfo object (for example, SQL_INTEGER, SQL_CHAR, SQL_FLOAT, etc.)</param>
      <param name="oSQLConnection">The SQL connection indicating where the table can be found.  If not specified, the current default connection is used, if any; if none is defined, the system asks the end user to log on to a database.</param>
      <remarks>
        <note type="tip">Refer to your ODBC documentation for a complete list of ODBC data types that are available.</note>
      </remarks>
    </member>
    <member name="M:VO.SQLListTypeInfo.Execute">
      <summary>
        Retrieve the list of type information.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.

        Level 1
      </returns>
    </member>
    <member name="F:VO.SQLListTypeInfo.SqlType">
      <summary>
        A numeric value representing the ODBC data type (for example, SQL_INTEGER, SQL_CHAR, SQL_FLOAT, etc.).
      </summary>
      <value>A numeric value representing the ODBC data type (for example, SQL_INTEGER, SQL_CHAR, SQL_FLOAT, etc.).</value>
      <remarks>
        <note type="tip">Refer to your ODBC documentation for a complete list of ODBC data types that are available.</note>
      </remarks>
    </member>
    <member name="T:VO.SQLParameter">
      <summary>
        Describe a SQL parameter.
      </summary>
    </member>
    <member name="M:VO.SqlParameter.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SQLParameter object.
      </summary>
      <param name="oHLParam">The hyperlabel for the SQLParameter object.</param>
      <param name="oFSParam">The column specification for the SQLParameter object.</param>
      <param name="nODBCType">
        The ODBC data type of the SQLParameter object (for example, SQL_INTEGER, SQL_CHAR, SQL_FLOAT, etc.).
      </param>
      <param name="nScale">The decimal precision of the SQLParameter object.  This is specified only when the data type is numeric.</param>
      <param name="lNullable">TRUE if the value can be NULL; otherwise, FALSE.</param>
      <param name="nIndex">The index of the SQLParameter object.</param>
      <remarks>
        <note type="tip">Refer to your ODBC documentation for a complete list of ODBC data types that are available.</note>
      </remarks>
    </member>
    <member name="F:VO.SqlParameter.Index">
      <summary>
        A numeric value representing the index of the parameter object.
      </summary>
      <value>A numeric value representing the index of the parameter object.</value>
    </member>
    <member name="T:VO.SQLSelect">
      <summary>
        Manage a SQL select statement to select a set of rows from an ODBC data source.  The rows can be read, modified, or deleted using the SQLSelect methods.
      </summary>
      <remarks>
        Once a SQL table is opened in a DataServer object, it can be manipulated through the methods of the SQLSelect class:
        <code language="X#">
          oCust:= SQLSelect{"SELECT * FROM customer"}
          oCust:Skip(3)
          ? oCust:CustName
          oCust:Delete()
          oCust:Close()
        </code>

        The model for SQL returns rows and columns as a result set, instead of records and fields.  The columns can be considered as exported instance variables of the object.  They can also be accessed through the FieldGet() and FieldPut() methods, with the column identified through a symbol, a string, or a number:
        <code language="X#">
          oCust := SQLSelect{"SELECT * FROM customer"}
          oCust:CustNo := 1234
          ? oCust:CustNo
          oCust:FieldPut(#CustNo, 1234)
          oCust:FieldPut("CustNo", 1234)
          oCust:FieldPut(1, 1234)
          ? oCust:FieldGet(#CustNo)
          ? oCust:FieldGet("CustNo")
          ? oCust:FieldGet(1)
        </code>
        (The columns are, of course, not real exported variables of the SQLSelect class.  See "Objects, Classes, and Methods" in the Programmer's Guide for a discussion of how these "virtual" exported variables are created using the NoIVarGet() and NoIVarPut() methods.)

        Unlike the DBServer class, the SQLSelect class does not position the server on the first row when an object is created.  However, when a method that references the first row is called, it will automatically be positioned on the first row.
        For databases that support positioned operations (such as, WATCOM) using scrollable cursors, the positioning methods (GoTop(), GoBottom(), Skip(), GoTo()) use the driver.  Otherwise, SQLSelect buffers the rows as it moves forward and performs the positioning methods by moving within the buffer (for backwards positioning).  Refer to the SQLConnection:ScrollCsr access for additional information.  To disable this buffering, use the SQLSelect:BufferData() method.

        It is not possible to use the SQLSelect class to create a database table; the table must exist before a server can be opened on it.
        <note type="tip">
          The cursor type and lock mode that is used by a SQLSelect object can be controlled by the following functions.
          Please consult the documentation for the ODBC driver you are using to see the effects of this setting on the performance of your application.
          SqlSetStmtConcurrency(),
          SqlSetStmtCursorType(),
          SqlSetStmtSimulateCursor()
        </note></remarks>
    </member>
    <member name="M:VO.SQLSelect.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SQL select object.
      </summary>
      <param name="cSQLSelect">A SQL select statement (for example 'SELECT * FROM employee').</param>
      <param name="oSQLConnection">The SQL connection indicating where the table can be found.  If not specified, the current default connection is used, if any; if none is defined, the system asks the end user to log on to a database.</param>
      <returns>
        As with all Init() methods, the instantiation returns the object.  An object is created even if the table was not successfully opened, perhaps because the table does not exist, is corrupted or is locked by another user.
      </returns>
    </member>
    <member name="M:VO.SQLSelect.Append">
      <summary>
        Create a blank row in the buffer; this blank row becomes the current position and is ready for assignment of data values.  The SQLSelect:RecNo of this buffer is SQLSelect:RecCount+1.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">The details of the implementation of this method, and how it interacts with other operations such as unique indexes and concurrency control, depend on the particular database.</note>
        Use FieldPut() to assign values into the blank buffer.  When you attempt to move position off this record, an insert will be automatically performed (using SQLSelect:AppendRow()) into the table, using the values in the buffer.  You can also deliberately force the update to occur by calling SQLSelect:AppendRow() or SQLSelect:Update(TRUE).
        If the AutoCommit option is off, you may need to invoke the Commit() method to insert the row into the database.
        <note type="tip">To cancel the pending update, call the SQLSelect:Delete() method.</note></remarks>
      <example>
        The following example demonstrates the use of the SQLSelect:Append() method:
        <code language="X#">
          FUNCTION NewRecord()
          LOCAL oSel AS SQLSelect
          LOCAL oConn AS SQLConnection
          oConn := SQLConnection{"sample","dba","sql"}
          oSel := SQLSelect{"SELECT * FROM customer", oConn}
          oSel:Append()
          oSel:CustNo := 515
          oSel:CustName := "Michelle"
          oSel:GoTop()		// Record inserted at this point
          oSel:FreeStmt(SQL_DROP)
          oConn:Disconnect()
        </code></example>
    </member>
    <member name="P:VO.SQLSelect.AppendFlag">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.SQLSelect.AppendRow(XSharp.__Usual)">
      <summary>
        Insert the row that has been created in the buffer since the last SQLSelect:Append() operation.
      </summary>
      <param name="lForce">A logical value determining whether the update should occur.  If omitted, the default is TRUE.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">The details of the implementation of this method, and how it interacts with other operations such as unique indexes and concurrency control, depend on the particular database.</note>
        This method is used to actually perform the insertion of a row into the table after the SQLSelect:Append() and SQLSelect:FieldPut() operations have been performed, which insert a blank row into the buffer and assign values into the buffer.
        It is not necessary to call SQLSelect:AppendRow() in all cases, since it will be called automatically when the position is changed (for example, using GoTop(), Skip(), etc.), using the values in the buffer.
        If the AutoCommit option is off, you may need to invoke the Commit() method to insert the row into the database.
        <note type="tip">To cancel the pending update, call the SQLSelect:Delete() method.</note></remarks>
    </member>
    <member name="P:VO.SQLSelect.BoF">
      <summary>
        A logical value indicating whether the server is positioned at the beginning of the result set, on the first row.
      </summary>
      <value>A logical value indicating whether the server is positioned at the beginning of the result set, on the first row.</value>
      <remarks>
        A logical value indicating whether the server is positioned at the beginning of the result set, on the first row.
        It returns TRUE after an attempt to move backward beyond the first logical row in the result set; otherwise, it returns FALSE.  If the current result set contains no rows, BOF returns TRUE.
      </remarks>
    </member>
    <member name="P:VO.SQLSelect.BoundedColumns">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.SQLSelect.BufferData">
      <summary>

        Note: This method is no longer available in Visual Objects 2.8 !
      </summary>
    </member>
    <member name="M:VO.SQLSelect.Close">
      <summary>
        Close the cursor corresponding to the server.  Note that the database connection is not closed, only the cursor.
      </summary>
      <returns>
        TRUE if the operation was successful; FALSE if not.  (How can closing down a server be unsuccessful?  If you are accessing a database over a network, and the network goes down before the server is closed, the SQLSelect:Close() operation may be the first one to fail, but it is still important to respond to this failure since it may indicate that database changes are not committed.)
      </returns>
    </member>
    <member name="M:VO.SQLSelect.Column(XSharp.__Usual)">
      <summary>
        Return a specified SQL column.
      </summary>
      <param name="siCol">The name, number, or symbol representing the desired column.</param>
      <returns>
        A SQLColumn object if successful; otherwise, NULL_OBJECT.
      </returns>
    </member>
    <member name="M:VO.SQLSelect.ColumnAttributes(XSharp.__Usual)">
      <summary>
        Return the SQL column attributes for a specified column.
      </summary>
      <param name="siCol">The name, number, or symbol representing the desired column.</param>
      <returns>
        A SQLColumnAttributes object if successful; otherwise, NULL_OBJECT.
      </returns>
    </member>
    <member name="M:VO.SQLSelect.Commit">
      <summary>
        Save the changes (updates and deletes) made since the last Commit().
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.  Commit() can fail for many reasons, from a lack of capability in the server to lock conflicts to technical problems such as network crashes.  Use the SQLSelect:Status property to determine the exact cause of the failure.
      </returns>
      <remarks>
        The exact implications of this action depend on the server.  With some database management systems, the method commits all servers using the same connection; with others, it commits only this server; and with yet others the method does nothing.  In addition, some SQL servers have other implications of a commit operation (they can close cursors, for example).  This is an area that is not standardized; you should carefully study the documentation for your database management system.
        The AutoCommit option may interfere with manual commits.  You may want to turn AutoCommit off, for example:
        <code language="X#">oSelect:Connection:SetConnectOption(SQL_AUTOCOMMIT, 0)</code></remarks>
    </member>
    <member name="P:VO.SQLSelect.Connection">
      <summary>
        The SQL connection object that the SQLSelect is using to manipulate the result set.
      </summary>
      <value>The SQL connection object that the SQLSelect is using to manipulate the result set.</value>
    </member>
    <member name="P:VO.SQLSelect.CursorName">
      <summary>
        A string containing the cursor name.
      </summary>
      <value>A string containing the cursor name.</value>
    </member>
    <member name="P:VO.SQLSelect.CursorType">
      <summary>
        A constant, which describes the cursor type used by the SQL statement:
      </summary>
      <value>A constant, which describes the cursor type used by the SQL statement:</value>
      <remarks>
        One of the following constants, which describes the cursor type used by the SQL statement:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SQL_CURSOR_FORWARD_ONLY</term><description>The cursor only scrolls forward</description></item><item><term>SQL_CURSOR_KEYSET_DRIVEN</term><description>The driver saves and uses the keys for the number of rows specified in the SQL_ATTR_KEYSET_SIZE statement attribute</description></item><item><term>SQL_CURSOR_DYNAMIC</term><description>The driver saves and uses only the keys for the rows in the rowset.</description></item><item><term>SQL_CURSOR_STATIC</term><description>The data in the result set is static</description></item></list>
        The default value for this property can be set through the function SqlSetStmtCursorType()
        <note type="tip">
          Please consult the documentation for the ODBC driver you are using to see the effects of this setting on the performance of your application.
        </note></remarks>
    </member>
    <member name="M:VO.SQLSelect.DataField(XSharp.__Usual)">
      <summary>
        Return the data (DataField object) at a specified column position.
      </summary>
      <param name="uFieldPos">The name, number, or symbol representing the desired column.</param>
      <returns>
        A DataField object if successful; otherwise, -1.
      </returns>
    </member>
    <member name="P:VO.SQLSelect.DBStruct">
      <summary>
        An array containing the structure of this data server.
      </summary>
      <value>An array containing the structure of this data server.</value>
      <remarks>
        An array containing the structure of this data server, whose length (that is, number of elements) is equal to the number of columns in the server.
        Each subarray is comprised of five elements, which contain the following information, in this order:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>DBS_NAME</term><description>cName</description></item><item><term>DBS_TYPE</term><description>cType</description></item><item><term>DBS_LEN</term><description>nLength</description></item><item><term>DBS_DEC</term><description>nDecimals</description></item><item><term>DBS_ALIAS</term><description>cAlias</description></item></list></remarks>
    </member>
    <member name="M:VO.SQLSelect.Delete">
      <summary>
        Delete the current row.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        The row is not deleted until the Commit() is invoked and is not deleted if Rollback() is invoked.  Delete() sends a NotifyRecordChange message if successful.
        If the server is currently positioned on the append buffer, SQLSelect:Delete() will cancel the pending update.
        The type of SQL statement (searched or positioned) used by Delete() is determined by the system automatically, unless set to cursor, key, or value, using SQLSelect:ScrollUpdateType.
        <note type="tip">If the type of SQL statement used by SQLSelect:Delete() is "value", more than one row may be deleted, since the rows that are deleted are based on matching this value.</note></remarks>
    </member>
    <member name="P:VO.SQLSelect.Deleted">
      <summary>
        A logical value indicating whether the current row has been deleted.
      </summary>
      <value>A logical value indicating whether the current row has been deleted.</value>
      <remarks>
        A logical value indicating whether the current row has been deleted.
        It returns TRUE if the current row has been deleted; otherwise, it returns FALSE.
      </remarks>
    </member>
    <member name="P:VO.SQLSelect.EoF">
      <summary>
        A logical value indicating whether the server is positioned at the end of the result set, after the last row.
      </summary>
      <value>A logical value indicating whether the server is positioned at the end of the result set, after the last row.</value>
      <remarks>
        A logical value indicating whether the server is positioned at the end of the result set, after the last row.
        It returns TRUE after an attempt to move forward beyond the last logical row; otherwise, it returns FALSE.  If the current result set contains no rows, BOF returns TRUE.
      </remarks>
    </member>
    <member name="P:VO.SQLSelect.ErrInfo">
      <summary>
        An SQLErrorInformation object.
      </summary>
      <value>An SQLErrorInformation object.</value>
    </member>
    <member name="M:VO.SQLSelect.Error(XSharp.__Usual)">
      <summary>
        Provide a method for handling error conditions raised during database processing.  This is an event handler: it is automatically called by other methods; the developer does not normally need to call the error method, but might want to replace or amend it.
      </summary>
      <param name="oError">An Error object describing the error condition.</param>
      <remarks>
        All methods of the SQLSelect trap serious errors with a recover statement and send them to this method.  Ordinary failures, such as locking conflicts or record-not-found, do not raise error conditions; they are simply indicated through failure return values.
        The standard Error() handling method fills in some more information about the errors and about the SQLSelect object that originates the error, sets the status value for the server object, and passes the problem to its client, if there is one, in its standard Error() handling method.  If there is no client who wants to deal with the problem, the method passes it up the call stack by issuing a BREAK with the same Error object.
        <note type="tip">If an error comes in while one is being handled, the Error() method immediately breaks.</note></remarks>
    </member>
    <member name="M:VO.SQLSelect.Execute(XSharp.__Usual)">
      <summary>
        Open the cursor.
      </summary>
      <param name="uParam">
        The array of parameters to execute.
        &lt;cParam&gt; [, &lt;cParam&gt; …] | &lt;nParam&gt; [ , &lt;nParam&gt; …]
        The list of parameters to execute.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <example>
        The following example demonstrates the use of the SQLSelect:Execute() method:
        <code language="X#">
          oSel := SQLSelect{"SELECT * FROM customer WHERE CustNo &gt; ?",oConn}
          oSel:Execute(100)
        </code></example>
    </member>
    <member name="M:VO.SQLSelect.ExtendedFetch(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Provide extended fetch capabilities, specifying type and row.
      </summary>
      <param name="kFetchType">The type of fetch (for example, SQL_FETCH_NEXT, SQL_FETCH_PREV, SQL_FETCH_FIRST, SQL_FETCH_LAST, SQL_FETCH_ABSOLUTE, SQL_FETCH_RELATIVE).  Refer to your ODBC documentation for a complete list of ODBC fetch types that are available.</param>
      <param name="kRow">The row to be fetched, specified by SQL_FETCH_ABSOLUTE or SQL_FETCH_RELATIVE.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.

        Level 2
      </returns>
      <remarks>
        Sends a NotifyRecordChange message, if successful.  (If &lt;kFetchType&gt; is specified as SQL_FETCH_FIRST, this method sends a NotifyGoTop message, if successful.  If SQL_FETCH_LAST is specified, NotifyGoBottom is sent, if successful.)
        <note type="tip">ODBC does not support the use of both SQLSelect:Fetch() and SQLSelect:ExtendedFetch() within the same select.</note></remarks>
    </member>
    <member name="P:VO.SQLSelect.FCount">
      <summary>
        The number of columns in the result set.  A value of -1 indicates an error.
      </summary>
      <value>The number of columns in the result set.  A value of -1 indicates an error.</value>
    </member>
    <member name="M:VO.SQLSelect.Fetch">
      <summary>
        Fetch the next row.
      </summary>
      <returns>
        TRUE if successful; otherwise FALSE.
      </returns>
      <remarks>
        Sends a NotifyRecordChange message, if successful.
        <note type="tip">ODBC does not support the use of both SQLSelect:Fetch() and SQLSelect:ExtendedFetch() within the same select.</note></remarks>
    </member>
    <member name="M:VO.SQLSelect.FIELDGET(XSharp.__Usual)">
      <summary>
        Retrieve the contents of the specified column.
      </summary>
      <param name="uField">The name, number, or symbol representing the desired column.</param>
      <returns>
        The contents of the specified column, whose data type depends on the data type of the column, which is available from the Column() or ColumnAttributes() method.
        The following table shows how the ODBC database data type is mapped to the X# return value and the return value if the SQL value of the column is NULL:
        <list type="table"><listheader><term>ODBC Data Type</term><description>Return Value - NULL Return Value</description></listheader><item><term>SQL_BIGINT</term><description>DWORD - NIL</description></item><item><term>SQL_BIT</term><description>LOGIC - NIL</description></item><item><term>SQL_CHAR</term><description>STRING - NULL_STRING</description></item><item><term>SQL_DATE</term><description>DATE - NULL_DATE</description></item><item><term>SQL_DECIMAL</term><description>REAL8 - NIL</description></item><item><term>SQL_DOUBLE</term><description>REAL8 - NIL</description></item><item><term>SQL_FLOAT</term><description>REAL8 - NIL</description></item><item><term>SQL_INTEGER</term><description>LONGINT - NIL</description></item><item><term>SQL_LONGVARBINARY</term><description>MEMO - NULL_STRING</description></item><item><term>SQL_LONGVARCHAR</term><description>MEMO - NULL_STRING</description></item><item><term>SQL_NUMERIC</term><description>REAL8 - NIL</description></item><item><term>SQL_REAL </term><description>REAL4 N- IL</description></item><item><term>SQL_SMALLINT</term><description>SHORTINT - NIL</description></item><item><term>SQL_TIME </term><description>STRING - NULL_STRING</description></item><item><term>SQL_TIMESTAMP</term><description>STRING - NULL_DATE</description></item><item><term>SQL_TINYINT</term><description>BYTE - NIL</description></item><item><term>SQL_VARCHAR</term><description>STRING - NULL_STRING</description></item></list></returns>
    </member>
    <member name="M:VO.SQLSelect.FieldGetFormatted(XSharp.__Usual)">
      <summary>
        Retrieve the contents of the specified column according to the formatting specifications of its field specification.
      </summary>
      <param name="uFieldPos">The name, number, or symbol representing the desired column.</param>
    </member>
    <member name="M:VO.SQLSelect.FieldHyperLabel(XSharp.__Usual)">
      <summary>
        Return the hyperlabel of a specified column.
      </summary>
      <param name="uFieldPos">The name, number, or symbol representing the desired column.</param>
      <returns>
        The column hyperlabel object if successful; otherwise, NULL_OBJECT.
      </returns>
      <remarks>
        By accessing the hyperlabel, you can in turn access its various properties which annotate the column:
        <code language="X#">
          oServer:FieldHyperLabel(#LastName):Caption
          oServer:FieldHyperLabel(#LastName):Description
          oServer:FieldHyperLabel(#LastName):HelpContext
        </code></remarks>
    </member>
    <member name="M:VO.SQLSelect.FieldInfo(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Retrieve information about or set an alias for the indicated column.
      </summary>
      <param name="kFieldInfoType">
        The type of information, as specified by the following constants:
      </param>
      <param name="uFieldPos">The name, number, or symbol representing the desired column.</param>
      <param name="uFieldVal">The alias name to be assigned to the column.  This argument is only used if DB_ALIAS is specified for &lt;kColumnInfoType&gt;.</param>
      <returns>
        A value (whose data type depends on the value requested) if successful; otherwise, NIL.
      </returns>
      <remarks>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>DBS_ALIAS</term>
            <description>Alternate name (or alias) by which a column can be referenced</description>
          </item>
          <item>
            <term>DBS_DEC</term>
            <description>Number of decimal places</description>
          </item>
          <item>
            <term>DBS_LEN</term>
            <description>Length (field size) as a number</description>
          </item>
          <item>
            <term>DBS_NAME</term>
            <description>Field name as a string</description>
          </item>
          <item>
            <term>DBS_TYPE</term>
            <description>Data type as a string</description>
          </item>
        </list>
        The SQLSelect:FieldInfo() method is used to retrieve information about a column, except if you specify &lt;kColumnInfoType&gt; to be DBS_ALIAS.  You can then specify an alias for a column, which you can access by using the SQLColumn:AliasName property.
      </remarks>
    </member>
    <member name="M:VO.SQLSelect.FieldName(XSharp.__Usual)">
      <summary>
        Return the name of a specified column.  Note that the column's hyperlabel also contains a name.
      </summary>
      <param name="siFieldPosition">The name, number, or symbol representing the desired column.</param>
      <returns>
        The name of the specified column if successful; otherwise, NULL_STRING.
      </returns>
    </member>
    <member name="M:VO.SQLSelect.FieldPos(XSharp.__Usual)">
      <summary>
        Return the position of a specified column within the data server, as a number starting with 1.
      </summary>
      <param name="cFieldName">The name, number, or symbol representing the desired column.</param>
      <returns>
        The position of the specified column if successful; otherwise, 0.
      </returns>
    </member>
    <member name="M:VO.SQLSelect.FIELDPUT(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Assign a value to a column in a data server.
      </summary>
      <param name="uFieldPos">The name, number, or symbol representing the desired column.</param>
      <param name="uValue">The value to be assigned to the column.  The data type of the value should match the data type of the column (refer to SQLSelect:FieldGet() for data types); if not, it is converted.</param>
      <returns>
        The value assigned to the column if successful; otherwise, NIL.
      </returns>
      <remarks>
        Sends a NotifyRecordChange message, if successful.
      </remarks>
    </member>
    <member name="M:VO.SQLSelect.FieldSpec(XSharp.__Usual)">
      <summary>
        Return the field specification object for the indicated column.
      </summary>
      <param name="uFieldPos">The name, number, or symbol representing the desired column.</param>
      <returns>
        The field specification object if successful; otherwise, NULL_OBJECT.
      </returns>
    </member>
    <member name="M:VO.SQLSelect.FieldStatus(XSharp.__Usual)">
      <summary>
        Return a hyperlabel object identifying the status after the last operation.
      </summary>
      <param name="uFieldPos">The name, number, or symbol representing the desired column.</param>
      <returns>
        Returns a hyperlabel object if any error condition had occurred or if a validation has failed, NIL if everything is OK, if the validation passed, or if there has been no validation attempt.  In particular, SQLSelect:FieldStatus() can be used to find out more about a validation failure.
        By accessing the properties of this hyperlabel, you can retrieve not only a description but also context-sensitive help on the condition that was raised:
        <code language="X#">
          oServer:FieldStatus(#LastName):Caption
          oServer:FieldStatus(#LastName):Description
          oServer:FieldStatus(#LastName):HelpContext
        </code></returns>
    </member>
    <member name="M:VO.SQLSelect.FieldSym(XSharp.__Usual)">
      <summary>
        Return the symbolic name of a specified column.  Note that the column's hyperlabel also contains a name; these two names are the same in the code generated by the SQL Editor.
      </summary>
      <param name="uFieldPos">The name, number, or symbol representing the desired column.</param>
      <returns>
        The symbolic name if successful; otherwise, NULL_SYMBOL.
      </returns>
    </member>
    <member name="M:VO.SQLSelect.FieldValidate(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Validate the provided value according to the validation rules of the indicated column's FieldSpec.
      </summary>
      <param name="uFieldPos">The name, number, or symbol representing the desired column.</param>
      <param name="uValue">
        The value that is to be validated.  It should be of a type compatible with the data type of the column; 
        if the type cannot be converted to the appropriate data type, it is considered to have failed validation.
      </param>
    </member>
    <member name="M:VO.SQLSelect.FLOCK">
      <summary>
        This method is provided to override the inherited functionality from the DataServer class, as it does not apply to SQLSelect.
      </summary>
    </member>
    <member name="P:VO.SQLSelect.FOUND">
      <summary>
        A logical value indicating whether the previous search operation succeeded.
      </summary>
      <value>A logical value indicating whether the previous search operation succeeded.</value>
    </member>
    <member name="M:VO.SQLSelect.FreeStmt(XSharp.__Usual)">
      <summary>
        Free the statement, according to the specified option.
      </summary>
      <param name="kOption">The option used when the statement is freed, specified by one of the following constants:</param>
      <param name="Constant">Description</param>
      <param name="SQL_CLOSE">Closes the cursor.</param>
      <param name="SQL_DROP">Closes the cursor, unbinds and resets the parameters, and frees the statement.</param>
      <param name="SQL_RESET_PARAMS">Resets the parameters.</param>
      <param name="SQL_UNBIND">Unbinds the parameters.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.SQLSelect.GetData(XSharp.__Usual)">
      <summary>
        Retrieve the contents of the specified column.
      </summary>
      <returns>
        The data type of the return value depends on the data type of the column, which is available from Column() or ColumnAttributes() methods.  If the SQL value of the column is NULL, then NIL is returned.
      </returns>
    </member>
    <member name="M:VO.SQLSelect.GetLookupTable(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Retrieve a two-column array of values from two fields in the server.
      </summary>
      <param name="nMaxRows">
        The maximum number of rows that should be retrieved.  If omitted, the default is 100.
        The name, number, or symbol of the first field to be retrieved.  If omitted, the first field is retrieved.
        The name, number, or symbol of the second field to be retrieved.  If omitted, the second field is retrieved.
      </param>
      <returns>
        The method returns a two-column array of values found for the specified fields, moving sequentially until the specified maximum number of rows or until end of file.
        Note that the method does not reposition to the beginning before starting to fill the array.  Either provide a start value, or explicitly position the server before using the method.  (This allows incremental reading, building up an array in pieces.)
      </returns>
      <remarks>
        Sends a NotifyRecordChange message afterwards, and leaves the server positioned at the last record used or at end of file (last file record).  One use of this method is to populate translation lists in user interfacing.  The resulting array can be used in ATranslate().
      </remarks>
      <example>
        The following builds a lookup table, for example to translate product codes into product names and vice versa, beginning at the indicated product number:
        <code language="X#">
          oSQLSelect := SQLSelect{"SELECT * FROM products WHERE ProdNo &gt; 100"}
          aProducts := SQLSelect:GetLookupTable(500,#ProdNo, #ProdName)
          oSQLSelect:Close()
        </code></example>
    </member>
    <member name="M:VO.SQLSelect.GetStatementOption(XSharp.__Usual)">
      <summary>
        Retrieve the current setting for a statement option.
      </summary>
      <param name="kStmtOption">The statement option (for example, SQL_MAX_LENGTH or SQL_NOSCAN).  Refer to SQLGetStmtOption() in your ODBC documentation for a complete list of ODBC connection options that are available.</param>
      <returns>
        The current settings for a statement option if successful; otherwise, NIL.

        Level 1
      </returns>
    </member>
    <member name="M:VO.SQLSelect.GoBottom">
      <summary>
        Position the data server on the last row.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyGoBottom message, if successful.
        <note type="tip">If the database supports scrollable cursors (see SQLConnection:ScrollCsr), then record numbers will be negative relative to the bottom (see SQLSelect:RecNo).  If not, all records will be buffered, to simulate positioning.  Use with caution, since large result sets may degrade performance.  You can disable the buffering with the SQLSelect:BufferData() method.</note></remarks>
      <example>
        The following example demonstrates the value that SQLSelect:RecNo returns after the SQLSelect:GoBottom() method is called:
        <code language="X#">
          oCust := SQLSelect{"SELECT * FROM customer"}
          oCust:GoTop()
          ? oCust:RECNO			// Prints 1
          oCust:Skip()
          ? oCust:RECNO			// Prints 2
          oCust:GoBottom()
          ? oCust:RECNO			// Prints -1
          oCust:Skip(-1)
          ? oCust:RECNO			// Prints -2
          oCust:GoTop()
          ? oCust:RECNO			// Prints 1
          oCust:Skip()
          ? oCust:RECNO			// Prints 2
        </code></example>
    </member>
    <member name="M:VO.SQLSelect.GoTo(XSharp.__Usual)">
      <summary>
        Position the data server on the specified row number.
      </summary>
      <param name="nRow">The row number that the server should be positioned to.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">Some types of data servers cannot support movement by row number.</note>
        Sends a NotifyRecordChange message, if successful.
      </remarks>
    </member>
    <member name="M:VO.SQLSelect.GoTop">
      <summary>
        Position the data server on the first row.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyGoTop message, if successful.
      </remarks>
      <example>
        The following example demonstrates the value that SQLSelect:RecNo returns after the SQLSelect:GoTop() method is called:
        <code language="X#">
          oCust := SQLSelect{"SELECT * FROM customer"}
          oCust:GoTop()
          ? oCust:RECNO				// Prints 1
          oCust:Skip()
          ? oCust:RECNO				// Prints 2
          oCust:GoBottom()
          ? oCust:RECNO				// Prints -1
          oCust:Skip(-1)
          ? oCust:RECNO				// Prints -2
          oCust:GoTop()
          ? oCust:RECNO				// Prints 1
          oCust:Skip()
          ? oCust:RECNO				// Prints 2
        </code></example>
    </member>
    <member name="P:VO.SQLSelect.LASTREC">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="P:VO.SQLSelect.MoreResults">
      <summary>
        A logical value representing whether there are more rows to retrieve.
      </summary>
      <value>A logical value representing whether there are more rows to retrieve.</value>
    </member>
    <member name="P:VO.SQLSelect.Name">
      <summary>
        A string representing the name of the table.
      </summary>
      <value>A string representing the name of the table.</value>
    </member>
    <member name="P:VO.SQLSelect.NameSym">
      <summary>
        A symbol representing the name of the table.
      </summary>
      <value>A symbol representing the name of the table.</value>
    </member>
    <member name="P:VO.SQLSelect.NativeSQL">
      <summary>
        A string containing the native SQL text of the statement.

        Level 2
      </summary>
      <value>
        A string containing the native SQL text of the statement.

        Level 2
      </value>
    </member>
    <member name="M:VO.SQLSelect.NoIVarGet(XSharp.__Usual)">
      <summary>
        Provide a general error interception that is automatically called (in any class) whenever an access reference is made to a non-existent exported instance variable.  In the SQLSelect class, it is used to implement the virtual column variable.
        <br />Important!  NoIVarGet() should not be called directly; it is called by the system for handling invalid references.
      </summary>
      <param name="symFieldName">he name, number, or symbol representing the desired column.</param>
      <remarks>
        For SQLSelect, this method is used to intercept references to column names as exported variables, which ordinarily would not be allowed.  If the column name is valid, it does FieldGet() for the corresponding column name, in effect turning table columns into access methods of each SQLSelect object.  See "Objects, Classes, and Methods" in the Programmer's Guide for more information on NoIVarGet().
      </remarks>
    </member>
    <member name="M:VO.SQLSelect.NoIVarPut(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Provide a general error interception that is automatically called (in any class) whenever an assignment reference is made to a non-existent exported instance variable.
        <br />Important!  NoIVarPut() should not be called directly; it is called by the system for handling invalid references.
      </summary>
      <param name="symFieldName">The name, number, or symbol representing the desired column.</param>
      <param name="uValue">The corresponding value to be assigned.  &lt;uValue&gt; should be compatible with the column type.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyFieldChange message if the variable reference was to a valid column of the server, and the assignment was successful.
        For SQLSelect, this method is used to intercept references to column names as exported variables, which ordinarily would not be allowed.  If the column name is valid, it does a FieldPut() for the corresponding column name with the passed value, in effect turning table columns into Assign methods of each SQLSelect object.  See "Objects, Classes, and Methods" in the Programmer's Guide for more information on NoIVarPut().
      </remarks>
    </member>
    <member name="M:VO.SQLSelect.Notify(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Provide a method that is automatically called by the action methods of the server after completion of some significant event:  a column has changed, the server position has changed, some operation has been completed.  Its standard implementation is to broadcast the same notification to its attached clients.
      </summary>
      <param name="kNotifyName">
        The identification of the event, specified as one of the following constants:
        symbol describing the event.  Used only with some notification types, as described above.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <include file="VOSDK_Classes.xml" path="doc/commonblocks/notify/*" />
      </remarks>
    </member>
    <member name="P:VO.SQLSelect.NullAsBlank">
      <summary>
        A logical value determining whether SQL NULL values are strongly typed (TRUE) or not (FALSE, default value).
      </summary>
      <value>A logical value determining whether SQL NULL values are strongly typed (TRUE) or not (FALSE, default value).</value>
      <remarks>
        A logical value determining whether SQL NULL values are strongly typed (TRUE) or not (FALSE, default value).  Proper support for SQL NULL values would be to set this value to TRUE.
        <para>If TRUE, null fields will have the following values:</para><list type="table"><listheader><term>VO Type</term><description>NULL Value</description></listheader><item><term>STRING</term><description>NULL_STRING</description></item><item><term>DATE</term><description>NULL_DATE</description></item><item><term>LOGIC</term><description>FALSE</description></item><item><term>FLOAT</term><description>0</description></item><item><term>LONG</term><description>0</description></item><item><term>All others</term><description>NIL</description></item></list>

        If FALSE, all null fields will be NIL.  Note that the default behavior (FALSE) can cause conflicts with strongly typed variables, as NIL cannot be assigned to strongly typed variables.
      </remarks>
    </member>
    <member name="P:VO.SQLSelect.NumParameters">
      <summary>
        A numeric value containing the number of parameters.  A value of -1 indicates an error.

        Level 2
      </summary>
      <value>
        A numeric value containing the number of parameters.  A value of -1 indicates an error.

        Level 2
      </value>
    </member>
    <member name="M:VO.SQLSelect.NumResultCols">
      <summary>
        Return the number of columns in the result set.
      </summary>
      <returns>
        The number of columns if successful; otherwise, -1.
      </returns>
    </member>
    <member name="P:VO.SQLSelect.NumResultColumns">
      <summary>
        A numeric value containing the number of columns in the result set.
      </summary>
      <value>A numeric value containing the number of columns in the result set.</value>
    </member>
    <member name="P:VO.SQLSelect.NumSuccessfulRows">
      <summary>
        A numeric value containing the number of rows that were modified by a delete, append, or update operation.
      </summary>
      <value>A numeric value containing the number of rows that were modified by a delete, append, or update operation.</value>
    </member>
    <member name="M:VO.SQLSelect.PreExecute(XSharp.__Usual)">
      <summary>
        Return the SQL command that is generated by X#.
      </summary>
      <param name="cSQLString">A string containing the SQL statement which will be passed to the SQL driver.</param>
      <returns>
        A possibly updated SQL string that will be passed to the SQL driver.
      </returns>
      <remarks>
        This method is a callback method that is passed to the SQL command generated by X# for the purpose of inspection and optional modification, immediately prior to the command being passed to ODBC.  It must return SQL statement text.
      </remarks>
      <example>
        The following example demonstrates the use of the SQLSelect:PreExecute() method:
        <code language="X#">
          METHOD PreExecute(cSQLString) CLASS SubclassOfSQLSelect
          ? sSQLString	//View all the SQL can modify it here, too
          RETURN cSQLString
        </code></example>
    </member>
    <member name="M:VO.SQLSelect.Prepare">
      <summary>
        Prepare the statement.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        In most cases, there is no need to invoke SQLSelect:Prepare(), since it is automatically invoked when needed.
      </remarks>
    </member>
    <member name="P:VO.SQLSelect.PrepFlag">
      <summary>
        A logical value that indicates if the select statement has been prepared.
      </summary>
      <value>A logical value that indicates if the select statement has been prepared.</value>
    </member>
    <member name="P:VO.SQLSelect.RecCount">
      <summary>
        A numeric value representing the number of rows in the data server.
      </summary>
      <value>A numeric value representing the number of rows in the data server.</value>
      <remarks>
        A numeric value representing the number of rows in the data server.  NIL is returned if the number of rows cannot be determined.
        <note type="tip">Some types of data servers may not be able to provide this number.</note></remarks>
    </member>
    <member name="P:VO.SQLSelect.Recno">
      <summary>
        A numeric value representing the relative position in the data server.
      </summary>
      <value>A numeric value representing the relative position in the data server.</value>
      <remarks>
        A numeric value representing the relative position in the data server.
        It is not possible to efficiently or accurately determine how many records are in the result set for SQL (especially for databases that support scrollable cursors, like WATCOM).  Therefore, negative numbers are used to reflect relative position from the bottom of the database, as positive numbers are used to reflect relative position from the top of the database.
        If the server is positioned at the Phantom record (after skipping past the last record) SQLSelect:Recno returns SQLSelect:Reccount+1
      </remarks>
      <example>
        The following example demonstrates the value that SQLSelect:RecNo returns after each method is called:
        <code language="X#">
          oCust := SQLSelect{"SELECT * FROM customer"}
          oCust:GoTop()
          ? oCust:RECNO			// Prints 1
          oCust:Skip()
          ? oCust:RECNO			// Prints 2
          oCust:GoBottom()
          ? oCust:RECNO			// Prints -1
          oCust:Skip(-1)
          ? oCust:RECNO			// Prints -2
          oCust:GoTop()
          ? oCust:RECNO			// Prints 1
          oCust:Skip()
          ? oCust:RECNO			// Prints 2
        </code></example>
    </member>
    <member name="M:VO.SQLSelect.Refresh">
      <summary>
        Refresh the current row in the buffer, discarding any changes that have been made.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyRecordChange message, if successful.
        This command discards all changes to the current row.  It is useful as a way of implementing Undo in an application. However, it cannot roll back changes that have been committed with the SQLSelect:Commit().  Also, note that it applies only to the current row; the data server and the drivers do not buffer changes made to multiple rows.
      </remarks>
    </member>
    <member name="M:VO.SQLSelect.ResetNotification">
      <summary>
        Resume the broadcasting of Notify messages to the server's attached clients (after SQLSelect:SuspendNotification() has been called).
      </summary>
      <remarks>
        This method is used in conjunction with SQLSelect:SuspendNotification(), which suspends the broadcasting of Notify messages.
        Note that SQLSelect:SuspendNotification() stacks its invocations.  Therefore, for each call to SQLSelect:SuspendNotification(), there needs to be a corresponding call SQLSelect:ResetNotification().
      </remarks>
    </member>
    <member name="M:VO.SQLSelect.RLOCK(XSharp.__Usual)">
      <summary>
        This method is provided to override the inherited functionality from the DataServer class, as it does not apply to SQLSelect.
      </summary>
    </member>
    <member name="M:VO.SQLSelect.RLockVerify">
      <summary>
        This method is provided to override the inherited functionality from the DataServer class, as it does not apply to SQLSelect.
      </summary>
    </member>
    <member name="M:VO.SQLSelect.Rollback">
      <summary>
        Undo the changes (updates and deletes) made since the last Commit().
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.  Rollback() can fail for many reasons, from a lack of capability in the server to lock conflicts to technical problems such as network crashes.  Use the SQLSelect:Status property to determine the exact cause of the failure.
      </returns>
      <remarks>
        Some servers lack support for this operation.  If the server does support it, the exact implications of a rollback vary with the server — with some database management systems, the method rolls back all servers using the same connection; with others, it rolls back only this server.  In addition, some SQL servers have other implications of a rollback operation (they can close cursors, for example).  This is an area that is that is not standardized in SQL; you should carefully study the documentation for your database management system.
        The AutoCommit option may interfere with manual commits.  You may want to turn AutoCommit off, for example:
        <code language="X#">oSelect:Connection:SetConnectOption(SQL_AUTOCOMMIT, 0)</code></remarks>
    </member>
    <member name="P:VO.SQLSelect.ScrollConcurrency">
      <summary>
        A constant, which describes the concurrency mode used by the SQL statement:
      </summary>
      <value>A constant, which describes the concurrency mode used by the SQL statement:</value>
      <remarks>
        <para>One of the following constants, which describes the concurrency mode used by the SQL statement:</para>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>SQL_CONCUR_READ_ONLY</term>
            <description>Cursor is read-only. No updates are allowed</description>
          </item>
          <item>
            <term>SQL_CONCUR_LOCK</term>
            <description>Cursor uses the lowest level of locking sufficient to ensure that the row can be updated</description>
          </item>
          <item>
            <term>SQL_CONCUR_ROWVER</term>
            <description>Cursor uses optimistic concurrency control, comparing row versions such as SQLBase ROWID or Sybase TIMESTAMP</description>
          </item>
          <item>
            <term>SQL_CONCUR_VALUES</term>
            <description>Cursor uses optimistic concurrency control, comparing values</description>
          </item>
        </list>
        The default value for this property can be set through the function SqlSetStmtConcurrency()
        <note type="tip">
          Please consult the documentation for the ODBC driver you are using to see the effects of this setting on the performance of your application.
        </note></remarks>
    </member>
    <member name="P:VO.SQLSelect.ScrollUpdateType">
      <summary>
        A constant, which describes the type of SQL statement to use during append, update or delete operations.
      </summary>
      <value>A constant, which describes the type of SQL statement to use during append, update or delete operations.</value>
      <remarks>
        One of the following constants, which describes the type of SQL statement; searched (by key or value) or positioned (by cursor) to use during append, delete, or update operations:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SQL_SC_UPD_AUTO</term><description>
              The system determines which type of SQL statement to use:  attempting to use cursor, key, and value, respectively.
              The type that applies first is used.  This is the <b>default</b>.
            </description></item><item><term>SQL_SC_UPD_CURSOR</term><description>The cursor position is used.</description></item><item><term>SQL_SC_UPD_KEY</term><description>The key(s) specified in the primary key are used.</description></item><item><term>SQL_SC_UPD_VALUE</term><description>The value(s) of all the columns in the row are used.</description></item></list></remarks>
    </member>
    <member name="M:VO.SQLSelect.Seek(XSharp.__Usual)">
      <summary>
        This method is provided to override the inherited functionality from the DataServer class, as it does not apply to SQLSelect.
      </summary>
    </member>
    <member name="M:VO.SQLSelect.SetPrimaryKey(XSharp.__Usual)">
      <summary>
        Specify a column to be used as a unique index in searched updates or deletes that require a key (i.e., SQLSelect:ScrollUpdateType = SQL_SC_UPD_KEY).
      </summary>
      <param name="uFieldPos">The name, number, or symbol representing the desired column.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        If SQLSelect:SetPrimaryKey() is passed a zero as an argument, all assigned columns are cleared.  You can also find the unique index columns by using the SQLListSpecialColumns class.
      </remarks>
    </member>
    <member name="M:VO.SQLSelect.SetStatementOption(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Change a statement option.
      </summary>
      <param name="fOption">
        The statement option to set (for example, SQL_MAX_LENGTH or SQL_NOSCAN).
      </param>
      <param name="uValue">The value of the statement option.</param>
      <remarks>
        <note type="tip">Refer to SQLSetStatementOption() in your ODBC documentation for a complete list of ODBC statement options that are available.</note>
      </remarks>
    </member>
    <member name="P:VO.SQLSelect.SimulateCursor">
      <summary>
        A constant, which describes the way the ODBC drivers tries to guarantee that update or delete statements only affect one single row.
      </summary>
      <value>A constant, which describes the way the ODBC drivers tries to guarantee that update or delete statements only affect one single row.</value>
      <remarks>
        One of the following constants, which describes the way the ODBC drivers tries to guarantee that update or delete statements only affect one single row.
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SQL_SC_NON_UNIQUE</term><description>
              The driver does not guarantee that simulated positioned update or delete statements will affect only one row;
              it is the application's responsibility to do so. If a statement affects more than one row, SQLExecute, SQLExecDirect, or SQLSetPos returns SQLSTATE 01001 (Cursor operation conflict).
            </description></item><item><term>SQL_SC_TRY_UNIQUE</term><description>
              The driver attempts to guarantee that simulated positioned update or delete statements affect only one row.
              The driver always executes such statements, even if they might affect more than one row, such as when there is no unique key. If a statement affects more than one row, SQLExecute, SQLExecDirect, or SQLSetPos returns SQLSTATE 01001 (Cursor operation conflict).
            </description></item><item><term>SQL_SC_UNIQUE</term><description>
              The driver guarantees that simulated positioned update or delete statements affect only one row.
              If the driver cannot guarantee this for a given statement, SQLExecDirect or SQLPrepare returns an error
            </description></item></list>
        The default value for this property can be set through the function SqlSetStmtSimulateCursor()
        <note type="tip">
          Please consult the documentation for the ODBC driver you are using to see the effects of this setting on the performance of your application.
        </note></remarks>
    </member>
    <member name="M:VO.SQLSelect.Skip(XSharp.__Usual)">
      <summary>
        Move forward or backward relative to the current row.  (Similar to the Skip() function).
      </summary>
      <param name="nRowCount">The number of rows to skip.  Positive numbers more forward; negative numbers move backward.  If omitted, +1 is assumed.</param>
      <returns>
        TRUE if successful; otherwise, FALSE (including if beginning or end of data was encountered).
      </returns>
      <remarks>
        <note type="tip">Not all data servers are capable of moving backward.  (See SQLConnection:ScrollCsr and SQLSelect:BufferData().)</note>
        Sends a NotifyRecordChange message if any move was made.
      </remarks>
    </member>
    <member name="P:VO.SQLSelect.SQLColumns">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="P:VO.SQLSelect.SqlData">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="P:VO.SQLSelect.SQLString">
      <summary>
        A string representing the SQL statement text.
      </summary>
      <value>A string representing the SQL statement text.</value>
      <remarks>
        A string representing the SQL statement text.
        <note type="tip">	The SQLSelect:SQLString assign will automatically close the cursor, if one is open.</note></remarks>
    </member>
    <member name="P:VO.SQLSelect.Statement">
      <summary>
        A SQL statement object.
      </summary>
      <value>A SQL statement object.</value>
      <remarks>
        A SQL statement object.
      </remarks>
    </member>
    <member name="P:VO.SQLSelect.StatementHandle">
      <summary>
        A numeric value representing the statement handle.
      </summary>
      <value>A numeric value representing the statement handle.</value>
    </member>
    <member name="P:VO.SQLSelect.Status">
      <summary>
        A hyperlabel object identifying the status after the last operation.
      </summary>
      <value>A hyperlabel object identifying the status after the last operation.</value>
      <remarks>
        A hyperlabel object identifying the status after the last operation.  If the last operation was successful, SQLSelect:Status returns NULL_OBJECT; if something went wrong, whether it raised an error condition or merely returned a failure code, SQLSelect:Status returns an informative hyperlabel object.
        By accessing the properties of this hyperlabel, you can retrieve not only a description but also context-sensitive help on the condition that was raised.
      </remarks>
      <example>
        The following examples invoke several Status access/assign methods of the data server:
        <code language="X#">
          oServer:Status:Caption
          oServer:Status:Description
          oServer:Status:HelpContext
        </code></example>
    </member>
    <member name="M:VO.SQLSelect.SuspendNotification">
      <summary>
        Suspend the broadcasting of Notify messages to the server's attached clients.
      </summary>
      <remarks>
        This method is useful, for example, when the server is moving through the database and the server is ultimately restored to its original position.  Therefore, there is no reason to notify the clients of the server of a change in position within the database.
        Note that SQLSelect:SuspendNotification() stacks its invocations.  Therefore, for each call to SQLSelect:SuspendNotification(), there needs to be a corresponding call SQLSelect:ResetNotification().
      </remarks>
    </member>
    <member name="P:VO.SQLSelect.TableName">
      <summary>
        A string representing the name of the table.
      </summary>
      <value>A string representing the name of the table.</value>
    </member>
    <member name="P:VO.SQLSelect.TimeStampAsDate">
      <summary>**Missing documentation **</summary>
      <value>**Missing documentation **</value>
    </member>
    <member name="M:VO.SQLSelect.Unlock(XSharp.__Usual)">
      <summary>
        This method is provided to override the inherited functionality from the DataServer class, as it does not apply to SQLSelect.
      </summary>
    </member>
    <member name="M:VO.SQLSelect.Update(XSharp.__Usual)">
      <summary>
        Update the current row or restore the original values of the row.
      </summary>
      <param name="lUpdate">TRUE updates the row; FALSE cancels the update and restores the original values of the row.  The default is TRUE.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        The type of SQL statement (searched or positioned) used by Update() is determined by the system automatically, unless set to cursor, key, or value, using SQLSelect:ScrollUpdateType.
        SQLSelect:Update() is invoked automatically if a field's value is changed (using SQLSelect:FieldPut()), and then a positioning operation (such as Skip()) was requested.
        When executed successfully, this method sends a NotifyRecordChange message to this data server's clients.
      </remarks>
    </member>
    <member name="P:VO.SQLSelect.Used">
      <summary>
        A logical value indicating whether the current query is active.
        It returns TRUE if the current query is active; otherwise, it returns FALSE.
      </summary>
      <value>
        A logical value indicating whether the current query is active.
        It returns TRUE if the current query is active; otherwise, it returns FALSE.
      </value>
    </member>
    <member name="T:VO.SQLStatement">
      <summary>
        Manage a SQL statement.
      </summary>
      <example>
        The following example demonstrates the use of the SQLStatement class:
        <code language="X#">
          FUNCTION CreateTable()
          LOCAL oStmt AS SQLStatement
          LOCAL oConn AS SQLConnection
          oConn := SQLConnection{"sample","dba","sql"}
          oStmt := SQLStatement{"Create table test ;
          (Col1 INT,Col2 Char(10))", oConn}
          IF !oStmt:Execute()
          oStmt:ErrInfo:ShowErrorMsg()
          ENDIF
          oStmt:FreeStmt(SQL_DROP)
          oConn:Disconnect()
        </code></example>
    </member>
    <member name="M:VO.SQLStatement.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SQLStatement object.
      </summary>
      <param name="cSQLStatement">The statement text.</param>
      <param name="oSQLConnection">The SQL connection indicating where the table can be found.  If not specified, the current default connection is used, if any; if none is defined, the system asks the end user to log on to a database.</param>
      <example>
        The following example executes the SQL statement:
        <code language="X#">
          oConn := SQLConnection{Source,UserId,Pswd}
          ACCEPT "Enter Simple SQL Statement:" TO cStatement
          oStmt := SQLStatement{cStatement,oConn}
          // Execute the statement...
          oStmt:Execute()
        </code></example>
    </member>
    <member name="M:VO.SQLStatement.Commit">
      <summary>
        Save the changes made since the last Commit().
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        The AutoCommit option may interfere with manual commits.  You may want to turn AutoCommit off, for example:
        <code language="X#">oStmt:Connection:SetConnectOption(SQL_AUTOCOMMIT, 0)</code></remarks>
    </member>
    <member name="P:VO.SQLStatement.Connection">
      <summary>
        The data source — a SQLConnection object — that this statement is connected to.
      </summary>
      <value>The data source — a SQLConnection object — that this statement is connected to.</value>
    </member>
    <member name="P:VO.SQLStatement.ErrInfo">
      <summary>
        An SQL statement error information (SQLErrorInfo) object.  Use the error flag of the returned object to determine if an error occurred.
      </summary>
      <value>An SQL statement error information (SQLErrorInfo) object.  Use the error flag of the returned object to determine if an error occurred.</value>
    </member>
    <member name="M:VO.SQLStatement.Execute(XSharp.__Usual)">
      <summary>
        Execute the statement.
      </summary>
      <param name="uParm">The array of parameters to execute., or a list of parameters to execute.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <example>
        The following example executes the SQL statement:
        <code language="X#">
          oStmt := SQLStatement{"Insert into employee;
          values(?, ?, ?, ?, ?, ?, ?, ?)",oConn}
          Execute(90012, 'Bill', 'wm', NULL, '911', NULL, 'PROF','4002')
          ?"Inserted!"
        </code></example>
    </member>
    <member name="M:VO.SQLStatement.FreeStmt(XSharp.__Usual)">
      <summary>
        Free the statement, according to the specified option.
      </summary>
      <param name="kOption">
        The option used when the statement is freed, specified by one of the following constants:
        Constant	Description
        SQL_CLOSE	Closes the cursor.
        SQL_DROP	Closes the cursor, unbinds and resets the parameters, and frees the statement.
        SQL_RESET_PARAMS	Resets the parameters.
        SQL_UNBIND	Unbinds the parameters.
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.SQLStatement.GetStatementOption(XSharp.__Usual)">
      <summary>
        Return current setting for a statement option or NIL, if an error occurred.
      </summary>
      <param name="kOption">The statement option (for example, SQL_BIND_TYPE, etc.).  Refer to SQLGetStmtOption() in your ODBC documentation for a complete list of ODBC connection options that are available.</param>
    </member>
    <member name="P:VO.SQLStatement.HyperLabel">
      <summary>
        A hyperlabel containing a description of the statement.
      </summary>
      <value>A hyperlabel containing a description of the statement.</value>
    </member>
    <member name="P:VO.SQLStatement.NativeSQL">
      <summary>
        A string containing the native text of the statement.

        Level 2
      </summary>
      <value>
        A string containing the native text of the statement.

        Level 2
      </value>
    </member>
    <member name="P:VO.SQLStatement.NumParameters">
      <summary>
        A numeric value containing the number of parameters in the statement.  A return value of -1 indicates an error.

        Level 2
      </summary>
      <value>
        A numeric value containing the number of parameters in the statement.  A return value of -1 indicates an error.

        Level 2
      </value>
    </member>
    <member name="P:VO.SQLStatement.NumSuccessfulRows">
      <summary>
        A numeric value containing the number of rows that were affected by the insert, update, or delete statement.  A return value of -1 indicates an error.
      </summary>
      <value>A numeric value containing the number of rows that were affected by the insert, update, or delete statement.  A return value of -1 indicates an error.</value>
    </member>
    <member name="M:VO.SQLStatement.Prepare">
      <summary>
        Prepare a statement.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        In most cases, there is no need to invoke SQLStatement:Prepare(), since it will be automatically invoked when needed, by other methods (for example, Execute()).
      </remarks>
    </member>
    <member name="P:VO.SQLStatement.PrepFlag">
      <summary>
        A logical value that indicates if the statement has been prepared.
      </summary>
      <value>A logical value that indicates if the statement has been prepared.</value>
    </member>
    <member name="M:VO.SQLStatement.RollBack">
      <summary>
        Undo the changes made since the last Commit().
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        The AutoCommit option may interfere with manual commits.  You may want to turn AutoCommit off, for example:
        <code language="X#">oStmt:Connection:SetConnectOption(SQL_AUTOCOMMIT, 0)</code></remarks>
    </member>
    <member name="M:VO.SQLStatement.SetStatementOption(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set current setting for a statement option.
      </summary>
      <param name="fOption">The statement option (for example, SQL_BIND_TYPE, etc.).  Refer to SQLSetStatement Option() in your ODBC documentation for a complete list of ODBC statement options that are available.</param>
      <param name="uValue">The value to set the statement option to.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.

        Level 1
      </returns>
    </member>
    <member name="P:VO.SQLStatement.SQLString">
      <summary>
        A string containing the text of the statement.
      </summary>
      <value>A string containing the text of the statement.</value>
      <remarks>
        A string containing the text of the statement.
        <note type="tip">	You can use the SQLSelect:SQLString assign to change the statement text.</note>
        Note:		If you assign a different SQLString and the statement is Preparedm it will become 'unprepared'.
      </remarks>
    </member>
    <member name="P:VO.SQLStatement.StatementHandle">
      <summary>
        A long integer representing the statement handle.
      </summary>
      <value>A long integer representing the statement handle.</value>
    </member>
    <member name="P:VO.SQLStatement.Status">
      <summary>
        A hyperlabel describing the error, or NULL_OBJECT if no error has occurred.
      </summary>
      <value>A hyperlabel describing the error, or NULL_OBJECT if no error has occurred.</value>
    </member>
    <member name="T:VO.SQLTable">
      <summary>
        Manage a table.
      </summary>
    </member>
    <member name="M:VO.SQLTable.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SQLTable object.
      </summary>
      <param name="symTableName">The symbol representing the name of the table.</param>
      <param name="aFieldList">The array of column names from the table to be included.  If not specified, all columns are included.</param>
      <param name="oSQLConnection">The SQL connection indicating where the table can be found.  If not specified, the current default connection is used, if any; if none is defined, the system asks the end user to log on to a database.</param>
    </member>
    <member name="M:VO.SQLTable.ClearRelation(XSharp.__Usual)">
      <summary>
        Clear a relation (or all relations) held by this server to other servers.
      </summary>
      <param name="nRelation">The number of the relation to clear.  If omitted, all relations are cleared.</param>
      <returns>
        TRUE if successful; otherwise, it returns FALSE.
      </returns>
    </member>
    <member name="M:VO.SQLTable.Condition(XSharp.__Usual)">
      <summary>
        Store any other condition that is appended to the end of the SQL statement.
      </summary>
      <param name="cOtherConditions">A string representing other conditions appended to the end of the SQL statement, such as 'GROUPBY' and 'HAVING'.</param>
    </member>
    <member name="M:VO.SQLTable.Notify(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Provide a method that is automatically called by the action methods of the server after completion of some significant event:  a column has changed, the server position has changed, some operation has been completed.  Its standard implementation is to broadcast the same notification to its attached clients.
      </summary>
      <param name="kNotification">The identification of the event, specified as one of the following constants:</param>
      <param name="uDescription">Used only with some notification types.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <include file="VOSDK_Classes.xml" path="doc/commonblocks/notify/*" />
      </remarks>
    </member>
    <member name="M:VO.SQLTable.OrderBy">
      <summary>
        Specify an ORDER BY clause.
      </summary>
      <param name="cOrder [, cOrder]">The list of strings comprising the ORDER BY clause.  The list will be concatenated, separated by commas.  The strings can contain any valid ORDER BY syntax that is accepted by the driver, including ASC and DESC keywords.</param>
      <example>
        The following example demonstrates the use of the SQLTable:OrderBy() method:
        <code language="X#">
          oTable := SQLTable{#Customer,,oConn}
          oTable:OrderBy("CustNum DESC")
          oTable:Seek()
        </code></example>
    </member>
    <member name="M:VO.SQLTable.Relation(XSharp.__Usual)">
      <summary>
        Return the linking expression of a specified relation.
      </summary>
      <param name="nRelation">The position of the desired relation in the list of current relations.  The relations are numbered according to the order in which they were defined with SetRelation().</param>
      <returns>
        A string containing the linking expression of the relation specified by &lt;nRelation&gt;.  If there is no relation set for &lt;nRelation&gt;, SQLTable:Relation() returns a NULL_STRING.
      </returns>
    </member>
    <member name="M:VO.SQLTable.Seek(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Search for a value based on a controlling search order.
      </summary>
      <param name="asymColumn">The array of columns that is to be searched for.</param>
      <param name="auValue">The array of values that is to be searched for of a type compatible with &lt;asymColumn&gt;.  The number of elements in this array and &lt;asymColumn&gt; must be identical.</param>
      <param name="symColumn">The column that is to be searched for.</param>
      <param name="uValue">The value that is to be searched for of a type compatible with &lt;symColumn&gt;.</param>
      <param name="lSoftSeek">Indicates whether the '&gt;=' operator is to used in the where clause (TRUE) or if the '=' operator is to be used (FALSE).</param>
      <returns>
        TRUE if successful; otherwise, FALSE. (whether this is because the server is incapable of searching, or because the value was not found).
      </returns>
      <remarks>
        SQLTable:Seek() dynamically rebuilds the select statement using the values in the WHERE clause.
      </remarks>
    </member>
    <member name="M:VO.SQLTable.SetRelation(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a relation from this server to the child server; standard database operations are restricted to those records that match the relation.
      </summary>
      <param name="oChild">The server attached to the child server must be specified as a SQLTable object.  If omitted, all relations for this server are removed (the recommended way of doing this is the ClearRelations() method).</param>
      <param name="uRelation">The field name representing the relation for the server.  An alias can be used for the field name.  (See the SQLSelect:FieldInfo() method to set an alias name).</param>
      <param name="cRelation">The array of field names representing the relation for the server.  The array can also contain complex relational operators (SQL_RELOP_AND, SQL_RELOP_OR, SQL_RELOP_NOT, SQL_RELOP_OPENP, SQL_RELOP_CLOSEP).</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        In the SQLTable class, SetRelation() functions identically to SetSelectiveRelation().  The relation is implemented as an extension to the WHERE clause.
        Sends a NotifyRecordChange message to the child server, if successful.
      </remarks>
      <example>
        The API can take these forms:
        <code language="X#">
          oSQLCustomer:SetRelation(oSQLOrders, {||_FIELD-&gt;CustNo},"CustNo")
          oSQLCustomer:SetRelation(oSQLOrders,#CustNo)
          oSQLCustomer:SetRelation(oSQLOrders, {#LastName,#Initial,#FirstName})
        </code>
        The following relation is equivalent to the set of orders where ORDER.LASTNAME=CUST.LASTNAME OR (ORDER.INITIAL=CUST.INITIAL AND ORDER.FIRSTNAME=CUST.FIRSTNAME):
        <code language="X#">
          oSQLCustomer:SetRelation(oSQLOrders,{#LastName,
          SQL_RELOP_OR,SQL_RELOP_OPENP,#Initial,
          SQL_RELOP_AND,#FirstName,SQL_RELOP_CLOSEP}
        </code></example>
    </member>
    <member name="M:VO.SQLTable.SetSelectiveRelation(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a selective relation from this server to the child server; standard database operations are restricted to those records that match the relation.
      </summary>
      <param name="oChild">The server attached to the child server must be specified as a SQLTable object.  If &lt;oSQLChild&gt; is omitted, all relations for this server are removed (the recommended way of doing this is the ClearRelations() method).</param>
      <param name="uRelation">The field name from this server.  An alias can be used for the field name.  (See the SQLSelect:FieldInfo() method to set an alias name).</param>
      <param name="cRelation">The array of field names representing the relation for the server.  The array can also contain complex relational operators (SQL_RELOP_AND, SQL_RELOP_OR, SQL_RELOP_NOT, SQL_RELOP_OPENP, SQL_RELOP_CLOSEP).</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Sends a NotifyRecordChange message to the child server, if successful.  This method is equivalent to the SetRelation() method.
      </remarks>
      <example>
        The API can take these forms:
        <code language="X#">
          oSQLCustomer:SetSelectiveRelation(oSQLOrders,;
          {||_FIELD-&gt;CustNo},"CustNo")
          oSQLCustomer:SetSelectiveRelation(oSQLOrders, CustNo)
          oSQLCustomer:SetSelectiveRelation(oSQLOrders,;
          {#LastName,#Initial,#FirstName})
        </code></example>
    </member>
    <member name="M:VO.SQLTable.Where">
      <summary>
        Specify a WHERE condition.  The where clause is built by concatenating these conditions with the AND operator.
      </summary>
      <param name="cCondition [, cCondition]">The list of conditions (for example, 'STATE = 'NY'', etc.).</param>
    </member>
    <member name="T:VO.SQLValue">
      <summary>
        Describe a SQL value.
      </summary>
    </member>
    <member name="M:VO.SQLValue.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SQLValue object.
      </summary>
      <param name="oHyperLabel">The hyperlabel for the SQL value.</param>
      <param name="oFieldSpec">The column specification for the SQL value.</param>
      <param name="nODBCType">The ODBC data type of the SQL value (for example, SQL_INTEGER, SQL_CHAR, SQL_FLOAT, etc.).  Refer to your ODBC documentation for a complete list of ODBC data types that are available.</param>
      <param name="nScale">The decimal precision of the SQL value.  This is specified only when the ODBC data type is numeric.</param>
      <param name="lNullable">Specify TRUE if the value can be NULL; otherwise, FALSE.</param>
    </member>
    <member name="F:VO.SQLValue.Nullable">
      <summary>
        A logical value representing whether the SQL value can be NULL.
      </summary>
      <value>A logical value representing whether the SQL value can be NULL.</value>
      <remarks>
        A logical value representing whether the SQL value can be NULL.  If it can be NULL, TRUE is returned; otherwise, FALSE.
      </remarks>
    </member>
    <member name="F:VO.SQLValue.ODBCType">
      <summary>
        A numeric value representing the ODBC type of the SQL value (such as, SQL_INTEGER, SQL_CHAR, SQL_FLOAT).
      </summary>
      <value>A numeric value representing the ODBC type of the SQL value (such as, SQL_INTEGER, SQL_CHAR, SQL_FLOAT).</value>
      <remarks>
        <note type="tip">Refer to your ODBC documentation for a complete list of ODBC data types that are available.</note>
      </remarks>
    </member>
    <member name="F:VO.SQLValue.Scale">
      <summary>
        A numeric value representing the number of decimal places in the SQL value.
      </summary>
      <value>A numeric value representing the number of decimal places in the SQL value.</value>
    </member>
    <member name="P:VO.SQLValue.UsualType">
      <summary>
        A string representing the X# usual type corresponding to the originating ODBC type (for example, SQL_INTEGER returns LONG).
      </summary>
      <value>A string representing the X# usual type corresponding to the originating ODBC type (for example, SQL_INTEGER returns LONG).</value>
      <remarks>
        A string representing the X# usual type corresponding to the originating ODBC type (for example, SQL_INTEGER returns LONG).
        <para>Possible ODBC types and their return values include:</para><list type="table"><listheader><term>ODBC Type</term><description>VO Type</description></listheader><item><term>SQL_INTEGER</term><description>LONG</description></item><item><term>SQL_SMALLINT</term><description>SHORTINT</description></item><item><term>SQL_FLOAT</term><description>FLOAT</description></item><item><term>SQL_REAL</term><description>FLOAT</description></item><item><term>SQL_DOUBLE</term><description>FLOAT</description></item><item><term>SQL_BIT</term><description>LOGIC</description></item><item><term>SQL_DATE</term><description>DATE</description></item><item><term>All other values</term><description>STRING</description></item></list><note type="tip">Refer to your ODBC documentation for a complete list of ODBC usual types that are available for that particular driver.</note></remarks>
    </member>
    <member name="T:VO.StandardColorDialog">
      <summary>
        Provide the base class from which all X# color dialog boxes are subclassed.
      </summary>
      <remarks>
        <br />Important!  StandardColorDialog is an abstract class and should not be used directly — instead, use one of its subclasses, which include PaletteDialog and SelectDialog.
      </remarks>
    </member>
    <member name="M:VO.StandardColorDialog.#ctor(XSharp.__Usual)">
      <summary>
        Construct a standard color dialog.
      </summary>
      <param name="oColor">Color object representing the default color to be displayed in the standard color dialog.  If omitted, the default color is black.</param>
    </member>
    <member name="M:VO.StandardColorDialog.Color">
      <summary>
        Return the color that the user selected.
      </summary>
    </member>
    <member name="M:VO.StandardColorDialog.Destroy">
      <summary>
        Provide a method to free memory resources allocated for a StandardColorDialog object and its derived objects.
      </summary>
      <remarks>
        StandardColorDialog:Destroy() frees resources for StandardColorDialog objects created explicitly in an application.  This method also takes care of resources allocated to derived classes and deallocates them in the necessary order.
      </remarks>
    </member>
    <member name="M:VO.StandardColorDialog.Show">
      <summary>
        Display a standard color dialog box.  To retrieve the value that the user selected, use the StandardColorDialog:Color() method.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="T:VO.StandardDialog">
      <summary>
        Provide the base class from which all X# standard dialog boxes are subclassed.
      </summary>
      <remarks>
        <br />Important!  StandardDialog is an abstract class and should not be used directly — instead, use one of its subclasses, which include OpenDialog, PaletteDialog, SaveAsDialog, SelectDialog, and StandardFontDialog.
      </remarks>
    </member>
    <member name="M:VO.StandardDialog.#ctor">
      <summary>
        Construct a standard dialog.
      </summary>
    </member>
    <member name="T:VO.StandardFileDialog">
      <summary>
        Provide the base class from which all X# standard file-oriented dialog boxes are subclassed.
      </summary>
      <remarks>
        <br />Important!  StandardFileDialog is an abstract class and should not be used directly — instead, use one of its subclasses, which include OpenDialog and SaveAsDialog.
      </remarks>
    </member>
    <member name="M:VO.StandardFileDialog.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a standard file dialog.
      </summary>
      <param name="uOwner">The window object that owns the standard file dialog.  If omitted, the dialog is not owned by any window.</param>
      <param name="cInitPath">String representing the initial file or directory to display in the dialog.  Use this, for example, to prompt the user with the current name of the file.  You can also specify wildcards, such as '*.TXT'.  The default is '*.*'.</param>
      <remarks>
        <note type="tip">
          If the :SetFilter( ) method is going to be used, cInitPath must be specified as "" because without this the filter will have no effect and the default of "*.*" will take effect so as to show all files.
        </note>
      </remarks>
    </member>
    <member name="P:VO.StandardFileDialog.Caption">
      <summary>
        Return or update the title displayed in the dialog window.
      </summary>
      <value>Return or update the title displayed in the dialog window.</value>
      <example>
        This example uses the Caption assign to set a title for an OpenFile dialog window:
        <code language="X#">
          METHOD MyOpen() CLASS StandardShellWindow
            LOCAL oOpenDialog AS OpenDialog
            oOpenDialog:=OpenDialog{SELF}
            oOpenDialog:Caption:="My OpenFile Dialog"
            oOpenDialog:Show()
        </code></example>
    </member>
    <member name="P:VO.StandardFileDialog.DefExt">
      <summary>
        Return or update the default file extension displayed in the dialog window.
      </summary>
      <value>Return or update the default file extension displayed in the dialog window.</value>
    </member>
    <member name="M:VO.StandardFileDialog.Destroy">
      <inheritdoc />
    </member>
    <member name="M:VO.StandardFileDialog.Dispatch(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Intercept messages normally handled by the dialog box procedure in COMMDLG.DLL.  Override this method to add your own custom processing.
      </summary>
      <param name="oEvt">An Event object.</param>
      <param name="hDlg">Handle of the dialog box.</param>
      <seealso cref="T:VO.Event" />
      <returns>
        A long integer indicating if the message is to be handled by the dialog box procedure in COMMDLG.DLL.  Returns a non zero value to indicate that no further processing of the message is required.  Returns a zero to continue processing for this message.
      </returns>
    </member>
    <member name="P:VO.StandardFileDialog.FileName">
      <summary>
        A string representing the name of the file which the user selected.  If the user cancels, the file name is NULL_STRING.
      </summary>
      <value>A string representing the name of the file which the user selected.  If the user cancels, the file name is NULL_STRING.</value>
      <example>
        This example displays an OpenFile dialog with a filter which is set to display only DBFs and index files.  Multiple file selection enables a user to select a DBF and an index.  A DBServer object for the selected file(s) is created and returned to the caller.
        <code language="X#">
          METHOD OpenDB() CLASS StandardShellWindow
            LOCAL oOpenDialog      AS OpenDialog
            LOCAL uFileName      AS USUAL
            LOCAL aoFileSpecs   := {}   AS ARRAY
            LOCAL lDone   := .F.   AS LOGIC
            LOCAL oDB      AS Dbserver
          DO WHILE !lDone
            oOpenDialog:=OpenDialog{SELF}
            oOpenDialog:Caption:="Open DBF and Index"
            oOpenDialog:SetFilter ({"CUST*.*","ORD*.*","DET*.*"},;
                                  {"Customers", "Orders", "Details"})
            oOpenDialog:SetStyle(OFN_ALLOWMULTISELECT + OFN_HIDEREADONLY)
            oOpenDialog:InitialDirectory := "C:\CAVO2x\SAMPLES\GSTUTOR"  
            oOpenDialog:Show()
            uFileName := oOpenDialog:FileName
            IF IsArray(uFileName) .AND. ALen(uFileName) &gt; 2
               (TextBox{SELF,"File Selection Error",;
               "Too many files selected"+CRLF+;
               "Please select one DBF and one index"}):Show()
            ELSE
               lDone := .T.
            ENDIF
          ENDDO
            // Open the selected DBF and index file
            uFileName := oOpenDialog:FileName
            IF IsArray(uFileName)      // DBF and Index selected ?
               AEval(uFileName,{ | cFileName | AADD( ;
                  aoFileSpecs, FileSpec{cFileName} ) } )
               IF aoFileSpecs[1]:Extension != ".DBF"
                  aoFileSpecs[1]:= ArraySwap(aoFileSpecs, ;
                                 2, aoFileSpecs[1])
               ENDIF
               RDDSetDefault("DBF"+SUBSTR(aoFileSpecs[2]:;
                     Extension, 2, 3) )
               oDB := DBServer{aoFileSpecs[1]}
               oDB:SetIndex(aoFileSpecs[2])
            ELSEIF LOGIC(_CAST, uFileName)      // Anything selected at all?
               AADD(aoFileSpecs,FileSpec{uFileName})
               oDB := DBServer{aoFileSpecs[1]}
            ENDIF
          RETURN oDB
        </code></example>
    </member>
    <member name="P:VO.StandardFileDialog.FilterIndex">
      <summary>
        A string representing the index of the effective filter.
      </summary>
      <value>A string representing the index of the effective filter.</value>
    </member>
    <member name="M:VO.StandardFileDialog.help">
      <summary>
        Provide a means of displaying help when the HELP button is pressed.  The HELP push button will be displayed if the SetStyle(OFN_SHOWHELP) message has been sent to the dialog object.
      </summary>
      <returns>
        A long integer indicating if  the message is to be handled by the dialog box procedure in COMMDLG.DLL.  The method returns a non zero value to indicate that no further processing of the message is required.  It returns a zero to continue processing for this message.
      </returns>
      <remarks>
        <note type="tip">If &lt;oStandardFileDialog&gt;:SetStyle(OFN_SHOWHELP) is used, a "Help" pushbutton is created on the dialog box.  A &lt;oStandardFileDialog&gt;:Help() method needs to be created to process the event associated with a user clicking on the "Help" button.</note>
      </remarks>
    </member>
    <member name="P:VO.StandardFileDialog.InitialDirectory">
      <summary>
        Set the initial directory for the dialog window.  The tree control will be initially positioned accordingly.
      </summary>
      <value>Set the initial directory for the dialog window.  The tree control will be initially positioned accordingly.</value>
      <example>
        This example sets the initial directory to "C:\CAVO2x\SAMPLES":
        <code language="X#">
          METHOD MyOpen() CLASS StandardShellWindow
            LOCAL oOpenDialog AS OpenDialog
            oOpenDialog := OpenDialog{SELF}
            oOpenDialog:InitialDirectory := "C:\CAVO2x\SAMPLES"
            oOpenDialog:Show()
        </code></example>
    </member>
    <member name="P:VO.StandardFileDialog.NoPlacesBar">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.StandardFileDialog.ReadOnly">
      <summary>
        A logical value indicating that the file's read-only attribute is set.
      </summary>
      <value>A logical value indicating that the file's read-only attribute is set.</value>
    </member>
    <member name="M:VO.StandardFileDialog.SetFilter(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set single or multiple filters and descriptions for the standard dialogs.  If multiple filters are specified, a filter index may also be specified.
      </summary>
      <param name="uFilter">An array of filter strings.  Grouped filters within a string must be delimited by semicolons or 
        a single filter string.  Grouped filters within a string must be delimited by semicolons..</param>
      <param name="uFilterDesc">An array of filter descriptions.</param>
      <param name="nIndex">A number specifying the initial filter in use if multiple filters are in effect.</param>
      <remarks>
        The standard dialog windows for the OpenFile and SaveAs dialogs may be customized by specifying one or more file name filters and their descriptions.  The filters are used as a mask for file names displayed in the list.  Each filter string may be composed of several filters delimited by semicolons.  If multiple filters have been set, an index may be specified, which in turn specifies the initial filter displayed.
        <note type="tip">
          In the above example, the second parameter to the class has been specified as "" because without this the filter will have no effect and the default of "*.*" will take effect so as to show all files.
        </note></remarks>
      <example>
        This example sets multiple filters for an OpenFile dialog.  Some of the filter strings specify groups of filters:
        <code language="X#">
          METHOD MyOpen() CLASS StandardShellWindow
          LOCAL oOpenDialog AS OpenDialog
          oOpenDialog:= OpenDialog{SELF, ""}
          oOpenDialog:Caption:="Multiple Filters Test"
          oOpenDialog:SetFilter (	{"*.WRI;*.TXT", "*.PRG;*.CXX;*.C", "*.INI"},;
          {"Doc", "Program Source", "INI Files"},2)
          // The index may also be set independently:
          // oOpenDialog:SetFilter(,,2)
          oOpenDialog:InitialDirectory := "C:\CAVO28\Bin\"
          oOpenDialog:Show()
        </code></example>
    </member>
    <member name="M:VO.StandardFileDialog.SetStyle(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the style for the dialog window.
      </summary>
      <param name="kStyle">The capability to be queried, specified by a Windows API OpenFileName flag constant (for example, OFN_ALLOWMULTISELECT).</param>
      <param name="lOnOff">A logical value that specifies whether the style setting is turned on or off.  A value of TRUE means that the style setting is turned on; a value of FALSE means that it is set off.  The default is TRUE.</param>
      <remarks>
        The style of the dialog windows for the OpenFile and SaveAs dialogs may be customize through the use of the SetStyle() method.  Refer to the Windows API constants documented in the Microsoft Win32 Software Development Kit.
      </remarks>
      <example>
        This example removes the ReadOnly check box from the dialog window, allows multiple file selection and retains current directory setting in effect prior to the dialog:
        <code language="X#">
          METHOD MyOpen() CLASS StandardShellWindow
            LOCAL oOpenDialog AS OpenDialog
            oOpenDialog:=OpenDialog{SELF}
            oOpenDialog:SetStyle(OFN_ALLOWMULTISELECT)
            oOpenDialog:SetStyle(OFN_NOCHANGEDIR)
            oOpenDialog:SetStyle(OFN_HIDEREADONLY)
            oOpenDialog:Show()
        </code><note type="tip">If &lt;oStandardFileDialog&gt;:SetStyle(OFN_SHOWHELP) is used, a "Help" push button is created on the dialog box.  A &lt;oStandardFileDialog&gt;:Help() method needs to be created to process the event associated with a user clicking on the "Help" button.</note></example>
    </member>
    <member name="M:VO.StandardFileDialog.SetStyleEx(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the Exstyle for the dialog window.
      </summary>
      <param name="kStyle">The capability to be queried, specified by a Windows API OpenFileName flag constant (for example, OFN_ALLOWMULTISELECT).</param>
      <param name="lOnOff">A logical value that specifies whether the style setting is turned on or off.  A value of TRUE means that the style setting is turned on; a value of FALSE means that it is set off.  The default is TRUE.</param>
    </member>
    <member name="M:VO.StandardFileDialog.Show">
      <summary>
        Display a standard file dialog box.  To retrieve the value that the user selected, use the StandardFileDialog:FileName property.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="T:VO.StandardFolderDialog">
      <summary>
        Encapsulate a standard folder dialog.
      </summary>
      <remarks>
        The standard folder dialog allows the user to select a folder or directory interactively.
      </remarks>
    </member>
    <member name="M:VO.StandardFolderDialog.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a standard folder dialog.
      </summary>
      <param name="oOwner">The window that owns the standard folder dialog.</param>
      <param name="sCaption">The caption of the standard folder dialog.  The default is 'Browser Folder'.</param>
      <param name="sStartFolder">The starting folder for the browse.</param>
      <param name="kType">
        Any _ORed combination of the following constants:
        Returns only file system directories (default).
        Does not include network folders below the domain level.
        Returns only computers.
        Returns only printers.
        The browse dialog includes files and folders.
      </param>
      <remarks>
        The standard folder dialog allows the user to browse for directories, as well as for printers and computers.
      </remarks>
    </member>
    <member name="M:VO.StandardFolderDialog.DialogCallBack(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <exclude />
    </member>
    <member name="P:VO.StandardFolderDialog.FolderName">
      <summary>
        The name of the selected folder or directory (same as StandardFolderDialog:Result).
      </summary>
      <value>The name of the selected folder or directory (same as StandardFolderDialog:Result).</value>
    </member>
    <member name="P:VO.StandardFolderDialog.Result">
      <summary>
        The name of the selected folder or directory (same as StandardFolderDialog:FolderName).
      </summary>
      <value>The name of the selected folder or directory (same as StandardFolderDialog:FolderName).</value>
    </member>
    <member name="M:VO.StandardFolderDialog.Show">
      <summary>
        Display a standard folder dialog box.  To retrieve the value that the user selected, use the relevant method of the specific subclass.
      </summary>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        The item selected by the user can be retrieved with the StandardFolderDialog:Result property.
      </remarks>
    </member>
    <member name="T:VO.StandardFontDialog">
      <summary>
        Provide standard font dialog facilities.
      </summary>
    </member>
    <member name="M:VO.StandardFontDialog.#ctor(XSharp.__Usual)">
      <summary>
        Construct a standard font dialog.
      </summary>
      <param name="uOwner">A Window object which identifies the device (i.e., monitor) for which to create the font list.</param>
      <param name="oPrinter">A Printer object which identifies the device (i.e., printer) for which to create the font list.</param>
      <remarks>
        A StandardFontDialog object is created, with a list of fonts available for the specified device.
      </remarks>
    </member>
    <member name="M:VO.StandardFontDialog.EnableANSI(XSharp.__Usual)">
      <summary>
        Allow ANSI fonts to appear in the list of fonts in the standard font dialog.
      </summary>
      <param name="bOnOff">The logical value indicating whether ANSI fonts appear in the list of fonts.  TRUE is the default, if omitted or if the method is not called.</param>
    </member>
    <member name="M:VO.StandardFontDialog.EnableEffects(XSharp.__Usual)">
      <summary>
        Allow the ability to change font effects, such as underline, strikethrough, and color.
      </summary>
      <param name="bOnOff">The logical value indicating whether font effects can be modified through the standard font dialog.  TRUE is the default, if omitted or if the method is not called.</param>
      <remarks>
        When StandardFontDialog:EnableEffects() method is called, check boxes that allow the user to select the underline and strikethrough font attributes appear.  The combo box to allow the user to select the color of the text is also enabled.  The color that the user last selected is only evident after StandardFontDialog:EnableEffects(TRUE) is called.
      </remarks>
    </member>
    <member name="M:VO.StandardFontDialog.EnableFixedPitch(XSharp.__Usual)">
      <summary>
        Determine whether only fixed pitch fonts will be displayed in the list of fonts for the standard font dialog.
      </summary>
      <param name="bOnOff">Logical value indicating whether only fixed pitch fonts appear in the list of fonts.</param>
    </member>
    <member name="M:VO.StandardFontDialog.EnableTrueType(XSharp.__Usual)">
      <summary>
        Determine whether only true type fonts will be displayed in the list of fonts for the standard font dialog.
      </summary>
      <param name="bOnOff">Logical value indicating whether only true type fonts appear in the list of fonts.</param>
    </member>
    <member name="P:VO.StandardFontDialog.Flags">
      <summary>
        A Windows API style constant to be set for the standard font dialog window.
      </summary>
      <value>A Windows API style constant to be set for the standard font dialog window.</value>
      <remarks>
        <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for information on the available constants.</note>
      </remarks>
    </member>
    <member name="P:VO.StandardFontDialog.Font">
      <summary>
        The font that was last selected in the standard font dialog window.
      </summary>
      <value>The font that was last selected in the standard font dialog window.</value>
    </member>
    <member name="P:VO.StandardFontDialog.FontColor">
      <summary>
        The font color that was last selected in the standard font dialog window.  This is only evident after EnableEffects(TRUE) has been called.
      </summary>
      <value>The font color that was last selected in the standard font dialog window.  This is only evident after EnableEffects(TRUE) has been called.</value>
    </member>
    <member name="M:VO.StandardFontDialog.Show">
      <summary>
        Display a standard font dialog.  To retrieve the value that the user selected, use the StandardFontDialog:Font access.
      </summary>
      <returns>
        TRUE if user chooses a font, FALSE if the user presses CANCEL.
      </returns>
    </member>
    <member name="T:VO.StatusBar">
      <summary>
        Create a status bar for use in a window.
      </summary>
      <remarks>
        A status bar is the shallow bar that appears usually at the bottom of a window to provide status information to the user without taking up much screen "real-estate."  Visual Object's status bar class has methods to present the following kinds of information:
        Status messages (permanent or transient)
        Time
        Keyboard state (NumLock, CapsLock, ScrollLock, and Insert keys)
        Virtual memory available
        A screen coordinate reading
        The sequence in which you call the various Display… methods determines the left-to-right order in which the corresponding items appear upon the status bar.  Any transient status message overrides the StatusBar:PermanentText status message, but it times out after five seconds.
        <note type="tip">You never create a status bar yourself.  Instead, you ask the window to do it, by calling AppWindow:EnableStatusBar().  Once you pick up the status bar returned by that method, you can customize the status bar by invoking the various Display… methods of status bar.  Note that, except for the time display, the status bar items require you to refresh them.  For example, if you turn on the display of available virtual memory, you must call the StatusBar:RefreshMemoryDisplay() method whenever the application is about to embark on a "memory-hungry" task.  Because you never create status bars, you also never destroy them — the window does that itself.</note></remarks>
    </member>
    <member name="M:VO.StatusBar.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a status bar.
      </summary>
      <param name="oOwner">The window that owns the status bar.</param>
      <param name="xID">The unique ID of the control (between 1 and 8000).</param>
      <param name="oPoint">The origin of the control in canvas coordinates.</param>
      <param name="oDimension">The dimension of the control in canvas coordinates.</param>
    </member>
    <member name="M:VO.StatusBar.AddItem(XSharp.__Usual)">
      <summary>
        Add a new item to the status bar.
      </summary>
      <param name="oStatusBarItem">The new item to add to the status bar.</param>
    </member>
    <member name="P:VO.StatusBar.AsString">
      <summary>
        A string representing the most recent StatusBar:PermanentText status message,
      </summary>
      <value>A string representing the most recent StatusBar:PermanentText status message,</value>
      <remarks>
        A string representing the most recent StatusBar:PermanentText status message, even if the status bar currently displays a transient message.  If you disabled the message display, StatusBar:AsString returns NIL.
        The status bar does not wait for any transient message to time out.  If the message was supplied as a hyperlabel instead of a string, AsString extracts and returns the hyperlabel's description.
      </remarks>
    </member>
    <member name="P:VO.StatusBar.Background">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.
      </summary>
      <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.</value>
    </member>
    <member name="M:VO.StatusBar.ClearItems">
      <summary>
        Remove all of the status bar items.
      </summary>
    </member>
    <member name="P:VO.StatusBar.ControlID">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.
      </summary>
      <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.</value>
    </member>
    <member name="P:VO.StatusBar.ControlText">
      <summary>
        A string representing a message associated with a control to be displayed on the status bar.  This message takes priority over the StatusBar:PermanentText message.
      </summary>
      <value>A string representing a message associated with a control to be displayed on the status bar.  This message takes priority over the StatusBar:PermanentText message.</value>
    </member>
    <member name="M:VO.StatusBar.Create">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.StatusBar.Destroy">
      <summary>
        Provide a method to de-instantiate a StatusBar object.
      </summary>
      <remarks>
        This method can be used when a StatusBar object is no longer needed.  StatusBar:Destroy() de-instantiates the StatusBar object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.StatusBar.Disable">
      <summary>
        Disable a status bar (until a subsequent call to StatusBar:Enable()).
      </summary>
      <remarks>
        Disabled status bars are not active and, therefore, they do not send events to their owner windows.
      </remarks>
    </member>
    <member name="P:VO.StatusBar.DisabledKeyIndicatorColor">
      <summary>
        The Color object that the status bar uses to indicate that a key is disabled.  The default is gray.
      </summary>
      <value>The Color object that the status bar uses to indicate that a key is disabled.  The default is gray.</value>
    </member>
    <member name="M:VO.StatusBar.Dispatch(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.StatusBar.DisplayKeyboard">
      <summary>
        Enable the display of the keyboard state on the status bar.
      </summary>
      <remarks>
        The status bar refreshes the keyboard state itself, except for the insertion mode, which you must refresh by managing the StatusBar:InsertMode property.
        <note type="tip">You must call this method before calling StatusBar:Show().</note></remarks>
    </member>
    <member name="M:VO.StatusBar.DisplayMemory">
      <summary>
        Enable the display of the virtual memory available, on the status bar.  You must keep the display refreshed as necessary by calling StatusBar:RefreshMemoryDisplay().
      </summary>
    </member>
    <member name="M:VO.StatusBar.DisplayMessage">
      <summary>
        Enable the display of messages on the status bar.
      </summary>
    </member>
    <member name="M:VO.StatusBar.DisplayPosition">
      <summary>
        Enable the display of a coordinate pair on the status bar.
      </summary>
      <remarks>
        The pair is usually the mouse position, but you can supply any Pair object you like, such as a dimension or a point.  You must keep the display refreshed as necessary by assigning pairs to the status bar's Position pseudo-variable.
        <note type="tip">You must call this method before calling StatusBar:Show().</note></remarks>
    </member>
    <member name="M:VO.StatusBar.DisplayTime">
      <summary>
        Enable the digital clock display on the status bar.
      </summary>
    </member>
    <member name="M:VO.StatusBar.Enable">
      <summary>
        Enable a status bar that was previously disabled.
      </summary>
      <remarks>
        Enabling a status bar allows it to generate events and to send the events to its owner window when the user manipulates the status bar.  The dimming of disabled status bar is removed, and the status bar is restored to its normal appearance.
        By default, status bars are enabled until disabled, so there is no need to call this Enable() method unless StatusBar:Disable() was previously called.
      </remarks>
    </member>
    <member name="P:VO.StatusBar.ErrorMessageBeep">
      <summary>
        A logical value determining whether a beep is sounded by the error system when an error occurs.  TRUE turns beeping on; FALSE turns it off.
      </summary>
      <value>A logical value determining whether a beep is sounded by the error system when an error occurs.  TRUE turns beeping on; FALSE turns it off.</value>
    </member>
    <member name="P:VO.StatusBar.ErrorText">
      <summary>
        A string representing an error message to be displayed on the status bar.  This message takes priority over the StatusBar:ControlText and StatusBar:PermanentText messages.
      </summary>
      <value>A string representing an error message to be displayed on the status bar.  This message takes priority over the StatusBar:ControlText and StatusBar:PermanentText messages.</value>
    </member>
    <member name="M:VO.StatusBar.GetItem(XSharp.__Symbol)">
      <summary>**Missing documentation **</summary>
      <param name="symItemName">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.StatusBar.GetItemBoundingBox(XSharp.__Usual)">
      <summary>
        Get the bounding box that describes the area of a status bar item.
      </summary>
      <param name="symItemName">The symbolic name of the status bar item whose bounding box will be returned.  If omitted, the bounding box of the main message area will be returned.</param>
      <returns>
        The bounding box for the specified item.
      </returns>
    </member>
    <member name="M:VO.StatusBar.GetTipText(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="symItemName">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.StatusBar.Handle(XSharp.__Usual)">
      <summary>
        Return the handle for a status bar.
      </summary>
      <param name="nHandleType">The type of handle required.  0 is the only supported option and is the default if &lt;nHandleType&gt; is omitted.</param>
      <returns>
        A handle to the "window" (control), describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the window, which can then be used by Windows API calls.
      </remarks>
    </member>
    <member name="M:VO.StatusBar.Hide">
      <summary>
        Hide a status bar so it is not visible (until a subsequent call to StatusBar:Show()).
      </summary>
    </member>
    <member name="P:VO.StatusBar.HorizontalBorder">
      <summary>
        A numeric value representing the width of the horizontal border between the top or bottom edge of the status bar and its items.
      </summary>
      <value>A numeric value representing the width of the horizontal border between the top or bottom edge of the status bar and its items.</value>
    </member>
    <member name="P:VO.StatusBar.InsertMode">
      <summary>
        A logical value indicating whether the program is in insert mode.
      </summary>
      <value>A logical value indicating whether the program is in insert mode.</value>
      <remarks>
        A logical value indicating whether the program is in insert mode.  If insert mode is not enabled, NIL is returned.
        <note type="tip">The status bar figures out for itself the state of the other keys, such as CapsLock, but it has no automatic way of determining whether the program is in insertion mode or overwrite mode.  Only the program knows that, and the program must set it.</note></remarks>
    </member>
    <member name="P:VO.StatusBar.ItemBorder">
      <summary>
        A numeric value representing the width of the borders between the status bar items.
      </summary>
      <value>A numeric value representing the width of the borders between the status bar items.</value>
    </member>
    <member name="P:VO.StatusBar.KeyIndicatorColor">
      <summary>
        The Color object that the status bar uses to indicate to the user that a key is in the on state.
      </summary>
      <value>The Color object that the status bar uses to indicate to the user that a key is in the on state.</value>
      <remarks>
        The Color object that the status bar uses to indicate to the user that a key is in the on state.  For example, the imitation LEDs on the buttons that represent the state of the keyboard, such as NumLock.  The default is green.
        <note type="tip">If you change StatusBar:KeyIndicatorColor, you must then invoke the StatusBar:Show() method for the change to take effect.</note></remarks>
    </member>
    <member name="P:VO.StatusBar.Length">
      <summary>
        A numeric value representing the number of characters in the message to be displayed on the status bar.
      </summary>
      <value>A numeric value representing the number of characters in the message to be displayed on the status bar.</value>
    </member>
    <member name="P:VO.StatusBar.MenuText">
      <summary>
        A string representing a message associated with a menu selection to be displayed on the status bar.
      </summary>
      <value>A string representing a message associated with a menu selection to be displayed on the status bar.</value>
      <remarks>
        A string representing a message associated with a menu selection to be displayed on the status bar.  This message takes priority over any other status bar messages, including StatusBar:ControlText, StatusBar:ErrorText, or StatusBar:PermanentText.
      </remarks>
    </member>
    <member name="M:VO.StatusBar.ODDrawItem(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oEvent">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.StatusBar.Origin">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.
      </summary>
      <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.</value>
    </member>
    <member name="P:VO.StatusBar.Owner">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.
      </summary>
      <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.</value>
    </member>
    <member name="P:VO.StatusBar.PermanentText">
      <summary>
        A string representing the default message to be displayed on the status bar
      </summary>
      <value>A string representing the default message to be displayed on the status bar</value>
      <remarks>
        A string representing the default message to be displayed on the status bar; it is stored whenever a higher priority message (including StatusBar:ControlText, StatusBar:ErrorText, or StatusBar:MenuText) takes precedence and redisplayed when no other messages take priority.
      </remarks>
    </member>
    <member name="P:VO.StatusBar.Position">
      <summary>
        A pair representing the coordinates to be shown in the status bar.  The units you choose for coordinates are arbitrary.
      </summary>
      <value>A pair representing the coordinates to be shown in the status bar.  The units you choose for coordinates are arbitrary.</value>
    </member>
    <member name="M:VO.StatusBar.RefreshMemoryDisplay(XSharp.__Usual)">
      <summary>
        Cause the status bar to bring the display of virtual memory up-to-date.
      </summary>
      <param name="kMemoryType">** missing parameter documentation **</param>
      <remarks>
        The status bar gets this information from the operating system.  If you disabled the memory display, nothing happens.
      </remarks>
    </member>
    <member name="M:VO.StatusBar.SetFocus">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.
      </summary>
    </member>
    <member name="M:VO.StatusBar.SetIcon(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oIcon">** missing parameter documentation **</param>
      <param name="symItemName">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.StatusBar.setmessage(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Display a string in the main message area of the status bar.
      </summary>
      <param name="cMessage">The message to be displayed in the status bar.</param>
      <param name="nMode">The type of message to be displayed in the status bar.</param>
    </member>
    <member name="M:VO.StatusBar.SetPair(XSharp.__Usual)">
      <summary>
        Set a pair representing the coordinates to be shown in the status bar.
      </summary>
      <param name="oPoint">The point to set.</param>
      <remarks>
        The units you choose for coordinates are arbitrary.
      </remarks>
    </member>
    <member name="M:VO.StatusBar.SetText(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set text for a status bar item.
      </summary>
      <param name="cText">The text to set.</param>
      <param name="symItemName">The name of the status bar item.</param>
    </member>
    <member name="M:VO.StatusBar.SetTipText(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="cTipText">** missing parameter documentation **</param>
      <param name="symItemName">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.StatusBar.SetValue(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="uValue">** missing parameter documentation **</param>
      <param name="symItemName">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.StatusBar.Show">
      <summary>
        Display a status bar so it is visible.
      </summary>
      <remarks>
        StatusBar:Show() is also usually called to redisplay a status bar that was hidden with the StatusBar:Hide() method.
      </remarks>
    </member>
    <member name="P:VO.StatusBar.Size">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.
      </summary>
      <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.</value>
    </member>
    <member name="P:VO.StatusBar.TextValue">
      <summary>
        A string representing the value held in the status bar.
      </summary>
      <value>A string representing the value held in the status bar.</value>
      <remarks>
        A string representing the value held in the status bar.  For example, the value can be "Jones" or "$14,683.00".
        Note that the string is formatted according to the picture clause help in the field specification of the status bar; in turn, status bars linked to a data server inherit the field specification — and hence picture — from the field of the server.
      </remarks>
    </member>
    <member name="P:VO.StatusBar.TimeOut">
      <summary>
        A numeric value indicating the number of seconds a nonpermanent message is displayed on the status bar.
      </summary>
      <value>A numeric value indicating the number of seconds a nonpermanent message is displayed on the status bar.</value>
    </member>
    <member name="M:VO.StatusBar.Timer">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.StatusBar.Transient">
      <summary>
        A string representing an error message to be displayed on the status bar.  This message takes priority over the StatusBar:ControlText and StatusBar:PermanentText messages.
      </summary>
      <value>A string representing an error message to be displayed on the status bar.  This message takes priority over the StatusBar:ControlText and StatusBar:PermanentText messages.</value>
    </member>
    <member name="P:VO.StatusBar.VerticalBorder">
      <summary>
        A numeric value representing the height of the vertical border between the left or right edge of the status bar and its items.
      </summary>
      <value>A numeric value representing the height of the vertical border between the left or right edge of the status bar and its items.</value>
    </member>
    <member name="T:VO.StatusBarItem">
      <summary>
        Create a status bar item.
      </summary>
      <remarks>
        A status bar item is an object that can be added to a status bar.  It is displayed as a rectangular section of the status bar and can be used to display text or graphical information.  Simple status bar items that display messages, pairs of numbers, keyboard states, and memory information can be added automatically by calling the appropriate methods of the StatusBar class; this class is designed to allow the addition of user-defined items.
      </remarks>
    </member>
    <member name="M:VO.StatusBarItem.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a status bar item.
      </summary>
      <param name="symName">Name of the StatusbarItem</param>
      <param name="nWidth">Width of the StatusbarItem in pixels</param>
      <param name="kStyle">
        Style of the StatusbarItem
        One of:
        SBITEMFLAT
        SBITEMRAISED
        SBITEMSUNKEN
      </param>
      <param name="oIcon">Optional Icon object to display</param>
    </member>
    <member name="P:VO.StatusBarItem.Icon">
      <summary>
        The icon of the status bar item.
      </summary>
      <value>The icon of the status bar item.</value>
    </member>
    <member name="P:VO.StatusBarItem.NameSym">
      <summary>
        The symbolic name of the status bar item.
      </summary>
      <value>The symbolic name of the status bar item.</value>
    </member>
    <member name="P:VO.StatusBarItem.Style">
      <summary>
        A constant determining the three-dimensional appearance of the status bar item:
      </summary>
      <value>A constant determining the three-dimensional appearance of the status bar item:</value>
      <remarks>
        One of the following constants determining the three-dimensional appearance of the status bar item:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SBITEMFLAT</term><description>Creates a status bar item with a flat appearance</description></item><item><term>SBITEMSUNKEN</term><description>Creates a status bar item with a sunken appearance</description></item><item><term>SBITEMRAISED</term><description>Creates a status bar item with a raised appearance</description></item></list></remarks>
    </member>
    <member name="P:VO.StatusBarItem.Value">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.StatusBarItem.Width">
      <summary>
        A numeric value that represents the width of the status bar item.
      </summary>
      <value>A numeric value that represents the width of the status bar item.</value>
    </member>
    <member name="T:VO.StatusBarKeyItem">
      <summary>
        Create a status bar item to display CapsLock, Numlock and Insert keys
      </summary>
    </member>
    <member name="M:VO.StatusBarKeyItem.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a status bar item.
      </summary>
      <param name="symName">Name of the StatusbarItem</param>
      <param name="nWidth">Width of the StatusbarItem in pixels</param>
      <param name="kStyle">
        Style of the StatusbarItem
        One of:
        SBITEMFLAT
        SBITEMRAISED
        SBITEMSUNKEN
      </param>
      <param name="oIcon">Optional Icon object to display</param>
    </member>
    <member name="M:VO.StatusBarKeyItem.ODDrawItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="oEvent">** missing parameter documentation **</param>
      <param name="oStatusBar">** missing parameter documentation **</param>
    </member>
    <member name="T:VO.StdSocket">
      <exclude />
    </member>
    <member name="M:VO.StdSocket.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.StdSocket.InternetStatus(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="T:VO.Stream">
      <summary>
        A class representing streams in the ActiveXControl:StreamIn() and ActiveXControl:StreamOut() methods.
      </summary>
      <remarks>
        <note type="tip">Stream objects are automatically instantiated by the OLE runtime.</note>
        A Stream object is automatically instantiated by the OLE runtime system and passed as a parameter to the ActiveXControl:StreamIn() and ActiveXControl:StreamOut() methods.  The Stream object wraps an OLE stream, allowing you to write to and read from the stream.
      </remarks>
    </member>
    <member name="M:VO.Stream.#ctor">
      <summary>
        Construct a Stream object instance.
      </summary>
      <param name="pStream">Pointer to an OLE stream.</param>
    </member>
    <member name="M:VO.Stream.Read">
      <summary>
        Read the next USUAL value from a stream.
      </summary>
      <returns>
        The next value (type USUAL) in the stream.  The USUAL can hold any X# data, including nested arrays but not objects.
      </returns>
      <remarks>
        Stream:Read() can be used in ActiveXControl:StreamIn handlers to read USUAL values from the stream.  You can use subsequent calls to Stream:Read() to read in as many values as have been saved to the stream by previous calls to Stream:Write().  Stream:Read() and Stream:Write() operations should be balanced and in the same order.
        For further details, see Creating OLE Servers in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
      </remarks>
      <example>
        This is from the StreamIn() method of the Calendar ActiveX sample that is accessible from the Samples tab page of the Application Gallery:
        <code language="X#">
          method StreamIn(oStream) class CalOCX
          local u as usual
          u := oStream:Read()
          if IsDate(u)
           curDate := u
          endif
        </code></example>
    </member>
    <member name="M:VO.Stream.Write">
      <summary>
        Write a USUAL value into a stream.
      </summary>
      <param name="uValue">The USUAL value, which is written into the stream.</param>
      <returns>
        TRUE, if the write operation was successful; otherwise, FALSE.
      </returns>
      <remarks>
        Stream:Write() can be used in ActiveXControl:StreamOut handlers to write USUAL values into the stream.  You can use subsequent calls to Stream:Write() to write multiple values subsequently.  Stream:Read() and Stream:Write() operations should be balanced and in the same order.
        For further details, see Creating OLE Servers in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
      </remarks>
      <example>
        This is from the StreamOut() method of the Calendar ActiveX sample that is accessible from the Samples tab page of the Application Gallery:
        <code language="X#">
          method StreamOut(oStream) class CalOCX
          oStream:Write(oOCXWindow:CurrentDate)
          return
        </code></example>
    </member>
    <member name="T:VO.StringFS">
      <summary>
        Create a string field specification, which holds string data type information.
      </summary>
    </member>
    <member name="M:VO.StringFS.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a string field specification.
      </summary>
      <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new string field specification.</param>
      <param name="uLength">The length of the field.  If not specified, the default is 10.</param>
    </member>
    <member name="T:VO.strucPictureFuncFlags">
      <exclude />
    </member>
    <member name="T:VO.SysLink">
      <summary>
        Create a SysLink control.
      </summary>
      <remarks>
        The SysLink control provides hyperlink capabilities when running under XP visual themes.
        <note type="tip">
          This control is dependent on version 6 or greater of the COMCTL32.DLL and WinXP Theams.
          When XP themes are not available, such as when running on Windows 2000 or running the application on XP in "classic" mode, the SysLink control displays the full text assigned to it - any hyperlink references are included as literal text. It is suggested that the programmer should test for XP theme support, see IsThemeEnabled(), to determine what text should be assigned to the SysLink control
          For this reason it is recomended that it is called in this way -
          <code language="X#">
            IF IsThemeEnabled()
            s := "Visit &lt;A HREF="+_chr(34)+;
            "http://www.grafxsoft.com"+_chr(34)+"&gt;GrafX&lt;/A&gt; and &lt;A HREF="+;
            _CHR(34)+"http://www.cavo.com"+_Chr(34)+"&gt;X#&lt;/A&gt; on the web!"
            ELSE
            s := "Visit http://www.grafxsoft.com and http://www.cavo.com"+;
            " on the web!"
            ENDIF
          </code>
          The difference between the HyperLink and the SysLink classes is in the way that the text is used.
          In a HyperLink control, ALL of the text is passed as the hyperlink where as in the SysLink control you can mix display text and hyperlink text.
        </note></remarks>
      <example>
        For an example of this , see the Help About screen in the Standard MDI Application.
      </example>
    </member>
    <member name="M:VO.SysLink.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a SysLink control.
        <br />Important!  This method is used internally by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oOwner">The window that owns the SysLink control.</param>
      <param name="xID">The unique ID between 1 and 8000 of the SysLink control.</param>
      <param name="oPoint">The Point object that locates the control.</param>
      <param name="oDimension">The Dimension that sets the size of the control.</param>
      <param name="cText">The text (including HTML tags) to be displayed.</param>
      <param name="lDataAware">TRUE sets the control to be Data-Aware, FALSE sets this off.  The Default is TRUE.</param>
    </member>
    <member name="T:VO.SysLinkSelectEvent">
      <summary>
        Provide information about an event that gets generated when a SysLink control is selected
      </summary>
    </member>
    <member name="M:VO.SysLinkSelectEvent.#ctor(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.SysLinkSelectEvent.ID">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.SysLinkSelectEvent.LinkIndex">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.SysLinkSelectEvent.URL">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.SystemMenu">
      <summary>
        Create a system menu.
      </summary>
      <remarks>
        System menus are used to provide a series of standard operations, such as moving, closing, and resizing windows.  Different GUI conventions dictate what items should be added to the system menu.
        An application window can have a system menu by calling AppWindow:EnableSystemMenu().  Using the Window:MenuCommand() event handler, the system menu can be manipulated in the same way as a menu.
        To access a window's system menu, you must first enable the system menu with a call to AppWindow:EnableSystemMenu().  You can then use the system menu it returns.
      </remarks>
      <example>
        The following example adds an About item to a system menu:
        <code language="X#">
          oSysMenu := oMyWin:EnableSystemMenu()
          oSysMenu:AppendItem(MENUSEPARATOR)
          oSysMenu:AppendItem(IDM_ABOUT,"About...")
          oSysMenu:RegisterItem(IDM_ABOUT,HyperLabel{#About})
        </code></example>
    </member>
    <member name="M:VO.SystemMenu.#ctor(XSharp.__Usual)">
      <summary>
        Construct a system menu.
        <br />Important!  This method is used internally by X#.  Normally, it should not be called in your application code.  To create a system menu object, store the return value of the AppWindow:EnableSystemMenu() method.
      </summary>
      <param name="oOwner">
        The window that owns the system menu.
        The resource ID of the system menu.  If not specified, the system creates an empty menu.
      </param>
    </member>
    <member name="M:VO.SystemMenu.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.TabControl">
      <summary>
        Create a tab control.
      </summary>
      <remarks>
        A tab control is a control that manages multiple pages (modeless dialog windows) and can be compared to dividers in a notebook.  By using a tab control, an application can define multiple pages for the same area of a dialog window or data window.  Each page is displayed when the user selects the corresponding tab.
      </remarks>
    </member>
    <member name="M:VO.TabControl.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a tab control.
      </summary>
      <param name="oOwner">The window that owns the tab control.</param>
      <param name="xID">The unique ID between 1 and 8000 of the tab control.</param>
      <param name="nResourceID">The resource ID of the tab control.</param>
      <param name="oPoint">The origin of the tab control, in canvas coordinates.</param>
      <param name="oDimension">The dimension of the tab control, in canvas coordinates.</param>
      <param name="kStyle">The style of the tab control.</param>
    </member>
    <member name="M:VO.TabControl.AddTipText(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Add a string to be displayed as tip text for a tab.
      </summary>
      <param name="symTabName">The symbolic name of the tab to which you want to add the text.</param>
      <param name="cText">The text to add.</param>
    </member>
    <member name="M:VO.TabControl.AppendTab(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Add a new tab and tab page at the end of a tab control.
      </summary>
      <param name="symTabName">The symbolic name of the new tab.</param>
      <param name="cCaption">The caption of the new tab.</param>
      <param name="xPage">The modeless dialog window to act as the page for this tab or the symbolic name of the class to use for the tab.</param>
      <param name="nImage">The index of the image in the tab control's image list to display in the new tab.</param>
      <returns>
        TRUE if the tab was added successfully; otherwise FALSE.
      </returns>
    </member>
    <member name="P:VO.TabControl.AutoSize">
      <summary>
        A logical value which lets the tab control automatically resize itself to accommodate the size of largest tab page. The default is FALSE.
      </summary>
      <value>A logical value which lets the tab control automatically resize itself to accommodate the size of largest tab page. The default is FALSE.</value>
    </member>
    <member name="M:VO.TabControl.ChangeTipText(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Change the current tip text for a tab.
      </summary>
      <param name="symTabName">The symbolic name of the tab whose tip text you want to change.</param>
      <param name="cText">The text to replace the current tip text.</param>
      <returns>
        TRUE if the text could be changed; otherwise FALSE.
      </returns>
    </member>
    <member name="M:VO.TabControl.CreatePageInstance(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Dynamically create a tab page.
        Note: this is a callback method that is called automatically by X#
      </summary>
      <param name="symPageClass">Classname of the page to create</param>
      <param name="symTabName">Symbolic Name of the tab to create</param>
      <returns>
        New Page Object
      </returns>
    </member>
    <member name="P:VO.TabControl.CurrentPage">
      <summary>
        The currently displayed tab control page.
      </summary>
      <value>The currently displayed tab control page.</value>
    </member>
    <member name="M:VO.TabControl.DeleteAllTabs">
      <summary>
        Remove all the tabs and their corresponding pages in the tab control.
      </summary>
      <returns>
        TRUE if all tabs could be deleted; otherwise FALSE.
      </returns>
    </member>
    <member name="M:VO.TabControl.DeleteTab(XSharp.__Usual)">
      <summary>
        Remove a tab and page from the tab control.
      </summary>
      <param name="symTabName">The symbolic name of the tab to delete.</param>
      <returns>
        TRUE if the tab could be deleted; otherwise FALSE.
      </returns>
    </member>
    <member name="M:VO.TabControl.Destroy">
      <summary>
        Provide a method to de-instantiate a Tab Control object.
      </summary>
      <remarks>
        This method can be used when a Tab Control object is no longer needed.  Tab Control:Destroy() de-instantiates the Tab Control object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.TabControl.FocusNextPage">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.TabControl.FocusPreviousPage">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.TabControl.FocusTab(XSharp.__Symbol)">
      <summary>**Missing documentation **</summary>
      <param name="symTabName">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.TabControl.GetCaption(XSharp.__Usual)">
      <summary>
        Return the current caption for a tab.
      </summary>
      <param name="symTabName">The symbolic name of the tab whose caption you want to obtain.</param>
      <returns>
        The current caption of the specified tab.
      </returns>
    </member>
    <member name="M:VO.TabControl.GetPage(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="symPageName">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.TabControl.GetPageSymbol(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="uPageName">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.TabControl.GetTabBoundingBox(XSharp.__Usual)">
      <summary>
        Get the bounding box representing the area that a tab occupies.
      </summary>
      <param name="symTabName">The symbolic name of the tab whose bounding box you want to obtain.</param>
      <returns>
        The bounding box that the specified tab occupies.
      </returns>
    </member>
    <member name="M:VO.TabControl.GetTabImage(XSharp.__Usual)">
      <summary>
        Return the current image for a tab.
      </summary>
      <param name="symTabName">The symbolic name of the tab whose image you want to obtain.</param>
      <returns>
        The current image number of the specified tab.
      </returns>
    </member>
    <member name="M:VO.TabControl.GetTabPage(XSharp.__Usual)">
      <summary>
        Retrieve a specified tab page.
      </summary>
      <param name="xSymbolOrPosition">Specifies the tab page's symbol or the numeric position of the tab page.</param>
      <returns>
        The modeless dialog window object that represents the specified tab page.
      </returns>
    </member>
    <member name="M:VO.TabControl.GetTipText(XSharp.__Usual)">
      <summary>
        Return the current tip text for a tab.
      </summary>
      <param name="symTabName">The symbolic name of the tab whose tip text you want to obtain.</param>
      <returns>
        The current tip text of the specified tab.
      </returns>
    </member>
    <member name="M:VO.TabControl.Hide">
      <summary>
        To hide the current tab page.
      </summary>
    </member>
    <member name="P:VO.TabControl.ImageList">
      <summary>
        The image list for the tab control.
      </summary>
      <value>The image list for the tab control.</value>
    </member>
    <member name="M:VO.TabControl.InsertTab(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Insert a new tab and tab page at a particular position in the tab control.
      </summary>
      <param name="nPosition">The numeric position of the new tab.</param>
      <param name="symTabName">The symbolic name of the new tab.</param>
      <param name="cCaption">The caption of the new tab.</param>
      <param name="xPage">The modeless dialog window to act as the page for this tab or the symbolic name of the class to use for the tab.</param>
      <param name="nImage">The index of the image in the tab control's image list to display in the new tab.</param>
      <returns>
        TRUE if the tab was added successfully; otherwise FALSE.
      </returns>
    </member>
    <member name="M:VO.TabControl.IsTabPage(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="xSymbolOrPosition">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.TabControl.Move(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.TabControl.PadTabs(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Pad a tab's label and icon with empty space.
      </summary>
      <param name="dwWidth">The amount of horizontal padding (in pixels).</param>
      <param name="dwHeight">The amount of vertical padding (in pixels).</param>
    </member>
    <member name="P:VO.TabControl.Pages">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.TabControl.RemoveTabImage(XSharp.__Usual)">
      <summary>
        Remove an image from the tab control's image list.
      </summary>
      <param name="nImageIndex">The index in the tab control's image list of the image you want to remove.</param>
      <returns>
        TRUE if the image was removed; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.TabControl.RemoveTipText(XSharp.__Usual)">
      <summary>
        Remove the current tip text for a tab.
      </summary>
      <param name="symTabName">The symbolic name of the tab whose tip text you want to remove.</param>
      <returns>
        TRUE if the text could be removed; otherwise FALSE.
      </returns>
    </member>
    <member name="M:VO.TabControl.Resize(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.TabControl.RowCount">
      <summary>
        A numeric value representing the number of rows of tabs currently displayed in the tab control.
      </summary>
      <value>A numeric value representing the number of rows of tabs currently displayed in the tab control.</value>
    </member>
    <member name="P:VO.TabControl.SelectedTab">
      <summary>
        A symbolic name representing the currently selected tab in the tab control.
      </summary>
      <value>A symbolic name representing the currently selected tab in the tab control.</value>
    </member>
    <member name="P:VO.TabControl.SelectedTabPage">
      <summary>
        The modeless dialog window object representing the currently selected tab page in the tab control.
      </summary>
      <value>The modeless dialog window object representing the currently selected tab page in the tab control.</value>
    </member>
    <member name="M:VO.TabControl.SelectTab(XSharp.__Usual)">
      <summary>
        Select a tab and display its page.
      </summary>
      <param name="symTabName">The symbolic name of the tab you want to select.</param>
    </member>
    <member name="M:VO.TabControl.SetCaption(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set a new caption for a tab.
      </summary>
      <param name="symTabName">The symbolic name of the tab whose caption you want to obtain.</param>
      <param name="cCaption">The new caption for the Tab</param>
      <returns>
        TRUE if the caption could be changed; otherwise FALSE
      </returns>
    </member>
    <member name="M:VO.TabControl.SetTabImage(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Dynamically change the image (index) of a tab page.
      </summary>
      <param name="symTabName">The symbol of the page on which the image index will be changed.</param>
      <param name="nImageIndex">The index into the image list.</param>
      <returns>
        The new index into the image list.
      </returns>
    </member>
    <member name="M:VO.TabControl.SetTipText(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Change the current tip text for a tab.
      </summary>
      <param name="symTabName">The symbolic name of the tab whose tip text you want to change.</param>
      <param name="cText">The text to replace the current tip text.</param>
      <returns>
        TRUE if the text could be changed; otherwise FALSE.
      </returns>
    </member>
    <member name="M:VO.TabControl.Show">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.TabControl.TabCaption">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.TabControl.TabCount">
      <summary>
        A numeric value representing the total number of tabs in the tab control.
      </summary>
      <value>A numeric value representing the total number of tabs in the tab control.</value>
    </member>
    <member name="T:VO.TextBox">
      <summary>
        Present the user with a text message box.
      </summary>
      <remarks>
        A message box is a small window that displays a caption, a message, an icon (chosen from a predefined set of icons), and push buttons (selected from a variety of predefined combinations).  It provides an easy alternative to the dialog window when all you require from the user is a simple response.
        Message boxes require no sizing, positioning, or event handling.  In addition, message boxes can be application modal (no processing can continue in the application until the user has acknowledged the message box), or it can be modal in relation to its owner window (no processing can continue in its owner window until the user has acknowledged the message box).
      </remarks>
      <example>
        The following example handles a QueryClose event:
        <code language="X#">
          METHOD QueryClose(oEvent) CLASS TopAppWindow
            oTB := TextBox{SELF, "Quit", "Do you really want to quit?"}
            oTB:TYPE := BOXICONQUESTIONMARK + BUTTONYESNO
            IF (oTB:Show() = BOXREPLYYES)
               RETURN TRUE // Quit application.
            ELSE
               RETURN FALSE
               // Don't quit the application.
            ENDIF
        </code></example>
    </member>
    <member name="M:VO.TextBox.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Create a message box.
      </summary>
      <param name="uParent">The window that owns the message box.  If omitted, the text box is application modal (that is, the application is suspended until the user acknowledges the text box).</param>
      <param name="uCaption">The text to be displayed in the title bar of the message boxor the hyperlabel containing a caption and description for the text box.  If omitted, the default is NULL_STRING.</param>
      <param name="uText">
        The information to be printed in the message box. .  If omitted, the default is NULL_STRING.</param>
      <param name="nType">
        The text box type.  Valid types include the following button combinations and/or icons:
        <pre>
          Group 1: buttons
          Constant            Button(s)
          BOXABORTRETRYIGNORE Abort, Retry, and Ignore
          BUTTONOKAY          OK  (This is the default.)
          BUTTONOKAYCANCEL    OK and Cancel
          BUTTONRETRYCANCEL   Retry and Cancel
          BUTTONYESNO         Yes and No
          BUTTONYESNOCANCEL   Yes, No, and Cancel

          Group 2: Standard Icons
          Constant            Icon
          BOXICONASTERISK     An icon consisting of a lowercase 'i' within a circle
          BOXICONEXCLAMATION  An exclamation mark
          BOXICONHAND         A warning icon
          BOXICONQUESTIONMARK A question mark
        </pre></param>
    </member>
    <member name="P:VO.TextBox.Beep">
      <summary>
        A logical value indicating whether to use a system default beep when displaying the text box.  TRUE indicates that there will be a beep; FALSE indicates that there will be no beep.
      </summary>
      <value>A logical value indicating whether to use a system default beep when displaying the text box.  TRUE indicates that there will be a beep; FALSE indicates that there will be no beep.</value>
    </member>
    <member name="P:VO.TextBox.Caption">
      <summary>
        A string value representing the TextBox caption.
      </summary>
      <value>A string value representing the TextBox caption.</value>
    </member>
    <member name="P:VO.TextBox.Message">
      <summary>
        A string value representing the TextBox message.
      </summary>
      <value>A string value representing the TextBox message.</value>
    </member>
    <member name="M:VO.TextBox.Show">
      <summary>
        Display this message box and return a value indicating how it was closed.
      </summary>
      <returns>
        The button selected by the user.
        <para>The possible values are:</para><list type="table"><listheader><term>Constant</term><description>Button</description></listheader><item><term>BOXREPLYABORT</term><description>Abort</description></item><item><term>BOXREPLYCANCEL</term><description>Cancel</description></item><item><term>BOXREPLYIGNORE</term><description>Ignore</description></item><item><term>BOXREPLYNO</term><description>No</description></item><item><term>BOXREPLYOKAY</term><description>OK</description></item><item><term>BOXREPLYRETRY</term><description>Retry</description></item><item><term>BOXREPLYYES</term><description>Yes</description></item></list></returns>
    </member>
    <member name="P:VO.TextBox.Type">
      <summary>
        A constant or combination of constants that indicates which push buttons and/or icons are displayed in the message box
      </summary>
      <value>A constant or combination of constants that indicates which push buttons and/or icons are displayed in the message box</value>
      <remarks>
        A constant or combination of constants that indicates which push buttons and/or icons are displayed in the message box.  One item from each of these groups is added together to create the combination that you choose.
        <para>Group 1: Standard Button Combinations</para><list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>BOXABORTRETRYIGNORE</term><description>Abort, Retry, and Ignore</description></item><item><term>BUTTONOKAY</term><description>
              OK (This is the <b>default</b>.)
            </description></item><item><term>BUTTONOKAYCANCEL</term><description>OK and Cancel</description></item><item><term>BUTTONRETRYCANCEL</term><description>Retry and Cancel</description></item><item><term>BUTTONYESNO</term><description>Yes and No</description></item><item><term>BUTTONYESNOCANCEL</term><description>Yes, No, and Cancel</description></item></list><para>Group 2: Standard Icons</para><list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>BOXICONASTERISK</term><description>An icon consisting of a lowercase "i" within a circle</description></item><item><term>BOXICONEXCLAMATION</term><description>An exclamation mark</description></item><item><term>BOXICONHAND</term><description>A warning icon</description></item><item><term>BOXICONQUESTIONMARK</term><description>A question mark</description></item></list></remarks>
      <example>
        This example creates a text box with an exclamation mark icon and the OK and Cancel buttons:
        <code language="X#">oTextBox:Type := BOXICONEXCLAMATION + BUTTONOKAYCANCEL</code></example>
    </member>
    <member name="T:VO.TextControl">
      <summary>
        Provide the base class from which all X# controls are subclassed.
      </summary>
      <remarks>
        Text controls in dialog windows are destroyed when the window is closed.  Therefore, it is recommended that you save the text in a buffer if it is to be used after calling DialogWindow:EndDialog().
      </remarks>
      <example>
        This example changes the color of a button's name to red when the button is clicked:
        <code language="X#">
          METHOD ButtonClick(aControlEvent) CLASS TopAppWindow
          oPB := oControlEvent:Control
          oPB:TextColor := Color{COLORRED}
        </code></example>
    </member>
    <member name="M:VO.TextControl.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Create a text control.
      </summary>
      <param name="oOwner">The window that owns the text control.</param>
      <param name="xId">The unique ID between 1 and 8000 of the text control.</param>
      <param name="oPoint">The origin of the text control in canvas coordinates.</param>
      <param name="oDimension">The dimension of the text control in canvas coordinates.</param>
      <param name="cRegclass">The window class name (e.g., 'ListBox') of the control.</param>
      <param name="kStyle">
        Constant representing the window style of the control, specified either by a X# style constant or a Windows API style constant.  Styles can be combined using the _Or() operator.
      </param>
      <remarks>
        <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular Windows API constant.</note>
      </remarks>
      <param name="lDataAware">
        A logical value specifying whether the text control is data aware.
        For detailed information, see TextControl:Init() and the corresponding Init() method topics for the Button, CheckBox, ComboBox, DateTimePicker, Edit, FixedText, GroupBox, HotKeyEdit, IPAddress, ListBox, ListView, MonthCalendar, MultiLineEdit, PushButton, RadioButton, RadioButtonGroup, RichEdit, and SingleLineEdit subclasses in the online help.
      </param>
      <param name="nResourceID">The resource ID of the text control.</param>
    </member>
    <member name="P:VO.TextControl.Caption">
      <summary>
        The string representing the caption of the text control.
      </summary>
      <value>The string representing the caption of the text control.</value>
    </member>
    <member name="P:VO.TextControl.ControlFont">
      <summary>
        The font used to draw the text in the control.
      </summary>
      <value>The font used to draw the text in the control.</value>
    </member>
    <member name="M:VO.TextControl.Create">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.TextControl.CurrentText">
      <summary>
        A string representing the text currently displayed in a text control.   For edit controls, including the edit box associated with simple and drop-down combo boxes, it contains the text currently appearing in the edit box.  For fixed icon and group box controls,  TextControl:CurrentText contains NULL_STRING.
      </summary>
      <value>A string representing the text currently displayed in a text control.   For edit controls, including the edit box associated with simple and drop-down combo boxes, it contains the text currently appearing in the edit box.  For fixed icon and group box controls,  TextControl:CurrentText contains NULL_STRING.</value>
    </member>
    <member name="M:VO.TextControl.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.TextControl.EnableAutoComplete(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="dwFlags">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.TextControl.Font(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Change the current font of the text control.
      </summary>
      <param name="oNewFont">The font used to draw the text control.</param>
      <param name="lRescal">TRUE rescales the control according to the new font size.  FALSE does not allow rescaling.  If omitted, the default is FALSE.</param>
      <returns>
        The previous font used by the text control.
      </returns>
    </member>
    <member name="P:VO.TextControl.Font(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        The font used to draw the text in the control.

        This Access/Assign was called Font (without the underscore) in previous versions of X#. it has been renamed to avoid name collision with the TextControl:Font() method
      </summary>
      <value>
        The font used to draw the text in the control.

        This Access/Assign was called Font (without the underscore) in previous versions of X#. it has been renamed to avoid name collision with the TextControl:Font() method
      </value>
    </member>
    <member name="M:VO.TextControl.Ime(XSharp.__Usual)">
      <summary>
        Return and optionally set whether Input Method Editor is enabled for this text control.
      </summary>
      <param name="symIme">TRUE enables the Input Method Editor for this text control; FALSE disables it.</param>
      <returns>
        If &lt;symIme&gt; is not specified, TextControl:IME() returns the current setting.  If &lt;lEnable&gt; is specified, the previous setting is returned.
      </returns>
      <remarks>
        This method applies to International versions of Windows.
      </remarks>
    </member>
    <member name="P:VO.TextControl.Length">
      <summary>
        A numeric value representing the number of characters in the control.
      </summary>
      <value>A numeric value representing the number of characters in the control.</value>
    </member>
    <member name="P:VO.TextControl.Modified">
      <summary>
        A logical value that is set to TRUE when a standard edit control or editable combo box is in the process of being modified.  When the editing is completed and focus shifts to another control, TextControl:Modified is reset to FALSE.  TextControl:Modified is always FALSE for non-editable controls (fixed icon, fixed text, or group box).
      </summary>
      <value>A logical value that is set to TRUE when a standard edit control or editable combo box is in the process of being modified.  When the editing is completed and focus shifts to another control, TextControl:Modified is reset to FALSE.  TextControl:Modified is always FALSE for non-editable controls (fixed icon, fixed text, or group box).</value>
    </member>
    <member name="M:VO.TextControl.RemoveEditBalloonTip(XSharp.__Usual)">
      <summary>
        Removes the current BallonTip from the Edit control that has inherited from this class.
      </summary>
      <param name="hControl">The optional handle of the edit control to remove the BalloonTip from. The default is the control that the method is called against.</param>
    </member>
    <member name="M:VO.TextControl.SetCueBanner(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Add a cue banner to the Edit control that has inherited from this class.
      </summary>
      <param name="cText">The text displayed as the cue.</param>
      <param name="hControl">The optional handle of the edit control to add the cue too. The default is the control that the method is called against.</param>
      <remarks>
        A cue banner is text displayed in an edit control, usually indicating the purpose of the control or prompting for the type of input required. When the control gets focus or has text in it the cue is no longer displayed.
      </remarks>
    </member>
    <member name="M:VO.TextControl.ShowEditBalloonTip(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Add a BallonTip to the Edit control that has inherited from this class.
      </summary>
      <param name="cTitle">The title displayed in the tip.</param>
      <param name="cText">The text displayed in the tip.</param>
      <param name="dwIcon">The icon to use in the tip.</param>
      <param name="hControl">The optional handle of the edit control to add the BalloonTip too. The default is the control that the method is called against.</param>
      <remarks>
        dwIcon can be:
        <list type="table"><listheader><term>Value</term><description>Description</description></listheader><item><term>TTI_ERROR</term><description>Use the error icon.</description></item><item><term>TTI_INFO</term><description>Use the information icon.</description></item><item><term>TTI_NONE</term><description>Use no icon.</description></item><item><term>TTI_WARNING</term><description>Use the warning icon</description></item></list>
        A balloon tip can be displayed, pointing to an edit control.

        The tip always points to the current cursor position within the control, and is dismissed by either clicking on it, by moving focus to a control other than the control the tip is assigned to, or by typing into the text box. Showing the tip automatically sets focus to the control at the last cursor position. A form can not show more than one tip at a time, and if the tip is repeatedly shown, the previous tip is destroyed first. Tips never get focus, and there is no message sent when the tip is dismissed. If the tip is not dismissed before the system timeout value for tool tips is reached, it automatically disappears leaving focus on the control.
      </remarks>
    </member>
    <member name="P:VO.TextControl.TextColor">
      <summary>
        The color used to draw the text in the control.  (Refer to the Color:Init() method for details on specifying a color object.)
      </summary>
      <value>The color used to draw the text in the control.  (Refer to the Color:Init() method for details on specifying a color object.)</value>
    </member>
    <member name="P:VO.TextControl.TextValue">
      <summary>
        A string representing the value held in the control.
      </summary>
      <value>A string representing the value held in the control.</value>
      <remarks>
        A string representing the value held in the control.  For example, in a standard edit control, the value can be "Jones" or "$14,683.00".  TextValue is set to NULL_STRING for FixedIcon objects, or to the Caption value for all other non-editable controls.
        Note that the string is formatted according to the picture clause held in the field specification of the text control; in turn, text controls linked to a data server inherit the field — and hence picture — from the field of the server.
      </remarks>
    </member>
    <member name="T:VO.TextObject">
      <summary>
        Create a text-drawing object.
      </summary>
      <remarks>
        This is part of the DrawObject hierarchy.  It allows the programmer to display a text string at a particular point in a given color.  An optional font can be specified.
      </remarks>
    </member>
    <member name="M:VO.TextObject.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Create a TextObject object.
      </summary>
      <param name="oPoint">The origin of the TextObject object in canvas coordinates.  If omitted, the default is (10,10).</param>
      <param name="cText">The text to be displayed.  If omitted, the default is NULL_STRING.</param>
      <param name="oFont">The font to be used by the TextObject object.  The default is the system font.</param>
      <param name="oColor">The color to be used by the TextObject object.  The default is the color currently being used.  (Refer to the Color:Init() method for details on specifying a color.)</param>
    </member>
    <member name="P:VO.TextObject.BoundingBox">
      <summary>
        A bounding box representing the smallest rectangle (in the owner window's canvas coordinates) which encloses this TextObject object.
      </summary>
      <value>A bounding box representing the smallest rectangle (in the owner window's canvas coordinates) which encloses this TextObject object.</value>
    </member>
    <member name="P:VO.TextObject.Color">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.TextObject.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.TextObject.DisplayText">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.TextObject.Draw">
      <summary>
        Draw the TextObject object on the window.
        <br />Important!  This method is called by X# when the text requires redrawing.  Do not call this method from your application code — use Window:Draw() instead.
      </summary>
    </member>
    <member name="P:VO.TextObject.Font">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="T:VO.ToolBar">
      <summary>
        Create a toolbar.
      </summary>
      <remarks>
        A toolbar provides the user with an alternative way of selecting menu commands.  Although a toolbar looks more like a collection of controls than like a menu, it is constructed and manipulated as a menu rather than as a control.  It is true that the events generated by a menu, a toolbar, and a push button are not fundamentally different: each menu command, toolbar button, or push button has a symbolic name; each type of event calls a named method; each has a description that appears in the status bar ("short help") and a help context that appears when you select context help (Shift+F1).  But, since the toolbar is one object, capable of generating many events, and, since it is attached to the window as a whole (instead of as several push buttons), it resembles a menu more than a regular control.  Also, the standard way of defining and using a toolbar is as an adjunct of its associated menu; this is the structure generated by the Menu Editor.

        Toolbar buttons can be presented with icons, icons plus text captions, or text only.  The border around the buttons offers several different looks, and the gaps between buttons can be adjusted.  If a toolbar is too small to display all its buttons, perhaps because its owner window is too small, it automatically presents scrolling buttons.
        The placement of the toolbar depends, to a certain extent, on its contents.  For example, text-only buttons are long and thin, and are, therefore, better stacked along a vertical edge than along the top or bottom edge.  Icon-only buttons, with no gaps, look very natural along the top edge.  Icon and text buttons, with a small gap, are effective along the bottom edge.
        The ToolBar class also provides CoolBar/Band support, i.e., toolbars with separator bands:

        (This example is from one of the Internet Explorer's flat-style, toolbar bands.)

        A window is assigned a toolbar the same way it is assigned a menu, through an assignment to AppWindow:ToolBar().  Each toolbar button is associated with a menu command and generates the corresponding menu event; therefore, the menu and toolbar assigned to a window must be coordinated.  The most convenient way to manage the toolbar is to associate it with a menu when both are created.  Then, when the menu is assigned to the window, its toolbar is automatically assigned as well.  This automatic approach, which fits the class definition created by the Menu Editor, ensures that toolbar button clicks are associated with the intended menu command event.
        <code language="X#">
          METHOD Init(oWOwner) CLASS MyWindow
          ...
          SELF:Menu := MyMenu{}
          ...
          METHOD Init() CLASS MyMenu
          ...
          SELF:ToolBar := ToolBar{}
        </code>
        (This is also the approach used with the accelerator table.  Thus, a "menu" is actually a combination of menu, accelerator table, and toolbar, all coordinated and all used together.)

        It is possible to place a toolbar on any window, even windows that cannot own menus (such as dialog windows and nested subwindows).  In these cases, assigning a menu does not produce a visible menu, but the toolbar is still active.  It is also possible to have a toolbar button associated with a menu command that is not included on any menu, as long as the menu command is registered with Menu:RegisterItem().
        A toolbar takes up room on the window's client area.  Some window types automatically adapt to this spatial conflict, but others require explicit management of space.
        The most common use of a toolbar in business applications is to attach it to a shell window or a data window.  Both of these window types automatically adapt to the toolbar, so no further action is required.  The data window is most likely used as a child window under the shell, or as a nested subwindow; in either case, the data window adapts to the toolbar.
        Placing a toolbar on a subwindow is particularly useful:  it visually associates operations with the data they apply to.  Many data windows may use toolbar buttons like Insert Record, Delete Record, Skip Next, Skip Previous, Go Top, Go Bottom, Seek, Undo, Cut, Copy, and Paste.
        With general top windows, child windows, and dialog windows, the management of space is the responsibility of the developer.  With a toolbar on the window, this is somewhat tricky, especially if the user is allowed to drag the toolbar around: the room available depends both on resizing of the window and placement of the toolbar.  The toolbar has the ToolBar:ClientArea access, which can be called during expose events to determine the shape of the remaining area.

        The action of control events sent by a toolbar attached to a window would seem to be pretty obvious:  clicking on the Print button sends a #Print message to the window.  But what happens if the toolbar is not attached to a child window, but to the shell window?  Or if it is attached to the child window but the method that acts on the message belongs to the shell window?  And what of a toolbar attached to a data window used as a nested subform?
        Toolbars are identical to menus in their action.  Regardless of which window owns the toolbar or menu, the command event is sent first to the window that has focus; if it does not deal with it, it is sent to its owner, and to its owner, until it is handled.  If no window responds to the message, the shell window displays a message in its status bar.
        More precisely, the chain of responses looks like this, given the symbolic name of the toolbar or menu command:
        Does the window that has focus have a method with a proper name?  If so, it is called.
        <note type="tip">This is not necessarily the window that owns the toolbar or menu.</note>
        Check if its owner has a matching method, as well as the owner's owner, and so on.
        If no window has a matching method, the message is sent to the MenuCommand() method of the window with focus.  The default implementation has the following logic:  if it is owned by a window (as is a child window or subform), pass the method up to its owner; if it is owned by the application (as is the top or shell window), check if there is a window class with that name, and if so instantiate it; if not, display the message.  The MenuCommand() method can, of course, be replaced with different logic (for example, the traditional CASE statement often used in low-level Windows programming).
        Thus, there are two chains of escalation:  first, the system looks for matching method names up the ownership chain; then it escalates through the MenuCommand() methods up the ownership chain.  If nobody reacts to the method, as a last resort, the window instantiation is tried; otherwise, it fails.
        This means that a toolbar can be placed on the shell window, on a child window, or even on a nested subwindow: it is active in any case, and the message is sent to all the windows and propagated up the ownership chain.  Remember that only one menu is visible at any time, and a child window with a menu replaces the menu of its shell; but toolbars are different, they can be visible on any type of window.
        The window instantiation trick means that if we design a window in the Window Editor, all we have to do to open it is to give its name to a menu or toolbar item that is owned by some visible window.

        Note that there is a potential for confusing the end user with commands that could refer to different windows.  (This problem is not confined to toolbars; it applies to menus as well.)  Consider an order window, with information about an order and a nested subwindow (in browse view) that contains the order's line items.  If a menu contains a Delete command, what does this refer to?  Does it delete an order, an order and all its line items, or only a line item?
        Technically, the issue is clear:  the command is sent to the lowest level window that has focus, so if the user is located on the line item subwindow, that window gets the command first.  If it does not respond to it, the order window and later the shell window gets the command.
        However, from the user's viewpoint, this behavior is not obvious.  The problem lies in the caption of the menu command or toolbar button: "Delete" is not very clear.  Since the user may not be aware that the line item table is a subwindow (it looks just like a table on a window) getting different effects of Delete (depending on where the cursor is) can be confusing.
        It is, therefore, recommended that menu commands and toolbar buttons be labeled explicitly and clearly, for example as "Delete Order" and "Delete Item."  Even if higher-level logic disables commands depending on cursor location and data (for example, Delete Order may be dimmed as long as there are still unshipped line items), captions should still be clear.
      </remarks>
      <example>
        For examples of suitable code, use the Menu Editor to generate a simple menu with a toolbar, and then use the Window Editor to assign this menu to a window.
      </example>
    </member>
    <member name="M:VO.ToolBar.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Create a toolbar.
      </summary>
      <param name="oOwner">The window that owns the toolbar.</param>
      <param name="xID">The unique ID of the toolbar (between 1 and 8000).</param>
      <param name="oPoint">The origin of the toolbar in canvas coordinates.</param>
      <param name="oDimension">The dimension of the toolbar in canvas coordinates.</param>
      <param name="lEnableBands">A flag specifying whether the toolbar supports bands.  Band support is disabled if the flag is set to FALSE or if the application is running on a system with an old version of the Common Controls library.  In this case, the band-related methods (AddBand(), AddSubToolBarBand(), etc.) are not available.  The default is TRUE.</param>
      <remarks>
        A toolbar is usually assigned to a window simply by attaching it to its corresponding menu; when the menu is assigned to the window, the toolbar is assigned as well.  (It is also possible to explicitly assign a toolbar separately from its menu, using the AppWindow:ToolBar property.)
        Instantiating the toolbar does not make it visible and active.  The toolbar becomes alive only when attached to a window in the same way as a menu.  To reduce "visual noise"(undesirable blinking and flicker), the configuration of the buttons and layout of the toolbar should be completed before it is assigned to the window and made visible.
        To define the button layout of a toolbar, you use the AppendItem() and InsertItem() methods.  Note that the item IDs must be coordinated with the corresponding menu item IDs.  The easiest way to manage this correspondence is to use the Menu Editor, which automatically generates the corresponding code.
        A toolbar can be placed on any type of window.  Note however, that the window takes up some of the area of the window, leaving less space to work with.  Shell windows and data windows automatically adapt to the toolbar, but if you place a toolbar on another kind of window you need to accommodate the change explicitly.  Use the ToolBar:ClientArea property to determine how much room is left.
      </remarks>
    </member>
    <member name="M:VO.ToolBar.AddBand(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Use this method to add a band to the ToolBar.
      </summary>
      <param name="sBandName">A symbol naming the band.</param>
      <param name="oControl">A window or control descendant to be included in the new band.</param>
      <param name="iPos">Position of the band.  The default is the last position (-1).</param>
      <param name="iMinWidth">Minimum width of the band.</param>
      <param name="iMinHeight">Minimum height of the band.</param>
      <param name="sText">Text to be displayed on the band.</param>
      <param name="oForeColor">A Color object specifying the foreground color of the band.</param>
      <param name="oBackColor">A Color object specifying the background color of the band.</param>
      <param name="iImageIndex">An index into the image list specifying an image to be displayed.</param>
      <param name="oBackBitmap">A Bitmap object specifying a bitmap to be displayed as the band's background.</param>
      <returns>
        TRUE, if the operation was successful; otherwise, FALSE.
      </returns>
      <remarks>
        The ToolBar:AddBand() method adds a new band to the toolbar.  Bands are separate areas of a toolbar control, or window, which that can be resized and moved by the end user.  Each band can hold a text, an image, and a control.  Additionally, foreground and background colors, as well as a background bitmap, can be specified.  If you want to create a band holding a sub-toolbar as a control, use ToolBar:AddSubToolBarBand().
      </remarks>
      <example>
        For an example of a band-style toolbar, see the Private Eye sample application.
      </example>
    </member>
    <member name="M:VO.ToolBar.AddSubToolBarBand(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Add a new band to the toolbar as a sub-toolbar.
      </summary>
      <param name="symToolBar">A symbol naming the main toolbar.</param>
      <param name="iPos">Position of the sub-toolbar band.  The default is -1 (the last position).</param>
      <param name="iMinWidth">Minimum width of the sub-toolbar band.  The default is 100.</param>
      <param name="lFlat_dwStyle">
        You are now able to pass a DWORD value to this parameter which allows you to create ToolBars with different styles inside a ReBar control.
        <pre>
          TBSTYLE_TOOLTIPS:= 0x0100
          TBSTYLE_WRAPABLE:= 0x0200
          TBSTYLE_ALTDRAG:= 0x0400
          TBSTYLE_FLAT:= 0x0800
          TBSTYLE_LIST:= 0x1000
          TBSTYLE_CUSTOMERASE:= 0x2000
          TBSTYLE_REGISTERDROP:= 0x4000
          TBSTYLE_TRANSPARENT:= 0x8000
        </pre></param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        The AddSubToolBarBand() method creates a new band holding its own toolbar.  This way, you can create a toolbar that is divided into several bands, each holding a sub-toolbar.
      </remarks>
    </member>
    <member name="M:VO.ToolBar.AddTipText(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Add a string to be displayed as tip text for a button.
      </summary>
      <param name="nButtonID">The button ID of the button to which to add the text.</param>
      <param name="nMenuItemID">The menu item ID of the button to which to add the text.</param>
      <param name="cText">The text to add.</param>
    </member>
    <member name="M:VO.ToolBar.AppendItem(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Add a new toolbar button item to the end of the toolbar from the list of buttons available.
      </summary>
      <param name="nButtonID">
        The ID of the new toolbar button item.  To add a gap between groups of buttons, append an item labeled IDT_SEPARATOR.  To see the standard button items available, bring up the list in the Menu Editor.
        For custom toolbar buttons, append an item labeled IDT_CUSTOMBITMAP.  (For example, for the first button, the &lt;nButtonID&gt; is IDT_CUSTOMBITMAP + 1; the second is IDT_CUSTOMBITMAP + 2, and so on.)
      </param>
      <param name="nMenuItemID">The ID of the menu item corresponding to the new toolbar button item.</param>
      <param name="oBmp">
        A bitmap object that contains one or more custom bitmaps.  Each button in the bitmap must be a 16-color, 20 x 16 pixel bitmap.  The first button in the bitmap must be drawn in pixel positions 1 and 20, the second in positions 21 and 40, the third in positions 41 and 60, and so on.  (Effectively, this is a ribbon of buttons.)
        It is possible to have the custom buttons in individual bitmap resource files, and create a Bitmap object for each button.  &lt;nPosition&gt; is set to 1 if you use this method.  It is recommended to use a ribbon of buttons in one bitmap file, as this only uses one handle.  The latter method will use a handle for each object created.
      </param>
      <param name="nPosition">
        The position of a custom toolbar button in the bitmap.  If a ribbon of buttons is used for &lt;oBitmap&gt;, then the first button is 1, the second is 2, and so on.  If an individual bitmap is used or if not specified, &lt;nPosition&gt; is 1.
        The following figure illustrates a ribbon of buttons contained in one bitmap, showing the pixel positions and the &lt;nPosition&gt; for each:
      </param>
      <param name="cTitle">The title of the toolbar button that is used if the button is displayed on the toolbar, in either of the TB_TEXTANDICON or TB_TEXTONLY styles.  If not specified, the default is NULL_STRING.</param>
      <param name="nImgCount">The number of buttons in the image passed in &lt;oBmp&gt;.  The default is 1.</param>
      <param name="bState">The initial state of the button — enabled or disabled.  If enabled, the button can be selected by the user.  If disabled, the button appears dimmed (grayed) and cannot be selected; it remains unavailable until it is enabled by the application.  The default is enabled (TBSTATE_ENABLED).</param>
      <param name="bStyle">
        An optional style flag for the toolbar item.  By default the style is automatically derived from the other parameters.  Passing a Windows API constant can, however, enforce a specific style.  The default is TBSTYLE_BUTTON.
      </param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular Windows API constant.</note>
        Both the event triggered, when the button is clicked, and the description that shows up in the status bar are based on the properties of the associated menu.  Thus, the toolbar controls the action of the application indirectly, through its associated menu.
        Specifying a toolbar by calling this method for each standard toolbar button might seem cumbersome.  The recommended way to define the toolbar is to use the Menu Editor, which automatically generates code to lay out the toolbar.
        Note that the user can modify the set of button items on the toolbar with the configuration dialog.  The program does not need to concern itself with what buttons exist, since the events come in as if they were menu selections.
        In order to reduce "visual noise" (undesirable blinking and flicker), the toolbar does not immediately reflect a button added with ToolBar:AppendItem().  Instead, you must call ToolBar:Update() to make all the new buttons show up at once.  The ToolBar:Show() method automatically updates the display.  For toolbars that are defined once and for all and attached to a window, there is no need for explicitly calling ToolBar:Update(), it is intended only for toolbars that change their button configuration on the fly.
      </remarks>
      <example>
        The following example adds two custom bitmaps to the toolbar:
        <code language="X#">
          DEFINE BUTTON_ONE := 1
          DEFINE BUTTON_TWO := 2
          DEFINE FIRST_BUTTON := IDT_CUSTOMBITMAP + BUTTON_ONE
          DEFINE SECOND_BUTTON := IDT_CUSTOMBITMAP + BUTTON_TWO
          DEFINE MENUOPTIONONE := 3000
          DEFINE MENUOPTIONTWO := 3001
          LOCAL oBitmap AS Bitmap
          // IDB_BUTTONS is the resource definition of the
          // bitmap for 2 buttons
          oBitmap := Bitmap{IDT_BUTTONS}
          // The first AppendItem() method takes the first
          // button bitmap in the bitmap object, while the
          // the second one takes the second bitmap.
          SELF:ToolBar:AppendItem(FIRST_BUTTON,MENUOPTIONONE,;
          oBitmap,1,"Button One")
          SELF:ToolBar:AppendItem(SECOND_BUTTON,;
          MENUOPTIONTWO,oBitmap,2,"Button Two")
        </code></example>
    </member>
    <member name="M:VO.ToolBar.AppendSubItem(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
      <param name="nButtonID">** missing parameter documentation **</param>
      <param name="nMenuItemID">** missing parameter documentation **</param>
      <param name="oBmp">** missing parameter documentation **</param>
      <param name="nPosition">** missing parameter documentation **</param>
      <param name="cTitle">** missing parameter documentation **</param>
      <param name="nImgCount">** missing parameter documentation **</param>
      <param name="bState">** missing parameter documentation **</param>
      <param name="bStyle">** missing parameter documentation **</param>
    </member>
    <member name="P:VO.ToolBar.BandCount">
      <summary>
        The number of bands in the toolbar.
      </summary>
      <value>The number of bands in the toolbar.</value>
    </member>
    <member name="P:VO.ToolBar.BandImageList">
      <summary>
        An Image List object used for the bands.
      </summary>
      <value>An Image List object used for the bands.</value>
    </member>
    <member name="P:VO.ToolBar.Bitmap">
      <summary>
        The Bitmap object (containing a bitmap ribbon with one or more button images) that will be used to display buttons on the toolbar.  If not assigned, the default bitmap is used.
      </summary>
      <value>The Bitmap object (containing a bitmap ribbon with one or more button images) that will be used to display buttons on the toolbar.  If not assigned, the default bitmap is used.</value>
    </member>
    <member name="P:VO.ToolBar.BorderStyle">
      <summary>
        This property is no longer supported.  It is included only for compatibility with existing X# 1.0 code.
      </summary>
      <value>This property is no longer supported.  It is included only for compatibility with existing X# 1.0 code.</value>
    </member>
    <member name="P:VO.ToolBar.BoundingBox">
      <summary>
        The bounding box, in canvas coordinates, representing the minimal area that encloses the toolbar.
      </summary>
      <value>The bounding box, in canvas coordinates, representing the minimal area that encloses the toolbar.</value>
    </member>
    <member name="P:VO.ToolBar.ButtonCount">
      <summary>
        A numeric value representing the number of buttons currently on the toolbar.
      </summary>
      <value>A numeric value representing the number of buttons currently on the toolbar.</value>
    </member>
    <member name="P:VO.ToolBar.ButtonSize">
      <summary>
        A Dimension object representing the size of buttons on the toolbar.  If not assigned, the default is a 16 by 16 button.
      </summary>
      <value>A Dimension object representing the size of buttons on the toolbar.  If not assigned, the default is a 16 by 16 button.</value>
    </member>
    <member name="P:VO.ToolBar.ButtonStyle">
      <summary>
        A constant that represents how the buttons are displayed:
      </summary>
      <value>A constant that represents how the buttons are displayed:</value>
      <remarks>
        A constant that represents how the buttons are displayed:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>TB_ICONONLY</term><description>
              Display icons only.  The buttons are very small; many can fit in a limited space. This is the <b>default</b>.
            </description></item><item><term>TB_TEXTANDICON</term><description>Display both text and icons.  The buttons are very large; not many can fit, but they are easy to use and easy to understand.</description></item><item><term>TB_TEXTONLY</term><description>Display text only.  The icons are wide, but low.  They take up too much room to be effective on a toolbar across the top or bottom, but can be very useful along the left or right side. Text-labeled buttons are not very flashy, but there are times when subtle distinctions among abstract concepts are referenced, and coming up with recognizable icons may not be easy (for example, for choices like Lease, Secured Credit and Unsecured Credit).</description></item></list></remarks>
    </member>
    <member name="M:VO.ToolBar.ChangeTipText(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Change the current tip text for a button.
      </summary>
      <param name="nID">The ID of the button whose tip text you want to change.  This is either the button ID or the menu item ID, depending on the value of &lt;symLookup&gt;.</param>
      <param name="cText">The text that will replace the current tip text.</param>
      <param name="symLookUp">A symbol that describes how to interpret &lt;nID&gt;.  If the value is #ButtonID, &lt;nID&gt; is the button ID of the button; otherwise, if the value is #MenuItemID, &lt;nID&gt; is the menu item ID of the button.  If omitted, &lt;nID&gt; is interpreted as the button ID.</param>
      <returns>
        TRUE if the text could be changed; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ToolBar.ClickItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Make a button look like it is has been clicked, indicating that it has been selected.
      </summary>
      <param name="nMenuItemID">
        The menu item ID corresponding to the button that is clicked. This is not the original button ID that defines the look of the button; rather, it is the menu item ID which defines the meaning of the button.
      </param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
      <remarks>
        ClickItem() and UnclickItem() are used to indicate status ("sticky" buttons).  A toolbar button is normally clicked in (which turns the middle of the button black) and out (which returns the middle of the button to white) to indicate that its corresponding menu item has been checked or unchecked.  A button retains its clicked-in state whether enabled or disabled.
      </remarks>
    </member>
    <member name="P:VO.ToolBar.ClientArea">
      <summary>
        A bounding box (group or character box) representing the area of its parent window that remains available given the placement of the toolbar.
      </summary>
      <value>A bounding box (group or character box) representing the area of its parent window that remains available given the placement of the toolbar.</value>
      <remarks>
        A bounding box (group or character box) representing the area of its parent window that remains available given the placement of the toolbar.  When a toolbar is used in the standard way, on a shell window or a data window, there is usually little need to use this property; the windows automatically adapt themselves to the toolbar.  However, when placing the toolbar on a regular window, such as a TopAppWindow, the developer is responsible for adapting the window to the size that remains as the user moves the toolbar around.  Thus, the window might respond to an expose event by asking its toolbar how much space remains.
      </remarks>
    </member>
    <member name="M:VO.ToolBar.Configure">
      <summary>
        This method is no longer supported.  It is included only for compatibility with existing X# 1.0 code.
      </summary>
    </member>
    <member name="M:VO.ToolBar.Create">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VO.ToolBar.DeleteItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Remove a button from the toolbar.
      </summary>
      <param name="nMenuItemID">
        The menu item ID corresponding to the button that is to be removed.
        This is not the original button ID that defines the look of the button; rather it is the menu item ID which defines the meaning of the button.
      </param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
    </member>
    <member name="M:VO.ToolBar.Destroy">
      <summary>
        Provide a method to de-instantiate a ToolBar object.
      </summary>
      <remarks>
        This method can be used when a ToolBar object is no longer needed.  ToolBar:Destroy() de-instantiates the ToolBar object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.ToolBar.DimItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Dim a button.
      </summary>
      <param name="nMenuItemID">The menu item ID of the button you want to dim.</param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
    </member>
    <member name="M:VO.ToolBar.DisableItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Disable a button.
      </summary>
      <param name="nMenuItemID">
        The menu item ID corresponding to the button that is to be disabled.
        This is not the original button ID that defines the look of the button; rather it is the menu item ID which defines the meaning of the button.
      </param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
      <remarks>
        A toolbar button is normally disabled (dimmed) and enabled (blackened) in conjunction with its corresponding menu item.  A button retains its clicked-in state whether enabled or disabled.
      </remarks>
    </member>
    <member name="F:VO.ToolBar.Divider">
      <summary>This field reflects the constructor parameter lEnableBands (Divider is TRUE when lEnableBands = FALSE).</summary>
      <value>Should the toolbar have dividers or separate bands.</value>
    </member>
    <member name="M:VO.ToolBar.EnableBands(XSharp.__Usual)">
      <summary>
        Enable toolbar band support.
      </summary>
      <param name="lEnable">A logical value specifying whether or not toolbar separator bands are supported.  The default is TRUE.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        This method enables or disables toolbar band support.  If bands are enabled (the default), the toolbar uses internally a Rebar32 control and supports the management of several bands.  If you do not need or want bands, issue EnableBands(FALSE) before the toolbar is shown/created.
        <note type="tip">If band support is disabled, the band-related methods,  such as ToolBar:AddBand(), will not work.</note></remarks>
      <example>
        For an example of a band-style toolbar, see the Private Eye sample application.
      </example>
    </member>
    <member name="M:VO.ToolBar.EnableDrag(XSharp.__Usual)">
      <summary>
        Allow the user to move the toolbar around with the mouse.
      </summary>
      <param name="lEnable">The logical value indicating whether dragging is allowed.  TRUE is the default if omitted or if the method is not called.</param>
      <remarks>
        When dragged to an edge, the toolbar snaps onto the edge; if left in the central area of the window, the toolbar floats and is resizable.
        The EnableDrag() method can only be used before the toolbar is assigned to a window.
      </remarks>
    </member>
    <member name="M:VO.ToolBar.EnableItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Enable a button that has been disabled.
      </summary>
      <param name="nMenuItemID">
        The menu item ID corresponding to the button that is to be removed.
        This is not the original button ID that defines the look of the button, reference is based on the menu item ID which defines the meaning of the button.
      </param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
      <remarks>
        A toolbar button is normally disabled and enabled in conjunction with its corresponding menu item.  A button retains its clicked-in state whether enabled or disabled.
      </remarks>
    </member>
    <member name="P:VO.ToolBar.Flat">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.ToolBar.GapSize">
      <summary>
        This property is no longer supported.  It is included only for compatibility with existing X# 1.0 code.
      </summary>
      <value>This property is no longer supported.  It is included only for compatibility with existing X# 1.0 code.</value>
    </member>
    <member name="M:VO.ToolBar.GetButtonCount(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
    </member>
    <member name="M:VO.ToolBar.GetButtonDescription(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Retrieve the description of a toolbar button.
      </summary>
      <param name="nButtonID">The ID of the toolbar button.</param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
      <returns>
        The description of the toolbar button taken from the hyperlabel connected to the toolbar button.
      </returns>
    </member>
    <member name="M:VO.ToolBar.GetImageList(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Gets the ImageList that is specified by the parameters passed.
      </summary>
      <param name="symType">
        an be #IMAGELIST, #HOTIMAGELIST or #DISABLEDIMAGELIST,
        The default value is #IMAGELIST
      </param>
      <param name="symTB">
        Is the name of the toolbar (subtoolbar)
        The default is #Maintoolbar
      </param>
      <remarks>
        You can assign your own imagelist for every subtoolbar. Additionally you could assign a separate HotImagelist and a DisabledImagelist for every subtoolbar.
        This method is used to get those ImageLists.
      </remarks>
    </member>
    <member name="M:VO.ToolBar.GetRows(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
    </member>
    <member name="M:VO.ToolBar.GetState(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="nMenuItemID">** missing parameter documentation **</param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
    </member>
    <member name="M:VO.ToolBar.GetTipText(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Return the current tip text for a button.
      </summary>
      <param name="nButtonID">The ID of the button whose tip text you want to obtain.  This is either the button ID or the menu item ID, depending on the value of &lt;symLookup&gt;.</param>
      <param name="symLookUp">A symbol that describes how to interpret &lt;nID&gt;.  If the value is #ButtonID, &lt;nID&gt; is the button ID of the button; otherwise, if the value is #MenuItemID, &lt;nID&gt; is the menu item ID of the button.  If omitted, &lt;nID&gt; is interpreted as the button ID.</param>
      <returns>
        The current tip text of the specified button.
      </returns>
    </member>
    <member name="M:VO.ToolBar.Hide">
      <summary>
        Hide a toolbar so it is not visible.
      </summary>
      <remarks>
        The toolbar remains hidden from display until the ToolBar:Show() method is called.
      </remarks>
    </member>
    <member name="M:VO.ToolBar.HideItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Hide a button.
      </summary>
      <param name="nMenuItemID">The menu item ID of the button to hide.</param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
    </member>
    <member name="P:VO.ToolBar.ImageCount">
      <summary>
        A numeric value representing the number of images in the toolbar bitmap.  If a custom bitmap has been assigned to the toolbar, this value must be assigned as the number of images in that bitmap.
      </summary>
      <value>A numeric value representing the number of images in the toolbar bitmap.  If a custom bitmap has been assigned to the toolbar, this value must be assigned as the number of images in that bitmap.</value>
    </member>
    <member name="M:VO.ToolBar.InsertItem(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Insert a new toolbar button item before a specified toolbar button item, from the list of buttons available.
      </summary>
      <param name="nButtonID">The ID of the new toolbar button item.  To add a gap between groups of buttons, append an item labeled IDT_SEPARATOR.  To see the button items available, see Appendix A or bring up a list in the Menu Editor.</param>
      <param name="nMenuItemID">The ID of the menu item corresponding to the new toolbar button item.</param>
      <param name="nBeforeID">The ID of the toolbar button item before which the new toolbar button item should be inserted.  If omitted, the new toolbar button item is inserted after the last toolbar button item.</param>
      <param name="bState">** missing parameter documentation **</param>
      <param name="bStyle">** missing parameter documentation **</param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>
        Both the event triggered when the button is clicked and the description that shows up in the status bar are based on the properties of the associated menu.  Thus, the toolbar controls the action of the application indirectly, through its associated menu.
        Specifying a toolbar by calling this method for each button might seem cumbersome.  The recommended way to define the toolbar is to use the Menu Editor, which automatically generates code to lay out the toolbar.
        Note that the user can modify the set of button items on the toolbar with the configuration dialog.  The program does not need to concern itself with what buttons exist, since the events come in as if they were menu selections.
        In order to reduce "visual noise" (undesirable blinking and flicker), the toolbar does not immediately reflect a button added with InsertItem().  Instead, you must call Update() to make all the new buttons show up at once.  The Show() method automatically updates the display.  For toolbars that are defined once and for all and attached to a window, there is no need for explicitly calling Update(), it is intended only for toolbars that change their button configuration on the fly.
      </remarks>
    </member>
    <member name="M:VO.ToolBar.IsClicked(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Return a logical value indicating whether the specified button is currently clicked or selected.
      </summary>
      <param name="nID">The ID of the desired toolbar button item.</param>
      <param name="symIDType">Symbol indicating the type of data &lt;nButtonID&gt; represents.  Valid values are #ButtonID and #MenuItemID.  Defaults to #ButtonID.</param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
      <returns>
        TRUE if clicked (or selected); otherwise, FALSE.
      </returns>
      <example>
        <code language="X#">
          //check if the first toolbar button is dimmed
          oTB:IsClicked(1)
          //check if the first toolbar button is dimmed, specifying a button ID for
          //the first parameter
          oTB:IsClicked(1, #ButtonID)
          //check if the File Open button is dimmed, specifying a menu item ID for
          //the first parameter
          oTB:IsClicked(IDM_StandardShellMenu_File_Open_ID, #MenuItemID)
        </code>
      </example>
    </member>
    <member name="M:VO.ToolBar.IsDimmed(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Determine whether a button is dimmed.
      </summary>
      <param name="nID">The ID of the button whose state you want to determine.  This is either the button ID or the menu item ID, depending on the value of &lt;symLookup&gt;.</param>
      <param name="symLookup">A symbol that describes how to interpret &lt;nID&gt;.  If the value is #ButtonID, &lt;nID&gt; is the button ID of the button; otherwise, if the value is #MenuItemID, &lt;nID&gt; is the menu item ID of the button.  If omitted, &lt;nID&gt; is interpreted as the button ID.</param>
      <param name="symIDType">Symbol indicating the type of data &lt;nButtonID&gt; represents.  Valid values are #ButtonID and #MenuItemID.  Defaults to #ButtonID.</param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
      <returns>
        TRUE if the button is dimmed; otherwise, FALSE.
      </returns>
      <example>
        <code language="X#">
          //check if the first toolbar button is dimmed
          oTB:IsDimmed(1)
          //check if the first toolbar button is dimmed, specifying a button ID for
          //the first parameter
          oTB:IsDimmed(1, #ButtonID)
          //check if the File Open button is dimmed, specifying a menu item ID for
          //the first parameter
          oTB:IsDimmed(IDM_StandardShellMenu_File_Open_ID, #MenuItemID)
        </code>
      </example>
    </member>
    <member name="M:VO.ToolBar.IsEnabled(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Return a logical value indicating whether the specified button is currently enabled.
      </summary>
      <param name="nID">The ID of the desired toolbar button item.  This can be either the numeric position of the button in the toolbar (the button ID) or the menu item ID.</param>
      <param name="symIDType">Symbol indicating the type of data &lt;nButtonID&gt; represents.  Valid values are #ButtonID and #MenuItemID.  Defaults to #ButtonID.</param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
      <returns>
        TRUE if enabled; otherwise, FALSE.
      </returns>
      <example>
        <code language="X#">
          //check if the first toolbar button is enabled
          oTB:IsEnabled(1)
          //check if the first toolbar button is enabled, specifying a button ID for
          //the first parameter
          oTB:IsEnabled(1, #ButtonID)
          //check if the File Open button is enabled, specifying a menu item ID for
          //the first parameter
          oTB:IsEnabled(IDM_StandardShellMenu_File_Open_ID, #MenuItemID)
        </code>
      </example>
    </member>
    <member name="M:VO.ToolBar.IsHidden(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Determine whether a button is hidden.
      </summary>
      <param name="nID">The ID of the button whose state you want to determine.  This is either the button ID or the menu item ID, depending on the value of &lt;symLookup&gt;.</param>
      <param name="symIDType">A symbol that describes how to interpret &lt;nID&gt;.  If the value is #ButtonID, &lt;nID&gt; is the button ID of the button; otherwise, if the value is #MenuItemID, &lt;nID&gt; is the menu item ID of the button.  If omitted, &lt;nID&gt; is interpreted as the button ID.</param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
      <returns>
        TRUE if the button is hidden; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.ToolBar.IsPressed(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Determine whether a button is pressed.
      </summary>
      <param name="nID">The ID of the button whose state you want to determine.  This is either the button ID or the menu item ID, depending on the value of &lt;symLookup&gt;.</param>
      <param name="symIDType">A symbol that describes how to interpret &lt;nID&gt;.  If the value is #ButtonID, &lt;nID&gt; is the button ID of the button; otherwise, if the value is #MenuItemID, &lt;nID&gt; is the menu item ID of the button.  If omitted, &lt;nID&gt; is interpreted as the button ID.</param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
      <returns>
        TRUE if the button is pressed; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.ToolBar.Location">
      <summary>
        This property is no longer supported.  It is included only for compatibility with existing X# 1.0 code.
      </summary>
      <value>This property is no longer supported.  It is included only for compatibility with existing X# 1.0 code.</value>
    </member>
    <member name="P:VO.ToolBar.Origin">
      <summary>
        A point representing the origin of a toolbar on its owner window.
      </summary>
      <value>A point representing the origin of a toolbar on its owner window.</value>
    </member>
    <member name="P:VO.ToolBar.Owner">
      <summary>
        The window that owns the toolbar.
      </summary>
      <value>The window that owns the toolbar.</value>
    </member>
    <member name="M:VO.ToolBar.PressItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Press a button.
      </summary>
      <param name="nMenuItemID">The menu item ID of the button to press.</param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
    </member>
    <member name="M:VO.ToolBar.RemoveTipText(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Remove the current tip text for a button.
      </summary>
      <param name="nButtonID">The ID of the button whose tip text you want to remove.  This is either the button ID or the menu item ID, depending on the value of &lt;symLookup&gt;.</param>
      <param name="symLookUp">A symbol that describes how to interpret &lt;nID&gt;.  If the value is #ButtonID, &lt;nID&gt; is the button ID of the button; otherwise, if the value is #MenuItemID, &lt;nID&gt; is the menu item ID of the button.  If omitted, &lt;nID&gt; is interpreted as the button ID.</param>
      <returns>
        TRUE if the text could be removed; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.ToolBar.Rows">
      <summary>
        A numeric value representing the number of rows of buttons on the toolbar.
        Note that Rows now has an optional parameter, &lt;symTB&gt;, to indicate which toolbar, or sub-toolbar, to query.  If not specified, #MAINTOOLBAR is assumed.
      </summary>
      <value>
        A numeric value representing the number of rows of buttons on the toolbar.
        Note that Rows now has an optional parameter, &lt;symTB&gt;, to indicate which toolbar, or sub-toolbar, to query.  If not specified, #MAINTOOLBAR is assumed.
      </value>
      <example>
        To set the number of rows in the main toolbar, the following statements are equivalent:
        <code language="X#">
          oToolBar:Rows := 3
          oToolBar:[Rows, #MAINTOOLBAR] := 3
        </code>
        To set the number of rows for a (sub-)toolbar, you should do the following:
        <code language="X#">oToolBar:[Rows, #MYTOOLBAR] := 4</code>
        where #MYTOOLBAR is the symbol name representing the toolbar you which to change.
        There are two ways to query the number of rows in the main toolbar:
        <code language="X#">
          nRows := oToolBar:Rows
          nRows := oToolBar:[Rows, #MAINTOOLBAR]
        </code>
        To query the number of rows in the sub-toolbar represented by #MYSUBTOOLBAR, you could do the following:
        <code language="X#">nRows := oToolBar:[Rows, #MYSUBTOOLBAR]</code></example>
    </member>
    <member name="P:VO.ToolBar.SeparatorSize">
      <summary>
        This property is no longer supported.  It is included only for compatibility with existing X# 1.0 code.
      </summary>
      <value>This property is no longer supported.  It is included only for compatibility with existing X# 1.0 code.</value>
    </member>
    <member name="M:VO.ToolBar.SetImageList(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Sets the ImageList to be used by the ToolBar.
      </summary>
      <param name="uImageList">Can be an Imagelist or a bitmap loaded with LR_CREATEDIBSECTION and the background Color{192, 192, 192}.</param>
      <param name="symType">
        Can be #IMAGELIST, #HOTIMAGELIST or #DISABLEDIMAGELIST,
        The default value is #IMAGELIST
      </param>
      <param name="symTB">
        Is the name of the toolbar (subtoolbar)
        The default is #Maintoolbar
      </param>
      <remarks>
        You can assign your own imagelist for every subtoolbar.
        Additionally you could assign a separate HotImagelist and a DisabledImagelist for every subtoolbar.
        If you assign a Bitmap instead, it is automatically converted into a compatible Imagelist. Bitmaps for a toolbar imagelist must be loaded with the parameter LR_CREATEDIBSECTION and not with the BMP_3DTRANSPARENT which is needed for Ribbons.
        The Bitmap must have the default VO background color for Toolbar ribbons Color{192, 192, 192}.
      </remarks>
    </member>
    <member name="M:VO.ToolBar.SetRows(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="nRows">** missing parameter documentation **</param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
    </member>
    <member name="M:VO.ToolBar.SetState(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="nMenuItemID">** missing parameter documentation **</param>
      <param name="nState">** missing parameter documentation **</param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
    </member>
    <member name="M:VO.ToolBar.Show">
      <summary>
        Display a toolbar so it is visible.
      </summary>
      <remarks>
        ToolBar:Show() is used to redisplay a toolbar that was hidden with the ToolBar:Hide() method.  The toolbar does not have to be shown initially, it becomes visible as soon as it is assigned to a window.
      </remarks>
    </member>
    <member name="M:VO.ToolBar.ShowBand(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="iPos">** missing parameter documentation **</param>
      <param name="lShow">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.ToolBar.ShowItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Show a button.
      </summary>
      <param name="nMenuItemID">The menu item ID of the button to show.</param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
    </member>
    <member name="P:VO.ToolBar.Size">
      <summary>
        A dimension representing the size of a toolbar.
      </summary>
      <value>A dimension representing the size of a toolbar.</value>
    </member>
    <member name="M:VO.ToolBar.UnClickItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Make a button look like it is "clicked-out" (returned to its normal state) after it has been "clicked-in" to indicate that it has been selected.
      </summary>
      <param name="nMenuItemID">
        The menu item ID corresponding to the button that is unclicked.
        This is not the original button ID that defines the look of the button; rather it is the menu item ID which defines the meaning of the button.
      </param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
      <remarks>
        ToolBar:ClickItem() and ToolBar:UnclickItem() are used to indicate status ("sticky" buttons).  A toolbar button is normally clicked in (which turns the middle of the button black) and out (which returns the middle of the button to white) to indicate that its corresponding menu item has been checked or unchecked.  A button retains its clicked-in state whether enabled or disabled.
      </remarks>
    </member>
    <member name="M:VO.ToolBar.UnDimItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Undim a button.
      </summary>
      <param name="nMenuItemID">The menu item ID of the button to undim.</param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
    </member>
    <member name="M:VO.ToolBar.UnPressItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Unpress a button.
      </summary>
      <param name="nMenuItemID">The menu item ID of the button to unpress.</param>
      <param name="symTB">Symbolic name representing the toolbar to be used.  Defaults to the main toolbar.</param>
    </member>
    <member name="M:VO.ToolBar.Update">
      <summary>
        This method is no longer supported.  It is included only for compatibility with existing X# 1.0 code.
      </summary>
    </member>
    <member name="T:VO.TopAppWindow">
      <summary>
        Create a top-level application window.
      </summary>
      <remarks>
        A top-level application window is the main window of an application; it has no owner windows.  As with other application windows, a top application window can have icons, captions, resizeable borders, menus, and system menus.  An application can have more than one top application window.
      </remarks>
      <example>
        This example creates a top application window with the caption "TopAppWindow":
        <code language="X#">
          METHOD Start() CLASS App
          MyWin := TopAppWindow{}
          MyWin:Caption := "TopAppWindow"
          MyWin:Show()
          SELF:Exec()
        </code></example>
    </member>
    <member name="M:VO.TopAppWindow.#ctor(XSharp.__Usual)">
      <summary>
        Create a top-level application window.
      </summary>
      <param name="oOwner">The window that owns the top-level application window, which is the application itself.  If not specified, SELF is used.</param>
    </member>
    <member name="M:VO.TopAppWindow.Destroy">
      <inheritdoc />
    </member>
    <member name="P:VO.TopAppWindow.Owner">
      <summary>
        The owner of the top application window, either a Window or App object.
      </summary>
      <value>The owner of the top application window, either a Window or App object.</value>
    </member>
    <member name="M:VO.TopAppWindow.Resize(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.TopAppWindow.ToolBarHeightChanged">
      <inheritdoc />
    </member>
    <member name="T:VO.TreeView">
      <summary>
        Create a tree view control.
      </summary>
      <remarks>
        A tree view control is a control that displays a hierarchical list of tree view items, such as files and directories on a disk.  Each item consists of a label and an optional icon, and each item can have a list of subitems associated with it.  By clicking an item, the user can expand and collapse the associated list of subitems.
      </remarks>
    </member>
    <member name="M:VO.TreeView.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a tree view.
      </summary>
      <param name="oOwner">The window that owns the tree view.</param>
      <param name="xID">The unique ID of the tree view (between 1 and 8000).</param>
      <param name="nResourceID">The resource ID of the tree view.</param>
      <param name="oPoint">The origin of the tree view in canvas coordinates.</param>
      <param name="oDimension">The dimension of the tree view in canvas coordinates.</param>
      <param name="kStyle">The style of the tree view.</param>
    </member>
    <member name="M:VO.TreeView.AddItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Add a new tree view item as the last child item of a specified parent.
      </summary>
      <param name="symParentName">The symbolic name of the parent tree view item.  This can be the symbolic name of any tree view item or one of the following items: #Root, #First, #Last, and, if the tree view style is sorted, #Sort.</param>
      <param name="oTreeViewItem">The tree view item to add.</param>
      <returns>
        TRUE if the item was added successfully; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.TreeView.Collapse(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Collapse a tree view item, hiding its child items.
      </summary>
      <param name="symName">The symbolic name of the tree view item to be collapsed.</param>
      <param name="oItem">The TreeViewItem object representing the tree view item to be collapsed.</param>
      <param name="lRemoveChildItems">A logical value indicating whether child tree view items of the specified item will be removed when the item is collapsed.  If omitted, the default is FALSE.</param>
      <param name="lAll">If lAll is TRUE(default = FALSE), the operation is done for the complete subtree of the specified item.</param>
      <param name="lForceNotify">
        If lForceNotify is TRUE(default = FALSE), a notify message Window:TreeViewItemExpanding() and Window:TreeViewItemExpanded() is sent for each item whose expand state is changed.
        Generally windows will only send these messages when an item is first expanded. It depends on the TVIS_EXPANDEDONCE state. (see in Platform SDK the TVM_EXPAND Message for more details.)
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.TreeView.DeleteAll">
      <summary>
        Delete all items of the tree view.
      </summary>
      <returns>
        TRUE if all items were deleted successfully; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.TreeView.DeleteItem(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Delete a tree view item.
      </summary>
      <param name="symName">The symbolic name of the tree view item to be deleted.</param>
      <param name="oItem">The TreeViewItem object representing the tree view item to be deleted.</param>
      <param name="lChildsOnly">New logic parameter lChildsOnly which defaults to FALSE. If lChildsOnly is TRUE only the child items are deleted</param>
      <returns>
        TRUE if the item was deleted successfully; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.TreeView.Destroy">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:VO.TreeView.DragDropEnabled">
      <summary>
        A logical value that is TRUE if drag-and-drop is enabled for the tree view.  If drag-and-drop is enabled, items can be dragged within, as well as outside, the control.
      </summary>
      <value>A logical value that is TRUE if drag-and-drop is enabled for the tree view.  If drag-and-drop is enabled, items can be dragged within, as well as outside, the control.</value>
    </member>
    <member name="P:VO.TreeView.DragImageList">
      <summary>
        An image list containing a single image displayed during a drag-and-drop operation for the tree view.
      </summary>
      <value>An image list containing a single image displayed during a drag-and-drop operation for the tree view.</value>
    </member>
    <member name="M:VO.TreeView.EditItemLabel(XSharp.__Usual)">
      <summary>
        Begins in-place label editing of an item in the tree view.
      </summary>
      <param name="symName">The symbolic name of the tree view item whose label you want to edit or the TreeViewItem object representing the tree view item whose label you want to edit.</param>
    </member>
    <member name="M:VO.TreeView.EnableDragDrop(XSharp.__Usual)">
      <summary>
        Enable or disable drag-and-drop of items for the tree view.
      </summary>
      <param name="lEnable">A logical value that determines whether drag-and-drop is enabled or disabled.</param>
      <returns>
        TRUE if drag-and-drop could be enabled or disabled; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.TreeView.EnableSort(XSharp.__Usual)">
      <summary>
        Register a user-defined method to use for sorting items in the tree view.
      </summary>
      <param name="symMethodName">The symbolic name of the user-defined method that will be used to sort items in the tree view.  When called, this method receives two TreeViewItem objects as arguments.  The method should determine which of the two tree view items should come first in the tree view.  If the first item precedes the second, this method should return -1; if the second item precedes the first, this method should return 1; if the items are equivalent, this method should return 0.</param>
      <returns>
        The symbolic name of the user-defined method that will be used to perform the sort.
      </returns>
    </member>
    <member name="M:VO.TreeView.EnsureVisible(XSharp.__Usual)">
      <summary>
        Ensure that an item is visible in the tree view, expanding its parent item or scrolling the tree view if necessary.
      </summary>
      <param name="symName">The symbolic name of the tree view item which should be made visible or the TreeViewItem object representing the tree view item which should be made visible.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.TreeView.Expand(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Expand a tree view item, showing its child items.
      </summary>
      <param name="symName">The symbolic name of the tree view item to be expanded or the TreeViewItem object representing the tree view item to be expanded.</param>
      <param name="lAll">If lAll is TRUE(default = FALSE), the operation is done for the complete subtree of the specified item.</param>
      <param name="lForceNotify">
        If lForceNotify is TRUE(default = FALSE), a notify message Window:TreeViewItemExpanding() and Window:TreeViewItemExpanded() is sent for each item whose expand state is changed.
        Generally windows will only send these messages when an item is first expanded. It depends on the TVIS_EXPANDEDONCE state. (see in Platform SDK the TVM_EXPAND Message for more details.)
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.TreeView.GetDropHighlight">
      <summary>
        Return the first tree view item that is the target of a drag-and-drop operation.
      </summary>
      <returns>
        The first tree view item that is the target of a drag-and-drop operation.
      </returns>
    </member>
    <member name="M:VO.TreeView.GetFirstChildItem(XSharp.__Usual)">
      <summary>
        Return the first child tree view item.
      </summary>
      <param name="symItem">The symbolic name of the tree view item from which to start the search.  If omitted, the search starts from the root item. 
      Or the TreeViewItem object representing the tree view item from which to start the search.</param>
      <returns>
        The first tree view item from the starting item.
      </returns>
    </member>
    <member name="M:VO.TreeView.GetFirstVisibleItem">
      <summary>
        Return the first visible tree view item.
      </summary>
      <returns>
        The first visible tree view item.
      </returns>
    </member>
    <member name="M:VO.TreeView.GetItemAtPosition(XSharp.__Usual)">
      <summary>
        Return the tree view item at a particular position, if one exists.
      </summary>
      <param name="oPoint">The point at which to find a tree view item.</param>
      <returns>
        The tree view item at the specified point.
      </returns>
    </member>
    <member name="M:VO.TreeView.GetItemAttributes(XSharp.__Usual)">
      <summary>
        Return a tree view item given its symbolic name.
      </summary>
      <param name="symItem">The symbolic name of the tree view item to be returned.</param>
      <param name="oItem">The TreeViewItem object representing the tree view item to be returned.</param>
      <returns>
        The tree view item specified by the symbolic name.
      </returns>
    </member>
    <member name="M:VO.TreeView.GetItemBoundingBox(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Return the bounding box of a tree view item.
      </summary>
      <param name="symItem">The symbolic name of the tree view item whose bounding box you want to obtain.</param>
      <param name="oItem">The TreeViewItem object representing the tree view item whose bounding box you want to obtain.</param>
      <param name="lTextOnly">Logical value determining whether the returned bounding box encloses just the portion of the list view item that the text takes up (TRUE), or the entire length of the list view item (FALSE).  If omitted, defaults to FALSE.</param>
      <returns>
        The bounding box of the tree view item specified by the symbolic name or TreeViewItem object.
      </returns>
    </member>
    <member name="M:VO.TreeView.GetNextSiblingItem(XSharp.__Usual)">
      <summary>
        Return a tree view item's next sibling item.
      </summary>
      <param name="symItem">The symbolic name of the tree view item whose next sibling you want to obtain.</param>
      <param name="oItem">The TreeViewItem object representing the tree view item whose next sibling you want to obtain.</param>
      <returns>
        The next sibling tree view item of the specified item.
      </returns>
    </member>
    <member name="M:VO.TreeView.GetNextVisibleItem(XSharp.__Usual)">
      <summary>
        Return a tree view item's next visible item.
      </summary>
      <param name="symItem">The symbolic name of the tree view item whose next visible item you want to obtain.</param>
      <param name="oItem">The TreeViewItem object representing the tree view item whose next visible item you want to obtain.</param>
      <returns>
        The next visible tree view item of the specified item.
      </returns>
    </member>
    <member name="M:VO.TreeView.GetParentItem(XSharp.__Usual)">
      <summary>
        Return a tree view item's parent item.
      </summary>
      <param name="symItem">The symbolic name of the tree view item whose parent item you want to obtain.</param>
      <param name="oItem">The TreeViewItem object representing the tree view item whose parent item you want to obtain.</param>
      <returns>
        The parent tree view item of the specified item.
      </returns>
    </member>
    <member name="M:VO.TreeView.GetPreviousSiblingItem(XSharp.__Usual)">
      <summary>
        Return a tree view item's previous sibling item.
      </summary>
      <param name="symItem">The symbolic name of the tree view item whose previous sibling item you want to obtain.</param>
      <param name="oItem">The TreeViewItem object representing the tree view item whose previous sibling item you want to obtain.</param>
      <returns>
        The previous sibling tree view item of the specified item.
      </returns>
    </member>
    <member name="M:VO.TreeView.GetPreviousVisibleItem(XSharp.__Usual)">
      <summary>
        Return a tree view item's previous visible item.
      </summary>
      <param name="symItem">The symbolic name of the tree view item whose previous visible item you want to obtain.</param>
      <param name="oItem">The TreeViewItem object representing the tree view item whose previous visible item you want to obtain.</param>
      <returns>
        The previous visible tree view item of the specified item.
      </returns>
    </member>
    <member name="M:VO.TreeView.GetRootItem">
      <summary>
        Return the root tree view item.
      </summary>
      <returns>
        The root tree view item.
      </returns>
    </member>
    <member name="M:VO.TreeView.GetSelectedItem">
      <summary>
        Return the currently selected tree view item.
      </summary>
      <returns>
        The currently selected tree view item.
      </returns>
    </member>
    <member name="P:VO.TreeView.ImageList">
      <summary>
        An image list containing images to display for each item in the tree view.
      </summary>
      <value>An image list containing images to display for each item in the tree view.</value>
    </member>
    <member name="P:VO.TreeView.Indent">
      <summary>
        A numeric value representing the number of pixels that child items are indented from parent items.
      </summary>
      <value>A numeric value representing the number of pixels that child items are indented from parent items.</value>
    </member>
    <member name="M:VO.TreeView.InsertItem(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Insert a new tree view item as a child of a specified item and after a specified item in the tree view.
      </summary>
      <param name="symParentName">The symbolic name of the parent tree view item of the new item.  This can be the symbolic name of any tree view item or one of the following items: #Root, #First, #Last, and, if the tree view style is sorted, #Sort.</param>
      <param name="symInsertAfter">The symbolic name of the tree view item after which the new item should be inserted.  This can be the symbolic name of any tree view item or one of the following items: #Root, #First, #Last, and, if the tree view style is sorted, #Sort.</param>
      <param name="oTreeViewItem">The tree view item to insert.</param>
      <returns>
        TRUE if the item was inserted successfully; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.TreeView.ItemCount">
      <summary>
        A numeric value representing the number of items in the tree view.
      </summary>
      <value>A numeric value representing the number of items in the tree view.</value>
    </member>
    <member name="P:VO.TreeView.SearchString">
      <summary>
        The incremental search string associated with the tree view.
      </summary>
      <value>The incremental search string associated with the tree view.</value>
      <remarks>
        The incremental search string associated with the tree view.  The incremental search string is the character sequence that the user types while the tree view has the input focus.  When the user types a character, the character is appended to the search string, and a matching item is sought.  If the system finds a match, it selects the item.  A timeout period is associated with the search string; if the timeout period elapses before the user types another character, the string is reset.
      </remarks>
    </member>
    <member name="M:VO.TreeView.SelectItem(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Cause a tree view to select a tree view item, scroll the item into view, or redraw it as the target of a drag-and-drop operation.
      </summary>
      <param name="symItem">The symbolic name of the tree view item to be selected.</param>
      <param name="oItem">The TreeViewItem object representing the tree view item to be selected.</param>
      <param name="symCode">The symbolic name of the type of selection.  It can be one of the following values: #FirstVisible to scroll the item into view, or #DropHighlight to redraw the item.  If omitted, the item is simply selected.</param>
      <param name="lSelect">The optional logical value to determine whether the specified tree view item is selected (TRUE) or deselected (FALSE).  If omitted, defaults to TRUE.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.TreeView.SetItemAttributes(XSharp.__Usual)">
      <summary>
        Update a tree view item within the tree view.
      </summary>
      <param name="oTreeViewItem">The tree view item to update.</param>
    </member>
    <member name="M:VO.TreeView.SortChildren(XSharp.__Usual)">
      <summary>
        Sort the child tree view items of an item using the user-defined sort method specified by EnableSort().
      </summary>
      <param name="symParentName">The symbolic name of the tree view item whose children will be sorted.</param>
      <param name="oParentItem">TreeViewItem object representing the tree view item whose children will be sorted.</param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.TreeView.StateImageList">
      <summary>
        An image list containing state images to display for each item in the tree view.
      </summary>
      <value>An image list containing state images to display for each item in the tree view.</value>
    </member>
    <member name="M:VO.TreeView.Toggle(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Toggle the expanded or collapsed state of a tree view item, showing or hiding its child items appropriately.
      </summary>
      <param name="symName">The symbolic name of the tree view item to be toggled or the TreeViewItem object representing the tree view item to be toggled.</param>
      <param name="lAll">If lAll is TRUE(default = FALSE), the operation is done for the complete subtree of the specified item.</param>
      <param name="lForceNotify">
        If lForceNotify is TRUE(default = FALSE), a notify message Window:TreeViewItemExpanding() and Window:TreeViewItemExpanded() is sent for each item whose expand state is changed.
        Generally windows will only send these messages when an item is first expanded. It depends on the TVIS_EXPANDEDONCE state. (see in Platform SDK the TVM_EXPAND Message for more details.)
      </param>
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
    </member>
    <member name="P:VO.TreeView.VisibleCount">
      <summary>
        A numeric value representing the number of tree view items that are fully visible in the tree view.
      </summary>
      <value>A numeric value representing the number of tree view items that are fully visible in the tree view.</value>
    </member>
    <member name="M:VO.TreeView_CompareDelegate.#ctor(System.Object,System.IntPtr)">
      <exclude />
    </member>
    <member name="M:VO.TreeView_CompareDelegate.BeginInvoke(System.Int32,System.Int32,System.Int32,System.AsyncCallback,System.Object)">
      <exclude />
    </member>
    <member name="M:VO.TreeView_CompareDelegate.EndInvoke(System.IAsyncResult)">
      <exclude />
    </member>
    <member name="M:VO.TreeView_CompareDelegate.Invoke(System.Int32,System.Int32,System.Int32)">
      <exclude />
    </member>
    <member name="T:VO.TreeViewDeleteEvent">
      <summary>
        Provide information about a tree view delete event, which is generated when an item in a tree view control is deleted.
      </summary>
      <remarks>
        The tree view control generates this event whenever one of its items is deleted.  The information packaged with this event object includes which item was deleted so that the application can process any information stored in the TreeViewItem object.

      </remarks>
    </member>
    <member name="M:VO.TreeViewDeleteEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.TreeViewDeleteEvent.TreeViewItem">
      <summary>
        The TreeViewItem object which was deleted.
      </summary>
      <value>The TreeViewItem object which was deleted.</value>
    </member>
    <member name="T:VO.TreeViewDragEvent">
      <summary>
        Provide information about a tree view drag event, which is generated when an item in a tree view control is dragged.
      </summary>
      <remarks>
        The tree view control generates this event whenever one of its items is dragged.  The user can use either the right or the left mouse button to generate the event and can take different courses of action depending on which mouse button is currently being used.

      </remarks>
    </member>
    <member name="M:VO.TreeViewDragEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.TreeViewDragEvent.IsLeftButton">
      <summary>
        A logical value that is TRUE if this is a left-button drag.
      </summary>
      <value>A logical value that is TRUE if this is a left-button drag.</value>
    </member>
    <member name="P:VO.TreeViewDragEvent.IsRightButton">
      <summary>
        A logical value that is TRUE if this is a right-button drag.
      </summary>
      <value>A logical value that is TRUE if this is a right-button drag.</value>
    </member>
    <member name="P:VO.TreeViewDragEvent.ListViewItem">
      <summary>
        The TreeViewItem object which is being dragged.
      </summary>
      <value>The TreeViewItem object which is being dragged.</value>
    </member>
    <member name="P:VO.TreeViewDragEvent.Position">
      <summary>
        A Point object that describes the initial position of the drag in tree view control coordinates.
      </summary>
      <value>A Point object that describes the initial position of the drag in tree view control coordinates.</value>
    </member>
    <member name="P:VO.TreeViewDragEvent.TreeViewItem">
      <summary>
        The TreeViewItem object which was dragged.
      </summary>
      <value>The TreeViewItem object which was dragged.</value>
    </member>
    <member name="T:VO.TreeViewEditEvent">
      <summary>
        Provide information about a tree view edit event, which is generated when the label of an item in a tree view control is edited.
      </summary>
      <remarks>
        The tree view control generates this event whenever the label of one of its items is edited.  The event is actually generated twice for any edit operation: once at the beginning of the edit and once at the end.  Properties of this object can determine whether the edit is beginning or ending.

      </remarks>
    </member>
    <member name="M:VO.TreeViewEditEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.TreeViewEditEvent.EditBeginning">
      <summary>
        A logical value that is TRUE if the edit is beginning.
      </summary>
      <value>A logical value that is TRUE if the edit is beginning.</value>
    </member>
    <member name="P:VO.TreeViewEditEvent.EditEnding">
      <summary>
        A logical value that is TRUE if the edit is ending.
      </summary>
      <value>A logical value that is TRUE if the edit is ending.</value>
    </member>
    <member name="P:VO.TreeViewEditEvent.EditText">
      <summary>
        The Changed label of the TreeViewItem object.
      </summary>
      <value>The Changed label of the TreeViewItem object.</value>
    </member>
    <member name="P:VO.TreeViewEditEvent.TreeViewItem">
      <summary>
        The TreeViewItem object which is being edited.
      </summary>
      <value>The TreeViewItem object which is being edited.</value>
    </member>
    <member name="T:VO.TreeViewExpandedEvent">
      <summary>
        Provide information about a tree view expanded event, which is generated when an item in a tree view is expanded or collapsed, exposing or hiding its children.
      </summary>
      <remarks>
        The tree view control generates this event whenever one of its items is expanded or collapsed.  Information packaged in the event object includes which item is affected and if the item is collapsed or expanded.

      </remarks>
    </member>
    <member name="M:VO.TreeViewExpandedEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.TreeViewExpandedEvent.Collapsed">
      <summary>
        A logical value that is TRUE if the item is collapsed.
      </summary>
      <value>A logical value that is TRUE if the item is collapsed.</value>
    </member>
    <member name="P:VO.TreeViewExpandedEvent.Expanded">
      <summary>
        A logical value that is TRUE if the item is expanded.
      </summary>
      <value>A logical value that is TRUE if the item is expanded.</value>
    </member>
    <member name="P:VO.TreeViewExpandedEvent.TreeViewItem">
      <summary>
        The TreeViewItem object which is being modified.
      </summary>
      <value>The TreeViewItem object which is being modified.</value>
    </member>
    <member name="T:VO.TreeViewExpandingEvent">
      <summary>
        Provide information about a tree view expanding event, which is generated when an item in a tree view is about to be expanded or collapsed, exposing or hiding its children.
      </summary>
      <remarks>
        The tree view control generates this event whenever one of its items is about to be expanded or collapsed.  Information packaged in the event object includes which item is affected.  The primary difference between this object and the TreeViewExpandedEvent is that this event is generated before the expand/collapse action occurs.

      </remarks>
    </member>
    <member name="M:VO.TreeViewExpandingEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.TreeViewExpandingEvent.TreeViewItem">
      <summary>
        The TreeViewItem object which is being modified.
      </summary>
      <value>The TreeViewItem object which is being modified.</value>
    </member>
    <member name="T:VO.TreeViewItem">
      <summary>
        Create a tree view item.
      </summary>
      <remarks>
        A tree view item describes an item in a tree view control.
      </remarks>
    </member>
    <member name="M:VO.TreeViewItem.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a tree view item.
      </summary>
      <param name="sName">The symbolic name for the tree view item.</param>
      <param name="cTextVal">The text value of the tree view item.</param>
      <param name="uVal">The usual value associated with the tree view item.</param>
      <param name="iImage">A numeric value that represents the index of the tree view item's image in the image list.</param>
      <param name="iSelImage">A numeric value that represents the index of the tree view item's selected image in the image list.</param>
    </member>
    <member name="P:VO.TreeViewItem.Bold">
      <summary>
        A logical value that is TRUE if the text of the tree view item is bold.
      </summary>
      <value>A logical value that is TRUE if the text of the tree view item is bold.</value>
    </member>
    <member name="M:VO.TreeViewItem.Collapse(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Collapse the tree view item, hiding its child items.
      </summary>
      <param name="lAll">** missing parameter documentation **</param>
      <param name="lForceNotify">** missing parameter documentation **</param>
      <returns>
        TRUE if successful; otherwise FALSE.
      </returns>
    </member>
    <member name="M:VO.TreeViewItem.Delete(XSharp.__Usual)">
      <summary>
        Delete the tree view item.
      </summary>
      <param name="lChildsOnly">** missing parameter documentation **</param>
      <returns>
        TRUE if successful; otherwise FALSE.
      </returns>
    </member>
    <member name="P:VO.TreeViewItem.Disabled">
      <summary>
        A logical value that is TRUE if the image of the tree view item is disabled.
      </summary>
      <value>A logical value that is TRUE if the image of the tree view item is disabled.</value>
    </member>
    <member name="P:VO.TreeViewItem.DropTarget">
      <summary>
        A logical value that is TRUE if the tree view item is highlighted as the target of a drag-and-drop operation.
      </summary>
      <value>A logical value that is TRUE if the tree view item is highlighted as the target of a drag-and-drop operation.</value>
    </member>
    <member name="M:VO.TreeViewItem.Expand(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Expand the tree view item, showing its child items.
      </summary>
      <param name="lAll">** missing parameter documentation **</param>
      <param name="lForceNotify">** missing parameter documentation **</param>
      <returns>
        TRUE if successful; otherwise FALSE.
      </returns>
    </member>
    <member name="P:VO.TreeViewItem.Expanded">
      <summary>
        A logical value that determines if the tree view item is expanded or collapsed.
      </summary>
      <value>A logical value that determines if the tree view item is expanded or collapsed.</value>
    </member>
    <member name="P:VO.TreeViewItem.FirstChild">
      <summary>
        The first child item of the tree view item.
      </summary>
      <value>The first child item of the tree view item.</value>
    </member>
    <member name="P:VO.TreeViewItem.Focused">
      <summary>
        A logical value that is TRUE if the tree view item is focused.
      </summary>
      <value>A logical value that is TRUE if the tree view item is focused.</value>
    </member>
    <member name="P:VO.TreeViewItem.ImageIndex">
      <summary>
        A numeric value that represents the index of the tree view item's image in the image list.
      </summary>
      <value>A numeric value that represents the index of the tree view item's image in the image list.</value>
    </member>
    <member name="P:VO.TreeViewItem.NameSym">
      <summary>
        The symbolic name for the tree view item.
      </summary>
      <value>The symbolic name for the tree view item.</value>
    </member>
    <member name="P:VO.TreeViewItem.NextSibling">
      <summary>
        The next sibling item of the tree view item.
      </summary>
      <value>The next sibling item of the tree view item.</value>
    </member>
    <member name="P:VO.TreeViewItem.OverlayImageIndex">
      <summary>
        A numeric value that represents the index of the tree view item's overlay image in the image list.  Overlay images are images that are drawn over the item's main image.  A tree view can have up to four overlay images, so this value can be in the range of 1 to 4.
      </summary>
      <value>A numeric value that represents the index of the tree view item's overlay image in the image list.  Overlay images are images that are drawn over the item's main image.  A tree view can have up to four overlay images, so this value can be in the range of 1 to 4.</value>
    </member>
    <member name="P:VO.TreeViewItem.Parent">
      <summary>
        The parent TreeView object of the tree view item.
      </summary>
      <value>The parent TreeView object of the tree view item.</value>
    </member>
    <member name="P:VO.TreeViewItem.PreviousSibling">
      <summary>
        The previous sibling item of the tree view item.
      </summary>
      <value>The previous sibling item of the tree view item.</value>
    </member>
    <member name="P:VO.TreeViewItem.Selected">
      <summary>
        A logical value that is TRUE if the tree view item is selected.
      </summary>
      <value>A logical value that is TRUE if the tree view item is selected.</value>
    </member>
    <member name="P:VO.TreeViewItem.SelectedImageIndex">
      <summary>
        A numeric value that represents the index of the tree view item's selected image in the image list.  Selected images are displayed in place of an item's normal image when the item is selected.
      </summary>
      <value>A numeric value that represents the index of the tree view item's selected image in the image list.  Selected images are displayed in place of an item's normal image when the item is selected.</value>
    </member>
    <member name="P:VO.TreeViewItem.StateImageIndex">
      <summary>
        A numeric value that represents the index of the tree view item's state image in the state image list.  State images are images that are drawn next to the item's main image.
      </summary>
      <value>A numeric value that represents the index of the tree view item's state image in the state image list.  State images are images that are drawn next to the item's main image.</value>
    </member>
    <member name="P:VO.TreeViewItem.TextValue">
      <summary>
        The text value of the tree view item.
      </summary>
      <value>The text value of the tree view item.</value>
    </member>
    <member name="P:VO.TreeViewItem.TreeViewControl">
      <summary>
        The TreeView object identifying the TreeView control to which the current tree view item is linked.
      </summary>
      <value>The TreeView object identifying the TreeView control to which the current tree view item is linked.</value>
    </member>
    <member name="P:VO.TreeViewItem.Value">
      <summary>
        The usual value associated with the tree view item.
      </summary>
      <value>The usual value associated with the tree view item.</value>
    </member>
    <member name="T:VO.TreeViewKeyEvent">
      <summary>
        Provide information about a tree view key event, which is generated when a key is pressed while the tree view control has the input focus.
      </summary>
      <remarks>
        The tree view control generates this event whenever a key is pressed while the tree view control has the input focus.  Information packaged with this event includes the virtual key code of the pressed key.

      </remarks>
    </member>
    <member name="M:VO.TreeViewKeyEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.TreeViewKeyEvent.KeyCode">
      <summary>
        The virtual key code of the key that was pressed.
      </summary>
      <value>The virtual key code of the key that was pressed.</value>
    </member>
    <member name="T:VO.TreeViewMouseEvent">
      <summary>
        Provide information about a tree view mouse event, which is generated when a mouse button in a tree view control is clicked or double-clicked.
      </summary>
      <remarks>
        This event occurs when a mouse click or double-click occurs within the tree view control.  Properties of the event determine not only the position where the event occurred physically but also the event's relationship to items in the control.

      </remarks>
    </member>
    <member name="M:VO.TreeViewMouseEvent.#ctor(XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.TreeViewMouseEvent.ButtonID">
      <summary>
        A constant representing which mouse button was clicked.  The value can be either BUTTONLEFT or BUTTONRIGHT.
      </summary>
      <value>A constant representing which mouse button was clicked.  The value can be either BUTTONLEFT or BUTTONRIGHT.</value>
    </member>
    <member name="P:VO.TreeViewMouseEvent.IsLeftButton">
      <summary>
        A logical value that is TRUE if this is a left-button event.
      </summary>
      <value>A logical value that is TRUE if this is a left-button event.</value>
    </member>
    <member name="P:VO.TreeViewMouseEvent.IsRightButton">
      <summary>
        A logical value that is TRUE if this is a right-button event.
      </summary>
      <value>A logical value that is TRUE if this is a right-button event.</value>
    </member>
    <member name="P:VO.TreeViewMouseEvent.PointAboveClientArea">
      <summary>
        A logical value that is TRUE if the click occurred above the tree view control's client area.
      </summary>
      <value>A logical value that is TRUE if the click occurred above the tree view control's client area.</value>
    </member>
    <member name="P:VO.TreeViewMouseEvent.PointBelowClientArea">
      <summary>
        A logical value that is TRUE if the click occurred below the tree view control's client area.
      </summary>
      <value>A logical value that is TRUE if the click occurred below the tree view control's client area.</value>
    </member>
    <member name="P:VO.TreeViewMouseEvent.PointLeftOfClientArea">
      <summary>
        A logical value that is TRUE if the click occurred to the left of the tree view control's client area.
      </summary>
      <value>A logical value that is TRUE if the click occurred to the left of the tree view control's client area.</value>
    </member>
    <member name="P:VO.TreeViewMouseEvent.PointNowhere">
      <summary>
        A logical value that is TRUE if the click occurred inside the tree view control but not on an item.
      </summary>
      <value>A logical value that is TRUE if the click occurred inside the tree view control but not on an item.</value>
    </member>
    <member name="P:VO.TreeViewMouseEvent.PointOnItem">
      <summary>
        A logical value that is TRUE if the click occurred on a tree view item in the tree view control.
      </summary>
      <value>A logical value that is TRUE if the click occurred on a tree view item in the tree view control.</value>
    </member>
    <member name="P:VO.TreeViewMouseEvent.PointOnItemButton">
      <summary>
        A logical value that is TRUE if the click occurred on a tree view item's button in the tree view control.
      </summary>
      <value>A logical value that is TRUE if the click occurred on a tree view item's button in the tree view control.</value>
    </member>
    <member name="P:VO.TreeViewMouseEvent.PointOnItemImage">
      <summary>
        A logical value that is TRUE if the click occurred on a tree view item's image in the tree view control.
      </summary>
      <value>A logical value that is TRUE if the click occurred on a tree view item's image in the tree view control.</value>
    </member>
    <member name="P:VO.TreeViewMouseEvent.PointOnItemIndent">
      <summary>
        A logical value that is TRUE if the click occurred on a tree view item's indented area in the tree view control.
      </summary>
      <value>A logical value that is TRUE if the click occurred on a tree view item's indented area in the tree view control.</value>
    </member>
    <member name="P:VO.TreeViewMouseEvent.PointOnItemLabel">
      <summary>
        A logical value that is TRUE if the click occurred on a tree view item's label in the tree view control.
      </summary>
      <value>A logical value that is TRUE if the click occurred on a tree view item's label in the tree view control.</value>
    </member>
    <member name="P:VO.TreeViewMouseEvent.PointOnItemRight">
      <summary>
        A logical value that is TRUE if the click occurred to the right of a tree view item in the tree view control.
      </summary>
      <value>A logical value that is TRUE if the click occurred to the right of a tree view item in the tree view control.</value>
    </member>
    <member name="P:VO.TreeViewMouseEvent.PointOnItemStateImage">
      <summary>
        A logical value that is TRUE if the click occurred on a tree view item's state image in the tree view control.
      </summary>
      <value>A logical value that is TRUE if the click occurred on a tree view item's state image in the tree view control.</value>
    </member>
    <member name="P:VO.TreeViewMouseEvent.PointRightOfClientArea">
      <summary>
        A logical value that is TRUE if the click occurred to the right of the tree view control's client area.
      </summary>
      <value>A logical value that is TRUE if the click occurred to the right of the tree view control's client area.</value>
    </member>
    <member name="P:VO.TreeViewMouseEvent.Position">
      <summary>
        A Point object that describes the position where the click occurred in tree view control coordinates.
      </summary>
      <value>A Point object that describes the position where the click occurred in tree view control coordinates.</value>
    </member>
    <member name="P:VO.TreeViewMouseEvent.TreeViewItem">
      <summary>
        The TreeViewItem object which was clicked, if the mouse click occurred on an item; otherwise, a null object.
      </summary>
      <value>The TreeViewItem object which was clicked, if the mouse click occurred on an item; otherwise, a null object.</value>
    </member>
    <member name="T:VO.TreeViewSelectionEvent">
      <summary>
        Provide information about a tree view selection event, which is generated when the current selection in a tree view control has changed or is about to change.
      </summary>
      <remarks>
        The tree view control generates this event whenever the current selection changes or is about to change.  Information packaged in the event includes what caused the selection to change, as well as which item gained selection focus and which item lost it.

      </remarks>
    </member>
    <member name="M:VO.TreeViewSelectionEvent.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="P:VO.TreeViewSelectionEvent.KeyBoardAction">
      <summary>
        A logical value indicating whether the selection change was caused by a key press.
      </summary>
      <value>A logical value indicating whether the selection change was caused by a key press.</value>
    </member>
    <member name="P:VO.TreeViewSelectionEvent.MouseAction">
      <summary>
        A logical value indicating whether the selection change was caused by a mouse click.
      </summary>
      <value>A logical value indicating whether the selection change was caused by a mouse click.</value>
    </member>
    <member name="P:VO.TreeViewSelectionEvent.NewTreeViewItem">
      <summary>
        The TreeViewItem object that is selected as a result of this event.
      </summary>
      <value>The TreeViewItem object that is selected as a result of this event.</value>
    </member>
    <member name="P:VO.TreeViewSelectionEvent.OldTreeViewItem">
      <summary>
        The TreeViewItem object that was selected before this event occurred.
      </summary>
      <value>The TreeViewItem object that was selected before this event occurred.</value>
    </member>
    <member name="P:VO.TreeViewSelectionEvent.SelectionChanged">
      <summary>
        A logical value indicating whether the selection has changed.
      </summary>
      <value>A logical value indicating whether the selection has changed.</value>
    </member>
    <member name="P:VO.TreeViewSelectionEvent.SelectionChanging">
      <summary>
        A logical value indicating whether the selection is about to change.
      </summary>
      <value>A logical value indicating whether the selection is about to change.</value>
    </member>
    <member name="P:VO.TreeViewSelectionEvent.UnknownAction">
      <summary>
        A logical value indicating whether the selection change was caused by an unknown source.
      </summary>
      <value>A logical value indicating whether the selection change was caused by an unknown source.</value>
    </member>
    <member name="T:VO.VerticalScrollBar">
      <summary>
        Create a vertical scroll bar.
      </summary>
      <remarks>
        There are two types of vertical scroll bars in X#: regular (created with CLASS VerticalScrollBar) and window (created with the AppWindow:EnableVerticalScroll() method).  Both types have an owner window and can be manipulated using Window:VerticalScroll().  However, a window vertical scroll bar differs in that it automatically appears aligned along the right side of its owner window's canvas area and also resizes itself according to the size of its owner window.
        A vertical scroll bar allows the user to update a short integer numeric value by either moving the thumb position, clicking on the button at either end of the scroll bar to change the number by the designated ScrollBar:UnitSize, or by clicking in the interior of the scroll bar to change the number by the designated ScrollBar:BlockSize.  The minimum and maximum allowable numeric values are indicated by the Min and Max values for the Range object associated with the scroll bar.  The ScrollBar:Value access indicates the currently selected numeric value.  A scroll bar may be bound to a numeric field in a server.
        <note type="tip">By default, Window:VerticalScroll() updates the thumb position in the scroll bar; if desired, you can change this by using your own implementation of this handler.</note>

        In Windows, vertical scroll bars are equivalent to a scroll bar with the SBS_VERT style.  These are normally specified in the resource entity like this:
        <code language="X#">
          RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 120
          STYLE WS_POPUP | WS_DLGFRAME
          BEGIN
          CONTROL "", IDS_RED, "scrollbar", SBS_VERT, 10, 16, 24, 100
          END
        </code></remarks>
    </member>
    <member name="M:VO.VerticalScrollBar.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a vertical scroll bar.
      </summary>
      <param name="oOwner">The window that owns the vertical scroll bar.</param>
      <param name="xID">The unique ID between 1 and 8000 of the vertical scroll bar.</param>
      <param name="oPoint">The origin of the vertical scroll bar in canvas coordinates.</param>
      <param name="oDimension">The dimension of the vertical scroll bar in canvas coordinates.</param>
      <param name="oResourceID">The resource ID of the vertical scroll bar.</param>
    </member>
    <member name="M:VO.VerticalScrollBar.Destroy">
      <summary>
        Provide a method to de-instantiate a VerticalScrollBar object.
      </summary>
      <remarks>
        This method can be used when a VerticalScrollBar object is no longer needed.  VerticalScrollBar:Destroy() de-instantiates the VerticalScrollBar object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="T:VO.VerticalSelectionSlider">
      <summary>
        Create a vertical selection slider control.
      </summary>
      <remarks>
        A vertical selection slider is a control that contains a thumb, optional tick marks, and a selection bar.  The user can move the vertical selection slider's thumb using either the mouse or the Direction keys.
      </remarks>
    </member>
    <member name="M:VO.VerticalSelectionSlider.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a vertical selection slider.
      </summary>
      <param name="oOwner">The window that owns the vertical selection slider.</param>
      <param name="xID">The unique ID between 1 and 8000 of the vertical selection slider.</param>
      <param name="nResourceID">The resource ID of vertical selection slider.</param>
      <param name="oPoint">The origin of the vertical selection slider in canvas coordinates.</param>
      <param name="oDimension">The dimension of the vertical selection slider in canvas coordinates.</param>
    </member>
    <member name="T:VO.VerticalSlider">
      <summary>
        Create a vertical slider control.
      </summary>
      <remarks>
        A vertical slider is a control that contains a thumb and optional tick marks.  The user can move the vertical slider's thumb using either the mouse or the Direction keys.
      </remarks>
    </member>
    <member name="M:VO.VerticalSlider.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a vertical slider.
      </summary>
      <param name="oOwner">The window that owns the vertical slider.</param>
      <param name="xID">The unique ID between 1 and 8000 of the vertical slider.</param>
      <param name="nResourceID">The resource ID of vertical slider.</param>
      <param name="oPoint">The origin of the vertical slider in canvas coordinates.</param>
      <param name="oDimension">The dimension of the vertical slider in canvas coordinates.</param>
    </member>
    <member name="T:VO.VerticalSpinner">
      <summary>
        Create a spinner with vertical arrow buttons.
      </summary>
      <remarks>
        A vertical spinner is a pair of up- and down-pointing arrow buttons that can be clicked to change a value, such as a number displayed in another control.  A vertical spinner can exist independently but is most often used with another control, referred to as the client.
      </remarks>
    </member>
    <member name="M:VO.VerticalSpinner.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Construct a vertical spinner.
      </summary>
      <param name="oOwner">The window that owns the vertical spinner.</param>
      <param name="xID">The unique ID between 1 and 8000 of the vertical spinner.</param>
      <param name="nResourceID">The resource ID of the vertical spinner.</param>
      <param name="oPoint">The origin of the vertical spinner in canvas coordinates.</param>
      <param name="oDimension">The dimension of the vertical spinner in canvas coordinates.</param>
      <param name="kStyle">The style of the vertical spinner.</param>
    </member>
    <member name="T:VO.VObject">
      <summary>
        Define the class on which all other GUI classes are based.
      </summary>
      <example>
        When you define a method (such as in the example below) or property for this class, it becomes available to all other GUI classes:
        <code language="X#">
          METHOD Save() CLASS VObject
          ...
          RETURN lSuccess
        </code></example>
    </member>
    <member name="M:VO.VObject.#ctor">
      <summary>
        Construct a VObject object.
      </summary>
    </member>
    <member name="M:VO.VObject.Destroy">
      <summary>
        Free memory resources allocated for an object and its derived objects.
      </summary>
    </member>
    <member name="T:VO.WarningBox">
      <summary>
        Create a warning message box.
      </summary>
      <remarks>
        A warning message box is a window that displays a user-defined caption in the title bar, the text of the warning, and a warning icon.  These boxes are typically used to alert users to a potential error or undesirable situation.  For example, you might display a warning box to confirm a delete request on a particular file (like, "Are you sure you want to delete COMMAND.COM?").
        <note type="tip">A warning box is application modal; therefore, the user must acknowledge it before continuing with the application.  When the warning box closes, focus is returned to its owner window.</note></remarks>
    </member>
    <member name="M:VO.WarningBox.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Create a warning box.
      </summary>
      <param name="uParent">The window that owns the warning box.  If omitted, the owner is the desktop, and the warning box is application modal (that is, the application is suspended until the user acknowledges the warning box).</param>
      <param name="uCaption">The text to be displayed in the title bar of the warning box or 
        the hyperlabel containing a caption and description for the warning box.  If omitted, the default caption is 'Warning' and the default description is 'Warning...'.</param>
      <param name="uText">The information to be printed in the warning box when it is shown.  If omitted, the default is NULL_STRING.</param>
    </member>
    <member name="T:VO.WCError">
      <exclude />
    </member>
    <member name="M:VO.WCError.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <exclude />
    </member>
    <member name="M:VO.Win32.ClosePrinter(System.Void*)">
      <exclude />
    </member>
    <member name="M:VO.Win32.DeviceCapabilities(System.String,System.String,System.UInt16,System.Void*,System.Void*)">
      <exclude />
    </member>
    <member name="M:VO.Win32.DocumentProperties(System.Void*,System.Void*,System.String,VO._WINDEVMODE*,VO._WINDEVMODE*,System.UInt32)">
      <exclude />
    </member>
    <member name="M:VO.Win32.OpenPrinter(System.String,System.Void*@,VO._winPRINTER_DEFAULTS*)">
      <exclude />
    </member>
    <member name="T:VO.WinDLLVersion">
      <summary>
        Get the version info from DLLs.
      </summary>
      <remarks>
        This will get the version information from DLLs. The DLL must contain a function called DllGetVersion which fills in a _WINDLLVERSIONINFO structure.
        This convention for determining DLL version is followed by Windows DLLs such as Shell32.DLL.
      </remarks>
    </member>
    <member name="M:VO.WinDLLVersion.#ctor(System.String)">
      <summary>
        Construct a WinDLLVersion object.
      </summary>
      <param name="cDLLName">The name of the DLL as a string.</param>
      <remarks>
        This will create a WinDLLVersion object arround the DLL passed as the parameter.
        The DLL must contain a function called DllGetVersion which fills in a _WINDLLVERSIONINFO structure.
        This convention for determining DLL version is followed by Windows DLLs such as Shell32.DLL.
      </remarks>
    </member>
    <member name="P:VO.WinDLLVersion.DLL">
      <summary>
        The string representing the name of the DLL.
      </summary>
      <value>The string representing the name of the DLL.</value>
    </member>
    <member name="P:VO.WinDLLVersion.IsWinNT">
      <summary>
        A Logical value regarding the platform that the DLL was developed for.
      </summary>
      <value>A Logical value regarding the platform that the DLL was developed for.</value>
    </member>
    <member name="T:VO.Window">
      <summary>
        Provide the base class from which all X# windows are subclassed.
      </summary>
      <remarks>
        Windows are central to every GUI.  GUI windows can be thought of in two ways:
        As presentation objects with their visual representation on the screen
        As event handlers which process user interactions
        Each type of event goes to the appropriate event handler provided by subclasses of class Window.
        Event handler methods of the Window class are the system's default event handlers.  By overriding these in subclasses, you change the behavior of your derived window from the default behavior provided by the Window class.
      </remarks>
    </member>
    <member name="M:VO.Window.#ctor(XSharp.__Usual)">
      <summary>
        Construct a Window object.
      </summary>
      <param name="oOwner">The window that owns this window.</param>
      <remarks>
        The window initialization code generated by the Window Editor calls PreInit() and PostInit() at the beginning and the end, respectively, of the Init() method.  The default implementation returns NIL.  Implementation of PreInit()/PostInit(), however, results in customized initialization code which is not overridden by the Window Editor's code generation.
      </remarks>
    </member>
    <member name="P:VO.Window.Accelerator">
      <summary>
        The accelerator table associated with this window.
      </summary>
      <value>The accelerator table associated with this window.</value>
    </member>
    <member name="M:VO.Window.Activate(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when this window is activated.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oEvent">The event that describes which window was activated.</param>
      <seealso cref="T:VO.Event" />
      <remarks>
        The Activate() event occurs at the start of the window's lifetime or when the window is activated after it has been deactivated (for example, by clicking on it with the mouse).  The newly active window receives the input focus.

        You should create and show cursors (if needed) in this event handler method.
        Any subclass with its own Activate() and Deactivate() event handlers should always call its owner's handlers.  This ensures that the caption bars get highlighted or dimmed accordingly.
      </remarks>
      <seealso cref="T:VO.Event" />
    </member>
    <member name="M:VO.Window.AddTrayIcon(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Adds a tray icon associated with the window.
      </summary>
      <param name="oTrayIcon">The icon object to add to the tray.</param>
      <param name="dwID">The unique ID of the icon (between 1 and 8000).</param>
      <param name="sToolTip">The tool tip string to be displayed for this icon.</param>
      <remarks>
        <note type="tip">
          If Shell version 5 or above is loaded, the tool tip will support line breaks by using CRLF.
          On older versions of the Shell the CRLF is automatically replaced with a space.
        </note>
      </remarks>
    </member>
    <member name="M:VO.Window.Animate(XSharp.__Usual,XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="nTime">** missing parameter documentation **</param>
      <param name="nFlags">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.Window.AnimationStart(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when an animation control begins playback.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlEvent">The ControlEvent object that describes which animation control started playback.</param>
      <seealso cref="T:VO.ControlEvent" />
    </member>
    <member name="M:VO.Window.AnimationStop(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when an animation control ends playback.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlEvent">The ControlEvent object that describes which animation control ended playback.</param>
      <seealso cref="T:VO.ControlEvent" />
    </member>
    <member name="M:VO.Window.AppCommand(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when an AppCommand event takes place.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oACEvent">The AppCommandEvent object that describes the event which was initiated.</param>
      <remarks>
        This event must be overridden in the application and must return TRUE to complete the processing.
      </remarks>
      <seealso cref="T:VO.AppCommandEvent" />
    </member>
    <member name="P:VO.Window.Automated">
      <summary>
        A logical value determining whether the window object is to be exposed as an OLE automation server.  This is a convenient shortcut for the RegisterOLEAutomationObject() function.  When the window is destroyed, the UnRegisterOLEAutomationObject() is automatically called.
      </summary>
      <value>A logical value determining whether the window object is to be exposed as an OLE automation server.  This is a convenient shortcut for the RegisterOLEAutomationObject() function.  When the window is destroyed, the UnRegisterOLEAutomationObject() is automatically called.</value>
    </member>
    <member name="P:VO.Window.Background">
      <summary>
        The background brush currently in use by this window.

        The background brush currently in use by this window.
        A window's background brush is used by CanvasErase() and in handling Expose events.  Assigning a new background brush has no effect until the window (or portion of the window) is redrawn.  If a window was partially covered and is then fully exposed, only the covered part of the window is redrawn and only that part gets the new background.

        This related example will change the background color of an application's main window, and would typically occur in the main Initialize() method:
        <code language="X#">
          oWin:oColour := Color{164,255,164}
          // app background set to light green
          oWin:ShellWithColourOnly()
        </code></summary>
      <value>
        The background brush currently in use by this window.

        The background brush currently in use by this window.
        A window's background brush is used by CanvasErase() and in handling Expose events.  Assigning a new background brush has no effect until the window (or portion of the window) is redrawn.  If a window was partially covered and is then fully exposed, only the covered part of the window is redrawn and only that part gets the new background.

        This related example will change the background color of an application's main window, and would typically occur in the main Initialize() method:

        oWin:oColour := Color{164,255,164}
        // app background set to light green
        oWin:ShellWithColourOnly()
      </value>
    </member>
    <member name="M:VO.Window.ButtonClick(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a check box, push button, or radio button is clicked with the mouse.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlEvent">The ControlEvent object that describes which button was clicked.</param>
      <seealso cref="T:VO.ControlEvent" />
      <remarks>
        Button click events (radio, check, and push buttons) are propagated to the window's owner the same way as MenuEvents.  For an in-depth discussion on command event propagation, refer to the Programmer's Guide.
        You must supply the code to turn a radio button on (and all the other radio buttons off) when a user clicks on a radio button.  Similarly, you must also be sure to invert the state of a check box when it is clicked.
      </remarks>
      <example>
        This is a typical example of responding to various button clicks:
        <code language="X#">
          METHOD ButtonClick(oControlEvent) CLASS TeamInfo
          LOCAL oControl 		AS Control
          LOCAL sSym			AS SYMBOL
          oControl := IIf(oControlEvent == NULL_OBJECT, NULL_OBJECT, ;
          oControlEvent:Control)
          SUPER:ButtonClick(oControlEvent)
          //Put your changes here
          sSym := oControl:nameSym
          DO CASE
          CASE sSym == #cbHasSponsor		// a checkbox
          IF SELF:oDCcbHasSponsor:checked
          SELF:oDCsleSponsorName:enable()
          ELSE
          SELF:oDCsleSponsorName:TextValue := SPACE(25)
          SELF:oDCsleSponsorName:disable()
          ENDIF
          CASE sSym == #rbRecreational .or. sSym == #rbCompetition
          // radio buttons
          // Do something in here
          ENDCASE
        </code></example>
    </member>
    <member name="M:VO.Window.ButtonDoubleClick(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a check box, push button, or radio button is double-clicked.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlEvent">
        The <seealso cref="T:VO.ControlEvent">ControlEvent</seealso> that describes which button was double-clicked.
      </param>
      <seealso cref="T:VO.ControlEvent" />
    </member>
    <member name="P:VO.Window.CanvasArea">
      <summary>
        The bounding box representing the current size of this window's canvas area.
      </summary>
      <value>The bounding box representing the current size of this window's canvas area.</value>
    </member>
    <member name="M:VO.Window.CanvasErase">
      <summary>
        Erase the current canvas area of this window and repaint it using either the background brush or the system's default background color.
      </summary>
    </member>
    <member name="P:VO.Window.Caption">
      <summary>
        The string representing the caption (the text in the title bar of this window).  This method can also be used to change the title of this window.
      </summary>
      <value>The string representing the caption (the text in the title bar of this window).  This method can also be used to change the title of this window.</value>
    </member>
    <member name="M:VO.Window.Center">
      <summary>Center the window on its owner, or if the owner is the dektop, then center the window on the desktop.</summary>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.Close(XSharp.__Usual)">
      <summary>
        Invoked just as the window is about to close.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oEvent">An empty event required to maintain the protocol that all event handlers have exactly one event as their argument.</param>
      <remarks>
        Note that this method is automatically called when an EndDialog() or EndWindow() method is called.
      </remarks>
      <seealso cref="T:VO.Event" />
    </member>
    <member name="M:VO.Window.ComboBoxExEndEdit(XSharp.__Usual)">
      <summary>
        A callback method that is invoked when a ComboBoxEx control sends an 'EndEdit' notification message
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oComboBoxExEndEditEvent">An object that has the information about the event</param>
      <remarks>
        Provide a method that is invoked when a ComboBoxEx controls sends a CBEN_ENDEDIT message.
      </remarks>
      <seealso cref="T:VO.ComboBoxExEndEditEvent" />
    </member>
    <member name="M:VO.Window.ComboBoxExNotify(XSharp.__Usual)">
      <summary>
        A callback method that is invoked when a ComboBoxEx control sends a notification message
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlNotifyEvent">An event that has the information about the notify event</param>
      <remarks>
        Provide a method that is invoked when a ComboBoxEx control sends one of the following notification messages.
        CBEN_INSERTITEM,  CBEN_DELETEITEM,  CBEN_DRAGBEGIN, CBEN_BEGINEDIT and CBEN_ENDEDIT
        Currently this method contains only a message handler for the CBEN_ENDEDIT message,
        which calls the Window:ComboBoxExEndEdit() method.
        If you override this method to process the other messages, don’t forget to call SUPER: ComboBoxExNotify(oControlNotifyEvent)  in the otherwise part.
      </remarks>
      <seealso cref="T:VO.ControlNotifyEvent" />
    </member>
    <member name="P:VO.Window.ContextMenu">
      <summary>
        A menu object representing the local pop-up menu for a window or window control.
      </summary>
      <value>A menu object representing the local pop-up menu for a window or window control.</value>
    </member>
    <member name="M:VO.Window.ControlNotify(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a control sends a notification to its parent window.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlNotifyEvent">The ControlNotifyEvent object that describes which control sent the notification.</param>
      <remarks>
        This is a general method that is called whenever a common control sends a notification to its parent window.  
        In many cases, a more specific method is invoked in addition to this method in response to the notification.
        Notifiy codes that are not handled by this method are send to the Control:ParentNotify() method when this method is available.
      </remarks>
      <seealso cref="T:VO.ControlNotifyEvent" />
    </member>
    <member name="M:VO.Window.DateTimeSelectionChanged(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a DateTimePicker selection is changed.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oDateTimeSelectionEvent">The DateTimeSelectionEvent object that describes which control sent the notification.</param>
      <seealso cref="T:VO.DateTimeSelectionEvent" />
    </member>
    <member name="M:VO.Window.DeActivate(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when this window is deactivated.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oEvent">An empty event required to maintain the protocol that all event handlers have exactly one event as their argument.</param>
      <remarks>
        This event handler is normally invoked when another application or window becomes activated.  If Window:MouseTrapOn() is left on, MouseEvent events cannot be directed to other applications or windows.
      </remarks>
      <seealso cref="T:VO.Event" />
    </member>
    <member name="M:VO.Window.DeactivateAllOLEObjects(XSharp.__Usual)">
      <exclude />
    </member>
    <member name="M:VO.Window.Default(XSharp.__Usual)">
      <summary>Call the default windows procedure for a window and set the EventReturnValue for the object.</summary>
      <param name="oEvent">The event that occurred for the control.</param>
      <returns>NIL</returns>
      <seealso cref="T:VO.Event" />
    </member>
    <member name="M:VO.Window.DeleteTrayIcon(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="dwID">** missing parameter documentation **</param>
    </member>
    <member name="M:VO.Window.Destroy">
      <summary>
        Free memory resources allocated for a window and its derived objects.
      </summary>
      <remarks>
        This method immediately frees resources for Window objects created explicitly in your application.  Window:Destroy() also takes care of resources allocated to derived classes and deallocates them in the necessary order (e.g., child windows are destroyed before the parent window, dialog windows and MDI shell windows are also looked after).
      </remarks>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.Disable">
      <summary>
        Disable this window (until a subsequent call to Enable()).
      </summary>
      <remarks>
        Disabled windows no longer receive mouse and keyboard events.
      </remarks>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.Dispatch(XSharp.__Usual)">
      <summary>
        Provide the dispatcher for events within the system when the window has focus;
        routing various events to their appropriate event handlers.
        <br />Important!  This is a callback method used by X#.
      </summary>
      <param name="oEvent">The event to be handled.</param>
      <seealso cref="T:VO.Event" />
      <returns>
        A numeric value representing the event handler to handle the event. This is usually the value of the EventReturnValue field.
      </returns>
      <remarks>
        Windows receive events from the user and the system all of the time.  Each window receives only the events that are
        relevant to it.  For each event that is generated, two things happen:
        1.	The event is converted to a particular Event object (an ExposeEvent or a MouseEvent, for example) according to the action that triggered the event.
        2.	The appropriate event handler is called, and this typed Event object is passed to it.
        <note type="tip">
          If you want to set a specific return value for the underlying window procedure, you have to change the EventReturnValue variable for the window object.
          If you want to handle other events (for example, timer events), you need to write your own Dispatch() method.
          The following guidelines should be followed when writing a customized Dispatch() method:
          1.	Subclass an event type appropriate to the type of operation for which it is being used.
          2.	Add an event handler function to your derived object.  (This event handler should be called with the event when the event is received.)
          3.	In general, the implementation of this event handler should call Default().  This keeps the same behavior as the base class, but it also
          allows other classes to provide useful event handlers for your new type of event, allowing you to provide a framework for other classes to use.
          The base class Dispatch() method should be called in those cases where the received event is not handled by the customized dispatcher.  
          For example:
          <code language="X#">RETURN SUPER:Dispatch(&lt;oEvent&gt;)</code></note>
        You can now write a DispatchUnknown( oEvent ) method on your own window class to handle messages that are not processed by the window.
        When this message exists then it will be automatically called by the Dispatch() method inside the Window class.
        <example><code language="X#">
            METHOD DispatchUnknown(oEvent) CLASS MyCustomWindow
            // Your code
            // If you need the default window
            //	procedure call SELF:Default(oEvent)
            // Assign the event return value to SELF:EventReturnValue,
            //	the default value is 0l.
                 SELF:EventReturnValue := 1l
          </code></example></remarks>
    </member>
    <member name="P:VO.Window.DragDropClient">
      <summary>
        The DragDropClient object created when Window:EnableDragDropClient(TRUE) is called.
      </summary>
      <value>The DragDropClient object created when Window:EnableDragDropClient(TRUE) is called.</value>
    </member>
    <member name="P:VO.Window.DragDropServer">
      <summary>
        The DragDropServer object created when Window:EnableDragDropServer(TRUE) is called.
      </summary>
      <value>The DragDropServer object created when Window:EnableDragDropServer(TRUE) is called.</value>
    </member>
    <member name="P:VO.Window.DragImageList">
      <summary>
        The ImageList object used for a drag-and-drop operation.
      </summary>
      <value>The ImageList object used for a drag-and-drop operation.</value>
    </member>
    <member name="M:VO.Window.Draw(XSharp.__Usual)">
      <summary>
        Display a Draw object on this window.
      </summary>
      <param name="oDrawObject">The object to be drawn, or the array of objects to be drawn.</param>
      <remarks>
        A Draw object is drawn by placing the device context or presentation space into the Draw object and then calling the Draw object's method Draw().  This is the only valid way of drawing a Draw object on a window.
      </remarks>
      <seealso cref="T:VO.DrawObject" />
    </member>
    <member name="M:VO.Window.DrawBackground(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Draw the background of a window.
      </summary>
      <param name="hdc">The handle of the device context.</param>
      <param name="oWindow">
        The window to be drawn.
        The oWindow object is normally identical with SELF except when SELF is a DataWindow. In this case oWindow should be the oSurface (__FormDialogWindow) object. In a DataWindow you should draw the background only if oWindow == oSurface, otherwise it is superfluous.
      </param>
      <remarks>
        If you draw the background for yourself you should return TRUE otherwise FALSE.
      </remarks>
    </member>
    <member name="M:VO.Window.Drop">
      <summary>
        Retrieve information about a load from the drag event and act on each file in the selection.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oDragEvent">The DragEvent that determines the position of the mouse (in canvas coordinates), as well as the number and names of files, in the drag-and-drop load.</param>
      <remarks>
        The system dispatches this method when the user lets go of the mouse button to drop the load in the client area.  This method is required to handle drag-and-drop correctly.  It retrieves information about the load from the drag event and acts on each file in the selection.
      </remarks>
      <seealso cref="T:VO.DragEvent" />
    </member>
    <member name="M:VO.Window.EditChange(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the text in an edit control is changed.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlEvent">The ControlEvent object that describes which edit control was changed.</param>
      <seealso cref="T:VO.ControlEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.EditFocusChange(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the input focus changes to or from an edit control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
      <param name="oEditFocusChangeEvent">The EditFocusChangeEvent object that identifies which edit control generated the EditFocusChangeEvent object and whether it has just gained or lost the keyboard focus.</param>
      <seealso cref="T:VO.EditFocusChangeEvent" />
      <remarks>
        If Window:EditFocusChange() is used to validate an edit control (and also return the focus to it if invalid), Control:SetFocus() should not be called until another control has received the focus.
        In complex dialog windows that contain many edit controls, it makes sense to grab the edit control's text when the focus is changing so that other controls can be updated with it if necessary.
        See the ButtonClick() method for an example of similar syntax to be used in this method.  Note that none of the button controls are passed through this method, only SingleLineEdit and MultiLineEdit controls.  If looking to control Combobox selections, then use the ListBoxSelect() callback method.
      </remarks>
    </member>
    <member name="M:VO.Window.EditScroll(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked for this window when an edit control is scrolled.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlEvent">The ControlEvent object that identifies which edit control invoked the event handler.</param>
      <seealso cref="T:VO.ControlEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
      <remarks>
        This type of event normally happens when the user enters more characters in an edit control than it can display.

        In Windows, you must set flags in the resource entity description of the edit control to allow scrolling:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>ES_AUTOHSCROLL</term><description>Automatically scrolls the text horizontally</description></item><item><term>ES_AUTOVSCROLL</term><description>Automatically scrolls the text vertically</description></item><item><term>WS_HSCROLL</term><description>Displays a horizontal scroll bar on the edit control</description></item><item><term>WS_VSCROLL</term><description>Displays a vertical scroll bar on the edit control</description></item></list></remarks>
    </member>
    <member name="M:VO.Window.Enable">
      <summary>
        Enable a previously disabled window.
      </summary>
      <remarks>
        Enabling a window allows it to receive mouse and keyboard events.  By default, windows are enabled until disabled, so there is no need to call the Window:Enable() method unless Window:Disable() was previously called.
      </remarks>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.EnableCloseBox(XSharp.__Usual)">
      <summary>
        Enable or Disable the close button on a window (the X )
      </summary>
      <param name="uValue">A logic value indicating if the close box should be enabled (TRUE) or disabled (FALSE).</param>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.EnableDragDropClient(XSharp.__Usual)">
      <summary>
        Allow "draggable" windows to be dropped on this window.
      </summary>
      <param name="lEnable">TRUE enables the window as a drop client.  FALSE does not allow this behavior.  If omitted, the default is TRUE.</param>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.EnableDragDropClient(XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
      <param name="lSurfaceOnly">When a logical value of TRUE is passed then only the surface of the DataWindow is activated.</param>
    </member>
    <member name="M:VO.Window.EnableDragDropServer(XSharp.__Usual)">
      <summary>
        Allow this window to be dropped on windows with drag and drop capabilities.
      </summary>
      <param name="lEnable">TRUE enables the window as a drag server.  FALSE does not allow this behavior.  If omitted, the default is TRUE.</param>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.EnableHelp(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Enable or disable help for a window and its child windows.
      </summary>
      <param name="lEnable">TRUE enables help; FALSE disables help.  If not specified, the default is TRUE.</param>
      <param name="oHelpDisplay">A HelpDisplay object specifying the help file to use.</param>
      <remarks>
        This method is called by Window:HelpDisplay().
      </remarks>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.EnableHelpButton">
      <summary>
        Enables the help button in the window caption bar.
      </summary>
      <remarks>
        Enables the help button in the window caption bar. This works only if no maximize or minimize button is present on the caption bar. It is recommended for DialogWindow’s.
        This is recommended only, if you have created the HelpDisplay{} object with lWin32Processing is TRUE.
      </remarks>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.EnableHelpCursor">
      <summary>
        Changes the cursor to a question mark with a pointer.
      </summary>
      <remarks>
        Changes the cursor to a question mark with a pointer. If the user then clicks a control the control receives a help request message.
        This is recommended only, if you have created the HelpDisplay{} object with lWin32Processing is TRUE.
      </remarks>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.EnableThemeDialogTexture(XSharp.__Usual)">
      <summary>
        Enables or disables the visual style of a dialog window's background.
      </summary>
      <param name="dwStyle">
        The style to be set.
        <pre>
          Style               Description
          ETDT_ENABLE         Enables dialog window background texturing. The texturing is defined by a visual style.
          ETDT_ENABLETAB      Enables dialog window background texturing. The texture is the Tab control texture defined
          by the visual style. This flag is equivalent to (ETDT_ENABLE | ETDT_USETABTEXTURE).
          ETDT_DISABLE        Disables background texturing.
          ETDT_USETABTEXTURE  Uses the Tab control texture for the background texture of a dialog window.
        </pre></param>
      <remarks>
        This method allows the enabling and disableing of background themes in WinXP and later.
      </remarks>
    </member>
    <member name="M:VO.Window.EnableToolTips(XSharp.__Usual)">
      <summary>
        Enable or disable the tooltips for a window.  Note that assigning a value to Control:ToolTipText automatically enables the tooltip's display on the parent window.
      </summary>
      <param name="lEnable">Logical value indicating whether the tool tips should be enabled (TRUE) or disabled (FALSE).  If omitted, the default is TRUE.</param>
      <returns>
        TRUE, if tooltips were enabled; FALSE, if tooltips were disabled.
      </returns>
    </member>
    <member name="F:VO.Window.EventReturnValue">
      <summary>This field stores the result of the call to the Windows Procedure for the window.</summary>
    </member>
    <member name="M:VO.Window.Expose(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked whenever part of the window needs repainting.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oExposeEvent">The ExposeEvent object that describes which area of the window needs repainting.</param>
      <seealso cref="T:VO.ExposeEvent" />
      <remarks>
        This is one of the most important event handlers.
        A window requires repainting when the window:
        <list type="bullet"><item>Is partially uncovered by another window</item><item>Is first shown</item><item>Increases in size</item><item>Is being restored after being iconized</item><item>The window should retain enough information to redraw the screen as it was (or as it should be).</item></list>
        An ExposeEvent is also triggered by calling Repaint() or Update(); you should not call Repaint() or Update() during the Expose().
      </remarks>
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.FocusChange(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the input focus changes from the current window to another (or vice versa).
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oFocusChangeEvent">The FocusChangeEvent object that identifies whether the focus is being gained or lost.</param>
      <seealso cref="T:VO.FocusChangeEvent" />
      <remarks>
        If your window uses cursors, you should hide the window's cursor when the focus is changed to a different window, and then show the cursor when the window receives focus again.  This should be used in conjunction with the Window:Activate() and Window:Deactivate() event handlers.
      </remarks>
      <example>
        This example demonstrates how Window:FocusChange() displays the cursor at the specified cursor position when focus is gained.  If the focus is lost, the cursor is hidden:
        <code language="X#">
          METHOD FocusChange(oFocusChangeEvt) CLASS MyTopAppWindow
          IF oFocusChangeEvt:GotFocus	 // Gaining focus
          oMyCursor:Show()
          oMyCursor:Position := oMyCursorPos
          ELSE						// Losing focus
          oMyCursorPos := oMyCursor:Position
          oMyCursor:Hide()
          ENDIF
        </code></example>
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="P:VO.Window.Font">
      <summary>
        The font currently used by this window.  This font is used by the TextObject:TextPrint() method.
      </summary>
      <value>The font currently used by this window.  This font is used by the TextObject:TextPrint() method.</value>
    </member>
    <member name="P:VO.Window.Foreground">
      <summary>
        The foreground brush currently in use by this window.
      </summary>
      <value>The foreground brush currently in use by this window.</value>
    </member>
    <member name="M:VO.Window.GetAllChildren">
      <summary>
        Obtain an array of all X# children objects of the window.
      </summary>
      <returns>
        An array of all X# children objects of the window.  This array may contain window objects as well as control objects.  Note that controls which do not have a corresponding X# object, like a FixedText control where the Generate Code property was set to "No", are not included in the returned array.
      </returns>
    </member>
    <member name="M:VO.Window.GetExStyle">
      <summary>
        Retrieve the Ex styles for the window.
      </summary>
      <returns>
        Numeric value representing the X# style constants or Windows API style constants enabled for the window.
      </returns>
    </member>
    <member name="M:VO.Window.GetStyle">
      <summary>
        Retrieve the styles for the window.
      </summary>
      <returns>
        Numeric value representing the X# style constants or Windows API style constants enabled for the window.
      </returns>
    </member>
    <member name="M:VO.Window.Handle">
      <summary>
        Return the handle for a window.
      </summary>
      <param name="nHandleType">The type of handle required.  0 is the only supported option and is the default if &lt;nHandleType&gt; is omitted.</param>
      <returns>
        A handle to the window, describing the underlying system object.
      </returns>
      <remarks>
        This method provides a handle to the window, which can then be used by Windows API calls.
      </remarks>
    </member>
    <member name="M:VO.Window.HasExStyle(System.Int32)">
      <summary>Check if an exstyle value has been set for the window</summary>
      <param name="kStyle">The style to check for</param>
      <returns>TRUE when the exstyle is set. Otherwise FALSE.</returns>
    </member>
    <member name="M:VO.Window.HasStyle(System.Int32)">
      <summary>Check if a style value has been set for the window</summary>
      <param name="kStyle">The style to check for</param>
      <returns>TRUE when the style is set. Otherwise FALSE.</returns>
    </member>
    <member name="P:VO.Window.HelpDisplay">
      <summary>
        The help display object currently used by this window.  This help display object provides a connection between the help file to be displayed and this window.
      </summary>
      <value>The help display object currently used by this window.  This help display object provides a connection between the help file to be displayed and this window.</value>
      <example>
        The following example handles the default Help menu command:
        <code language="X#">
          CLASS MyWindow INHERIT TopAppWindow
          METHOD Init() CLASS MyWindow
          SUPER:Init()
          SELF:HelpDisplay := HelpDisplay{"mywind.hlp"}
          METHOD MenuCommand(oMCE) CLASS MyWindow
          LOCAL nItemID := oMCE:ItemID
          DO CASE
          CASE nItemID = IDM_MENU_HELP_INDEX_ID
          SELF:HelpDisplay:Show("HelpIndex")
          CASE nItemID = IDM_MENU_HELP_USINGHELP_ID
          SELF:HelpDisplay:Show("HelpOnHelp")
          OTHERWISE
          SUPER:MenuCommand(oMCE)
          ENDCASE
        </code></example>
    </member>
    <member name="M:VO.Window.HelpRequest(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the user requests help from the application using one of the available context-sensitive help mechanisms.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oHelpRequestEvent">The HelpRequestEvent object that describes which item help is being requested for.</param>
      <seealso cref="T:VO.HelpRequestEvent" />
      <remarks>
        This event handler is invoked only if the help mechanism has been enabled for the current window (or one of its owners).  The help mechanism is enabled by assigning a HelpDisplay object to the windows HelpDisplay property.
        The default implementation of this event handler is to display the help topic that is associated with the control, menu command, or window region with focus when the HelpRequestEvent was generated.  This is accomplished using HelpDisplay:Show(&lt;cKeyword&gt;), where &lt;cKeyword&gt; is either a HyperLabel:HelpContext property or a default keyword generated by this event handler in cases where a hyperlabel is not available.
        If there is no hyperlabel for an item, the keyword generated is as follows:
        A HELPCONTROL request generates the keyword Control_xxxx, where xxxx is the numeric ID of the control, in decimal.  For example, an OK push button might generate the keyword Control_101.
        A HELPMENU request generates the keyword Menu_xxxx, where xxxx is the "cleaned" text of the menu command.  The cleaned text has all leading and trailing spaces and the ampersand character (&amp;) removed.  In addition, all sequences of spaces are replaced by a single underscore, and the string is truncated at the first tab character.
        For example, the keyword generated for the menu command:
        Save &amp;As\tF3
        is
        Menu_Save_As
        A HELPWINDOW request generates one of the keywords listed in the table below, depending on the window region that has focus:
        <pre>
          Keyword				Window Region
          Window_Border		Border
          Window_Caption		Title bar
          Window_MaxBox		Maximize button
          Window_MinBox		Minimize button
          Window_SysMenuBox	System menu button
          Window_Unknown		Any area of the window not explicitly identified in this table
          Window_WindowCanvas	Canvas area
        </pre><note type="tip">If the Window_Unknown keyword is generated, the default behavior of HelpRequest() is to display the Contents topic as defined in the HelpDisplay (that is, HelpDisplay:Show("HelpIndex")).</note>
        If a HELPWINDOW request is received, while Window:HelpContext is defined, Window:HelpRequest() uses the HelpContext property, regardless of the window region that has focus.
        Refer to the "GUI Classes" chapter in the Programmer's Guide for more information on programming an online help system for your application.
      </remarks>
    </member>
    <member name="M:VO.Window.Hide">
      <summary>
        Hide this window so it is not visible.
      </summary>
      <remarks>
        The window remains hidden from display until the Window:Show() method is called.  This method is not used to close a window.  Use Window:Hide() to make a window disappear from view, but remain available for re-opening.
      </remarks>
    </member>
    <member name="M:VO.Window.HorizontalScroll(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a horizontal scroll bar is scrolled.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oScrollEvent">The ScrollEvent object that describes the scroll type and new position.</param>
      <seealso cref="T:VO.ScrollEvent" />
      <remarks>
        The default behavior for this event handler is to update the thumb position of the scrollbar; this can be changed using your own implementation of the handler.  This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects.  If the application has vertical scroll bars, use a WindowVerticalScrollBar event handler.
      </remarks>
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.HorizontalSlide(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a horizontal slider's thumb is dragged either by the mouse or the keyboard.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oSliderEvent">The SliderEvent object that describes which horizontal slider's thumb was dragged.</param>
      <seealso cref="T:VO.SliderEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.HorizontalSpin(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a horizontal spinner is spun.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <remarks>
        The default behavior for this event handler is to update the position of the spinner; this can be changed using your own implementation of the handler.  This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects.  If the application has vertical scroll bars, use a WindowVerticalScrollBar event handler.
      </remarks>
      <param name="oSpinnerEvent">The SpinnerEvent object that describes which horizontal spinner was spun.</param>
      <seealso cref="T:VO.SpinnerEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="P:VO.Window.HyperLabel">
      <summary>
        The hyperlabel connected to this window.
      </summary>
      <value>The hyperlabel connected to this window.</value>
      <remarks>
        The hyperlabel connected to this window.  From the hyperlabel, you can retrieve additional information about the window, for example:
        <code language="X#">
          cCaption := oWindow:HyperLabel:Caption
          cDescription := oWindow:HyperLabel:Description
          cHelpContext := oWindow:HyperLabel:HelpContext
        </code>
        HyperLabel can also be used to assign a HyperLabel object to a window, although this is most commonly done during instantiation.
      </remarks>
    </member>
    <member name="P:VO.Window.Icon">
      <summary>
        The large icon object used for this window.
      </summary>
      <value>The large icon object used for this window.</value>
    </member>
    <member name="P:VO.Window.IconSm">
      <summary>
        The small icon object used for this window.
      </summary>
      <value>The small icon object used for this window.</value>
    </member>
    <member name="M:VO.Window.IsEnabled">
      <summary>
        Report if this window is currently enabled.
      </summary>
      <returns>
        TRUE if the window is enabled; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.Window.IsIconic">
      <summary>
        Report if this window is currently iconized.
      </summary>
      <returns>
        TRUE if the window is iconized; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.Window.IsVisible">
      <summary>
        Report if this window is visible (completely or partially) or hidden.
      </summary>
      <returns>
        TRUE if the window is visible; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.Window.IsZoomed">
      <summary>
        Report if this window is maximized (fills the entire screen).
      </summary>
      <returns>
        TRUE if the window is maximized; otherwise, FALSE.
      </returns>
    </member>
    <member name="M:VO.Window.KeyDown(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a key on the keyboard is pressed.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oKeyEvent">The KeyEvent object that describes what key was pressed.</param>
      <remarks>
        This event handler is called only if the window has the input focus.  In addition, it is rarely overridden due to the existence of edit controls.  If it is overridden for a dialog window, it should call the owner handler (this ensures that tabbing to controls in Windows still works).
      </remarks>
    </member>
    <member name="M:VO.Window.KeyUp(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a key on the keyboard is released.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oKeyEvent">The KeyEvent object that describes what key was released.</param>
      <remarks>
        This event handler is called only if the window has the input focus.
      </remarks>
    </member>
    <member name="M:VO.Window.LineTo(XSharp.__Usual)">
      <summary>
        Draw a line on this window (using the current pen) from the current pen position to a specified point.
      </summary>
      <param name="oPoint">
        The position where the line should end, in canvas coordinates. or an array of points,
        in canvas coordinates,  where the line should end, in which case Window:LineTo() acts like a polyline method.
      </param>
      <seealso cref="T:VO.Point" />
      <remarks>
        The current pen position is updated to the line's ending position (as specified by &lt;oPoint&gt; or &lt;aoPoint&gt;).
      </remarks>
    </member>
    <member name="M:VO.Window.ListBoxClick(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when an item in a list box owned by this window is double-clicked.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlEvent">The ControlEvent object that describes which list box contained the item that is double-clicked.</param>
      <seealso cref="T:VO.ControlEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.ListBoxSelect(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when an item in a list box owned by this window is clicked.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlEvent">The ControlEvent object that describes which list box contained the item that was clicked.</param>
      <seealso cref="T:VO.ControlEvent" />
      <example>
        Typical example below of using this method:
        <code language="X#">
          METHOD ListBoxSelect(oControlEvent) CLASS TeamInfo
            LOCAL oControl AS Control
            LOCAL sSym AS SYMBOL
            oControl := IIf(oControlEvent == NULL_OBJECT, NULL_OBJECT, ;
                              oControlEvent:Control)
            SUPER:ListBoxSelect(oControlEvent)
            //Put your changes here
            sSym   := oControl:nameSym
            IF sSym == #cbxTeamNumbers
                IF SELF:cLastTeamNr != SELF:oDCcbxTeamNumbers:Value
                    SELF:cLastTeamNr := SELF:oDCcbxTeamNumbers:Value
                    SELF:BreakDownTeamNumber( SELF:oDCcbxTeamNumbers:Value )
                ENDIF
            ENDIF
        </code></example>
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.ListViewColumnClick(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a list view column header is clicked in a list view control.
      </summary>
      <param name="oListViewColumnClickEvent">The ListViewColumnClickEvent object that describes which list view column of which list view control was clicked.</param>
      <seealso cref="T:VO.ListViewColumnClickEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.ListViewItemChanged(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a list view item has changed.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oListViewItemEvent">The ListViewItemEvent object that describes which list view item has changed.</param>
      <seealso cref="T:VO.ListViewItemEvent" />
      <remarks>
        The ListViewItemChanged event handler notifies a list view control's parent window that an item has changed.
      </remarks>
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.ListViewItemChanging(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the state of a list view item is about to change.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oListViewItemEvent">The ListViewItemEvent object that describes which list view item is about to change.</param>
      <seealso cref="T:VO.ListViewItemEvent" />
      <remarks>
        The ListViewItemChanging event handler notifies a list view control's parent window that an item is about to be changed.
      </remarks>
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.ListViewItemDelete(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a list view item is deleted in a list view control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oListViewDeleteEvent">The ListViewDeleteEvent object that describes which list view item of which list view control was deleted.</param>
      <seealso cref="T:VO.ListViewDeleteEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.ListViewItemDrag(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a list view item is dragged in a list view control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oListViewDragEvent">The ListViewDragEvent object that describes which list view item of which list view control was dragged.</param>
      <seealso cref="T:VO.ListViewDragEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
      <remarks>
        The default implementation of this method checks to see if the listview control has DragDrop enabled, builds and positions the Drag image and
        calls the DragEnter() method on the imagelist.
      </remarks>
    </member>
    <member name="M:VO.Window.ListViewItemEdit(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a list view item is edited in a list view control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oListViewEditEvent">The ListViewEditEvent object that describes which list view item of which list view control was edited.</param>
      <seealso cref="T:VO.ListViewEditEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.ListViewKeyDown(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a key is pressed in a list view control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oListViewKeyEvent">The ListViewKeyEvent object that describes which list view control received a key press.</param>
      <seealso cref="T:VO.ListViewKeyEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.ListViewMouseButtonDoubleClick(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a mouse button is double-clicked in a list view control.  This could be used to invoke an "edit screen" for the selected item, print a report, etc.  See the ListViewMouseButtonDown() method for sample syntax.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oListViewMouseEvent">The ListViewMouseEvent object that describes which list control received a mouse button double-click.</param>
      <seealso cref="T:VO.ListViewMouseEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.ListViewMouseButtonDown(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a mouse button is clicked in a list view control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oListViewMouseEvent">The ListViewMouseEvent object that describes which list control received a mouse button click.</param>
      <seealso cref="T:VO.ListViewMouseEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
      <example>
        Typical example of a ListViewMouseButtonDown usage.  Note that in the example, the item's record number is stored in the "value" of the LVI, whereas the text of the item is stored in the "text" entity.  Obviously this will only work when using a string-type column in the ListView for storing the record number also.
        <code language="X#">
          METHOD ListViewMouseButtonDown(oListViewMouseEvent) CLASS CoachesBrowse
          LOCAL sSym AS SYMBOL
          LOCAL oLVI AS ListViewItem
          SUPER:ListViewMouseButtonDown(oListViewMouseEvent)
          //Put your changes here
          oLVI := oListViewMouseEvent:ListViewItem
          sSym := oListViewMouseEvent:NameSym
          DO CASE
          CASE sSym == #lvCoaches
          IF oLVI != NULL_OBJECT
          IF oListViewMouseEvent:PointOnItem
          SELF:iCoachRec := oLVI:GetValue( #cCoachName )
          SELF:cSelCoach := oLVI:GetText( #cCoachName )
          SELF:oDbCoaches:GoTo( SELF:iCoachRec )
          ENDIF
          ENDIF
          ENDCASE
        </code></example>
    </member>
    <member name="P:VO.Window.Menu">
      <summary>
        The menu currently in use by this window.
      </summary>
      <value>The menu currently in use by this window.</value>
    </member>
    <member name="M:VO.Window.MenuCommand(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when an item on a menu owned by this window is selected.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oMenuCommandEvent">The MenuCommandEvent object that describes which menu and menu command (via the item's ID) generated the event.</param>
      <seealso cref="T:VO.MenuCommandEvent" />
    </member>
    <member name="M:VO.Window.MenuInit(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a pop-up menu owned by this window is about to "pop up."
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oMenuInitEvent">The MenuInitEvent object that describes which menu is about to pop up.</param>
      <seealso cref="T:VO.MenuInitEvent" />
      <remarks>
        This event handler can be used to initialize menu commands, check items, and so forth.
      </remarks>
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.MenuSelect(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when an item on a menu owned by this window is selected.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oMenuSelectEvent">The MenuSelectEvent object that describes which menu and menu command (via the item's ID) generated the event.</param>
      <seealso cref="T:VO.MenuSelectEvent" />
      <remarks>
        One use for this event handler is to provide more extensive help with the user's current selection.  Selecting a menu command does not necessarily imply that it is invoked, only that the menu highlight bar is currently over this item.
      </remarks>
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.MinMaxInfo(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the size or position of a window is about to change (cf WM_GETMINMAXINFO in Win API).
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <remarks>
        The default implementation of this method sets the MinTrackSize property of the MinMaxInfoEvent event to the minsize of the window.
      </remarks>
      <param name="oMinMaxInfoEvent">The MinMaxInfoEvent object that describes the maximised width, height and position of the maximised window in addition to the minimum and maximum height and width of the window.</param>
      <seealso cref="T:VO.MinMaxInfoEvent" />
    </member>
    <member name="P:VO.Window.MinSize">
      <summary>The minimum size for the window</summary>
      <value>The minimum size for the window</value>
    </member>
    <member name="M:VO.Window.ModifyTrayIcon(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Modify the tray icon associated with the window.
      </summary>
      <param name="oTrayIcon">The icon object to add to the tray.</param>
      <param name="dwID">The unique ID of the icon (between 1 and 8000).</param>
      <param name="sToolTip">The tool tip string to be displayed for this icon.</param>
      <remarks>
        <note type="tip">
          If modern versions of window , the tool tip will support line breaks by using CRLF.
          On older versions the CRLF is automatically replaced with a space.
        </note>
      </remarks>
    </member>
    <member name="M:VO.Window.MonthCalSelectionChanged(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the selection of a MonthCalendar control is changed.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="_oMonthCalSelectionEvent">The MonthCalSelectionEvent object that describes the changed selection.</param>
      <seealso cref="T:VO.MonthCalSelectionEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.MouseButtonDoubleClick(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the mouse pointer is positioned over the window and a mouse button is double-clicked.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oMouseEvent">The MouseEvent object that contains information about the state of the mouse when the button was double-clicked.</param>
      <seealso cref="T:VO.MouseEvent" />
      <remarks>
        MouseButtonDoubleClick() often occurs between MouseButtonDown() and MouseButtonUp() event handlers.
      </remarks>
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.MouseButtonDown(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the mouse pointer is positioned over the window and a mouse button is clicked.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oMouseEvent">The MouseEvent object that contains information about the state of the mouse when the button was clicked.</param>
      <seealso cref="T:VO.MouseEvent" />
      <remarks>
        Use the Window:MouseTrapOn() method to force MouseEvents generated outside the canvas area to be directed to this window.
      </remarks>
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.MouseButtonUp(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the mouse pointer is positioned over the window and a mouse button is released.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oMouseEvent">The MouseEvent object that contains information about the state of the mouse when the button was released.</param>
      <seealso cref="T:VO.MouseEvent" />
      <remarks>
        Do not assume Window:MouseButtonUp() is called immediately after Window:MouseButtonDown().  Other MouseEvents can be generated during this time.
        In some cases, there may be no Window:MouseButtonUp() events directed to the window for a corresponding Window:MouseButtonDown().
        This can occur if the mouse button is clicked while over the window, but released after the mouse has moved off the window.  
        Use Window:MouseTrapOn() to direct all MouseEvents to this window. <br />
        This event also detects if a MouseDrag was active and ends the drag.

      </remarks>
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.MouseDrag(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a mouse with one or more buttons clicked is moved in the window.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oMouseEvent">The MouseEvent object containing information on the location and state of the buttons when the mouse was dragged.</param>
      <seealso cref="T:VO.MouseEvent" />
      <remarks>
        This method moves the drag imagelist to the new position.
      </remarks>
    </member>
    <member name="M:VO.Window.MouseMove(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the mouse is moved in the window.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oMouseEvent">The MouseEvent object containing information on the location of the mouse when it was moved.</param>
      <seealso cref="T:VO.MouseEvent" />
      <remarks>
        This event occurs when the mouse is moved with no mouse buttons clicked.
      </remarks>
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.MouseTrapOff">
      <summary>
        Disable the window from trapping MouseEvents generated outside itself.
      </summary>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.MouseTrapOn">
      <summary>
        Enable this window to trap MouseEvents generated outside itself.
      </summary>
      <remarks>
        Turn mouse trapping off before disabling or deactivating this window; otherwise, other windows cannot receive MouseEvents.
      </remarks>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.Move(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the window is moved (either by the user or by the application).
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oMoveEvent">The MoveEvent object that describes the window movement.</param>
      <seealso cref="T:VO.MoveEvent" />
    </member>
    <member name="M:VO.Window.MoveTo(XSharp.__Usual)">
      <summary>
        Move the current pen to a point on the window's canvas area.
      </summary>
      <param name="oPoint">The position of the pen, in canvas coordinates.</param>
      <returns>
        A point representing the previous location of the pen, in canvas coordinates.
      </returns>
      <remarks>
        The pen location may not be remembered between event handlers.
      </remarks>
    </member>
    <member name="P:VO.Window.Origin">
      <summary>
        The point representing the new location of this window, in the canvas coordinates of its owner.
      </summary>
      <value>The point representing the new location of this window, in the canvas coordinates of its owner.</value>
      <example>
        The following example sets the origin of a window object:
        <code language="X#">oWin:Origin := Point{nLeft,nBottom}</code></example>
    </member>
    <member name="P:VO.Window.Owner">
      <summary>
        The owner of the window, either a Window or App object.
      </summary>
      <value>The owner of the window, either a Window or App object.</value>
    </member>
    <member name="P:VO.Window.OwnerAlignment">
      <summary>The Owner Alignment value for the window, which is used when the window is a subwindow on another window.</summary>
      <value>The Owner Alignment value for the window</value>
    </member>
    <member name="M:VO.Window.PaintBackground(XSharp.__Usual)">
      <summary>
        Paint the background for a window with the brush or background object that was specified by the user.<br /><br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="hDC">The device context of the window on which the background must be painted.</param>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.PaintBoundingBox(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Paint a rectangular area in the window using a specified painting method.
      </summary>
      <param name="oBoundingBox">The bounding box (group or character box) representing the window area to be painted, in canvas coordinates.</param>
      <param name="kPaintMode">
        The constant that represents how the window area is painted:
        <pre>
          Constant      Description
          PAINTFILL     Fills the entire rectangle using the currently selected brush.  This is the default.
          PAINTFRAME    Frames the entire rectangle using the currently selected pen
          PAINTINVERT   Inverts the entire rectangle
        </pre></param>
      <returns>NIL</returns>
    </member>
    <member name="P:VO.Window.Pen">
      <summary>
        The pen assigned to the window and used in subsequent line and rectangle drawing operations; it should not be deleted while it is the current selection.
      </summary>
      <value>The pen assigned to the window and used in subsequent line and rectangle drawing operations; it should not be deleted while it is the current selection.</value>
    </member>
    <member name="P:VO.Window.Pointer">
      <summary>
        The pointer used by the window to represent the mouse when it enters the window.
      </summary>
      <value>The pointer used by the window to represent the mouse when it enters the window.</value>
    </member>
    <member name="M:VO.Window.PostInit">
      <summary>
        Implement customized initialization code for the window.
      </summary>
      <remarks>
        This method is used to customize the initialization code for a window.  
        The customized initialization code will not be overridden by the Window Editor's default initialization code.
        A call to PostInit() is automatically generated at the end of the Init() method.
        You can customize the code generation by changing the [PostInitCall] and [PostInit] sections
        in your CAVOWED.TPL file.  Note that PreInit() is always called prior to PostInit(). <br />
        The default implementation of PostInit() in this class is empty.
      </remarks>
    </member>
    <member name="M:VO.Window.PreInit">
      <summary>
        Implement customized initialization code for the window.
      </summary>
      <remarks>
        This method is used to customize the initialization code for a window.  
        The customized initialization code will not be overridden by the Window Editor's default initialization code.
        A call to PreInit() is automatically generated at the beginning of the Init() method.  
        You can customize the code generation by changing the [PreInitCall] and [PreInit] sections
        in your CAVOWED.TPL file.  Note that only class variables are accessible in the PreInit() method,
        no window controls are visible until the PostInit() method itself is called. <br />
        The default implementation of PostInit() in this class is empty.
        <note type="tip">
          In .Net it is normally not allowed or recommended to run code in a class before the parent constructor is called.
          The generated code in the Window editor does this (it calls PreInit before the SUPER() call). We advise you to
          be very careful not to touch protected instance variables inherited from parent classes, since these may not be
          initialized and/or values that you assign to them may be overwritten in the constructor of the parent class.
        </note></remarks>
    </member>
    <member name="M:VO.Window.PreMenuCommand">
      <summary>
        Process menu events before the normal MenuCommand method is called.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <remarks>
        This method can be written at the Window level to process menu commands. The window:PreMenuCommand( ) method will be called if it exists to process menu events before the normal MenuCommand( ) methods are called.
        The method must return a logic –
        TRUE – If you have processed the MenuCommand.
        FALSE – If you want the normal MenuCommand to run as well.
      </remarks>
    </member>
    <member name="M:VO.Window.Print(XSharp.__Usual)">
      <summary>
        Print the contents of the window.
      </summary>
      <param name="oDevice">The PrintingDevice object that will receive the output.  If omitted, the default printer driver is used.</param>
      <seealso cref="T:VO.PrintingDevice" />
      <returns>
        TRUE if successful; otherwise, FALSE.
      </returns>
      <remarks>The default implementation of this method creates a Butmap of the surface of the window and sends that to the default printer.</remarks>
    </member>
    <member name="M:VO.Window.QueryClose(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked just before the window closes to confirm if the application really wants to close the window.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
        <note type="tip">If you reimplement this method in your subclass, it is recommended that you first call SUPER:QueryClose() within the method to obtain its default behavior.</note></summary>
      <param name="oEvent">An empty event required to maintain the protocol that all event handlers have exactly one event as their argument.</param>
      <seealso cref="T:VO.Event" />
      <returns>
        The method inside the window class always returns TRUE.
        If you override this method in your subclass then you must return TRUE if the window is to be closed; otherwise, return FALSE.
      </returns>
      <remarks>
        When a user tries to close an application by selecting the Close menu command from a system menu (or by using another method to end the session), the system calls each window's QueryClose() event handler.
      </remarks>
      <example>
        This example displays a message box to confirm that a user wants to quit the application.  If a user chooses YES, TRUE is returned (otherwise, FALSE is returned).
        <code language="X#">
          METHOD QueryClose(oEvent) CLASS TopAppWindow
            oTB := TextBox{SELF, "Quit", "Do you really want to quit?"}
            oTB:TYPE := BOXICONQUESTIONMARK + BUTTONYESNO
            IF (oTB:Show() = BOXREPLYYES)
               RETURN TRUE // Quit application.
            ELSE
               RETURN FALSE
               // Don't quit the application.
            END
        </code></example>
    </member>
    <member name="M:VO.Window.RegisterTimer(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Register a timer method to be invoked for the window.
      </summary>
      <param name="nInterval">Time interval, in seconds, between calls to the Timer() method of the window.</param>
      <param name="lOneTime">Logical value indicating if the timer is called just once (TRUE), or multiple times (FALSE).  If omitted, the default is FALSE.</param>
    </member>
    <member name="M:VO.Window.RePaint">
      <summary>
        Send an ExposeEvent to repaint the window's canvas area.
      </summary>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.RepaintBoundingBox(XSharp.__Usual)">
      <summary>
        Repaint a rectangular area in the window.
      </summary>
      <param name="oBoundingBox">The bounding box (group or character box) representing the window area to be repainted, in canvas coordinates.</param>
      <remarks>
        This method should be avoided within an Expose() event handler.  If it is used, make sure the application does not fall into an infinite loop.
      </remarks>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.Resize(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the window changes size.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oResizeEvent">The ResizeEvent object that describes the new dimensions of the window canvas area.</param>
      <seealso cref="T:VO.ResizeEvent" />
      <remarks>
        In the Window:Resize() event handler, calling Window:Size should be used with caution to avoid entering an infinite loop. <br />
        If the window has a Toolbar then this method will also make sure that the toolbar is resized as well.
      </remarks>
    </member>
    <member name="M:VO.Window.RichEditProtected(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when an attempt is made to modify text that is protected in a rich edit control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oRichEditProtectEvent">The RichEditProtectEvent object that describes which rich edit control received a protect event.</param>
      <seealso cref="T:VO.RichEditProtectEvent" />
      <returns>This method always sets the EventReturnValue to 1 and returns 0</returns>
    </member>
    <member name="M:VO.Window.RichEditSelectionChange(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the current selection in a rich edit control is changed.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oRichEditSelectionEvent">The RichEditSelectionEvent object that describes which rich edit had its current selection change.</param>
      <seealso cref="T:VO.RichEditSelectionEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.RichEditUndoLost(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the undo state in a rich edit control can no longer be maintained.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlNotifyEvent">The ControlNotifyEvent object that describes which rich edit has lost its undo state.</param>
      <seealso cref="T:VO.ControlNotifyEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.Scroll(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Scroll a rectangular area in the window a specified amount, in a specified direction, and optionally clip the area when scrolled.
      </summary>
      <param name="oDimension">The dimension representing the amount to move the rectangular scroll area (relative to its origin).  Positive width values scroll to the right while negative width values scroll to the left.  In addition, positive height values scroll upwards while negative height values scroll downwards.</param>
      <param name="oBoundingBox">The bounding box representing the rectangular window area, in canvas coordinates.  If omitted, the default is the canvas area of the screen.</param>
      <param name="lClip">Indicates whether to clip the rectangular area when scrolled.  TRUE clips the area; FALSE does not.  If omitted, the default is TRUE.</param>
      <remarks>
        The clip region is an area that can receive output from the system.
      </remarks>
    </member>
    <member name="M:VO.Window.SetAlignStartSize(XSharp.__Usual)">
      <summary>This method is used to register the start size of a window which is used later to resize controls that have their OwnerAlignment property set.</summary>
      <param name="oSize">The dimenstion object that contains the size that should be stored. If this object is not passed then the method will calculate the size of the window and store that for future reference.</param>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.SetBackgroundBrush(XSharp.__Usual)">
      <summary>
        Set the background brush used to paint the window.
      </summary>
      <param name="dwNew">The new brush to use. The default is COLOR_3DSHADOW.</param>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.SetExStyle(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the extended style of a window.
      </summary>
      <param name="dwSetStyle">The extended style to set.</param>
      <param name="lEnable">A logical value. TRUE turns the style on, FALSE turns it off.</param>
      <returns>The new ExStyle of the window (calculated by taking the existing style and enableing or disabling the passed style value).</returns>
    </member>
    <member name="M:VO.Window.SetFocus">
      <summary>
        Set the keyboard focus to this window.
      </summary>
    </member>
    <member name="M:VO.Window.SetHandle(XSharp.__Usual)">
      <summary>This methdod allows to set or change the handle of the window. This is normally done right after the window is created.</summary>
      <param name="hNewWnd">The new window handle for the window.</param>
      <returns>The windows handle.</returns>
      <remarks>DO NOT CHANGE THE WINDOW HANDLE IF YOU DON'T KNOW WHAT YOU ARE DOING !</remarks>
    </member>
    <member name="M:VO.Window.SetStyle(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Set the styles for the window.
      </summary>
      <param name="dwSetStyle">The X# style constant or Windows API style constant to set.</param>
      <param name="lEnable">Logical value indicating whether the style should be enabled (TRUE) or disabled(FALSE).  If omitted, the default is TRUE.</param>
      <returns>
        <returns>The new Style of the window (calculated by taking the existing style and enableing or disabling the passed style value).</returns>
      </returns>
    </member>
    <member name="M:VO.Window.Show(XSharp.__Usual)">
      <summary>
        Display this window.
      </summary>
      <param name="kShowState">The constant that represents how the window is shown.  Valid values are:</param>
      <remarks>
        <pre>
          Constant		  Description
          SHOWCENTERED	Shows the window centered within its owner window.  If the owner is the desktop, the window is centered on the screen.
          SHOWICONIZED	Shows the window initially as an icon
          SHOWNORMAL	  Shows the window on its owner, in a size chosen by the owner.  If the owner is the desktop,
          the window appears quite large but may not fill the whole desktop.  You can control the window's
          size precisely, if you want, with Window:Size and Window:Origin.  This is the default.
          SHOWZOOMED    Shows the window at the maximum size allowed by its owner.  If the owner is the desktop, the window occupies
          the whole desktop.
        </pre>
      </remarks>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.ShowBalloonTrayTip(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Display a balloon tip for an icon in the tray that is associated with this window.
      </summary>
      <param name="oTrayIcon">The icon to be displayed in the tray.</param>
      <param name="dwID">The unique ID of the icon (between 1 and 8000).</param>
      <param name="sHeading">The heading to be displayed in the balloon. This title appears in boldface above the text. It can have a maximum of 63 characters.</param>
      <param name="sToolTip">The text to be displayed in the balloon. In Shell version 5 and above, the maximum size is 128 charecters. Below Shell version 5, the maximum is 64 charecters.</param>
      <param name="dwTimeOut">
        The length of time to display the balloon before it is removed if it is not dismissed by the user.
        The system enforces minimum and maximum timeout values. dwTimeout values that are too large are set to the maximum value and values that are too small default to the minimum value.
        This is set in milliseconds.
      </param>
      <param name="dwInfo">
        Flags that can be set to add an icon to a balloon ToolTip.
        Valid values are:
        <pre>
          Constant      Description
          NIIF_ERROR    An error icon.
          NIIF_INFO     An information icon.
          NIIF_NONE     No icon.
          NIIF_WARNING  A warning icon.
          NIIF_NOSOUND  Do not play the associated sound.
        </pre></param>
      <returns>The result of the call to Shell_NotifyIcon() (see the WIN32 API)</returns>
    </member>
    <member name="P:VO.Window.Size">
      <summary>
        The dimension representing the size of this window.
      </summary>
      <value>The dimension representing the size of this window.</value>
      <example>
        The following example sets the size of a window object:
        <code language="X#">oWin:Size := Dimension{nWidth,nHeight}</code></example>
    </member>
    <member name="M:VO.Window.SizeText(XSharp.__Usual)">
      <summary>
        Determine the space needed to print a string on the window in the current font.
      </summary>
      <param name="cTextToSize">The string to be printed.</param>
      <returns>
        A dimension representing the space required to print the string on this window using the current font.
      </returns>
    </member>
    <member name="M:VO.Window.StatusMessage(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        This is an empty method, since the Window class does not have a statusbar.
      </summary>
      <param name="oHL">The hyperlabel containing a description (HyperLabel:Description) for the status message or the status message as a string.</param>
      <param name="ntype">
        The constant value indicating the type and priority of the message to be displayed on the status bar.  
        The highest priority message (MESSAGEMENU) always takes precedence over and replaces lower priority messages. See table in the remarks section for more info.
      </param>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.SysLinkSelect(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a a user clicks on a SysLink control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
      <param name="oSysLinkSelectEvent">The SysLinkSelectEvent object that describes the control on which the user clicked.</param>
      <seealso cref="T:VO.SysLinkSelectEvent" />
    </member>
    <member name="M:VO.Window.TabKeyDown(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a key press occurs in a tab control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlNotifyEvent">The ControlNotifyEvent object that describes which tab control received a key press.</param>
      <seealso cref="T:VO.ControlNotifyEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.TabSelect(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a tab is selected in a tab control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlNotifyEvent">The ControlNotifyEvent object that describes which tab control's tab has been selected.</param>
      <seealso cref="T:VO.ControlNotifyEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.TabSelectionChanging(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a tab selection is changing in a tab control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlNotifyEvent">The ControlNotifyEvent object that describes which tab control's selected tab is changing.</param>
      <seealso cref="T:VO.ControlNotifyEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="P:VO.Window.TextColor">
      <summary>
        Uses a pen object and builds a pen in this window.
      </summary>
      <value>Uses a pen object and builds a pen in this window.</value>
    </member>
    <member name="M:VO.Window.TextPrint(XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Display a given string on the window at a specified location using the current font and the current pen color.
      </summary>
      <param name="cText">The string to be printed.</param>
      <param name="oPoint">The position of the string's origin, in canvas coordinates.</param>
    </member>
    <member name="M:VO.Window.Timer">
      <summary>
        Provide a method to be invoked at specific intervals defined when the timer is registered though the RegisterTimer() method.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
    </member>
    <member name="P:VO.Window.ToolBar">
      <summary>
        The toolbar in use by the window.
      </summary>
      <value>The toolbar in use by the window.</value>
    </member>
    <member name="M:VO.Window.ToolBarHeightChanged(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the height of the window's toolbar is changed.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oControlNotifyEvent">The ControlNotifyEvent object that describes the changes to the toolbar height.</param>
      <seealso cref="T:VO.ControlNotifyEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.ToTop">
      <summary>
        Move this window "to the front" of the windows lying on the desktop, giving it the input focus.
      </summary>
      <remarks>
        This makes the window fully visible.
      </remarks>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.TrayIconBalloonClicked(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a tray icon balloon is clicked.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="dwID">The ID that was associated with the tray icon balloon.</param>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.TrayIconBalloonShown(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a tray icon balloon is shown.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="dwID">The ID that was associated with the tray icon balloon.</param>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.TrayIconBalloonTimeOut(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a tray icon balloon times out.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="dwID">The ID that was associated with the tray icon balloon.</param>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.TrayIconClicked(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a user clicks on a tray Icon
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="dwID">The ID that was associated with the tray icon balloon.</param>
      <param name="lRightButton">TRUE when the user clicked with the Right Mouse button</param>
      <param name="lDoubleClick">TRUE when the user double clicked</param>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.TreeViewItemDelete(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a tree view item is deleted in a tree view control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oTreeViewDeleteEvent">The TreeViewDeleteEvent object that describes which tree view item of which tree view control was deleted.</param>
      <seealso cref="T:VO.TreeViewDeleteEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.TreeViewItemDrag(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a tree view item is dragged in a tree view control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oTreeViewDragEvent">The TreeViewDragEvent object that describes which tree view item of which tree view control was dragged.</param>
      <seealso cref="T:VO.TreeViewDragEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.TreeViewItemEdit(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a tree view item is edited in a tree view control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oTreeViewEditEvent">The TreeViewEditEvent object that describes which tree view item of which tree view control was edited.</param>
      <seealso cref="T:VO.TreeViewEditEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.TreeViewItemExpanded(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a tree view item is expanded in a tree view control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oTreeViewExpandedEvent">The TreeViewExpandedEvent object that describes which tree view item of which tree view control was expanded.</param>
      <seealso cref="T:VO.TreeViewExpandedEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.TreeViewItemExpanding(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a tree view item is expanding in a tree view control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oTreeViewExpandingEvent">The TreeViewExpandingEvent object that describes which tree view item of which tree view control is expanding.</param>
      <seealso cref="T:VO.TreeViewExpandingEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.TreeViewKeyDown(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a key is pressed in a tree view control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oTreeViewKeyEvent">The TreeViewKeyEvent object that describes which tree view control received a key press.</param>
      <seealso cref="T:VO.TreeViewKeyEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.TreeViewMouseButtonDoubleClick(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a mouse button is double-clicked in a tree view control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oTreeViewMouseEvent">The TreeViewMouseEvent object that describes which tree view control received a mouse button double-click.</param>
      <seealso cref="T:VO.TreeViewMouseEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.TreeViewMouseButtonDown(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a mouse button is clicked in a tree view control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oTreeViewMouseEvent">The TreeViewMouseEvent object that describes which tree view control received a mouse button click.</param>
      <seealso cref="T:VO.TreeViewMouseEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.TreeViewSelectionChanged(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the selection has changed from one tree view item to another in a tree view control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oTreeViewSelectionEvent">The TreeViewSelectionEvent object that describes which tree view control's selected item was changed.</param>
      <seealso cref="T:VO.TreeViewSelectionEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.TreeViewSelectionChanging(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when the selection is changing from one tree view item to another in a tree view control.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oTreeViewSelectionEvent">The TreeViewSelectionEvent object that describes which tree view control's selected item is changing.</param>
      <seealso cref="T:VO.TreeViewSelectionEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.Update">
      <summary>
        Update the client area of the specified window.
      </summary>
      <remarks>
        This method utilizes the Windows API UpdateWindow() function which updates the client area of the specified window by sending a WM_PAINT message to the window.  The message is sent directly to the window procedure of the specified window, thus bypassing the application queue.
        The Window:Update() method is automatically called upon when terminating the Expose().
        <note type="tip">This method should not be used within an Expose() event handler.</note></remarks>
      <returns>NIL</returns>
    </member>
    <member name="M:VO.Window.VerticalScroll(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a vertical scroll bar is scrolled.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oScrollEvent">The ScrollEvent object that describes the scroll type and new position.</param>
      <seealso cref="T:VO.ScrollEvent" />
      <remarks>
        The default behavior for this event handler is to update the thumb position of the scrollbar; this can be changed using your own implementation of the handler.  This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects.  If the application has horizontal scroll bars, use a HorizontalScrollBar event handler.
      </remarks>
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.VerticalSlide(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a vertical slider's thumb is dragged either by the mouse or the keyboard.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <param name="oSliderEvent">The SliderEvent object that describes which vertical slider's thumb was dragged.</param>
      <seealso cref="T:VO.SliderEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="M:VO.Window.VerticalSpin(XSharp.__Usual)">
      <summary>
        Provide a method that is invoked when a vertical spinner is spun.
        <br />Important!  This is a callback method used by X#.  Normally, it should not be called in your application code.
      </summary>
      <remarks>
        The default behavior for this event handler is to update the position of the spinner; this can be changed using your own implementation of the handler.  This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects.  If the application has vertical scroll bars, use a WindowVerticalScrollBar event handler.
      </remarks>
      <param name="oSpinnerEvent">The SpinnerEvent object that describes which vertical spinner was spun.</param>
      <seealso cref="T:VO.SpinnerEvent" />
      <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    </member>
    <member name="P:VO.Window.WindowArea">
      <summary>
        The bounding box representing the minimal area which encloses the entire window (canvas area and non-canvas area), in canvas coordinates.
      </summary>
      <value>The bounding box representing the minimal area which encloses the entire window (canvas area and non-canvas area), in canvas coordinates.</value>
    </member>
    <member name="T:VO.WindowHorizontalScrollBar">
      <summary>
        Create a window horizontal scroll bar.
      </summary>
      <remarks>
        There are two types of horizontal scroll bars in X#: regular (created with CLASS HorizontalScrollBar) and window (created with the AppWindow:EnableHorizontalScroll() method).  Both types have an owner window and can be manipulated using Window:HorizontalScroll().  However, a window horizontal scroll bar differs in that it automatically appears aligned along the bottom of its owner window's canvas area and also resizes itself according to the size of its owner window.
        <note type="tip">By default, Window:HorizontalScroll() updates the thumb position in the scroll bar; if desired, you can change this by using your own implementation of this handler.</note></remarks>
    </member>
    <member name="M:VO.WindowHorizontalScrollBar.#ctor(XSharp.__Usual)">
      <summary>
        Construct a window horizontal scroll bar.
      </summary>
      <param name="oOwner">The window that owns the window horizontal scroll bar.</param>
    </member>
    <member name="P:VO.WindowHorizontalScrollBar.Background">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.
      </summary>
      <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.</value>
    </member>
    <member name="M:VO.WindowHorizontalScrollBar.Background Access/Assign_2">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.
      </summary>
    </member>
    <member name="P:VO.WindowHorizontalScrollBar.ControlID">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.
      </summary>
      <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.</value>
    </member>
    <member name="M:VO.WindowHorizontalScrollBar.ControlID Access_2">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.
      </summary>
    </member>
    <member name="M:VO.WindowHorizontalScrollBar.Destroy">
      <summary>
        Provide a method to de-instantiate a WindowHorizontalScrollBar object.
      </summary>
      <remarks>
        This method can be used when a WindowHorizontalScrollBar object is no longer needed.  WindowHorizontalScrollBar:Destroy() de-instantiates the WindowHorizontalScrollBar object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.WindowHorizontalScrollBar.Destroy Method_2">
      <summary>
        Provide a method to de-instantiate a WindowHorizontalScrollBar object.
      </summary>
      <remarks>
        This method can be used when a WindowHorizontalScrollBar object is no longer needed.  WindowHorizontalScrollBar:Destroy() de-instantiates the WindowHorizontalScrollBar object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="M:VO.WindowHorizontalScrollBar.Init Method_2">
      <summary>
        Construct a window horizontal scroll bar.
      </summary>
      <param name="oOwner">The window that owns the window horizontal scroll bar.</param>
    </member>
    <member name="P:VO.WindowHorizontalScrollBar.Origin">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.
      </summary>
      <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.</value>
    </member>
    <member name="M:VO.WindowHorizontalScrollBar.Origin Access/Assign_2">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.
      </summary>
    </member>
    <member name="M:VO.WindowHorizontalScrollBar.SetFocus">
      <summary>
        This method is inherited from the Control class, but does not apply to WindowHorizontalScrollBar.
      </summary>
    </member>
    <member name="M:VO.WindowHorizontalScrollBar.SetFocus Method_2">
      <summary>
        This method is inherited from the Control class, but does not apply to WindowHorizontalScrollBar.
      </summary>
    </member>
    <member name="P:VO.WindowHorizontalScrollBar.Size">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.
      </summary>
      <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.</value>
    </member>
    <member name="M:VO.WindowHorizontalScrollBar.Size Access/Assign_2">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.
      </summary>
    </member>
    <member name="T:VO.WindowScrollBar">
      <summary>
        Abstract class for Windows Scrollbars
      </summary>
      <remarks>
        There are two types of horizontal scroll bars in X#: regular (created with CLASS HorizontalScrollBar) and window (created with the AppWindow:EnableHorizontalScroll() method).  Both types have an owner window and can be manipulated using Window:HorizontalScroll().  However, a window horizontal scroll bar differs in that it automatically appears aligned along the bottom of its owner window's canvas area and also resizes itself according to the size of its owner window.
        <note type="tip">By default, Window:HorizontalScroll() updates the thumb position in the scroll bar; if desired, you can change this by using your own implementation of this handler.</note></remarks>
    </member>
    <member name="M:VO.WindowScrollBar.#ctor(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <inheritdoc />
    </member>
    <member name="M:VO.WindowStyle.#ctor">
      <exclude />
    </member>
    <member name="M:VO.WindowStyle.ClassName(System.Void*)">
      <exclude />
    </member>
    <member name="M:VO.WindowStyle.SetExStyle(System.Void*,System.UInt32,System.Boolean)">
      <exclude />
    </member>
    <member name="M:VO.WindowStyle.SetStyle(System.Void*,System.UInt32,System.Boolean)">
      <exclude />
    </member>
    <member name="T:VO.WindowVerticalScrollBar">
      <summary>
        Create a window vertical scroll bar.
      </summary>
      <remarks>
        There are two types of vertical scroll bars in X#: regular (created with CLASS VerticalScrollBar) and window (created with the AppWindow:EnableVerticalScroll() method).  Both types have an owner window and can be manipulated using Window:VerticalScroll().  However, a window vertical scroll bar differs in that it automatically appears aligned along the right of its owner window's canvas area and also resizes itself according to the size of its owner window.
        <note type="tip">By default, Window:VerticalScroll() updates the thumb position of the scroll bar; if desired, you can change this by using your own implementation of this handler.</note></remarks>
    </member>
    <member name="M:VO.WindowVerticalScrollBar.#ctor(XSharp.__Usual)">
      <summary>
        Construct a window vertical scroll bar.
      </summary>
      <param name="oOwner">The window that owns the window vertical scroll bar.</param>
    </member>
    <member name="P:VO.WindowVerticalScrollBar.Background">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.
      </summary>
      <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.</value>
    </member>
    <member name="P:VO.WindowVerticalScrollBar.ControlID">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.
      </summary>
      <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.</value>
    </member>
    <member name="M:VO.WindowVerticalScrollBar.Destroy">
      <summary>
        Provide a method to de-instantiate a WindowVerticalScrollBar object.
      </summary>
      <remarks>
        This method can be used when a WindowVerticalScrollBar object is no longer needed.  WindowVerticalScrollBar:Destroy() de-instantiates the WindowVerticalScrollBar object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
      </remarks>
    </member>
    <member name="P:VO.WindowVerticalScrollBar.Origin">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.
      </summary>
      <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.</value>
    </member>
    <member name="M:VO.WindowVerticalScrollBar.SetFocus">
      <summary>
        This method is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.
      </summary>
    </member>
    <member name="P:VO.WindowVerticalScrollBar.Size">
      <summary>
        This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.
      </summary>
      <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.</value>
    </member>
    <member name="T:VOGUIClasses.Functions">
      <summary>
        This compiler generated class contains all the functions, globals and defines that are defined in the VOGUIClasses assembly.
      </summary>
    </member>
    <member name="M:VOGUIClasses.Functions.ApplicationExec(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="kExecType">** missing parameter documentation **</param>
    </member>
    <member name="M:VOGUIClasses.Functions.DIBCreateFromFile(XSharp.__Psz)">
      <summary>
        Create a device independent bitmap (DIB) from an image file.
      </summary>
      <param name="pszFName">Name of the new DIB file.</param>
      <returns>
        Pointer to DIB data which can be displayed; otherwise, NULL_PTR.
      </returns>
      <remarks>
        DIBCreateFromFile() creates a device independent bitmap (.DIB file) from an image file of the following types: .JPG, .TIF, .BMP, .TGA, .PNG, .PCX, or .PCT.
      </remarks>
      <example></example>
      <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromPTR">DIBCreateFromPTR</seealso>
      <seealso cref="O:VOGUIClasses.Functions.DIBDelete">DIBDelete</seealso>
    </member>
    <member name="M:VOGUIClasses.Functions.DIBCreateFromPTR(System.Byte*,System.Int32)">
      <summary>
        Convert an image file to a device independent bitmap (DIB).
      </summary>
      <param name="pbImage">Pointer to the first byte of image data.</param>
      <param name="nSize">Size (number of bytes) of image data.</param>
      <returns>
        Pointer to DIB data which can be displayed; otherwise, NULL_PTR.
      </returns>
      <remarks>
        DIBCreateFromPtr() converts an image file of type .JPG, .TIF, .BMP, .TGA, .PNG, .PCX, or .PCT into a device independent bitmap (.DIB file).
      </remarks>
      <example>
        The following sample converts a file, test.jpg, and displays the DIB within a TopAppWindow:
        <code language="X#">
          METHOD Start() CLASS App
          LOCAL oWin
          AS MyWindow
          LOCAL hf  
          AS PTR
          LOCAL nSize AS INT
          LOCAL pDib
          AS PTR
          WCSetCoordinateSystem(WCWindowsCoordinates)
          InitializeCAPaint()
          hf := FOpen("test.jpg")
          IF hf != F_ERROR
          nSize := FSeek(hf, 0, FS_END)
          FSeek(hf, 0, FS_SET)
          pDib := MemAlloc(nSize)
          IF FRead3(hf, pDib, nSize) == nSize
          oWin := MyWindow{ SELF, pDib, nSize }
          oWin:Show(SHOWCENTERED)
          ENDIF
          FClose(hf)
             SELF:Exec()
             oWin:Axit()
          MemFree(pDib)
          ENDIF
          CLASS MyWindow INHERIT TopAppWindow
          PROTECT pBitMap   AS PTR
          PROTECT lBitMap   AS LOGIC
          CONSTRUCTOR(oParent, xFile, nSize)
          LOCAL pBmiH     AS _WINBITMAPINFO
          LOCAL nHeight   AS INT
          LOCAL nWidth  
          AS INT
          LOCAL oPOint  
          AS POINT
          LOCAL hWnd    
          AS PTR
          LOCAL cx      
          AS INT
          LOCAL cy      
          AS INT
          LOCAL cr        IS _WINRECT
          LOCAL wr        IS _WINRECT
          SUPER:Init(oParent)
          SELF:QuitOnClose := TRUE
          IF IsPtr(xFile) .AND. IsNumeric(nSize)
          SELF:pBitMap := DIBCreateFromPtr(xFile, nSize)
          ENDIF
          IF pBitMap = NULL_PTR
          MessageBox(0, "Error reading image", "ERROR ", MB_ICONSTOP)
          ELSE
          SELF:lBitmap := .T.
          oPoint  := SELF:Origin
          pBmiH   := DIBGetInfo(pBitMap)
          nHeight := pBmiH.bmiHeader.biHeight
          nWidth  := pBmiH.bmiHeader.biWidth
          hWnd    := SELF:Handle()
          GetWindowRect(hWnd, @wr)
          GetClientRect(hWnd, @cr)
          cx := wr.right  - wr.left - cr.right
          cy := wr.bottom - wr.top  - cr.bottom
          SELF:Size   := DIMension{nWidth + cx, nHeight + cy}
          SELF:Origin := oPoint
          ENDIF
          RETURN SELF

          METHOD Expose(oExposeEvent)
          SUPER:Expose(oExposeEvent)
          IF SELF:lBitMap
          DIBShow( SELF:pBitMap, NULL_PTR )
          ENDIF
          DESTRUCTOR()        CLASS MyWindow
          DIBDelete(SELF:pBitmap)
          END CLASS
        </code></example>
      <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromFile">DIBCreateFromFile</seealso>
      <seealso cref="O:VOGUIClasses.Functions.DIBDelete">DIBDelete</seealso>
    </member>
    <member name="M:VOGUIClasses.Functions.DIBDelete(System.Void*)">
      <summary>
        Destroy a DIB created either by DIBCreateFromFile() or DIBCreateFromPtr().
      </summary>
      <param name="pWinBmp">Pointer to DIB data.</param>
      <returns></returns>
      <remarks>
        DIBDelete() destroys a DIB created by DIBCreateFromFile() or DIBCreateFromPtr().
      </remarks>
      <example>
        See the DIBCreateFromPtr() example.
      </example>
      <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromFile">DIBCreateFromFile</seealso>
      <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromPTR">DIBCreateFromPtr</seealso>
    </member>
    <member name="M:VOGUIClasses.Functions.DIBGetInfo(System.Void*)">
      <summary>
        Retrieve a pointer to the BITMAPINFO structure of a DIB.
      </summary>
      <param name="pWinBmp">Pointer to DIB data.</param>
      <returns>
        Pointer to the BITMAPINFO structure, if successful; otherwise, NULL_PTR.
      </returns>
      <remarks>
        DIBGetInfo() retrieves a pointer to the BITMAPINFO structure of a DIB.
      </remarks>
      <example>
        See the DIBCreateFromPtr() example.
      </example>
      <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromPTR">DIBCreateFromPtr</seealso>
    </member>
    <member name="M:VOGUIClasses.Functions.DIBSaveAs(System.Void*,XSharp.__Psz)">
      <summary>
        Save the DIB to a file.
      </summary>
      <param name="pWinBmp">Pointer to DIB data.</param>
      <param name="pszFName">Name of the new DIB file.</param>
      <returns></returns>
      <remarks>
        DIBSaveAs() saves the DIB as a file.
      </remarks>
      <example>
        The following sample saves the image, test.jpg, as file, test.dib:
        <code language="X#">
          FUNC Start()
          LOCAL pDib	AS PTR
        </code><code language="X#">
          pDib := DIBCreateFromFile("c:\test.jpg")
          IF pDib = NULL_PTR
          DIBSaveAs(pDib, "c:\test.dib")
          DIBDelete(pDib)
          ENDIF
          WAIT
        </code><code language="X#">	RETURN </code></example>
      <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromFile">DIBCreateFromFile</seealso>
    </member>
    <member name="M:VOGUIClasses.Functions.DIBShow(System.Void*,System.Void*)">
      <summary>
        Display the DIB within the specified window.
      </summary>
      <param name="pWinBmp">Pointer to DIB data.</param>
      <param name="hWnd">Window handle.</param>
      <returns></returns>
      <remarks>
        DIBShow() displays the DIB within to the specified window &lt;hWnd&gt;.
      </remarks>
      <example>
        See the DIBCreateFromPtr() example.
      </example>
      <seealso cref="O:VOGUIClasses.Functions.DIBStretch">DIBStretch</seealso>
    </member>
    <member name="M:VOGUIClasses.Functions.DIBStretch(System.Void*,System.Void*,System.UInt32,System.UInt32,System.Double)">
      <summary>
        Display the DIB within the specified window.
      </summary>
      <param name="pWinBmp">Pointer to the DIB data.</param>
      <param name="hWnd">Window handle.</param>
      <param name="nCx">Width of the area for displaying the DIB.</param>
      <param name="nCy">Height of the area for displaying the DIB.</param>
      <param name="r8Factor">
        The zoom factor of the bitmap.
        A value of 1.0 would be its normal size.
      </param>
      <returns></returns>
      <remarks>
        DIBStretch() copies a DIB into a destination rectangle of &lt;nWidth&gt; by &lt;nHeight&gt;, stretching or compressing the bitmap by a factor of &lt;r8Zoom&gt; to fit the dimensions of the specified window, &lt;hWnd&gt;.  &lt;r8Zoom&gt; can be calculated as &lt;size of the area&gt;/&lt;size of the bitmap&gt;.
        For example, a value of 2.0 would double the bitmap size, while a value of 0.5 would shrink the DIB to half its normal size.
      </remarks>
      <example></example>
      <seealso cref="O:VOGUIClasses.Functions.DIBShow">DIBShow</seealso>
    </member>
    <member name="M:VOGUIClasses.Functions.Enable3dControls">
      <summary>Determines whether controls on windows created with the GUI classes are displayed using a sculpted, three-dimensional look.</summary>
      <remarks>Note - This function has no purpose in 32 bit programs. It is included for backward compatibility with 16 bit applications only.</remarks>
    </member>
    <member name="M:VOGUIClasses.Functions.EnableAppVisualTheme(System.Boolean)">
      <summary>
        Enable or disable the applications support for visual themes.
      </summary>
      <param name="lEnable">
        An optional logical value. TRUE sets the support for visual themes on, FALSE sets this off.

        The default is TRUE.
      </param>
      <returns>
        TRUE if visual themes are enabled; otherwise, FALSE.
      </returns>
      <remarks>
        Visual themes are automatically enabled if version 6 of the common controls is loaded by using an application manifest.
      </remarks>
      <seealso cref="O:VOGUIClasses.Functions.IsThemeEnabled">IsThemeEnabled</seealso>
    </member>
    <member name="M:VOGUIClasses.Functions.EnableThemeDialogTexture(XSharp.__Usual,System.UInt32)">
      <summary>**Missing documentation **</summary>
      <param name="oWindow">** missing parameter documentation **</param>
      <param name="dwStyle">** missing parameter documentation **</param>
    </member>
    <member name="M:VOGUIClasses.Functions.GetAppObject">
      <summary>
        Return the global App object for this application.
      </summary>
      <returns></returns>
      <remarks></remarks>
      <example>
        The following example terminates a dialog based application:
        <code language="X#">METHOD CancelButton() CLASS OrderDialog</code><code language="X#">
          SELF:EndDialog()
          GetAppObject():Quit()
        </code></example>
      <seealso cref="T:VO.App">App Class</seealso>
      <seealso cref="O:VOGUIClasses.Functions.GetObjectByHandle">GetObjectByHandle</seealso>
    </member>
    <member name="M:VOGUIClasses.Functions.GetFocusedObject">
      <summary>
        Return the object corresponding to the control or window that currently has input focus.
      </summary>
      <returns>
        The window or control object that currently has input focus.
      </returns>
      <remarks></remarks>
      <example>
        This example causes a beep if the object that currently has input focus is a MultiLineEdit control:
        <code language="X#">
          oObj := GetFocusedObject()
          IF oObj != NULL_OBJECT .AND. IsInstanceOf(oControl, #MultiLineEdit)
          MessageBeep(MB_ICONASTERISK)
          ENDIF
        </code></example>
      <seealso cref="T:VO.Control">CLASS Control</seealso>
      <seealso cref="T:VO.Window">Class Window</seealso>
      <seealso cref="O:VOGUIClasses.Functions.GetAppObject">GetAppObject</seealso>
      <seealso cref="O:VOGUIClasses.Functions.GetObjectByHandle">GetObjectByHandle</seealso>
    </member>
    <member name="M:VOGUIClasses.Functions.GetFrameWidth(System.Void*)">
      <summary>**Missing documentation **</summary>
      <param name="hWnd">** missing parameter documentation **</param>
    </member>
    <member name="M:VOGUIClasses.Functions.GetObjectByHandle(System.Void*)">
      <summary>
        Return the object associated with a given window handle.
      </summary>
      <param name="hwnd">The window handle.</param>
      <returns>
        The Window or Control object associated with the given window handle.
      </returns>
      <remarks></remarks>
      <example>
        This example gets the object associated with the control that currently has focus:
        <code language="X#">
          FUNCTION GetFocusedObject() AS OBJECT
          LOCAL oCtrl AS OBJECT
          oCtrl := GetObjectByHandle(GetFocus())
          IF IsInstanceOf(oCtrl, #Control)
          RETURN oCtrl
          ELSE
          RETURN NULL_OBJECT
          ENDIF
        </code></example>
      <seealso cref="T:VO.Control">CLASS Control</seealso>
      <seealso cref="T:VO.Window">Class Window</seealso>
      <seealso cref="O:VOGUIClasses.Functions.GetAppObject">GetAppObject</seealso>
      <seealso cref="O:VOGUIClasses.Functions.GetFocusedObject">GetAppObject</seealso>
    </member>
    <member name="M:VOGUIClasses.Functions.GetThemeAppProperties">
      <summary>
        Retrieves the property flags that control how visual styles are applied in the current application
      </summary>
      <returns>
        STAP_ALLOW_NONCLIENT
        Specifies that the nonclient areas of application windows have visual styles applied.
        STAP_ALLOW_CONTROLS
        Specifies that controls in application windows have visual styles applied.
        STAP_ALLOW_WEBCONTENT
        Specifies that all web content displayed in an application is rendered using visual styles.




      </returns>
      <remarks></remarks>
      <example></example>
    </member>
    <member name="M:VOGUIClasses.Functions.IsAltPressed">
      <summary>Get the current state of the Alt key.</summary>
    </member>
    <member name="M:VOGUIClasses.Functions.IsAppThemed">
      <summary>Return the theme setting for the current application.</summary>
    </member>
    <member name="M:VOGUIClasses.Functions.IsControlPressed">
      <summary>Get the current state of the Ctrl key.</summary>
    </member>
    <member name="M:VOGUIClasses.Functions.IsCtl3dEnabled">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VOGUIClasses.Functions.IsShiftPressed">
      <summary>Get the current state of the Shift key.</summary>
    </member>
    <member name="M:VOGUIClasses.Functions.IsThemeEnabled">
      <summary>
        Determine if visual theme support is enabled.
      </summary>
      <returns>
        TRUE if visual theme support is enabled; otherwise, FALSE.
      </returns>
      <seealso cref="O:VOGUIClasses.Functions.EnableAppVisualTheme">EnableAppVisualTheme</seealso>
    </member>
    <member name="M:VOGUIClasses.Functions.VerifyThemeState">
      <summary>Verifies the current theme state and sets the ThemeEnabled flag.</summary>
      <returns>The function returns the current value of the ThemeEnabled flag like the function IsThemeEnabled().</returns>
    </member>
    <member name="T:VOInternetClasses.Functions">
      <summary>
        This compiler generated class contains all the functions, globals and defines that are defined in the VOInternetClasses assembly.
      </summary>
    </member>
    <member name="T:VORDDClasses.Functions">
      <summary>
        This compiler generated class contains all the functions, globals and defines that are defined in the VORDDClasses assembly.
      </summary>
    </member>
    <member name="M:VORDDClasses.Functions.DBFDebug(System.String,System.String,System.String,System.String)">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VORDDClasses.Functions.DbGetDefaultLockMode">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VORDDClasses.Functions.DbSetDefaultLockMode(System.UInt32)">
      <summary>**Missing documentation **</summary>
      <param name="dwLockMode">** missing parameter documentation **</param>
    </member>
    <member name="M:VORDDClasses.Functions.DbSetRestoreWorkarea(XSharp.__Usual)">
      <summary>**Missing documentation **</summary>
      <param name="lEnable">** missing parameter documentation **</param>
    </member>
    <member name="T:VOSQLClasses.Functions">
      <summary>
        This compiler generated class contains all the functions, globals and defines that are defined in the VOSQLClasses assembly.
      </summary>
    </member>
    <member name="M:VOSQLClasses.Functions.SQLConnectErrorMsg(XSharp.__Usual)">
      <summary>
        Return and optionally change the setting that determines whether to display connection error messages.
      </summary>
      <param name="lValue">
        TRUE enables the connection error message; FALSE disables the connection error message.
        The initial default is TRUE.
      </param>
      <returns>
        If &lt;lNewSetting&gt; is not specified, SQLConnectErrorMsg() returns the current setting.
        If &lt;lNewSetting&gt; is specified, the previous setting is returned.
      </returns>
      <remarks>
        If SQLConnectErrorMsg() is set to FALSE, connection error messages are not displayed.
        If SQLConnectErrorMsg() is set to TRUE, which is the default, a connection error message is displayed in a message box.
      </remarks>
      <example></example>
      <seealso cref="O:VO.SQLConnection.Connect">SQLConnection:Connect</seealso>
      <seealso cref="O:VO.SQLConnection.DriverConnect">SQLConnection:DriverConnect</seealso>
    </member>
    <member name="M:VOSQLClasses.Functions.SqlDeleteWhiteSpace(System.String)">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:VOSQLClasses.Functions.SQLDropMyConnection(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Disconnect the ODBC data source.
      </summary>
      <param name="cMySourceName">The source for this connection.</param>
      <param name="cMyUserid">The user id that was used to connect to the source.</param>
      <param name="cMyPassword">The password that was used to connect to the source.</param>
      <returns>
        TRUE if a connection is found; otherwise FALSE.
      </returns>
      <remarks>
        If a connection is found, the use count is decremented by 1.  When the use count is 1, the source is disconnected.
      </remarks>
      <example>
        The following example connects to WATCOM; then ends the connection:
        <code language="X#">
          FUNCTION TestConnect()
          LOCAL oConn AS SQLConnection
          oConn := SQLGetMyConnection("sample", "dba", "sql")
          ? "SRC=",oConn:DataSource
          ? "UID=",oConn:UserID
          ? "PWD=",oConn:Password
          SQLDropMyConnection("sample", "dba", "sql")
        </code></example>
      <seealso cref="O:VOSQLClasses.Functions.SQLGetDataSources">SQLGetDataSources</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SQLGetMyConnection">SQLGetMyConnection</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SQLOpenConnection">SQLOpenConnection</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SQLSetConnection">SQLSetConnection</seealso>
    </member>
    <member name="M:VOSQLClasses.Functions.SQLGetDataSources">
      <summary>
        Identify the available ODBC data sources.
      </summary>
      <returns>
        An array of strings identifying the available ODBC data sources.
        If no sources are available, SQLGetDataSources() returns a NULL_ARRAY.
      </returns>
      <remarks></remarks>
      <example>
        The following example tests connection utility functions:
        <code language="X#">
          FUNCTION TestConnect()
          LOCAL wCount AS DWORD
          LOCAL aSources AS ARRAY
          LOCAL oConn AS SQLConnection
          // Get an array of sources
          aSources := SQLGetDataSources()
          // List them
          ? "ODBC Sources..."
          for wCount := 1 to ALen(aSources)
          ? aSources[wCount]
          next
          // Connect to a list of sources
          oConn := SQLOpenConnection()
          // Make it the default connection
          SQLSetConnection(oConn)
          // Disconnect
          oConn:Disconnect()
        </code></example>
      <seealso cref="O:VOSQLClasses.Functions.SQLDropMyConnection">SQLDropMyConnection</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SQLGetMyConnection">SQLGetMyConnection</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SQLOpenConnection">SQLOpenConnection</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SQLSetConnection">SQLSetConnection</seealso>
    </member>
    <member name="M:VOSQLClasses.Functions.SQLGetMyConnection(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <summary>
        Connect to the ODBC source specified.
      </summary>
      <param name="cMySourceName">The source to connect to.</param>
      <param name="cMyUserID">The user ID that will be used to connect to the source.</param>
      <param name="cMyPassword">The password that will be used to connect to the source.</param>
      <returns>
        If a connection to the source is found, it is returned as an SQLConnection object.
        If a connection is not found, one is created and returned as an object.
      </returns>
      <remarks>
        SQLGetMyConnection is used in the code generated from the SQL editor.
        It allows a connection to be shared among multiple servers in the same task.
      </remarks>
      <example>
        The following example connects to WATCOM; then ends the connection:
        <code language="X#">
          FUNCTION TestConnect()
          LOCAL oConn AS SQLConnection
          oConn := SQLGetMyConnection("sample", "dba", "sql")
          ? "SRC=",oConn:DataSource
          ? "UID=",oConn:UserID
          ? "PWD=",oConn:Password
          SQLDropMyConnection("sample", "dba", "sql")
        </code></example>
      <seealso cref="O:VOSQLClasses.Functions.SQLDropMyConnection">SQLDropMyConnection</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SQLGetDataSources">SQLGetDataSources</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SQLOpenConnection">SQLOpenConnection</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SQLSetConnection">SQLSetConnection</seealso>
    </member>
    <member name="M:VOSQLClasses.Functions.SqlIsBinaryType(System.Int32)">
      <summary>Helper function to determine if an ODBC type is Binary</summary>
    </member>
    <member name="M:VOSQLClasses.Functions.SqlIsCharType(System.Int32)">
      <summary>Helper function to determine if an ODBC type is Character</summary>
    </member>
    <member name="M:VOSQLClasses.Functions.SqlIsLongType(System.Int32)">
      <summary>Helper function to determine if an ODBC type is Long (BLOB, MEMO etc)</summary>
    </member>
    <member name="M:VOSQLClasses.Functions.SQLOpenConnection">
      <summary>
        Connect to a list of ODBC sources.
      </summary>
      <returns>
        An SQLConnection object.
      </returns>
      <remarks>
        SQLOpenConnection() displays a dialog box listing all of the sources that have been installed and prompts you to select one.
      </remarks>
      <example>
        The following example tests connection utility functions:
        <code language="X#">
          FUNCTION TestConnect()
          LOCAL wCount AS DWORD
          LOCAL aSources AS ARRAY
          LOCAL oConn AS SQLConnection
          // Get an array of sources
          aSources := SQLGetDataSources()
          // List them
          ? "ODBC Sources..."
          for wCount := 1 to ALen(aSources)
          ? aSources[wCount]
          next
          // Connect to a list of sources
          oConn := SQLOpenConnection()
          // Make it the default connection
          SQLSetConnection(oConn)
          // Disconnect
          oConn:Disconnect()
        </code></example>
      <seealso cref="O:VOSQLClasses.Functions.SQLDropMyConnection">SQLDropMyConnection</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SQLGetDataSources">SQLGetDataSources</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SQLGetMyConnection">SQLGetMyConnection</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SQLSetConnection">SQLSetConnection</seealso>
    </member>
    <member name="M:VOSQLClasses.Functions.SQLSetConnection(XSharp.__Usual)">
      <summary>
        Return and optionally change the default SQL connection.
      </summary>
      <param name="oSQLConnection">The default SQL connection that will be used by any function or class that requires a connection.</param>
      <returns>
        If &lt;oSQLConnection&gt; is not specified, SQLSetConnection() returns the current setting.
        If &lt;oSQLConnection&gt; is specified, the new setting is returned.
      </returns>
      <remarks>
        If &lt;oSQLConnection&gt; is not specified and there is no previous or default connection, SQLSetConnection() calls SQLOpenConnection(), sets that connection as the default, and returns it.
      </remarks>
      <example>
        The following example tests connection utility functions:
        <code language="X#">
          FUNCTION TestConnect()
          LOCAL wCount AS DWORD
          LOCAL aSources AS ARRAY
          LOCAL oConn AS SQLConnection
          // Get an array of sources
          aSources := SQLGetDataSources()
          // List them
          ? "ODBC Sources..."
          for wCount := 1 to ALen(aSources)
          ? aSources[wCount]
          next
          // Connect to a list of sources
          oConn := SQLOpenConnection()
          // Make it the default connection
          SQLSetConnection(oConn)
          // Disconnect
          oConn:Disconnect()
        </code></example>
      <seealso cref="O:VOSQLClasses.Functions.SQLDropMyConnection">SQLDropMyConnection</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SQLGetDataSources">SQLGetDataSources</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SQLGetMyConnection">SQLGetMyConnection</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SQLSetConnection">SQLSetConnection</seealso>
    </member>
    <member name="M:VOSQLClasses.Functions.SqlSetStmtConcurrency(XSharp.__Usual)">
      <summary>
        Return and optionally change the default concurrency mode for SQLSelect objects
      </summary>
      <param name="nNew">The default  concurrency strategy that will be used by new SqlSelect objects</param>
      <returns>
        If &lt;nNew&gt; is not specified, SQLSetStmtConcurrency() returns the current setting.
        If &lt;nNew&gt; is specified, the new setting is returned.
      </returns>
      <remarks>
        The concurrency mode for SQLSelect objects is used to determine if rows have been changed by other connections. The possible values are:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SQL_CONCUR_READ_ONLY</term><description>Cursor is read-only. No updates are allowed</description></item><item><term>SQL_CONCUR_LOCK</term><description>Cursor uses the lowest level of locking sufficient to ensure that the row can be updated</description></item><item><term>SQL_CONCUR_ROWVER</term><description>Cursor uses optimistic concurrency control, comparing row versions such as SQLBase ROWID or Sybase TIMESTAMP</description></item><item><term>SQL_CONCUR_VALUES</term><description>Cursor uses optimistic concurrency control, comparing values</description></item></list>
        The default value used by X# is SQL_CONCUR_ROWVER
      </remarks>
      <example></example>
      <seealso cref="O:VOSQLClasses.Functions.SqlSetStmtCursorType">SqlSetStmtCursorType</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SqlSetStmtSimulateCursor">SqlSetStmtSimulateCursor</seealso>
      <seealso cref="P:VO.SQLSelect.ScrollConcurrency">SqlSelect:ScrollConcurrency</seealso>
      <seealso cref="P:VO.SQLSelect.CursorType">SqlSelect:CursorType</seealso>
      <seealso cref="P:VO.SQLSelect.SimulateCursor">SqlSelect:SimulateCursor</seealso>
    </member>
    <member name="M:VOSQLClasses.Functions.SqlSetStmtCursorType(XSharp.__Usual)">
      <summary>
        Return and optionally change the default cursor type used by for SQLSelect objects
      </summary>
      <param name="nNew">The default  concurrency strategy that will be used by new SqlSelect objects</param>
      <returns>
        If &lt;nNew&gt; is not specified, SQLSetStmtCursorType() returns the current setting.
        If &lt;nNew&gt; is specified, the new setting is returned.
      </returns>
      <remarks>
        The concurrency mode for SQLSelect objects is used to determine if rows have been changed by other connections. The possible values are:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SQL_CURSOR_FORWARD_ONLY</term><description>The cursor only scrolls forward</description></item><item><term>SQL_CURSOR_KEYSET_DRIVEN</term><description>The driver saves and uses the keys for the number of rows specified in the SQL_ATTR_KEYSET_SIZE statement attribute</description></item><item><term>SQL_CURSOR_DYNAMIC</term><description>The driver saves and uses only the keys for the rows in the rowset.</description></item><item><term>SQL_CURSOR_STATIC</term><description>The data in the result set is static</description></item></list>
        The default value used by X# is SQL_CURSOR_KEYSET_DRIVEN
      </remarks>
      <example></example>
      <seealso cref="O:VOSQLClasses.Functions.SqlSetStmtConcurrency">SqlSetStmtConcurrency</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SqlSetStmtSimulateCursor">SqlSetStmtSimulateCursor</seealso>
      <seealso cref="P:VO.SQLSelect.ScrollConcurrency">SqlSelect:ScrollConcurrency</seealso>
      <seealso cref="P:VO.SQLSelect.CursorType">SqlSelect:CursorType</seealso>
      <seealso cref="P:VO.SQLSelect.SimulateCursor">SqlSelect:SimulateCursor</seealso>
    </member>
    <member name="M:VOSQLClasses.Functions.SqlSetStmtSimulateCursor(XSharp.__Usual)">
      <summary>
        Return and optionally change the default cursor simulation mode used by for SQLSelect objects
      </summary>
      <param name="nNew">The default cursor simulation mode that will be used by new SqlSelect objects</param>
      <returns>
        If &lt;nNew&gt; is not specified, SQLSetStmtSimulateCursor() returns the current setting.
        If &lt;nNew&gt; is specified, the new setting is returned.
      </returns>
      <remarks>
        The cursor simulation mode for SQLSelect objects is used to determine if rows have been changed by other connections. The possible values are:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>SQL_SC_NON_UNIQUE</term><description>The driver does not guarantee that simulated positioned update or delete statements will affect only one row; it is the application's responsibility to do so. If a statement affects more than one row, SQLExecute, SQLExecDirect, or SQLSetPos returns SQLSTATE 01001 (Cursor operation conflict).</description></item><item><term>SQL_SC_TRY_UNIQUE</term><description>The driver attempts to guarantee that simulated positioned update or delete statements affect only one row. The driver always executes such statements, even if they might affect more than one row, such as when there is no unique key. If a statement affects more than one row, SQLExecute, SQLExecDirect, or SQLSetPos returns SQLSTATE 01001 (Cursor operation conflict).</description></item><item><term>SQL_SC_UNIQUE</term><description>The driver guarantees that simulated positioned update or delete statements affect only one row. If the driver cannot guarantee this for a given statement, SQLExecDirect or SQLPrepare returns an error.</description></item></list>
        The default value used by X# is SQL_SC_TRY_UNIQUE
      </remarks>
      <example></example>
      <seealso cref="O:VOSQLClasses.Functions.SqlSetStmtConcurrency">SqlSetStmtConcurrency</seealso>
      <seealso cref="O:VOSQLClasses.Functions.SqlSetStmtCursorType">SqlSetStmtCursorType</seealso>
      <seealso cref="P:VO.SQLSelect.ScrollConcurrency">SqlSelect:ScrollConcurrency</seealso>
      <seealso cref="P:VO.SQLSelect.CursorType">SqlSelect:CursorType</seealso>
      <seealso cref="P:VO.SQLSelect.SimulateCursor">SqlSelect:SimulateCursor</seealso>
    </member>
    <member name="M:VOSQLClasses.Functions.SQLThrowOutOfMemoryError">
      <exclude />
    </member>
    <member name="M:VOSQLClasses.Functions.SQLType2CType(System.Int16)">
      <exclude />
    </member>
    <member name="T:VOSystemClasses.Functions">
      <summary>
        This compiler generated class contains all the functions, globals and defines that are defined in the VOSystemClasses assembly.
      </summary>
    </member>
    <member name="M:XSharp.ChildWinForm.#ctor(XSharp.__Usual,XSharp.__Usual)">
      <exclude />
    </member>
    <member name="M:XSharp.ChildWinForm.Activate(XSharp.__Usual)">
      <exclude />
    </member>
    <member name="M:XSharp.ChildWinForm.Close(XSharp.__Usual)">
      <exclude />
    </member>
    <member name="M:XSharp.ChildWinForm.DeActivate(XSharp.__Usual)">
      <exclude />
    </member>
    <member name="M:XSharp.ChildWinForm.Resize(XSharp.__Usual)">
      <exclude />
    </member>
    <member name="P:XSharp.ChildWinForm.WinForm">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:XSharp.VOWinFormApp.#ctor">
      <exclude />
    </member>
    <member name="M:XSharp.VOWinFormApp.BeforeDispatch(XSharp.__Usual,XSharp.__Usual,XSharp.__Usual,XSharp.__Usual)">
      <exclude />
    </member>
    <member name="M:XSharp.VOWinFormApp.RegisterWinForm(System.Windows.Forms.Form)">
      <exclude />
    </member>
    <member name="M:XSharp.VOWinFormApp.UnRegisterWinForm(System.Windows.Forms.Form)">
      <exclude />
    </member>
    <member name="M:XSharp.WinFormVOWindow.#ctor">
      <exclude />
    </member>
    <member name="M:XSharp.WinFormVOWindow.CloseHostForm(VO.Window)">
      <exclude />
    </member>
    <member name="M:XSharp.WinFormVOWindow.Initialize">
      <exclude />
    </member>
    <member name="P:XSharp.WinFormVOWindow.VOWindowHost">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:XSharp.WinFormVOWindowHost.#ctor">
      <exclude />
    </member>
    <member name="M:XSharp.WinFormVOWindowHost.#ctor(System.ComponentModel.IContainer)">
      <exclude />
    </member>
    <member name="M:XSharp.WinFormVOWindowHost.#ctor(VO.Window,System.Windows.Forms.Control)">
      <exclude />
    </member>
    <member name="M:XSharp.WinFormVOWindowHost.AdjustVOWindow">
      <exclude />
    </member>
    <member name="P:XSharp.WinFormVOWindowHost.ClassesNeedingTranslateTabToArrow">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:XSharp.WinFormVOWindowHost.Close">
      <exclude />
    </member>
    <member name="M:XSharp.WinFormVOWindowHost.Focus">
      <exclude />
    </member>
    <member name="P:XSharp.WinFormVOWindowHost.HostingControl">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="M:XSharp.WinFormVOWindowHost.IsHostingDataWindow">
      <exclude />
    </member>
    <member name="M:XSharp.WinFormVOWindowHost.ProcessDialogKey(System.Windows.Forms.Keys)">
      <exclude />
    </member>
    <member name="P:XSharp.WinFormVOWindowHost.VOWindow">
      <summary>**Missing documentation **</summary>
    </member>
    <member name="P:XSharp.WinFormVOWindowHost.VOWindowClassName">
      <summary>**Missing documentation **</summary>
    </member>
  </members>
  <commonblocks>
    <notify>
      <span>
        <list type="table">
          <listheader>
            <term>Constant</term>
            <description>Description</description>
          </listheader>
          <item>
            <term>NOTIFYAPPEND</term>
            <description>A blank record has been appended to the server; the server is still positioned on this new record, and its values have not been finalized.</description>
          </item>
          <item>
            <term>NOTIFYCLEARRELATION</term>
            <description>Not sent to a data browser.</description>
          </item>
          <item>
            <term>NOTIFYCLOSE</term>
            <description>The server intends to close itself.</description>
          </item>
          <item>
            <term>NOTIFYCOMPLETION</term>
            <description>The server has completed some large operation that did not involve repositioning of the server or change to the data (such as reindexing).  This gives the browser a chance to update visual indication to the user that some operation has been completed.   In this situation, &lt;uDescription&gt; is the name of the method that was just completed, as a symbol.</description>
          </item>
          <item>
            <term>NOTIFYDELETE</term>
            <description>The current record has been deleted, and the server is now positioned according to its rules for how a deletion is handled.  The browser should refresh its display accordingly.</description>
          </item>
          <item>
            <term>NOTIFYFIELDCHANGE</term>
            <description>A field has changed.  &lt;uDescription&gt; is the field name as a symbol.   Note that the browser might not contain a column with the indicated name.  The server knows only that it has a field of that name and that it changed, and it notifies all its clients in case they are interested.</description>
          </item>
          <item>
            <term>NOTIFYFILECHANGE</term>
            <description>The server has executed some method that perform many changes to the data; all the browser's knowledge about the server and its data is potentially obsolete, and it should refresh all information from the server and all calculations that depend on the data or its position.  </description>
          </item>
          <item>
            <term>NOTIFYGOBOTTOM</term>
            <description>The server has moved to its last record.  Many clients treat this merely as a record change, but the data browser can treat a positioning-to-the-end as a special case.</description>
          </item>
          <item>
            <term>NOTIFYGOTOP</term>
            <description>The server has moved to its first record.  Many clients treat this merely as a record change, but the data browser can treat a positioning-to-the-top as a special case.</description>
          </item>
          <item>
            <term>NOTIFYINTENTTOMOVE</term>
            <description>The server intends to make a move.  (Note that the move may have been initiated by another client.) The browser should make sure that all its data is saved, if necessary, before the movement is done.  The standard implementation checks validation status.  If the browser contains data that is invalid, the user has a choice of correcting the errors or discarding the data.  </description>
          </item>
          <item>
            <term>NOTIFYRECORDCHANGE</term>
            <description>The record position of the server has changed.   All clients are notified after any movement, so they can refresh their displays from the server.  A browser needs to update its display intelligently, depending on how far the move was.   &lt;uDescription&gt; might indicate the length of the move (the number of records).  The browser can use this information for display optimization, but cannot rely on its availability.  </description>
          </item>
          <item>
            <term>NOTIFYRELATIONCHANGE</term>
            <description>Not sent to a data browser (relation changes among servers are transmitted to clients as file changes).</description>
          </item>
        </list>
        This Notify() method is at the heart of the automatic notification among linked browsers and servers, allowing any window to make a change to a field value or initiate a movement and also ensuring that all client windows reflect the change.  Any class that is registered as a client of a server must respond intelligently to the Notify message.
        As always with defined constants, you should never rely on the actual values of the constants — they will not necessarily stay the same.  However, the constants do maintain their order:
        <list type="table"><listheader><term>Constant</term><description>Description</description></listheader><item><term>NOTIFYFIELDCHANGE</term><description>Lowest</description></item><item><term>NOTIFYCLOSE</term><description>...</description></item><item><term>NOTIFYCOMPLETION</term><description>...</description></item><item><term>NOTIFYINTENTTOMOVE</term><description>...</description></item><item><term>NOTIFYRECORDCHANGE</term><description>...</description></item><item><term>NOTIFYGOBOTTOM</term><description>...</description></item><item><term>NOTIFYGOTOP</term><description>...</description></item><item><term>NOTIFYDELETE</term><description>...</description></item><item><term>NOTIFYAPPEND</term><description>...</description></item><item><term>NOTIFYFILECHANGE</term><description>...</description></item><item><term>NOTIFYRELATIONCHANGE</term><description>...</description></item><item><term>NOTIFYCLEARRELATION</term><description>Highest</description></item></list>
        Thus, you can reliably write:
        <code language="X#">
          IF    kNotifyName &gt; NOTIFYINTENTTOMOVE;
          .AND. kNotifyName &lt; NOTIFYFILECHANGE
          ... // Only record level moves
          ENDIF
        </code></span>
    </notify>
  </commonblocks>
</doc>