//
// Copyright (c) XSharp B.V.  All Rights Reserved.  
// Licensed under the Apache License, Version 2.0.  
// See License.txt in the project root for license information.
//
USING System
USING System.Runtime.InteropServices
USING System.Runtime.CompilerServices
USING System.Diagnostics

BEGIN NAMESPACE XSharp
    // use explicit layout so we can compact the size into 12 bytes
    // Type is Immutable, so no settable properties
    /// <summary>Internal type that implements the VO Compatible FLOAT type.
    /// This type has many operators and implicit converters that normally are never directly called from user code.
    /// </summary>
    /// <seealso cref="T:XSharp.IFloat"/>
    /// <seealso cref="T:XSharp.RDD.DbFloat"/>
    [StructLayout(LayoutKind.Explicit, Pack := 4)];
    PUBLIC STRUCTURE __VOFloat IMPLEMENTS IFLoat, ;
        IConvertible,; 
        IFormattable, ;
        IComparable<__VoFloat>, ;
        IEquatable<__VoFloat>, ;
        IComparable
    
        [FieldOffset(0)]  PRIVATE INITONLY _value AS REAL8
        [FieldOffset(8)]  PRIVATE INITONLY _length AS SHORTINT
        [FieldOffset(10)] PRIVATE INITONLY _decimals AS SHORTINT
        
        #region constructors
        /// <summary>This constructor is used in code generated by the compiler when needed.</summary>
        /// <param name="r8">Real8 value to convert to a FLOAT</param>
        [DebuggerStepThroughAttribute] [MethodImpl(MethodImplOptions.AggressiveInlining)];        
        CONSTRUCTOR (r8 AS REAL8)
            SELF:_value    := r8
            SELF:_length   := 0
            SELF:_decimals := 0
            
        /// <summary>This constructor is used in code generated by the compiler when needed.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)];        
        CONSTRUCTOR (r8 AS REAL8, decimals AS INT)
            SELF:_value    := r8
            SELF:_length   := 0
            SELF:_decimals := (SHORTINT) decimals 
            
        /// <summary>This constructor is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute] [MethodImpl(MethodImplOptions.AggressiveInlining)];        
        CONSTRUCTOR (r8 AS REAL8, decimals AS DWORD)
            SELF:_value    := r8
            SELF:_length   := 0
            SELF:_decimals := (SHORTINT) decimals 
            
        /// <summary>This constructor is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute] [MethodImpl(MethodImplOptions.AggressiveInlining)];        
        CONSTRUCTOR (r8 AS REAL8, length AS DWORD, decimals AS DWORD)
            SELF:_value    := r8
            SELF:_length   := (SHORTINT) length
            SELF:_decimals := (SHORTINT) decimals 
            
        /// <summary>This constructor is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute] [MethodImpl(MethodImplOptions.AggressiveInlining)];        
        CONSTRUCTOR (r8 AS REAL8, length AS INT, decimals AS INT )
            SELF:_value    := r8
            SELF:_length   := (SHORTINT) length
            SELF:_decimals := (SHORTINT) decimals
            
        /// <summary>This constructor is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute] [MethodImpl(MethodImplOptions.AggressiveInlining)];        
        CONSTRUCTOR (VALUE AS IFloat)
            SELF:_value		:= VALUE:value
            SELF:_length	:= (SHORT) VALUE:Digits
            SELF:_decimals	:= (SHORT) VALUE:Decimals
        #endregion
        #region Properties
        /// <summary>REAL8 (System.Double) value</summary>
        PROPERTY @@Value    AS REAL8	GET _value			
        /// <summary>Width </summary>
        PROPERTY Digits   AS INT	GET _length		
        /// <summary>Number of decimals</summary>
        PROPERTY Decimals AS INT	GET _decimals	
        #endregion
        
        #region Equality Operators
        /// <summary>This method is used in code generated by the compiler when needed.</summary>
        OVERRIDE METHOD Equals(rhs AS OBJECT  ) AS LOGIC
            LOCAL result AS LOGIC
            IF rhs != NULL .AND. rhs IS FLOAT
                result := SELF:Equals( (FLOAT) rhs)
            ELSE
                result := FALSE
            ENDIF
            RETURN result
            
        /// <summary>This method is used in code generated by the compiler when needed.</summary>
        METHOD Equals(rhs AS FLOAT ) AS LOGIC
            LOCAL delta AS REAL8
            LOCAL diff  AS REAL8
            LOCAL equal AS LOGIC
            delta := RuntimeState.FloatDelta
            diff := _value - rhs:_value
            IF delta == 0.0
                equal :=  diff == 0.0
            ELSEIF diff < 0.0
                equal :=  Math.Abs(diff) < delta
            ELSE
                equal := diff < delta
            ENDIF
            RETURN equal
            
            /// <inheritdoc />
        VIRTUAL METHOD GetHashCode() AS INT
            RETURN SELF:_value:GetHashCode()
            
            /// <exclude />	
        METHOD GetTypeCode() AS TypeCode
            RETURN TypeCode.Double
            
            
            /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR ==(lhs AS FLOAT, rhs AS FLOAT) AS LOGIC
            RETURN lhs:Equals(rhs)
            
            /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR !=(lhs AS FLOAT, rhs AS FLOAT) AS LOGIC
            RETURN ! lhs:Equals(rhs)
            #endregion
            
        #region Comparison Operators
        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR >(lhs AS FLOAT, rhs AS FLOAT) AS LOGIC
            LOCAL delta AS REAL8
            LOCAL diff  AS REAL8
            delta := RuntimeState.FloatDelta
            diff := lhs:_value - rhs:_value
            IF (delta == 0.0)
                RETURN diff > 0.0
            ENDIF
            RETURN diff > delta
            
            
            /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR <(lhs AS FLOAT, rhs AS FLOAT) AS LOGIC
            LOCAL delta AS REAL8
            LOCAL diff  AS REAL8
            delta := RuntimeState.FloatDelta
            diff := lhs:_value - rhs:_value
            IF (delta == 0.0)
                RETURN diff < 0.0
            ENDIF
            RETURN diff < delta
            
            /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR >=(lhs AS FLOAT, rhs AS FLOAT) AS LOGIC
            // call other operator methods for simplicity
            // we may want to optimize this later
            RETURN lhs > rhs .OR. lhs == rhs
            
            /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR <=(lhs AS FLOAT, rhs AS FLOAT) AS LOGIC
            // call other operator methods for simplicity
            // we may want to optimize this later
            RETURN lhs < rhs .OR. lhs == rhs
            
            #endregion
            
        #region Implicit Converters
        /// <summary>This implicit converter is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR IMPLICIT(b AS BYTE) AS FLOAT
            RETURN FLOAT{b, 0}
            
            /// <summary>This implicit converter is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR IMPLICIT(sb AS SByte) AS FLOAT
            RETURN FLOAT{sb, 0}
            
            /// <summary>This implicit converter is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR IMPLICIT(si AS SHORT) AS FLOAT
            RETURN FLOAT{si, 0}
            
            /// <summary>This implicit converter is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR IMPLICIT(w AS WORD) AS FLOAT
            RETURN FLOAT{w, 0}
            
            /// <summary>This implicit converter is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR IMPLICIT(i AS INT) AS FLOAT
            RETURN FLOAT{i, 0}
            
            /// <summary>This implicit converter is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR IMPLICIT(dw AS DWORD) AS FLOAT
            RETURN FLOAT{dw, 0}
            
            /// <summary>This implicit converter is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR IMPLICIT(i64 AS INT64) AS FLOAT
            RETURN FLOAT{i64, 0}
            
            /// <summary>This implicit converter is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR IMPLICIT(ui64 AS UINT64) AS FLOAT
            RETURN FLOAT{ui64, 0}
            
            /// <summary>This implicit converter is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR IMPLICIT(r4 AS REAL4) AS FLOAT
            RETURN FLOAT{r4, RuntimeState.Decimals}
            
            /// <summary>This implicit converter is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR IMPLICIT(r8 AS REAL8) AS FLOAT
            RETURN FLOAT{r8, RuntimeState.Decimals}
            
            
            /// <summary>This implicit converter is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR IMPLICIT(VALUE AS System.Decimal) AS FLOAT
            RETURN FLOAT{ (REAL8) VALUE, RuntimeState.Decimals}
            
            /// <summary>This implicit converter is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR IMPLICIT(fl  AS FLOAT) AS REAL8
            RETURN fl:_value
            
            /// <summary>This implicit converter is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR IMPLICIT(fl  AS FLOAT) AS REAL4
            RETURN (REAL4) fl:_value
            
            /// <summary>This implicit converter is used in code generated by the compiler when needed.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR IMPLICIT(fl  AS FLOAT) AS System.Decimal
            RETURN (System.Decimal) fl:_value

        #endregion
        #region Explicit Converters
        /// <summary>This explicit converter is used in code generated by the compiler when you use a cast in your code.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR EXPLICIT(fl  AS FLOAT) AS BYTE
            IF RuntimeState.CompilerOptionVO11
                RETURN Convert.ToByte(fl:_value)
            ENDIF
            RETURN (BYTE) fl:_value
            /// <summary>This explicit converter is used in code generated by the compiler when you use a cast in your code.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR EXPLICIT(fl AS FLOAT) AS SByte
            RETURN (SByte) fl:_value
            /// <summary>This explicit converter is used in code generated by the compiler when you use a cast in your code.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR EXPLICIT(fl  AS FLOAT) AS SHORT
            IF RuntimeState.CompilerOptionVO11
                RETURN Convert.ToInt16(fl:_value)
            ENDIF
            RETURN (SHORT) fl:_value
            /// <summary>This explicit converter is used in code generated by the compiler when you use a cast in your code.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR EXPLICIT(fl  AS FLOAT) AS WORD
            RETURN (WORD) fl:_value
            /// <summary>This explicit converter is used in code generated by the compiler when you use a cast in your code.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR EXPLICIT(fl  AS FLOAT) AS LONG
            IF RuntimeState.CompilerOptionVO11
                RETURN Convert.ToInt32(fl:_value)
            ENDIF
            RETURN (LONG) fl:_value
            /// <summary>This explicit converter is used in code generated by the compiler when you use a cast in your code.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR EXPLICIT(fl  AS FLOAT) AS DWORD
            RETURN (DWORD) fl:_value
            /// <summary>This explicit converter is used in code generated by the compiler when you use a cast in your code.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR EXPLICIT(fl  AS FLOAT) AS INT64
            IF RuntimeState.CompilerOptionVO11
                RETURN Convert.ToInt64(fl:_value)
            ENDIF
            RETURN (INT64) fl:_value
            /// <summary>This explicit converter is used in code generated by the compiler when you use a cast in your code.</summary>
        [DebuggerStepThroughAttribute];
        STATIC OPERATOR EXPLICIT(fl  AS FLOAT) AS UINT64
            RETURN (UINT64) fl:_value
            
            #endregion
            
        #region Numeric Operators
        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR +(fl  AS FLOAT) AS FLOAT
            RETURN fl
            
            /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR -(fl  AS FLOAT) AS FLOAT
            RETURN FLOAT{- fl:_value, fl:Digits, fl:Decimals}
            
            /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR+(lhs AS FLOAT, rhs AS FLOAT) AS FLOAT
            RETURN lhs:Add(rhs)
            
            /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR+(lhs AS FLOAT, rhs AS USUAL) AS FLOAT
            RETURN lhs:Add(rhs)
            
            /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR+(lhs AS USUAL, rhs AS FLOAT) AS FLOAT
            RETURN rhs:Add(lhs)
            
            /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR-(lhs AS FLOAT, rhs AS FLOAT) AS FLOAT
            RETURN lhs:Subtract(rhs)
            
            /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR-(lhs AS FLOAT, rhs AS USUAL) AS FLOAT
            RETURN lhs:Subtract(rhs)
            
            /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR-(lhs AS USUAL, rhs AS FLOAT) AS FLOAT
            // set decimals for LHS to 0, so max decmals is decimals right
            RETURN FLOAT{lhs, 0}:Subtract(rhs)		
            
            /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR*(lhs AS FLOAT, rhs AS FLOAT) AS FLOAT
            RETURN FLOAT{ lhs:_value * rhs:_value, lhs:Decimals + rhs:Decimals}
            
            /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR/(lhs AS FLOAT, rhs AS FLOAT) AS FLOAT
            RETURN FLOAT{ lhs:_value / rhs:_value, RuntimeState.Decimals}
            
            /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR%(lhs AS FLOAT, rhs AS FLOAT) AS FLOAT
            RETURN FLOAT{ lhs:_value % rhs:_value, RuntimeState.Decimals}
            
            #endregion
        #region Unary Operators
        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR ++ (fl  AS FLOAT) AS FLOAT
            RETURN FLOAT{fl:_value+1, fl:Digits, fl:Decimals}
            
            /// <summary>This operator is used in code generated by the compiler when needed.</summary>
        OPERATOR -- (fl  AS FLOAT) AS FLOAT
            RETURN FLOAT{fl:_value-1, fl:Digits, fl:Decimals}
            #endregion
            
        #region Explicit casts. Used inside Transform
        /// <exclude />	
        METHOD CastToInt() AS INT
            RETURN (INT)(SELF:_value)
            
            /// <exclude />	
        METHOD CastToInt64() AS INT64
            RETURN (INT64)(SELF:_value)
            
            #endregion
        #region Add and Subtract
        /// <exclude />	
        METHOD Add(rhs AS FLOAT) AS FLOAT
            RETURN FLOAT{ SELF:_value + rhs:_value, math.Max(SELF:_decimals, rhs:_decimals)}
            
            /// <exclude />	
        METHOD Add(rhs AS USUAL) AS FLOAT
            LOCAL result AS FLOAT
            IF rhs:IsFloat
                result := SELF:Add ( (FLOAT) rhs)
            ELSEIF rhs:IsDecimal
                result := SELF:Add ( (System.Decimal) rhs)
            ELSEIF  rhs:IsLong
                result := FLOAT{ SELF:_value + (LONG) rhs, SELF:Digits, SELF:Decimals}
            ELSE
                THROW Error.ArgumentError(__ENTITY__,Nameof(rhs), "Argument is not numeric")
            ENDIF
            RETURN result
            
            
            /// <exclude />	
        METHOD Subtract(rhs AS FLOAT) AS FLOAT
            RETURN FLOAT{ SELF:_value - rhs:_value, math.Max(SELF:_decimals, rhs:_decimals)}
            
            /// <exclude />	
        METHOD Subtract(rhs AS USUAL) AS FLOAT
            LOCAL result AS FLOAT
            IF rhs:IsFloat
                result := SELF:Subtract( (FLOAT) rhs)
            ELSEIF rhs:IsDecimal
                result := SELF:Subtract( (System.Decimal) rhs)
            ELSEIF  rhs:IsLong
                result := FLOAT{ SELF:_value - (LONG) rhs, SELF:Digits, SELF:Decimals}			
            ELSE
                THROW Error.ArgumentError(__ENTITY__,Nameof(rhs), "Argument is not numeric")
            ENDIF
            RETURN result
            
            
            #endregion
            
        #region IConvertable
        /// <inheritdoc />
        PUBLIC METHOD IConvertible.ToBoolean(provider AS System.IFormatProvider) AS LOGIC
            THROW NotImplementedException{}
            
            /// <inheritdoc />
        PUBLIC METHOD IConvertible.ToByte(provider AS System.IFormatProvider) AS BYTE
            RETURN ((IConvertible) _value):ToByte(provider)
            
            /// <inheritdoc />
        PUBLIC METHOD IConvertible.ToChar(provider AS System.IFormatProvider) AS CHAR
            RETURN ((IConvertible) _value):ToChar(provider)
            
            /// <inheritdoc />
        PUBLIC METHOD IConvertible.ToDateTime(provider AS System.IFormatProvider) AS System.DateTime
            RETURN ((IConvertible) _value):ToDateTime(provider)
            
            /// <inheritdoc />
        PUBLIC METHOD IConvertible.ToDecimal(provider AS System.IFormatProvider) AS Decimal
            RETURN ((IConvertible) _value):ToDecimal(provider)
            
            /// <inheritdoc />
        PUBLIC METHOD IConvertible.ToDouble(provider AS System.IFormatProvider) AS REAL8
            RETURN ((IConvertible) _value):ToDouble(provider)
            
            /// <inheritdoc />
        PUBLIC METHOD IConvertible.ToInt16(provider AS System.IFormatProvider) AS SHORT
            RETURN ((IConvertible) _value):ToInt16(provider)
            
            /// <inheritdoc />
        PUBLIC METHOD IConvertible.ToInt32(provider AS System.IFormatProvider) AS LONG
            RETURN ((IConvertible) _value):ToInt32(provider)
            
            /// <inheritdoc />
        PUBLIC METHOD IConvertible.ToInt64(provider AS System.IFormatProvider) AS INT64
            RETURN ((IConvertible) _value):ToInt64(provider)
            
            /// <inheritdoc />
        PUBLIC METHOD IConvertible.ToSByte(provider AS System.IFormatProvider) AS SByte
            RETURN ((IConvertible) _value):ToSByte(provider)
            
            /// <inheritdoc />
        PUBLIC METHOD IConvertible.ToSingle(provider AS System.IFormatProvider) AS REAL4
            RETURN ((IConvertible) _value):ToSingle(provider)
            
            /// <inheritdoc />
        PUBLIC METHOD IConvertible.ToType(conversionType AS System.Type, provider AS System.IFormatProvider) AS OBJECT
            RETURN ((IConvertible) _value):ToType(conversionType, provider)
            
            /// <inheritdoc />
        PUBLIC METHOD IConvertible.ToUInt16(provider AS System.IFormatProvider) AS WORD
            RETURN ((IConvertible) _value):ToUInt16(provider)
            
            /// <inheritdoc />
        PUBLIC METHOD IConvertible.ToUInt32(provider AS System.IFormatProvider) AS DWORD
            RETURN ((IConvertible) _value):ToUInt32(provider)
            
            /// <inheritdoc />
        PUBLIC METHOD IConvertible.ToUInt64(provider AS System.IFormatProvider) AS UINT64
            RETURN ((IConvertible) _value):ToUInt64(provider)
            
            /// <inheritdoc />
        PUBLIC METHOD IConvertible.ToString(provider AS System.IFormatProvider) AS STRING
            RETURN ((IConvertible) _value):ToString(provider)
            #endregion
        #region IFormattable
        /// <inheritdoc />
        PUBLIC METHOD ToString() AS STRING
            RETURN Str1(SELF)
            
            /// <inheritdoc />
        PUBLIC METHOD ToString(sFormat AS STRING) AS STRING
            RETURN _value:ToString(sFormat)
            
            /// <inheritdoc />
        PUBLIC METHOD ToString(format AS STRING, provider AS System.IFormatProvider) AS STRING
            RETURN ((IFormattable) _value):ToString(format, provider)
            #endregion
        #region IComparable
        /// <inheritdoc />
        PUBLIC METHOD CompareTo(rhs AS FLOAT) AS INT
            RETURN _Value:CompareTo( rhs:_Value)
            
            /// <inheritdoc />
        PUBLIC METHOD CompareTo(rhs AS OBJECT) AS INT
            RETURN SELF:CompareTo( (FLOAT) rhs)
            #endregion
            
    END STRUCTURE
    
END NAMESPACE
