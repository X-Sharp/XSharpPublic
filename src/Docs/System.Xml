<?xml version="1.0" encoding="utf-8"?>
<doc>
    <members></members>
    <notifyappend>
        <summary>
            A new record has been appended
        </summary>
    </notifyappend>
    <notifyclose>
        <summary>
            The server is closed
        </summary>
    </notifyclose>
    <notifyintenttomove>
        <summary>
            The server intents to move
        </summary>
    </notifyintenttomove>
    <notifygobottom>
        <summary>
            The server has moved to the last (logical)  record
        </summary>
    </notifygobottom>
    <notifydelete>
        <summary>
            The current record has been deleted
        </summary>
    </notifydelete>
    <notifygotop>
        <summary>
            The server has moved to the first (logical)  record
        </summary>
    </notifygotop>

    <notifycompletion>
        <summary>
            An operation has completed
        </summary>
    </notifycompletion>
    <notifyrecordchange>
        <summary>
            The current record has changed
        </summary>
    </notifyrecordchange>
    <notifyfieldchange>
        <summary>
            A field in the current record has changed
        </summary>
    </notifyfieldchange>
    <notifyfilechange>
        <summary>
            An operation has finished that processed one or more records
        </summary>
    </notifyfilechange>
    <notifyrelationchange>
        <summary>
            The parent record has changed, the child must change too
        </summary>
    </notifyrelationchange>
    <notifyclearrelation>
        <summary>
            The relation between the parent and child was changed
        </summary>
    </notifyclearrelation>
    <notifyconcurrencycontrolmode>
        <summary>
            Not used
        </summary>
    </notifyconcurrencycontrolmode>
    <DataField>
        <summary>
            Create a field, which is an object that holds information that defines a particular field in a data server (for example, the field's data type and length).
        </summary>
        <remarks>
            A DataField object is a specific item in a database record.  This is in contrast to a FieldSpec object, which is a description of the properties that some field might have.
            For example, assume you want to create a FieldSpec object that defines an employee number and you have an EMPLOYEE database that has two different fields: EMPNO, which the employee's number (the employee whose record this is), and MGRNO, which is the number of that employee's manager.  Thus, you might define the FieldSpec object as follows:
            <code language="X#">
                CLASS EmployeeNumber INHERIT FieldSpec
                ...
            </code>
            and then in the database define two different fields as:
            <code language="X#">
                DataField{HyperLabel{#EmpNo, "Employee Number"}, ;
                EmployeeNumber{}}
                DataField{HyperLabel{#MgrNo, "Manager Number"}, ;
                EmployeeNumber{}}
            </code>
            Note that some of the field properties can appear redundant given the available FieldSpec properties.  For example, the field contains a hyperlabel, but the field's FieldSpec object also contains a hyperlabel.  Furthermore, the field's hyperlabel contains a symbolic name, and the FieldSpec's hyperlabel contains a symbolic name.
            However, this apparent redundancy serves a useful purpose.  A FieldSpec's hyperlabel identifies the general class of data (called #EmpNo in this example).  This name is often used as the standard name of fields of this type, but it does not have to be, because each particular field has a specific name — in the example above, #EmpNo and #MgrNo.
            A field, therefore, holds two "groups" of properties:
            General label information, like its name, caption, description, and help context ID
            Data type information, stored as a FieldSpec object, that includes data type, length, decimals, validation rules, error messages, diagnostics, and formatting rules
            In any case, all data-oriented objects in the system have a name and a hyperlabel, which are often shipped around the system for annotation and help purposes.
            <br />Important!  There is rarely a need for the developer to consider the fields directly as they are typically created through the code generated by the various data server editors.
        </remarks>
    </DataField>
    <DataField.ctor>
        <summary>
            Construct a data field.
        </summary>
        <param name="oHLName">The name or symbol representing the field.</param>
        <param name="oFS">The FieldSpec object that defines the field's properties.  At a minimum, it must contain the data type and length of the field.</param>
    </DataField.ctor>
    <DataField.ctor>
        <summary>
            Construct a data field.
        </summary>
        <param name="oHLName">The hyperlabel containing the name of the field and any optional annotation.</param>
        <param name="oFS">The FieldSpec object that defines the field's properties.  At a minimum, it must contain the data type and length of the field.</param>
    </DataField.ctor>
    <DataField.AsString>
        <summary>
            Return the descriptive label defined for this field.
        </summary>
        <returns>
            The caption from this field's hyperlabel, if it contains one; otherwise, the field's name is returned.
        </returns>
    </DataField.AsString>
    <DataField.FieldSpec>
        <summary>
            The FieldSpec object connected to this field.
        </summary>
        <value>The FieldSpec object connected to this field.</value>
        <remarks>
            The FieldSpec object connected to this field.  From the FieldSpec object, you can, in turn, access its various properties that control the field's behavior and presentation.
            For example, the following invokes several FieldSpec access/assign methods of a field:
            <code language="X#">
                oDataField:FieldSpec:Type
                oDataField:FieldSpec:Length
                oDataField:FieldSpec:Decimals
                oDataField:FieldSpec:Validate(&lt;uValue&gt;)
            </code>
        </remarks>
    </DataField.FieldSpec>
    <DataField.HyperLabel>
        <summary>
            The hyperlabel connected to this field.
        </summary>
        <value>The hyperlabel connected to this field.</value>
        <remarks>
            The hyperlabel connected to this field.  From the hyperlabel, you can retrieve additional information about the field — for example:
            <code language="X#">
                cCaption := oDataField:HyperLabel:Caption
                cDescription := oDataField:HyperLabel:Description
                cHelpContext := oDataField:HyperLabel:HelpContext
            </code>
        </remarks>
    </DataField.HyperLabel>
    <DataField.Name>
        <summary>
            A string representing the name of the field.
        </summary>
        <value>A string representing the name of the field.</value>
        <remarks>
            A string representing the name of the field.  Note that the hyperlabel also contains a name; these two names are the same in the code generated by the DBServer Editor.
        </remarks>
    </DataField.Name>
    <DataField.NameSym>
        <summary>
            A symbol representing the name of the field.
        </summary>
        <value>A symbol representing the name of the field.</value>
        <remarks>
            A symbol representing the name of the field.  Note that the field's hyperlabel also contains a symbolic name; these two names are the same in the code generated by the DBServer Editor.
        </remarks>
    </DataField.NameSym>
    <DataServer>
        <summary>
            Provide the base class from which all X# data servers are subclassed.
        </summary>
        <remarks>
            <br />Important!  DataServer is an abstract class and should not be used directly — instead, use one of its subclasses, which include DBServer and SQLSelect.  The documentation in this class is provided for the purposes of creating a DataServer subclass and details the data server entities that should be implemented for a consistent interface to other X# components (for example, a data window).
            This abstract class defines the common protocol — properties and behavior — used by the various X# data servers.  These data servers provide an object-oriented interface to databases in many contexts, but they are particularly useful as drivers for the DataWindow class.  For example, any class that derives from DataServer can be connected as a server to a data window or data browser.
        </remarks>
    </DataServer>
    <DataServer.ctor>
        <summary>
            Construct a data server.
        </summary>
    </DataServer.ctor>
    <DataServer.Append>
        <summary>
            Append a blank record to the end of this data server (the new record becomes the current position and is ready for assignment of data values).
        </summary>
        <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
        <remarks>
            <note type="tip">The details of the implementation of this method, as well as how it interacts with other operations (such as unique indexes and concurrency control), depend on the particular data server subclass.</note>
        </remarks>
    </DataServer.Append>
    <DataServer.AsString>
        <summary>
            Return the descriptive label defined for this data server.
        </summary>
        <returns>
            The caption from this data server's hyperlabel, if it contains one; otherwise, the data server's name is returned.
        </returns>
    </DataServer.AsString>
    <DataServer.BoF>
        <summary>
            A logical value indicating whether this data server is positioned at the beginning of the file, on the first record (TRUE if yes, FALSE if no).
        </summary>
        <value>A logical value indicating whether this data server is positioned at the beginning of the file, on the first record (TRUE if yes, FALSE if no).</value>
    </DataServer.BoF>
    <DataServer.Clients>
        <summary>**Missing documentation **</summary>
        <value>**Missing documentation **</value>
    </DataServer.Clients>
    <DataServer.Close>
        <summary>
            Close down the server in a manner specific to the database used.
        </summary>
        <returns>
            TRUE if the operation was successful; FALSE if not. (How can closing down a server be unsuccessful?  If you are accessing a database over a network, and the network goes down before the server is closed, the DataServer:Close() operation may be the first one to fail, but it is still important to respond to this failure since it may indicate that database changes are not committed.)
        </returns>
    </DataServer.Close>
    <DataServer.Commit>
        <summary>
            Force all pending updates to this data server to be permanently written to disk.
        </summary>
        <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
        <remarks>
            DataServer:Commit() can fail for many reasons, ranging from a lack of capability in the server to lock conflicts and technical problems, such as network crashes.  Use the DataServer:Status property to determine the exact cause of the failure.
            The exact implications of this action depend on the type of the data server.  With some database management systems, the method commits all servers using the same connection; with others, it commits only this server; and with yet others, the method does nothing.  In addition, some SQL servers have other implications of a commit operation (they can close cursors, for example).
            <note type="tip">You should carefully study the documentation for your database management system.</note>
        </remarks>
    </DataServer.Commit>
    <DataServer.ConcurrencyControl>
        <summary>
            A constant, identifying the mode of automatic concurrency control for this data server, determining when and how records are locked and released:
        </summary>
        <value>A constant, identifying the mode of automatic concurrency control for this data server, determining when and how records are locked and released:</value>
        <remarks>
            One of the following constants, identifying the mode of automatic concurrency control for this data server, determining when and how records are locked and released:
            <list type="table">
                <listheader>
                    <term>Constant</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>CCNONE</term>
                    <description>The data server provides no automatic record locking; the application is required to do all locking explicitly. </description>
                </item>
                <item>
                    <term>CCOPTIMISTIC</term>
                    <description>
                        No locks are maintained continuously except when appending — the record just appended is locked,
                        and the lock is only released when moving off the record or explicitly calling the DataServer or DBServer Unlock() method.
                        For all other records, the record is reread from disk before any update is done.  This is the <b>default</b>.
                    </description>
                </item>
                <item>
                    <term>CCSTABLE</term>
                    <description>The record that the server is sitting on is always kept locked.</description>
                </item>
                <item>
                    <term>CCREPEATABLE</term>
                    <description>All records that have been read are maintained locked.  The user is guaranteed that when moving back among previously viewed data, they are unchanged.</description>
                </item>
                <item>
                    <term>CCFILE</term>
                    <description>All the records in the entire set provided by the server are locked throughout.  This is not very practical for windows associated with all the records of the server.  It is intended to be used in conjunction with method DataServer:SetSelectiveRelation(). </description>
                </item>
            </list>
        </remarks>
    </DataServer.ConcurrencyControl>
    <DataServer.DataField>
        <summary>
            Retrieve the DataField object at a specified field position.
        </summary>
        <param name="nFieldPosition">The name, number, or symbol representing the desired field.</param>
    </DataServer.DataField>
    <DataServer.DBStruct>
        <summary>
            An array containing the structure of this data server.
        </summary>
        <value>An array containing the structure of this data server.</value>
        <remarks>
            An array containing the structure of this data server.
            The structure of the data server is represented in an array, whose length (that is, number of elements) is equal to the number of fields in the server.  Each subarray is comprised of five elements, which contain the following information, in this order:
            <list type="table">
                <listheader>
                    <term>Constant</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>DBS_NAME</term>
                    <description>cName</description>
                </item>
                <item>
                    <term>DBS_TYPE</term>
                    <description>cType</description>
                </item>
                <item>
                    <term>DBS_LEN</term>
                    <description>nLength</description>
                </item>
                <item>
                    <term>DBS_DEC</term>
                    <description>nDecimals</description>
                </item>
                <item>
                    <term>DBS_ALIAS</term>
                    <description>cAlias</description>
                </item>
            </list>
        </remarks>
    </DataServer.DBStruct>
    <DataServer.Delete>
        <summary>
            Delete the current record in this data server.
        </summary>
        <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
        <remarks>
            When executed successfully, this method sends a NotifyDelete message to this data server's clients.
            <note type="tip">The details of the implementation of this method, and its requirements on concurrency control, depend on the particular data server subclass.</note>
        </remarks>
    </DataServer.Delete>
    <DataServer.EoF>
        <summary>
            A logical value indicating whether this data server is positioned at the end of the file, on the last record after an attempt to move beyond the last record (TRUE if yes, FALSE if no).
        </summary>
        <value>A logical value indicating whether this data server is positioned at the end of the file, on the last record after an attempt to move beyond the last record (TRUE if yes, FALSE if no).</value>
    </DataServer.EoF>
    <DataServer.FCount>
        <summary>
            The number of fields in this data server.
        </summary>
        <value>The number of fields in this data server.</value>
    </DataServer.FCount>
    <DataServer.FieldGet>
        <summary>
            Return the contents of a specified field in this data server.
        </summary>
        <param name="nFieldPosition">The name, number, or symbol representing the desired field.</param>
        <returns>
            The field's contents.  The data type of the return value depends on the data type of the field.
        </returns>
    </DataServer.FieldGet>
    <DataServer.FieldGetFormatted>
        <summary>
            Return the contents of a specified field in this data server, according to the formatting specifications of its FieldSpec.
        </summary>
        <param name="nFieldPosition">The name, number, or symbol representing the desired field.</param>
        <returns>
            The field's contents.
        </returns>
    </DataServer.FieldGetFormatted>
    <DataServer.FieldHyperLabel>
        <summary>
            Return the hyperlabel defined for a field in this data server.
        </summary>
        <param name="nFieldPosition">The name, number, or symbol representing the desired field.</param>
        <remarks>
            By accessing a field's hyperlabel, you can, in turn, access its various properties which annotate the field.  For example:
            <code language="X#">
                oDataServer:FieldHyperLabel(#LastName):Caption
                oDataServer:FieldHyperLabel(#LastName):Description
                oDataServer:FieldHyperLabel(#LastName):HelpContext
            </code>
        </remarks>
    </DataServer.FieldHyperLabel>
    <DataServer.FieldName>
        <summary>
            Return the name of a field in this data server.
        </summary>
        <param name="nFieldPosition">The number of the desired field.</param>
    </DataServer.FieldName>
    <DataServer.FieldPos>
        <summary>
            Return the position of a field in this data server.
        </summary>
        <param name="nFieldPosition">The name of the desired field.</param>
    </DataServer.FieldPos>
    <DataServer.FieldPut>
        <summary>
            Assign a value to a field in this data server.
        </summary>
        <param name="nFieldPosition">The name, number, or symbol representing the desired field.</param>
        <param name="uValue">The value to be assigned to the field.  The data type of this value must match the data type of the field.</param>
        <returns>
            The newly assigned value if the operation was successful; otherwise, NIL.
        </returns>
    </DataServer.FieldPut>
    <DataServer.FieldSpec>
        <summary>
            Return the FieldSpec object for a field in this data server.
        </summary>
        <param name="nFieldPosition">The number representing the desired field.</param>
        <remarks>
            By referencing the attributes of a field's FieldSpec object, the individual properties and methods of the field can be accessed.  For example:
            <code language="X#">oDataServer:FieldSpec(1):Description</code>
            For more information on FieldSpecs, refer to "Defining Data Servers and FieldSpecs" in the IDE User Guide and "Data Server Classes" in the Programmer's Guide.
        </remarks>
    </DataServer.FieldSpec>
    <DataServer.FieldStatus>
        <summary>
            Determine the status of a field in this data server after the last operation.
        </summary>
        <param name="nFieldPosition">The name, number, or symbol representing the desired field.</param>
        <returns>
            A HyperLabel object if any error condition had occurred or if a validation has failed, NIL if everything is OK, if the validation passed, or if there has been no validation attempt.
        </returns>
        <remarks>
            In particular, DataServer:FieldStatus() can be used to find out more about a validation failure.  By accessing the properties of this hyperlabel, you can retrieve not only a description of the condition that was raised, but also context-sensitive help on it.  For example:
            <code language="X#">
                oDataServer:FieldStatus(#LastName):Caption
                oDataServer:FieldStatus(#LastName):Description
                oDataServer:FieldStatus(#LastName):HelpContext
            </code>
        </remarks>
    </DataServer.FieldStatus>
    <DataServer.FieldSym>
        <summary>
            Return the symbolic name of a field in this data server.
        </summary>
        <param name="nFieldPosition">The name, number, or symbol representing the desired field.</param>
    </DataServer.FieldSym>
    <DataServer.FieldValidate>
        <summary>
            Perform all the validations defined to the FieldSpec of a field in this data server (for example, required, maximum and minimum digits, maximum and minimum value, validation rule) and return the result of the test.
        </summary>
        <param name="nFieldPosition">The name, number, or symbol representing the desired field.</param>
        <param name="uValue">The value that is to be validated.  Its data type should be compatible with the data type of the specified field.  If the type cannot be converted to the appropriate data type, it is considered to have failed validation.</param>
        <returns>
            FALSE if any of the validations fail; otherwise, TRUE.
        </returns>
    </DataServer.FieldValidate>
    <DataServer.FLOCK>
        <summary>
            Lock this entire data server for exclusive access.
        </summary>
        <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    </DataServer.FLOCK>
    <DataServer.GoBottom>
        <summary>
            Position this data server at the last record.
        </summary>
        <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
        <remarks>
            When executed successfully, this method sends a NotifyGoBottom message to this data server's clients.
        </remarks>
    </DataServer.GoBottom>
    <DataServer.GoTo>
        <summary>
            Position this data server on a specified record number.
        </summary>
        <param name="nPosition">The record number to which the server should be positioned.</param>
        <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
        <remarks>
            When executed successfully, this method sends a NotifyRecordChange message to this data server's clients.
            <note type="tip">Some types of data servers cannot support movement by record number.</note>
        </remarks>
    </DataServer.GoTo>
    <DataServer.GoTop>
        <summary>
            Position this data server at the first record.
        </summary>
        <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
        <remarks>
            When executed successfully, this method sends a NotifyGoTop message to this data server's clients.
        </remarks>
    </DataServer.GoTop>
    <DataServer.HLStatus>
        <summary>**Missing documentation **</summary>
        <value>**Missing documentation **</value>
    </DataServer.HLStatus>
    <DataServer.HyperLabel>
        <summary>
            The hyperlabel connected to this data server.  From the hyperlabel, you can retrieve additional information about the data server
        </summary>
        <value>The hyperlabel connected to this data server.  From the hyperlabel, you can retrieve additional information about the data server</value>
        <example>
            <code language="X#">
                cCaption := oDataServer:HyperLabel:Caption
                cDescription := oDataServer:HyperLabel:Description
                cHelpContext := oDataServer:HyperLabel:HelpContext
            </code>
            This property can also be used to assign a HyperLabel object to a data server, although this is most commonly done during instantiation of the data server.
        </example>
    </DataServer.HyperLabel>
    <DataServer.Name>
        <summary>
            A string representing the name of this data server.
        </summary>
        <value>A string representing the name of this data server.</value>
    </DataServer.Name>
    <DataServer.NameSym>
        <summary>
            A symbol representing the name of this data server.
        </summary>
        <value>A symbol representing the name of this data server.</value>
    </DataServer.NameSym>
    <DataServer.NoIVarGet>
        <summary>
            Provide a general error interception that is automatically called (in any class) whenever an access reference is made to a non-existent exported instance variable.  In the DataServer class, it is used to implement the virtual field variable.
            <br />Important!  NoIVarGet() should not be called directly; it is called by the system for handling invalid references.
        </summary>
        <param name="symFieldName">The symbolic name of the variable that was referenced.  In the standard usage of the method with the DataServer class, this is a field name.</param>
        <remarks>
            For DataServer, this method is used to intercept references to field names as exported variables, which ordinarily would not be allowed.  If the field name is valid, it calls DataServer:FieldGet() for the corresponding field name, in effect turning database fields into access methods of each DBServer object.  See "Objects, Classes, and Methods" in the Programmer's Guide for more information on NoIVarGet().
        </remarks>
    </DataServer.NoIVarGet>
    <DataServer.NoIVarPut>
        <summary>
            Provide a general error interception that is automatically called (in any class) whenever an assignment reference is made to a non-existent exported instance variable.  In the DataServer class, it is used to implement the virtual field variable.
            <br />Important!  NoIVarPut() should not be called directly; it is called by the system for handling invalid references.
        </summary>
        <param name="symFieldName">The symbolic name of the variable that was referenced.  In the standard usage of the method with the DBServer class, this is a field name.</param>
        <param name="uValue">The value to be assigned to the field.  The data type of this value must match the data type of the field.</param>
        <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
        <remarks>
            When executed successfully, this method sends a NotifyFieldChange message to this data server's clients.
            For DataServer, this method is used to intercept references to field names as exported variables, which ordinarily would not be allowed.  If the field name is valid, it does a DataServer:FieldPut() for the corresponding field name with the passed value (in effect, turning database fields into assign methods of each DBServer object).  See "Objects, Classes, and Methods" in the Programmer's Guide for more information on NoIVarPut().
        </remarks>
    </DataServer.NoIVarPut>
    <DataServer.Notify>
        <summary>
            An event handler that responds to events that have occurred in methods of this server, or in other servers that are linked to this server in some way.  The standard implementation notifies all the server's clients of the event.
            Description
            <br />Important!  This method is automatically called by the various action methods of the data server, and should normally not be called by application code.
        </summary>
        <param name="kNotification">Identifies the event, specified as one of the following constants:</param>
        <param name="uDescription">Used only with some notification types.</param>
        <returns>
            SELF, except if NOTIFYINTENTTOMOVE is specified for <paramref name="kNotifyName" />.  In this case, the return value is TRUE if successful; otherwise, FALSE.
        </returns>
        <remarks>
            <include file="VOSDK.xml" path="doc/commonblocks/notify/*" />
        </remarks>
    </DataServer.Notify>
    <DataServer.PostInit>
        <summary>
            Implement customized initialization code for the window.
        </summary>
        <remarks>
            This method is used to customize the initialization code for a dataserver.
            The customized initialization code will not be overridden by the generated default initialization code.
            A call to PostInit() is automatically generated at the end of the Init() method.
        </remarks>
    </DataServer.PostInit>
    <DataServer.PreInit>
        <summary>
            Implement customized initialization code for the server.
        </summary>
        <remarks>
            This method is used to customize the initialization code for a server.
            The customized initialization code will not be overridden by the generated default initialization code.
            A call to PreInit() is automatically generated at the beginning of the Init() method.
            The default implementation of PostInit() in this class is empty.
            <note type="tip">
                In .Net it is normally not allowed or recommended to run code in a class before the parent constructor is called.
                The generated code in the Window editor does this (it calls PreInit before the SUPER() call). We advise you to
                be very careful not to touch protected instance variables inherited from parent classes, since these may not be
                initialized and/or values that you assign to them may be overwritten in the constructor of the parent class.
            </note>
        </remarks>
    </DataServer.PreInit>
    <DataServer.RecCount>
        <summary>
            A numeric value representing the number of records in this data server.
        </summary>
        <value>A numeric value representing the number of records in this data server.</value>
        <remarks>
            <note type="tip">Some types of data servers may not be able to provide this number.  If a failure does occur, -1 is returned.</note>
        </remarks>
    </DataServer.RecCount>
    <DataServer.RecNo>
        <summary>
            A numeric value representing the current record number, identifying the position of the record pointer in this data server.
        </summary>
        <value>A numeric value representing the current record number, identifying the position of the record pointer in this data server.</value>
        <remarks>
            A numeric value representing the current record number, identifying the position of the record pointer in this data server.
            Assigning a value to DataServer:RecNo is equivalent to executing DataServer:GoTo(); both reposition the record pointer on the given record.
            <note type="tip">Some types of data servers cannot support movement by record number.</note>
        </remarks>
    </DataServer.RecNo>
    <DataServer.RegisterClient>
        <summary>
            Register an object as a client of this data server, so that it receives notification messages from the server about certain actions.
        </summary>
        <param name="oForm">The object to be registered as a client of this data server (for example, a data window or a data browser).  Any object that provides a Notify() method can register itself as a client.</param>
    </DataServer.RegisterClient>
    <DataServer.ResetNotification>
        <summary>
            Resume the broadcasting of Notify messages to the server's attached clients (after DataServer:SuspendNotification() has been called).
        </summary>
        <remarks>
            This method is used in conjunction with DataServer:SuspendNotification(), which suspends the broadcasting of Notify messages.
            Note that DataServer:SuspendNotification() stacks its invocations.  Therefore, for each call to DataServer:SuspendNotification(), there needs to be a corresponding call DataServer:ResetNotification().
        </remarks>
    </DataServer.ResetNotification>
    <DataServer.RLOCK>
        <summary>
            Lock a specific record in this data server for exclusive write access; other users can still make read-only reference to the record.
        </summary>
        <param name="nRecord">The ID (usually a record number) of the record to be locked.  If specified, record locks held by the current process are retained.  If not specified, all locks held by the current process are released and the current record is assumed.</param>
        <returns>
            TRUE if successful; otherwise, FALSE.  Note that FALSE is returned even if the record was successfully locked but other record locks cannot be maintained.
        </returns>
        <remarks>
            When specified with an argument, RLock() does not release records locks held by the current process.  Instead, it adds the newly locked record to the lock list.
            <note type="tip">Some data servers cannot support the maintenance of multiple record locks or even the lock of a record other than the current one based on a record number.</note>
        </remarks>
    </DataServer.RLOCK>
    <DataServer.RLockVerify>
        <summary>
            Determine if the current record in this data server has any pending updates and lock it for exclusive write access if there are none.
        </summary>
        <returns>
            TRUE if the record is unchanged and the lock was successfully taken; otherwise, FALSE.
        </returns>
        <remarks>
            This method checks for pending updates to the current record by comparing the values that were read to the record when the server was initially positioned on the record with the current values in the corresponding database record.
            If the values match, it signifies that no other user has modified the data since the user started working on it, and, therefore, that it is safe to lock the record and let the user continue with an update transaction.  (Note that when locked, other users can still make read-only reference to the record.)
            If the values do not match, somebody else has changed the record, and the user should refresh the values from disk and  restart the transaction.  The application has to decide what to do about values that are different.  Note that DataServer:Status can be used to determine the reason for the failure.
            This method is used for optimistic concurrency control.  See "Concurrency Control" in the Programmer's Guide for more information.)
        </remarks>
    </DataServer.RLockVerify>
    <DataServer.Rollback>
        <summary>
            Undo the changes made to this data server within the current transaction.
        </summary>
        <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
        <remarks>
            This method can fail for many reasons, from a lack of capability in the server to lock conflicts to technical problems such as network crashes.  Use DataServer:Status to determine the exact cause of the failure.
            Note that not all servers support this operation, including the standard Xbase DBServer.  If the server does support it, the exact implications of a rollback vary with the server.  With some database management systems, the method rolls back all servers using the same connection; with others, it rolls back only this server.  In addition, some SQL servers have other implications of a rollback operation (they can close cursors, for example).
            <note type="tip">You should carefully study the documentation for your database management system.</note>
        </remarks>
    </DataServer.Rollback>
    <DataServer.Seek>
        <summary>
            Move to the next record having a specified key value in the controlling order.
        </summary>
        <param name="uValue">The value to be searched for.  The data type of the search expression should match the type of the controlling order.  If there is no controlling order, Seek() searches on the record number and is therefore equivalent to GoTo().</param>
        <returns>
            TRUE if the specified key value was found; otherwise, FALSE.  Note that a FALSE value can indicate either that the value was not found or that the server does not support this search operation.  Use the DataServer:Status property to determine the reason for a failure.
        </returns>
    </DataServer.Seek>
    <DataServer.SetDataField>
        <summary>
            Assign a DataField object to a specified field in this data server.
        </summary>
        <param name="nFieldPosition">The number of the data field.</param>
        <param name="oDataField">The data field to be assigned.</param>
        <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
        <remarks>
            The data type of the new field must be compatible with the actual database field.
            This method is normally used only during instantiation of a data server (most often in Init() methods of subclasses).  For example, the code generated by the data server editors use this method.
        </remarks>
    </DataServer.SetDataField>
    <DataServer.Skip>
        <summary>
            Move the record pointer forward or backward in this data server a specified number of records.
        </summary>
        <param name="nRelativePosition">The number of records to move, relative to the current record.  A positive value means to move forward, and a negative value means to move backward.  The default is +1.</param>
        <returns>
            TRUE if successful; otherwise, FALSE.  Note that a FALSE value can also indicate that beginning- or end-of-file was encountered.  Use the DataServer:Status property to determine the reason for a failure.
        </returns>
        <remarks>
            When executed successfully, this method sends a NotifyRecordChange message to this data server's clients.
            <note type="tip">Not all data servers are capable of moving backward.</note>
        </remarks>
    </DataServer.Skip>
    <DataServer.Status>
        <summary>
            A hyperlabel identifying the status of this data server after the last operation.
        </summary>
        <value>A hyperlabel identifying the status of this data server after the last operation.</value>
        <remarks>
            A hyperlabel identifying the status of this data server after the last operation.  If the last operation was successful, this value is NULL_OBJECT; if something went wrong (whether it raised an error condition or merely returned a failure code), DataServer:Status returns an informative hyperlabel.
            By accessing the properties of this hyperlabel, you can retrieve not only a description of the condition that was raised, but also context-sensitive help on the condition that was raised.
        </remarks>
        <example>
            The following examples invoke several DataServer:Status properties of the data server:
            <code language="X#">
                oDataServer:Status:Caption
                oDataServer:Status:Description
                oDataServer:Status:HelpContext
            </code>
        </example>
    </DataServer.Status>
    <DataServer.SuspendNotification>
        <summary>
            Suspend the broadcasting of Notify messages to the server's attached clients.
        </summary>
        <remarks>
            This method is useful, for example, when the server is moving through the database and the server is ultimately restored to its original position.  Therefore, there is no reason to notify the clients of the server of a change in position within the database.
            Note that DataServer:SuspendNotification() stacks its invocations.  Therefore, for each call to DataServer:SuspendNotification(), there needs to be a corresponding call DataServer:ResetNotification().
        </remarks>
    </DataServer.SuspendNotification>
    <DataServer.UnLock>
        <summary>
            Remove all locks held on this data server.
        </summary>
        <include file="VOSDK.xml" path="doc/ReturnsLogic/*" />
    </DataServer.UnLock>
    <DataServer.UnRegisterClient>
        <summary>
            Remove the registration of an object as a client of this data server, so that it no longer receives notification messages from the server about certain actions.
        </summary>
        <param name="oClient">The object to unregister (for example, DataWindow or DataBrowser).</param>
        <param name="lAllowClose">
            TRUE closes the server if this is the last client registered with the server;
            FALSE does not close the server.  The default is TRUE.
        </param>
        <returns>
            TRUE if successful; otherwise, FALSE (including if the client was not previously registered).
        </returns>
    </DataServer.UnRegisterClient>
    <DataServer.Update>
        <summary>
            Update this server with data from another server or table.
        </summary>
        <returns>
            TRUE if successful; otherwise, FALSE, although even with FALSE, some records may have been updated.
            This can happen if the operation failed halfway through because of technical problems.
        </returns>
        <remarks>
            Sends a NotifyFileChange message upon completion.
            There are two different formulations of the matching relationship between the two servers.
            If <paramref name="lRandomFlag" /> is TRUE, this server must be indexed on the specified key, but the other server can be in any order; if <paramref name="lRandomFlag" /> is not specified or is FALSE, both servers must be indexed or sorted on the specified key.  If there is more than one record in this server with matching key fields, only the first one is updated.
        </remarks>
    </DataServer.Update>
    <DateFS>
        <summary>
            Create a date field specification which holds date data type information.
        </summary>
    </DateFS>
    <DateFS.ctor>
        <summary>
            Construct a date specification.
        </summary>
        <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new date field specification.</param>
    </DateFS.ctor>
    <DbError>
        <exclude />
    </DbError>
    <DbError.ctor>
        <exclude />
    </DbError.ctor>
    <DbError.Throw>
        <exclude />
    </DbError.Throw>
    <FieldSpec>
        <summary>
            Create a field specification, which holds general data type information about data elements, such as database fields and window controls.
        </summary>
        <remarks>
            A FieldSpec object holds a number of properties which relate to fields.  Specifically, a FieldSpec object can be defined for:
            Because both types ultimately apply to fields, a field specification's properties are described in terms of fields only (i.e., not window controls).
            <note type="tip">A field specification corresponds to what is sometimes referred to as an "element definition," a "domain," or an "abstract data type."</note>
            The field specification holds the following properties:
            <list type="table">
                <listheader>
                    <term>Property</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>Decimals</term>
                    <description>The number of decimals in a field (numeric only)</description>
                </item>
                <item>
                    <term>Diagnostics</term>
                    <description>Hyperlabels for each of the validation rules.  Note that a hyperlabel contains not only a diagnostic message, but also a help context to provide for context sensitive help after a validation failure.</description>
                </item>
                <item>
                    <term>HyperLabel</term>
                    <description>Information about a field: its name, caption, description, and help context</description>
                </item>
                <item>
                    <term>Length</term>
                    <description>The length of a field</description>
                </item>
                <item>
                    <term>Min,Max</term>
                    <description>The data range allowed in a field</description>
                </item>
                <item>
                    <term>MinLength</term>
                    <description>The minimum number of characters allowed in a field (for example, a STATE field can be defined with a Length and MinLength of 2, while a PASSWORD might have a Length of 10 and a MinLength of 4)</description>
                </item>
                <item>
                    <term>Picture</term>
                    <description>A picture clause used to format a field.  This is a standard Xbase picture clause, such as @! or 999-99-9999.</description>
                </item>
                <item>
                    <term>Status</term>
                    <description>A HyperLabel object that describes the results of a validation test (it is NIL if the validation passed)</description>
                </item>
                <item>
                    <term>Type</term>
                    <description>The underlying storage type of a field (number, string, logic, date, or memo)</description>
                </item>
                <item>
                    <term>Validation</term>
                    <description>A code block that sets validation rule to be used for a field (i.e., required fields, data type compliance, range compliance, and so on) Also note that a FieldSpec subclass can be given a Validation() method, which overrides this code block.</description>
                </item>
            </list>
        </remarks>
    </FieldSpec>
    <FieldSpec.ctor>
        <summary>
            Construct a field specification.
        </summary>
        <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new field specification.</param>
        <param name="uType">The data type of the new field specification.  It can be specified either as a one-character string or as a constant (See FieldSpec:ValType and FieldSpec:UsualType for valid strings and constants, respectively).</param>
        <param name="uLength">The length of the field.  This argument is required for numeric and string data types, but is optional for all others.</param>
        <param name="uDecimals">The number of decimals in the field.  This argument is used for numeric data types only.  The default is 0.</param>
    </FieldSpec.ctor>
    <FieldSpec.AsString>
        <summary>
            Return the caption defined to this field specification's hyperlabel; if no caption is defined, return the name defined to the hyperlabel.
        </summary>
    </FieldSpec.AsString>
    <FieldSpec.Decimals>
        <summary>
            A numeric value representing the number of decimals defined to this field specification.
        </summary>
        <value>A numeric value representing the number of decimals defined to this field specification.</value>
        <remarks>
            A numeric value representing the number of decimals defined to this field specification.  This argument is used for numeric data types only.  The default is 0.
        </remarks>
    </FieldSpec.Decimals>
    <FieldSpec.HyperLabel>
        <summary>
            The hyperlabel connected to this field specification.
        </summary>
        <value>The hyperlabel connected to this field specification.</value>
        <remarks>
            The hyperlabel connected to this field specification.  From the hyperlabel, you can retrieve additional information about the field specification — for example:
            <code language="X#">
                cCaption := oFieldSpec:HyperLabel:Caption
                cDescription := oFieldSpec:HyperLabel:Description
                cHelpContext := oFieldSpec:HyperLabel:HelpContext
            </code>
        </remarks>
    </FieldSpec.HyperLabel>
    <FieldSpec.Length>
        <summary>
            A numeric value representing the length defined to this field specification.
        </summary>
        <value>A numeric value representing the length defined to this field specification.</value>
    </FieldSpec.Length>
    <FieldSpec.Maximum>
        <summary>
            A numeric value representing the maximum value in the range validation for this field specification.
        </summary>
        <value>A numeric value representing the maximum value in the range validation for this field specification.</value>
    </FieldSpec.Maximum>
    <FieldSpec.Minimum>
        <summary>
            A numeric value representing the minimum value in the range validation for this field specification.
        </summary>
        <value>A numeric value representing the minimum value in the range validation for this field specification.</value>
    </FieldSpec.Minimum>
    <FieldSpec.MinLength>
        <summary>
            A numeric value representing the new minimum length validation for this field specification.
        </summary>
        <value>A numeric value representing the new minimum length validation for this field specification.</value>
    </FieldSpec.MinLength>
    <FieldSpec.MinLengthHL>
        <summary>Error message when MinLength validation fails.</summary>
        <value>Error message when MinLength validation fails.</value>
    </FieldSpec.MinLengthHL>
    <FieldSpec.Nullable>
        <summary>Is the field Nullable ?</summary>
        <value>Is the field Nullable ?</value>
    </FieldSpec.Nullable>
    <FieldSpec.PerformValidations>
        <summary>
            Test a specified value to see if it passes all of this field specification's validation rules.
        </summary>
        <param name="uValue">The value to test.</param>
        <param name="arg">A second argument that is passed to the FieldSpec:Validate() method.</param>
        <returns>
            TRUE if the validation succeeded; otherwise, FALSE.
            <note type="tip">If FALSE, the system sets FieldSpec:Status to the appropriate hyperlabel for the validation rule that failed; if TRUE, FieldSpec:Status is set to NULL_OBJECT.</note>
        </returns>
        <example>
            The following example performs a validation and assigns the resulting status to a status bar message variable:
            <code language="X#">
                IF !oFS:PerformValidations(x)
                SELF:StatusBarMessage := oFS:Status
                ENDIF
            </code>
        </example>
    </FieldSpec.PerformValidations>
    <FieldSpec.Picture>
        <summary>
            A string representing the picture clause defined to this field specification.  It is used by the FieldSpec:Transform() method.
        </summary>
        <value>A string representing the picture clause defined to this field specification.  It is used by the FieldSpec:Transform() method.</value>
    </FieldSpec.Picture>
    <FieldSpec.RangeHL>
        <summary>Error message when Range validation fails.</summary>
        <value>Error message when Range validation fails.</value>
    </FieldSpec.RangeHL>
    <FieldSpec.Required>
        <summary>
            Logical value indicating whether the field is required (TRUE) or not (FALSE).
        </summary>
        <value>Logical value indicating whether the field is required (TRUE) or not (FALSE).</value>
    </FieldSpec.Required>
    <FieldSpec.RequiredHL>
        <summary>Error message when Required validation fails.</summary>
        <value>Error message when Required validation fails.</value>
    </FieldSpec.RequiredHL>
    <FieldSpec.SetLength>
        <summary>
            Set a new length for this field specification and new hyperlabel diagnostics for the length check.
        </summary>
        <param name="w">The new length.  If omitted, the current value is not changed.</param>
        <param name="oHL">The hyperlabel that contains the new diagnostics for the length check (caption, description, and help context).  If omitted, the current value is not changed.</param>
        <remarks>
            A field specification's length is typically set during instantiation, and should not normally be changed later.
        </remarks>
    </FieldSpec.SetLength>
    <FieldSpec.SetMinLength>
        <summary>
            Set a new minimum length validation for this field specification and new hyperlabel diagnostics for the minimum length check.
        </summary>
        <param name="w">The new minimum length (if 0, the minimum length check is removed).  If omitted, the current value is not changed.</param>
        <param name="oHL">The hyperlabel that contains the new diagnostics for the minimum length check (caption, description, and help context).  If omitted, the current value is not changed.</param>
    </FieldSpec.SetMinLength>
    <FieldSpec.SetRange>
        <summary>
            Set a new range validation for this field specification and new hyperlabel diagnostics for the range check.
        </summary>
        <param name="uMinimum">The new minimum value.  If omitted, the current value is not changed.</param>
        <param name="uMaximum">The new maximum value.  If omitted, the current value is not changed.</param>
        <param name="oHL">The hyperlabel that contains the new diagnostics for the range check (caption, description, and help context).  If omitted, the current value is not changed.</param>
    </FieldSpec.SetRange>
    <FieldSpec.SetRequired>
        <summary>
            Set a new required validation for this field specification and new hyperlabel diagnostics for the required check.
        </summary>
        <param name="lReq">TRUE if the field should be required; otherwise, FALSE.  If omitted, TRUE is assumed.</param>
        <param name="oHL">The hyperlabel that contains the new diagnostics for the required check (caption, description, and help context).  If omitted, the current value is not changed.</param>
    </FieldSpec.SetRequired>
    <FieldSpec.SetType>
        <summary>
            Set a new data type for this field specification and new hyperlabel diagnostics for the data type check.
        </summary>
        <param name="uType">The new data type.  It can be specified either as a one-character string or as a constant (See FieldSpec:ValType and FieldSpec:UsualType for valid strings and constants, respectively).  If omitted, the current value is not changed.</param>
        <param name="oHL">The hyperlabel that contains the new diagnostics for the data type check (caption, description, and help context).  If omitted, the current value is not changed.</param>
        <remarks>
            A field specification's data type is typically set during instantiation, and should not normally be changed later.
        </remarks>
    </FieldSpec.SetType>
    <FieldSpec.SetValidation>
        <summary>
            Set a new validation rule for this field specification and new hyperlabel diagnostics for the validation rule check.
        </summary>
        <param name="cb">The new validation rule.  If omitted, the current value is not changed.</param>
        <param name="oHL">The hyperlabel that contains the new diagnostics for the validation rule check (caption, description, and help context).  If omitted, the current value is not changed.</param>
    </FieldSpec.SetValidation>
    <FieldSpec.Status>
        <summary>
            After a validation request (see FieldSpec:PerformValidations() for details), this contains a HyperLabel object that describes the results of the validation or NULL_OBJECT if the validation passed.
        </summary>
        <value>After a validation request (see FieldSpec:PerformValidations() for details), this contains a HyperLabel object that describes the results of the validation or NULL_OBJECT if the validation passed.</value>
        <example>
            The following example performs a validation and assigns the resulting status to a status bar message variable:
            <code language="X#">
                IF !oFS:PerformValidations(x)
                SELF:StatusBarMessage := oFS:Status
                ENDIF
            </code>
        </example>
    </FieldSpec.Status>
    <FieldSpec.Transform>
        <summary>
            Convert a specified value into a string, formatted according to this field specification's picture clause.
        </summary>
        <param name="uValue">The value to format.  It should be of a type compliant with the underlying data type of this field specification.  If not, the method returns NIL and sets FieldSpec:Status accordingly (note that FieldSpec:Transform() performs no other validations).</param>
    </FieldSpec.Transform>
    <FieldSpec.UsualType>
        <summary>
            A constant, representing the data type defined to this field specification:
        </summary>
        <value>A constant, representing the data type defined to this field specification:</value>
        <remarks>
            <para>One of the following constants, representing the data type defined to this field specification:</para>
            <list type="table">
                <listheader>
                    <term>Constant</term>
                    <description>Meaning</description>
                </listheader>
                <item>
                    <term>BYTE</term>
                    <description>Byte</description>
                </item>
                <item>
                    <term>DATE</term>
                    <description>Date</description>
                </item>
                <item>
                    <term>DWORD</term>
                    <description>Double word</description>
                </item>
                <item>
                    <term>FLOAT</term>
                    <description>Float</description>
                </item>
                <item>
                    <term>INT</term>
                    <description>Integer, long integer</description>
                </item>
                <item>
                    <term>LOGIC</term>
                    <description>Logical</description>
                </item>
                <item>
                    <term>OBJECT</term>
                    <description>Object</description>
                </item>
                <item>
                    <term>REAL4</term>
                    <description>Real4</description>
                </item>
                <item>
                    <term>REAL8</term>
                    <description>Real8</description>
                </item>
                <item>
                    <term>SHORT</term>
                    <description>Short integer</description>
                </item>
                <item>
                    <term>STRING</term>
                    <description>String</description>
                </item>
                <item>
                    <term>TYPE_BITMAP</term>
                    <description>Bitmap</description>
                </item>
                <item>
                    <term>WORD</term>
                    <description>Word</description>
                </item>
            </list>
        </remarks>
    </FieldSpec.UsualType>
    <FieldSpec.Val>
        <summary>
            Convert a string to a value, according to this field specification's defined data type.
        </summary>
        <param name="cString">The string to convert.  If the string cannot be converted to the appropriate value, this method returns NIL and sets FieldSpec:Status to indicate the reason for the failure (note that FieldSpec:Val() performs no other validations).</param>
        <remarks>
            The FieldSpec:Val() method acts as the inverse of the FieldSpec:Transform() method, converting a transformed string back to its original value.
        </remarks>
    </FieldSpec.Val>
    <FieldSpec.Validate>
        <summary>
            A replaceable method for performing validations.  The standard implementation evaluates the code block specified through FieldSpec:SetValidation().
        </summary>
        <param name="uValue">The value to be validated.</param>
        <param name="arg">A second argument that is passed to the code block specified from FieldSpec:SetValidation().  During FieldSpec:PerformValidations(), executed from a data window or data browser, this argument is the Control object or Column object.</param>
        <returns>
            TRUE if the value is valid; otherwise, FALSE.
        </returns>
        <remarks>
            This method is called by FieldSpec:PerformValidations(), and should not normally be called by the developer.  It is provided as a way for the developer to optionally use a customized validation technique.
            The standard implementation is:
            <code language="X#">
                METHOD Validate(uValue, uArg) CLASS FieldSpec
                RETURN cbValidation = NULL_CODEBLOCK;
                .OR. EVAL(cbValidation, uValue)
            </code>
        </remarks>
    </FieldSpec.Validate>
    <FieldSpec.Validation>
        <summary>
            A code block that sets the validation rule for this field specification.
        </summary>
        <value>A code block that sets the validation rule for this field specification.</value>
    </FieldSpec.Validation>
    <FieldSpec.ValidationHL>
        <summary>Error message when Validation fails.</summary>
        <value>Error message when Validation fails.</value>
    </FieldSpec.ValidationHL>
    <FieldSpec.ValType>
        <summary>
            A one-character string representing the data type defined to this field specification:
        </summary>
        <value>
            A one-character string representing the data type defined to this field specification:
        </value>
        <remarks>
            <list type="table">
                <listheader>
                    <term>Character</term>
                    <description>Meaning</description>
                </listheader>
                <item>
                    <term>C</term>
                    <description>String</description>
                </item>
                <item>
                    <term>D</term>
                    <description>Date</description>
                </item>
                <item>
                    <term>L</term>
                    <description>Logic</description>
                </item>
                <item>
                    <term>M</term>
                    <description>Memo</description>
                </item>
                <item>
                    <term>N</term>
                    <description>Long integer, float, byte, short integer, word, double word, Real4, Real8</description>
                </item>
            </list>
        </remarks>
    </FieldSpec.ValType>
    <FileSpec>
        <summary>
            Create a file specification, which provides a useful framework for managing file names and paths.
        </summary>
        <remarks>
            A file specification is intended as a way of storing and managing name- and path-related information for a file.  It provides some methods for copying, moving, deleting and renaming files, as well as access methods for retrieving information about the file.  If the path is not specified using the assign methods provided by the FileSpec class, it is obtained by the SetDefault() and SetPath() functions.
            This class allows you to manage this data for all different types of files in a common way.  Because of this, it does not provide any methods for processing a file, such as reading and writing it, as such methods would depend on the type of file it is.  For example, .DBF files can be processed with the DBServer object; other files can be processed with either functions or customized FileSpec subclasses that have been customized for handling different types of files.
        </remarks>
        <example>
            File specifications are often used as arguments to DBServer objects and methods.  For example, to copy selected records from one file to another:
            <code language="X#">
                // Source file
                oFSSource := FileSpec{"c:\data\customer"}
                // For the target file, use path of source file
                oFSTarget := FileSpec{oFSSource:FullPath}
                // Change file name for target file
                oFSTarget:FileName := "nycust"
                // Open source file in server object
                oDBSource := DBServer{oFSSource}
                // Copy records to target file
                oDBSource:CopyDB(oFSTarget,,{||STATE="NY"})
            </code>
            A FileSpec object is also a convenient way to find the current directory and then search in subdirectories according to a logical structure:
            <code language="X#">
                oFileSpec := FileSpec{}
                oFileSpec:Path := CurDir()
                oFileSpec:AppendToPath("data")
                oFileSpec:FileName := "custdata"
                oDB := DBServer{oFileSpec}
            </code>
        </example>
    </FileSpec>
    <FileSpec.ctor>
        <summary>
            Construct a file specification.
        </summary>
        <param name="cFullPath">The file name containing either a full or partial path name.  If omitted, you should specify this file's path using the assign methods of the FileSpec class before the object is used.</param>
    </FileSpec.ctor>
    <FileSpec.AppendToPath>
        <summary>
            Append a subdirectory to the end of this file specification's path.
        </summary>
        <param name="cDirectory">
            The subdirectory to be appended, with or without leading and trailing slashes.  A list of subdirectories separated by slashes can also be appended.
        </param>
        <remarks>
            <note type="tip">
                If the path was previously unknown (NIL), <paramref name="cDirectory" /> becomes the new path.
            </note>
        </remarks>
        <returns>
            The resulting path.
        </returns>
        <example>
            The following examples illustrate the use of FileSpec:AppendToPath():
            <code language="X#">
                // d:\data\cust
                oFS:Path := "d:\data"
                oFS:AppendToPath("cust")
                // d:\data\cust
                oFS:Path := "d:\data"
                oFS:AppendToPath("\cust\")
                // \data
                oFS:Path := "\"
                oFS:AppendToPath("data")
                // \cust
                oFS:Path := NIL
                oFS:AppendToPath("cust")
                // d:\data\cust\1993\budget
                oFS:Path := "d:\data"
                oFS:AppendToPath("cust\1993\budget")
            </code>
        </example>
    </FileSpec.AppendToPath>
    <FileSpec.Attributes>
        <summary>
            One or more of the following characters concatenated into a string, indicating the attributes of the file represented by this file specification:
        </summary>
        <value>One or more of the following characters concatenated into a string, indicating the attributes of the file represented by this file specification:</value>
        <remarks>
            One or more of the following characters concatenated into a string, indicating the attributes of the file represented by this file specification:
            <list type="table">
                <listheader>
                    <term>Character</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>A</term>
                    <description>File whose archive bit is set</description>
                </item>
                <item>
                    <term>H</term>
                    <description>Hidden file</description>
                </item>
                <item>
                    <term>NULL_STRING</term>
                    <description>Normal read/write file</description>
                </item>
                <item>
                    <term>R</term>
                    <description>Read only file</description>
                </item>
                <item>
                    <term>S</term>
                    <description>System file</description>
                </item>
            </list><note type="tip">You can use the At() function to determine if a particular property is set.</note>
        </remarks>
        <example>
            This example checks if the file "abc.dbf" is read only:
            <code language="X#">
                oFileSpec := FileSpec("abc.dbf")
                IF AT("R", oFileSpec:Attributes) &gt; 0
                // Attribute string contains "R" therefore, the file is read only
                ...
                ENDIF
            </code>
        </example>
    </FileSpec.Attributes>
    <FileSpec.Copy>
        <summary>
            Make a copy of the file represented by this file specification.
        </summary>
        <param name="oFSTarget">The name of the target file, including an optional drive, directory, and extension.  The file is created following operating system rules.</param>
        <param name="lName">Logical parameter.  TRUE causes an auto-rename of the target file if a file conflict occurs during the copy.  The default is FALSE.</param>
        <returns>
            TRUE, if the file was successfully copied; otherwise, FALSE.
        </returns>
        <example>
            This example defines a file specification and then copies it to a target file:
            <code language="X#">
                // Define original file
                oFSSource := FileSpec{"c:\data\customer.dbf"}
                // Copy the file
                oFSSource:Copy("a:\custdata")
            </code>
        </example>
    </FileSpec.Copy>
    <FileSpec.DateChanged>
        <summary>
            A date value denoting when the file was created or last changed.  If the file is not found, NULL_DATE is returned.
        </summary>
        <value>A date value denoting when the file was created or last changed.  If the file is not found, NULL_DATE is returned.</value>
    </FileSpec.DateChanged>
    <FileSpec.Delete>
        <summary>
            Delete the file represented by this file specification.
        </summary>
        <returns>
            TRUE if the file was successfully deleted; otherwise, FALSE.
        </returns>
    </FileSpec.Delete>
    <FileSpec.Drive>
        <summary>
            A string representing the drive defined to this file specification.
        </summary>
        <value>A string representing the drive defined to this file specification.</value>
        <remarks>
            A string representing the drive defined to this file specification.  The drive may have been assigned explicitly or as part of a longer file specification (assigned either as an instantiation parameter or as part of the file name or full path).
            When accessing FileSpec:Drive, the requested drive is returned with a trailing colon.
            When assigning FileSpec:Drive, you can specify a drive with or without a colon.  Assigning a NULL_STRING (or NIL) to the drive means that the drive is unknown or unspecified; the various functions and objects that use the file specification to locate the file looks on whatever default drive would apply if a file name without a drive is specified.
        </remarks>
        <example>
            To copy selected records from a file from one disk drive to another — using the same file name and directory — you could do this:
            <code language="X#">
                // Define original file
                oFSSource := FileSpec{"c:\data\customer"}
                // Copy path for target file
                oFSTarget := FileSpec{oFSSource:FullPath}
                // Change drive for target file
                oFSTarget:Drive := "d"
                // Open original file
                oDBSource := DBServer{oFSSource}
                // Copy selected records to target file
                oDBSource:CopyDB(oFSTarget,,{||STATE="NY"})
            </code>
        </example>
    </FileSpec.Drive>
    <FileSpec.ErrInfo>
        <summary>Return the error object from the last Copy() or Move() operation.</summary>
        <value>The error object from the last Copy() or Move() operation.</value>
        <seealso cref="O:VO.FileSpec.Copy" />
        <seealso cref="O:VO.FileSpec.Move" />
    </FileSpec.ErrInfo>
    <FileSpec.Error>
        <summary>
            Provide a method for handling error conditions raised during FileSpec processing.  This is an event handler: it is automatically called by other methods; the developer does not normally need to call the error method, but might want to replace or amend it.
        </summary>
        <param name="oError">An Error object describing the error condition.</param>
        <param name="symMethod">The symbolic name of the method that originated the error.</param>
        <remarks>
            All methods of the FileSpec trap serious errors with a recover statement and send them to this method.  Ordinary failures, such as file-not-found, do not raise error conditions; they are simply indicated through failure return values.
            The standard Error() handling method fills in some more information about the errors and about the FileSpec object that originates the error and sets the status value for the server object, in its standard Error() handling method.  The method passes it up the call stack by issuing a BREAK with the same Error object.
        </remarks>
    </FileSpec.Error>
    <FileSpec.Extension>
        <summary>
            A string representing the extension defined to this file specification.
        </summary>
        <value>A string representing the extension defined to this file specification.</value>
        <remarks>
            A string representing the extension defined to this file specification.  The extension may have been assigned explicitly or as part of a longer file specification (assigned either as an instantiation parameter or as part of the file name or full path).
            When accessing FileSpec:Extension, the requested extension is returned with a leading period.
            When assigning FileSpec:Extension, you can specify an extension with or without a leading period.  Assigning a NULL_STRING (or NIL) to the extension means that the extension is unknown or unspecified; the various functions and objects that use the file specification to locate the file uses whatever default extension applies to them.
            <note type="tip">Assigning just a single period as extension explicitly specifies an "empty" extension.</note>
        </remarks>
    </FileSpec.Extension>
    <FileSpec.FileName>
        <summary>
            A string representing the file name defined to this file specification.
        </summary>
        <value>A string representing the file name defined to this file specification.</value>
        <remarks>
            A string representing the file name defined to this file specification.  The file name may have been assigned explicitly or as part of a longer file specification (assigned either as an instantiation parameter or as part of a full path assignment).
            When accessing FileSpec:FileName, the requested file name is returned without a path and extension.
            When assigning FileSpec:FileName, you can specify a simple file name, a file name with an extension, or a full path complete with drive.  The information given is parsed and assigned to the appropriate components; in addition, only those parts that are specified are changed in the file specification.
            Assigning a NULL_STRING (or NIL) means that the file name is unknown or unspecified.
        </remarks>
        <example>
            Here are some examples that use FileSpec:FileName:
            <code language="X#">
                // Changes only the file name
                oFS:FileName := "cust"
                // Changes file name and extension
                oFS:FileName := "cust.dbx"
                // Changes path and file name
                oFS:FileName := "data\cust"
                // Changes path and file name
                oFS:FileName:="\data\cust"
                // Changes drive, path, file name
                oFS:FileName:="d:cust"
            </code>
        </example>
    </FileSpec.FileName>
    <FileSpec.Find>
        <summary>
            Search the disk for the file represented by this file specification, indicate if it exists, and if so, store its full path information in this file specification for future reference.
        </summary>
        <returns>
            TRUE if the file was found; otherwise, FALSE.
        </returns>
        <remarks>
            This method searches for the file subject to all the standard settings of the SetPath() and SetDefault() functions.  If the file is found, its full path information is stored for future reference, which is useful since the initial search starts from the current directory and the same file can later be used in a DBServer, for example, when the current directory may not be the same.
        </remarks>
        <example>
            The following example, part of a method in a hypothetical data window, defines a generic file, searches for it, and then displays its full path if found:
            <code language="X#">
                oFileSpec := FileSpec{"custfile"}
                IF oFileSpec:Find()
                SELF:Caption := oFileSpec:FullPath d:\data\custfile.dbf
                ...
                SELF:Use(DBServer{oFileSpec})
                ENDIF
            </code>
        </example>
    </FileSpec.Find>
    <FileSpec.FullPath>
        <summary>
            A string representing the full path name defined to this file specification.
        </summary>
        <value>A string representing the full path name defined to this file specification.</value>
        <remarks>
            A string representing the full path name defined to this file specification.  The individual components of the full path name may have been assigned explicitly or as part of a longer file specification (assigned either as an instantiation parameter or as part of a file name or full path assignment).
            When accessing FileSpec:FullPath, the requested path name is returned with drive, path, file name, and extension.
            However, if the file was not fully specified and the file has not been found since, parts of the path can be unknown.  Any part that is not known is omitted from the return value.
            When assigning FileSpec:FullPath, you can specify a simple file name, a file name with an extension, or a full path complete with drive.  The information given is parsed and assigned to the appropriate components; in addition, when assigning a string to FileSpec:FullPath, those parts that are omitted in the string are stored as unknown or unspecified.
            <note type="tip">FileSpec does not distinguish between a file with no extension and a subdirectory (e.g., C:\CAVOxx, in which the directory "CAVOxx" appears to be a file with no extension).</note>
        </remarks>
        <example>
            Here are some examples of strings that are returned by FileSpec:FullPath, with an explanation of what they indicate:
            <code language="X#">
                // All known
                c:\data\customer\custdata.dbf
                // Drive unknown
                \data\customer\custdata.dbf
                // Path is ROOT
                c:\custdata.dbf
                // Drive and path unknown
                custdata.dbf
                // Drive unknown, path is ROOT
                \custdata.dbf
                // Extension unknown
                c:\data\customer\custdata
                // Only file name is known
                custdata
            </code>
            Here are some examples of assigning strings to FileSpec:FullPath, with an explanation of the results:
            <code language="X#">
                // Assign and display FileSpec:FullPath
                oFS:FileSpec := ("String")
                ? oFS:FullPath
                // All but file name marked unknown
                oFS:FullPath := "cust"
                // All but file name and extension marked unknown
                oFS:FullPath:= "cust.dbx"
                // Sets path and file name, marks drive and
                // extension as unknown
                oFS:FullPath := "data\cust"
                // Same thing
                oFS:FullPath := "\data\cust"
                // Changes drive, path, file name;
                // sets extension unknown
                oFS:FullPath := "d:cust"
            </code>
        </example>
    </FileSpec.FullPath>
    <FileSpec.Move>
        <summary>
            Move the file represented by this file specification to a new location.
        </summary>
        <param name="oFSTarget">The name of the target file, including an optional drive, directory, and extension.  The file is created following operating system rules.  Note that a file can be moved across volumes.</param>
        <param name="lName">Logical parameter.  TRUE causes an auto-rename of the target file if a file conflict occurs during the move.  The default is FALSE.</param>
        <returns>
            TRUE, if the file was successfully moved; otherwise, FALSE.
        </returns>
        <example>
            This examples moves and also renames a file:
            <code language="X#">
                // Define original file
                oFSSource := FileSpec{"c:\data\customer.dbf"}
                // Move the file
                oFSSource:Move("a:\custdata\customer.bak")
            </code>
        </example>
    </FileSpec.Move>
    <FileSpec.Path>
        <summary>
            A string representing the path defined to this file specification.
        </summary>
        <value>A string representing the path defined to this file specification.</value>
        <remarks>
            A string representing the path defined to this file specification.  The path may have been assigned explicitly or as part of a longer file specification (assigned either as an instantiation parameter or as part of a file name or full path assignment).
            When accessing FileSpec:Path, the requested path is returned with a leading slash and when applicable a trailing slash.
            When assigning FileSpec:Path, you can specify a path with or without leading or trailing slashes.  To specify the root, assign a single slash.  Assigning a NULL_STRING (or NIL) to the drive means that the drive is unknown or unspecified; the various functions and objects that use the file specification to locate the file looks on whatever default drive would apply if a file name without a drive is specified.
            Assigning a value to the path normally does not affect the drive, file name, or extension.  If a drive is included in the path, it is assigned to the path.
        </remarks>
        <example>
            Here are some examples of strings that are returned by FileSpec:Path, with an explanation of what they indicate:
            <code language="X#">
                \data\customer					// Path is \data\customer
                \							// Path is ROOT
                &lt;EmptyString&gt;					// Path unknown
            </code>
            Here are some examples of assigning strings to FileSpec:Path, with an explanation of the results:
            <code language="X#">
                oFS:Path := NIL				// Unknown
                oFS:Path := ""				// Unknown
                oFS:Path := "\"				// Root
                oFS:Path := "data"			// \data
                oFS:Path := "\data"			// \data
                oFS:Path := "data\"			// \data
                oFS:Path := "\data"			// \data
                oFS:Path := "data\cust"		// \data\CUST
                oFS:Path := "\data\cust"		// \data\CUST
                oFS:Path := "d:data"			// Drive = d:
                // Path = \data
                oFS:Path := "d:\data"			// Drive = d:
                // Path = \data
                oFS:Path := "d:\"			// Drive = d:
                // Path = root
                oFS:Path := "d:"				// Drive = d:
                // Path = root
            </code>
        </example>
    </FileSpec.Path>
    <FileSpec.PathUp>
        <summary>
            Remove the last subdirectory from the end of this file specification's path.
        </summary>
        <returns>
            The resulting path.
        </returns>
        <remarks>
            If the path was previously the root or unknown (NIL), PathUp() does not change the path.  Other components — drive, file name, and extension — are not affected.
        </remarks>
        <example>
            For example, to store selected data in a backup directory at a peer level to the actual data directory:
            <code language="X#">
                oFSCust := FileSpec{"c:\data\cust.dbf"}
                oFSCustBackup := FileSpec{oFSCust:FullPath}
                oFSCustBackup:PathUp()
                oFSCustBackup:AppendToPath("backup")
            </code>
        </example>
    </FileSpec.PathUp>
    <FileSpec.Rename>
        <summary>
            Rename the file represented by this file specification.
        </summary>
        <param name="oFSTarget">The new file name.</param>
        <param name="lName">
            Make a different file name if conflict exist.
            The new name will start with the base file name of the original file.
            8 character file name with 5 or 6 chars of original name plus a suffix
            ranging from "_1" to "_99" if a name conflict occurs. Otherwise returns NULL_STRING
        </param>

        <returns>
            TRUE if the file was successfully renamed; otherwise, FALSE.
        </returns>
        <example>
            The following examples renames a file:
            <code language="X#">
                oFSSource := FileSpec{"c =:\data\customer.dbf"}
                // Rename the file
                oFSSource:Rename("customer.bak")
            </code>
        </example>
    </FileSpec.Rename>
    <FileSpec.Size>
        <summary>
            A numeric value representing the size, in bytes, of the file represented by this file specification.
        </summary>
        <value>A numeric value representing the size, in bytes, of the file represented by this file specification.</value>
    </FileSpec.Size>
    <FileSpec.TimeChanged>
        <summary>
            A string indicating the time when the file was created or last changed.
        </summary>
        <value>A string indicating the time when the file was created or last changed.</value>
        <remarks>
            A string indicating the time when the file was created or last changed.  If the file is not found, "00:00:00" is returned.
        </remarks>
    </FileSpec.TimeChanged>
    <FSError>
        <exclude />
    </FSError>
    <FSError.ctor>
        <exclude />
    </FSError.ctor>
    <HLError>
        <exclude />
    </HLError>
    <HLError.ctor>
        <exclude />
    </HLError.ctor>
    <HyperLabel>
        <summary>
            Create a hyperlabel, which stores information about another object.
        </summary>
        <remarks>
            The HyperLabel class stores prompts and instructions for context-sensitive help information about another object — the host object.  The purpose of the class is to collect this kind of information in a standard way so that the various help systems (status, exception, and error management functions) within the system can process the hyperlabel without knowing anything about the host object, just as a mailing system routes packages without knowing their content.
            Hyperlabels also record the symbolic name of the host.  For example, the system uses this name to match fields with controls when linking a data window to a data source and, in the case of menu commands, to decide which method of the menu's owner to dispatch when the user commands that menu command to execute.
            Individual database columns have hyperlabels, as do data types, data windows, controls, and menu commands.  Objects delegate hyperlabels to one another.  In fact a large part of good programming with X# consists in providing full and helpful hyperlabels.  Much of the automatic behavior of the system depends for its progress on the quality of information in the hyperlabels.
            It is called a hyperlabel because the system's hypertext help system navigates by hyperlabels.
            <note type="tip">You first create a hyperlabel and then affix it to its host object by assigning to the host's hyperlabel pseudo-variable.</note>
        </remarks>
    </HyperLabel>
    <HyperLabel.ctor>
        <summary>
            Construct a hyperlabel.
        </summary>
        <param name="uName">The symbolic name that the program uses to refer to the object to which the hyperlabel attaches.  For example, if the hyperlabel attaches to a menu command, the symbolic name is the method (of the window that owns the menu) that the system invokes when the user executes that menu command.  If the hyperlabel attaches to a field, the symbol is the field's name.  In other words, the symbolic name is only useful to the program.  The other items, by contrast, are meaningful to the user.</param>
        <param name="uCaption">
            The name of the object to which the hyperlabel attaches, as recognized by the user.  If the object is a control, the caption is the name shown beside, or on, the control.  If you supply the resource ID of a string, HyperLabel:Init() extracts the string.  if not specified, the default is the same as <paramref name="symName" />, if provided; otherwise, NULL_STRING.
        </param>
        <param name="uDescription">The purpose of the host object.  For a control, the purpose tells the user what the control is for.  By default, when a control gets focus, the system displays the control's hyperlabel's description upon the status bar.  Similarly, when the user drags the mouse across the menu, each time a new command is highlighted, its hyperlabel's description appears in the status bar.  If you supply the resource ID of a string, HyperLabel:Init() extracts the string.  If not specified, the default is NULL_STRING.</param>
        <param name="uHelpContext">The string that uniquely identifies the place to jump in the hypertext help system.  In the case of Windows, this is just the context name.  The system uses the object's hyperlabel's help context to decide where to jump when the user asks for in-context help about the host object.  If you supply the resource ID of a string, HyperLabel:Init() extracts the string.  If not specified, the default is NULL_STRING.</param>
    </HyperLabel.ctor>
    <HyperLabel.AsString>
        <summary>
            Return the caption of the hyperlabel.
        </summary>
        <remarks>
            This method returns the same as HyperLabel:Caption and presents the hyperlabel as a recognizable string.
        </remarks>
    </HyperLabel.AsString>
    <HyperLabel.Caption>
        <summary>
            A string representing the short name or caption by which the user refers to the host object (to which the hyperlabel is attached).  For a menu command, this would be the text appearing in the menu itself.
        </summary>
        <value>A string representing the short name or caption by which the user refers to the host object (to which the hyperlabel is attached).  For a menu command, this would be the text appearing in the menu itself.</value>
    </HyperLabel.Caption>
    <HyperLabel.Description>
        <summary>
            A string representing the purpose of the host object (to which the hyperlabel is attached).  Typically, the system uses this as a prompt to the user or as a faster substitute for hypertext help.
        </summary>
        <value>A string representing the purpose of the host object (to which the hyperlabel is attached).  Typically, the system uses this as a prompt to the user or as a faster substitute for hypertext help.</value>
    </HyperLabel.Description>
    <HyperLabel.Error>
        <summary>
            Provide a method for handling error conditions raised during hyperlabel processing.
        </summary>
        <param name="oError">An Error object describing the error condition.</param>
        <param name="symMethod">The symbolic name of the method that originated the error.</param>
        <remarks>
            <note type="tip">This is an event handler and is automatically called by other methods; the developer does not normally need to call the HyperLabel:Error() method, but might want to replace or amend it.</note>

            The standard Error() handling method fills in some more information about the errors and about the HyperLabel object that originates the error, sets the status value for the object, and passes the problem to its client, if there is one, in its standard Error() handling method.  If there is no client who wants to deal with the problem, the method passes it up the call stack by issuing a BREAK with the same Error object.
            <note type="tip">If an error comes in while one is being handled, the Error() method immediately breaks.</note>
        </remarks>
    </HyperLabel.Error>
    <HyperLabel.HelpContext>
        <summary>
            A string representing the key or ID for the place in the hypertext system where the system looks for help concerning the host object (to which the hyperlabel is attached).
        </summary>
        <value>A string representing the key or ID for the place in the hypertext system where the system looks for help concerning the host object (to which the hyperlabel is attached).</value>
    </HyperLabel.HelpContext>
    <HyperLabel.Name>
        <summary>
            A string representing the name of the host object to which the hyperlabel is attached.
        </summary>
        <value>A string representing the name of the host object to which the hyperlabel is attached.</value>
    </HyperLabel.Name>
    <HyperLabel.NameSym>
        <summary>
            A symbol representing the name of the host object to which the hyperlabel is attached.
        </summary>
        <value>A symbol representing the name of the host object to which the hyperlabel is attached.</value>
    </HyperLabel.NameSym>
    <IntegerFS>
        <summary>
            Create an integer field specification, which holds integer data type information.
        </summary>
    </IntegerFS>
    <IntegerFS.ctor>
        <summary>
            Construct an integer field specification.
        </summary>
        <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new integer field specification.</param>
        <param name="uLength">The length of the field.  If not specified, the default is 10.</param>
    </IntegerFS.ctor>
    <LogicFS>
        <summary>
            Create a logic field specification, which holds logic data type information.
        </summary>
    </LogicFS>
    <LogicFS.ctor>
        <summary>
            Construct a logic field specification.
        </summary>
        <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new logic field specification.</param>
    </LogicFS.ctor>
    <MoneyFS>
        <summary>
            Create a money field specification, which holds money data type information.
        </summary>
    </MoneyFS>
    <MoneyFS.ctor>
        <summary>
            Construct a money field specification.
        </summary>
        <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new money field specification.</param>
        <param name="uLength">The length of the field.  If not specified, the default is 12.</param>
        <param name="uDecimals">The number of decimals in the field.  If not specified, the default is 2.</param>
    </MoneyFS.ctor>
    <NumberFS>
        <summary>
            Create a number field specification, which holds numeric data type information.
        </summary>
    </NumberFS>
    <NumberFS.ctor>
        <summary>
            Construct a numeric field specification.
        </summary>
        <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new number field specification.</param>
        <param name="uLength">The length of the field.  If not specified, the default is 12.</param>
        <param name="uDecimals">The number of decimals in the field.  If not specified, the default is 2.</param>
    </NumberFS.ctor>
    <ObjCodeBlock>
        <exclude />
    </ObjCodeBlock>
    <ObjCodeBlock.ctor>
        <exclude />
    </ObjCodeBlock.ctor>
    <ObjCodeBlock.Eval>
        <exclude />
    </ObjCodeBlock.Eval>
    <StringFS>
        <summary>
            Create a string field specification, which holds string data type information.
        </summary>
    </StringFS>
    <StringFS.ctor>
        <summary>
            Construct a string field specification.
        </summary>
        <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new string field specification.</param>
        <param name="uLength">The length of the field.  If not specified, the default is 10.</param>
    </StringFS.ctor>
</doc>
