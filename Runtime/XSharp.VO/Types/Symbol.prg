//
// Copyright (c) XSharp B.V.  All Rights Reserved.
// Licensed under the Apache License, Version 2.0.
// See License.txt in the project root for license information.
//

USING System
USING System.Collections
USING System.Collections.Generic
USING System.Diagnostics
USING System.Runtime.CompilerServices

BEGIN NAMESPACE XSharp
    /// <summary>Internal type that implements the VO Compatible SYMBOL type.<br/>
    /// This type has many operators and implicit converters that normally are never directly called from user code.<br/>
    /// There are also some operators that handle implicit conversions between Symbols and Strings in your code.
    /// </summary>
    [DebuggerDisplay("{_value,nq}",Type := "SYMBOL")];
    [DebuggerTypeProxy(TYPEOF(SymbolDebugView))];
    PUBLIC STRUCTURE __Symbol ;
    IMPLEMENTS IEqualityComparer<__Symbol>, ;
    IEquatable<__Symbol>,;
    IComparable<__Symbol>, ;
    IComparable, ;
    ICloneable , ;
    IConvertible

        #region fields
        PRIVATE INITONLY _index		AS DWORD
        PRIVATE STATIC _PszDict			AS Dictionary<DWORD, PSZ>
        #endregion

        #region constrúctors
        /// <summary>Construct the type and create the SymbolTable.</summary>
        STATIC CONSTRUCTOR
            SymbolTable.Initialize()

            /// <summary>This constructor is used in code generated by the compiler when needed.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)];
        CONSTRUCTOR(sValue AS STRING)
            SELF(sValue, TRUE)

        /// <summary>This constructor is used in code generated by the compiler when needed.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)];
        CONSTRUCTOR(sValue AS STRING,  upperCase AS LOGIC)
            IF (upperCase)
                sValue := sValue:ToUpperInvariant()
            ENDIF
            _index := SymbolTable.Add(sValue)
            RETURN

        [MethodImpl(MethodImplOptions.AggressiveInlining)];
        PRIVATE CONSTRUCTOR (dwValue AS DWORD)
            SELF:_index := dwValue

        #endregion
        INTERNAL STATIC METHOD Find(sValue AS STRING ) AS __symbol
            IF SymbolTable:LookupTable:ContainsKey(sValue)
                VAR index := __Symbol.SymbolTable:LookupTable[sValue]
                RETURN __Symbol{index}
            ENDIF
            RETURN __Symbol{0}


        INTERNAL PROPERTY _value AS STRING
            GET
                RETURN SymbolTable.GetString(SELF:_index)
            END GET
        END PROPERTY
        INTERNAL STATIC PROPERTY PszDict AS Dictionary<DWORD, PSZ>
            GET
                IF _pszDict == NULL
                    _pszDict := Dictionary<DWORD, PSZ>{}
                ENDIF
                RETURN _PszDict
            END GET
        END PROPERTY

        #region methods
        /// <inheritdoc />
        VIRTUAL METHOD EQUALS(obj AS OBJECT) AS LOGIC
            LOCAL rhs AS SYMBOL
            IF (obj == NULL)
                RETURN FALSE
            ENDIF
            rhs := (SYMBOL) obj
            RETURN SELF:Equals(rhs)

            /// <inheritdoc />
        VIRTUAL METHOD GetHashCode() AS LONG
            RETURN (INT) SELF:_index

            /// <inheritdoc />
        METHOD GetHashCode(s AS __Symbol) AS LONG
            RETURN (INT) s:_index

            /// <inheritdoc />
        VIRTUAL METHOD ToString() AS STRING
            RETURN _value

            /// <exclude />
        METHOD SysGetAtomName() AS PSZ
            IF PszDict:ContainsKey(_index)
                RETURN PszDict[_index]
            ENDIF
            LOCAL pszAtom AS PSZ
            pszAtom := __Psz.CreatePsz(_value)
            PszDict:add(_index, pszAtom)
            RETURN pszAtom

            #endregion

        #region Equality
        /// <inheritdoc />
        METHOD @@Equals(symOther AS SYMBOL) AS LOGIC
            RETURN SELF:_index == symOther:_index

            /// <inheritdoc />
        METHOD @@Equals(x AS SYMBOL, y AS SYMBOL) AS LOGIC
            RETURN x:_index == y:_index

            /// <exclude />
        METHOD @@Equals(s AS STRING) AS LOGIC
            RETURN SELF:_value == s

            #endregion
        #region Operators

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR ==(lhs AS SYMBOL, rhs AS SYMBOL) AS LOGIC
            RETURN lhs:_index == rhs:_index

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR !=(a AS SYMBOL, b AS SYMBOL) AS LOGIC
            RETURN a:_index != b:_index

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR ==(lhs AS SYMBOL, rhs AS STRING) AS LOGIC
            RETURN lhs:_value == rhs

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR !=(lhs AS SYMBOL, rhs AS STRING) AS LOGIC
            RETURN lhs:_value != rhs

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR ==(lhs AS STRING, rhs AS SYMBOL) AS LOGIC
            RETURN lhs == rhs:_value

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR !=(lhs AS STRING, rhs AS SYMBOL) AS LOGIC
            RETURN lhs != rhs:_value

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR ==(lhs AS SYMBOL, rhs AS DWORD) AS LOGIC
            RETURN lhs:_index == rhs

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR !=(lhs AS SYMBOL, rhs AS DWORD) AS LOGIC
            RETURN lhs:_index != rhs

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR ==(lhs AS DWORD, rhs AS SYMBOL) AS LOGIC
            RETURN lhs == rhs:_index

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR !=(lhs AS DWORD, rhs AS SYMBOL) AS LOGIC
            RETURN lhs != rhs:_index

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR EXPLICIT(dwValue AS DWORD) AS SYMBOL
                IF dwValue <= SymbolTable.Count
					RETURN SYMBOL{dwValue}
				ENDIF
            RETURN SYMBOL{0}

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR EXPLICIT(symValue AS SYMBOL) AS DWORD
            RETURN symValue:_index

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR IMPLICIT(sValue AS STRING) AS SYMBOL
            RETURN SYMBOL{sValue, TRUE}

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR IMPLICIT(symValue AS SYMBOL) AS STRING
            RETURN symValue:_value

            // relative comparisons
        // compare symbols or symbols and strings
        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR >(lhs AS SYMBOL, rhs AS SYMBOL) AS LOGIC
            RETURN __StringCompare(lhs:_value, rhs:_value) > 0

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR >(lhs AS SYMBOL, rhs AS STRING) AS LOGIC
            RETURN __StringCompare(lhs:_value, rhs) > 0

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR >(lhs AS STRING, rhs AS SYMBOL) AS LOGIC
            RETURN __StringCompare(lhs, rhs:_value) > 0

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR <(lhs AS SYMBOL, rhs AS SYMBOL) AS LOGIC
            RETURN __StringCompare(lhs:_value, rhs:_value) < 0

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR <(lhs AS SYMBOL, rhs AS STRING) AS LOGIC
            RETURN __StringCompare(lhs:_value, rhs) < 0

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR <(lhs AS STRING, rhs AS SYMBOL) AS LOGIC
            RETURN __StringCompare(lhs, rhs:_value) < 0

        // or Equals
        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR >=(lhs AS SYMBOL, rhs AS SYMBOL) AS LOGIC
            RETURN __StringCompare(lhs:_value, rhs:_value) >= 0

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR >=(lhs AS SYMBOL, rhs AS STRING) AS LOGIC
            RETURN __StringCompare(lhs:_value, rhs) >= 0

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR >=(lhs AS STRING, rhs AS SYMBOL) AS LOGIC
            RETURN __StringCompare(lhs, rhs:_value) >= 0

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR <=(lhs AS SYMBOL, rhs AS SYMBOL) AS LOGIC
            RETURN __StringCompare(lhs:_value, rhs:_value) <= 0

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR <=(lhs AS SYMBOL, rhs AS STRING) AS LOGIC
            RETURN __StringCompare(lhs:_value, rhs) <= 0

        /// <summary>This operator is used in code generated by the compiler when needed.</summary>
            STATIC OPERATOR <=(lhs AS STRING, rhs AS SYMBOL) AS LOGIC
            RETURN __StringCompare(lhs, rhs:_value) <= 0

        #endregion


        #region INTERNAL types
            INTERNAL STATIC  CLASS SymbolTable
            #region fields
            // Note that we are not using a ConcurrentDictionary since we want to keep the LookupTable and List
            // in sync. Therefore we handle our own locking in this class
            STATIC INTERNAL LookupTable AS Dictionary<STRING,DWORD>
            STATIC INTERNAL Strings		AS List<STRING>
            STATIC PRIVATE sync AS OBJECT
            #endregion

            #region constructors
                STATIC METHOD Initialize() AS VOID
                sync		:= OBJECT{}
                LookupTable := Dictionary<STRING,DWORD>{}
                Strings := List<STRING>{}
                LookupTable:Add("", 0)
                Strings:Add("")
            #endregion

            #region methods
                INTERNAL STATIC METHOD ADD(strValue AS STRING) AS DWORD
                LOCAL index := 0 AS DWORD
                    BEGIN LOCK sync
                        IF (LookupTable:ContainsKey(strValue))
                        index := LookupTable[strValue]
                            ELSE
                            index := (DWORD) LookupTable:Count
                        LookupTable:Add(strValue, index)
                    Strings:Add(strValue)
                ENDIF
                END LOCK
            RETURN index

                INTERNAL STATIC METHOD GetString(index AS DWORD) AS STRING
                    IF (INT) index < Strings:Count
                RETURN Strings[(INT) index]
                ENDIF
            RETURN ""

                INTERNAL STATIC PROPERTY Count AS LONG
                    GET
                RETURN LookupTable:Count
            END GET
            END PROPERTY

            #endregion

        END CLASS
        #endregion


            METHOD CompareTo(o AS OBJECT) AS LONG
            RETURN CompareTo((SYMBOL)o)


            METHOD CompareTo(rhs AS SYMBOL) AS LONG
            RETURN __StringCompare(SELF:_value, rhs:_value)

            #region IConvertible Methods

            /// <inheritdoc />
                METHOD IConvertible.GetTypeCode() AS TypeCode
                RETURN TypeCode.Object

            /// <inheritdoc />
                METHOD IConvertible.ToBoolean( provider AS IFormatProvider ) AS LOGIC
                RETURN ((IConvertible)_value):ToBoolean( provider )

            /// <inheritdoc />
                METHOD IConvertible.ToByte( provider AS IFormatProvider ) AS BYTE
                RETURN ((IConvertible)_value):ToByte( provider )

            /// <inheritdoc />
                METHOD IConvertible.ToChar( provider AS IFormatProvider ) AS CHAR
                RETURN ((IConvertible)_value):ToChar( provider )

            /// <inheritdoc />
                METHOD IConvertible.ToDateTime( provider AS IFormatProvider ) AS DateTime
                RETURN ((IConvertible)_value):ToDateTime( provider )

            /// <inheritdoc />
                METHOD IConvertible.ToDecimal( provider AS IFormatProvider ) AS Decimal
                RETURN ((IConvertible)_value):ToDecimal( provider )

            /// <inheritdoc />
                METHOD IConvertible.ToDouble( provider AS IFormatProvider ) AS Double
                RETURN ((IConvertible)_value):ToDouble( provider )

            /// <inheritdoc />
                METHOD IConvertible.ToInt16( provider AS IFormatProvider ) AS Int16
                RETURN ((IConvertible)_value):ToInt16( provider )

            /// <inheritdoc />
                METHOD IConvertible.ToInt32( provider AS IFormatProvider ) AS Int32
                RETURN ((IConvertible)_value):ToInt32( provider )

            /// <inheritdoc />
                METHOD IConvertible.ToInt64( provider AS IFormatProvider ) AS INT64
                RETURN ((IConvertible)_value):ToInt64( provider )

            /// <inheritdoc />
                METHOD IConvertible.ToSByte( provider AS IFormatProvider ) AS SByte
                RETURN ((IConvertible)_value):ToSByte( provider )

            /// <inheritdoc />
                METHOD IConvertible.ToSingle( provider AS IFormatProvider ) AS Single
                RETURN ((IConvertible)_value):ToSingle( provider )

            /// <inheritdoc />
                METHOD IConvertible.ToString( provider AS IFormatProvider ) AS STRING
                RETURN ((IConvertible)_value):ToString( provider )

            /// <inheritdoc />
                METHOD IConvertible.ToType( conversionType AS Type, provider AS IFormatProvider ) AS OBJECT
                RETURN ((IConvertible)_value):ToType( conversionType, provider )

            /// <inheritdoc />
                METHOD IConvertible.ToUInt16( provider AS IFormatProvider ) AS UInt16
                RETURN ((IConvertible)_value):ToUInt16( provider )

            /// <inheritdoc />
                METHOD IConvertible.ToUInt32( provider AS IFormatProvider ) AS UInt32
                RETURN ((IConvertible)_value):ToUInt32( provider )

            /// <inheritdoc />
                METHOD IConvertible.ToUInt64( provider AS IFormatProvider ) AS UINT64
                RETURN ((IConvertible)_value):ToUInt64( provider )

            #endregion
            #region IClonable
            /// <exclude />
                METHOD Clone() AS OBJECT
                RETURN SYMBOL{SELF:_index}
            #endregion

            #region IEnumerable
            // Vulcan.Symbol
            //METHOD GetEnumerator() as IEnumerator
            //return SymbolTable.strings.GetEnumerator()

    #endregion
    END STRUCTURE
        INTERNAL CLASS SymbolDebugView
        PRIVATE _svalue AS SYMBOL
            CONSTRUCTOR( s AS SYMBOL)
        _svalue := s

        [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] ;
        PUBLIC PROPERTY VALUE AS OBJECT GET _svalue:_VALUE

    END CLASS

END NAMESPACE
