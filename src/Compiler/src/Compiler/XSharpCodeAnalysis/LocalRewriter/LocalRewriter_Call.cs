//
// Copyright (c) XSharp B.V.  All Rights Reserved.
// Licensed under the Apache License, Version 2.0.
// See License.txt in the project root for license information.
//

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using LanguageService.CodeAnalysis.XSharp.SyntaxParser;
using Microsoft.CodeAnalysis.CSharp.Symbols;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.PooledObjects;
using Roslyn.Utilities;

namespace Microsoft.CodeAnalysis.CSharp
{
    internal partial class LocalRewriter
    {
        private BoundExpression XsAdjustBoundCall(BoundExpression expression)
        {
            if (expression.Syntax is null || expression.SyntaxTree is null )
                return expression;
            var root = expression.SyntaxTree.GetRoot() as CompilationUnitSyntax;
            if (root is null)
                return expression;

            // find the current member to see if we have a local SELF or THIS
            var parent = expression.Syntax.Parent;
            while (parent != null && !(parent is MemberDeclarationSyntax))
            {
                parent = parent.Parent;
            }
            bool isStatic = false;
            if (parent is MemberDeclarationSyntax mds)
            {

                var mods = mds.Modifiers;
                isStatic = mods.Any(SyntaxKind.StaticKeyword);
            }
            // check if MethodSymbol has the NeedAccessToLocals attribute combined with /memvars and the FoxPro Dialect
            // if that is the case then the node is registered  in the FunctionsThatNeedAccessToLocals dictionary
            if (root.GetLocalsForFunction(expression.Syntax.CsNode, out var writeAccess,
                out var localsymbols) )
            {
                int count = 0;
                foreach (var sym in localsymbols)
                {
                    if (sym.Name.IndexOf("$") == -1)
                        count++;
                }
                if (count == 0 && isStatic)
                    return expression;
                // write prelude and after code
                // prelude code should register the locals
                /*
                    assume the following code:

                    LOCAL a := "Robert" AS STRING
                    LOCAL b := 42 AS LONG
                    ? Type(b")
                    RETURN
                    // This code gets generated by the compiler to allow the Type() function to access the locals

                    __LocalPut("a", a)
                    __LocalPut("b", b)
                    var temp := Type(b")
                    IF __LocalsUpdated()
                    a := __LocalGet("a")
                    b := __LocalGet("b")
                    ENDIF
                    __LocalsClear()
                */
                var rtType = _compilation.RuntimeFunctionsType();
                var exprs = ImmutableArray.CreateBuilder<BoundExpression>();
                var block = ImmutableArray.CreateBuilder<BoundExpression>();
                var usual = _compilation.UsualType();
                _factory.Syntax = expression.Syntax;

                if (!isStatic)
                {
                    BoundExpression value = new BoundThisReference(expression.Syntax, _compilation.GetSpecialType(SpecialType.System_Object));
                    value = MakeConversionNode(value, usual, false);
                    var localname = _factory.Literal("_THIS");
                    var mcall = _factory.StaticCall(rtType, ReservedNames.LocalPut, localname, value);
                    mcall.WasCompilerGenerated = true;
                    exprs.Add(mcall);
                }

                foreach (var symbol in localsymbols)
                {
                    var name = symbol.Name;
                    if (name.IndexOf("$") >= 0)
                        continue;
                    BoundExpression? localvar = null;
                    if (symbol is LocalSymbol ls)
                    {
                        localvar = _factory.Local(ls);
                    }
                    else if (symbol is ParameterSymbol ps)
                    {
                        localvar = _factory.Parameter(ps);
                    }
                    else
                    {
                        continue;
                    }
                    var varType = localvar.Type;
                    var localname = _factory.Literal(name);
                    count++;
                    // __LocalPut("name", (USUAL) localvar)
                    var value = MakeConversionNode(localvar, usual, false);
                    value.WasCompilerGenerated = true;
                    var mcall = _factory.StaticCall(rtType, ReservedNames.LocalPut, localname, value);
                    mcall.WasCompilerGenerated = true;
                    exprs.Add(mcall);

                    // create assignment expression for inside the block that is executed when locals are updated
                    // LocalVar := (CorrectType) __LocalGet("name")
                    mcall = _factory.StaticCall(rtType, ReservedNames.LocalGet, localname);
                    mcall.WasCompilerGenerated = true;
                    value = MakeConversionNode(mcall, localvar.Type!, false);
                    value.WasCompilerGenerated = true;
                    var ass = _factory.AssignmentExpression(localvar, value);
                    ass.WasCompilerGenerated = true;
                    block.Add(ass);
                }
                // we need an array of the local symbols for the sequence
                var locals = ImmutableArray.CreateBuilder<LocalSymbol>();
                var type = expression.Type ?? _compilation.GetSpecialType(SpecialType.System_Object);
                var isVoid = type.SpecialType == SpecialType.System_Void;
                var tempSym = _factory.SynthesizedLocal(type);
                locals.Add(tempSym);
                var tempLocal = _factory.Local(tempSym);
                if (!isVoid)
                {
                    var callorig = _factory.AssignmentExpression(tempLocal, expression);
                    exprs.Add(callorig);
                }
                else
                {
                    exprs.Add(expression);
                }
                if (writeAccess)
                {
                    // create condition  __LocalsUpdated()
                    var cond = _factory.StaticCall(rtType, ReservedNames.LocalsUpdated);
                    var t = _factory.Literal(true);
                    var f = _factory.Literal(false);
                    cond.WasCompilerGenerated = true;
                    // create a sequence with the assignment expressions, return true (because the conditional expression needs a value)
                    var assignmentsequence = _factory.Sequence(block.ToArray(), t);
                    assignmentsequence.WasCompilerGenerated = true;
                    // iif ( __localupdated(), <assignmentsequence>, false)
                    var condexpr = _factory.Conditional(cond, assignmentsequence, f, _compilation.GetSpecialType(SpecialType.System_Boolean));
                    condexpr.WasCompilerGenerated = true;
                    exprs.Add(condexpr);
                }
                if (count > 0)
                {
                    // __LocalsClear()
                    var clear = _factory.StaticCall(rtType, ReservedNames.LocalsClear);
                    exprs.Add(VisitExpression(clear));
                }

                // create a sequence that returns the temp var.
                expression = _factory.Sequence(locals.ToImmutable(), exprs.ToImmutable(), tempLocal);

            }
            return expression;
        }


    }
}
