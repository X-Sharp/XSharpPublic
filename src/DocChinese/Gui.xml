<?xml version="1.0" encoding="utf-8"?>
<doc>
  <members>
  </members>
  <EditConstants>
    <span>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>Windows API 常量</description>
        </listheader>
        <item>
          <term>
            EDITAUTOHSCROLL
          </term>
          <description>ES_AUTOHSCROLL</description>
        </item>
        <item>
          <term>
            EDITAUTOVSCROLL
          </term>
          <description>ES_AUTOVSCROLL</description>
        </item>
        <item>
          <term>
            EDITBORDERED
          </term>
          <description>WS_BORDER</description>
        </item>
        <item>
          <term>
            EDITCENTER
          </term>
          <description>ES_CENTER</description>
        </item>
        <item>
          <term>
            EDITLEFT
          </term>
          <description>ES_LEFT</description>
        </item>
        <item>
          <term>
            EDITLOWERCASE
          </term>
          <description>ES_LOWERCASE</description>
        </item>
        <item>
          <term>
            EDITMULTILINE
          </term>
          <description>ES_MULTILINE</description>
        </item>
        <item>
          <term>
            EDITNOHIDESEL
          </term>
          <description>ES_NOHIDESEL</description>
        </item>
        <item>
          <term>
            EDITOEMCONVERT
          </term>
          <description>ES_OEMCONVERT</description>
        </item>
        <item>
          <term>
            EDITPASSWORD
          </term>
          <description>ES_PASSWORD</description>
        </item>
        <item>
          <term>
            EDITREADONLY
          </term>
          <description>ES_READONLY</description>
        </item>
        <item>
          <term>
            EDITRIGHT
          </term>
          <description>ES_RIGHT</description>
        </item>
        <item>
          <term>
            EDITUPPERCASE
          </term>
          <description>ES_UPPERCASE</description>
        </item>
        <item>
          <term>
            EDITWANTRETURN
          </term>
          <description>ES_WANTRETURN</description>
        </item>
      </list>
    </span>
  </EditConstants>

  <Alignment>
    <span>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>GBAALIGNCENTER</term>
          <description>居中对齐</description>
        </item>
        <item>
          <term>GBAALIGNLEFT</term>
          <description> 左对齐(这是文本的<b>默认</b>设置) </description>
        </item>
        <item>
          <term>GBAALIGNRIGHT</term>
          <description> 右对齐(这是数值数据的<b>默认</b>设置) </description>
        </item>
      </list>
    </span>
  </Alignment>

  <BrowseStyle>
    <span>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>GBSCONTROL2D</term>
          <description>文本在一个平面矩形上</description>
        </item>
        <item>
          <term>GBSCONTROL3D</term>
          <description>三维按钮</description>
        </item>
        <item>
          <term>GBSEDIT</term>
          <description>使浏览器“可编辑”(关闭只读样式)</description>
        </item>
        <item>
          <term>GBSREADONLY</term>
          <description>使浏览器只读(文本不可更改)</description>
        </item>
      </list>
    </span>
  </BrowseStyle>

  <SplitBar>
    <span>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>GBSSBLEFT</term>
          <description>将分割条放置在浏览器的左边缘</description>
        </item>
        <item>
          <term>GBSSBMIDDLE</term>
          <description>将分割条放置在浏览器的中间</description>
        </item>
        <item>
          <term>GBSSBRIGHT</term>
          <description>将分割条放置在浏览器的右边缘</description>
        </item>
      </list>
    </span>
  </SplitBar>

  <Where>
    <span>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>GBLCOLCAPTION</term>
          <description>列标题区域</description>
        </item>
        <item>
          <term>GBLHITEXT</term>
          <description>数据区域中高亮(选中)的文本</description>
        </item>
        <item>
          <term>GBLTEXT</term>
          <description>数据展示区域中的文本。这是默认值</description>
        </item>
      </list>
    </span>
  </Where>

  <Colors>
    <span>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>颜色</description>
        </listheader>
        <item>
          <term>COLORBLACK</term>
          <description>黑色</description>
        </item>
        <item>
          <term>COLORBLUE</term>
          <description>蓝色</description>
        </item>
        <item>
          <term>COLORCYAN</term>
          <description>青色</description>
        </item>
        <item>
          <term>COLORGREEN</term>
          <description>绿色</description>
        </item>
        <item>
          <term>COLORMAGENTA</term>
          <description>洋红色</description>
        </item>
        <item>
          <term>COLORRED</term>
          <description>红色</description>
        </item>
        <item>
          <term>COLORWHITE</term>
          <description>白色</description>
        </item>
        <item>
          <term>COLORYELLOW</term>
          <description>黄色</description>
        </item>
      </list>
    </span>
  </Colors>

  <LBStyles>
    <span> 可能的样式值为： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>Windows API 常量</description>
        </listheader>
        <item>
          <term>LBOXDISABLENOSCROLL</term>
          <description>禁用，无滚动条</description>
        </item>
        <item>
          <term>LBOXEXTENDEDSEL</term>
          <description>扩展选择</description>
        </item>
        <item>
          <term>LBOXHASSTRINGS</term>
          <description>包含字符串</description>
        </item>
        <item>
          <term>LBOXMULTICOLUMN</term>
          <description>多列</description>
        </item>
        <item>
          <term>LBOXMULTIPLESEL</term>
          <description>多重选择</description>
        </item>
        <item>
          <term>LBOXNOINTEGRALHEIGHT</term>
          <description>无整数高度</description>
        </item>
        <item>
          <term>LBOXNOREDRAW</term>
          <description>不重绘</description>
        </item>
        <item>
          <term>LBOXNOTIFY</term>
          <description>通知</description>
        </item>
        <item>
          <term>LBOXOWNERDRAWFIXED</term>
          <description>固定所有者绘制</description>
        </item>
        <item>
          <term>LBOXOWNERDRAWVARIABLE</term>
          <description>可变所有者绘制</description>
        </item>
        <item>
          <term>LBOXSORT</term>
          <description>排序</description>
        </item>
        <item>
          <term>LBOXSTANDARD</term>
          <description>标准</description>
        </item>
        <item>
          <term>LBOXUSETABSTOPS</term>
          <description>使用制表位</description>
        </item>
        <item>
          <term>LBOXWANTKEYBOARDINPUT</term>
          <description>需要键盘输入</description>
        </item>
      </list>
    </span>
  </LBStyles>

  <CBStyles>
    <span>
      <list type="table">
        <listheader>
          <term>常量</term>
        </listheader>
        <item>
          <term>CBS_AUTOHSCROLL</term>
          <description></description>
        </item>
        <item>
          <term>CBS_DISABLENOSCROLL</term>
          <description></description>
        </item>
        <item>
          <term>CBS_DROPDOWN</term>
          <description></description>
        </item>
        <item>
          <term>CBS_DROPDOWNLIST</term>
          <description></description>
        </item>
        <item>
          <term>CBS_HASSTRINGS</term>
          <description></description>
        </item>
        <item>
          <term>CBS_LOWERCASE</term>
          <description></description>
        </item>
        <item>
          <term>CBS_NOINTEGRALHEIGHT</term>
          <description></description>
        </item>
        <item>
          <term>CBS_OEMCONVERT</term>
          <description></description>
        </item>
        <item>
          <term>CBS_OWNERDRAWFIXED</term>
          <description></description>
        </item>
        <item>
          <term>CBS_OWNERDRAWVARIABLE</term>
          <description></description>
        </item>
        <item>
          <term>CBS_SIMPLE</term>
          <description></description>
        </item>
        <item>
          <term>CBS_SORT</term>
          <description></description>
        </item>
        <item>
          <term>CBS_UPPERCASE</term>
          <description></description>
        </item>
      </list>
    </span>
  </CBStyles>

  <Callback>
    <span>
      <note type="tip">
        <font color="red">
          重要！这是一个由 X# 使用的回调方法。通常情况下，不应在您的应用程序代码中调用它。
        </font>
      </note>
    </span>
  </Callback>

  <NoIVar>
    <span>
      <note type="tip">
        <font color="red">
          重要！此消息不应直接调用。它由系统调用以处理无效引用。
        </font>
      </note>
    </span>
  </NoIVar>

  <ReturnsLogic>
    <returns>
      如果成功则返回 TRUE；否则返回 FALSE。
    </returns>
  </ReturnsLogic>

  <ReturnsString>
    <returns>
      如果成功，返回包含指定值的字符串；否则返回 NULL_STRING。
    </returns>
  </ReturnsString>

  <Accelerator>
    <summary>
      创建一个加速键表。
    </summary>
    <remarks>
      许多应用程序使用加速键作为菜单选择的键盘等效项。<br />
      加速键是与特定菜单命令相关联的按键序列——使用加速键可以执行菜单命令，而无需应用程序用户先显示菜单然后选择命令。
      例如，如果“文件新建”命令有一个加速键 Ctrl+N，您可以简单地按下这个组合键来打开一个新文档，而不必选择“文件”菜单然后选择“新建”命令。<br />
      每个窗口都可以使用 Window:Accelerator 属性赋予其自己的加速键。<br />
      加速键生成事件，就像其关联的菜单命令实际上被选择了一样。<br />
      注意，加速键的菜单命令甚至不必在任何菜单上可见——因此加速键可以被视为生成命令事件的直接按键序列。
    </remarks>
    <example> 
      以下示例演示了 Accelerator 类的使用： 
      <code language="X#">
          METHOD Init() CLASS MyTopAppWindow
          SUPER:Init()
          SELF:Show()
          SELF:Accelerator := Accelerator{IDA_HOTKEYS}
      </code>
      在 Windows 中，使用资源实体中的 ACCELERATORS 语句创建加速键对象。<br />
      例如，以下定义了三个加速键：“^X”用于退出菜单命令，“Ctrl+Insert”用于复制菜单命令，“Shift+Insert”用于粘贴菜单命令。 
      <code language="X#">
          RESOURCE IDA_HOTKEYS ACCELERATORS
          BEGIN
          ^X, IDMI_EXIT
          VK_INSERT, IDMI_COPY, VIRTKEY, CONTROL
          VK_INSERT, IDMI_PASTE, VIRTKEY, SHIFT
          END
      </code>
    </example>
  </Accelerator>

  <Accelerator.ctor>
    <summary>
      从资源实体加载一个加速键表。
    </summary>
    <param name="xResourceID">加速键表的资源 ID，或另一个加速键对象，其加速键将被复制。</param>
    <remarks>
      当没有传递参数时，X# 将创建一个动态加速键。如果传递了另一个加速键，X# 将复制其加速键表。
      实际的 Windows 加速键的创建会延迟到首次使用加速键时。
    </remarks>
  </Accelerator.ctor>

  <Accelerator.AddAccelerator>
    <summary>
      将一个加速键对象的所有加速键添加到另一个对象中
    </summary>
    <param name="oAccelerator">现有的加速键对象，其加速键将被复制。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks> 
      此方法将加速键从一个加速键对象复制到另一个对象。 
      <note type="tip">
        在首次使用动态加速键对象后，不能再添加加速键。
      </note>
    </remarks>
  </Accelerator.AddAccelerator>

  <Accelerator.AddKey>
    <summary>
      向加速键表中添加一个新的加速键
    </summary>
    <param name="nMenuItemId">当按下加速键时，与 MenuComandEvent{} 一起发送的加速键 ID。</param>
    <param name="xKeyId">可以是一个与 Windows 虚拟按键代码相同的数字 VO 按键代码，也可以是一个包含一个字符的字符串，用于指定字符代码。</param>
    <param name="lCtrl">当为 TRUE 时，按下加速键时必须按住 CTRL 键。</param>
    <param name="lAlt">当为 TRUE 时，按下加速键时必须按住 ALT 键。</param>
    <param name="lShift">当为 TRUE 时，按下加速键时必须按住 SHIFT 键。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">
        在首次使用动态加速键对象后，不能再添加加速键。
      </note>
    </remarks>
  </Accelerator.AddKey>

  <Accelerator.Create>
    <summary>
      <para>创建底层的 Windows 加速键。</para>
    </summary>
    <returns>
      <para>如果成功，返回加速键的句柄。如果控件创建失败，则返回空句柄(NULL_PTR)。</para>
    </returns>
  </Accelerator.Create>

  <Accelerator.Destroy>
    <summary>
      提供一种方法来销毁加速键对象。
    </summary>
    <remarks>
      当不再需要加速键对象时，可以使用此方法。<br/>
      Accelerator:Destroy() 销毁加速键对象，并允许您关闭和释放对象打开或创建的任何资源，而无需等待垃圾收集器。
    </remarks>
    <returns>
      NIL
    </returns>
  </Accelerator.Destroy>

  <Accelerator.Empty>
    <summary>
      当加速键表中没有键时返回 TRUE。
    </summary>
    <value>当加速键表中没有键时返回 TRUE。</value>
  </Accelerator.Empty>

  <Accelerator.Handle>
    <summary>
      返回加速键的句柄。
    </summary>
    <returns>
      描述底层系统对象的句柄。
    </returns>
    <remarks>
      此方法提供 Windows GDI 对象的句柄，然后可以由 Windows API GDI 调用使用。<br />
      当加速键对象是“动态”时，这将创建实际的 Windows GDI 对象，并且不能再向加速键添加加速键。
    </remarks>
  </Accelerator.Handle>

  <ActiveXControl>
    <summary>
      ActiveX 控件对象的基类。
    </summary>
    <remarks> 
      ActiveXControl 类用作在 X# 中开发的 ActiveX 控件的基类。表示 ActiveX 控件的主类必须从此类派生。 
      <note type="tip">
        在 IDE 中创建 ActiveX 控件时，必须在应用程序选项对话框的 OLE 服务选项卡页面上的 OCX 基本编辑控件中指定从 ActiveXControl 派生的类。
      </note>
    </remarks>
  </ActiveXControl>

  <ActiveXControl.ctor>
    <summary>
      实例化一个 ActiveXControl 对象。<br />
      Init() 由 ActiveX 容器自动调用。通常，不应从应用程序代码中调用它。
    </summary>
    <param name="hObject">表示对象的句柄(指针)。</param>
    <remarks>
      此方法实例化一个 ActiveXControl 对象。<br />
      与其他 Init() 方法不同，ActiveXControl:Init() 不应直接从 X# 应用程序代码中调用。相反，它由创建 ActiveX 对象的 ActiveX 容器调用。<br />
      有关详细信息，请参阅在线帮助的“如何”部分中的在 X# 中创建 OLE 服务，以及可以从应用程序库的示例选项卡页面访问的示例应用程序。
    </remarks>
  </ActiveXControl.ctor>

  <ActiveXControl.AutoServer>
    <summary>
      表示 ActiveX 控件的自动化服务接口的对象。
    </summary>
    <value>表示 ActiveX 控件的自动化服务接口的对象。</value>
    <remarks>
      <note type="tip">
        在 IDE 中创建 OLE 自动化服务器时，必须在应用程序选项对话框的 OLE 服务选项卡页面上的自动化编辑控件中指定自动化服务的类。
      </note>
    </remarks>
  </ActiveXControl.AutoServer>

  <ActiveXControl.Create>
    <summary>
      创建一个 ActiveX 控件。<br />
      Create() 由 ActiveX 容器自动调用。通常，不应从应用程序代码中调用它。
    </summary>
    <param name="hParent">父(容器)窗口的窗口句柄。</param>
    <remarks>
      Create() 方法在 ActiveXControl 对象实例化后调用。请注意，这两个方法都是由 ActiveX 容器应用程序调用的：它们不应直接从代码中调用。<br />
      在 Create() 中，您应该：<br />
      1. 实例化一个表示 ActiveX 控件用户界面的控件或窗口对象。此对象应分配给 OCXWindow。<br />
      2. 实例化一个表示 ActiveX 控件的自动化接口的对象，并将其分配给 AutoServer。<br />
      3. 实例化一个表示 ActiveX 控件的事件接口的对象，并将其分配给 Events—此步骤是可选的。<br />
      4. 执行其他初始化任务。<br />
      有关详细信息，请参阅在线帮助的“如何”部分中的在 X# 中创建 OLE 服务，以及可以从应用程序库的示例选项卡页面访问的示例应用程序。
    </remarks>
    <example> 
      这是可以从应用程序库的示例选项卡页面访问的日历 ActiveX 示例中的 Create() 方法： 
      <code language="X#">
        METHOD Create(hParent) CLASS CalOCX
        LOCAL oCal AS CalendarControl

        SUPER:Create(hParent)

        SELF:Events       := CalendarEvents{}

        oCal              := CalendarControl{hParent, 100, Point{0,0}, DIMension{100,100}, ,SELF}

        SELF:OCXWindow    := oCal
        SELF:AutoServer   := oCal

        oCal:CurrentDate  := curDate
        oCal:Show()

        RETURN oCal:Handle()
      </code>
    </example>
  </ActiveXControl.Create>

  <ActiveXControl.DesignMode>
    <summary>
      如果 ActiveX 控件处于设计模式，即在开发环境中使用，则返回逻辑值 TRUE 。
    </summary>
    <value>如果 ActiveX 控件处于设计模式，即在开发环境中使用，则返回逻辑值 TRUE 。</value>
  </ActiveXControl.DesignMode>

  <ActiveXControl.Destroy>
    <summary>
      提供一种方法来取消实例化 ActiveX 对象。
    </summary>
    <remarks>
      当不再需要 ActiveXControl 对象时，可以使用此方法。<br />
      ActiveXControl:Destroy() 取消实例化 ActiveXControl 对象，并允许您关闭和释放对象打开或创建的任何资源，而无需等待垃圾收集器。
    </remarks>
    <returns>
      NIL
    </returns>
  </ActiveXControl.Destroy>

  <ActiveXControl.Events>
    <summary>
      表示 ActiveX 控件的事件接口的对象。
    </summary>
    <value>表示 ActiveX 控件的事件接口的对象。</value>
    <remarks>
      <note type="tip">
        在 IDE 中创建 ActiveX 控件时，必须在应用程序选项对话框的 OLE 服务选项卡页面上的事件编辑控件中指定事件对象的类。
      </note>
      有关详细信息，请参阅在线帮助的“如何”部分中的在 X# 中创建 OLE 服务，以及可以从应用程序库的示例选项卡页面访问的示例应用程序。 
    </remarks>
  </ActiveXControl.Events>

  <ActiveXControl.OCXWindow>
    <summary>
      表示 ActiveX 控件的用户界面的对象。这可以是任何 X# 控件或窗口对象。<br />
      有关详细信息，请参阅在线帮助的“如何”部分中的在 X# 中创建 OLE 服务，以及可以从应用程序库的示例选项卡页面访问的示例应用程序。
    </summary>
    <value>
      表示 ActiveX 控件的用户界面的对象。这可以是任何 X# 控件或窗口对象。<br />
      有关详细信息，请参阅在线帮助的“如何”部分中的在 X# 中创建 OLE 服务器，以及可以从应用程序库的示例选项卡页面访问的示例应用程序。
    </value>
  </ActiveXControl.OCXWindow>

  <ActiveXControl.SetExtent>
    <summary>
      由容器调用，以调整 ActiveX 控件的大小。
    </summary>
    <param name="nX">请求的 ActiveXControl 宽度。</param>
    <param name="nY">请求的 ActiveXControl 高度。</param>
    <remarks>
      SetExtend() 是一个回调方法，每当需要调整 ActiveXControl 的大小时由容器调用。<br/>
      默认行为是调整用户界面对象的大小。您可以在派生的 ActiveX 类中重写此方法，以更改默认行为。<br />
      有关详细信息，请参阅在线帮助的“如何”部分中的在 X# 中创建 OLE 服务，以及可以从应用程序库的示例选项卡页面访问的示例应用程序。
    </remarks>
  </ActiveXControl.SetExtent>

  <ActiveXControl.ShowPropPages>
    <summary>
      每当 ActiveX 控件应显示其属性页对话框时，由 ActiveX 容器调用的回调方法。
    </summary>
    <remarks>
      ShowPropPages() 是一个回调方法，每当 ActiveX 控件应显示其属性页对话框时，由 ActiveX 容器调用。<br />
      默认实现显示一条消息框，说明属性页未实现。<br />
      在派生类中，应重写此回调方法以显示一个对话框，允许用户更改 ActiveX 控件的属性。<br />
      有关详细信息，请参阅在线帮助的“如何”部分中的在 X# 中创建 OLE 服务，以及可以从应用程序库的示例选项卡页面访问的示例应用程序。
    </remarks>
  </ActiveXControl.ShowPropPages>

  <ActiveXControl.StreamIn>
    <summary>
      用于加载持久数据的回调方法。
    </summary>
    <param name="oStream">表示输入流的 Stream 对象。</param>
    <remarks>
      有关详细信息，请参阅在线帮助的“如何”部分中的在 X# 中创建 OLE 服务，以及可以从应用程序库的示例选项卡页面访问的示例应用程序。
    </remarks>
    <example> 
      这是可以从应用程序库的示例选项卡页面访问的日历 ActiveX 示例中的 StreamIn() 方法： 
      <code language="X#">
        METHOD StreamIn(oStream) CLASS CalOCX
            LOCAL u AS USUAL
            u := oStream:Read()
            IF IsDate(u)
              curDate := u
            ENDIF
      </code>
    </example>
  </ActiveXControl.StreamIn>

  <ActiveXControl.StreamOut>
    <summary>
      用于保存持久数据的回调方法。
    </summary>
    <param name="oStream">表示输入流的 Stream 对象。</param>
    <remarks>
      有关详细信息，请参阅在线帮助的“如何”部分中的在 X# 中创建 OLE 服务，以及可以从应用程序库的示例选项卡页面访问的示例应用程序。
    </remarks>
    <example> 
      这是可以从应用程序库的示例选项卡页面访问的日历 ActiveX 示例中的 StreamOut() 方法： 
      <code language="X#">
        METHOD StreamOut(oStream) CLASS CalOCX
            oStream:Write(oOCXWindow:CurrentDate)
            RETURN
      </code>
    </example>
  </ActiveXControl.StreamOut>

  <ActiveXEvents>
    <summary>
      用于实现 ActiveX 服务应用程序事件接口的类的基类。
    </summary>
    <remarks>
      ActiveXEvents 用作实现 ActiveX 服务应用程序事件接口的类的基类。<br />
      实现应用程序事件接口的类应从 ActiveXEvents 派生，并且必须在应用程序选项对话框的 OLE 服务选项卡页面中指定应用程序选项时指定。
      事件类的方法包含在服务的类型库中，同时，服务可以通过调用 FIREEVENT 宏来触发事件。
    </remarks>
  </ActiveXEvents>

  <ActiveXEvents.FireEvent>
    <summary>
      FireEvent() 不应直接调用。请改用 FIREEVENT UDC。
    </summary>
    <param name="iEventID">事件 ID。</param>
    <param name="nPCount">参数数量。</param>
    <param name="pStack">堆栈指针。</param>
    <remarks>
      FireEvent() 方法不应直接调用。相反，应使用 FIREEVENT 宏(包含在 OCX.UDC 中)使用正确的参数调用此方法。
      通常，事件类的方法除了 FIREEVENT 调用外是空的。这样，这些方法既用于设置服务的类型库，也用于在服务代码中触发事件。
    </remarks>
  </ActiveXEvents.FireEvent>

  <AdsSQLServer>
    <summary>将字符串作为 SQL 查询传递给 Advantage RDD 的特殊 Dbserver 类。</summary>
  </AdsSQLServer>

  <AdsSQLServer.ctor>
    <inheritdoc />
    <summary>构造一个 AdsSQLServer 对象。</summary>
    <param name="oFile">执行的 SQL 查询。</param>
  </AdsSQLServer.ctor>

  <AnimationControl>
    <summary>
      创建一个动画控件。
    </summary>
    <remarks>
      动画控件显示一个无声的音频视频交错(AVI)剪辑。<br />
      无声 AVI 剪辑是一系列像电影一样的位图帧。虽然 AVI 剪辑可以有声音，但动画控件只能使用无声 AVI 剪辑。
    </remarks>
  </AnimationControl>

  <AnimationControl.ctor>
    <summary>
      构造一个动画控件。
    </summary>
    <param name="oOwner">拥有动画控件的窗口。</param>
    <param name="xID">动画控件的唯一 ID(介于 1 和 8000 之间)。</param>
    <param name="nResourceID">动画控件的资源 ID。</param>
    <param name="oPoint">动画控件在画布坐标中的原点。</param>
    <param name="oDimension">动画控件在画布坐标中的尺寸。</param>
    <param name="oFileSpec">描述关联 AVI 文件的 FileSpec 对象。</param>
    <param name="cFileName">描述关联 AVI 文件的文件名。</param>
    <param name="kStyle">动画控件的样式。</param>
    <param name="hInst">创建控件时传递给窗口的实例句柄。</param>
  </AnimationControl.ctor>

  <AnimationControl.Create>
    <summary>
      为 X# 动画控件对象创建底层窗口控件。
    </summary>
    <returns>
      如果成功，则返回控件的窗口句柄。如果控件创建失败，则返回空句柄 (NULL_PTR)。
    </returns>
    <remarks>
      对于不是从资源加载（即使用窗口编辑器设计）而是在运行时创建的控件，Create() 方法将创建底层窗口控件。
      通常情况下，无需直接调用 Create()--只要需要窗口句柄，CA-X# 就会在内部创建对象。
    </remarks>
    <example>
      <code language="X#">
        METHOD CreateAnimationControl() CLASS MyDataWindow
            LOCAL oAC AS AnimationControl
            // Init 创建 X# 动画控件对象
            oAC := AnimationControl{SELF, 100, Point{10,10}, Dimension{100,20}}
            // 调用 Create 强制创建 Windows 控件
            oAC:Create()
      </code>
    </example>
  </AnimationControl.Create>

  <AnimationControl.FileSpec>
    <summary>
      描述关联 AVI 文件的 FileSpec 对象。
    </summary>
    <value>描述关联 AVI 文件的 FileSpec 对象。</value>
  </AnimationControl.FileSpec>

  <AnimationControl.Open>
    <summary>
      打开 AVI 文件并在动画控件中显示其第一帧。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </AnimationControl.Open>

  <AnimationControl.OpenResource>
    <summary>
      打开 AVI 资源并在动画控件中显示其第一帧。
    </summary>
    <param name="xID">动画资源的唯一 ID(介于 1 和 8000 之间)，或标识 AVI 资源的 ResourceID 对象。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </AnimationControl.OpenResource>

  <AnimationControl.Play>
    <summary>
      在动画控件中播放 AVI 文件。
    </summary>
    <param name="nFrom">初始帧号。如果省略，则从第一帧开始播放。</param>
    <param name="nTo">最后一帧号。如果省略，则播放到最后一帧。</param>
    <param name="nRepeatCount">AVI 文件的播放次数。如果省略，则无限重复播放。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </AnimationControl.Play>

  <AnimationControl.Seek>
    <summary>
      指示动画控件显示 AVI 文件中的特定帧。
    </summary>
    <param name="nFrame">要显示的帧号。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </AnimationControl.Seek>

  <AnimationControl.Stop>
    <summary>
      指示动画控件停止显示 AVI 文件。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </AnimationControl.Stop>

  <App>
    <summary>
      创建一个表示整个应用程序的实体。<br />
      请注意，您必须在代码中创建 App 的子类并向该类添加 Start() 方法。您不能像在 VO 中那样在 GUI 类中向 App() 类添加 Start() 方法。
    </summary>
    <remarks>
      App 类启动、运行和停止应用程序。然而，几乎所有应用程序中的代码都在事件处理程序中执行。一旦调用 App:Exec() 方法，系统就会开始向您发送事件。<br />
      虽然术语应用程序在窗口和非窗口世界中是一致的，但窗口应用程序的事件驱动性质旨在处理用户驱动的事件(例如鼠标点击或窗口调整大小)。
      因此，窗口应用程序的功能被分配到事件调度循环中。<br />
      在此类中，Start() 方法类似于 CA-Clipper 中的入口点 START() 函数。它是构建应用程序主要元素的地方。
      在 App:Start() 中声明的对象应该是具有“应用程序范围”范围的对象。<br />
      在 App:Start() 方法中，您必须调用 App:Exec()。这样做会调用底层窗口系统的消息处理循环，并通过激活系统调度程序开始系统事件处理机制。<br />
      App:Exec() 方法可以被认为是一个分层服务，具有典型的“获取-翻译-调度-消息”机制，由您的底层窗口系统驱动，以及“过滤-翻译-调度-事件”机制，
      通过系统框架由系统调度程序指挥。<br />
      App:Quit() 方法提供了一种方法，可以通过调用 App:Quit() 方法来终止应用程序的 Exec() 循环，从而终止应用程序。
      它类似于 CA-Clipper 中的 QUIT() 函数。
    </remarks>
    <example> 
      以下示例演示了一个完整的应用程序，使用 App 类的各种方法： 
      <code language="X#">
        DEFINE IDM_MYMENU := "MyMenu"
        DEFINE IDM_MYMENU_CLOCK_ID := 1000
        DEFINE IDM_MYMENU_GETHANDLE_ID := 1001
        DEFINE IDM_MYMENU_QUIT_ID := 1002
        FUNCTION Start as VOID
            LOCAL oApp as XApp
            oApp := XApp{}
            oApp:Start()
            RETURN

        CLASS XApp INHERIT APP
            METHOD Start()
                LOCAL oWin AS Window
                oWin := MyTopAppWin{SELF}
                oWin:Show()

                SELF:Exec()

                RETURN NIL
        END CLASS

        CLASS MyTopAppWin INHERIT TopAppWindow
            CONSTRUCTOR(oOwnerApp)
                LOCAL lRetVal AS LONG

                SUPER(oOwnerApp)

                SELF:Menu := MyMenu{SELF}

                lRetVal := oOwnerApp:Run("Clock")

                SELF:Caption := "My Top App Window Application"
                SELF:WarningMessage("The return value of running CLOCK is :" +AsString(lRetVal))
                RETURN

            METHOD GetClock()
                SELF:Owner:Run("Clock")
                RETURN NIL

            METHOD GetHandle()
                SELF:WarningMessage("The handle of this app is :"+AsString(SELF:Handle()))
                RETURN NIL

            METHOD GoQuit()
                SELF:Owner:Quit()
                RETURN NIL
        END CLASS

        CLASS MyMenu INHERIT Menu
            CONSTRUCTOR(oOwner)
                SUPER(ResourceID{IDM_MYMENU})

                SELF:RegisterItem(IDM_MYMENU_CLOCK_ID, HyperLabel{#GetClock,,,})
                SELF:RegisterItem(IDM_MYMENU_GETHANDLE_ID, HyperLabel{#GetHandle,,,})
                SELF:RegisterItem(IDM_MYMENU_QUIT_ID, HyperLabel{#GoQuit,,,})
        END CLASS

        RESOURCE IDM_MYMENU MENU
            BEGIN
                POPUP "&amp;Menu1"

                BEGIN
                    MENUITEM "&amp;Clock", IDM_MYMENU_CLOCK_ID
                    MENUITEM "&amp;Get App Handle", IDM_MYMENU_GETHANDLE_ID
                    MENUITEM SEPARATOR
                    MENUITEM "&amp;QUIT", IDM_MYMENU_QUIT_ID
                END
            END
      </code>
    </example>
  </App>

  <App.ctor>
    <summary>
      构造一个应用程序。
    </summary>
    <remarks>
      <font color="red">重要！X# 实例化此对象。</font>
    </remarks>
    <param name="oOwner">拥有该应用程序的窗口。</param>
  </App.ctor>

  <App.AfterDispatch>
    <summary>
      与 App:BeforeDispatch() 一起使用的低级处理程序，用于拦截发送到应用程序消息队列的任何消息。
    </summary>
    <param name="hWnd">消息所针对的窗口句柄。</param>
    <param name="uMsg">消息常量。</param>
    <param name="wParam">DWORD 参数。</param>
    <param name="lParam">LONG 参数。</param>
    <remarks> 
      BeforeDispatch() 和 AfterDispatch() 方法是低级处理程序，用于拦截发送到应用程序消息队列的任何消息。
      BeforeDispatch() 在消息分派到相应窗口的 Dispatch() 方法之前调用，而 AfterDispatch() 在之后调用。 <br />
      <note type="tip">
        这些方法不是作为 GUI 类的一部分实现的。相反，如果需要一般的、应用程序范围的消息拦截和处理，程序员应实现这些方法。
        如果存在，BeforeDispatch() 和 AfterDispatch() 会在 App:Exec() 内部调用。
      </note>
    </remarks>
    <example>
      请参阅 App:BeforeDispatch() 示例。
    </example>
  </App.AfterDispatch>

  <App.BeforeDispatch>
    <summary>
      与 App:AfterDispatch() 一起使用的低级处理程序，用于拦截发送到应用程序消息队列的任何消息。
    </summary>
    <param name="hWnd">消息所针对的窗口句柄。</param>
    <param name="uMsg">消息常量。</param>
    <param name="wParam">DWORD 参数。</param>
    <param name="lParam">LONG 参数。</param>
    <returns>
      如果消息应进一步处理，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks> 
      BeforeDispatch() 和 AfterDispatch() 方法是低级处理程序，用于拦截发送到应用程序消息队列的任何消息。
      BeforeDispatch() 在消息分派到相应窗口的 Dispatch() 方法之前调用，而 AfterDispatch() 在之后调用。 <br />
      <note type="tip">
        这些方法不是作为 GUI 类的一部分实现的。相反，如果需要一般的、应用程序范围的消息拦截和处理，程序员应实现这些方法。
        如果存在，BeforeDispatch() 和 AfterDispatch() 会在 App:Exec() 内部调用。
      </note>
    </remarks>
    <example> 
      此示例在整个应用程序范围内禁用单击左键： 
      <code language="X#">
        METHOD BeforeDispatch(hWnd, uMsg, wParam, lParam) CLASS App
            IF uMsg == WM_LBUTTONDOWN
                RETURN FALSE
            ENDIF

            RETURN TRUE
      </code>
    </example>
  </App.BeforeDispatch>

  <App.Exec>
    <summary>
      启动应用程序的事件处理循环。
    </summary>
    <param name="uObject">
      要处理消息的对象(通常是对话窗口)
    </param>
    <param name="kExecType"> 
      要启动的事件处理循环的类型，指定为以下常量之一 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>EXECNORMAL</term>
          <description>
            告诉系统继续执行应用程序，直到用户关闭它(通过选择关闭菜单命令或使用标准的 Windows 快捷键 Alt+F4)或
            应用程序通过故意调用 App:Quit() 方法决定关闭。当应用程序终止时，控制线程从 App:Exec() 退出到代码中的下一条语句。这是默认值。
          </description>
        </item>
        <item>
          <term>EXECWHILEEVENT</term>
          <description>
            告诉系统仅在仍有事件排队时继续执行应用程序。一旦系统分派了队列中的最后一个事件，控制线程将从 App:Exec() 退出。
            这使您有机会进行一些处理，然后通过再次调用 App:Exec() 启动另一个事件循环。
            当应用程序空闲时，您应该使用此机制进行一些后台处理。
          </description>
        </item>
      </list>
    </param>
    <param name="oObject">** 缺少参数文档 **</param>
    <returns>
      值为 0 表示正常终止(无错误)。非零值表示异常终止。
    </returns>
    <remarks> 
      通常，应用程序的事件处理循环会继续循环，直到没有更多的 EventContext 对象。它也可以在调用 App:Quit() 时终止。 
      <note type="tip">
        确保在调用 App:Exec() 之前至少显示一个窗口对象。
      </note>
    </remarks>
  </App.Exec>

  <App.GetAccel>
    <summary>此方法返回当前活动加速键的句柄。</summary>
    <returns>当前活动加速键的句柄。</returns>
    <remarks>此句柄在窗口类的激活事件中设置。</remarks>
  </App.GetAccel>

  <App.GetAccelWindow>
    <summary>此方法获取必须翻译加速键的窗口句柄。</summary>
    <returns>必须翻译加速键的窗口。</returns>
    <remarks>此句柄在窗口类的激活事件中设置。</remarks>
  </App.GetAccelWindow>

  <App.GetDialogWindow>
    <summary>该方法获取必须处理对话框按键的活动对话框窗口句柄</summary>
    <returns>活动对话框窗口的句柄。请注意，DataWindow 也是一个对话框窗口。</returns>
    <remarks>此句柄在 DialogWindow 类的 Activate() 方法和事件处理程序中设置。</remarks>
  </App.GetDialogWindow>

  <App.GetMdiClientWindow>
    <summary>此方法获取活动 ShellWindow 上 MDI 客户端窗口的句柄。</summary>
    <returns>MDI 客户端窗口的句柄。</returns>
    <remarks>此句柄在 ShellWindow 的构造函数中设置。</remarks>
  </App.GetMdiClientWindow>

  <App.Handle>
    <summary>
      返回应用程序的句柄。
    </summary>
    <param name="nHandleType"> 所需句柄的类型。0 是唯一支持的选项，如果省略 <paramref name="nHandle" />，则为默认值。</param>
    <returns>
      描述底层系统对象的句柄。
    </returns>
    <remarks>
      此方法提供 Windows GDI 对象的句柄，然后可以由 Windows API GDI 调用使用。
    </remarks>
  </App.Handle>

  <App.Quit>
    <summary>
      通过指示应用程序关闭自身来终止应用程序。
    </summary>
    <remarks>
      通常在选择退出菜单命令时调用此方法。
    </remarks>
  </App.Quit>

  <App.Run>
    <summary>
      调用并执行指定的命令。
    </summary>
    <param name="sCommand">要执行的命令(包括任何所需的参数)。</param>
    <returns>
      表示成功完成或错误的长整数值。
      数字 0-32 对应于 Windows 中的特定错误类型(例如，0 表示“内存不足”，2 表示“找不到文件”等)；任何其他数字表示成功完成。
    </returns>
  </App.Run>

  <App.SetAccel>
    <summary>此方法设置当前活动加速键(属于活动菜单)的句柄。</summary>
    <param name="hNewAccel">要激活的加速键的句柄</param>
    <returns>NIL</returns>
    <remarks>此句柄在窗口类的激活事件中设置。</remarks>
  </App.SetAccel>

  <App.SetAccelWindow>
    <summary>此方法设置必须翻译加速键的窗口。</summary>
    <param name="hNewAccelWnd">必须翻译加速键(以 &amp; 符号开头的标签)的窗口句柄。</param>
    <returns>NIL</returns>
    <remarks>此句柄在窗口类的激活事件中设置。</remarks>
  </App.SetAccelWindow>

  <App.SetDialogWindow>
    <summary>此方法设置必须处理对话框键的活动对话框窗口的句柄</summary>
    <param name="hNewDialogWnd">活动对话框窗口的句柄。请注意，DataWindow 也是一个对话框窗口。</param>
    <param name="oSurface">活动窗口的对象。</param>
    <returns>NIL</returns>
    <remarks>此句柄在 DialogWindow 类的 Activate() 方法和事件处理程序中设置。</remarks>
  </App.SetDialogWindow>

  <App.SetMdiClientWindow>
    <summary>此方法设置活动 ShellWindow 上 MDI 客户端窗口的句柄。</summary>
    <param name="hNewMdiClientWnd">MDI 客户端窗口的句柄。</param>
    <returns>NIL</returns>
    <remarks>此句柄在 ShellWindow 的构造函数中设置。</remarks>
  </App.SetMdiClientWindow>

  <App.Start>
    <summary>
      提供应用程序的入口点。
    </summary>
    <remarks>
      在 App:Start() 方法中，构造应用程序的主要元素。<br />
      在 App:Start() 中声明的对象应具有“应用程序范围”的作用域。<br />
      在 App:Start() 方法中，您必须调用 App:Exec()，调用底层窗口系统的消息处理循环，并通过激活系统调度程序开始系统事件处理机制。
    </remarks>
  </App.Start>

  <AppCommandEvent>
    <summary>
      提供有关 AppCommand 事件的信息，该事件由扩展键盘或鼠标上的额外键启动。
    </summary>
    <remarks>
      AppCommandEvent 类由 X# 创建，以响应激活扩展键盘或鼠标上的键。
    </remarks>
  </AppCommandEvent>

  <AppCommandEvent.ctor>
    <inheritdoc />
  </AppCommandEvent.ctor>

  <AppCommandEvent.Command>
    <summary>
      与此事件关联的命令。
    </summary>
    <value>与此事件关联的命令。</value>
    <remarks>
      <a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/wm-appcommand">
        请参阅 Ms 文档网站以获取可能命令的列表
      </a>
    </remarks>
  </AppCommandEvent.Command>

  <AppCommandEvent.IsControl>
    <summary>
      如果 Control 键按下则返回 TRUE；否则返回 FALSE。
    </summary>
    <value>如果 Control 键按下则返回 TRUE；否则返回 FALSE。</value>
  </AppCommandEvent.IsControl>

  <AppCommandEvent.IsDeviceKey>
    <summary>
      如果发出命令的设备是键盘则返回 TRUE；否则返回 FALSE。
    </summary>
    <value>如果发出命令的设备是键盘则返回 TRUE；否则返回 FALSE。</value>
  </AppCommandEvent.IsDeviceKey>

  <AppCommandEvent.IsDeviceMouse>
    <summary>
      如果发出命令的设备是鼠标则返回 TRUE；否则返回 FALSE。
    </summary>
    <value>如果发出命令的设备是鼠标则返回 TRUE；否则返回 FALSE。</value>
  </AppCommandEvent.IsDeviceMouse>

  <AppCommandEvent.IsDeviceOEM>
    <summary>
      如果发出命令的设备是 OEM 设备则返回 TRUE；否则返回 FALSE。
    </summary>
    <value>如果发出命令的设备是 OEM 设备则返回 TRUE；否则返回 FALSE。</value>
  </AppCommandEvent.IsDeviceOEM>

  <AppCommandEvent.IsLeftButton>
    <summary>
      如果左键按下则返回 TRUE；否则返回 FALSE。
    </summary>
    <value>如果左键按下则返回 TRUE；否则返回 FALSE。</value>
  </AppCommandEvent.IsLeftButton>

  <AppCommandEvent.IsMiddleButton>
    <summary>
      如果中键按下则返回 TRUE；否则返回 FALSE。
    </summary>
    <value>如果中键按下则返回 TRUE；否则返回 FALSE。</value>
  </AppCommandEvent.IsMiddleButton>

  <AppCommandEvent.IsRightButton>
    <summary>
      如果右键按下则返回 TRUE；否则返回 FALSE。
    </summary>
    <value>如果右键按下则返回 TRUE；否则返回 FALSE。</value>
  </AppCommandEvent.IsRightButton>

  <AppCommandEvent.IsShift>
    <summary>
      如果 Shift 键按下则返回 TRUE；否则返回 FALSE。
    </summary>
    <value>如果 Shift 键按下则返回 TRUE；否则返回 FALSE。</value>
  </AppCommandEvent.IsShift>

  <AppCommandEvent.IsXButton1>
    <summary>
      如果第一个 X 键按下则返回 TRUE；否则返回 FALSE。
    </summary>
    <value>如果第一个 X 键按下则返回 TRUE；否则返回 FALSE。</value>
  </AppCommandEvent.IsXButton1>

  <AppCommandEvent.IsXButton2>
    <summary>
      如果第二个 X 键按下则返回 TRUE；否则返回 FALSE。
    </summary>
    <value>如果第二个 X 键按下则返回 TRUE；否则返回 FALSE。</value>
  </AppCommandEvent.IsXButton2>

  <AppCommandEvent.oTarget>
    <summary>
      返回命令的目标。<br />
      如果是键事件，目标是聚焦的控件或窗口。如果是鼠标事件，目标是鼠标指针下的控件或窗口。
    </summary>
    <value>
      命令的目标。<br />
      如果是键事件，目标是聚焦的控件或窗口。如果是鼠标事件，目标是鼠标指针下的控件或窗口。
    </value>
  </AppCommandEvent.oTarget>

  <AppWindow>
    <summary>
      提供所有 X# 应用程序窗口的基类。
    </summary>
    <remarks>
      使用 AppWindow 类的方法自定义顶级、外壳和子应用程序窗口的外观(例如，边框样式的显示、系统菜单或图标)。
    </remarks>
  </AppWindow>

  <AppWindow.ctor>
    <summary>
      构造一个应用程序窗口。
    </summary>
    <param name="oOwner">拥有该应用程序窗口的窗口。</param>
  </AppWindow.ctor>

  <AppWindow.Default>
    <inheritdoc />
  </AppWindow.Default>

  <AppWindow.Destroy>
    <summary>
      提供一种方法来释放为 AppWindow 对象及其派生对象分配的内存资源。
    </summary>
    <remarks>
      此方法立即释放在应用程序中显式创建的 AppWindow 对象的资源。<br />
      AppWindow:Destroy() 还会处理分配给派生类的资源，并按必要的顺序释放它们(例如，子窗口在父窗口之前销毁；对话窗口和 MDI 外壳窗口也会被处理)。
    </remarks>
  </AppWindow.Destroy>

  <AppWindow.Dispatch>
    <inheritdoc />
  </AppWindow.Dispatch>

  <AppWindow.EnableBorder>
    <summary>
      设置应用程序窗口的边框样式。
    </summary>
    <param name="kBorderStyle">应用程序窗口边框的显示样式，指定为以下常量之一</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>WINDOWNOBORDER</term>
          <description>无边框。</description>
        </item>
        <item>
          <term>WINDOWNONSIZINGBORDER</term>
          <description>带标题的固定边框。</description>
        </item>
        <item>
          <term>WINDOWSIZINGBORDER</term>
          <description>带标题可调整大小的边框。这是<b>默认</b>值。 </description>
        </item>
      </list>
    </remarks>
  </AppWindow.EnableBorder>

  <AppWindow.EnableHorizontalScroll>
    <summary>
      启用/禁用应用程序窗口中的水平滚动条。
    </summary>
    <param name="lEnable">TRUE 启用水平滚动条；FALSE 禁用它。默认值为 TRUE。</param>
    <returns>
      如果启用了滚动条，则返回 WindowHorizontalScrollBar 对象；如果禁用，则返回 NULL_OBJECT。
    </returns>
    <remarks>
      <note type="tip">
        这是创建窗口水平滚动条的唯一有效方法。
      </note> 
      WindowHorizontalScrollBar 对象是一种特殊类型的滚动条，显示在窗口画布区域的底部。它根据拥有它的窗口的大小自动调整大小。 
      创建窗口水平滚动条后，应显示它并设置其范围。 
    </remarks>
    <example> 
      此示例启用 WindowHorizontalScrollBar 对象并将其范围设置为 1-80，块大小为 8： 
      <code language="X#">
        METHOD Init() CLASS MyAppWindow
            owhs := SELF:EnableHorizontalScroll(TRUE)
            owhs:Show()
            owhs:Range      := Range{1,80}
            owhs:BlockSize  := 8
      </code>
    </example>
  </AppWindow.EnableHorizontalScroll>

  <AppWindow.EnableMaxBox>
    <summary>
      启用/禁用应用程序窗口中的最大化框。
    </summary>
    <param name="lEnable">TRUE 启用最大化框；FALSE 禁用它。默认值为 TRUE。</param>
  </AppWindow.EnableMaxBox>

  <AppWindow.EnableMinBox>
    <summary>
      启用/禁用应用程序窗口中的最小化框。
    </summary>
    <param name="lEnable">TRUE 启用最小化框；FALSE 禁用它。默认值为 TRUE。</param>
  </AppWindow.EnableMinBox>

  <AppWindow.EnableOleDropTarget>
    <summary>
      将窗口注册为 OLE 拖放目标。
    </summary>
    <param name="lEnable">一个逻辑值，指定是否启用 (TRUE) 或禁用 (FALSE) 窗口作为拖放目标。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      使用 AppWindow:EnableOLEDropTarget() 注册为 OLE 拖放目标的窗口可以处理 OLE 拖放事件，并在响应此类事件时创建新的 OLE 对象。
      在相关的处理程序中，OLEDragEvent 对象作为参数传递，可以通过调用 OLEObject:CreateFromOLEDragEvent() 来创建新的 OLE 对象。
    </remarks>
    <example> 
      以下代码启用数据窗口作为拖放目标，并在其 OLEDrop 处理程序中创建一个新的 OLE 对象。它还检查 OLE 对象的名称以仅允许 WordPad 文档： 
      <code language="X#">
        METHOD EnableOLEDropTarget CLASS DropTargetDataWindow
            SELF:EnableOLEDropTarget(TRUE)

        METHOD OLEDrop(oOLEDragEvent) CLASS MyChild
            LOCAL oOLE AS OLEObject
            LOCAL lRet AS LOGIC

            IF oOLEDragEvent:ObjectName == "WordPad Document"
                oOLE := OLEObject{SELF}

                oOLE:AllowInPlace := TRUE
                oOLE:AllowResize := TRUE

                IF oOLE:CreateFromOLEDragEvent(oOLEDragEvent)
                    oOLE:Origin := oOLEDragEvent:Position
                    oOLE:Show()
                    oOLE:SetFocus()
                ENDIF
            ENDIF
      </code>
    </example>
  </AppWindow.EnableOleDropTarget>

  <AppWindow.EnableStatusBar>
    <summary>
      启用/禁用应用程序窗口中的状态栏。
    </summary>
    <param name="lEnable">TRUE 启用状态栏；FALSE 禁用它。默认值为 TRUE。</param>
    <returns>
      状态栏对象。
    </returns>
    <remarks>
      发送到应用程序的任何状态信息都会显示在其状态栏上。
    </remarks>
  </AppWindow.EnableStatusBar>

  <AppWindow.EnableSystemMenu>
    <summary>
      启用/禁用应用程序窗口中的系统菜单。
    </summary>
    <param name="lEnable">TRUE 启用系统菜单；FALSE 禁用它。默认值为 TRUE。</param>
    <returns>
      如果启用了系统菜单，则返回系统菜单；如果禁用，则返回 NIL。
    </returns>
    <example> 
      以下示例在应用程序窗口中启用系统菜单： 
      <code language="X#">
        oSysMenu := oAppWindow:EnableSystemMenu(TRUE)
      </code>
    </example>
  </AppWindow.EnableSystemMenu>

  <AppWindow.EnableToolBar>
    <summary>
      启用/禁用应用程序窗口中的工具栏。
    </summary>
    <param name="lEnable">TRUE 启用工具栏；FALSE 禁用它。默认值为 TRUE。</param>
    <returns>
      工具栏对象。
    </returns>
  </AppWindow.EnableToolBar>

  <AppWindow.EnableVerticalScroll>
    <summary>
      启用/禁用应用程序窗口中的垂直滚动条。
    </summary>
    <param name="lEnable">TRUE 启用 WindowVerticalScrollBar 对象；FALSE 禁用它。默认值为 TRUE。</param>
    <returns>
      如果启用了滚动条，则返回 WindowVerticalScrollBar 对象；如果禁用，则返回 NULL_OBJECT。
    </returns>
    <remarks>
      <note type="tip">
        这是创建窗口垂直滚动条的唯一有效方法。
      </note> 
      WindowVerticalScrollBar 对象是一种特殊类型的滚动条，沿窗口画布区域的右侧对齐。它根据拥有它的窗口的大小自动调整大小。 <br />
      创建 WindowVerticalScrollBar 对象后，应显示它并设置其范围。 
    </remarks>
    <example> 
      此示例启用 WindowVerticalScrollBar 对象并将其范围设置为 1-200，块大小为 25： 
      <code language="X#">
        METHOD Init() CLASS TopAppWindow
            pwvs := SELF:EnableVerticalScroll()
            pwvs:Show()
            pwvs:Range := Range{1,200}
            pwvs:BlockSize := 25
      </code>
    </example>
  </AppWindow.EnableVerticalScroll>

  <AppWindow.EndWindow>
    <summary>
      从视图中移除此应用程序窗口(将控制权传递回创建应用程序窗口的例程)。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <param name="lSendMsg">
      一个逻辑值，指示类是否应使用 SendMessage() 函数关闭窗口(立即生效)或 PostMessage() 函数(将消息添加到消息事件队列中)。
    </param>
  </AppWindow.EndWindow>

  <AppWindow.ErrorMessage>
    <summary>
      在错误框中显示消息。
    </summary>
    <param name="oHyperLabel">包含描述(HyperLabel:Description)的超链接标签对象，将显示在错误框中。</param>
    <param name="uText">将在错误框中显示的描述。</param>
  </AppWindow.ErrorMessage>

  <AppWindow.OLEDragEnter>
    <summary>
      在拖放操作期间，每当鼠标进入窗口的客户区时调用。
    </summary>
    <param name="oOleDragEvent">指定的 OLEDragEvent 对象。</param>
    <remarks> 
      OLE 运行时引擎在 AppWindow 对象注册为 OLE 拖放目标后调用以下事件处理程序：OLEDragEnter()、OLEDragOver()、OLEDragLeave() 和 OLEDrop()。<br />
      通过检查传递的 OLEDragEvent 对象(例如，特定服务器)，您可以通过返回 TRUE 或 FALSE 来允许或禁止拖放操作。<br />
      这也会影响拖放光标的外观。<br />
      默认情况下，OLEDragEnter() 返回 TRUE。 
      <note type="tip">
        在派生类中，您可以实现自己的 OLEDragEnter 处理程序以自定义默认行为。
      </note>
      <note type="tip">
        此方法仅在将 OLE 库包含在应用程序的搜索路径中时可用。
      </note>
    </remarks>
  </AppWindow.OLEDragEnter>

  <AppWindow.OLEDragLeave>
    <summary>
      在拖放操作期间，每当鼠标离开窗口的客户区时调用。
    </summary>
    <param name="oOleDragEvent">指定的 OLEDragEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      OLE 运行时引擎在 AppWindow 对象注册为 OLE 拖放目标后调用以下事件处理程序：OLEDragEnter()、OLEDragOver()、OLEDragLeave() 和 OLEDrop()。<br />
      通过检查传递的 OLEDragEvent 对象(例如，特定服务)，您可以通过返回 TRUE 或 FALSE 来允许或禁止拖放操作。<br />
      这也会影响拖放光标的外观。<br />
      默认情况下，OLEDragLeave() 返回 TRUE。 
      <note type="tip">
        在派生类中，您可以实现自己的 OLEDragLeave 处理程序以自定义默认行为。
      </note>
      <note type="tip">
        此方法仅在将 OLE 库包含在应用程序的搜索路径中时可用。
      </note>
    </remarks>
  </AppWindow.OLEDragLeave>

  <AppWindow.OLEDragOver>
    <summary>
      在拖放操作期间，每当鼠标在窗口的客户区内移动时调用。
    </summary>
    <param name="oOleDragEvent">指定的 OLEDragEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      OLE 运行时引擎在 AppWindow 对象注册为 OLE 拖放目标后调用以下事件处理程序：OLEDragEnter()、OLEDragOver()、OLEDragLeave() 和 OLEDrop()。<br />
      通过检查传递的 OLEDragEvent 对象(例如，特定服务)，您可以通过返回 TRUE 或 FALSE 来允许或禁止拖放操作。<br />
      这也会影响拖放光标的外观。<br />
      默认情况下，OLEDragOver() 返回 TRUE。 
      <note type="tip">
        在派生类中，您可以实现自己的 OLEDragOver 处理程序以自定义默认行为。
      </note>
      <note type="tip">
        此方法仅在将 OLE 库包含在应用程序的搜索路径中时可用。
      </note>
    </remarks>
  </AppWindow.OLEDragOver>

  <AppWindow.OLEDrop>
    <summary>
      在拖放操作期间，每当鼠标在窗口的客户区内释放时调用。
    </summary>
    <param name="oOleDragEvent">指定的 OLEDragEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      OLE 运行时引擎在 AppWindow 对象注册为 OLE 拖放目标后调用以下事件处理程序：OLEDragEnter()、OLEDragOver()、OLEDragLeave() 和 OLEDrop()。<br />
      通过检查传递的 OLEDragEvent 对象(例如，特定服务)，您可以通过返回 TRUE 或 FALSE 来允许或禁止拖放操作。<br />
      这也会影响拖放光标的外观。 <br />
      默认情况下，OLEDrop() 返回 TRUE。<br />
      对 OLEDrop() 事件的典型响应是使用 CreateFromOLEDragEvent() 方法创建一个新的 OLE 对象。 
      <note type="tip">
        在派生类中，您可以实现自己的 OLEDrop 处理程序以自定义默认行为。
      </note>
      <note type="tip">
        此方法仅在将 OLE 库包含在应用程序的搜索路径中时可用。
      </note>
    </remarks>
    <example> 
      以下示例来自 ...\SAMPLES\OLE\CONT 中的 OLE 容器应用程序： 
      <code language="X#">
        METHOD OleDrop(oOleDragEvent) CLASS Container
            LOCAL oOle AS OleObject
            LOCAL p AS point
            LOCAL lRet := FALSE AS LOGIC
            oOle := DraggableOLEObject{SELF}

            oOle:AllowInPlace     := TRUE
            oOle:AllowResize      := TRUE
            oOle:AutoSizeOnCreate := TRUE

            IF (oOle:CreateFromOleDragEvent(oOleDragEvent))
                p := oOleDragEvent:Position
                SELF:SetupOLEObject(oOle, p)
                lRet := TRUE
            ENDIF

            RETURN lRet
      </code>
    </example>
  </AppWindow.OLEDrop>

  <AppWindow.OLEInPlaceActivate>
    <summary>
      每当子 OLE 对象即将“就地”激活时调用。
    </summary>
    <example> 
      以下示例来自 ...\SAMPLES\OLE\CONT 中的 OLE 容器应用程序： 
      <code language="X#">
        METHOD OLEInPlaceActivate() CLASS Container
            SELF:Owner:ToolBar:Hide()
            //self:Owner:StatusBar:Hide()
            RETURN SUPER:OLEInPlaceActivate()
      </code>
    </example>
  </AppWindow.OLEInPlaceActivate>

  <AppWindow.OLEInPlaceDeactivate>
    <summary>
      每当子 OLE 对象即将“就地”停用时调用。
    </summary>
    <example> 
      以下示例来自 ...\SAMPLES\OLE\CONT 中的 OLE 容器应用程序： 
      <code language="X#">
        METHOD OLEInPlaceDeactivate() CLASS Container
            SELF:Owner:ToolBar:Show()
            //self:Owner:StatusBar:Show()
            RETURN SUPER:OLEInPlaceDeactivate()
      </code>
    </example>
  </AppWindow.OLEInPlaceDeactivate>

  <AppWindow.QuitOnClose>
    <summary>
      一个逻辑值。如果设置为 TRUE，则在关闭此(主)窗口时退出应用程序。默认值为 FALSE。
    </summary>
    <value>一个逻辑值。如果设置为 TRUE，则在关闭此(主)窗口时退出应用程序。默认值为 FALSE。</value>
  </AppWindow.QuitOnClose>

  <AppWindow.ReportException>
    <summary>这是一个不再使用或需要的兼容性方法。</summary>
    <param name="oRQ">报告异常的 ReportQueue 对象。</param>
  </AppWindow.ReportException>

  <AppWindow.ReportNotification>
    <summary>
      当 ReportQueue 有消息要发送给所有者窗口时调用。
    </summary>
    <param name="oRQ">要检查是否有待处理命令的 ReportQueue 对象。</param>
    <returns>
      如果有任何待处理的报告命令等待执行，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      此方法提供了一种机制来确定此应用程序窗口拥有的报告队列是否有任何待处理的报告命令。<br />
      请参阅 ReportQueue:EventType 访问以获取不同的事件代码。<br />
      要实现不同的行为，请为最终从 AppWindow 派生的类重新编码此方法。<br />
      多态性确保事件被分派到您的 ReportNotification() 处理程序，而不是 AppWindow 的。
    </remarks>
    <example> 
      此示例可选地对报告服务器关闭事件做出反应，并忽略其他事件： 
      <code language="X#">
        METHOD ReportNotification(oRQ) CLASS AppWindow
            LOCAL oTB
            LOCAL Reply

            IF (oRQ:EventType == REPORTSERVERCLOSEEVENT)
                oTB := TextBox{SELF,"You closed" + oRQ:ReportServer, "Should pending reports be attempted?"}

                oTB:TYPE := BUTTONYESNO + BOXICONQUESTIONMARK

                Reply := oTB:Show()

                oTB:Axit()

                IF (Reply == BOXREPLYNO)
                    RETURN FALSE
                ENDIF // Reply was BOXREPLYYES
            ENDIF

            RETURN TRUE // De-queue any pending
            // commands which can cause
            // restart prompts
      </code>
    </example>
  </AppWindow.ReportNotification>

  <AppWindow.Show>
    <summary>
      显示窗口。
    </summary>
    <returns>NIL</returns>
    <param name="nShowState">窗口区域应显示的状态。</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>SHOWICONIZED</term>
          <description>最初以图标形式显示窗口。用户必须单击图标才能开始操作窗口</description>
        </item>
        <item>
          <term>SHOWNORMAL</term>
          <description> 
            在其所有者上显示窗口，大小由所有者选择。 
            如果所有者是桌面，窗口看起来很大，但不会填满整个桌面。
            如果需要，您可以通过分配其 Size 和 Origin 变量来精确控制窗口的大小。 
            用户始终可以根据自己的要求调整窗口大小。这是<b>默认</b>值。 
          </description>
        </item>
        <item>
          <term>SHOWZOOMED</term>
          <description>显示窗口为所有者允许的最大大小。如果所有者是桌面，窗口占据整个桌面。</description>
        </item>
      </list>
    </remarks>
  </AppWindow.Show>

  <AppWindow.StatusBar>
    <summary>
      当前与应用程序窗口关联的状态栏。<br />
      如果没有关联的状态栏，则返回所有者窗口的状态栏。如果所有权层次结构中没有状态栏，则返回 NIL。
    </summary>
    <value>
      当前与应用程序窗口关联的状态栏。<br />
      如果没有关联的状态栏，则返回所有者窗口的状态栏。如果所有权层次结构中没有状态栏，则返回 NIL。
    </value>
  </AppWindow.StatusBar>

  <AppWindow.StatusMessage>
    <summary>
      在应用程序窗口的状态栏中显示消息。
    </summary>
    <returns>NIL</returns>
    <param name="oHL">包含状态消息描述(HyperLabel:Description)的链接或状态消息字符串。</param>
    <param name="nType">
      指示要在状态栏上显示的消息类型和优先级的常量值。<br />
      最高优先级消息 (MESSAGEMENU) 始终优先于并替换较低优先级消息。<br />
      有关更多信息，请参阅备注部分。
    </param>
    <remarks>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>MESSAGEMENU</term>
          <description>优先级 4(最高优先级)：与菜单选择相关的消息。</description>
        </item>
        <item>
          <term>MESSAGEERROR</term>
          <description>优先级 3：错误消息。</description>
        </item>
        <item>
          <term>MESSAGECONTROL</term>
          <description>优先级 2：与控件相关的消息。</description>
        </item>
        <item>
          <term>MESSAGEPERMANENT</term>
          <description> 
            优先级 1(最低优先级)：状态栏上显示的默认消息；当更高优先级的消息优先时存储，并在没有其他消息优先时重新显示。这是<b>默认</b>。 
          </description>
        </item>
      </list>
    </remarks>
  </AppWindow.StatusMessage>

  <AppWindow.SystemMenu>
    <exclude />
  </AppWindow.SystemMenu>

  <AppWindow.ToolBar>
    <summary>
      与应用程序窗口对应的工具栏(如果返回值为 NIL，则没有先前选择的工具栏)。
    </summary>
    <value>与应用程序窗口对应的工具栏(如果返回值为 NIL，则没有先前选择的工具栏)。</value>
  </AppWindow.ToolBar>

  <AppWindow.WarningMessage>
    <summary>
      在警告框中显示消息。
    </summary>
    <param name="aPlace1">包含警告框标题和描述(HyperLabel:Caption 和 HyperLabel:Description)的链接，或要在警告框中显示的标题。</param>
    <param name="aPlace2">要在警告框中显示的描述。</param>
    <returns>WarningBox:Show()调用的返回值</returns>
  </AppWindow.WarningMessage>

  <ASPAppAbstract>
    <summary>
      定义 OLE 服务应用程序的通用协议。<br />
      这是一个抽象类，不应直接使用——而应使用其子类之一。
    </summary>
    <remarks>
      这个抽象类定义了各种 X# HTTP 服务应用程序使用的通用协议——属性和行为。
    </remarks>
  </ASPAppAbstract>

  <ASPAppAbstract.Exec>
    <summary>
      启动非GUI应用程序的事件处理循环。
    </summary>
    <remarks>
      通常，应用程序的事件处理循环会一直循环，直到没有更多的 EventContext 对象。它也可以在调用 ASPAppAbstract:Quit() 时终止。
    </remarks>
    <example> 
      以下代码显示了一个外部ASP组件应用程序的框架： 
      <code language="X#">
        CLASS ASPComponent INHERIT IScriptingContext
            GLOBAL oLogFile AS LogFile

        FUNC Start()
            LOCAL oServer AS ASPComponent
            LOCAL oAspApp AS AspApp

            #IFDEF __DEBUG__
                oLogFile := LogFile{}
                oLogFile:DebugMsg("ASP组件已启动...")
            #ENDIF

            oAspApp := ASPApp{}
            oServer := ASPComponent{}
            oServer:ASPApp := oAspApp
            oAspApp:Exec()
      </code>
    </example>
  </ASPAppAbstract.Exec>

  <ASPAppAbstract.Quit>
    <summary>
      通过指示应用程序关闭自身来终止非 GUI 应用程序。
    </summary>
    <remarks>
      通常在选择退出菜单命令时调用此方法。
    </remarks>
  </ASPAppAbstract.Quit>

  <AutoServer>
    <summary>
      实现 OLE 自动化服务的基类。
    </summary>
    <remarks>
      AutoServer 类可以用作实现 OLE 自动化服务器的基类。<br />
      您可以使用任何 X# 类作为自动化接口；
      但是，如果您决定让您的自动化服务器继承自AutoServer，则不必执行注册调用，
      RegisterOLEAutomationObject() 和 UnregisterOLEAutomationObject()。<br />
      有关详细信息，请参阅在线帮助的“如何”部分中的在X#中创建OLE服务，以及从应用程序库的示例选项卡页面访问的示例应用程序。
    </remarks>
  </AutoServer>

  <AutoServer.ctor>
    <summary>
      实例化一个新的 AutoServer 对象。
    </summary>
    <param name="oOwnerWnd">自动化服务的所有者。</param>
    <param name="sProgramID">自动化服务的程序 ID。程序 ID 是唯一标识自动化服务的字符串。</param>
    <param name="iResID">自动化服务类型库的资源ID。默认值为 1。</param>
    <param name="lASP"> 
      指定自动化服务是否用作 ASP 组件的标志。如果 <paramref name="oOwnerWnd" /> 是 ASPAppAbstract 类的后代，则默认值为 TRUE；否则为 FALSE。
    </param>
    <remarks> 
      Init() 方法实例化一个新的自动化服务器对象。 
      <note type="tip">
        在 IDE 中创建OLE自动化服务器应用程序时，必须在应用程序选项对话框的 OLE 服务器选项卡页面上设置应用程序属性，以匹配自动化服务器的 ProgID 和类。
      </note>
    </remarks>
  </AutoServer.ctor>

  <AutoServer.CloseServer>
    <summary>
      关闭服务应用程序。
    </summary>
    <remarks>
      如果表示自动化服务的 X# 类实现了 CloseServer() 方法，则当服务器的引用计数达到0时，即最后一个客户端关闭与服务器的连接时，将调用此方法。<br />
      AutoServer 类中的默认实现是终止服务器应用程序。
    </remarks>
  </AutoServer.CloseServer>

  <AutoServer.Destroy>
    <summary>
      提供一种方法来销毁 AutoServer 对象。
    </summary>
    <remarks>
      当不再需要 AutoServer 对象时，可以使用此方法。
    </remarks>
  </AutoServer.Destroy>

  <AutoServer.HelpAbout>
    <summary>
      显示“帮助关于”消息框。
    </summary>
    <remarks>
      自动化服务器通常提供 HelpAbout() 方法。在此基类中，HelpAbout() 方法显示一个简单的消息框。
      但是，在派生类中，您可能希望为专门的自动化服务重写该方法。
    </remarks>
  </AutoServer.HelpAbout>

  <AutoServer.Owner>
    <summary>
      自动化服务的所有者——窗口、控件或应用程序。
    </summary>
    <value>自动化服务的所有者——窗口、控件或应用程序。</value>
  </AutoServer.Owner>

  <BaseListBox>
    <summary>
      提供了 X# 列表框的基类，从中可以继承所有 X# 列表框类。
    </summary>
    <remarks>
      列表框向用户显示一个字符串(或项目)列表。您可以使用 BaseListBox 的方法来添加、排列、删除、询问列表框中的项目。<br />
      您还可以指定列表框中项目的排序方式。<br />
      当单击或双击列表框中的项目时，将分别在列表框的所有者窗口中触发 Window:ListBoxClick() 和 Window:ListBoxSelect() 事件处理程序。
    </remarks>
  </BaseListBox>

  <BaseListBox.ctor>
    <summary>
      构造一个列表框。
    </summary>
    <param name="oOwner">拥有列表框的窗口。</param>
    <param name="xID">列表框的唯一ID(介于1到8000之间)。</param>
    <param name="oPoint">列表框在画布坐标中的起点。</param>
    <param name="oDimension">列表框在画布坐标中的尺寸。</param>
    <param name="kStyle">列表框的样式，指定为以下常量之一：</param>
    <param name="lDataAware">一个逻辑值，指定列表框是否数据感知。</param>
    <param name="nResourceID">列表框的资源ID。</param>
    <remarks>
      <include file="Gui.xml" path="doc/LBStyles/*" />
    </remarks>
  </BaseListBox.ctor>

  <BaseListBox.AddItem>
    <summary>
      在指定位置向列表框添加一个新项目。
    </summary>
    <param name="cItem">要插入的项目。</param>
    <param name="uItem">要插入的项目。</param>
    <param name="nItemNumber">在列表框中插入新项目的位置。指定以下值之一：</param>
    <param name="uIndex">在列表框中插入新项目的位置。指定以下值之一：</param>
    <param name="Value">位置</param>
    <param name="uValue">位置</param>
    <param name="0">在未排序的列表框中，将新项目添加到列表的末尾；如果已排序，则在列表框确定的位置插入新项目。这是默认值。</param>
    <param name="1">列表框中的第一个位置。</param>
    <param name="n">列表框中的第n个位置。</param>
    <returns>
      如果项目已添加，则返回其在列表框中的位置(值1表示列表框中的第一个位置)。如果项目无法添加，则返回0。
    </returns>
  </BaseListBox.AddItem>

  <BaseListBox.Clear>
    <summary>
      清除列表框中的所有项目。
    </summary>
  </BaseListBox.Clear>

  <BaseListBox.CurrentItem>
    <inheritdoc />
  </BaseListBox.CurrentItem>

  <BaseListBox.CurrentItemNo>
    <inheritdoc />
  </BaseListBox.CurrentItemNo>

  <BaseListBox.CurrentText>
    <inheritdoc />
  </BaseListBox.CurrentText>

  <BaseListBox.DeleteItem>
    <summary>
      从列表框中删除一个项目。
    </summary>
    <param name="nItemNumber">要删除的项目编号。指定以下值之一：</param>
    <param name="Value">位置</param>
    <param name="0">当前选定的项目。这是默认值。</param>
    <param name="1">第一个项目。</param>
    <param name="n">第n个项目。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </BaseListBox.DeleteItem>

  <BaseListBox.Destroy>
    <summary>
      提供一种方法来销毁 BaseListBox 对象。
    </summary>
    <remarks>
      当不再需要 BaseListBox 对象时，可以使用此方法。<br />
      BaseListBox:Destroy() 销毁 BaseListBox 对象，并允许您关闭和释放对象打开或创建的任何资源，而无需等待垃圾收集器。
    </remarks>
    <returns>
      NIL
    </returns>
  </BaseListBox.Destroy>

  <BaseListBox.FindItem>
    <summary>
      搜索列表框中的指定字符串，并返回匹配的第一个项目的位置。
    </summary>
    <param name="cItem">要搜索的文本。</param>
    <param name="lWholeItem"> 
      指示如何执行搜索。<br />
      TRUE 将 <paramref name="cItem" /> 字符串与整个列表框项目进行精确匹配(例如，'can'字符串不匹配'scan')。<br />
      FALSE 查找任何以 <paramref name="cItem" /> 为前缀的列表框项目(例如，字符串'cat'将匹配列表框中的'catalog')。<br />
      默认值为 TRUE。
    </param>
    <param name="nStart">
      指定在搜索的第一个项目之前的项目的基于1的索引。<br />
      当搜索到列表框底部时，它会继续从列表框顶部搜索到 nStart 参数指定的项目。如果nStart为0，则从头开始搜索整个列表框。
    </param>
    <returns> 
      如果找到匹配项，则返回包含匹配文本的第一个项目的位置(值1表示列表框中的第一个位置)；<br />
      如果未找到匹配项，则返回0。 <br />
      例如，如果 <paramref name="cItem" /> 匹配列表框中的第五个字符串，则返回值为5。这意味着列表框中没有更早的字符串与之匹配。
    </returns>
  </BaseListBox.FindItem>

  <BaseListBox.GetItem>
    <summary>
      检索指定列表框项目的文本。
    </summary>
    <param name="nItemNumber"> 所需项目的编号。指定以下值之一： 
      <list type="table">
        <listheader>
          <term>值</term>
          <description>位置</description>
        </listheader>
        <item>
          <term>0</term>
          <description>当前选定的项目。</description>
        </item>
        <item>
          <term>1</term>
          <description>第一个项目。</description>
        </item>
        <item>
          <term>n</term>
          <description> 第n个项目。</description>
        </item>
      </list>
    </param>
    <param name="nLength">可选的数值，指示返回字符串的长度。</param>
    <returns>
      指定项目的文本。
    </returns>
  </BaseListBox.GetItem>

  <BaseListBox.ItemCount>
    <summary>
      表示列表框中项目数量的数值。
    </summary>
    <value>表示列表框中项目数量的数值。</value>
  </BaseListBox.ItemCount>

  <BaseListBox.SetTop>
    <summary>
      将指定项目移动到列表框的顶部。
    </summary>
    <param name="nItemNumber">要移动的项目编号。指定以下值之一：</param>
    <param name="Value">位置</param>
    <param name="0">当前选定的项目。</param>
    <param name="1">第一个项目。</param>
    <param name="n">第n个项目。</param>
  </BaseListBox.SetTop>

  <Bitmap>
    <summary>
      创建一个位图，它是一个位模式实体，即一个二维像素数组，每个像素具有颜色属性(单色或彩色)。
    </summary>
    <remarks>
      在 X# 中，位图是从资源实体创建的，可以用来创建画笔和图标。
    </remarks>
  </Bitmap>

  <Bitmap.ctor>
    <summary>
      从资源实体加载位图。
    </summary>
    <param name="xResourceID">位图的ResourceID对象或位图的数字资源ID。</param>
    <param name="kLoadOption">可选常量，表示加载选项。默认值为 LR_DEFAULTCOLOR。</param>
    <param name="iWidth">位图的可选宽度。默认值为位图的宽度。</param>
    <param name="iHeight">位图的可选高度。默认值为位图的高度。</param>
  </Bitmap.ctor>

  <Bitmap.Destroy>
    <summary>
      提供一种方法来销毁位图对象。
    </summary>
    <remarks>
      当不再需要位图对象时，可以使用此方法。<br />
      Bitmap:Destroy() 销毁位图对象，并允许您关闭和释放对象打开或创建的任何资源，而无需等待垃圾收集器。
    </remarks>
    <returns>
      NIL
    </returns>
  </Bitmap.Destroy>

  <Bitmap.Handle>
    <summary>
      返回位图的句柄。
    </summary>
    <param name="nHandleType"> 所需句柄的类型。0是唯一支持的选项，如果省略 <paramref name="nHandle" />，则为默认值。 </param>
    <returns>
      描述底层系统对象的句柄。
    </returns>
    <remarks>
      此方法提供 Windows GDI 对象的句柄，然后可以由 Windows API GDI 调用使用。
    </remarks>
  </Bitmap.Handle>

  <Bitmap.Size>
    <summary>
      表示位图大小的 Dimension 对象。
    </summary>
    <value>表示位图大小的 Dimension 对象。</value>
  </Bitmap.Size>

  <BitmapObject>
    <summary>
      创建一个 BitmapObject 对象；这种类型的实体是 DrawObject 层次结构的一部分，提供显示和操作各种对象的方法。
    </summary>
  </BitmapObject>

  <BitmapObject.ctor>
    <summary>
      构造一个 BitmapObject 对象。
    </summary>
    <param name="oPoint">BitmapObject 对象的原点，以画布坐标表示。</param>
    <param name="oDimension">BitmapObject 对象的尺寸，以画布坐标表示。</param>
    <param name="oBitmap">要使用的位图。</param>
  </BitmapObject.ctor>

  <BitmapObject.BoundingBox>
    <summary>
      表示完全包围 BitmapObject 对象的最小矩形的边界框。
    </summary>
    <value>表示完全包围 BitmapObject 对象的最小矩形的边界框。</value>
  </BitmapObject.BoundingBox>

  <BitmapObject.Draw>
    <summary>
      在窗口上绘制 BitmapObject 对象。
    </summary>
  </BitmapObject.Draw>

  <BitmapObject.Size>
    <summary>
      表示 BitmapObject 对象大小的 Dimension 对象。
    </summary>
    <value>表示 BitmapObject 对象大小的 Dimension 对象。</value>
  </BitmapObject.Size>

  <BoundingBox>
    <summary>
      创建一个边界框，它是一组四个数字，表示矩形的左下角和右上角。
    </summary>
    <example> 
      以下返回包围EllipseObject对象的最小矩形，以画布坐标表示： 
      <code language="X#">
        LOCAL oBB := oEllipse:BoundingBox()
      </code>
    </example>
    <remarks> 
      通常，矩形是包围另一个对象(例如，绘图或需要重绘的窗口区域)的整体大小和位置的最小矩形。 
      <note type="tip">
        边界框没有图形表示——它只是一个类中封装的四个数字。
      </note>
    </remarks>
  </BoundingBox>

  <BoundingBox.ctor>
    <summary>
      构造一个边界框。
    </summary>
    <param name="oPoint">边界框的原点，以画布坐标表示。</param>
    <param name="xPoint">
      边界框的尺寸。这可以是 <see cref="T:VO.Dimension">Dimension 对象</see>或 <see cref="T:VO.Dimension">Point 对象</see>。
    </param>
  </BoundingBox.ctor>

  <BoundingBox.Bottom>
    <summary>
      表示边界框底部 Y 坐标的数值，以画布坐标表示。
    </summary>
    <value>表示边界框底部 Y 坐标的数值，以画布坐标表示。</value>
  </BoundingBox.Bottom>

  <BoundingBox.ConvertToScreen>
    <summary>
      将边界框转换为给定窗口的屏幕坐标。
    </summary>
    <param name="oWindow"> 用于转换的 <see cref="T:VO.Window">Window 对象</see>。 </param>
    <returns>
      TRUE.
    </returns>
  </BoundingBox.ConvertToScreen>

  <BoundingBox.Extent>
    <exclude />
  </BoundingBox.Extent>

  <BoundingBox.Height>
    <summary>
      表示边界框高度的数值，以画布坐标表示。
    </summary>
    <value>表示边界框高度的数值，以画布坐标表示。</value>
  </BoundingBox.Height>

  <BoundingBox.Left>
    <summary>
      表示边界框左侧 X 坐标的数值，以画布坐标表示。
    </summary>
    <value>表示边界框左侧 X 坐标的数值，以画布坐标表示。</value>
  </BoundingBox.Left>

  <BoundingBox.Origin>
    <summary>
      表示边界框位置的点，以画布坐标表示。
    </summary>
    <value>表示边界框位置的点，以画布坐标表示。</value>
  </BoundingBox.Origin>

  <BoundingBox.PointInside>
    <summary>
      测试给定点是否在边界框内。
    </summary>
    <param name="oPoint">要测试的点。</param>
    <returns>
      如果点在边界框内，则为 TRUE；否则为 FALSE。
    </returns>
  </BoundingBox.PointInside>

  <BoundingBox.Right>
    <summary>
      表示边界框右侧 X 坐标的数值，以画布坐标表示。
    </summary>
    <value>表示边界框右侧 X 坐标的数值，以画布坐标表示。</value>
  </BoundingBox.Right>

  <BoundingBox.Size>
    <exclude />
  </BoundingBox.Size>

  <BoundingBox.Top>
    <summary>
      表示边界框顶部 Y 坐标的数值，以画布坐标表示。
    </summary>
    <value>表示边界框顶部 Y 坐标的数值，以画布坐标表示。</value>
  </BoundingBox.Top>

  <BoundingBox.Union_>
    <summary> 返回一个新的边界框，表示包含此边界框和由 <paramref name="oBoundingBox" /> 指定的边界框所需的最小区域。 </summary>
    <param name="oBB">要与此边界框合并的边界框。</param>
  </BoundingBox.Union_>

  <BoundingBox.Width>
    <summary>
      表示边界框宽度的数值，以画布坐标表示。
    </summary>
    <value>表示边界框宽度的数值，以画布坐标表示。</value>
  </BoundingBox.Width>

  <Brush>
    <summary>
      创建一个画笔，可以由 Window:PaintBoundingBox() 方法和 DrawObject 层次结构使用。
    </summary>
    <remarks>
      您可以通过指定颜色和图案组合来创建画笔(指定的图案可以是默认的预定义图案之一，也可以是用户提供的位图)。
    </remarks>
    <example> 
      此示例将窗口的背景更改为白色，并绘制一个黄色的交叉线矩形： 
      <code language="X#">
        oWindow:Background  := Brush{BRUSHWHITE}
        oBYellow            := Brush{Color{COLORYELLOW},HATCHORTHOGONALCROSS}
        oBPrevious          := oWindow:Foreground
        
        oWindow:Foreground := oBYellow
        oWindow:PaintBoundingBox(Point{0,0}, Dimension{100,100})
        oWindow:Foreground := oBPrevious
      </code>
    </example>
  </Brush>

  <Brush.ctor>
    <summary>
      构造一个画笔。
    </summary>
    <param name="oParent">** 缺少参数文档 **</param>
    <param name="xColor">
      新画笔的颜色对象。(有关指定颜色对象的详细信息，请参阅Color:Init()方法)或要创建的标准画笔，指定为以下常量之一。
    </param>
    <param name="kHatchStyle">新画笔的图案(也称为孵化样式或网格线图案)。指定以下常量之一。</param>
    <remarks> 
      xColor常量 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>BRUSHBLACK</term>
          <description>黑色</description>
        </item>
        <item>
          <term>BRUSHCLEAR</term>
          <description>透明</description>
        </item>
        <item>
          <term>BRUSHDARK</term>
          <description>深灰色</description>
        </item>
        <item>
          <term>BRUSHHOLLOW</term>
          <description>透明</description>
        </item>
        <item>
          <term>BRUSHLIGHT</term>
          <description>浅灰色</description>
        </item>
        <item>
          <term>BRUSHMEDIUM</term>
          <description>灰色</description>
        </item>
        <item>
          <term>BRUSHWHITE</term>
          <description>白色</description>
        </item>
      </list> 
      kHatchStyle常量: 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>0</term>
          <description>准备一个画笔。</description>
        </item>
        <item>
          <term>HATCHDIAGONAL135</term>
          <description>135度角平行线图案。</description>
        </item>
        <item>
          <term>HATCHDIAGONAL45</term>
          <description>45度角平行线图案。</description>
        </item>
        <item>
          <term>HATCHDIAGONALCROSS</term>
          <description>HATCHDIAGONAL45和HATCHDIAGONAL135的组合。</description>
        </item>
        <item>
          <term>HATCHHORIZONTAL</term>
          <description>水平平行线图案。</description>
        </item>
        <item>
          <term>HATCHORTHOGONALCROSS</term>
          <description>HATCHHORIZONTAL和HATCHVERTICAL的组合。</description>
        </item>
        <item>
          <term>HATCHSOLID</term>
          <description>实心图案。这是默认值。</description>
        </item>
        <item>
          <term>HATCHVERTICAL</term>
          <description>垂直平行线图案。</description>
        </item>
      </list>
    </remarks>
  </Brush.ctor>

  <Brush.CreateNew>
    <exclude />
  </Brush.CreateNew>

  <Brush.Destroy>
    <summary>
      提供一种方法来销毁 Brush 对象。
    </summary>
    <remarks>
      当不再需要 Brush 对象时，可以使用此方法。<br />
      Brush:Destroy() 销毁 Brush 对象，并允许您关闭和释放对象打开或创建的任何资源，而无需等待垃圾收集器。
    </remarks>
  </Brush.Destroy>

  <Brush.Handle>
    <summary>
      返回画笔的句柄。
    </summary>
    <param name="nHandleType"> 所需句柄的类型。0是唯一支持的选项，如果省略 <paramref name="nHandle" />，则为默认值。 </param>
    <returns>
      描述底层系统对象的句柄。
    </returns>
    <remarks>
      此方法提供 Windows GDI 对象的句柄，然后可以由 Windows API GDI 调用使用。
    </remarks>
  </Brush.Handle>

  <Button>
    <summary>
      提供所有 X# 按钮的基类。
    </summary>
    <remarks>
      您还可以使用 ControlWindow 类来创建具有不同于标准按钮的行为和/或外观的按钮。<br />
      使用 ControlWindow 允许控件捕获事件。典型的用途可能包括自定义控件的外观(如更改背景和前景颜色)或修改按键处理。
    </remarks>
  </Button>

  <Button.ctor>
    <summary>
      构造一个按钮。
    </summary>
    <param name="oOwner">拥有按钮的窗口。</param>
    <param name="xID">按钮的唯一ID(介于1和8000之间)。</param>
    <param name="oPoint">按钮在画布坐标中的起点。</param>
    <param name="oDimension">按钮在画布坐标中的尺寸。</param>
    <param name="cText">要在按钮中打印的信息文本。默认情况下，它是 NULL_STRING。</param>
    <param name="kStyle">
      按钮的样式，由 Windows API 样式常量指定。 
      <note type="tip">
        请查阅 Microsoft Win32 软件开发工具包文档，了解有关特定 Windows API 样式常量的详细信息。
      </note>
    </param>
    <param name="lDataAware">一个逻辑值，指定按钮是否数据感知。如果省略，默认为FALSE。</param>
    <param name="nResourceID">按钮的资源ID。</param>
  </Button.ctor>

  <Button.AsString>
    <summary>
      返回按钮的标识标签。
    </summary>
    <remarks>
      Button:AsString() 将按钮控件呈现为可识别的字符串形式&lt;ClassName&gt; - &lt;Caption&gt;。
    </remarks>
  </Button.AsString>

  <Button.Caption>
    <summary>
      表示显示在复选框或单选按钮旁边或推按钮顶部的文本字符串。Button:Caption 分配还会更改按钮的 Button:CurrentText。
    </summary>
    <value>表示显示在复选框或单选按钮旁边或推按钮顶部的文本字符串。Button:Caption 分配还会更改按钮的 Button:CurrentText。</value>
  </Button.Caption>

  <Button.CurrentText>
    <summary>
      对于复选框、推按钮和单选按钮，Button:CurrentText 包含 NULL_STRING。
    </summary>
    <value>对于复选框、推按钮和单选按钮，Button:CurrentText 包含 NULL_STRING。</value>
  </Button.CurrentText>

  <Button.Image>
    <summary>
      表示显示在按钮上的图标或位图图像的图像对象。
    </summary>
    <value>表示显示在按钮上的图标或位图图像的图像对象。</value>
  </Button.Image>

  <Button.ImageList>
    <exclude />
  </Button.ImageList>

  <Button.Modified>
    <summary>
      当用户点击按钮时设置为 TRUE，当鼠标按钮释放时重置为逻辑值 FALSE 。
    </summary>
    <value>当用户点击按钮时设置为 TRUE，当鼠标按钮释放时重置为逻辑值 FALSE 。</value>
  </Button.Modified>

  <ButtonImageList>
    <summary>
      创建用于按钮的图像列表。
    </summary>
    <remarks>
      用于按钮的图像作为 WinXP 支持的一部分自动放入 ButtonImageList 中。
    </remarks>
  </ButtonImageList>

  <ButtonImageList.ctor>
    <summary>
      构造一个用于按钮类的 WinXP 支持的图像列表对象。
    </summary>
    <param name="oImage">要放入图像列表中的图像对象。</param>
  </ButtonImageList.ctor>

  <ButtonImageList.Image>
    <summary>
      ButtonImageList 中的当前图像对象。
    </summary>
    <value>ButtonImageList 中的当前图像对象。</value>
  </ButtonImageList.Image>

  <CheckBox>
    <summary>
      创建复选框，复选框是用户可以切换开或关的控件(对于三态复选框，可以切换到第三种状态)。
    </summary>
    <remarks> 
      复选框允许用户在2种或3种状态之间进行选择。 <br />
      2态复选框允许在选中(ON)和未选中(OFF)状态之间进行选择。选择反映在 CheckBox:Value 访问中，可以为 TRUE 或 FALSE。 <br />
      3态复选框增加了第三种(未确定)状态，其中框变暗。第三种状态由 CheckBox:Value 为 TRUE 和 CheckBox:ValueChanged(通常为TRUE) 为 FALSE 表示。 <br /><br />

      复选框可以绑定到服务中的逻辑字段。<br />
      因此，您不能直接将三态复选框绑定到服务；
      相反，您必须创建一个数字或字符字段来存储三态信息，并根据 CheckBox:Value 和 CheckBox:ValueChanged 访问的状态更新它。<br />
      Window:ButtonClick() 事件处理程序响应复选框中的事件。事件处理程序的默认行为是切换复选框的状态。
      通常，您会实现自己的 ButtonClick() 事件处理程序，其中首先调用默认处理程序来设置按钮的状态。例如：
      <code language="X#">
        METHOD ButtonClick(oControlEvent) CLASS MyWind
            SUPER:ButtonClick(oControlEvent)
        // 执行其他操作
      </code>
    </remarks>
    <example> 
      此示例在对话窗口上创建一个复选框，然后选中它： 
      <code language="X#">
        CLASS MyDialog INHERIT DialogWindow
            HIDDEN oCBNew AS OBJECT

            METHOD Init(oWindow,nResourceID) CLASS MyDialog
                SUPER:Init(oWindow,nResourceID)

                oCBNew := CheckBox{SELF,IDB_CHECKBOX}
                oCBNew:Checked := TRUE

                SELF:Show()
      </code>
      在Windows中，复选框等同于具有 BS_CHECKBOX 样式的按钮。<br />
      BS_AUTOCHECKBOX 样式非常有用，因为按钮会自动选中和取消选中，而无需在系统中编写任何代码。它们通常在资源实体中指定，如下所示：
      <code language="X#">
        RESOURCE IDD_ABOUT DIALOG 20,20,160,120
        STYLE WS_POPUP | WS_DLGFRAME

        BEGIN
            CHECKBOX "&amp;Color" IDB_COLOR,10,20,40,12
            CHECKBOX "&amp;Filled" IDB_FILLED,10,35,40,12
            CONTROL "&amp;Auto",IDB_AUTO,"button", BS_AUTOCHECKBOX,10,65,40,12
            DEFPUSHBUTTON "OK" IDB_OK,64,80,32,14, WS_GROUP
        END
      </code>
    </example>
  </CheckBox>

  <CheckBox.ctor>
    <summary>
      构造一个复选框。
    </summary>
    <param name="oOwner">拥有复选框的窗口。</param>
    <param name="xID">复选框的唯一ID(介于1和8000之间)。</param>
    <param name="oPoint">复选框在画布坐标中的起点。</param>
    <param name="oDimension">复选框在画布坐标中的尺寸。</param>
    <param name="cText">与复选框关联的文本。如果未指定文本，则从 TextControl:TextValue 继承。</param>
    <param name="kStyle">
      表示复选框样式的常量，由 Windows API 样式常量指定。默认值为 BS_AUTOCHECKBOX。<br />
      请查阅Microsoft Win32软件开发工具包文档，了解有关特定Windows API样式常量的详细信息。
    </param>
    <param name="nResourceID">复选框的资源ID。</param>
  </CheckBox.ctor>

  <CheckBox.Checked>
    <summary>
      表示复选框当前状态的逻辑值。如果框被选中(或对于三态复选框，如果处于第三种未确定状态)，则为 TRUE，否则为 FALSE。<br />
      CheckBox:Checked 分配还会更改 CheckBox:Value 和 CheckBox:TextValue。
      此外，如果 CheckBox:Value 更改，CheckBox:ValueChanged 将设置为 TRUE。
    </summary>
    <value>
      表示复选框当前状态的逻辑值。如果框被选中(或对于三态复选框，如果处于第三种未确定状态)，则为 TRUE，否则为 FALSE。<br />
      CheckBox:Checked 分配还会更改 CheckBox:Value 和 CheckBox:TextValue。
      此外，如果 CheckBox:Value 更改，CheckBox:ValueChanged 将设置为 TRUE。
    </value>
  </CheckBox.Checked>

  <CheckBox.Destroy>
    <summary>
      提供一种方法来销毁 CheckBox 对象。
    </summary>
    <remarks>
      当不再需要 CheckBox 对象时，可以使用此方法。<br />
      CheckBox:Destroy() 销毁 CheckBox 对象，并允许您关闭和释放对象打开或创建的任何资源，而无需等待垃圾收集器。
    </remarks>
  </CheckBox.Destroy>

  <CheckBox.Image>
    <exclude />
  </CheckBox.Image>

  <CheckBox.TextValue>
    <summary>
      CheckBox:TextValue 在数据窗口上初始化为 FALSE，因为控件不包含文本。
    </summary>
    <value>CheckBox:TextValue 在数据窗口上初始化为 FALSE，因为控件不包含文本。</value>
  </CheckBox.TextValue>

  <CheckBox.Value>
    <summary>
      CheckBox:Value 包含 TRUE，如果复选框处于选中(ON)状态或对于三态复选框，处于第三种未确定状态。如果处于未选中状态(OFF)，则包含 FALSE。
    </summary>
    <value>
      CheckBox:Value 包含 TRUE，如果复选框处于选中(ON)状态或对于三态复选框，处于第三种未确定状态。如果处于未选中状态(OFF)，则包含 FALSE。
    </value>
  </CheckBox.Value>

  <CheckBox.ValueChanged>
    <summary>
      CheckBox:ValueChanged 包含 TRUE 或 FALSE，具体取决于复选框的状态。<br />
      对于2态复选框，它始终为 TRUE。<br />
      如果三态复选框处于第三种未确定状态，CheckBox:ValueChanged 为 FALSE 。
    </summary>
    <value>
      CheckBox:ValueChanged 包含 TRUE 或 FALSE，具体取决于复选框的状态。<br />
      对于2态复选框，它始终为 TRUE。<br />
      如果三态复选框处于第三种未确定状态，CheckBox:ValueChanged 为 FALSE 。
    </value>
  </CheckBox.ValueChanged>

  <ChildAppWindow>
    <summary>
      创建子应用程序窗口。
    </summary>
    <remarks>
      子应用程序窗口是“属于”另一个窗口(其所有者)的应用程序窗口。<br />
      由于子应用程序窗口不独立于所有者窗口，因此当其所有者窗口被销毁、隐藏或图标化时，它总是被销毁、隐藏或图标化。<br />
      还要注意，子应用程序窗口会被剪裁到所有者窗口。<br />
      子应用程序窗口在其所有者窗口上没有默认大小和位置。它们必须在显示之前给定一个起点和大小。<br />
      在 Windows 中，子应用程序窗口从不显示菜单(除了系统菜单)。但是，它可以拥有一个菜单。
      如果子窗口作为外壳窗口下的 MDI 子窗口使用，其菜单显示在外壳中。
      这非常有用：当不同的子窗口呈现不同类型的数据时，它们通常需要不同的菜单。
      系统会根据哪个子窗口具有焦点自动切换所有者外壳窗口的菜单。
    </remarks>
    <example> 
      以下示例显示一个子窗口： 
      <code language="X#">
        CLASS MyTopAppWindow INHERIT TopAppWindow
            HIDDEN oCAWNew AS OBJECT

            METHOD Init() CLASS MyTopAppWindow
                SUPER:Init()

                oCAWNew         := ChildAppWindow{SELF,FALSE}
                SELF:Caption    := "Top App Window"

                oCAWNew:Origin  := Point{10,10}
                oCAWNew:Size    := Dimension{100,60}

                SELF:Show()

                oCAWNew:Caption := "Child App Window"
                oCAWNew:Show()
      </code>
    </example>
  </ChildAppWindow>

  <ChildAppWindow.ctor>
    <summary>
      构造一个子应用程序窗口。
    </summary>
    <param name="oOwner">拥有子应用程序窗口的窗口。</param>
    <param name="lManaged">
      指示如何管理子应用程序窗口。<br />
      如果为 TRUE，子窗口由其所有者作为 MDI 客户端管理。<br />
      如果为 FALSE(默认值)，子窗口不会从 MDI 外壳获取其默认样式和菜单。在这种情况下，您必须显式提供代码来控制其行为。
    </param>
    <param name="lImpl">** 缺少参数文档 **</param>
  </ChildAppWindow.ctor>

  <ChildAppWindow.ContextMenu>
    <summary>
      表示窗口或窗口控件的本地弹出菜单的菜单对象。
    </summary>
    <value>表示窗口或窗口控件的本地弹出菜单的菜单对象。</value>
  </ChildAppWindow.ContextMenu>

  <ChildAppWindow.Default>
    <inheritdoc />
  </ChildAppWindow.Default>

  <ChildAppWindow.Destroy>
    <summary>
      提供一种方法来释放为 ChildAppWindow 对象及其派生对象分配的内存资源。
    </summary>
    <remarks>
      此方法立即释放在应用程序中显式创建的 ChildAppWindow 对象的资源。
      ChildAppWindow:Destroy() 还负责分配给派生类的资源，并按必要的顺序释放它们。
    </remarks>
    <returns>
      NIL
    </returns>
  </ChildAppWindow.Destroy>

  <ChildAppWindow.EnableBorder>
    <inheritdoc />
  </ChildAppWindow.EnableBorder>

  <ChildAppWindow.EnableHorizontalScroll>
    <inheritdoc />
  </ChildAppWindow.EnableHorizontalScroll>

  <ChildAppWindow.EnableOleDropTarget>
    <summary>
      将窗口注册为 OLE 拖放目标。
    </summary>
    <param name="lEnable">一个逻辑值，指定是否启用(TRUE)或禁用(FALSE)窗口作为拖放目标。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      使用 ChildAppWindow:EnableOLEDropTarget() 注册为 OLE 拖放目标的窗口可以处理 OLE 拖放事件，并在响应这些事件时创建新的 OLE 对象。<br />
      在关联的处理程序中，OLEDragEvent 对象作为参数传递，可以通过调用 OLEObject:CreateFromOLEDragEvent() 来创建新的 OLE 对象。
    </remarks>
    <example> 
      以下代码将数据窗口启用为拖放目标，并在其 OLEDrop 处理程序中创建一个新的 OLE 对象。<br />
      它还检查 OLE 对象的名称，以仅允许 WordPad 文档： 
      <code language="X#">
        METHOD EnableOLEDropTarget CLASS DropTargetDataWindow
            SUPER:EnableOLEDropTarget(TRUE)

            METHOD OLEDrop(oOLEDragEvent) CLASS MyChild
                LOCAL oOLE AS OLEObject
                LOCAL lRet AS LOGIC

                IF oOLEDragEvent:ObjectName == "WordPad Document"
                    oOLE := OLEObject{SELF}

                    oOLE:AllowInPlace := TRUE
                    oOLE:AllowResize  := TRUE

                    IF oOLE:CreateFromOLEDragEvent(oOLEDragEvent)
                        oOLE:Origin := oOLEDragEvent:Position
                        oOLE:Show()
                        oOLE:SetFocus()
                    ENDIF
                ENDIF
      </code>
    </example>
  </ChildAppWindow.EnableOleDropTarget>

  <ChildAppWindow.EnableStatusBar>
    <inheritdoc />
  </ChildAppWindow.EnableStatusBar>

  <ChildAppWindow.EnableVerticalScroll>
    <inheritdoc />
  </ChildAppWindow.EnableVerticalScroll>

  <ChildAppWindow.Show>
    <inheritdoc />
  </ChildAppWindow.Show>

  <ChildAppWindow.StatusBar>
    <inheritdoc />
  </ChildAppWindow.StatusBar>

  <ChildAppWindow.ToolBar>
    <inheritdoc />
  </ChildAppWindow.ToolBar>

  <ClipBoard>
    <summary>
      创建一个对象来引用 Windows 剪贴板，允许在不同应用程序之间共享文本和位图。
    </summary>
    <remarks>
      与 DDE 不同，数据传输几乎总是由用户发起的，例如当用户选择粘贴菜单命令时。
    </remarks>
  </ClipBoard>

  <Clipboard.ctor>
    <summary>
      构造一个剪贴板。
    </summary>
  </Clipboard.ctor>

  <Clipboard.Clear>
    <summary>
      清除剪贴板的内容。
    </summary>
    <returns>SELF</returns>
  </Clipboard.Clear>

  <Clipboard.FileCount>
    <summary>
      用于确定已拖放的文件数量。
    </summary>
    <value>用于确定已拖放的文件数量。</value>
  </Clipboard.FileCount>

  <Clipboard.GetItemSize>
    <summary>
      检索剪贴板中项目的大小，可以是字符串或位图对象。
    </summary>
    <param name="kFormat"> 
      要检索的项目类型，指定为以下常量之一： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>BITMAPFORMAT</term>
          <description>项目是一个位图对象。</description>
        </item>
        <item>
          <term>STRINGFORMAT</term>
          <description>项目是一个字符串。</description>
        </item>
      </list>
    </param>
  </Clipboard.GetItemSize>

  <Clipboard.Insert>
    <summary>
      将文本或位图插入剪贴板。
    </summary>
    <param name="xType">要插入剪贴板的文本或位图。</param>
    <remarks>
      如果插入文本，剪贴板中已有的文本将被覆盖。然而，剪贴板中的文本和位图不共享同一空间。<br />
      如果插入位图，现有的文本不会被删除；<br />
      如果插入文本，现有的位图不会被删除。
    </remarks>
    <returns>SELF</returns>
  </Clipboard.Insert>

  <Clipboard.InsertRTF>
    <summary>
      将 RTF 字符串插入剪贴板。
    </summary>
    <param name="cText">要插入剪贴板的 RTF 文本。</param>
    <remarks>
      用于将 RTF 文本插入剪贴板，覆盖可能已存在的任何先前的 RTF 文本。
    </remarks>
    <returns>SELF</returns>
  </Clipboard.InsertRTF>

  <Clipboard.RetrieveBitmap>
    <summary>
      从剪贴板中检索位图对象。
    </summary>
    <param name="oBitmap">一个空的位图对象，用于存储检索到的位图。</param>
    <returns>
      如果检索到位图对象，则为 TRUE；否则为 FALSE。
    </returns>
    <remarks>
      Clipboard:RetrieveBitmap() 方法会更改传递给它的位图对象参数的值。
    </remarks>
  </Clipboard.RetrieveBitmap>

  <Clipboard.RetrieveFiles>
    <summary>
      检索文件名数组。
    </summary>
    <param name="lMustExist">如果设置为 TRUE，文件必须实际存在才能出现在数组中。</param>
    <returns>
      文件名数组。
    </returns>
    <remarks>
      Clipboard:RetrieveFiles() 方法用于检索文件名数组。
    </remarks>
  </Clipboard.RetrieveFiles>

  <Clipboard.RetrieveRTF>
    <summary>
      从剪贴板中检索 RTF 字符串。
    </summary>
    <param name="nStringLength">要从剪贴板中检索的 RTF 文本的长度。如果为空或设置为0，则检索完整文本。</param>
    <remarks>
      用于从剪贴板中检索 RTF 文本。
    </remarks>
    <returns>
      剪贴板中的 RTF 字符串，如果剪贴板中没有字符串，则为 NULL_STRING。
    </returns>
  </Clipboard.RetrieveRTF>

  <Clipboard.RetrieveString>
    <summary>
      从剪贴板中检索字符串。
    </summary>
    <param name="nStringLength"> 要检索的字符串的长度。如果 <paramref name="nStringLength" /> 为零或未指定，则假定为完整的剪贴板内容。 </param>
    <returns>
      剪贴板中的字符串，如果剪贴板中没有字符串，则为 NULL_STRING。
    </returns>
  </Clipboard.RetrieveString>

  <Color>
    <summary>
      选择或创建一种颜色，该颜色可由 Brush、Pen 或 DrawObject 对象使用。
    </summary>
    <remarks>
      X# 提供了八种预定义颜色，或者您也可以通过指定红色、绿色和蓝色 (RGB) 值的加权组合来创建颜色(值的范围可以从 0(最低强度)到 255(最高强度))。
    </remarks>
    <example> 
      此示例使颜色变暗： 
      <code language="X#">
        METHOD Darken(oColor) CLASS MyWindow
            RETURN Color{oColor:Red - 9, oColor:Green - 9, oColor:Blue - 9}
      </code>
    </example>
  </Color>

  <Color.ctor>
    <summary>
      构造一种颜色
    </summary>
    <param name="nColor">
      使用单个数字构造颜色。当数字 &lt;= 时，假定它是预定义颜色之一，例如 ColorRed、ColorMagenta 等。否则颜色是颜色的 RGB 数字。
    </param>
    <param name="nRed">
      用于创建颜色的红色量。可以是 0(最低强度)到 255(最高强度)之间的值。默认值为 0。
    </param>
    <param name="nGreen">
      用于创建颜色的绿色量。可以是 0(最低强度)到 255(最高强度)之间的值。默认值为 0。
    </param>
    <param name="nBlue">
      用于创建颜色的蓝色量。可以是 0(最低强度)到 255(最高强度)之间的值。默认值为 0。
    </param>
    <remarks> 
      如果第一个和第二个参数都是数字并且第二个参数为 -1，VO 将把第一个数字视为颜色对象的 colorref。<br />
      在这种情况下，第一个数字表示要创建的标准颜色，指定为以下常量之一： 
      <include file="Gui.xml" path="doc/Colors/*" />
    </remarks>
    <example> 
      以下示例定义了一些颜色： 
      <code language="X#">
        oRed              := Color{COLORRED}
        oWhite            := Color{ 255, 255, 255}
        oMediumAquamarine := Color{  50, 204, 153}
        oBlack            := Color{   0,   0,   0}
        oBlue             := Color{   0,   0, 255}
        oCadetBlue        := Color{  95, 159, 159}
        oCornflowerBlue   := Color{  66,  66, 111}
        oDarkSlateBlue    := Color{ 107,  35, 142}
      </code>
    </example>
  </Color.ctor>

  <Color.Blue>
    <summary>
      0(最低强度)到 255(最高强度)之间的数值，表示颜色中蓝色的量。
    </summary>
    <value>0(最低强度)到 255(最高强度)之间的数值，表示颜色中蓝色的量。</value>
  </Color.Blue>

  <Color.ColorRef>
    <summary>
      0 到 0xFFFFFF 之间的数值，表示 RGB 格式的组合颜色。
    </summary>
    <value>0 到 0xFFFFFF 之间的数值，表示 RGB 格式的组合颜色。</value>
  </Color.ColorRef>

  <Color.Destroy>
    <summary>
      提供一种方法来销毁 Color 对象。
    </summary>
    <remarks>
      当不再需要 Color 对象时，可以使用此方法。<br />
      Color:Destroy() 销毁 Color 对象，并允许您关闭和释放对象打开或创建的任何资源，而无需等待垃圾收集器。
    </remarks>
  </Color.Destroy>

  <Color.Green>
    <summary>
      0(最低强度)到 255(最高强度)之间的数值，表示颜色中绿色的量。
    </summary>
    <value>0(最低强度)到 255(最高强度)之间的数值，表示颜色中绿色的量。</value>
  </Color.Green>

  <Color.Red>
    <summary>
      0(最低强度)到 255(最高强度)之间的数值，表示颜色中红色的量。
    </summary>
    <value>0(最低强度)到 255(最高强度)之间的数值，表示颜色中红色的量。</value>
  </Color.Red>

  <ComboBox>
    <summary>
      创建一个组合框，当您需要为用户提供一个选择列表和一个编辑控件(以便他们可以选择输入自己的选择)时使用。
    </summary>
    <remarks>
      组合框(也称为组合框)是一种结合了编辑控件和列表框功能的控件。<br />
      有三种类型的组合框——简单、下拉和下拉列表。<br />
      组合框向用户显示一个项目或选择列表，并允许直接在编辑区域中输入文本。组合框方法将允许您添加、排列、删除和查询项目列表。
      选择其中一项时，ComboBox:CurrentItem、ComboBox:CurrentItemNo、ComboBox:TextValue 和 ComboBox:Value 会更新。<br /><br />

      FillUsing() 方法中指定了一维或二维数组，每行表示可供选择的项目。
      对于二维数组，第一个元素称为显示值，第二个元素称为返回值。
      选择一个项目时，ComboBox:TextValue 包含第一个元素(显示值)，ComboBox:Value 包含第二个元素(返回值)。
      直接输入文本时，ComboBox:CurrentItemNo 设置为 0，新文本存储在 ComboBox:TextValue 和 ComboBox:Value 中。<br /><br />

      组合框可以绑定到服务器中的字段(字符、日期、逻辑、数字或备注)。字段的数据值存储在 ComboBox:Value 中。<br />
      组合框将数据值与 FillUsing() 数组中指定的第二个元素值进行比较，如果找到匹配项，
      则第一个元素(显示值)存储在 ComboBox:TextValue 中。在“无匹配”情况下，组合框显示未选择任何项目，
      ComboBox:CurrentItem 为 NULL_STRING，ComboBox:CurrentItemNo 设置为 0，
      ComboBox:TextValue 和 ComboBox:Value 反映字段内容。
      选择一个项目时，ComboBox:CurrentItemNo 设置为 1 到 ComboBox:ItemCount 之间的数字，
      对应的第二个元素存储为 ComboBox:Value 和字段的数据值。<br />
      直接输入文本时，它也会存储为字段的数据值。<br /><br />

      使用 Window:ListBoxSelect() 事件处理程序响应选择，使用 Window:ListBoxClick() 事件处理程序响应选择。<br />
      组合框主要是一个选择设备，因此不支持 Edit 类中可用的功能。
      但是，可以使用继承的 CurrentText 访问/分配方法更改或获取编辑组件的内容。<br /><br />

      组合框在其编辑控件失去或获得焦点时还会生成 EditFocusChangeEvents。
    </remarks>
    <example> 
      此示例创建一个组合框并填充动物列表： 
      <code language="X#">
        CLASS MyWindow INHERIT TopAppWindow
          HIDDEN oCB AS OBJECT

          METHOD Init() CLASS MyWindow
            SUPER:Init()

            oCB := ComboBox{SELF,42,Point{10,10}, Dimension{100,40}, BOXDROPDOWN}

            oCB:AddItem("Pig")
            oCB:AddItem("Cow")
            oCB:AddItem("Horse")

            oCB:Show()
      </code>
      此示例创建一个组合框，其中包含不同的货币，向用户显示显式表示，但内部使用不同的表示： 
      <code language="X#">
        METHOD Init(...) CLASS OrderWindow
            ...
            oCBCurrency := ComboBox{SELF,CBCURRENCY_ID}
            oCBCurrency:FillUsing({;
                                    {"U.S. Dollars",    "USD"},;
                                    {"Can. Dollars",    "CDN"},;
                                    {"Mexican Pesos",   "MEX"},;
                                    {"Yen",             "YEN"},;
                                    {"British Pounds",  "UK"},;
                                    {"German Marks",    "DM"};
                                  })
            oCBCurrency:Show()
      </code>
      此示例创建一个组合框，显示产品表中的可用产品： 
      <code language="X#">
        METHOD Init(...) CLASS OrderWindow
          ...
          oCBProducts := ComboBox{SELF,CBPRODUCTS_ID}
          oCBProducts:FillUsing(oDBProducts,#ProdName,#ProdNo)
          oCBProducts:Show()
      </code>
    </example>
  </ComboBox>

  <ComboBox.ctor>
    <summary>
      构造一个组合框。
    </summary>
    <param name="oOwner">拥有组合框的窗口。</param>
    <param name="xID">组合框的唯一 ID(介于 1 和 8000 之间)。</param>
    <param name="oPoint">组合框在画布坐标中的原点。</param>
    <param name="oDimension">组合框在画布坐标中的尺寸。</param>
    <param name="kComboType">要创建的组合框类型，指定为备注部分中列出的常量之一</param>
    <param name="kStyle">组合框的样式，指定为以下 Windows API 常量之一：</param>
    <param name="nResourceID">组合框的资源 ID。</param>
    <remarks>
      <list>
        <listheader>
          <term>常量</term>
          <description>创建</description>
        </listheader>
        <item>
          <term>BOXDROPDOWN</term>
          <description>
            带有编辑控件和下拉图标的扩展组合框。<br />
            用户可以在编辑控件中输入/编辑文本，或从列表框中选择项目
            (列表框仅在用户选择下拉图标时出现；如果用户再次选择图标，则列表框隐藏)。这是默认设置。
          </description>
        </item>
        <item>
          <term>BOXDROPDOWNLIST</term>
          <description>
            与 BOXDROPDOWN 相同，除了用户只能从列表框中选择项目。无法在编辑控件中输入或编辑文本。
          </description>
        </item>
        <item>
          <term>BOXSIMPLE</term>
          <description>
            带有编辑控件和始终可见的列表框的扩展组合框。用户可以在编辑控件中输入/编辑文本，或从列表框中选择项目。
          </description>
        </item>
      </list>
      kStyle 的可能值是： 
      <include file="Gui.xml" path="doc/CBStyles/*" />
    </remarks>
  </ComboBox.ctor>

  <ComboBox.CurrentItem>
    <summary>
      表示所选显示组合框项目的字符串。<br />
      ComboBox:CurrentItem 访问还会更改 ComboBox:CurrentItemNo、ComboBox:CurrentText、ComboBox:TextValue 和 ComboBox:Value(如果与可用显示项目匹配)。
    </summary>
    <value>
      表示所选显示组合框项目的字符串。<br />
      ComboBox:CurrentItem 访问还会更改 ComboBox:CurrentItemNo、ComboBox:CurrentText、ComboBox:TextValue 和 ComboBox:Value(如果与可用显示项目匹配)。
    </value>
  </ComboBox.CurrentItem>

  <ComboBox.CurrentItemNo>
    <summary>
      一个数值，介于 1 和 ComboBox:ItemCount 之间，表示最近获得焦点的项目。<br />
      如果未选择任何项目，则为 0。ComboBox:CurrentItemNo 分配还会更改 ComboBox:CurrentItem、ComboBox:TextValue 和 ComboBox:Value。
      如果 ComboBox:CurrentItemNo 分配表示更改，则 ComboBox:ValueChanged 将设置为 TRUE。
    </summary>
    <value>
      一个数值，介于 1 和 ComboBox:ItemCount 之间，表示最近获得焦点的项目。<br />
      如果未选择任何项目，则为 0。ComboBox:CurrentItemNo 分配还会更改 ComboBox:CurrentItem、ComboBox:TextValue 和 ComboBox:Value。
      ComboBox:CurrentItemNo 分配表示更改，则 ComboBox:ValueChanged 将设置为 TRUE。
    </value>
  </ComboBox.CurrentItemNo>

  <ComboBox.CurrentText>
    <summary>
      ComboBox:CurrentText 包含当前出现在组合框编辑框区域中的文本。<br />
      CurrentText 分配还会更改 TextValue 和 Value。<br />
      如果分配的 CurrentText 与显示的项目之一不匹配，则 CurrentItemNo 设置为 0。<br />
      如果分配的值表示更改，则 ValueChanged 将设置为 TRUE。
    </summary>
    <value>
      ComboBox:CurrentText 包含当前出现在组合框编辑框区域中的文本。<br />
      CurrentText 分配还会更改 TextValue 和 Value。<br />
      如果分配的 CurrentText 与显示的项目之一不匹配，则 CurrentItemNo 设置为 0。<br />
      如果分配的值表示更改，则 ValueChanged 将设置为 TRUE。
    </value>
  </ComboBox.CurrentText>

  <ComboBox.Destroy>
    <summary>
      提供一种方法来销毁 ComboBox 对象。
    </summary>
    <remarks>
      当不再需要 ComboBox 对象时，可以使用此方法。ComboBox:Destroy() 销毁 ComboBox 对象，并允许您关闭和释放对象打开或创建的任何资源，而无需等待垃圾收集器。
    </remarks>
  </ComboBox.Destroy>

  <ComboBox.EditHandle>
    <summary>
      组合框控件的编辑部分的句柄。
    </summary>
    <value>组合框控件的编辑部分的句柄。</value>
  </ComboBox.EditHandle>

  <ComboBox.EditHeight>
    <summary>
      指定嵌入式编辑控件高度的整数值。
    </summary>
    <value>指定嵌入式编辑控件高度的整数值。</value>
  </ComboBox.EditHeight>

  <ComboBox.EnableAutoComplete>
    <exclude />
  </ComboBox.EnableAutoComplete>

  <ComboBox.Font>
    <exclude />
  </ComboBox.Font>

  <ComboBox.Modified>
    <summary>
      一个逻辑值，指示可编辑组合框是否正在修改过程中。<br />
      当您输入新文本或移动高亮选择时，它设置为 TRUE。当焦点从组合框移开时，ComboBox:Modified 重置为 FALSE。
    </summary>
    <value>
      一个逻辑值，指示可编辑组合框是否正在修改过程中。<br />
      当您输入新文本或移动高亮选择时，它设置为 TRUE。当焦点从组合框移开时，ComboBox:Modified 重置为 FALSE。
    </value>
  </ComboBox.Modified>

  <ComboBox.ReadOnly>
    <exclude />
  </ComboBox.ReadOnly>

  <ComboBox.RemoveEditBalloonTip>
    <exclude />
  </ComboBox.RemoveEditBalloonTip>

  <ComboBox.SetCueBanner>
    <summary>
      向组合框控件的编辑部分添加提示横幅。
    </summary>
    <param name="cTitle">显示为提示的文本。</param>
    <remarks>
      提示横幅是显示在编辑控件中的文本，通常指示控件的用途或提示所需的输入类型。当控件获得焦点或其中有文本时，不再显示提示。
    </remarks>
  </ComboBox.SetCueBanner>

  <ComboBox.ShowEditBalloonTip>
    <exclude />
  </ComboBox.ShowEditBalloonTip>

  <ComboBox.TextValue>
    <summary>
      表示当前选定项目的显示值(第一个数组元素)的字符串(如果有)，或直接输入的任何文本。字符串根据附加到列表框(或组合框)的字段规范的图片子句进行格式化。<br />
      例如，ComboBoxTextValue 可以是“Jones”、“01/15/95”或“8”。<br />
      ComboBoxTextValue 分配还会更改 ComboBox:CurrentItem、ComboBox:CurrentItemNo、ComboBox:Modified、ComboBox:Value 和 ComboBox:ValueChanged。
      如果分配不匹配显示项目之一，则 ComboBox:TextValue 和 ComboBox:Value 设置为无法匹配的文本，ComboBox:CurrentItemNo 设置为 0。
      如果控件绑定到服务器中的字段并且字段数据值不匹配数组的第二个元素之一，ComboBox:TextValue 和 ComboBox:Value 包含字段的数据值。
    </summary>
    <value>
      表示当前选定项目的显示值(第一个数组元素)的字符串(如果有)，或直接输入的任何文本。字符串根据附加到列表框(或组合框)的字段规范的图片子句进行格式化。<br />
      例如，ComboBoxTextValue 可以是“Jones”、“01/15/95”或“8”。<br />
      ComboBoxTextValue 分配还会更改 ComboBox:CurrentItem、ComboBox:CurrentItemNo、ComboBox:Modified、ComboBox:Value 和 ComboBox:ValueChanged。
      如果分配不匹配显示项目之一，则 ComboBox:TextValue 和 ComboBox:Value 设置为无法匹配的文本，ComboBox:CurrentItemNo 设置为 0。
      如果控件绑定到服务器中的字段并且字段数据值不匹配数组的第二个元素之一，ComboBox:TextValue 和 ComboBox:Value 包含字段的数据值。
    </value>
  </ComboBox.TextValue>

  <ComboBox.Value>
    <summary>
      表示当前选定项目的返回值(FillUsing() 数组中的第二个元素)的字符串(如果有)，或直接输入的任何文本。<br />
      字符串根据附加到列表框(或组合框)的字段规范的图片子句进行格式化。
      例如，ComboBox:TextValue 可以是“Jones”、“01/15/95”或“8”。
    </summary>
    <value>
      表示当前选定项目的返回值(FillUsing() 数组中的第二个元素)的字符串(如果有)，或直接输入的任何文本。
      字符串根据附加到列表框(或组合框)的字段规范的图片子句进行格式化。
      例如，ComboBox:TextValue 可以是“Jones”、“01/15/95”或“8”。
    </value>
    <remrks>
      <note type="tip">
        ComboBox:Value 可能并不总是与控件的状态一致，如用户所示。<br />
        例如，如果字段的数据值不是列表框返回值的允许选择之一，则控件将处于“无匹配”状态。
        在这种情况下，列表框将恢复到其初始未选择状态，CurrentItemNo 设置为 0。
      </note> 
      如果没有选定项目并且组合框未绑定到服务器中的字段，则 ComboBox:Value 设置为 NIL。<br />
      如果有匹配项，ComboBox:Value 分配还会更改 ComboBox:CurrentItem、ComboBox:CurrentItemNo、ComboBox:TextValue 和 ComboBox:ValueChanged。<br />
      如果分配的文本与返回值选择之一不匹配，则 ComboBox:CurrentItemNo 设置为 0，TextValue 和 Value 设置为分配的文本。
      在列表框中，ComboBox:Value 通常是返回值之一，除非控件绑定到字段，其中实际内容不是允许的选择之一；
      在这种情况下，ComboBox:TextValue 和 ComboBox:Value 包含字段的数据值。 <br /><br />

      ComboBox:Value 的数据类型由列表框的字段规范确定；反过来，链接到数据服务器的控件从服务器字段继承字段规范(因此继承数据类型)。
      当通过将其名称设置为附加到数据窗口的服务中的字段名称来使控件数据感知时，ComboBox:Value 能够自动从该字段读取和写入。 
    </remrks>
  </ComboBox.Value>

  <ComboBox.ValueChanged>
    <summary>
      表示组合框值在选择过程中是否已从先前选定项目更改的逻辑值。TRUE 表示它已从先前的选择更改，而 FALSE 表示它未从先前的选择更改。<br />
      组合框值可以通过单击不同的项目、通过 ComboBox:TextValue 或 ComboBox:Value 分配，或通过直接输入文本来更改。
    </summary>
    <value>
      表示组合框值在选择过程中是否已从先前选定项目更改的逻辑值。TRUE 表示它已从先前的选择更改，而 FALSE 表示它未从先前的选择更改。<br />
      组合框值可以通过单击不同的项目、通过 ComboBox:TextValue 或 ComboBox:Value 分配，或通过直接输入文本来更改。
    </value>
  </ComboBox.ValueChanged>

  <ComboBoxEx>
    <summary>
      封装一个 ComboBoxEx 控件。
    </summary>
    <remarks>
      ComboBoxEx 控件是一个带有两个扩展的 ComboBox 控件。<br />
      首先，列表中的每个项目都可以在其旁边显示一个图像。这是通过分配给控件的 ImageList 对象实现的。当选择该项目时，它还可以覆盖第二个图像。添加项目时指定这两个图像。<br />
      其次，与普通的 ComboBox 控件不同，ComboBoxEx 控件不受其所有者框架的限制，而是可以越过框架并进入周围区域，以便在下拉框中显示其条目列表。
    </remarks>
  </ComboBoxEx>

  <ComboBoxEx.ctor>
    <summary>
      实例化一个新的 ComboBoxEx 对象。
    </summary>
    <param name="oOwner">拥有扩展组合框的窗口。</param>
    <param name="xID">扩展组合框的唯一 ID(介于 1 和 8000 之间)。</param>
    <param name="oPoint">扩展组合框在画布坐标中的原点。</param>
    <param name="oDimension">扩展组合框在画布坐标中的尺寸。</param>
    <param name="kComboType">要创建的扩展组合框的类型，指定为备注部分表中的常量之一。</param>
    <param name="kStyle">扩展组合框的样式，指定为备注部分中的 API 常量之一</param>
    <param name="nResourceID">扩展组合框的资源 ID。</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>创建</description>
        </listheader>
        <item>
          <term>BOXDROPDOWN</term>
          <description>
            一个带有编辑控件和旁边下拉图标的扩展组合框。<br />
            用户可以在编辑控件中输入/编辑文本，或从列表框中选择项目(列表框仅在用户选择下拉图标时出现；如果用户再次选择图标，则列表框隐藏)。这是默认设置。
          </description>
        </item>
        <item>
          <term>BOXDROPDOWNLIST</term>
          <description>
            与 BOXDROPDOWN 相同，除了用户只能从列表框中选择项目。无法在编辑控件中输入或编辑文本。
          </description>
        </item>
        <item>
          <term>BOXSIMPLE</term>
          <description>
            一个带有编辑控件和始终可见的列表框的扩展组合框。用户可以在编辑控件中输入/编辑文本，或从列表框中选择项目。
          </description>
        </item>
      </list>
      可能的 kStyle 值是： 
      <include file="Gui.xml" path="doc/CBStyles/*" />
      <note type="tip">
        请参阅 Microsoft Win32 软件开发工具包文档，了解有关特定样式常量的详细信息。
      </note>
    </remarks>
  </ComboBoxEx.ctor>

  <ComboBoxEx.AddItem>
    <summary>
      向 ComboBoxEx 对象添加新项目。
    </summary>
    <param name="cItem">项目文本作为字符串。</param>
    <param name="nItemNumber">插入新项目的位置。默认放置在列表末尾(-1)。请注意，组合框的索引是从零开始的。</param>
    <param name="uRetValue"> 与指定项目关联的值。默认值为 <paramref name="cItem" />。 </param>
    <param name="iImageIdx">与此项目关联的图像的索引。</param>
    <param name="iSelectedIdx">选择项目时显示的图像索引。</param>
    <param name="iOverlayIdx">图像列表中覆盖图像的图像索引。</param>
    <param name="iIndent">项目的缩进级别。</param>
    <returns>
      新插入项目的位置。
    </returns>
    <remarks>
      此方法将新项目插入 ComboBoxEx 控件中。除了父类已知的参数外，ComboBoxEx 还期望指定图像列表中图像索引的索引，这些索引与项目文本一起显示。
    </remarks>
  </ComboBoxEx.AddItem>

  <ComboBoxEx.DeleteItem>
    <summary>
      从 ComboBox 对象中删除项目。
    </summary>
    <param name="nItemNumber">要删除的项目编号。如果省略，则默认为当前项目。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      重写其父类的 DeleteItem() 方法，以实现相同的行为。
    </remarks>
  </ComboBoxEx.DeleteItem>

  <ComboBoxEx.Dispatch>
    <inheritdoc />
  </ComboBoxEx.Dispatch>

  <ComboBoxEx.EditHandle>
    <exclude />
  </ComboBoxEx.EditHandle>

  <ComboBoxEx.GetExCBStyle>
    <exclude />
  </ComboBoxEx.GetExCBStyle>

  <ComboBoxEx.GetItemAttributes>
    <exclude />
  </ComboBoxEx.GetItemAttributes>

  <ComboBoxEx.ImageList>
    <summary>
      包含 ComboBoxEx 对象中项目图像的 ImageList 对象。
    </summary>
    <value>包含 ComboBoxEx 对象中项目图像的 ImageList 对象。</value>
  </ComboBoxEx.ImageList>

  <ComboBoxEx.InsertItem>
    <exclude />
  </ComboBoxEx.InsertItem>

  <ComboBoxEx.Length>
    <summary>
      当前文本的长度。重写其父类的 Length 属性，以在此专用类中提供相同的功能。
    </summary>
    <value>当前文本的长度。重写其父类的 Length 属性，以在此专用类中提供相同的功能。</value>
  </ComboBoxEx.Length>

  <ComboBoxEx.SetExCBStyle>
    <exclude />
  </ComboBoxEx.SetExCBStyle>

  <ComboBoxEx.SetItemAttributes>
    <exclude />
  </ComboBoxEx.SetItemAttributes>

  <ComboBoxExEndEditEvent>
    <summary>
      提供有关 ComboBoxEx EndEdit 事件的信息
    </summary>
    <remarks>
      当用户在编辑框中完成操作或从控件的下拉列表中选择项目时，会生成 ComboBoxExEndEditEvent 事件。
    </remarks>
  </ComboBoxExEndEditEvent>

  <ComboBoxExEndEditEvent.ctor>
    <inheritdoc />
  </ComboBoxExEndEditEvent.ctor>

  <ComboBoxExEndEditEvent.IsChanged>
    <exclude />
  </ComboBoxExEndEditEvent.IsChanged>

  <ComboBoxExEndEditEvent.NewSelection>
    <exclude />
  </ComboBoxExEndEditEvent.NewSelection>

  <ComboBoxExEndEditEvent.TextValue>
    <exclude />
  </ComboBoxExEndEditEvent.TextValue>

  <ComboBoxExEndEditEvent.Why>
    <exclude />
  </ComboBoxExEndEditEvent.Why>

  <ComboBoxExItem>
    <summary>
      此类包含 ComboBoxEx 项目的所有属性。<br />
      它与 ComboBoxEx 方法一起使用 ComboBoxEx:SetItemAttributes() ComboBoxEx:GetItemAttributes() ComboBoxEx:InsertItem()
    </summary>
  </ComboBoxExItem>

  <ComboBoxExItem.ctor>
    <summary>
      实例化一个新的 ComboBoxExItem 对象。
    </summary>
    <param name="cItem">项目文本作为字符串。</param>
    <param name="nItemNumber">插入新项目的位置。默认放置在列表末尾(-1)。请注意，组合框的索引是从零开始的。</param>
    <param name="uRetValue"> 与指定项目关联的值。默认值为 <paramref name="cItem" />。 </param>
    <param name="iImageIdx">与此项目关联的图像的索引。</param>
    <param name="iSelectedIdx">选择项目时显示的图像索引。</param>
    <param name="iOverlayIdx">图像列表中覆盖图像的图像索引。</param>
    <param name="iIndent">项目的缩进级别。</param>
  </ComboBoxExItem.ctor>

  <ComboBoxExItem.ImageIndex>
    <exclude />
  </ComboBoxExItem.ImageIndex>

  <ComboBoxExItem.ImageIndex>
    <summary>与此项目关联的图像的索引。</summary>
    <value>与此项目关联的图像的索引。</value>
  </ComboBoxExItem.ImageIndex>

  <ComboBoxExItem.Indent>
    <exclude />
  </ComboBoxExItem.Indent>

  <ComboBoxExItem.Indent>
    <summary>项目的缩进级别。</summary>
    <value>项目的缩进级别。</value>
  </ComboBoxExItem.Indent>

  <ComboBoxExItem.ItemIndex>
    <exclude />
  </ComboBoxExItem.ItemIndex>

  <ComboBoxExItem.ItemIndex>
    <summary>组合框中项目的位置。</summary>
    <value>组合框中项目的位置。</value>
  </ComboBoxExItem.ItemIndex>

  <ComboBoxExItem.OverlayImageIndex>
    <exclude />
  </ComboBoxExItem.OverlayImageIndex>

  <ComboBoxExItem.OverlayImageIndex>
    <summary>图像列表中覆盖图像的图像索引。</summary>
    <value>图像列表中覆盖图像的图像索引。</value>
  </ComboBoxExItem.OverlayImageIndex>

  <ComboBoxExItem.SelectedImageIndex>
    <exclude />
  </ComboBoxExItem.SelectedImageIndex>

  <ComboBoxExItem.SelectedImageIndex>
    <summary>选择项目时显示的图像索引。</summary>
    <value>选择项目时显示的图像索引。</value>
  </ComboBoxExItem.SelectedImageIndex>

  <ComboBoxExItem.TextValue>
    <exclude />
  </ComboBoxExItem.TextValue>

  <ComboBoxExItem.TextValue>
    <summary>项目文本作为字符串。</summary>
    <value>项目文本作为字符串。</value>
  </ComboBoxExItem.TextValue>

  <ComboBoxExItem.Value>
    <exclude />
  </ComboBoxExItem.Value>

  <ComboBoxExItem.Value>
    <summary>与指定项目关联的值。</summary>
    <value>与指定项目关联的值。</value>
  </ComboBoxExItem.Value>

  <Control>
    <summary>
      提供所有 X# 控件的基类。
    </summary>
    <remarks>
      Control 是一个主要系统类层次结构的基类。<br />
      控件提供了一种简便的用户 I/O 机制。它们是自包含的，并在用户采取某些操作(例如按下按钮或输入文本)时通知其各自的所有者。<br /><br />

      从资源实体模板创建的对话窗口上的控件在显示对话窗口时会自动显示。
      但是，如果应用程序希望操作控件，则必须通过创建适当类型的系统对象来注册控件。
      控件必须出现在所有者窗口中。它们还需要知道出现的位置。有两种基本方法可以指定位置；<br />
      一种是使用窗口编辑器放置控件。在这种情况下，X# 生成一个表示控件的资源。在程序中构造控件时，将资源的 ID 作为第二个参数传递给构造函数。<br />
      另一种方法是动态放置控件，在这种情况下，将控件的位置和大小作为第三个和第四个参数传递(第一个参数始终是所有者，第二个参数始终是资源ID)。
      即使动态放置控件，也要传递一个唯一的 ID 作为第二个参数。<br />
    </remarks>
  </Control>

  <Control.ctor>
    <summary>
      构造一个控件。
    </summary>
    <param name="oOwner">拥有控件的窗口。</param>
    <param name="xID">控件的唯一 ID(介于 1 和 8000 之间)。</param>
    <param name="oPoint">控件在画布坐标中的原点。</param>
    <param name="oDimension">控件在画布坐标中的尺寸。</param>
    <param name="cRegClass">表示控件类的字符串(例如，“Edit”、“ListBox”等)</param>
    <param name="kStyle">
      表示控件样式的常量，指定为 X# 样式常量或 Windows API 样式常量。样式可以使用 _Or() 运算符组合。
    </param>
    <param name="lDataAware">指示控件是否数据感知(TRUE)或否(FALSE)的逻辑值。默认值为 FALSE。</param>
    <param name="nResourceID">控件的资源 ID。</param>
    <remarks>
      <note type="tip">
        请参阅 Microsoft Win32 软件开发工具包文档，了解有关特定 Windows API 常量的详细信息。
      </note>
      控件有两种创建方式：动态创建或从编译的对话框资源创建。<br />
      动态创建需要在实例化参数中指定大小和位置，可以在任何类型的窗口上使用。
      编译的对话框资源(指定控件的大小和位置)只能与数据窗口和对话窗口一起使用。<br />
      此外，控件创建时的默认状态取决于放置控件的方式： 使用动态创建，控件保持不可见，直到调用 Control:Show()。
      这允许程序正确设置控件(具有正确的大小、位置和任何其他参数)，同时避免更改控件的“视觉噪音”。 <br />
      使用资源绑定实例化，控件会自动显示，无需调用 Control:Show()。 
    </remarks>
  </Control.ctor>

  <Control.Activate>
    <summary> 提供在控件具有焦点并激活窗口时调用的方法。<br /><br />
    </summary>
    <param name="oEvent">描述激活哪个窗口的事件。</param>
    <seealso cref="T:VO.Event" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      Activate() 事件发生在控件生命周期的开始或控件在被停用后被激活时(例如，通过鼠标单击它)。新激活的控件接收输入焦点。 <br />
      您应该在此事件处理方法中创建和显示光标(如果需要)。 <br />
      任何具有自己 Activate() 和 Deactivate() 事件处理程序的子类都应始终调用其所有者的处理程序。这确保了标题栏得到相应的高亮显示或变暗。 
    </remarks>
  </Control.Activate>

  <Control.AsString>
    <summary>
      返回控件的内容(或其标识标签)。
    </summary>
    <remarks>
      对于具有值的控件，例如编辑控件和复选框，此方法返回与 Control:TextValue 相同的值。<br />
      对于没有值的控件，例如按钮，它返回与 Control:Caption 相同的值。<br />
      在任何情况下，Control:AsString() 都会将控件呈现为可识别的字符串。
    </remarks>
  </Control.AsString>

  <Control.Background>
    <summary>
      用于绘制控件背景的画刷。例如，在单行编辑控件中，背景是编辑控件中文本后面的颜色。
    </summary>
    <value>用于绘制控件背景的画刷。例如，在单行编辑控件中，背景是编辑控件中文本后面的颜色。</value>
    <remarks>
        <note type="tip">
          如果启用了三维控件(通过调用 Enable3DControls() 函数)，此方法无效。
        </note>
    </remarks>
  </Control.Background>

  <Control.Caption>
    <summary>
      表示控件标题的字符串(即标识控件的静态文本)
    </summary>
    <value>表示控件标题的字符串(即标识控件的静态文本)</value>
    <remarks>
      表示控件标题的字符串(即标识控件的静态文本)。<br />
      示例包括按钮表面的标签、复选框或单选按钮旁边的文本，或单选按钮组或组框边框上的文本。<br />
      请注意，并非所有控件都有可见的标题。例如，普通的编辑控件(MultiLineEdit 类)没有可见的标题——通常显示在编辑控件旁边的文本实际上是一个单独的控件，
      由窗口编辑器放置在那里。因此，为这种类型的控件分配一个新值不会改变屏幕上的任何内容。
    </remarks>
  </Control.Caption>

  <Control.ContextMenu>
    <summary>
      表示控件的本地弹出菜单的菜单对象。
    </summary>
    <value>表示控件的本地弹出菜单的菜单对象。</value>
  </Control.ContextMenu>

  <Control.ControlID>
    <summary>
      表示控件唯一 ID 的 1 到 8000 之间的数字
    </summary>
    <value>表示控件唯一 ID 的 1 到 8000 之间的数字</value>
    <remarks>
      表示控件唯一 ID 的 1 到 8000 之间的数字。<br />
      每个控件都有自己的唯一 ID，以将其与其他控件区分开来(使所有者窗口能够确定哪个控件生成了事件)。
    </remarks>
  </Control.ControlID>

  <Control.Create>
    <summary>
      创建底层的 Win32 控件
    </summary>
  </Control.Create>

  <Control.DataField>
    <exclude />
  </Control.DataField>

  <Control.Deactivate>
    <summary> 提供在控件具有焦点并且窗口被停用时调用的方法。</summary>
    <param name="oEvent">描述停用哪个窗口的事件。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      通常在另一个应用程序、窗口或控件被激活时调用此事件处理程序。 
    </remarks>
    <seealso cref="T:VO.Event" />
  </Control.Deactivate>

  <Control.Default>
    <summary>调用控件的默认 Windows 过程并设置 EventReturnValue。</summary>
    <param name="oEvent">控件发生的事件。</param>
    <returns>无</returns>
    <seealso cref="T:VO.Event" />
  </Control.Default>

  <Control.Destroy>
    <summary>
      提供一种方法来销毁任何控件对象。
    </summary>
    <remarks>
      当不再需要控件对象时，可以使用此方法。<br />
      Control:Destroy() 销毁控件对象，并允许您关闭和释放对象打开或创建的任何资源，而无需等待垃圾收集器。
    </remarks>
  </Control.Destroy>

  <Control.Disable>
    <summary>
      禁用控件(直到后续调用 Control:Enable())。
    </summary>
    <remarks>
      禁用的控件不活动(例如，按钮不能被点击，数据控件不能被修改)，因此它们不会向其所有者窗口发送事件。<br />
      请注意，在 Windows 下，禁用的控件是灰显的。
    </remarks>
  </Control.Disable>

  <Control.DisableTheme>
    <summary>
      禁用控件的 WinXP 主题。
    </summary>
  </Control.DisableTheme>

  <Control.Dispatch>
    <summary> 提供在控件具有焦点时系统内事件的原型调度程序；将各种事件路由到其相应的事件处理程序。</summary>
    <param name="oEvent">要处理的事件。</param>
    <seealso cref="T:VO.Event" />
    <returns>
      表示处理事件的事件处理程序的数值。
    </returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      控件始终从用户和系统接收事件。每个控件只接收与其相关的事件。对于生成的每个事件，会发生两件事： <br />
      1. 根据触发事件的操作，将事件转换为特定的 Event 对象(例如 ExposeEvent 或 MouseEvent)。 <br />
      2. 调用相应的事件处理程序，并将此类型的 Event 对象传递给它。 <br />
      <note type="tip">
        如果要为底层窗口过程设置特定的返回值，必须更改控件对象的 EventReturnValue 变量。 <br />
        如果要处理其他事件(例如计时器事件)，需要编写自己的 Dispatch() 方法。编写自定义 Dispatch() 方法时应遵循以下指南： <br />
        1. 子类化适合操作类型的事件类型。 <br />
        2. 向派生对象添加事件处理函数。(当接收到事件时，应调用此事件处理程序。) <br />
        3. 通常，事件处理程序的实现应调用 Default()。<br />
        这保持了与基类相同的行为，但也允许其他类为新类型的事件提供有用的事件处理程序，从而为其他类提供一个框架。
        在接收到的事件未被自定义调度程序处理的情况下，应调用基类 Dispatch() 方法。<br />
        例如： <br />
        <code language="X#"> 
          RETURN SUPER:Dispatch(<paramref name="oEvent" />) 
        </code>
      </note>
    </remarks>
  </Control.Dispatch>

  <Control.Drop>
    <exclude />
  </Control.Drop>

  <Control.Enable>
    <summary>
      启用先前禁用的控件。
    </summary>
    <remarks>
      启用控件允许它生成事件，并在用户操作控件时将事件发送到其所有者窗口。<br />
      禁用控件的灰显效果被移除，控件恢复到其正常外观。<br />
      默认情况下，控件在被禁用之前是启用的，因此除非之前调用了 Control:Disable()，否则无需调用此 Enable() 方法。
    </remarks>
  </Control.Enable>

  <Control.EventReturnValue>
    <exclude />
  </Control.EventReturnValue>

  <Control.Expose>
    <summary> 提供在控件具有焦点并且窗口的某部分需要重绘时调用的方法。</summary>
    <param name="oExposeEvent">描述窗口的哪个控件需要重绘的 ExposeEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      这是最重要的事件处理程序之一。当控件： 
      <list type="bullet">
        <item>被另一个窗口部分覆盖时</item>
        <item>首次显示时</item>
        <item>尺寸增加时</item>
        <item>从图标化状态恢复时</item>
        <item>控件应保留足够的信息，以按原样(或应有的样子)重新绘制屏幕。</item>
      </list> 
      调用 Repaint() 或 Update() 也会触发 ExposeEvent；在 Expose() 期间不应调用 Repaint() 或 Update()。 
    </remarks>
  </Control.Expose>

  <Control.FieldSpec>
    <summary>
      连接到控件的字段规范。
    </summary>
    <value>连接到控件的字段规范。</value>
    <remarks> 
      从字段规范中，可以检索有关控件的其他信息，例如： 
      <code language="X#">
        cPicture := oControl:FieldSpec:Picture

        IF !oControl:FieldSpec:Validate(x)
            oHLStatus := oControl:FieldSpec:Status
        ENDIF
      </code>
    </remarks>
  </Control.FieldSpec>

  <Control.FocusChange>
    <summary> 提供在控件具有焦点并且输入焦点从当前控件更改为另一个控件(或反之亦然)时调用的方法。</summary>
    <param name="oFocusChangeEvent">标识焦点是获得还是失去的 FocusChangeEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </Control.FocusChange>

  <Control.GetExStyle>
    <summary>
      检索控件的扩展样式。
    </summary>
    <returns>
      表示启用的 X# 样式常量或 Windows API 样式常量的数值。
    </returns>
  </Control.GetExStyle>

  <Control.GetStyle>
    <summary>
      检索控件的样式。
    </summary>
    <returns>
      表示启用的 X# 样式常量或 Windows API 样式常量的数值。
    </returns>
  </Control.GetStyle>

  <Control.Handle>
    <summary>
      返回控件的句柄。
    </summary>
    <param name="uType"> 所需句柄的类型。零(0)是唯一支持的选项，如果省略 <paramref name="nHandle" />，则为默认值。 </param>
    <returns>
      描述底层系统对象的“窗口”(控件)的句柄。
    </returns>
    <remarks>
      此方法提供窗口的句柄，然后可以由 Windows API 调用使用。
    </remarks>
  </Control.Handle>

  <Control.HandleAsDword>
    <exclude />
  </Control.HandleAsDword>

  <Control.HasBorder>
    <summary>检查控件是否设置了边框</summary>
    <returns>设置了边框时返回 TRUE。否则返回 FALSE。</returns>
  </Control.HasBorder>

  <Control.HasStyle>
    <summary>检查控件是否设置了样式值</summary>
    <param name="kStyle">要检查的样式</param>
    <returns>设置了样式时返回 TRUE。否则返回 FALSE。</returns>
  </Control.HasStyle>

  <Control.Hide>
    <summary>
      隐藏控件，使其不可见(直到后续调用 Control:Show())。
    </summary>
  </Control.Hide>

  <Control.HorizontalScroll>
    <summary> 提供在控件具有焦点并且水平滚动条滚动时调用的方法。<br /><br />
    </summary>
    <param name="oScrollEvent">描述滚动类型和新位置的 ScrollEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      此事件处理程序的默认行为是更新滑块位置；可以使用自己的处理程序实现更改此行为。<br />
      此事件处理程序仅适用于 HorizontalScrollBar 和 WindowHorizontalScrollBar 对象。<br />
      如果应用程序有垂直滚动条，请使用 WindowVerticalScrollBar 事件处理程序。 
    </remarks>
  </Control.HorizontalScroll>

  <Control.HyperLabel>
    <summary>
      连接到控件的链接。
    </summary>
    <value>连接到控件的链接。</value>
    <remarks> 
      从链接中，可以检索有关控件的其他信息，例如： 
      <code language="X#">
        cCaption      := oControl:HyperLabel:Caption
        cDescription  := oControl:HyperLabel:Description
        cHelpContext  := oControl:HyperLabel:HelpContext
      </code>
    </remarks>
  </Control.HyperLabel>

  <Control.IsDestroyed>
    <exclude />
  </Control.IsDestroyed>

  <Control.IsDisabled>
    <exclude />
  </Control.IsDisabled>

  <Control.IsEditable>
    <exclude />
  </Control.IsEditable>

  <Control.IsEnabled>
    <summary>
      报告此控件当前是否启用。
    </summary>
    <returns>
      如果控件已启用，则返回 TRUE；否则返回 FALSE。
    </returns>
  </Control.IsEnabled>

  <Control.IsExStyle>
    <summary>检查控件是否设置了扩展样式值</summary>
    <param name="nStyle">要检查的扩展样式</param>
    <returns>设置了扩展样式时返回 TRUE。否则返回 FALSE。</returns>
  </Control.IsExStyle>

  <Control.IsReadOnly>
    <summary>
      报告此控件当前是否为只读。
    </summary>
    <returns>
      如果控件为只读，则返回 TRUE；否则返回 FALSE。
    </returns>
  </Control.IsReadOnly>

  <Control.IsStyle>
    <summary>检查控件是否设置了样式值</summary>
    <param name="nStyle">要检查的样式</param>
    <returns>设置了样式时返回 TRUE。否则返回 FALSE。</returns>
  </Control.IsStyle>

  <Control.IsVisible>
    <summary>
      报告此控件是可见(完全或部分)还是隐藏。
    </summary>
    <returns>
      如果控件可见，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      此样式在 Windows 编辑器中设置。
    </remarks>
  </Control.IsVisible>

  <Control.KeyDown>
    <summary> 提供在控件具有焦点并且按下键盘上的键时调用的方法。<br /><br />
    </summary>
    <param name="oKeyEvent">描述按下了哪个键的 KeyEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      仅当控件具有输入焦点时才调用此事件处理程序。 
    </remarks>
  </Control.KeyDown>

  <Control.KeyUp>
    <summary> 提供在控件具有焦点并且释放键盘上的键时调用的方法。<br /><br />
    </summary>
    <param name="oKeyEvent">描述释放了哪个键的 KeyEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      仅当控件具有输入焦点时才调用此事件处理程序。 
    </remarks>
  </Control.KeyUp>

  <Control.LinkDF>
    <summary>
      将控件连接到数据服务中的数据字段。
    </summary>
    <param name="oDS">要连接字段的服务。通常，这是整个窗口连接到的公共服务，但也可以将单个字段连接到其他服务。</param>
    <param name="siDF">服务中数据字段的编号。</param>
    <remarks>
      Control:LinkDF() 通常不应由应用程序直接调用。它由 DataWindow:Use() 方法调用；Use() 将整个客户端连接到整个服务器。<br />
      可以使用 Control:LinkDF() 显式地将控件连接到数据字段，可能是因为控件的名称与数据字段的名称不匹配，因此 Use() 方法的自动链接不起作用。
      甚至可以使用 Control:LinkDF() 将单个控件连接到不同的服务器；然而，这不推荐，因为数据窗口的自动行为和与数据服务的协作不适用于多个服务。<br />
      不会接收主服务以外的服务的通知，诸如 DataWindow:Delete() 和 DataWindow:Append() 等操作仅适用于主服务器。<br />
      要将窗口连接到多个数据库，请使用《程序员指南》的“GUI 类”章节中描述的技术。
    </remarks>
  </Control.LinkDF>

  <Control.MenuInit>
    <summary>
      提供在控件拥有的弹出菜单即将弹出时调用的方法。
    </summary>
    <param name="oMenuInitEvent">描述即将弹出的菜单的 MenuInitEvent 对象。</param>
  </Control.MenuInit>

  <Control.MenuSelect>
    <summary>
      提供在控件拥有的菜单上的项目被高亮显示时调用的方法。
    </summary>
    <param name="oMenuSelectEvent">描述哪个菜单和菜单命令(通过项目的 ID)生成了事件的 MenuSelectEvent 对象。</param>
  </Control.MenuSelect>

  <Control.Modified>
    <summary>
      当标准编辑控件或可编辑组合框正在修改时，设置为逻辑值 TRUE 。
    </summary>
    <value>当标准编辑控件或可编辑组合框正在修改时，设置为逻辑值 TRUE 。</value>
    <remarks>
      当标准编辑控件或可编辑组合框正在修改时，设置为逻辑值 TRUE 。<br />
      当编辑完成并且焦点转移到另一个控件时，Control:Modified 被重置为 FALSE。<br />
      控件创建时，Control:Modified 初始化为 FALSE。
    </remarks>
  </Control.Modified>

  <Control.MouseButtonDoubleClick>
    <summary> 提供在控件具有焦点、鼠标指针位于窗口上方并且双击鼠标按钮时调用的方法。<br /><br />
    </summary>
    <param name="oMouseEvent">包含双击鼠标按钮时鼠标状态信息的 MouseEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      MouseButtonDoubleClick() 通常发生在 MouseButtonDown() 和 MouseButtonUp() 事件处理程序之间。 
    </remarks>
  </Control.MouseButtonDoubleClick>

  <Control.MouseButtonDown>
    <summary> 
      提供在控件具有焦点、鼠标指针位于窗口上方并且单击鼠标按钮时调用的方法。
    </summary>
    <param name="oMouseEvent">包含单击鼠标按钮时鼠标状态信息的 MouseEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </Control.MouseButtonDown>

  <Control.MouseButtonUp>
    <summary>
      提供在控件具有焦点、鼠标指针位于窗口上方并且释放鼠标按钮时调用的方法。
    </summary>
    <param name="oMouseEvent">包含释放鼠标按钮时鼠标状态信息的 MouseEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      不要假设 Control:MouseButtonUp() 会在 Control:MouseButtonDown() 之后立即被调用。
      在此期间可能会生成其他 MouseEvent。 <br />
      在某些情况下，可能没有相应的 Control:MouseButtonDown() 事件的 Control:MouseButtonUp() 事件发送到窗口。
      这种情况可能发生在鼠标按钮在窗口上方单击，但在鼠标移出窗口后释放。 
    </remarks>
  </Control.MouseButtonUp>

  <Control.MouseDrag>
    <summary>
      提供在控件具有焦点并且在窗口中移动一个或多个按钮被单击的鼠标时调用的方法。
    </summary>
    <param name="oMouseEvent">包含鼠标拖动时按钮位置和状态信息的 MouseEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </Control.MouseDrag>

  <Control.MouseMove>
    <summary>
      提供在控件具有焦点并且在控件中移动鼠标时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oMouseEvent">包含鼠标移动时鼠标位置信息的 MouseEvent 对象。</param>
    <remarks>
      当鼠标移动且没有按下鼠标按钮时会发生此事件。
    </remarks>
  </Control.MouseMove>

  <Control.Move>
    <summary>
      提供在控件具有焦点并且控件被移动(由用户或应用程序)时调用的方法。
    </summary>
    <param name="oMoveEvent">描述窗口移动的 MoveEvent 对象。</param>
  </Control.Move>

  <Control.Name>
    <summary>
      表示控件名称的字符串。
    </summary>
    <value>表示控件名称的字符串。</value>
    <remarks>
      表示控件名称的字符串。<br />
      不要将名称与标题混淆：名称是程序员的 ID，用户永远不会看到。名称在引导系统的内置处理方面很重要。
      例如，按钮的名称是单击按钮时调用的方法的名称，控件的名称是将数据窗口链接到数据服务器时链接到的数据库字段的名称。
    </remarks>
  </Control.Name>

  <Control.NameSym>
    <summary>
      表示控件名称的符号。
    </summary>
    <value>表示控件名称的符号。</value>
    <remarks>
      表示控件名称的符号。<br />
      不要将名称与标题混淆：名称是程序员的 ID，用户永远不会看到。名称在引导系统的内置处理方面很重要。
      例如，按钮的名称是单击按钮时调用的方法的名称，控件的名称是将数据窗口链接到数据服务器时链接到的数据库字段的名称。
    </remarks>
  </Control.NameSym>

  <Control.Origin>
    <summary>
      表示控件在其所有者窗口上的位置的点，以画布坐标表示。
    </summary>
    <value>表示控件在其所有者窗口上的位置的点，以画布坐标表示。</value>
  </Control.Origin>

  <Control.OverRide>
    <summary>这是一个不再使用或需要的兼容性方法。</summary>
    <param name="lEnable"></param>
  </Control.OverRide>

  <Control.Owner>
    <summary>
      控件的所有者窗口。
    </summary>
    <value>控件的所有者窗口。</value>
  </Control.Owner>

  <Control.OwnerAlignment>
    <summary>
      表示窗口在其所有者窗口内对齐方式的常量。
    </summary>
    <value>表示窗口在其所有者窗口内对齐方式的常量。</value>
    <remarks>
      <para>如果为此属性设置了值，则所有者窗口的任何调整大小都会导致窗口自动重新对齐、调整大小和/或相应地移动。</para>
      <para>
        <b>
          注意：默认情况下(或在窗口编辑器中将 OwnerAlignment 设置为 <paramref name="Auto" />)，控件将出现在程序员放置它的位置，
          并且在调整所有者窗口大小时不会重新对齐、调整大小和/或移动。
        </b>
      </para>
      <para>有两个辅助所有者对齐的分配：</para>
      <list type="bullet">
        <item>
          Control：OwnerAlignment 适用于控件
        </item>
        <item>
          window：OwnerAlignment 适用于窗口
        </item>
      </list>
      <para>
        每当调用这些分配之一时，控件或窗口的当前大小和位置将保存到内部数组中。可以根据需要多次调用分配而不会出现任何困难，它将简单地覆盖旧值。
      </para>
      <para>从构建 2824 开始，此属性可以采用两种不同的形式：</para>
      <list type="bullet">
        <item>比例模式</item>
        <item>线性模式</item>
      </list>
      <h2>比例所有者对齐</h2>
      <para> 使用 <b>比例模式</b> 时，您可以使用 OA_ 定义来指定控件的大小和位置在窗口大小变化时应如何变化。例如： </para>
      <para>
        使用线性模式，您不使用预定义的 OA_ 定义，而是在代码中为控件的 4 个属性中的每一个指定变化量：
      </para>
      <list type="bullet">
        <item>X 位置</item>
        <item>Y 位置</item>
        <item>宽度</item>
        <item>高度</item>
      </list>
    </remarks>
  </Control.OwnerAlignment>

  <Control.PerformValidations>
    <summary>
      执行所有定义在此控件字段规范中的验证(例如，必填项、最大和最小位数、最大和最小值、验证规则)并返回测试结果。
    </summary>
    <returns>
      如果任何验证失败，此方法会适当地设置控件的状态并返回 FALSE。否则，它返回 TRUE。
    </returns>
  </Control.PerformValidations>

  <Control.ReadOnly>
    <summary>
      控件是否为只读？
    </summary>
  </Control.ReadOnly>

  <Control.RegisterTimer>
    <summary>
      注册一个计时器方法以供控件调用。
    </summary>
    <param name="nInterval">调用控件的 Timer() 方法之间的时间间隔(以秒为单位)。</param>
    <param name="lOneTime">
      逻辑值，指示计时器是否仅调用一次(TRUE)，或多次调用(FALSE)。如果省略，默认值为 FALSE。
    </param>
  </Control.RegisterTimer>

  <Control.RePaint>
    <summary>
      发送 ExposeEvent 以重新绘制控件
    </summary>
  </Control.RePaint>

  <Control.Resize>
    <summary>
      提供在控件具有焦点并且控件大小发生变化时调用的方法。
    </summary>
    <param name="oResizeEvent">描述控件新尺寸的 ResizeEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      在 Control:Resize() 事件处理程序中，调用 Window:Size 时应谨慎使用，以避免进入无限循环。 
    </remarks>
  </Control.Resize>

  <Control.RestoreUpdate>
    <summary>
      恢复控件的所有绘图更新(在调用 Control:SuspendUpdate() 之后)。
    </summary>
    <remarks>
      此方法恢复控件的所有绘图更新(在调用 Control:SuspendUpdate() 之后)。
    </remarks>
  </Control.RestoreUpdate>

  <Control.Server>
    <summary>
      当前连接到此控件的服务器对象。如果没有连接服务器，则值为 NIL。
    </summary>
    <value>当前连接到此控件的服务器对象。如果没有连接服务器，则值为 NIL。</value>
  </Control.Server>

  <Control.SetExStyle>
    <summary>
      设置控件的扩展样式。
    </summary>
    <param name="kExStyle">控件的扩展样式，由 X# 样式常量或 Windows API 样式常量指定。</param>
    <param name="lEnable">TRUE 启用指定的样式；FALSE 禁用它。如果省略，默认值为 TRUE。</param>
    <returns>NIL</returns>
  </Control.SetExStyle>

  <Control.SetFocus>
    <summary>
      将输入焦点传递给控件，从而将所有鼠标和键盘输入定向到控件。
    </summary>
  </Control.SetFocus>

  <Control.SetParent>
    <summary>
      更改控件的父句柄。
    </summary>
    <param name="hWndNewParent">控件的新的父句柄。</param>
  </Control.SetParent>

  <Control.SetStyle>
    <summary>
      设置控件的样式。
    </summary>
    <param name="kStyle">控件的样式，由 X# 样式常量或 Windows API 样式常量指定。</param>
    <param name="lEnable">TRUE 启用指定的样式；FALSE 禁用它。如果省略，默认值为 TRUE。</param>
    <returns>NIL</returns>
  </Control.SetStyle>

  <Control.Show>
    <summary>
      显示控件，使其可见。
    </summary>
    <remarks>
      控件创建时的默认状态取决于您放置控件的方式：<br />
      动态创建时，控件保持不可见，直到调用 Control:Show()。
      这允许程序正确设置控件(具有正确的大小、位置和任何其他参数)，同时避免了更改控件的“视觉噪音”。<br />
      使用资源绑定实例化时，控件会自动显示，无需调用 Control:Show()。<br />
      Control:Show() 通常也用于重新显示使用 Control:Hide() 方法隐藏的控件。
    </remarks>
  </Control.Show>

  <Control.Size>
    <summary>
      表示控件大小的尺寸。
    </summary>
    <value>表示控件大小的尺寸。</value>
  </Control.Size>

  <Control.Status>
    <summary>
      表示控件在验证尝试或其他操作后的状态的链接。
    </summary>
    <value>表示控件在验证尝试或其他操作后的状态的链接。</value>
    <remarks> 
      如果验证通过或操作成功，此值为 NULL_OBJECT；如果没有，它包含有关失败的信息，可以检索并显示，例如： 
      <code language="X#">
        IF !oControl:FieldSpec:Validate(x)
            WarningBox{SELF, oControl:Status:Caption, oControl:Status:Description}:Show()
        ENDIF
      </code>
      链接在系统中常用，在这种情况下，警告框能够接受链接并从中提取相关信息。因此，此示例可以进一步简化： 
      <code language="X#">
        IF !oControl:FieldSpec:Validate(x)
            WarningBox{SELF,oControl:Status}:Show()
        ENDIF
      </code>
    </remarks>
  </Control.Status>

  <Control.Style>
    <exclude />
  </Control.Style>

  <Control.SuspendUpdate>
    <summary>
      暂时挂起控件的所有绘图更新；绘图在调用 Control:RestoreUpdate() 时恢复。
    </summary>
    <remarks>
      此方法挂起控件的所有绘图更新。它对于 TreeView 和 ListView 控件特别有用，通常希望在填充 ListView 或 TreeView 控件时挂起绘图。
    </remarks>
  </Control.SuspendUpdate>

  <Control.TextValue>
    <summary>
      表示控件中保存的值的字符串。
    </summary>
    <value>表示控件中保存的值的字符串。</value>
    <remarks>
      例如，在标准编辑控件中，值可以是“Jones”或“$14,683.00”。在复选框中，值可以是“TRUE”或“FALSE”。<br />
      对于按钮，Control:TextValue 设置为 NULL_STRING。<br />
      在列表框或组合框中，Control:TextValue 保存显示值文本。<br />
      在单选按钮组中，Control:TextValue 保存当前选中的单选按钮的标题文本。
      请注意，字符串根据控件字段规范中包含的 picture 子句进行格式化；反过来，链接到数据服务的控件从服务字段继承字段规范 - 因此也继承 picture 子句。
    </remarks>
    <example> 
      以下示例演示了 Control:TextValue 属性的使用： 
      <code language="X#">
        // 打印“C”表示字符字符串
        ?ValType(oDCAmountControl:TextValue)
        // 访问控件(字符串值)
        cAmount := oDCAmountControl:TextValue
        // 将“5”分配给控件
        oDCAmountControl:TextValue := "5"
      </code>
    </example>
  </Control.TextValue>

  <Control.Timer>
    <summary>
      提供在通过 RegisterTimer() 方法注册计时器时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </Control.Timer>

  <Control.ToolTipText>
    <summary>
      表示当用户将鼠标指针移动到控件上时使用的工具提示文本的字符串值。
    </summary>
    <value>表示当用户将鼠标指针移动到控件上时使用的工具提示文本的字符串值。</value>
    <remarks> 
      表示当用户将鼠标指针移动到控件上时使用的工具提示文本的字符串值。 
      <note type="tip">
        工具提示不支持静态控件，例如固定文本、组框等。
      </note>
    </remarks>
  </Control.ToolTipText>

  <Control.UseHLForToolTip>
    <summary>
      确定是否应将控件的链接描述文本用作工具提示文本的逻辑值。
    </summary>
    <value>确定是否应将控件的链接描述文本用作工具提示文本的逻辑值。</value>
    <remarks> 
      确定是否应将控件的链接描述文本用作工具提示文本的逻辑值。 
      <note type="tip">
        任何 ToolTipText 设置将覆盖 UseHLForToolTip。
      </note>
    </remarks>
  </Control.UseHLForToolTip>

  <Control.ValidateControl>
    <summary>此方法验证控件是否已创建，如果未创建，则触发控件创建</summary>
    <returns>控件成功创建时返回 TRUE。否则返回 FALSE。</returns>
  </Control.ValidateControl>

  <Control.Value>
    <summary>
      控件中保存的值，以控件保存的任何数据类型表示。
    </summary>
    <value>控件中保存的值，以控件保存的任何数据类型表示。</value>
    <remarks> 
      控件中保存的值，以控件保存的任何数据类型表示。因此，Control:Value 是常见的数据类型。<br />
      例如，<br />
      在常规编辑控件中，值可以是字符串“Jones”或数字 14683。<br />
      在复选框中，Control:Value 可以是 TRUE 或 FALSE。<br />
      在列表框或组合框中，Control:Value 通常是返回值之一(除非控件绑定到字段，其中实际内容不是允许的选择之一)。<br />
      在单选按钮组中，Control:Value 保存当前选中的单选按钮的组值(在窗口编辑器中指定)；如果没有选中，Control:Value 设置为 NIL。<br /><br />

      控件值的数据类型由其字段规范确定；反过来，链接到数据服务的控件从服务字段继承字段规范 - 因此也继承数据类型。<br />
      当控件通过将其名称设置为附加到数据窗口的数据服务中的字段名称而变为数据感知时，Control:Value 能够自动从该字段读取和写入。 
      <note type="tip">
        值可能并不总是与控件的状态一致，如向最终用户指示的那样。<br />
        例如，如果字段的数据值不是列表框或组合框返回值的允许选择之一，或单选按钮组的组值设置之一，则控件将处于“无匹配”状态。<br />
        在这种情况下，控件将恢复到其初始未选中状态。
      </note>
    </remarks>
    <example> 
      以下示例演示了 Control:Value 属性的使用： 
      <code language="X#">
        // 打印“N”表示数字
        ?ValType(oDCAmountControl:Value)
        // 访问控件(数值)
        nAmount := oDCAmountControl:Value
        // 将“5”分配给控件
        oDCAmountControl:Value := 5
      </code>
    </example>
  </Control.Value>

  <Control.ValueChanged>
    <summary>
      表示控件的值是否已从先前的设置更改的逻辑值。
    </summary>
    <value>表示控件的值是否已从先前的设置更改的逻辑值。</value>
    <remarks>
      表示控件的值是否已从先前的设置更改的逻辑值。<br />
      TRUE 表示已从先前的设置更改，而 FALSE 表示未更改。<br />
      Control:ValueChanged 访问在控件绑定到服务器中的字段时特别有用，因为每次移动到新记录时，它会重置为 FALSE。
      如果您已更改原始数据值，则会设置为 TRUE。
    </remarks>
  </Control.ValueChanged>

  <Control.VerticalScroll>
    <summary>
      提供在控件具有焦点并且垂直滚动条滚动时调用的方法。
    </summary>
    <param name="oScrollEvent">描述滚动类型和新位置的 ScrollEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      此事件处理程序的默认行为是更新滑块位置；可以使用您自己的处理程序实现来更改此行为。<br />
      此事件处理程序仅适用于 HorizontalScrollBar 和 WindowHorizontalScrollBar 对象。<br />
      如果应用程序有水平滚动条，请使用 HorizontalScrollBar 事件处理程序。 
    </remarks>
  </Control.VerticalScroll>

  <ControlEvent>
    <summary>
      提供有关生成控件事件的控件的信息。
    </summary>
    <remarks>
      当用户操作按钮、编辑和列表框(及其各自的子类)类型的控件时，会生成 ControlEvent 事件。
    </remarks>
  </ControlEvent>

  <ControlEvent.ctor>
    <inheritdoc />
  </ControlEvent.ctor>

  <ControlEvent.Control>
    <summary>
      生成此控件事件的控件。
    </summary>
    <value>生成此控件事件的控件。</value>
    <remarks> 
      生成此控件事件的控件。 
      <note type="tip">
        如果生成控件事件的控件未创建为系统控件，则此值为 NIL。
        如果在资源实体中指定了对话窗口，但未在系统中注册(即窗口不属于 DialogWindow 类)，则会发生这种情况。
      </note>
    </remarks>
  </ControlEvent.Control>

  <ControlEvent.ControlID>
    <summary>
      表示生成此控件事件的控件的唯一 ID 的 1 到 8000 之间的数字。
    </summary>
    <value>表示生成此控件事件的控件的唯一 ID 的 1 到 8000 之间的数字。</value>
    <remarks>
      表示生成此控件事件的控件的唯一 ID 的 1 到 8000 之间的数字。<br />
      每个控件都有自己的唯一 ID，以将其与其他控件区分开来(使所有者窗口能够确定哪个控件生成了事件)。
    </remarks>
  </ControlEvent.ControlID>

  <ControlEvent.Description>
    <summary>
      表示生成此控件事件的控件描述的字符串。
    </summary>
    <value>表示生成此控件事件的控件描述的字符串。</value>
    <remarks>
      表示生成此控件事件的控件描述的字符串。描述包含在控件的链接中。如果控件没有描述，则此值为 NULL_STRING。
    </remarks>
  </ControlEvent.Description>

  <ControlEvent.HelpContext>
    <summary>
      表示生成此控件事件的控件的帮助上下文 ID 的字符串。
    </summary>
    <value>表示生成此控件事件的控件的帮助上下文 ID 的字符串。</value>
    <remarks> 
      表示生成此控件事件的控件的帮助上下文 ID 的字符串。此 ID 包含在控件的链接中。 
      <note type="tip">
        帮助上下文 ID 指示超文本系统中查找有关此控件的帮助的位置。
      </note>
    </remarks>
  </ControlEvent.HelpContext>

  <ControlEvent.HyperLabel>
    <summary>
      连接到控件事件的链接。
    </summary>
    <value>连接到控件事件的链接。</value>
    <remarks> 
      连接到控件事件的链接。通过链接，您可以检索有关控件事件的其他信息，例如： 
      <code language="X#">
        cCaption      := oControlEvent:HyperLabel:Caption
        cDescription  := oControlEvent:HyperLabel:Description
        cHelpContext  := oControlEvent:HyperLabel:HelpContext
      </code>
    </remarks>
  </ControlEvent.HyperLabel>

  <ControlEvent.Name>
    <summary>
      表示生成事件的控件名称的字符串。
    </summary>
    <value>表示生成事件的控件名称的字符串。</value>
    <remarks>
      表示生成事件的控件名称的字符串。不要将名称与标题混淆：名称是程序员的 ID，用户永远不会看到。
    </remarks>
  </ControlEvent.Name>

  <ControlEvent.NameSym>
    <summary>
      表示生成事件的控件名称的符号。
    </summary>
    <value>表示生成事件的控件名称的符号。</value>
    <remarks>
      表示生成事件的控件名称的符号。不要将名称与标题混淆：名称是程序员的 ID，用户永远不会看到。
    </remarks>
  </ControlEvent.NameSym>

  <ControlFocusChangeEvent>
    <summary>
      提供有关 ControlFocusChangeEvent 的信息，当控件获得或失去键盘焦点时生成。
    </summary>
  </ControlFocusChangeEvent>

  <ControlFocusChangeEvent.ctor>
    <inheritdoc />
  </ControlFocusChangeEvent.ctor>

  <ControlFocusChangeEvent.Control>
    <summary>
      生成此控件事件的控件。
    </summary>
    <value>生成此控件事件的控件。</value>
    <remarks> 
      生成此控件事件的控件。 
      <note type="tip">
        如果生成控件事件的控件未创建为系统控件，则此值为 NIL。<br />
        如果在资源实体中指定了对话窗口，但未在系统中注册(即窗口不属于 DialogWindow 类)，则会发生这种情况。
      </note>
    </remarks>
  </ControlFocusChangeEvent.Control>

  <ControlNotifyEvent>
    <summary>
      提供有关控件通知事件的信息，当控件需要通知其父窗口某个事件时生成。
    </summary>
    <remarks>
      许多控件会生成通知事件，这些事件会发送到其父窗口，以便父窗口可以采取一些操作。<br />
      通知以 ControlNotify 事件处理程序的形式发送给父窗口。此事件通常被子类化，以便控件可以发送特定于控件和通知的事件对象。
      在这种情况下，还会调用父窗口中的更具体的事件处理程序。
    </remarks>
  </ControlNotifyEvent>

  <ControlNotifyEvent.ctor>
    <inheritdoc />
  </ControlNotifyEvent.ctor>

  <ControlNotifyEvent.Control>
    <summary>
      生成此事件的控件对象。
    </summary>
    <value>生成此事件的控件对象。</value>
  </ControlNotifyEvent.Control>

  <ControlNotifyEvent.NotifyCode>
    <summary>
      由 Windows API 定义的此事件的通知代码。
    </summary>
    <value>由 Windows API 定义的此事件的通知代码。</value>
    <remarks> 
      由 Windows API 定义的此事件的通知代码。
      通知代码的值取决于控件的类型和事件。<br />
      有关更多详细信息，请参阅 Microsoft Win32 软件开发工具包文档。 
      <note type="tip"> 
        ControlNotifyEvent:NotifyCode 访问返回一个 DWORD 变量。 <br />
        Windows SDK 中的 NotifyCode 值通常定义为： 
        <code language="X#">
          DEFINE TVN_KEYDOWN  := (TVN_FIRST-12)
          DEFINE TVN_FIRST    := (0U-400U)
        </code>
        在 X# 的早期版本中，TVN_KEYDOWN 编译为值为 -412 的 LONG。大多数其他开发环境将这些定义视为 DWORD(无符号)，
        因为 TVN_FIRST 的定义中包含一个或多个无符号常量。 
        不幸的是，X# 中存在一个小问题： USUAL 变量只能包含 LONG 或 FLOAT 数字，而不能包含 DWORD。 
        这意味着如果您晚绑定调用 ControlNotifyEvent:NotifyCode，您将收到一个 USUAL，因此是一个 LONG。 
        因此，如果 NotifyCode 是 TVN_KEYDOWN，则 USUAL 将具有 -412 的 LONG 值。 
        因此，我们强烈建议将事件对象存储在类型本地。这确保您将获得正确的数字类型： 
        <code language="X#">
          METHOD ControlNotify(oControlNotifyEvent) CLASS HelpAbout
              LOCAL oControl AS Control
              LOCAL oCNEvent AS ControlNotifyEvent

              oCNEvent := oControlNotifyEvent
              oControl := IIF(oCNEvent == NULL_OBJECT, NULL_OBJECT, oCNEvent:Control)

              SUPER:ControlNotify(oControlEvent)

              IF oCNEvent:NotifyCode == TVN_KEYDOWN
                  // 执行您想要的操作
              ENDIF

              RETURN NIL
        </code>
      </note>
    </remarks>
  </ControlNotifyEvent.NotifyCode>

  <ControlWindow>
    <summary>
      创建作为窗口层次结构一部分的控件，从而允许使用事件处理程序自定义控件的行为。
    </summary>
    <remarks>
      当控件作为窗口层次结构的一部分创建时，它可以捕获事件。
      例如，您可能希望自定义控件的外观(如更改背景和前景颜色)或修改其默认的键处理。<br />
      通过 ControlWindow 类操作控件比通过 Control 的子类创建的控件需要更多的开销。
      因此，建议仅在需要特殊处理的情况下使用控件窗口(例如，覆盖某些事件的处理或在控件上调用某些窗口方法)。
    </remarks>
  </ControlWindow>

  <ControlWindow.ctor>
    <summary>
      从现有控件构造控件窗口。
    </summary>
    <param name="oControl">应用于初始化控件窗口的控件。它应该是 Control 的任何子类的实例。</param>
    <remarks>
      用于初始化控件窗口的控件在控件窗口销毁时会自动销毁。
    </remarks>
    <example> 
      以下示例构造了一个具有与按钮相同属性的控件窗口： 
      <code language="X#">
        CLASS PbWindow INHERIT ControlWindow
            METHOD Init(oWOwner,nResourceID) CLASS PbWindow
                LOCAL oPB AS OBJECT
                oPB := PushButton{oOwner,nResourceID}
                SUPER:Init(oPB)
      </code>
    </example>
  </ControlWindow.ctor>

  <ControlWindow.Control>
    <summary>
      控件窗口所基于的控件。
    </summary>
    <value>控件窗口所基于的控件。</value>
    <remarks>
      控件窗口所基于的控件。此信息允许您使用控件窗口的继承方法，以便您可以使用其内置服务。
    </remarks>
  </ControlWindow.Control>

  <ControlWindow.ControlID>
    <summary>
      表示控件窗口所基于的控件的唯一 ID 的 1 到 8000 之间的数字。
    </summary>
    <value>表示控件窗口所基于的控件的唯一 ID 的 1 到 8000 之间的数字。</value>
    <remarks>
      表示控件窗口所基于的控件的唯一 ID 的 1 到 8000 之间的数字。<br />
      每个控件都有自己的唯一 ID，以将其与其他控件区分开来(使所有者窗口能够确定哪个控件生成了事件)。
    </remarks>
  </ControlWindow.ControlID>

  <ControlWindow.Default>
    <inheritdoc />
  </ControlWindow.Default>

  <ControlWindow.Destroy>
    <summary>
      释放为 ControlWindow 对象及其派生对象分配的内存资源。
    </summary>
    <remarks>
      此方法立即释放在应用程序中显式创建的 ControlWindow 对象的资源。<br />
      ControlWindow:Destroy() 还负责分配给派生类的资源，并按必要的顺序释放它们。
    </remarks>
  </ControlWindow.Destroy>

  <ControlWindow.Disable>
    <summary>
      禁用控件窗口及其关联的控件(直到后续调用 ControlWindow:Enable())。
    </summary>
    <remarks>
      禁用的控件不活动(例如，按钮无法点击，数据控件无法修改)，因此它们不会向其所有者窗口发送事件。<br />
      请注意，在 Windows 下，禁用的控件是灰显的。
    </remarks>
  </ControlWindow.Disable>

  <ControlWindow.Dispatch>
    <inheritdoc />
  </ControlWindow.Dispatch>

  <ControlWindow.Enable>
    <summary>
      启用先前已禁用的控件窗口。
    </summary>
    <remarks>
      启用控件窗口允许它生成事件，并在用户操作控件窗口时将事件发送到其所有者窗口。<br />
      禁用控件窗口的灰显效果被移除，控件窗口恢复到其正常外观。<br />
      默认情况下，控件窗口在禁用之前是启用的，因此除非先前调用了 ControlWindow:Disable()，否则无需调用此 Enable() 方法。
    </remarks>
  </ControlWindow.Enable>

  <ControlWindow.Hide>
    <summary>
      隐藏控件窗口及其关联的控件，使其不可见(直到后续调用 ControlWindow:Show())。
    </summary>
  </ControlWindow.Hide>

  <ControlWindow.HyperLabel>
    <summary>
      连接到控件窗口所基于的控件的链接。
    </summary>
    <value>连接到控件窗口所基于的控件的链接。</value>
    <remarks>
      连接到控件窗口所基于的控件的链接。通过链接，您可以检索有关控件的其他信息：
    </remarks>
    <example>
      <code language="X#">
        cCaption      := oControlWindow:HyperLabel:Caption
        cDescription  := oControlWindow:HyperLabel:Description
        cHelpContext  := oControlWindow:HyperLabel:HelpContext
      </code>
    </example>
  </ControlWindow.HyperLabel>

  <ControlWindow.Modified>
    <summary>
      表示控件窗口所基于的控件自上次设置以来是否已被用户更改的逻辑值。
    </summary>
    <value>表示控件窗口所基于的控件自上次设置以来是否已被用户更改的逻辑值。</value>
    <remarks>
      表示控件窗口所基于的控件自上次设置以来是否已被用户更改的逻辑值。<br />
      TRUE 表示控件已更改(即使尚未验证或验证失败)；FALSE 表示未更改。
    </remarks>
  </ControlWindow.Modified>

  <ControlWindow.Origin>
    <summary>
      表示控件窗口在其所有者窗口上的位置的点，以画布坐标表示。
    </summary>
    <value>表示控件窗口在其所有者窗口上的位置的点，以画布坐标表示。</value>
  </ControlWindow.Origin>

  <ControlWindow.Override>
    <summary>这是一个不再使用或需要的兼容性方法。</summary>
  </ControlWindow.Override>

  <ControlWindow.SetFocus>
    <summary>
      将输入焦点传递给控件窗口，从而将所有鼠标和键盘输入定向到其关联的控件。
    </summary>
  </ControlWindow.SetFocus>

  <ControlWindow.Size>
    <summary>
      表示控件窗口大小的尺寸。
    </summary>
    <value>表示控件窗口大小的尺寸。</value>
  </ControlWindow.Size>

  <CurHand>
    <exclude />
  </CurHand>

  <CurHand.ctor>
    <exclude />
  </CurHand.ctor>

  <Cursor>
    <summary>
      创建一个文本光标，用于在窗口中可视化表示下一个文本出现的位置。
    </summary>
    <remarks> 
      默认光标是一个I形光标，您也可以使用位图创建光标。 <br />
      请注意，一个窗口一次只能有一个光标。系统会自动在窗口之间管理光标。 
      <note type="tip">
        不适用于DialogWindows或DataWindows。<br />
        提示：在X#中，Cursor类对应于文本光标；使用Pointer类创建鼠标光标。
      </note>
    </remarks>
    <example> 
      此示例在焦点更改期间创建一个光标： 
      <code language="X#">
        METHOD FocusChange(oEvent) CLASS MyWindow
            IF oEvent:GotFocus
                oCursorText := Cursor{SELF,Dimension{20, 20}}
                oCursorText:Position := Point{40, 40}
                oCursorText:Show()
                ...
            ENDIF
      </code>
    </example>
  </Cursor>

  <Cursor.ctor>
    <summary>
      构造一个光标。
    </summary>
    <param name="oOwner">拥有光标的窗口。</param>
    <param name="oObject">光标的尺寸(以画布坐标表示)或用于描绘光标的位图。</param>
    <param name="lDimmed">TRUE 创建半透明(暗淡)的光标；FALSE 创建黑色光标。默认值为 TRUE。</param>
  </Cursor.ctor>

  <Cursor.Destroy>
    <summary>
      提供一种方法来销毁光标对象。
    </summary>
    <remarks>
      当不再需要光标对象时，可以使用此方法。Cursor:Destroy() 销毁光标对象，并允许您关闭和释放对象打开或创建的任何资源，而无需等待垃圾收集器。
    </remarks>
  </Cursor.Destroy>

  <Cursor.Handle>
    <summary>
      返回光标的句柄。
    </summary>
    <param name="nHandleType"> 所需句柄的类型。0是唯一支持的选项，如果省略<paramref name="nHandle" />，则为默认值。 </param>
    <returns>
      描述底层系统对象的句柄。
    </returns>
    <remarks>
      此方法提供 Windows GDI 对象的句柄，然后可以由 Windows API GDI 调用使用。
    </remarks>
  </Cursor.Handle>

  <Cursor.Hide>
    <summary>
      隐藏光标，使其不可见(直到后续调用Cursor:Show())。
    </summary>
  </Cursor.Hide>

  <Cursor.Position>
    <summary>
      表示光标当前位置的点(以所有者窗口画布坐标表示)。
    </summary>
    <value>表示光标当前位置的点(以所有者窗口画布坐标表示)。</value>
  </Cursor.Position>
  
  <Cursor.Show>
    <summary>
      显示光标，使其可见。
    </summary>
    <remarks>
      您必须始终显式调用 Show() 来显示光标。Cursor:Show() 通常也用于重新显示使用 Cursor:Hide() 方法隐藏的光标。
    </remarks>
  </Cursor.Show>

  <CustomControl>
    <summary>
      提供一个自定义控件基类，从中派生专门的自定义控件。
    </summary>
    <remarks>
      CustomControl 类注册其自己的窗口类，并可用作自定义和所有者绘制控件的基础。<br />
      CustomControl 类可通过窗口编辑器的工具调色板使用。<br />
      自定义控件是一个空的子窗口，可以用作任何窗口表面上的控件。
      普通的自定义控件没有任何内置功能，因此通常需要派生自己的自定义控件类并实现特定行为。
      此外，由于自定义控件仅实现一个空的子窗口，您应实现自己的Expose()处理程序以支持控件的所有者绘制表面。
    </remarks>
  </CustomControl>

  <CustomControl.ctor>
    <summary>
      构造一个自定义控件。
    </summary>
    <param name="oOwner">拥有自定义控件的窗口。</param>
    <param name="xID">自定义控件的唯一ID(介于1和8000之间)。</param>
    <param name="oPoint">自定义控件在画布坐标中的原点。</param>
    <param name="oDimension">自定义控件在画布坐标中的尺寸。</param>
    <param name="kStyle">表示自定义控件样式的常量，指定为 X# 样式常量或 Windows API 样式常量。样式可以使用 _Or() 运算符组合。</param>
    <param name="lDataAware">指示自定义控件是否数据感知(TRUE)或否(FALSE)的逻辑值。默认值为 FALSE。</param>
    <param name="nResourceID">自定义控件的资源ID。</param>
    <remarks>
      <note type="tip">
        请参阅 Microsoft Win32 软件开发工具包文档，了解有关特定 Windows API 常量的详细信息。
      </note>
    </remarks>
  </CustomControl.ctor>

  <DataBrowser>
    <summary>
      创建一个数据浏览器，它是一个类似电子表格的表，用于显示来自数据服务器的信息。
    </summary>
    <remarks>
      数据浏览器是一种控件，如复选框或编辑字段。然而，它通常不应作为独立控件创建；使用数据浏览器的最简单方法是将数据窗口切换到浏览视图。
      这会创建DataBrowser对象；可以通过数据窗口的Browser属性引用它。<br /><br />

      数据浏览器是数据感知的，类似于窗口，并且可以作为客户端连接到数据服务器。<br />
      它表现出与数据窗口相同的行为：将数据传播到服务器，并响应服务器发送给其客户端的所有通知消息。<br /><br />

      将浏览器作为控件与其他控件一起放置在窗口上的最简单方法是将另一个数据窗口作为嵌套子表单放置；请参阅 DataWindow 类的描述。
      这可以通过窗口编辑器使用编辑插入菜单命令或自动布局功能轻松完成。<br /> 
      有关详细信息，请参阅您的IDE用户指南中的“使用窗口编辑器”。
      <note type="tip">
        在此版本的X#中，包含 DataBrowser 和 SplitWindow 功能的 CATO3*.DLL 文件的静态依赖项已被移除。
        不使用数据浏览器和/或拆分窗口的应用程序不再需要这些.DLL文件。
        这导致更小的内存占用、更快的应用程序启动和更小的安装包。
      </note>
      数据浏览器以类似电子表格的表格形式呈现信息，具有行和列。 <br />
      列是DataColumn对象。数据列对应于数据服务器中的字段——每个数据列都链接到一个服务器字段(就像数据窗口上的数据控件一样)。
      行对应于服务器中的记录。<br /><br />

      与常规数据窗口不同，常规数据窗口一次只显示一条记录——“当前”记录——浏览器将多条记录显示为表格中的行。
      它始终保持一行作为“当前”行，即服务所在的记录。对数据和操作方法的引用始终指的是“当前”记录，就像在常规数据窗口中一样。
      因此，唯一的区别是视觉上的，因为浏览器显示了除当前记录之外的记录。<br /><br />
      
      用户和开发人员在数据浏览器的视觉布局上有很大的灵活性。<br />
      列可以由用户使用鼠标(除非开发人员禁用这些选项)或在程序控制下动态调整大小和重新排列。<br />
      为了在列重新排列后保持对列内容的有意义控制，列通过其名称进行标识。<br />
      如果需要使用数字进行引用(如在对其数据一无所知的通用实用程序程序中)，则可以通过其在浏览器中的原始位置编号引用列，这可能与其视觉位置相同或不同。
    </remarks>
  </DataBrowser>

  <DataBrowser.ctor>
    <summary>
      构造一个数据浏览器。
    </summary>
    <param name="oOwner">拥有数据浏览器的窗口。</param>
    <param name="xID">数据浏览器的唯一ID(介于1和8000之间)。</param>
    <param name="oPoint">数据浏览器在画布坐标中的原点。如果未指定，则使用(0,0)。</param>
    <param name="oDimension"> 数据浏览器在画布坐标中的尺寸。如果未指定，则使用 <paramref name="oOwner" /> 的大小。 </param>
    <param name="nResourceID">数据浏览器的资源ID。</param>
    <remarks>
      当所有者窗口是 DataWindow 对象时，数据浏览器占据数据窗口框架窗口的全部大小，并随着数据窗口大小的变化而变化。
    </remarks>
  </DataBrowser.ctor>

  <DataBrowser.AddColumn>
    <summary>
      向数据浏览器添加一个或多个列。
    </summary>
    <param name="oGColumn">要添加的数据列或要添加的数据列数组。</param>
    <param name="nIndex">
      新列将插入到其后的列。此值可以是表示列名称的字符串或符号，表示其列号的数字，或标识列的oDataColumn对象。<br />
      如果指定数字，请注意列编号从1开始(指的是逻辑顺序中的第一列，不一定是从视觉角度看最左边的列)。<br />
      如果省略，则在最后一列之后添加新列。
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      当列插入到序列中间时，任何后续列的参考编号将递增。这是列应通过名称而不是编号引用的原因之一。<br />
      此外，请注意，虽然列可以从视觉角度重新定位，但它们在浏览器中的逻辑位置保持不变。
    </remarks>
  </DataBrowser.AddColumn>

  <DataBrowser.AsString>
    <summary>
      返回数据浏览器的标识标签。
    </summary>
  </DataBrowser.AsString>

  <DataBrowser.Background>
    <summary>
      用于绘制此数据浏览器背景的画刷。
    </summary>
    <value>用于绘制此数据浏览器背景的画刷。</value>
  </DataBrowser.Background>

  <DataBrowser.CanUndo>
    <summary>
      确定是否可以撤消对数据浏览器列的最近更改(使用DataBrowser:Undo())。
    </summary>
    <returns>
      如果操作可以撤消，则为 TRUE；否则为 FALSE。
    </returns>
  </DataBrowser.CanUndo>

  <DataBrowser.Caption>
    <summary>
      表示数据浏览器标题栏中使用的标题的字符串。
    </summary>
    <value>表示数据浏览器标题栏中使用的标题的字符串。</value>
    <remarks>
      表示数据浏览器标题栏中使用的标题的字符串。默认情况下，数据浏览器使用其链接中定义的标题。<br />
      分配空白标题(" ")会导致标题栏显示无文本。分配 NULL_STRING 会导致标题栏隐藏。<br />
      请注意，通过在标题字符串中嵌入换行符(Chr(10))，标题栏会更改高度以适应多行。
    </remarks>
  </DataBrowser.Caption>

  <DataBrowser.CellDoubleClick>
    <summary>
      提供一个事件处理程序，当用户在数据浏览器中的单元格中双击时调用。
    </summary>
    <remarks>
      与所有事件处理程序一样，此方法由系统自动调用。<br />
      开发人员可以重写此方法以自定义对该事件的响应：标准响应是将单元格切换到编辑模式并选择整个内容。<br />
      此外，单元格允许立即编辑，接受第一个击键作为新单元格内容。
    </remarks>
  </DataBrowser.CellDoubleClick>

  <DataBrowser.CellEdit>
    <summary>
      当DataBrowser处于编辑模式时，返回当前单元格的编辑控件。否则返回 NULL_OBJECT。
    </summary>
    <value>当DataBrowser处于编辑模式时，返回当前单元格的编辑控件。否则返回 NULL_OBJECT。</value>
  </DataBrowser.CellEdit>

  <DataBrowser.ChangeBackground>
    <summary>
      设置此数据浏览器的新背景画刷。
    </summary>
    <param name="oBrush">要使用的新背景画刷。</param>
    <param name="kWhere">
      指定应重新绘制浏览器的哪个部分，指定为以下常量之一：
    </param>
    <remarks> 
      指定应重新绘制浏览器的哪个部分，指定为以下常量之一： 
      <include file="Gui.xml" path="doc/Where/*" />
      可以为数据浏览器的不同部分设置背景颜色，但不能为单个列设置背景颜色。<br />
      要为单个列设置背景画刷，请使用 DataColumn:ChangeBackground()。<br />
      通常，初始设置从环境的标准设置中获取——在 Windows 下，颜色在控制面板中设置。<br />
      请注意，虽然可以更改标题和列标题区域的颜色，但在使用三维雕刻的“按钮外观”时不推荐这样做——如果按钮看起来不像按钮，最终用户可能会感到困惑。
    </remarks>
    <example> 
      要将文本区域的背景设置为黄色，将高亮文本设置为蓝色： 
      <code language="X#">
        oDataBrowser:ChangeBackground(Brush{Color{COLORYELLOW}},GBLTEXT)
        oDataBrowser:ChangeBackground(Brush{Color{COLORBLUE}},  GBLHITEXT)
      </code>
    </example>
  </DataBrowser.ChangeBackground>

  <DataBrowser.ChangeFont>
    <summary>
      在数据浏览器的特定区域设置新字体。
    </summary>
    <param name="oFont">要使用的新字体。</param>
    <param name="kWhere"> 
      指定应更改浏览器的哪个部分，指定为以下常量之一： <include file="Gui.xml" path="doc/Where/*" />
    </param>
    <returns>
      先前分配给更改区域的字体。
    </returns>
    <remarks>
      可以为数据浏览器的不同部分设置字体，但不能为单个列设置字体。最初，默认字体从浏览器的所有者窗口中提取。
    </remarks>
    <example> 
      要在文本区域使用 Helvetica 类型的字体，并在列标题区域使用相同字体的粗体版本： 
      <code language="X#">
        oDataBrowser:ChangeFont(Font{FONTSWISS8}, GBLTEXT)
        oDataBrowser:ChangeFont(Font{FONTROMAN14},GBLCOLCAPTION)
      </code>
    </example>
  </DataBrowser.ChangeFont>

  <DataBrowser.ChangeTextColor>
    <summary>
      在数据浏览器的特定区域设置新颜色。
    </summary>
    <param name="oColor">要使用的新颜色。</param>
    <param name="kColor">要使用的标准颜色，指定为下表中的常量之一</param>
    <param name="kWhere">指定应更改浏览器的哪个部分，指定为下表中的常量之一</param>
    <returns>
      先前分配给更改区域的颜色。
    </returns>
    <remarks> 
      kColor的值 
      <include file="Gui.xml" path="doc/Colors/*" /> 
      kWhere的值 
      <include file="Gui.xml" path="doc/Where/*" />
      可以为数据浏览器的不同部分设置文本颜色，但不能为单个列设置颜色。<br />
      要为单个列设置颜色，请使用 DataColumn:ChangeTextColor()。<br />
      通常，初始设置从环境的标准设置中获取——在Windows下，颜色在控制面板中设置。 
    </remarks>
    <example> 
      要将主区域的文本颜色设置为蓝色，将高亮文本设置为红色： 
      <code language="X#">
        oDataBrowser:ChangeTextColor (Color{COLORBLUE}, GBLTEXT)
        oDataBrowser:ChangeTextColor (Color{COLORRED},  GBLHITEXT)
      </code>
    </example>
  </DataBrowser.ChangeTextColor>

  <DataBrowser.Clear>
    <summary>
      如果数据浏览器中选择了一个或多个单元格，则清除其内容；如果仅选择了单元格中的某些字符，则仅删除这些字符。
    </summary>
    <remarks> 
      当前选择可以是单元格中的几个字符、整个单元格的内容、多个单元格、多个记录或根本没有选择。 
      <note type="tip">
        如果选择了多个记录，则不允许 Clear()。
      </note>
      请注意，此方法会更改此数据浏览器的单元格链接的字段，因此更改需要验证。操作将单元格留空，但必填字段或其他验证规则可能会将记录标记为无效。
      此方法执行的操作与标准 GUI 应用程序中通常由编辑清除菜单命令执行的操作相同(请注意，在 Windows 下，此菜单命令通常链接到 Delete 键)。
      X# 自动提供此标准行为，因此无需提供特殊方法(实际上，即使没有菜单命令，Delete 键也能工作)。
      像电子表格这样的系统(提供清除和删除操作)将Delete键链接到编辑清除菜单命令，而不是编辑删除菜单命令。
      <note type="tip">
        不要将清除与删除混淆。清除结构(如单元格或字段)会删除其内容。另一方面，删除结构会删除实际结构。
      </note>
    </remarks>
  </DataBrowser.Clear>

  <DataBrowser.ColPos>
    <summary>
      返回当前聚焦列的位置。
    </summary>
  </DataBrowser.ColPos>

  <DataBrowser.ColumnCount>
    <summary>
      表示数据浏览器中列数的数值。
    </summary>
    <value>数据浏览器中列数的数值。</value>
  </DataBrowser.ColumnCount>

  <DataBrowser.ColumnFocusChange>
    <summary>
      当列焦点发生变化时，提供一个被调用的方法。
    </summary>
    <param name="oDataColumn">正在获得或失去焦点的列。</param>
    <param name="lHasFocus">TRUE 表示列正在获得焦点；FALSE 表示列正在失去焦点。</param>
    <remarks>
      当列焦点发生变化(即，用户从一个列移动到另一个列)时，通常会生成两个事件，因此 ColumnFocusChange() 会被调用两次。<br />
      第一个事件是为了前一个列失去焦点，<br />
      第二个事件是为了新列获得焦点。<br />
      您可以通过检查 <paramref name="lHasFocus" /> 的值来捕获任一事件。 
    </remarks>
    <example> 
      以下代码演示了如何使用 ColumnFocusChange 处理程序： 
      <code language="X#">
        CLASS MyDataBrowser INHERIT DATABROWSER
            METHOD ColumnFocusChange(oDataColumn, lHasFocus) CLASS MyDataBrowser
                SUPER:FocusChange(oDataColumn, lHasFocus)

                IF lHasFocus
                    TextBox{ SELF, oDataColumn:Name, "获得焦点"}:Show()
                ELSE
                    TextBox{ SELF, oDataColumn:Name, "失去焦点"}:Show()
                ENDIF

                RETURN SELF
      </code>
    </example>
  </DataBrowser.ColumnFocusChange>

  <DataBrowser.ColumnMoved>
    <summary>
      当列移动时，提供一个被调用的方法。
    </summary>
    <param name="oColumn">被移动的列。</param>
  </DataBrowser.ColumnMoved>

  <DataBrowser.ColumnReSize>
    <summary>
      当列调整大小时，提供一个被调用的方法。
    </summary>
    <param name="oColumn">被调整大小的列。</param>
  </DataBrowser.ColumnReSize>

  <DataBrowser.Copy>
    <summary>
      将数据浏览器中的当前选择复制到剪贴板。
    </summary>
    <remarks>
      当前选择可以是单元格中的几个字符、整个单元格的内容、多个单元格、多个记录或根本没有选择。<br />
      如果选择了多个单元格，它们将以电子表格和文字处理器产品接受的标准制表符分隔格式复制到剪贴板。
      此方法执行的操作与标准 GUI 应用程序中通常由编辑复制菜单命令执行的操作相同(请注意，在 Windows 下，此菜单命令通常链接到 Ctrl+C 和/或 Ctrl+Insert 加速器)。
      X#自动提供此标准行为，因此无需提供特殊方法(实际上，即使没有菜单命令，加速器也能工作)。
    </remarks>
  </DataBrowser.Copy>

  <DataBrowser.CurrentColumn>
    <summary>
      数据浏览器中的当前数据列(即，包含光标的列)。
    </summary>
    <value>数据浏览器中的当前数据列(即，包含光标的列)。</value>
  </DataBrowser.CurrentColumn>

  <DataBrowser.Cut>
    <summary>
      将数据浏览器中的当前选择剪切到剪贴板。
    </summary>
    <remarks>
      当前选择可以是单元格中的几个字符、整个单元格的内容、多个单元格、多个记录或根本没有选择。<br />
      如果选择了多个单元格，它们将以电子表格和文字处理器产品接受的标准制表符分隔格式剪切到剪贴板。 <br />
      <note type="tip">
        如果选择了多个记录，则不允许Cut()。
      </note>
      请注意，此方法会更改此数据浏览器的单元格链接的字段，因此更改需要验证。操作将单元格留空，但必填字段或其他验证规则可能会将记录标记为无效。
      此方法执行的操作与标准GUI应用程序中通常由编辑剪切菜单命令执行的操作相同(请注意，在Windows下，此菜单命令通常链接到Ctrl+X和/或Shift+Insert加速器)。
      X#自动提供此标准行为，因此无需提供特殊方法(实际上，即使没有菜单命令，加速器也能工作)。
      </remarks>
  </DataBrowser.Cut>

  <DataBrowser.Default>
    <inheritdoc />
  </DataBrowser.Default>

  <DataBrowser.Destroy>
    <summary>
      提供一个方法来取消实例化 DataBrowser 对象。
    </summary>
    <remarks>
      当不再需要 DataBrowser 对象时，可以使用此方法。<br />
      DataBrowser:Destroy() 取消实例化 DataBrowser 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </DataBrowser.Destroy>

  <DataBrowser.Disable>
    <summary>
      禁用数据浏览器(直到后续调用 DataBrowser:Enable())。
    </summary>
    <remarks>
      禁用的数据浏览器不活动，因此它们不会向其所有者窗口发送事件或接收输入焦点。<br />
      请注意，禁用的数据浏览器会变暗。
    </remarks>
  </DataBrowser.Disable>

  <DataBrowser.Dispatch>
    <inheritdoc />
  </DataBrowser.Dispatch>

  <DataBrowser.EditFont>
    <summary>
      返回 DataBrowser 的编辑字体。可以使用 ChangeFont() 方法更改此字体。
    </summary>
    <value>DataBrowser 的编辑字体。可以使用 ChangeFont() 方法更改此字体。</value>
  </DataBrowser.EditFont>

  <DataBrowser.Enable>
    <summary>
      启用先前禁用的数据浏览器。
    </summary>
    <remarks>
      启用数据浏览器允许它生成事件，并在用户操作数据浏览器时将事件发送到其所有者窗口。<br />
      它还允许数据浏览器接收输入焦点。<br />
      禁用的数据浏览器的变暗效果消失，数据浏览器恢复到正常外观。<br />
      默认情况下，数据浏览器在禁用之前是启用的，因此除非之前调用了 DataBrowser:Disable()，否则不需要调用此 Enable() 方法。
    </remarks>
  </DataBrowser.Enable>

  <DataBrowser.EnableBorder>
    <summary>
      指定数据浏览器的边框样式。
    </summary>
    <param name="kBorderType">
      数据浏览器窗口边框的显示样式，指定为下表中的常量之一
    </param>
    <remarks>
      kBorderType 的值
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>BTNOBORDER</term>
          <description>无边框。</description>
        </item>
        <item>
          <term>BTNONSIZINGBORDER</term>
          <description>不允许调整大小的单线边框。</description>
        </item>
        <item>
          <term>BTSIZINGBORDER</term>
          <description>允许调整大小的边框。这是默认值。</description>
        </item>
      </list>
      当数据浏览器作为数据窗口的浏览视图时启用自动调整大小时，数据浏览器不应该有边框，因为窗口提供了调整大小的边框。<br />
      当数据浏览器作为常规控件时，通常使用非调整大小的边框。 
    </remarks>
  </DataBrowser.EnableBorder>

  <DataBrowser.EnableColumnMove>
    <summary>
      启用/禁用用户是否可以使用鼠标移动(重新排列)数据浏览器中的列。如果未调用此方法，将默认启用列移动功能。
    </summary>
    <param name="lAllowMove">TRUE 允许列移动；FALSE 禁用列移动。默认值为 TRUE。</param>
    <remarks>
      用户可以通过简单地用鼠标拖动列的标题区域来重新排列列。为了从程序中引用，列保留其原始编号，而不管视觉位置。<br />
      列移动在两个级别上启用/禁用：DataBrowser 类级别和 DataColumn 类级别。<br />
      如果在浏览器级别设置了列移动，可以使用 DataBrowser:EnableColumnMove() 来启用/禁用移动。
      但是，如果在列级别启用了列移动，就不能再使用此方法。
      必须使用 DataColumn:EnableColumnMove() 来更改设置。
    </remarks>
  </DataBrowser.EnableColumnMove>

  <DataBrowser.EnableColumnReSize>
    <summary>
      启用/禁用用户是否可以使用鼠标调整数据浏览器中的列。如果未调用此方法，将默认启用列调整大小功能。
    </summary>
    <param name="lAllowResize">TRUE 允许调整列大小；FALSE 禁用调整列大小。默认值为 TRUE。</param>
    <remarks>
      用户可以通过用鼠标拖动列标题区域的边界来调整列的大小。<br />
      列调整大小在两个级别上启用/禁用：DataBrowser类级别和DataColumn类级别。
      如果在浏览器级别设置了列调整大小，可以使用DataBrowser:EnableColumnResize()来启用/禁用调整大小。
      但是，如果在列级别启用了列调整大小，就不能再使用此方法。
      必须使用DataColumn:EnableColumnResize()来更改设置。
    </remarks>
  </DataBrowser.EnableColumnReSize>

  <DataBrowser.EnableColumnTitles>
    <summary>
      为整个浏览器打开或关闭列标题。
    </summary>
    <param name="lEnable">TRUE 显示列标题；FALSE 隐藏列标题。默认值为 TRUE。 </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      引入此方法是为了替代调用 DataColumn:SetCaption 并使用 NIL 参数，该参数被记录为从列中删除标题区域。<br />
      由于单个列的标题区域不能从单个列中删除，因此必须在整个浏览器中全局执行此操作。
    </remarks>
    <example> 
      以下示例说明了如何使用 DataBrowser:EnableColumnTitles 来抑制通过 Window Editor 生成的源代码创建的子窗体浏览器中的列标题的显示： 
      <code language="X#">
        METHOD Init( oOwner ) CLASS DW_Detail_DataBrowser
            SUPER:Init( oOwner )
            SELF:EnableColumnTitles( FALSE )
            RETURN SELF
      </code>
    </example>
  </DataBrowser.EnableColumnTitles>

  <DataBrowser.EnableGrid>
    <summary>
      启用/禁用网格的显示。如果未调用此方法，将默认启用网格。
    </summary>
    <param name="lShowGrid">TRUE 显示网格；FALSE 隐藏网格。默认值为 TRUE。</param>
  </DataBrowser.EnableGrid>

  <DataBrowser.EnableHorizontalScroll>
    <summary>
      启用/禁用数据浏览器的水平滚动。如果未调用此方法，将默认启用水平滚动。
    </summary>
    <param name="lAllowScroll">TRUE 允许通过在数据浏览器的底部边缘显示水平滚动条来滚动；FALSE 禁用滚动条。默认值为 TRUE。</param>
  </DataBrowser.EnableHorizontalScroll>

  <DataBrowser.EnableHorizontalSplit>
    <summary>
      启用/禁用数据浏览器中的水平分隔条。
    </summary>
    <param name="lShowSplit">
      TRUE 启用(并显示)分隔条；FALSE 禁用(并隐藏)分隔条。默认值为 TRUE。<br />
      如果未为数据浏览器调用此方法，FALSE 是默认值。
    </param>
  </DataBrowser.EnableHorizontalSplit>

  <DataBrowser.EnableVerticalScroll>
    <summary>
      启用/禁用数据浏览器的垂直滚动。如果未调用此方法，将默认启用垂直滚动。
    </summary>
    <param name="lAllowScroll">TRUE 允许通过在数据浏览器的右边缘显示垂直滚动条来滚动；FALSE 禁用滚动条。默认值为 TRUE。</param>
  </DataBrowser.EnableVerticalScroll>

  <DataBrowser.EnableVerticalSplit>
    <summary>
      启用/禁用数据浏览器中的垂直分隔条。
    </summary>
    <param name="lShowSplit">
      TRUE 启用(并显示)分隔条；FALSE 禁用(并隐藏)分隔条。默认值为 TRUE。<br />
      如果未为数据浏览器调用此方法，FALSE 是默认值。
    </param>
    <param name="nMode"> 
      初始分隔条位置，指定为以下常量之一： 
      <include file="Gui.xml" path="doc/SplitBar/*" />
      如果未指定，初始分隔条位置默认为 GBSSBMIDDLE。 
    </param>
    <remarks>
      <include file="Gui.xml" path="doc/SplitBar/*" /> 
      垂直分隔条允许窗口的左右部分独立水平滚动。分隔条在窗口中的位置也可以通过鼠标调整。 
    </remarks>
  </DataBrowser.EnableVerticalSplit>

  <DataBrowser.Error>
    <summary>
      提供一个方法来处理数据浏览器处理过程中引发的错误条件。
    </summary>
    <remarks>
      <note type="tip">
        这是一个事件处理程序，通常由其他方法自动调用；开发人员通常不需要调用 DataBrowser:Error() 方法，但可能需要覆盖它。
      </note>
    </remarks>
    <param name="oErrorObj">描述错误条件的 Error 对象。</param>
  </DataBrowser.Error>

  <DataBrowser.Font>
    <summary>
      用于数据浏览器的文本区域的字体。
    </summary>
    <value>用于数据浏览器的文本区域的字体。</value>
  </DataBrowser.Font>

  <DataBrowser.GetColumn>
    <summary>
      在此数据浏览器中检索指定的列。
    </summary>
    <param name="xColumnID">要检索的列的名称、编号或符号。</param>
    <returns>
      指定的数据列，如果找不到，则为 NIL。
    </returns>
  </DataBrowser.GetColumn>

  <DataBrowser.Handle>
    <summary>
      返回数据浏览器的句柄。
    </summary>
    <returns>
      数据浏览器的句柄，描述底层系统对象。
    </returns>
    <remarks>
      此方法提供了数据浏览器的句柄，然后可以通过 Windows API 调用使用它。
    </remarks>
  </DataBrowser.Handle>

  <DataBrowser.HiBackground>
    <summary>
      返回数据浏览器中突出行和单元格的背景刷。可以使用 ChangeBackground() 方法更改此刷。
    </summary>
    <value>数据浏览器中突出行和单元格的背景刷。可以使用 ChangeBackground() 方法更改此刷。</value>
  </DataBrowser.HiBackground>

  <DataBrowser.Hide>
    <summary>
      隐藏数据浏览器，使其不可见。
    </summary>
    <remarks>
      数据浏览器保持隐藏，直到调用 DataBrowser:Show() 方法。
    </remarks>
  </DataBrowser.Hide>

  <DataBrowser.NewRow>
    <exclude />
  </DataBrowser.NewRow>

  <DataBrowser.Notify>
    <summary>
      一个事件处理程序，用于反映已在与此数据浏览器连接的服务器上发生的事件。
    </summary>
    <returns> 
      除非为 <paramref name="kNotifyName" /> 指定了 NOTIFYINTENTTOMOVE，否则为 NIL。<br />
      在这种情况下，如果成功，返回值为 TRUE；否则，为 FALSE。 
    </returns>
    <include file="VOSDK.xml" path="doc/commonblocks/notify/*" />
  </DataBrowser.Notify>

  <DataBrowser.Origin>
    <summary>
      表示数据浏览器在其所有者窗口上的位置，以画布坐标表示。
    </summary>
    <value>表示数据浏览器在其所有者窗口上的位置，以画布坐标表示。</value>
  </DataBrowser.Origin>

  <DataBrowser.Owner>
    <summary>
      数据浏览器的所有者窗口。
    </summary>
    <value>数据浏览器的所有者窗口。</value>
  </DataBrowser.Owner>

  <DataBrowser.Paste>
    <summary>
      将剪贴板的当前内容粘贴到当前数据浏览器单元格中。
    </summary>
    <remarks> 
      剪贴板数据的粘贴方式取决于以下情况： <br />
      当前选择    当前选择可以是单元格中的几个字符，整个单元格的内容，几个单元格，几个记录，或者根本没有。
      如果选择了几个字符或整个单元格，所选字符将被粘贴数据覆盖。
      请注意，在这种情况下，使用电子表格和文字处理产品通常接受的标准制表符分隔格式，只要选择的形状匹配。
      如果没有选择，剪贴板数据将插入到当前单元格(即，包含光标的单元格)中。
      请注意，数据将在光标之前插入。 
      <note type="tip">
        如果选择了多个记录，不允许使用Paste()。
      </note>
      插入键      请注意，此方法会更改与此数据浏览器的单元格链接的字段，因此，更改将受到验证的影响。
      操作会使单元格变空，但是必填字段或其他验证规则可能会将记录标记为无效。
      此方法执行的操作与标准GUI应用程序中通常由编辑粘贴菜单命令执行的操作相同(请注意，在Windows下，此菜单命令通常与Ctrl+V和/或Shift+Insert加速器链接)。
      这种标准行为由 X# 自动提供，因此不需要为此提供特殊的方法(实际上，即使没有菜单命令，加速器也可以工作)。
      </remarks>
  </DataBrowser.Paste>

  <DataBrowser.Pointer>
    <summary>
      用于在数据浏览器的文本区域中使用的 Pointer 对象。
    </summary>
    <value>用于在数据浏览器的文本区域中使用的 Pointer 对象。</value>
  </DataBrowser.Pointer>

  <DataBrowser.ptrControlDefaultProc>
    <exclude />
  </DataBrowser.ptrControlDefaultProc>

  <DataBrowser.Refresh>
    <summary>
      强制更新数据浏览器的内容，从数据服务器。
    </summary>
  </DataBrowser.Refresh>

  <DataBrowser.RemoveColumn>
    <summary>
      从此数据浏览器中删除一个列。
    </summary>
    <param name="uColumnOrIndex">要删除的列的名称、编号或符号。</param>
    <returns>
      如果成功，返回已删除的数据列；否则，为 NULL_OBJECT。
    </returns>
    <remarks>
      当删除列时，任何后续列的引用编号都会减少。这是为什么应该使用列的名称，而不是编号的一个原因。
    </remarks>
  </DataBrowser.RemoveColumn>

  <DataBrowser.RestoreUpdate>
    <summary>
      更新此数据浏览器的可视化并恢复标准操作(在调用 DataBrowser:SuspendUpdate() 之后)。
    </summary>
    <remarks>
      DataBrowser:SuspendUpdate() 用于在数据浏览器进行多记录更新时减少视觉干扰。<br />
      更新完成后，调用 DataBrowser:RestoreUpdate() 方法以刷新显示并恢复正常操作。<br />
      请注意，DataBrowser:SuspendUpdate() 调用是可堆叠的。
      因此，每次调用 DataBrowser:SuspendUpdate() 时，都必须有对应的 DataBrowser:RestoreUpdate() 调用。
    </remarks>
  </DataBrowser.RestoreUpdate>

  <DataBrowser.RowCount>
    <summary>
      表示数据浏览器中的行数的数值。
    </summary>
    <value>表示数据浏览器中的行数的数值。</value>
  </DataBrowser.RowCount>

  <DataBrowser.SetCaption>
    <summary>
      设置数据浏览器标题栏的标题。
    </summary>
    <param name="cText">要用作标题的文本。 </param>
    <param name="symText">要用作标题的符号。</param>
    <remarks>
      设置空白标题("")会导致标题栏显示没有标题。设置空标题会隐藏标题栏。<br />
      通过在标题字符串中嵌入换行符，标题栏的高度会改变以适应多行。
    </remarks>
  </DataBrowser.SetCaption>

  <DataBrowser.SetColumn>
    <summary>
      用另一个列替换数据浏览器中的现有列。
    </summary>
    <param name="oDataColumn">新的数据列。</param>
    <param name="nColumnNumber">要替换的列。数字必须在数据浏览器中的列范围内；此方法不会在末尾追加列。</param>
    <returns>
      如果成功，返回已替换的数据列；否则，为 NULL_OBJECT。
    </returns>
  </DataBrowser.SetColumn>

  <DataBrowser.SetColumnFocus>
    <summary>
      将列焦点设置为指定的数据列。
    </summary>
    <param name="oColumn">焦点将被设置的列。如果省略，将使用默认值 NULL_OBJECT；焦点不会被更改。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </DataBrowser.SetColumnFocus>

  <DataBrowser.SetPointer>
    <summary>
      设置新的指针，当鼠标移动到数据浏览器的特定区域时使用。
    </summary>
    <param name="oPointer">要使用的新指针。如果未指定，将使用默认指针 POINTERARROW。</param>
    <param name="kWhere">指示应更改浏览器的哪个部分，指定为以下常量之一</param>
    <param name="Constant">描述</param>
    <param name="GBLCAPTION">浏览器标题区域。只有在首先设置浏览器标题后才可见。</param>
    <param name="GBLCOLCAPTION">列标题区域。</param>
    <param name="GBLTEXT">数据显示区域。这是默认值。</param>
  </DataBrowser.SetPointer>

  <DataBrowser.SetStandardStyle>
    <summary>
      设置数据浏览器标题区域的外观。
    </summary>
    <param name="kStyle">要设置的样式，指定为以下常量之一：</param>
    <remarks>
      <note type="tip">
        DataBrowser:SetStandardStyle() 方法可以被 DataColumn:SetStandardStyle() 方法覆盖，用于单独的列。
      </note>
      <include file="Gui.xml" path="doc/BrowseStyle/*" /> 
      如果未指定，默认样式是雕刻的、三维的和“可编辑的”。 提示：要指定多个样式参数，只需进行多次调用。 
      <note type="tip">
        DataBrowserSetStandardStyle() 可以被 DataColumn:SetStandardStyle() 方法覆盖，用于单独的列。
      </note>
    </remarks>
  </DataBrowser.SetStandardStyle>

  <DataBrowser.Show>
    <summary>
      显示此数据浏览器。
    </summary>
    <remarks>
      当首次显示数据浏览器时，它连接的数据服务器可以被遍历以构建其记录缓冲区。<br />
      当数据浏览器遍历服务时，它使用当前服务光标位置获取其第一个记录。应用程序需要在使用数据浏览器之前定位服务。
    </remarks>
  </DataBrowser.Show>

  <DataBrowser.Size>
    <summary>
      表示数据浏览器的大小的维度。
    </summary>
    <value>表示数据浏览器的大小的维度。</value>
  </DataBrowser.Size>

  <DataBrowser.SuspendUpdate>
    <summary>
      在修改数据时临时禁用数据浏览器的重绘；通过调用 DataBrowser:RestoreUpdate() 恢复绘制。
    </summary>
    <remarks>
      此方法用于减少在从数据服务器更新多个记录时数据浏览器的视觉干扰。<br />
      例如，当读取屏幕上的所有数据时，窗口的外观更加流畅和美观。<br />
      完成更新后，调用 DataBrowser:RestoreUpdate() 方法以刷新显示并恢复正常功能。<br />
      注意，DataBrowser:SuspendUpdate() 可以多次调用并堆叠。<br />
      因此，每次调用 DataBrowser:SuspendUpdate() 后，都需要相应地调用 DataBrowser:RestoreUpdate()。
    </remarks>
  </DataBrowser.SuspendUpdate>

  <DataBrowser.TextColor>
    <summary>
      用于数据浏览器的文本区域的文本颜色。
    </summary>
    <value>用于数据浏览器的文本区域的文本颜色。</value>
  </DataBrowser.TextColor>

  <DataBrowser.Undo>
    <summary>
      撤销数据浏览器中一行的最近更改。
    </summary>
    <remarks>
      通常情况下，几乎不需要调用此方法，因为它会自动从数据窗口调用。<br />
      常规撤销操作的键盘界面是由所有对象自动提供的，但是菜单命令和工具栏项也应该在窗口上提供。
    </remarks>
  </DataBrowser.Undo>

  <DataBrowser.Use>
    <summary>
      将数据浏览器连接到客户端-服务器关系中的数据服务器。
    </summary>
    <param name="oServer">
      要将此数据浏览器连接到的数据服务器。<br />
      如果数据浏览器已经连接到服务器，它会首先断开连接。<br />
      如果省略，数据浏览器将从数据服务器断开连接。
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">
        如果浏览器用作数据窗口的浏览视图，那么没有理由使用此方法；浏览器会自动连接到其所属窗口的服务器。
      </note>
      DataBrowser:Use() 方法会根据匹配的名称将浏览器列与数据服务器的字段连接起来。<br />
      任何没有明确提供字段规范和超链接的列都会从其数据服务器字段继承 FieldSpec 和 HyperLabel 对象。
      如果数据浏览器没有任何列，DataBrowser:Use() 方法会自动创建一个包含所有服务器字段的列布局。
      DataBrowser:Use() 还会使用 DataServer:RegisterClient() 方法将数据浏览器注册为服务器的客户端。 
    </remarks>
  </DataBrowser.Use>

  <DataBrowser.Validate>
    <summary>
      确定当前聚焦记录是否有效。
    </summary>
    <returns>
      如果记录有效，返回 TRUE；否则，返回 FALSE。
    </returns>
  </DataBrowser.Validate>

  <DataColumn>
    <summary>
      为在数据浏览器中使用的列创建列。
    </summary>
    <remarks>
      数据列不是一个控件；它是数据浏览器的一个组件。<br />
      但是，从数据管理的角度来看，数据列类似于数据窗口上的控件：当浏览器连接到服务器时，每个列都会链接到一个数据字段。
    </remarks>
  </DataColumn>

  <DataColumn.ctor>
    <summary>
      构造一个数据列。
    </summary>
    <param name="nWidth">在其中显示列的初始宽度，以字符为单位，或者从中提取宽度的 FieldSpec 对象。如果未指定，默认值为16。</param>
    <param name="xColumnID">列的名称或包含列名称和任何可选注释的超链接。</param>
  </DataColumn.ctor>

  <DataColumn.Alignment>
    <summary>
      表示此数据列的对齐方式的以下常量之一：
    </summary>
    <value>表示此数据列的对齐方式的以下常量之一：</value>
    <remarks> 
      表示此数据列的对齐方式的以下常量之一： 
      <include file="Gui.xml" path="doc/Alignment/*" />
    </remarks>
  </DataColumn.Alignment>

  <DataColumn.AsString>
    <summary>
      将当前数据列的当前行的当前值作为格式化字符串返回。
    </summary>
    <param name="uParam">当前数据列的当前行的当前值。 </param>
    <remarks>
      此方法返回的结果与 DataColumn:TextValue 相同。<br />
      AsString()是所有对象提供的标准方法，用于在需要时返回一些合理的文本。
      请注意，此字符串的格式是根据从关联服务器字段继承的 FieldSpec 对象中的图片规范进行格式化的。
    </remarks>
  </DataColumn.AsString>

  <DataColumn.Background>
    <summary>
      用于绘制此数据列的背景的 Brush 对象。
    </summary>
    <value>用于绘制此数据列的背景的 Brush 对象。</value>
  </DataColumn.Background>

  <DataColumn.Block>
    <summary>
      与数据列关联的代码块。如果设置，它将用于过滤数据列的数据。
    </summary>
    <value>与数据列关联的代码块。如果设置，它将用于过滤数据列的数据。</value>
    <example> 
      此示例设置了一个计算的 Wages 列的代码块，其中 HoursWorked 和 HourlyRate 是数据库中的字段。这些行将出现在 DataBrowser:Init() 方法中： 
      <code language="X#">
        oMyColumn:BlockOwner  := SELF:Server // 附加到浏览器的服务器对象
        oMyColumn:Block       := { | oVar | oVar:HoursWorked * oVar:HourlyRate }
        //其中 oVar 是 BlockOwner
      </code>
    </example>
  </DataColumn.Block>

  <DataColumn.BlockOwner>
    <summary>
      与数据列关联的代码块的所有者。如果分配了代码块，当评估代码块时，将调用此对象。<br />
      有关示例，请参见 DataColumn:Block。
    </summary>
    <value>
      与数据列关联的代码块的所有者。如果分配了代码块，当评估代码块时，将调用此对象。<br />
      有关示例，请参见 DataColumn:Block。
    </value>
  </DataColumn.BlockOwner>

  <DataColumn.Caption>
    <summary>
      一个字符串，表示此数据列的标题，用于在其标题区域中使用。
    </summary>
    <value>一个字符串，表示此数据列的标题，用于在其标题区域中使用。</value>
    <remarks>
      一个字符串，表示此数据列的标题，用于在其标题区域中使用。<br />
      默认情况下，数据列使用其超链接中定义的标题。
      您可以以类似于 DataBrowser:Caption 属性的方式指定标题(例如，分配一个空标题("")会导致标题区域显示没有文本的标题)。<br />
      请注意，标题区域的高度会自动调整为足够大，以容纳所有拥有数据浏览器的列的标题。
    </remarks>
  </DataColumn.Caption>

  <DataColumn.CellBackground>
    <summary>
      用于绘制单元格背景的 Brush 对象，如果已调用 DataColumn:EnableCellDraw 。
    </summary>
    <value>用于绘制单元格背景的 Brush 对象，如果已调用 DataColumn:EnableCellDraw 。</value>
    <remarks>
      用于绘制单元格背景的 Brush 对象，如果已调用 DataColumn:EnableCellDraw 。<br />
      此对象不应该是 DataColumn:EnableCellDraw 提供的单元格绘制方法的局部变量。
    </remarks>
  </DataColumn.CellBackground>

  <DataColumn.CellTextColor>
    <summary>
      用于绘制单元格文本的 Color 对象，如果已调用 DataColumn:EnableCellDraw 。
    </summary>
    <value>用于绘制单元格文本的 Color 对象，如果已调用 DataColumn:EnableCellDraw 。</value>
    <remarks>
      用于绘制单元格文本的 Color 对象，如果已调用 DataColumn:EnableCellDraw 。<br />
      此对象不应该是 DataColumn:EnableCellDraw 提供的单元格绘制方法的局部变量。
    </remarks>
  </DataColumn.CellTextColor>

  <DataColumn.ChangeBackground>
    <summary>
      为此数据列设置新的背景刷。
    </summary>
    <param name="oBrush">要使用的新背景刷。</param>
    <param name="kWhere"> 
      指示应该重新绘制数据列的哪个部分，指定为以下常量之一： 
      <include file="Gui.xml" path="doc/Where/*" />
    </param>
    <returns>
      先前分配给更改区域的刷子。
    </returns>
    <remarks>
      此处指定的设置将在此数据列中，对于此数据列的所有者数据浏览器中设置的设置之前。尽管可以指定按钮和标题区域，但该方法仅引用此列。<br />
      通常，初始设置从环境的标准设置中获取——在 Windows 下，颜色在控制面板中设置。<br />
      请注意，虽然可以更改标题和列标题区域的颜色，但当使用三维、雕刻的“按钮外观”时，不建议这样做——如果按钮看起来不像按钮，最终用户可能会感到困惑。
    </remarks>
    <example> 
      要将文本区域的背景设置为黄色，将列标题设置为蓝色： 
      <code language="X#">
        oDataColumn:ChangeBackground(Brush{Color{COLORYELLOW}}, GBLTEXT)
        oDataColumn:ChangeBackground(Brush{Color{COLORBLUE}},   GBLCOLCAPTION)
      </code>
    </example>
  </DataColumn.ChangeBackground>

  <DataColumn.ChangeTextColor>
    <summary>
      在此数据列的特定区域设置新的画笔。
    </summary>
    <param name="oColor">要使用的新颜色。</param>
    <param name="kColor">
      指定要使用的标准颜色，指定为以下常量之一：
    </param>
    <param name="kWhere">
      指定应更改数据列的哪个部分，指定为以下常量之一。
    </param>
    <returns>
      先前分配给更改区域的画笔。
    </returns>
    <remarks> 
      kColor 的可能值 
      <include file="Gui.xml" path="doc/Colors/*" /> 
      kWhere 的可能值 
      <include file="Gui.xml" path="doc/Where/*" /> 
      通常，初始设置从环境的标准设置中获取——在 Windows 下，颜色在控制面板中设置。<br />
      默认值从环境的标准设置中获取；例如，在 Windows 下，按钮的文本颜色是在控制面板中设置的。尽管可以指定按钮和标题区域，但该方法仅引用此列。 
    </remarks>
    <example> 
      要将主区域的文本颜色设置为蓝色，将列标题的文本设置为红色： 
      <code language="X#">
        oDataColumn:ChangeTextColor(Color{COLORBLUE}, GBLTEXT)
        oDataColumn:ChangeTextColor(Color{COLORRED},  GBLCOLCAPTION)
      </code>
    </example>
  </DataColumn.ChangeTextColor>

  <DataColumn.ClearStatus>
    <exclude />
  </DataColumn.ClearStatus>

  <DataColumn.DataField>
    <exclude />
  </DataColumn.DataField>

  <DataColumn.Destroy>
    <summary>
      提供一个方法，用于取消实例化 DataColumn 对象。
    </summary>
    <remarks>
      当不再需要 DataColumn 对象时，可以使用此方法。<br />
      DataColumn:Destroy() 取消实例化 DataColumn 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </DataColumn.Destroy>

  <DataColumn.DisableCellDraw>
    <exclude />
  </DataColumn.DisableCellDraw>

  <DataColumn.DrawCellData>
    <exclude />
  </DataColumn.DrawCellData>

  <DataColumn.EnableCellDraw>
    <summary>
      通过注册单元格绘制方法，启用对单元格的个别绘制。
    </summary>
    <param name="symMethodName">将用于绘制此列中的单元格的方法的符号名称。</param>
    <remarks>
      通过开发人员提供的方法，启用对此列中的单元格的绘制。<br />
      每当要绘制单元格时，都会调用提供的方法。方法会传递单元格的通常值，并且可以使用该值来确定绘制时应使用的文本颜色和背景刷，
      分别通过分配新值给 DataColumn:CellTextColor 和 DataColumn:CellBackground 来实现。
    </remarks>
    <example> 
      以下示例显示了如何使用 DataColumn:EnableCellDraw 来在数据浏览器中突出过期的帐户： 
      <code language="X#">
        CLASS ColorColumn INHERIT DataColumn
            PROTECT oValidTextColor AS Color
            PROTECT oValidBackground AS Brush
            PROTECT oInvalidTextColor AS Color
            PROTECT oInvalidBackground AS Brush

            METHOD Init( oFieldSpec ) CLASS ColorColumn
                SUPER:Init( oFieldSpec )

                oValidTextColor     := Color{ COLORWHITE }
                oValidBackground    := Brush{ Color{ COLORBLUE } }
                oInvalidTextColor   := Color{ COLORYELLOW }
                oInvalidBackground  := Brush{ Color{ COLORRED } }

                RETURN SELF

            METHOD Init( oWindow, iCtlID, oServer ) CLASS ColorSubForm
                // 一些初始化代码
                SELF:Browser := ColorSubForm_Browser{ SELF }

                oDBDUE_DATE             := ColorColumn{ ACCOUNTS_DUE_DATE{} }
                oDBDUE_DATE:Width       := 12
                oDBDUE_DATE:HyperLabel  := oDCDUE_DATE:HyperLabel
                oDBDUE_DATE:Caption     := "DueDate"

                SELF:Browser:AddColumn( oDBDUE_DATE )

                oDBDUE_DATE:EnableCellDraw( #ValidDateDraw )
                // 更多初始化代码
                RETURN SELF

            METHOD ValidDateDraw( uValue ) CLASS ColorColumn
                IF uValue &lt; GetPastDueDate()
                    SELF:CellTextColor  := oValidTextColor
                    SELF:CellBackground := oValidBackground
                ELSE
                    SELF:CellTextColor  := oInvalidTextColor
                    SELF:CellBackground := oInvalidBackground
                ENDIF

                RETURN NIL
      </code>
    </example>
  </DataColumn.EnableCellDraw>

  <DataColumn.EnableColumnMove>
    <summary>
      启用/禁用用户是否可以使用鼠标移动(重新排列)此数据列。如果未调用该方法，其默认行为由拥有此列的数据浏览器确定。
    </summary>
    <param name="lAllowMove">TRUE 允许列移动；FALSE 禁用。默认值为 TRUE。</param>
    <remarks>
      用户可以通过简单地用鼠标拖动列的标题区域来重新排列列。为了从程序中引用，列保留其原始编号，而不管其视觉位置如何。
    </remarks>
  </DataColumn.EnableColumnMove>

  <DataColumn.EnableColumnReSize>
    <summary>
      启用/禁用用户是否可以使用鼠标调整此数据列的大小。如果未调用该方法，其默认行为由拥有此列的数据浏览器确定。
    </summary>
    <param name="lAllowResize">TRUE 允许列调整大小；FALSE 禁用。默认值为 TRUE。</param>
    <remarks>
      用户可以通过在列标题区域的边界上用鼠标拖动来调整列的大小。
    </remarks>
  </DataColumn.EnableColumnReSize>

  <DataColumn.FieldSpec>
    <summary>
      与此数据列连接的 FieldSpec 对象。
    </summary>
    <value>与此数据列连接的 FieldSpec 对象。</value>
    <remarks>
      与此数据列连接的 FieldSpec 对象。这用于验证目的，以及计算默认宽度和对齐特性。
    </remarks>
  </DataColumn.FieldSpec>

  <DataColumn.GetCaption>
    <exclude />
  </DataColumn.GetCaption>

  <DataColumn.GetEditObject>
    <exclude />
  </DataColumn.GetEditObject>

  <DataColumn.GetModified>
    <summary>
      确定列中的值是否已被修改。
    </summary>
    <returns>
      如果列中的值已被修改，则返回 TRUE；否则，返回 FALSE。
    </returns>
  </DataColumn.GetModified>

  <DataColumn.GetValue>
    <summary>
      获取当前数据列的值。
    </summary>
  </DataColumn.GetValue>

  <DataColumn.HyperLabel>
    <summary>
      与此数据列连接的超链接。
    </summary>
    <value>与此数据列连接的超链接。</value>
    <remarks> 
      与此数据列连接的超链接。从超链接中，您可以检索有关数据列的其他信息，例如： 
      <code language="X#">
        cCaption      := oDataColumn:HyperLabel:Caption
        cDescription  := oDataColumn:HyperLabel:Description
        cHelpContext  := oDataColumn:HyperLabel:HelpContext
      </code>
    </remarks>
  </DataColumn.HyperLabel>

  <DataColumn.LinkDF>
    <summary>
      将列连接到数据服务器中的字段。
    </summary>
    <param name="oDataServer">要将列连接到的服务器。通常，这是整个窗口链接的公共服务器，但也可以将单个列链接到其他服务器。</param>
    <param name="nFieldData">服务器内的字段的编号。</param>
    <remarks>
      DataColumn:LinkDF() 通常不应该由应用程序直接调用。它由 DataBrowser:Use() 调用；Use() 将整个客户端连接到整个服务。<br />
      您可以使用 DataColumn:LinkDF() 显式地将列连接到数据字段，也许是因为列的名称与数据字段的名称不匹配，因此 DataBrowser:Use() 的自动连接不起作用。
      甚至可以使用 DataColumn:LinkDF() 将单个列链接到不同的服务器；但是，这不推荐，因为数据窗口的任何自动行为和与数据服务器的任何协作都不适用于多个服务器。<br />
      对于除了窗口注册的主服务之外的服务，将不会收到通知，而且诸如 DataWindow:Delete() 和 DataWindow:Append() 之类的操作只适用于主服务。<br />
      要将窗口链接到多个数据，请使用“程序员指南”章节中描述的技术。
    </remarks>
  </DataColumn.LinkDF>

  <DataColumn.Modified>
    <summary>
      一个逻辑值，指示此数据列的当前行的内容是否已被用户修改。TRUE 表示已修改(即使尚未验证或验证失败)；FALSE 表示未修改。
    </summary>
    <value>一个逻辑值，指示此数据列的当前行的内容是否已被用户修改。TRUE 表示已修改(即使尚未验证或验证失败)；FALSE 表示未修改。</value>
  </DataColumn.Modified>

  <DataColumn.Name>
    <summary>
      一个字符串，表示此数据列的名称。
    </summary>
    <value>一个字符串，表示此数据列的名称。</value>
  </DataColumn.Name>

  <DataColumn.NameSym>
    <summary>
      一个符号，表示此数据列的名称。
    </summary>
    <value>一个符号，表示此数据列的名称。</value>
  </DataColumn.NameSym>

  <DataColumn.Owner>
    <summary>
      拥有此数据列的数据浏览器。
    </summary>
    <value>拥有此数据列的数据浏览器。</value>
  </DataColumn.Owner>

  <DataColumn.PerformValidations>
    <summary>
      执行定义给此数据列的字段规范的所有验证(例如，必填、最大和最小数字、最大和最小值、验证规则)并返回测试的结果。
    </summary>
    <returns>
      如果任何验证失败，此方法会适当设置数据列的状态，并返回 FALSE。否则，返回 TRUE。
    </returns>
  </DataColumn.PerformValidations>

  <DataColumn.PixelWidth>
    <exclude />
  </DataColumn.PixelWidth>

  <DataColumn.Server>
    <summary>
      当前连接到此数据列的数据服务器，如果有的话。
    </summary>
    <value>当前连接到此数据列的数据服务器，如果有的话。</value>
  </DataColumn.Server>

  <DataColumn.SetCaption>
    <summary>
      设置数据列的标题。
    </summary>
    <param name="cText">要用作标题的文本。如果省略，数据浏览器将使用超链接中的标题。</param>
    <param name="kAlignment">
      以下常量之一，表示数据列的标题的对齐方式：
    </param>
    <remarks>
      <include file="Gui.xml" path="doc/Alignment/*" /> 
      设置空标题("")会导致数据列的标题显示为没有标题。设置空标题会隐藏标题。<br />
      通过在标题字符串中嵌入换行符，标题字段的高度会更改以容纳多行。 
    </remarks>
  </DataColumn.SetCaption>

  <DataColumn.SetModified>
    <summary>
      标记当前数据列，表示它已被修改。
    </summary>
    <param name="lModified">指定 TRUE 以标记数据列为已修改；否则，指定 FALSE。</param>
  </DataColumn.SetModified>

  <DataColumn.SetStandardStyle>
    <summary>
      设置此数据列的标题区域的外观。
    </summary>
    <param name="kStyle">
      要设置的样式，指定为以下常量之一
    </param>
    <remarks>
      <include file="Gui.xml" path="doc/BrowseStyle/*" /> 
      提示：要指定多个样式参数，只需进行多次调用 
      <note type="tip">
        DataColumn:SetStandardStyle() 可以覆盖 DataBrowser:SetStandardStyle() 方法，用于单独的列。
      </note>
    </remarks>
  </DataColumn.SetStandardStyle>

  <DataColumn.SetValue>
    <summary>
      设置当前数据列的值。
    </summary>
    <param name="cNewValue">要分配给指定数据列的新值，以字符串形式指定。</param>
    <returns>
      一个字符串，表示数据列的当前值。
    </returns>
  </DataColumn.SetValue>

  <DataColumn.Status>
    <summary>
      一个超链接标签，指示对此数据列的验证结果或最近操作。
    </summary>
    <value>一个超链接标签，指示对此数据列的验证结果或最近操作。</value>
    <remarks>
      一个超链接标签，指示对此数据列的验证结果或最近操作。<br />
      如果验证通过或操作成功，此值为 NULL_OBJECT；如果不是，它包含有关错误原因的信息。
    </remarks>
  </DataColumn.Status>

  <DataColumn.TextColor>
    <summary>
      用于此数据列的文本区域的文本颜色。
    </summary>
    <value>用于此数据列的文本区域的文本颜色。</value>
  </DataColumn.TextColor>

  <DataColumn.TextValue>
    <summary>
      一个字符串，表示此数据列的当前行中保存的值。<br />
      请注意，此字符串根据从关联服务器字段继承的 FieldSpec 对象中保存的图片规范进行格式化。
    </summary>
    <value>
      一个字符串，表示此数据列的当前行中保存的值。<br />
      请注意，此字符串根据从关联服务器字段继承的 FieldSpec 对象中保存的图片规范进行格式化。
    </value>
  </DataColumn.TextValue>

  <DataColumn.Value>
    <summary>
      此数据列的当前行中保存的值，以从关联服务字段继承的 FieldSpec 对象中保存的任何数据类型。
    </summary>
    <value>此数据列的当前行中保存的值，以从关联服务字段继承的 FieldSpec 对象中保存的任何数据类型。</value>
  </DataColumn.Value>

  <DataColumn.ValueChanged>
    <summary>
      一个逻辑值，指示自上次设置以来，数据列的值是否已更改为“有效”值。
    </summary>
    <value>一个逻辑值，指示自上次设置以来，数据列的值是否已更改为“有效”值。</value>
    <remarks>
      一个逻辑值，指示自上次设置以来，数据列的值是否已更改为“有效”值。<br />
      TRUE 表示已更改为有效值；FALSE 表示未更改为有效值。
    </remarks>
  </DataColumn.ValueChanged>

  <DataColumn.VisualPos>
    <summary>
      返回数据浏览器中的数据列的视觉位置的编号。
    </summary>
    <value>数据浏览器中的数据列的视觉位置的编号。</value>
    <example> 
      以下示例显示了如何使用 DataColumn:VisualPos 将浏览器的当前布局保存到一个 .INI 文件中： 
      <code language="X#">
        METHOD SaveLayout() CLASS MySubForm
            LOCAL wCount AS DWORD
            LOCAL aColumnInfo := {} AS ARRAY
            LOCAL oDataColumn AS DataColumn

            FOR wCount := 1 UPTO SELF:Browser:ColumnCount
                oDataColumn := SELF:Browser:GetColumn( wCount )
                AADD( aColumnInfo, {oDataColumn:NameSym, oDataColumn:VisualPos} )
            NEXT wCount

            SaveSettings( aColumnInfo )

            RETURN NIL
      </code>
    </example>
  </DataColumn.VisualPos>

  <DataColumn.Width>
    <summary>
      此数据列在画布坐标中的宽度。
    </summary>
    <value>此数据列在画布坐标中的宽度。</value>
  </DataColumn.Width>

  <DataDialog>
    <summary>
      创建一个数据窗口，它的行为类似于模态对话框窗口(通常也称为对话框框)。
    </summary>
    <remarks>
      与常规数据窗口是 MDI 子窗口不同，数据对话框窗口的行为类似于模态对话框窗口。
      这意味着用户必须在继续应用程序之前响应窗口并关闭它，并且数据对话框窗口不可调整大小。<br />
      此类的主要目的是提供一种创建用于小型数据输入任务的窗口的方法，例如密码输入。<br />
      请注意，因为 DataDialog 类在内部使用 DialogWindow(而不是 ChildAppWindow)，AppWindow:EnableVerticalScroll() 和 AppWindow:EnableHorizontalScroll() 只是存根，它们不做任何事情。
    </remarks>
  </DataDialog>

  <DataDialog.ctor>
    <summary>
      构造一个数据对话框窗口。
    </summary>
    <param name="oOwner">
      拥有数据对话框窗口的窗口。以下窗口类型可以是所有者：App、ShellWindow、TopAppWindow、ChildAppWindow、DialogWindow 或 DataWindow。
    </param>
    <param name="oSource">定义数据对话框窗口布局的资源的ID。如果未指定，窗口在连接到数据服务器时会自动布局。</param>
    <param name="nResourceID">
      指定子数据窗口的位置和大小的资源ID。<br />
      指定此参数会在其所有者数据窗口上创建新的子数据窗口(只有数据窗口所有者可以有子数据窗口)。它应该引用其所有者数据窗口的资源实体中定义的一个控件。
    </param>
    <param name="nDialogStyle">DataDialog边框的样式。默认为 WS_DLGFRAME。</param>
  </DataDialog.ctor>

  <DataListView>
    <summary>
      创建一个数据列表视图，作为更快速、只读、独立控件和数据浏览器的替代。
    </summary>
    <remarks>
      数据列表视图是一个“数据仓库”列表视图控件，它作为数据浏览器的快速、只读替代。
      与列表视图列控件一起，在窗口编辑器中可以“绘制”数据窗口的浏览视图部分。它也可以作为一个独立控件使用。<br />
      DataListView 控件在内部使用虚拟列表视图，这意味着它的速度不受数据库中记录总数的影响。此外，滚动条的大小和位置始终正确地表示数据库中的位置。
      DataListView 控件依赖于关联服务的 OrderKeyCount()、OrderKeyGoto() 和 OrderKeyNo() 方法。
      如果没有活动的顺序，DataListView 控件使用 RecCount()、GoTo() 和 RecNo()。<br />
      此外，DataListView 控件有一些限制，取决于当前活动的 RDD：<br />
      仅对 NTX 和 CDX 驱动程序支持 SetFilter。 不是所有 RDD 都支持 SetDeleted(TRUE)。
      如果要隐藏所有已删除的记录，应使用 SetDeleted(FALSE) 并指定数据服务器的过滤条件，如： 
      <code language="X#"> 
        SetFilter({||!Deleted()}, "!Deleted()")
      </code> 
      仅对 NTX 和 CDX 驱动程序支持 OrderScopes。<br />
      如果要将 DataListView 控件用作 DataBrowser 控件的替代，将 Window Editor 中的 Browser Inherits From 属性设置为 DataListView。
      生成的代码将引用 DataListView。 
      <note type="tip">
        选择 DataListView 控件作为 DataBrowser 控件的替代还有一个优势：您的应用程序将不需要 CATO3xxx.DLL 支持DLL。
      </note>
      DataListView 控件也可以作为一个独立控件，可以放置在任何窗口或对话框上。
      在这种情况下，您必须显式地将一个数据服务器分配给 DataListView:Server 属性。 
    </remarks>
  </DataListView>

  <DataListView.ctor>
    <summary>
      构造一个数据列表视图。
    </summary>
    <param name="oOwner">拥有数据列表视图的窗口。</param>
    <param name="xID">数据列表视图的唯一ID(在1和8000之间)。</param>
    <param name="nResourceID">数据列表视图的资源ID。</param>
    <param name="oPoint">数据列表视图在画布坐标中的原点。</param>
    <param name="oDimension">数据列表视图在画布坐标中的尺寸。</param>
    <param name="kStyle">数据列表视图的样式。</param>
  </DataListView.ctor>

  <DataListView.DeleteAll>
    <summary>
      删除数据列表视图中的所有项目。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </DataListView.DeleteAll>

  <DataListView.Destroy>
    <summary>
      提供一个方法，用于取消实例化 DataListView 对象。
    </summary>
    <remarks>
      当不再需要 DataListView 对象时，可以使用此方法。<br />
      DataListView:Destroy() 取消实例化 DataListView 对象，并允许您关闭和释放对象打开或创建的任何资源，而无需等待垃圾收集器。
    </remarks>
  </DataListView.Destroy>

  <DataListView.FieldGet>
    <summary>
      返回与数据列表视图关联的数据服务器的指定字段的内容。
    </summary>
    <param name="nFieldPos">表示所需字段的名称、编号或符号。</param>
    <returns>
      字段的内容。返回值的数据类型取决于字段的数据类型。
    </returns>
    <remarks>
      默认情况下，会调用关联服务的 FieldGet() 方法。<br />
      通过子类化 DataListView，可以更改或增强此功能。这是使用 DataListView 控件创建计算(虚拟)列的推荐方式
    </remarks>
  </DataListView.FieldGet>

  <DataListView.Notify>
    <summary>
      提供一个反映已发生在与此数据列表视图连接的服务器中的事件的事件处理程序。
    </summary>
    <returns> 
      NIL，除非为 <paramref name="kNotification" /> 指定了 NOTIFYINTENTTOMOVE。<br />
      在这种情况下，如果成功，返回值为 TRUE；否则，返回值为 FALSE。 
    </returns>
    <include file="VOSDK.xml" path="doc/commonblocks/notify/*" />
  </DataListView.Notify>

  <DataListView.Owner>
    <summary>
      此 DataListView 控件的所有者。
    </summary>
    <value>此 DataListView 控件的所有者。</value>
  </DataListView.Owner>

  <DataListView.Refresh>
    <summary>
      强制更新数据列表视图的内容，从数据服务器。
    </summary>
  </DataListView.Refresh>

  <DataListView.Server>
    <summary>
      与数据列表视图关联的数据服务器。
    </summary>
    <value>与数据列表视图关联的数据服务器。</value>
  </DataListView.Server>

  <DataListView.Use>
    <summary>
      将数据服务器与数据列表视图关联。
    </summary>
    <param name="oNewServer">要与数据列表视图关联的数据服务器。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法等效于 DataListView:Server 分配，它将数据服务器与数据列表视图关联。
    </remarks>
  </DataListView.Use>

  <DataWindow>
    <summary>
      创建一个数据窗口，它能够与数据服务器智能地交互。
    </summary>
    <remarks>
      数据窗口结合了子窗口和对话框窗口的属性和行为，并添加了数据感知行为，使它们能够与数据服务智能地交互。<br />
      当连接到数据服务时，数据窗口形成了对服务的视图，允许直接访问和操作服务的数据。
      与其他类型的窗口不同，数据窗口根据其使用方式而采用不同的行为。<br />
      它根据其所有者对其施加的要求自适应，根据情况的不同表现出不同的行为： <br />
      <list type="table">
        <listheader>
          <term>所有者类型</term>
          <term>数据窗口的行为</term>
        </listheader>
        <listitem>
          <term>ChildAppWindow</term>
          <term>模态对话框窗口</term>
        </listitem>
        <listitem>
          <term>DataWindow</term>
          <term>模态对话框窗口(如果未指定放置位置)或嵌套的子数据窗口(如果指定了放置位置)</term>
        </listitem>
        <listitem>
          <term>DialogWindow</term>
          <term>模态对话框窗口</term>
        </listitem>
        <listitem>
          <term>ShellWindow ChildAppWindow TopAppWindow</term>
          <term>模态对话框窗口</term>
        </listitem>
      </list>
      数据窗口可以在所有者-子窗口的关系中放置在另一个数据窗口上(类似于其他控件如复选框和单选按钮)。
      当以这种方式在另一个数据窗口上放置一个数据窗口时，它被称为子数据窗口。<br />
      请注意，只有数据窗口可以拥有子数据窗口，因为它是唯一可以处理与数据相关事件的窗口类型。<br /><br />

      当创建数据窗口时，可以将其作为子数据窗口创建。<br />
      可以选择指定第三个参数(<paramref name="nResourceID" />)，指示应在窗口上创建新的数据窗口作为控件，通过给出其位置和大小。
      当像控件一样放置时，数据窗口隐藏其边框装饰，并且表现得像子数据窗口
      (如果省略此参数，数据窗口将作为模态对话框窗口创建，而不是子数据窗口)<br />
      有关详细信息，请参见 DataWindow:Init()。<br />
      提示：您可能更喜欢使用窗口编辑器的自动布局功能，一触即发，自动为数据窗口的关联数据服务中的每个可用字段创建控件。<br />
      请参见 IDE 用户指南中的“使用窗口编辑器”。<br /><br />

      数据窗口通过 Use() 方法与服务连接。建立此连接时，窗口上的每个控件都会根据匹配的名称与数据服务中的字段连接：名为 CustName 的字段与名为 CustName 的控件连接。
      控件始终反映数据服务中数据的当前值，并且将值分配给控件会自动将其传播到服务器。<br /><br />

      数据窗口可以通过两种方式与数据服务器关联：单服务或双服务(主细节)关系。<br />
      主细节选项允许您将一个窗口链接到两个数据服务，形成主细节关系。
      在这种情况下，为主服务创建一个数据窗口，为细节服务创建一个嵌套的子数据窗口。
      提供的字段列表来自主数据服务。您选择的字段用于根据其控制顺序对细节服务执行 SetSelectiveRelation()。<br />
      如果不选择字段，细节窗口将相对于主窗口的当前记录位置进行更新。<br /><br />

      数据窗口可以采用两种不同的视图模式：表单视图，其中包含数据字段的单独控件，和浏览视图，其中包含类似电子表格的数据浏览器。<br />
      数据窗口可以最初以任一模式显示，并且可以随时切换到另一模式(使用 DataWindow:ViewAs() 方法)。
      任何数据窗口都支持这两种外观，尽管开发人员当然可以选择不提供选择一种模式或另一种模式的方法。<br />
      两种视图模式提供相同的一组设施：相同的数据链接设施，相同的显示选项，相同的数据操作方法。<br />
      从应用程序的角度来看，无论视图模式如何，数据窗口都具有相同的行为和相同的数据属性。<br /><br />

      使用数据窗口的标准方式是在窗口编辑器中绘制其布局。
      这将产生一个资源实体，指定窗口具有哪些控件，它们的位置、大小、标题和加速器。<br />
      它还会生成一个数据窗口子类和一个 Init() 方法，该方法将每个控件的名称和进一步的注释与其关联。<br />
      有了这样的预定义布局，窗口的显示速度非常快，并且窗口的方法具有足够的信息来智能地行事。<br />
      数据窗口也可以在没有资源实体的情况下创建。在这种情况下，当窗口连接到数据服务时，窗口上的控件的布局会自动生成。
      在自动生成布局后，窗口的行为与基于资源的实例化具有完全相同的行为。<br />
      如果数据窗口切换到新的视图模式，并且新模式没有通过资源实体或以编程方式定义，数据窗口会根据连接的数据服务的特性自动创建布局。
      新布局会获取有关字段和控件的所有信息，这些信息已知于其他视图。
      因此，如果已为表单视图中的单个控件指定了复杂的验证规则、提示和帮助，浏览视图的列将继承相同的属性。<br /><br />

      当控件与数据服务中的字段连接时，输入到控件的值或从程序分配给适当名称的值会自动传播到服务。
      因此，执行此语句后： 
      <code language="X#">
        oCustomerWindow:CustName := x
      </code> 
      服务中的 CustName 字段将具有正确的值。<br />
      当服务重新定位自身或其他窗口进行更改时，数据窗口会自动将数据从数据服务传播到数据窗口。<br />
      这不需要任何特殊操作：在执行Skip()方法或将值分配给字段后，与服务器连接的每个窗口都会自动更新以反映更改。
      用户输入的数据会使用附加到控件或列的字段规范的规则进行自动验证。
      (有关提供的验证规则的更多详细信息，请参见 FieldSpec 类。)<br />
      如果数据未通过验证测试，数据窗口将不会将无效信息传播到服务器或其他窗口，也不会执行需要将无效值写入服务器的任何操作。<br /><br />

      除了特定于字段的验证，系统还允许为窗口整体指定一个 ValidateRecord() 方法，用于交叉字段验证。<br />
      如果提供了此方法，它将在所有字段都通过其各自的验证后调用。<br /><br />

      数据窗口还提供了注册受验证状态影响的控件的功能。当窗口的验证状态不好时，已注册的控件将被禁用。<br />
      数据窗口类还提供了与所有数据服务器的一般能力相对应的操作方法：GoTop()、GoTo()、GoBottom()、SkipNext()、SkipPrevious()、Append()、Delete()等。
      这些方法的数据窗口版本会验证窗口上的控件的验证状态。如果一切都有效，窗口将调用数据服务器的相应方法。<br />
      数据窗口提供了内置的并发控制设施，根据需要自动获取和释放记录锁。<br />
      一旦通过将一个可用的模式分配给 DataWindow:ConcurrencyControl 来选择了适当的模式，记录的移动和更改将使用数据服务器的并发控制设施来获取和释放锁。
      如果获取锁失败，因为另一个用户控制了记录，数据窗口操作将失败。
    </remarks>
  </DataWindow>

  <DataWindow.ctor>
    <summary>
      构造一个数据窗口。
    </summary>
    <param name="oOwner">
      拥有数据窗口的窗口。以下窗口类型可以是所有者：<br />
      ShellWindow, TopAppWindow, ChildAppWindow, DialogWindow, DataDialog, 或另一个 DataWindow。<br />
      数据窗口的行为由其所有者的类型决定—请参阅 Adaptive Behavior 中的描述。
    </param>
    <param name="oSource">
      定义数据窗口布局的资源的ID。如果未指定，数据窗口在连接到数据服务器时会自动布局。
    </param>
    <param name="nResourceID"> 
      指定子数据窗口的位置和大小的资源ID。 指定此参数会在其所有者数据窗口上创建新的数据窗口作为子数据窗口
      (只有数据窗口所有者可以拥有子数据窗口)。它应该引用其所有者数据窗口的资源实体中定义的控件。 <br />
      如果省略了 <paramref name="nResourceID" /> 或者 <paramref name="oOwner" /> 不是数据窗口，数据窗口将作为模态对话框窗口创建。 
    </param>
    <param name="nDialogStyle">** 缺少参数文档 **</param>
    <example> 
      以下创建了一个数据窗口和一个数据服务器，将服务器分配给窗口，然后显示窗口： 
      <code language="X#">
        ...
        oDWCust       := DataWindow{oShell,"CustomerWindow"}
        oDWCustOrders := DBServer{SELF,"CustOrders",IDW_CUSTORDERS}

        oDWGeneric := DBServer{SELF}
        oDWGeneric:Use(DBServer{cFileName})
        oDWGeneric:Show()
      </code>
    </example>
  </DataWindow.ctor>

  <DataWindow.Activate>
    <inheritdoc />
  </DataWindow.Activate>

  <DataWindow.AllowServerClose>
    <summary>
      一个逻辑值，指定是否应自动关闭数据窗口的服务器。默认情况下，这在 DataWindow:Init() 方法中设置为 TRUE。
    </summary>
    <value>一个逻辑值，指定是否应自动关闭数据窗口的服务器。默认情况下，这在 DataWindow:Init() 方法中设置为 TRUE。</value>
  </DataWindow.AllowServerClose>

  <DataWindow.Append>
    <summary>
      在与此数据窗口连接的数据服务器上追加一个空记录，并将窗口定位在这个新记录上。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      当成功执行时，新记录被追加的数据服务器会向其所有客户端(包括这个数据窗口)发送一个 NotifyAppend 消息。<br />
      DataWindow:Append() 可能因为许多原因而失败(例如，窗口中输入的数据未通过验证，记录锁失败，因为另一个用户控制了数据服务，或者由于技术原因，对数据库的访问失败)。<br />
      使用 DataWindow:Status 属性来确定失败的确切原因。您可能还想在操作之前检查操作的可行性，使用 DataWindow:StatusOK() 等方法。
    </remarks>
  </DataWindow.Append>

  <DataWindow.AutoScroll>
    <summary>
      数据窗口在通过Tab键获得焦点时自动滚动到任何控件，即使该控件不可见(例如，当窗口被调整大小时)。<br />
      通过将 AutoScroll 设置为 FALSE，可以阻止这种自动滚动行为。
    </summary>
    <value>
      数据窗口在通过 Tab 键获得焦点时自动滚动到任何控件，即使该控件不可见(例如，当窗口被调整大小时)。<br />
      通过将 AutoScroll 设置为 FALSE，可以阻止这种自动滚动行为。
    </value>
  </DataWindow.AutoScroll>

  <DataWindow.Background>
    <summary>
      当前由此数据窗口使用的背景画刷。
    </summary>
    <value>
      当前由此数据窗口使用的背景画刷。
    </value>
    <remarks>
      一个窗口的背景画刷由 CanvasErase() 使用，并在处理 Expose 事件时使用。<br />
      分配新的背景画刷在数据窗口(或数据窗口的一部分)被重绘之前没有效果。<br />
      如果一个数据窗口部分被覆盖，然后完全暴露，只有被覆盖的部分的数据窗口被重绘，并且只有该部分获得新的背景。
    </remarks>
  </DataWindow.Background>

  <DataWindow.Browser>
    <summary>
      当此数据窗口在浏览视图中显示时要使用的 DataBrowser 对象。
    </summary>
    <value>当此数据窗口在浏览视图中显示时要使用的 DataBrowser 对象。</value>
    <remarks>
      当此数据窗口在浏览视图中显示时要使用的 DataBrowser 对象。<br />
      数据窗口不一定需要拥有特定的数据浏览器。<br />
      如果数据窗口没有浏览器，且应用程序选择在浏览模式下查看它，X#会自动为窗口创建一个浏览器，并用数据服务器中的每个字段创建一个列。
      列标题来自服务器，使用其字段的超链接。
    </remarks>
  </DataWindow.Browser>

  <DataWindow.BrowserClass>
    <summary>
      一个符号，指定数据窗口的浏览模式使用的类。有效值为：#DATABROWSER，#DATALISTVIEW，或任何用户定义的类。默认值为 #DATABROWSER。
    </summary>
    <value>
      一个符号，指定数据窗口的浏览模式使用的类。有效值为：#DATABROWSER，#DATALISTVIEW，或任何用户定义的类。默认值为 #DATABROWSER。
    </value>
  </DataWindow.BrowserClass>

  <DataWindow.ButtonClick>
    <summary>
      当鼠标点击复选框、按钮或单选按钮时调用的方法。
    </summary>
    <param name="oControlEvent">描述哪个按钮被点击的 ControlEvent 对象。</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      按钮点击事件与菜单事件一样传播到数据窗口的所有者。<br />
      有关命令事件传播的深入讨论，请参阅程序员指南。 <br />
      当用户点击单选按钮时，您必须提供代码来打开(并关闭所有其他单选按钮)单选按钮。类似地，当单击复选框时，您还必须确保反转复选框的状态。 
    </remarks>
  </DataWindow.ButtonClick>

  <DataWindow.Cancel>
    <summary>
      放弃在此数据窗口中输入的所有信息并关闭窗口。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks> 
      “取消”操作非常清晰易懂，可能在创建 MDI 子窗口(非常规或不)时在数据窗口上有益。 <br />
      请注意，用户可能不清楚确切放弃了哪些事务。<br />
      例如，如果修改了多条记录，DataWindow:Cancel() 的默认实现只会放弃对当前记录的更改。 
      您可能希望将按钮或菜单命令标记为其他内容，或者提供更全面的实现。 
      <note type="tip">
        DataWindow:Cancel() 使用 DataServer:UnregisterClient() 断开与数据服务的连接，并告诉服务如果没有其他注册的客户端，它可以关闭自己。<br />
        从窗口显式强制关闭服务器不推荐，因为这可能会在未来创建问题。<br />
        应用程序的修改可以将其他客户端附加到服务器，并且任何一个窗口都不应该禁用其他窗口。
      </note>
    </remarks>
  </DataWindow.Cancel>

  <DataWindow.CanvasErase>
    <summary>
      擦除此数据窗口的当前画布区域，并使用背景画刷或系统的默认背景颜色重新绘制它。
    </summary>
  </DataWindow.CanvasErase>

  <DataWindow.ChangeFont>
    <summary>
      更改此数据窗口使用的字体。
    </summary>
    <param name="oFont">要使用的新字体。</param>
    <param name="lUpdate">
      指定 TRUE 以调整和重新定位此对话框窗口中的所有控件，并更改它们的字体；否则，为 FALSE。<br />
      如果省略，缺省值为 FALSE。
    </param>
    <returns>
      先前分配给数据窗口的字体。
    </returns>
  </DataWindow.ChangeFont>

  <DataWindow.CheckStatus>
    <summary>
      测试此数据窗口中当前显示的控件的信息，以查看它是否通过了连接服务器定义的所有验证规则。
    </summary>
    <returns>
      如果窗口通过了所有验证检查，则为 TRUE；否则，为 FALSE。
    </returns>
    <remarks>
      此方法调用 DataWindow:StatusOK()，该方法验证窗口中每个控件的信息。<br />
      如果验证检查失败，使用 DataWindow:Status 属性确定失败的确切原因。
    </remarks>
  </DataWindow.CheckStatus>

  <DataWindow.Clear>
    <summary>
      清除此数据窗口中的当前选择。
    </summary>
    <remarks>
      如果数据窗口处于表单视图，编辑控件的内容将被清除；如果处于浏览视图，将清除数据浏览器中所选单元格的内容(或单元格的一部分)。
    </remarks>
  </DataWindow.Clear>

  <DataWindow.ClearRelations>
    <summary>
      清除到此数据窗口的服务器定义的所有关系。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      在数据窗口中，关系用于管理与连接到同一数据服务的窗口之间的关系。<br />
      清除关系会删除窗口之间的链接；实际上，它会清除为连接到此和任何其他窗口的数据服务器设置的关系。<br />
      使用 DataWindow:SetRelation() 和 DataWindow:SetSelectiveRelation() 设置关系。
    </remarks>
  </DataWindow.ClearRelations>

  <DataWindow.ClipperKeys>
    <summary>
      一个逻辑值，指示是否要在此数据窗口中使用 Clipper 导航键(即，方向和返回键)(如果是，则为 TRUE，否则为 FALSE)。
    </summary>
    <value>
      一个逻辑值，指示是否要在此数据窗口中使用 Clipper 导航键(即，方向和返回键)(如果是，则为 TRUE，否则为 FALSE)。
    </value>
  </DataWindow.ClipperKeys>

  <DataWindow.Close>
    <summary>
      在数据窗口即将关闭时调用。
    </summary>
    <param name="oEvent">需要维护协议的事件，即所有事件处理程序的参数都必须是一个事件。</param>
    <seealso cref="T:VO.Event" />
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      此方法不用于关闭数据窗口。使用 DataWindow:Hide() 使数据窗口从视图中消失，但仍然可以重新打开；使用 DataWindow:Destroy() 永久销毁数据窗口。 
    </remarks>
  </DataWindow.Close>

  <DataWindow.Commit>
    <summary>
      强制将此数据窗口的服务上的所有挂起更新永久写入磁盘。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法还会使更改对网络上的其他机器上的其他用户以及同一机器上的其他应用程序可见。<br />
      在 DataWindow:Commit() 之前，更改只保证对同一应用程序中连接到同一服务的其他数据窗口可见。<br />
      DataWindow:Commit() 可能因为许多原因而失败，从服务中的能力不足到锁冲突等技术问题。使用 DataServer:Status 属性确定失败的确切原因。<br />
      您还应该注意，没有保证未提交的更改可以被回滚。
      回滚功能取决于特定的数据服务实现(例如，SQLSelect 通常可以做到—具体取决于使用的 SQL 数据库，但 DBServer 不能)。<br />
      有关详细信息，请参阅您打算使用的特定服务的文档。
    </remarks>
  </DataWindow.Commit>

  <DataWindow.ConcurrencyControl>
    <summary>
      一个常量，用于标识此数据窗口的自动并发控制模式，确定何时以及如何锁定和释放记录：
    </summary>
    <value>一个常量，用于标识此数据窗口的自动并发控制模式，确定何时以及如何锁定和释放记录：</value>
    <remarks> 
      以下常量之一，用于标识此数据窗口的自动并发控制模式，确定何时以及如何锁定和释放记录： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>CCNONE</term>
          <description>数据窗口不提供自动记录锁定；应用程序需要显式地进行所有锁定。</description>
        </item>
        <item>
          <term>CCSTABLE</term>
          <description>窗口所在的记录始终被保持锁定。请注意，当处于浏览视图时，光标所在的行代表当前记录。</description>
        </item>
        <item>
          <term>CCOPTIMISTIC</term>
          <description> 
            除了在追加时(刚刚追加的记录被锁定，只有在移动到记录之外或显式调用 DataServer 或 DBServer Unlock() 方法时才释放锁)，
            不会持续维护任何锁定。对于所有其他记录，在执行任何更新之前都会重新从磁盘读取记录。这是<b>默认</b>。 
          </description>
        </item>
        <item>
          <term>CCREPEATABLE</term>
          <description>所有已读取的记录都会被保持锁定。用户可以确保在先前查看的数据之间移动时，它们没有发生更改。</description>
        </item>
        <item>
          <term>CCFILE</term>
          <description>
            整个由服务器提供的集合中的所有记录都会被持续锁定。
            这对于与服务器的所有记录相关联的窗口不太实际，因为它将对应于文件锁。
            它意在与 DataWindow:SetSelectiveRelation() 方法一起使用。
          </description>
        </item>
      </list>
    </remarks>
  </DataWindow.ConcurrencyControl>

  <DataWindow.ContextMenu>
    <summary>
      附加到窗口的上下文菜单
    </summary>
    <value>附加到窗口的上下文菜单</value>
    <remarks> 
      这可以以两种方式使用。 DataWindow 及其 Browser 通常共享相同的 ContextMenu，在这种情况下，分配可以像这样使用 – 
      <code language="X#">
        <paramref name="oDataWindow" />:ContextMenu := MyContextMenu{} 
      </code>
      如果要使上下文菜单不同，现在可以使用这样的代码 – 
      <code language="X#">
        <paramref name="oDataWindow" />:[ContextMenu,#FormView] := MyContextMenu{} 
      </code>
      仅设置 FormView 上下文菜单，以及这样的代码 – 
      <code language="X#">
        <paramref name="oDataWindow" />:[ContextMenu,#BrowseView] := MyOtherContextMenu{} 
      </code>
      设置 BrowseView 上下文菜单。 
    </remarks>
  </DataWindow.ContextMenu>

  <DataWindow.ControlFocusChange>
    <summary>提供一个在输入焦点切换到或从控件时调用的方法。</summary>
    <param name="oControlFocusChangeEvent">
      标识生成 ControlFocusChangeEvent 对象的哪个控件，并且它是否刚刚获得或失去了键盘焦点的 ControlFocusChangeEvent 对象。 </param>
    <remarks>
      如果 ControlFocusChange() 用于验证控件(并且还将焦点设置到另一个控件)，
      则在其他控件获得焦点之前不应调用 Control:SetFocus()。<br />
      在包含许多编辑控件的复杂对话框窗口中，当焦点正在切换时，抓取编辑控件的文本是有意义的，以便如果需要，可以使用其他控件更新它。<br />
      请参阅 ButtonClick() 方法，以查看在此方法中使用的类似语法的示例。<br />
      请注意，此方法会通过此方法传递所有控件，而不仅仅是 SingleLineEdit 和 MultiLineEdit 控件。<br />
      如果要控制 Combobox 的选择，那么应该查看 ListBoxSelect() 回调方法。
    </remarks>
    <seealso cref="T:VO.ControlFocusChangeEvent" />
  </DataWindow.ControlFocusChange>

  <DataWindow.Controls>
    <exclude />
  </DataWindow.Controls>

  <DataWindow.Copy>
    <summary>
      将此数据窗口中的当前选择复制到剪贴板。
    </summary>
    <remarks>
      如果数据窗口处于表单视图，将复制编辑控件的内容；如果处于浏览视图，将复制数据浏览器中所选单元格的内容(或单元格的一部分)。
    </remarks>
  </DataWindow.Copy>

  <DataWindow.CurrentControl>
    <exclude />
  </DataWindow.CurrentControl>

  <DataWindow.CurrentView>
    <summary>
      一个表示数据窗口的视图模式的符号，如 #BrowseView 或 #FormView。
    </summary>
    <value>一个表示数据窗口的视图模式的符号，如 #BrowseView 或 #FormView。</value>
  </DataWindow.CurrentView>

  <DataWindow.Cut>
    <summary>
      删除此数据窗口中的当前选择，并将其复制到剪贴板。
    </summary>
    <remarks>
      如果数据窗口处于表单视图，将剪切编辑控件的内容；如果处于浏览视图，将剪切数据浏览器中所选单元格的内容(或单元格的一部分)。
    </remarks>
  </DataWindow.Cut>

  <DataWindow.DeActivate>
    <inheritdoc />
  </DataWindow.DeActivate>

  <DataWindow.DeactivateAllOLEObjects>
    <inheritdoc />
  </DataWindow.DeactivateAllOLEObjects>

  <DataWindow.DeferUse>
    <summary>
      一个逻辑值，指定是否应将用于将数据窗口连接到关联服务的 Use() 操作推迟到首次显示数据窗口。
    </summary>
    <value>一个逻辑值，指定是否应将用于将数据窗口连接到关联服务的 Use() 操作推迟到首次显示数据窗口。</value>
    <remarks>
      一个逻辑值，指定是否应将用于将数据窗口连接到关联服务的 Use() 操作推迟到首次显示数据窗口。<br />
      这在多个数据窗口为选项卡控件构建页面的情况下很有用。默认值为 FALSE。
    </remarks>
  </DataWindow.DeferUse>

  <DataWindow.Delete>
    <summary>
      删除附加服务中的当前记录，并根据更改更新窗口。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks> 
      当成功执行时，从删除记录的数据服务器向其所有客户端(包括此数据窗口)发送 NotifyDelete 消息。<br />
      对于一些服务(特别是 DBServer)，删除的记录不会从服务器中删除，而是只是标记为已删除。
      标记的记录只有在文件打包时才会被删除，并且在此之前可以被召回
      (对于 DBServer，SetDeleted() 函数的当前设置影响是否可以看到已删除的记录)。<br />
      在删除记录之前，记录中的字段所做的任何更改都会被记录；如果稍后召回字段，则正确地反映删除操作之前所做的任何更改。
      <note type="tip">
        DataWindow:Delete() 在删除操作完成后会前进到下一条记录(如果 SetDeleted() 为 TRUE)，而 DBServer:Delete() 不会。
      </note>
      DataWindow:Delete() 在允许删除操作之前不会检查验证状态。如果窗口包含无效数据，它将被丢弃，并且删除操作将被完成。
      如果您希望在删除之前进行验证，请使用 DataWindow:DeleteValidated()。
      <note type="tip">
        不要混淆清除和删除。清除结构(例如记录或字段)会删除其内容。另一方面，删除结构会删除实际的结构。
      </note>
    </remarks>
  </DataWindow.Delete>

  <DataWindow.DeleteValidated>
    <summary>
      仅当通过其验证规则时，才删除附加服务器中的当前记录，并根据更改更新窗口。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks> 
      当成功执行时，从删除记录的数据服务器向其所有客户端(包括此数据窗口)发送 NotifyDelete 消息。<br />
      此方法在允许删除操作之前会检查验证状态。
      如果窗口包含无效数据，用户将被要求在继续删除操作之前丢弃或更正数据。<br />
      如果不希望出现这种行为(也许是因为应用程序不使用回收或窗口只用于不支持回收已删除记录的服务器)，请使用 DataWindow:Delete()。<br />
      对于一些服务器(特别是 DBServer)，删除的记录不会从服务器中删除，而是只是标记为已删除。<br />
      标记的记录只有在文件打包时才会被删除，并且在此之前可以被召回
      (对于 DBServer，SetDeleted() 函数的当前设置影响是否可以看到已删除的记录)。<br />
      在删除记录之前，记录中的字段所做的任何更改都会被记录；如果稍后召回字段，则正确地反映删除操作之前所做的任何更改。
      <note
        type="tip">不要混淆清除和删除。清除结构(例如记录或字段)会删除其内容。另一方面，删除结构会删除实际的结构。</note>
    </remarks>
  </DataWindow.DeleteValidated>

  <DataWindow.Destroy>
    <summary>
      释放为窗口及其派生对象分配的内存资源。
    </summary>
    <remarks>
      此方法立即释放显式在应用程序中创建的 DataWindow 对象的资源。DataWindow:Destroy() 还负责分配给派生类的资源，并按照必要的顺序对其进行解除分配。
    </remarks>
  </DataWindow.Destroy>

  <DataWindow.DisableConditionalControls>
    <summary>
      禁用此数据窗口中已注册的条件控件。
    </summary>
    <remarks>
      此方法禁用所有已注册的控件，这些控件已在 DataWindow:RegisterConditionalControls() 中注册，该方法将这些控件标记为需要验证。
      每当窗口验证失败时，DataWindow:Prevalidate() 都会自动调用此方法。这样，所有已注册的控件都可以在窗口处于无效状态时保证不可用。
    </remarks>
  </DataWindow.DisableConditionalControls>

  <DataWindow.Dispatch>
    <inheritdoc />
  </DataWindow.Dispatch>

  <DataWindow.Draw>
    <summary>
      在此数据窗口上显示一个绘图对象。
    </summary>
    <param name="oDrawObject">要绘制的对象。</param>
    <param name="aoDrawObject">要绘制的对象的数组。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      通过将设备上下文或呈现空间放入绘图对象，然后调用绘图对象的 Draw() 方法，可以在窗口上绘制绘图对象。<br />
      这是在窗口上绘制绘图对象的唯一有效方法。 
    </remarks>
  </DataWindow.Draw>

  <DataWindow.EditChange>
    <summary>
      当编辑控件中的文本更改时，提供一个被调用的方法。
    </summary>
    <param name="oControlEvent">描述哪个编辑控件已更改的 ControlEvent 对象。</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      每当编辑控件的内容更改时，都会调用此方法。 
    </remarks>
  </DataWindow.EditChange>

  <DataWindow.EnableConditionalControls>
    <summary>
      启用已注册的条件控件。
    </summary>
    <remarks>
      此方法启用所有已在 DataWindow:RegisterConditionalControls() 中注册的控件，该方法将这些控件标记为需要验证。<br />
      每当窗口的验证状态为 OK 时，DataWindow:Prevalidate() 都会自动调用此方法。<br />
      这样，所有已注册的控件都可以在窗口已知处于有效状态时保证可用。
    </remarks>
  </DataWindow.EnableConditionalControls>

  <DataWindow.EnableDragDropClient>
    <inheritdoc />
  </DataWindow.EnableDragDropClient>

  <DataWindow.EnableStatusBar>
    <inheritdoc />
  </DataWindow.EnableStatusBar>

  <DataWindow.EnableToolTips>
    <inheritdoc />
  </DataWindow.EnableToolTips>

  <DataWindow.Error>
    <summary>
      提供一个处理数据窗口处理过程中引发的错误条件的方法。
    </summary>
    <param name="oErrorObj">描述错误条件的 Error 对象。</param>
    <remarks>
      <note type="tip">
        这是一个事件处理程序，通常由其他方法自动调用；开发人员通常不需要调用 DataWindow:Error() 方法，但可能需要覆盖它。
      </note>
    </remarks>
  </DataWindow.Error>

  <DataWindow.Expose>
    <summary>
      当数据窗口的一部分需要重新绘制时，提供一个被调用的方法。
    </summary>
    <param name="oExposeEvent">描述数据窗口的哪个区域需要重新绘制的 ExposeEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      这是最重要的事件处理程序之一。当数据窗口： 
      <list type="bullet">
        <item>被另一个窗口部分遮盖</item>
        <item>首次显示</item>
        <item>增大尺寸</item>
        <item>从最小化状态恢复</item>
        <item>应该保留足够的信息，以便在需要时重绘屏幕。</item>
      </list>
      调用 Repaint() 或 Update() 也会触发 ExposeEvent；在 Expose() 中不应调用 Repaint() 或 Update()。 
    </remarks>
  </DataWindow.Expose>

  <DataWindow.FIELDGET>
    <summary>
      检索此数据窗口中指定控件的当前值(以及与此控件关联的数据服务器字段，如果有)。
    </summary>
    <param name="uFieldID">表示所需字段的名称、编号或符号。</param>
    <returns>
      字段的内容。返回值的数据类型取决于字段的数据类型。
    </returns>
    <remarks>
      在数据窗口中，可以将控件(例如编辑控件和复选框)链接到连接的数据服务器中的字段。<br />
      由于控件的名称和字段的名称相同，FieldGet() 也可以用于检索未连接到服务器的控件。
    </remarks>
  </DataWindow.FIELDGET>

  <DataWindow.FIELDPUT>
    <summary>
      设置此数据窗口中控件的值(以及与此控件关联的数据服务器字段，如果有)。
    </summary>
    <param name="uFieldId">引用的字段的名称、编号或符号。</param>
    <param name="uNewValue">要分配给字段的值。此值的数据类型必须与字段的数据类型匹配。</param>
    <returns>
      如果操作成功，返回新分配的值；否则，返回 NIL。
    </returns>
    <remarks>
      当成功执行时，接收到更新值的数据服务器向其所有客户端(包括此数据窗口)发送 NotifyFieldChange 消息。<br />
      在数据窗口中，可以将控件(例如编辑控件和复选框)链接到连接的数据服务器中的字段。
    </remarks>
  </DataWindow.FIELDPUT>

  <DataWindow.FocusChange>
    <summary>
      当输入焦点从当前数据窗口更改到另一个窗口(或反之)时，提供一个被调用的方法。
    </summary>
    <param name="oFocusChangeEvent">标识焦点是获得还是失去的 FocusChangeEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      如果您的数据窗口使用游标，应在焦点从当前数据窗口更改到另一个数据窗口时隐藏数据窗口的游标，然后在数据窗口再次获得焦点时显示游标。<br />
      这应该与 Activate() 和 Deactivate() 事件处理程序一起使用。
    </remarks>
    <example> 
      此示例演示了 FocusChange() 在获得焦点时显示指定的游标位置。如果失去焦点，游标将被隐藏： 
      <code language="X#">
        METHOD FocusChange(oFocusChangeEvt) CLASS MyDataWindow
            IF oFocusChangeEvt:GotFocus // Gaining focus
                oMyCursor:Show()
                oMyCursor:ChangePos(oMyCursorPos)
            ELSE // Losing focus
                oMyCursorPos := oMyCursor:GetPos()
                oMyCursor:Hide()
            ENDIF
      </code>
    </example>
  </DataWindow.FocusChange>

  <DataWindow.Foreground>
    <summary>
      当前由此数据窗口使用的前景画刷。
    </summary>
    <value>当前由此数据窗口使用的前景画刷。</value>
  </DataWindow.Foreground>

  <DataWindow.GetAllChildren>
    <inheritdoc />
  </DataWindow.GetAllChildren>

  <DataWindow.GoBottom>
    <summary>
      将连接到此数据窗口的数据服务器定位在最后一个逻辑记录，并根据更改更新窗口。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      当成功执行时，数据服务器向其所有客户端(包括此数据窗口)发送 NotifyGoBottom 消息。<br />
      DataWindow:GoBottom() 可能由于许多原因而失败，从服务器中的锁冲突到技术问题，如网络崩溃。使用 DataServer:Status 属性确定失败的确切原因。<br />
      还要注意，DataWindow:GoBottom() (像所有重新定位操作一样)需要验证——如果窗口中的当前数据验证失败，它将无法写出，并且移动将被拒绝。
    </remarks>
  </DataWindow.GoBottom>

  <DataWindow.GoTo>
    <summary>
      将连接到此数据窗口的数据服务器定位在指定的记录号，并根据更改更新窗口。
    </summary>
    <param name="nRecNo">数据窗口应该定位到的记录号。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      当成功执行时，数据服务器向其所有客户端(包括此数据窗口)发送 NotifyRecordChange 消息。<br />
      DataWindow:GoTo() 可能由于许多原因而失败，从服务器中的锁冲突到技术问题，如网络崩溃。使用 DataServer:Status 属性确定失败的确切原因。<br />
      还要注意，DataWindow:GoTo() (像所有重新定位操作一样)需要验证——如果窗口中的当前数据验证失败，它将无法写出，并且移动将被拒绝。
    </remarks>
  </DataWindow.GoTo>

  <DataWindow.GoTop>
    <summary>
      将连接到此数据窗口的数据服务器定位在第一个逻辑记录，并根据更改更新窗口。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      当成功执行时，数据服务器向其所有客户端(包括此数据窗口)发送 NotifyGoTop 消息。<br />
      DataWindow:GoTop() 可能由于许多原因而失败，从服务器中的锁冲突到技术问题，如网络崩溃。使用 DataServer:Status 属性确定失败的确切原因。<br />
      还要注意，DataWindow:GoTop() (像所有重新定位操作一样)需要验证——如果窗口中的当前数据验证失败，它将无法写出，并且移动将被拒绝。
    </remarks>
  </DataWindow.GoTop>

  <DataWindow.HelpRequest>
    <summary>
      当用户使用可用的上下文敏感帮助机制之一从应用程序请求帮助时，提供一个被调用的方法。
    </summary>
    <param name="oHelpRequestEvent">描述正在请求帮助的项目的 HelpRequestEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      仅当当前数据窗口(或其所有者之一)的帮助机制已启用时，才会调用此事件处理程序。<br />
      通过将 HelpDisplay 对象分配给窗口的 HelpDisplay 属性，可以启用帮助机制。
      此事件处理程序的默认实现是在生成 HelpRequestEvent 时显示与控件、菜单命令或具有焦点的窗口区域关联的帮助主题。
      这是通过使用 HelpDisplay:Show(<paramref name="cKeyword" />) 实现的，
      其中 <paramref name="cKeyword" /> 是 HyperLabel:HelpContext 属性或在超链接标签不可用的情况下由此事件处理程序生成的默认关键字。<br />
      如果项目没有超链接标签，生成的关键字如下：<br />
      HELPCONTROL 请求生成关键字 Control_xxxx，其中 xxxx 是控件的数字ID，以十进制表示。例如，OK 按钮可能生成关键字 Control_101。<br />
      HELPMENU    请求生成关键字 Menu_xxxx，其中 xxxx 是菜单命令的“清理”文本。清理文本已删除所有前导和尾随空格以及和字符(&amp;)。<br />
      此外，所有空格序列都替换为单个下划线，并且字符串在第一个制表符处截断。
      例如，对于菜单命令： <br />
      <code language="X#">
        Save &amp;As\tF3 is Menu_Save_As A HELPWINDOW 
      </code>
      请求会生成下表所列的关键字之一，具体取决于焦点所在的窗口区域。
      <list type="table">
        <listheader>
          <term>关键字</term>
          <term>窗口区域</term>
        </listheader>
        <item>
          <term>Window_Border</term>
          <term>边框</term>
        </item>
        <item>
          <term>Window_Caption</term>
          <term>标题栏</term>
        </item>
        <item>
          <term>Window_MaxBox</term>
          <term>最大化按钮</term>
        </item>
        <item>
          <term>Window_MinBox</term>
          <term>最小化按钮</term>
        </item>
        <item>
          <term>Window_SysMenuBox</term>
          <term>系统菜单按钮</term>
        </item>
        <item>
          <term>Window_Unknown</term>
          <term>在本表中未明确标识的窗口的任何区域</term>
        </item>
        <item>
          <term>Window_WindowCanvas</term>
          <term>画布区域</term>
        </item>
      </list>
      <note type="tip">
        如果生成的关键字是 Window_Unknown，HelpRequest() 的默认行为是显示 HelpDisplay 中定义的 Contents 主题(即，HelpDisplay:Show("HelpIndex"))。
      </note>
      如果接收到 HELPWINDOW 请求，同时 DataWindow:HelpContext 已定义，DataWindow:HelpRequest() 将使用 HelpContext 属性，而不管具有焦点的窗口区域是什么。<br />
      有关如何为应用程序编程在线帮助系统的更多信息，请参阅程序员指南中的“GUI类”章节。 
    </remarks>
  </DataWindow.HelpRequest>

  <DataWindow.Hide>
    <summary>
      隐藏此数据窗口，使其不可见。
    </summary>
    <remarks>
      数据窗口保持隐藏，直到调用 Show() 方法。
    </remarks>
  </DataWindow.Hide>

  <DataWindow.HorizontalScroll>
    <summary>
      当水平滚动条滚动时，提供一个被调用的方法。
    </summary>
    <param name="oScrollEvent">描述滚动类型和新位置的 ScrollEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      此事件处理程序的默认行为是更新滚动条的拇指位置；可以通过自己的事件处理程序实现更改。<br />
      此事件处理程序仅适用于 HorizontalScrollBar 和 WindowHorizontalScrollBar 对象。<br />
      如果应用程序有垂直滚动条，使用 WindowVerticalScrollBar 事件处理程序。
      </remarks>
  </DataWindow.HorizontalScroll>

  <DataWindow.HorizontalSlide>
    <inheritdoc />
  </DataWindow.HorizontalSlide>

  <DataWindow.HorizontalSpin>
    <inheritdoc />
  </DataWindow.HorizontalSpin>

  <DataWindow.InsertObject>
    <summary>
      使用标准的插入对象对话框将 OLE 对象插入到数据窗口的焦点 OLEObject 中。
    </summary>
    <remarks>
      DataWindow:InsertObject() 显示标准的插入对象对话框，并允许用户将 OLE 对象插入到 OLEObject 容器中，该容器当前必须具有输入焦点。
    </remarks>
  </DataWindow.InsertObject>

  <DataWindow.IsDialog>
    <exclude />
  </DataWindow.IsDialog>

  <DataWindow.KeyDown>
    <summary>
      此方法是从 Window 类继承的，但不适用于 DataWindow。
    </summary>
  </DataWindow.KeyDown>

  <DataWindow.KeyUp>
    <summary>
      此方法是从 Window 类继承的，但不适用于 DataWindow。
    </summary>
  </DataWindow.KeyUp>

  <DataWindow.LastFocus>
    <exclude />
  </DataWindow.LastFocus>

  <DataWindow.LineTo>
    <summary>
      在此数据窗口上绘制一条线(使用当前的笔)从当前笔位置到指定点。
    </summary>
    <param name="uPoint">
      线应该结束的位置，以画布坐标表示，或者是点的数组，以画布坐标表示，线应该结束的位置，此时 DataWindow:LineTo() 的行为类似于折线方法。
    </param>
    <param name="oPoint">
      线应该结束的位置，以画布坐标表示，或者是点的数组，以画布坐标表示，线应该结束的位置，此时 DataWindow:LineTo() 的行为类似于折线方法。
    </param>
    <remarks> 当前笔位置更新为线的结束位置(由 <paramref name="oPoint" /> 或 <paramref name="aoPoint" /> 指定)。 </remarks>
  </DataWindow.LineTo>

  <DataWindow.Links>
    <summary>
      显示标准的链接对话框。
    </summary>
    <remarks>
      DataWindow:Links() 显示标准的链接对话框，允许用户管理所有链接的 OLE 对象。
    </remarks>
  </DataWindow.Links>

  <DataWindow.ListBoxClick>
    <summary>
      当此数据窗口拥有的列表框中的项目被双击时，提供一个被调用的方法。
    </summary>
    <param name="oControlEvent">描述包含被双击项目的列表框的 ControlEvent 对象。</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </DataWindow.ListBoxClick>

  <DataWindow.ListBoxSelect>
    <summary>
      当此数据窗口拥有的列表框中的项目被单击时，提供一个被调用的方法。
    </summary>
    <param name="oControlEvent">描述包含被单击项目的列表框的 ControlEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <seealso cref="T:VO.ControlEvent" />
  </DataWindow.ListBoxSelect>

  <DataWindow.MouseButtonDown>
    <inheritdoc />
  </DataWindow.MouseButtonDown>

  <DataWindow.MoveTo>
    <summary>
      将当前笔移动到数据窗口的画布区域上的一个点。
    </summary>
    <param name="oPoint">笔的位置，以画布坐标表示。</param>
    <returns>
      一个点，表示笔的上一个位置，以画布坐标表示。
    </returns>
    <remarks>
      笔的位置可能不会在事件处理程序之间记住。
    </remarks>
  </DataWindow.MoveTo>

  <DataWindow.Notify>
    <summary> 
      反映连接到此数据窗口的服务器中发生的事件的事件处理程序。 <br />
      重要！Notify() 由服务器自动调用，通常不应由应用程序代码调用。 
    </summary>
    <returns> 
      SELF，除非在 <paramref name="kNotifyName" /> 中指定了 NOTIFYINTENTTOMOVE。在这种情况下，如果成功，返回值为 TRUE；否则，为 FALSE。
    </returns>
    <include file="VOSDK.xml" path="doc/commonblocks/notify/*" />
  </DataWindow.Notify>

  <DataWindow.OK>
    <summary>
      接受在此数据窗口中输入的所有信息，并关闭窗口。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks> 
      此方法检查窗口的验证状态。<br />
      如果数据有效且正确下载到数据服务器，它会强制向服务器提交，然后关闭窗口。
      “OK”操作非常清晰易懂，可能会在用作 MDI 子窗口的数据窗口上(不管是否非传统)有益地使用。<br />
      请注意，用户可能会对要接受的信息的确切内容感到困惑(例如，在具有嵌套窗口的复杂数据窗口中)。
      如果有任何不确定，您可能会考虑使用更明确的标签来标记按钮或菜单命令。 
      <note type="tip">
        DataWindow:OK() 使用 DataServer:UnregisterClient() 断开与数据服务器的连接，并告诉服务器如果没有其他注册的客户端，它可以关闭自己。<br />
        不建议从窗口显式地强制关闭服务器，因为这可能会在未来创建问题。<br />
        对应用程序的修改可能会将其他客户端附加到服务器，并且任何一个窗口都不应禁用其他窗口。
      </note>
    </remarks>
  </DataWindow.OK>

  <DataWindow.OLEInPlaceActivate>
    <inheritdoc />
  </DataWindow.OLEInPlaceActivate>

  <DataWindow.OLEInPlaceDeactivate>
    <inheritdoc />
  </DataWindow.OLEInPlaceDeactivate>

  <DataWindow.Origin>
    <summary>
      表示此数据窗口的新位置的点，以其所有者的画布坐标表示。
    </summary>
    <value>表示此数据窗口的新位置的点，以其所有者的画布坐标表示。</value>
    <example> 
      以下示例设置数据窗口对象的原点： 
      <code language="X#">
        oDW:Origin := Point{nLeft,nBottom}
      </code>
    </example>
  </DataWindow.Origin>

  <DataWindow.Owner>
    <summary>
      数据窗口的所有者，它本身将是一个 Window 对象。
    </summary>
    <value>数据窗口的所有者，它本身将是一个 Window 对象。</value>
  </DataWindow.Owner>

  <DataWindow.OwnerServer>
    <exclude />
  </DataWindow.OwnerServer>

  <DataWindow.PaintBoundingBox>
    <summary>
      使用指定的绘制方法在数据窗口中的一个矩形区域上绘制。
    </summary>
    <param name="oBB">表示要绘制的数据窗口区域的边界框(组或字符框)，以画布坐标表示。</param>
    <param name="kPM">表示数据窗口区域如何绘制的常量：</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>PAINTFILL</term>
          <description>使用当前选择的画刷填充整个矩形。这是默认值。</description>
        </item>
        <item>
          <term>PAINTFRAME</term>
          <description>使用当前选择的笔对整个矩形进行框架化。</description>
        </item>
        <item>
          <term>PAINTINVERT</term>
          <description>对整个矩形进行反转。</description>
        </item>
      </list>
    </remarks>
  </DataWindow.PaintBoundingBox>

  <DataWindow.Paste>
    <summary>
      使用剪贴板的内容替换此数据窗口中的当前选择。
    </summary>
    <remarks>
      如果数据窗口处于“表单”视图，编辑控件的内容将被剪贴板的内容替换；如果处于“浏览”视图，将替换所选单元格的内容或单元格的部分。
    </remarks>
  </DataWindow.Paste>

  <DataWindow.PasteSpecial>
    <summary>
      使用标准的粘贴特殊对话框将 OLE 对象插入到数据窗口的焦点 OLEObject 中。
    </summary>
    <remarks>
      DataWindow:PasteSpecial() 显示标准的粘贴特殊对话框，并允许用户将剪贴板中的 OLE 对象插入到 OLEObject 容器中，该容器当前必须具有输入焦点。
    </remarks>
  </DataWindow.PasteSpecial>

  <DataWindow.Pointer>
    <summary>
      数据窗口用于表示鼠标进入窗口时的指针。
    </summary>
    <value>数据窗口用于表示鼠标进入窗口时的指针。</value>
  </DataWindow.Pointer>

  <DataWindow.PreValidate>
    <summary>
      在此数据窗口中的任何状态更改后调用，以允许基于当前验证状态启用/禁用控件和菜单命令。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      此方法提供了经典 Xbase @...SAY...GET 语句中 WHEN 子句的一些功能。
      但是，由于 GUI 方法不强制严格的数据输入顺序，而允许用户随机从控件到控件移动，因此启用和禁用控件的逻辑必须不同。<br />
      不是在控件中的焦点切换时检查条件(这太晚了，鼠标的用户已经在新控件上)，系统必须在每个重要事件上不断检查。
      DataWindow:Prevalidate() 通过 DataWindow:RegisterConditionalControls() 提供了这种类型的验证的一些自动处理，
      但它也允许您通过覆盖该方法插入自定义逻辑。
      DataWindow:Prevalidate() 的标准操作是调用 DataWindow:EnableConditionalControls();
      如果存在问题，它会调用 DataWindow:DisableConditionalControls()。<br />
      DataWindow:Prevalidate() 在应用标准验证后调用，允许用户在验证成功或失败时替换默认处理。 
    </remarks>
  </DataWindow.PreValidate>

  <DataWindow.PreventAutoLayout>
    <summary>
      一个逻辑值，指示数据窗口的 AutoLayout 行为是否被阻止(如果是，为 TRUE；如果不是，为 FALSE)。<br />
      当首次使用新的数据服务器时，空数据窗口不会自动创建控件。
    </summary>
    <value>
      一个逻辑值，指示数据窗口的 AutoLayout 行为是否被阻止(如果是，为 TRUE；如果不是，为 FALSE)。<br />
      当首次使用新的数据服务器时，空数据窗口不会自动创建控件。
    </value>
  </DataWindow.PreventAutoLayout>

  <DataWindow.QueryClose>
    <summary>
      提供一个在数据窗口关闭之前调用的方法，以确认应用程序是否真的想要关闭窗口。
    </summary>
    <param name="oQCE">描述即将关闭的数据窗口的事件对象。</param>
    <seealso cref="T:VO.Event" />
    <returns>
      如果数据窗口将被关闭，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      <br /><include file="Gui.xml" path="doc/Callback/*" />
      <note type="tip">
        如果在子类中重新实现此方法，建议首先在方法中调用 SUPER:QueryClose()，以获取其默认行为。
      </note>
      当用户尝试通过从系统菜单中选择关闭菜单命令(或使用其他方法结束会话)来关闭应用程序时，系统会调用每个数据窗口的 QueryClose() 事件处理程序。 
    </remarks>
  </DataWindow.QueryClose>

  <DataWindow.RadioGroups>
    <exclude />
  </DataWindow.RadioGroups>

  <DataWindow.RegisterConditionalControls>
    <summary>
      注册此数据窗口中的控件，使其受验证状态的影响，因此当窗口处于无效状态时，这些控件会自动变暗；当窗口的状态为 OK 时，它们会自动再次启用。
    </summary>
    <param name="oCC">要注册的控件。</param>
    <remarks>
      条件控件允许开发人员注册多个控件，使其受验证的影响。这意味着当窗口未通过验证时，这些控件会自动禁用；当窗口的状态为 OK 时，它们会自动再次启用。<br />
      已注册的控件会根据验证状态的变化自动启用或禁用——DataWindow:Prevalidate() 在窗口的任何状态更改时调用，这是一个重要的事件。<br />
      在实际的数据输入窗口中，所有按钮都会被注册并且会被条件地禁用——SkipNext，SkipPrevious，GoTop，GoBottom，Insert，Delete，OK——除了 Cancel，
      它会丢弃无效的更改，因此应始终可用。
    </remarks>
  </DataWindow.RegisterConditionalControls>

  <DataWindow.RePaint>
    <summary>
      发送一个 ExposeEvent 来重新绘制数据窗口的画布区域。
    </summary>
  </DataWindow.RePaint>

  <DataWindow.RepaintBoundingBox>
    <summary>
      重新绘制数据窗口中的一个矩形区域。
    </summary>
    <param name="oBB">表示要重新绘制的数据窗口区域的边界框(组或字符框)，以画布坐标表示。</param>
    <remarks>
      在 Expose() 事件处理程序中应避免使用此方法。如果使用了该方法，请确保应用程序不会陷入无限循环。
    </remarks>
  </DataWindow.RepaintBoundingBox>

  <DataWindow.Resize>
    <summary>
      提供一个在数据窗口改变大小时调用的方法。
    </summary>
    <param name="oResizeEvent">描述数据窗口画布区域新尺寸的 ResizeEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      在 Resize() 事件处理程序中，应谨慎使用 DataWindow:Size，以避免进入无限循环。 
    </remarks>
  </DataWindow.Resize>

  <DataWindow.Seek>
    <summary>
      基于控制的搜索顺序在与此数据窗口连接的数据服务器中搜索一个值，并根据更改更新窗口。
    </summary>
    <param name="uValue">要搜索的值。其数据类型应与控制的搜索顺序兼容。</param>
    <param name="lSoftSeek"> 
      如果未找到指定的键值，确定如何定位附加的数据服务器：TRUE 执行软搜索；FALSE 不执行。
      如果省略了 <paramref name="lSoftSeek" />，则使用当前的 SetSoftSeek() 设置。 
    </param>
    <param name="lLast">
      是否应选择最后一个匹配的键？
    </param>
    <returns>
      如果成功，则返回 TRUE；否则返回 FALSE。<br />
      请注意，FALSE 值可能表示未找到该值，也可能表示服务器不支持此搜索操作。使用 DataWindow:Status 属性来确定失败的确切原因。
    </returns>
  </DataWindow.Seek>

  <DataWindow.Server>
    <summary>
      当前连接到此数据窗口的 DataServer 对象。如果没有连接服务器，则此值为 NIL。
    </summary>
    <value>当前连接到此数据窗口的 DataServer 对象。如果没有连接服务器，则此值为 NIL。</value>
  </DataWindow.Server>

  <DataWindow.SetAlignStartSize>
    <summary>
      设置表单窗口的起始大小。通常，这个大小是通过第一次对 OwnerAlignment 的分配来设置的，但当尝试自己控制大小时，它可能会很有用。
    </summary>
    <param name="oDataWindow">
      附加到子服务器的窗口；必须是与兼容类型的服务器连接的数据窗口。<br />
      如果省略了，将删除此服务器的所有关系(尽管推荐的做法是使用 DataWindow:ClearRelations() 方法)。
    </param>
    <param name="oSize">表示窗口大小的 Dimension。</param>
  </DataWindow.SetAlignStartSize>

  <DataWindow.SetContextMenu>
    <exclude />
  </DataWindow.SetContextMenu>

  <DataWindow.SetDialog>
    <exclude />
  </DataWindow.SetDialog>

  <DataWindow.SetRelation>
    <summary>
      从与此数据窗口连接的数据服务器到另一个数据服务器的数据服务器设置一个关系，从而在两个服务器和两个窗口之间创建一个所有者-子服务器关系。
    </summary>
    <remarks>
      <note type="tip">
        这个操作可能不被支持，这取决于使用的服务器是否支持关系并且是否是兼容类型的。<br />
        原型实现是提供的标准 Xbase DBServer:SetRelation() 方法。
      </note>
    </remarks>
    <param name="oDWChild">
      附加到子服务器的窗口；必须是与兼容类型的服务器连接的数据窗口。<br />
      如果省略了，将删除此服务器的所有关系(尽管推荐的做法是使用 DataWindow:ClearRelations() 方法)。
    </param>
    <param name="uRelation">
      服务器的关系代码块，表示此服务器的字段的名称或符号；代码块是构造和宏编译的，或者是表示服务器的关系的字段名称或符号的数组。<br />
      字段名称与加号连接，并形成一个代码块，该代码块被宏编译。
    </param>
    <param name="cRelation">
      当关系被指定为代码块时，还可以提供代码块的字符串版本；它由 Relation() 方法返回。
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <example> 
      API 可以采用以下形式： 
      <code language="X#">
        oDWCustomer:SetRelation(oDWOrders, {||_FIELD-&gt;CustNo}, "CustNo")
        oDWCustomer:SetRelation(oDWOrders, #CustNo)
        oDWCustomer:SetRelation(oDWOrders, {#LastName, #Initial, #FirstName})
      </code>
    </example>
  </DataWindow.SetRelation>

  <DataWindow.SetSelectiveRelation>
    <summary>
      从此窗口到子窗口设置一个选择性关系，或者实际上是从此窗口的服务器到另一个窗口的服务器。<br />
      选择性关系是一种限制对子服务器操作的关系，只有符合关系条件的记录才能进行操作。
    </summary>
    <remarks>
      <note type="tip">
        这个操作可能不被支持，这取决于使用的服务器是否支持关系并且是否是兼容类型的。
      </note>
    </remarks>
    <param name="oDWChild">
      附加到子服务器的窗口；必须是与兼容类型的服务器连接的数据窗口。<br />
      如果省略了，将删除此服务器的所有关系(尽管推荐的做法是使用 DataWindow:ClearRelations() 方法)。
    </param>
    <param name="uRelation">
      服务器的关系代码块，表示此服务器的字段的名称或符号；代码块是构造和宏编译的，或者是表示服务器的关系的字段名称或符号的数组。<br />
      字段名称与加号连接，并形成一个代码块，该代码块被宏编译。
    </param>
    <param name="cRelation">
      当关系被指定为代码块时，还可以提供代码块的字符串版本；它由 Relation() 方法返回。
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <example> 
      API 可以采用以下形式： 
      <code language="X#">
        oDWCustomer:SetSelectiveRelation(oDWOrders, {||_FIELD-&gt;CustNo}, "CustNo")
        oDWCustomer:SetSelectiveRelation(oDWOrders, #CustNo)
        oDWCustomer:SetSelectiveRelation(oDWOrders, {#LastName, #Initial, #FirstName})
      </code>
    </example>
  </DataWindow.SetSelectiveRelation>

  <DataWindow.Show>
    <inheritdoc />
  </DataWindow.Show>

  <DataWindow.Size>
    <summary>
      表示数据窗口在画布坐标中的大小的 Dimension。
    </summary>
    <value>表示数据窗口在画布坐标中的大小的 Dimension。</value>
    <example> 
      以下示例设置了一个数据窗口对象的大小： 
      <code language="X#">
        oDW:Size := Dimension{nWidth, nHeight}
      </code>
    </example>
  </DataWindow.Size>

  <DataWindow.Skip>
    <summary>
      在服务器中向前或向后移动指定数量的记录。
    </summary>
    <param name="uRelativePosition">要移动的记录数。正数向前移动，负数向后移动。默认值为+1。</param>
    <returns>
      如果操作成功，则返回 TRUE；否则返回 FALSE。<br />
      Skip() 可能因为多种不同的原因而失败。它可能因为验证失败，可能没有那么多的记录可以移动，可能因为与控制服务器的其他用户的锁冲突而导致的写操作失败，
      或者可能因为服务器由于技术问题而不可用。使用 DataWindow:Status 来确定失败的原因。
    </returns>
    <remarks>
      这个方法受到验证的影响(即，如果窗口中的数据未通过验证，移动操作将被拒绝)。<br />
      该方法并不会在移动后显式刷新窗口的内容；这是由随后的 NotifyRecordChange 消息自动完成的。
      由于它接受一个数值参数，因此 Skip() 方法很少直接与按钮或菜单命令连接：对于简单的移动，使用 SkipNext() 和 SkipPrevious() 方法。
      Skip() 提供了很大的灵活性，但通常是从代码中调用的，在数据窗口的方法中。
    </remarks>
  </DataWindow.Skip>

  <DataWindow.SkipNext>
    <summary>
      移动到下一条记录(与 Skip(1) 相同)。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </DataWindow.SkipNext>

  <DataWindow.SkipPrevious>
    <summary>
      移动到上一条记录(与 Skip(-1) 相同)。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </DataWindow.SkipPrevious>

  <DataWindow.Status>
    <summary>
      标识此数据窗口在最后一次操作后的状态的超链接标签。
    </summary>
    <value>标识此数据窗口在最后一次操作后的状态的超链接标签。</value>
    <remarks>
      标识此数据窗口在最后一次操作后的状态的超链接标签。<br />
      如果最后一次操作成功，这个值为 NULL_OBJECT；<br />
      如果出现问题(无论是引发了错误条件还是仅仅返回了失败代码)，DataWindow:Status 会返回一个信息丰富的超链接标签。
    </remarks>
    <example> 
      以下示例调用了数据服务器的几个 DataWindow:Status 属性： 
      <code language="X#">
        oDataWindow:Status:Caption
        oDataWindow:Status:Description
        oDataWindow:Status:HelpContext
      </code>
    </example>
  </DataWindow.Status>

  <DataWindow.StatusBar>
    <exclude />
  </DataWindow.StatusBar>

  <DataWindow.StatusOK>
    <summary>
      通过返回代码和设置 DataWindow:Status 属性来指示窗口的当前验证状态。
    </summary>
    <remarks>
      StatusOK() 会扫描窗口上的所有控件，查找无效的状态。<br />
      如果找到了无效的控件状态，方法会返回 TRUE。使用 DataWindow:Status 属性来确定哪个控件返回了无效的状态。<br />
      否则，StatusOK() 会返回 FALSE。
    </remarks>
  </DataWindow.StatusOK>

  <DataWindow.SubForms>
    <exclude />
  </DataWindow.SubForms>

  <DataWindow.Surface>
    <exclude />
  </DataWindow.Surface>

  <DataWindow.symFormDialog>
    <exclude />
  </DataWindow.symFormDialog>

  <DataWindow.TextPrint>
    <summary>
      使用当前字体和当前笔颜色，在指定位置在数据窗口上显示给定的字符串。
    </summary>
    <param name="cText">要打印的字符串。</param>
    <param name="oPoint">字符串原点的位置，以画布坐标表示。</param>
  </DataWindow.TextPrint>

  <DataWindow.ToolBarHeightChanged>
    <inheritdoc />
  </DataWindow.ToolBarHeightChanged>

  <DataWindow.Undo>
    <summary>
      撤销最近在此数据窗口中进行的更改。
    </summary>
    <remarks>
      如果数据窗口处于“表单”视图，这适用于更改当前编辑控件的内容；如果处于“浏览”视图，这适用于在数据浏览器中对单元格进行的更改。
    </remarks>
  </DataWindow.Undo>

  <DataWindow.UndoAll>
    <summary>
      撤销自上次记录移动或 Commit() 操作以来在此数据窗口中进行的所有更改。
    </summary>
    <remarks>
      在对这条记录进行了长时间的一系列更改后，DataWindow:UndoAll() 方法会将记录恢复到最初访问时的值。<br />
      但是，该方法并不提供恢复对多条记录进行的更改的功能；一旦服务器移出了一条记录，这些更改就会被 DataWindow:UndoAll() 视为永久的。<br />
      如果数据窗口处于“表单”视图，这适用于更改当前编辑控件的内容；如果处于“浏览”视图，这适用于在数据浏览器中对行进行的更改。
    </remarks>
  </DataWindow.UndoAll>

  <DataWindow.UpdateActiveObject>
    <summary>
      更新任何处于激活状态的 OLE 对象的工具栏。
    </summary>
    <remarks>
      OLEDataWindow:UpdateActiveObject() 调用 OLE 数据窗口包含的任何当前激活的 OLE 对象的 UpdateTools() 方法。<br />
      它首先确定哪个 OLE 对象控件是就地激活的，然后用 OLE 服务器的工具栏替换 X# 容器应用程序的工具栏。<br />
      对容器应用程序的大小调整作出响应时，这个方法会导致 OLE 对象服务器重新排列其工具栏。
    </remarks>
  </DataWindow.UpdateActiveObject>

  <DataWindow.Use>
    <summary>
      在客户端-服务器关系中连接数据窗口到数据服务器。
    </summary>
    <param name="oDataServer">
      要连接到的数据服务器对象。如果窗口已经连接到一个服务器，首先会断开连接。<br />
      如果省略了服务器参数，则服务器不会连接到任何窗口。
    </param>
    <returns>
      如果连接成功，则返回 TRUE；否则，返回 FALSE。<br />
      操作在以下情况下会失败：如果窗口有控件和列，但没有一个与服务器的字段名称匹配的，当然，如果服务器存在技术问题。
    </returns>
    <remarks>
      Use() 方法根据匹配的名称将控件和浏览器列与数据服务器的字段连接起来。<br />
      任何没有明确提供字段规范和超链接的控件都将从其数据服务器字段继承字段规范和超链接。<br />
      如果窗口没有任何控件或列，Use() 方法将自动为服务器中的所有字段创建一个布局，包括控件或列。每个视图—数据窗口和浏览—只在需要时创建布局。<br />
      Use() 还使用 DataServer:RegisterClient() 方法将窗口注册为服务器的客户端。
    </remarks>
  </DataWindow.Use>

  <DataWindow.ValidateRecord>
    <summary>
      如果开发人员提供了，当您尝试更改记录时，X# 会调用 ValidateRecord()。
    </summary>
    <returns>
      如果当前记录中的所有字段都有效，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      数据窗口类中不存在此方法的默认版本。<br />
      如果提供了记录级别的验证方法，它应该返回一个逻辑值，指示窗口是否总体有效。<br />
      如果返回 FALSE，方法应该将窗口的 Status 属性设置为一个 HyperLabel 对象，该对象至少包含一个适当的描述和可能还有一个帮助上下文标签。<br />
      ValidateRecord() 可以用于执行跨字段的验证，例如“奖金不能超过工资的一半，且不能超过6级及以下的10000”和“如果州是NY，税务申报信息必须填写”。<br />
      虽然可以为单个控件指定这样的验证规则，并保持控件彼此独立。
      这提高了代码的可重用性，使控件和其字段规范可以在窗口上的其他内容无关的情况下使用。
    </remarks>
  </DataWindow.ValidateRecord>

  <DataWindow.VerticalScroll>
    <summary>
      当垂直滚动条滚动时，提供一个被调用的方法。
    </summary>
    <param name="oScrollEvent">描述滚动类型和新位置的 ScrollEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      此事件处理程序的默认行为是更新滚动条的拇指位置；可以通过自己的事件处理程序实现更改。<br />
      此事件处理程序仅适用于 HorizontalScrollBar 和 WindowHorizontalScrollBar 对象。<br />
      如果应用程序有水平滚动条，使用 HorizontalScrollBar 事件处理程序。
    </remarks>
  </DataWindow.VerticalScroll>

  <DataWindow.VerticalSlide>
    <inheritdoc />
  </DataWindow.VerticalSlide>

  <DataWindow.VerticalSpin>
    <inheritdoc />
  </DataWindow.VerticalSpin>

  <DataWindow.ViewAs>
    <summary>
      指定数据窗口的视图模式，即浏览视图或表单视图。
    </summary>
    <param name="symViewType"> 
      指定要使用的视图模式。使用以下符号之一： 
      <list type="table">
        <listheader>
          <term>符号</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>#BrowseView </term>
          <description>多条记录同时显示，作为电子表格样式的表格行，每个字段对应一个列。</description>
        </item>
        <item>
          <term>#FormView </term>
          <description>一次只显示一条记录，其字段在各自的控件中显示。</description>
        </item>
      </list>
    </param>
    <remarks>
      当窗口切换到新的视图模式时，如果之前没有定义布局，将自动生成一个布局。<br />
      由于它需要一个参数，DataWindow:ViewAs() 很少直接与按钮或菜单命令连接；而是使用 DataWindow:ViewForm() 和 DataWindow:ViewTable() 方法。
    </remarks>
  </DataWindow.ViewAs>

  <DataWindow.ViewForm>
    <summary>
      为数据窗口选择表单视图。
    </summary>
  </DataWindow.ViewForm>

  <DataWindow.ViewTable>
    <summary>
      为数据窗口选择浏览视图。
    </summary>
  </DataWindow.ViewTable>

  <DateFS>
    <summary>
      创建一个日期字段规范，其中包含日期数据类型信息。
    </summary>
  </DateFS>

  <DateFS.ctor>
    <summary>
      构造一个日期规范。
    </summary>
    <param name="oHLName">包含要用于创建新日期字段规范的字段名称和其他属性(即，标题，描述和帮助上下文)的超级标签。</param>
  </DateFS.ctor>

  <DateRange>
    <summary>
      由 DateTimePicker 和 MonthCalendar 控件使用的辅助类，用于表示日期范围。
    </summary>
    <remarks>
      DateRange 类封装了 MonthCalendar 和 DateTimePicker 类的各种方法所期望的日期范围。
    </remarks>
  </DateRange>

  <DateRange.ctor>
    <summary>
      构造一个 DateRange 对象。
    </summary>
    <param name="dStart">日期范围的开始日期。如果省略，将默认为 Today()。</param>
    <param name="dEnd">日期范围的结束日期。如果省略，将默认为 Today()。</param>
  </DateRange.ctor>

  <DateRange.Max>
    <summary>
      表示日期范围的上限日期。
    </summary>
    <value>表示日期范围的上限日期。</value>
  </DateRange.Max>

  <DateRange.Min>
    <summary>
      表示日期范围的下限日期。
    </summary>
    <value>表示日期范围的下限日期。</value>
  </DateRange.Min>

  <DateTimePicker>
    <summary>
      封装一个 DateTimePicker 控件。
    </summary>
    <remarks> 
      DateTimePicker 控件允许用户选择日期或时间。 
      <note type="tip">
        使用 DateTimePicker 控件需要 COMCTL32.DLL 的 4.70 或更高版本。
      </note>
    </remarks>
  </DateTimePicker>

  <DateTimePicker.ctor>
    <summary>
      构造一个 DateTimePicker 对象。
    </summary>
    <param name="oOwner">拥有 DateTimePicker 对象的窗口。</param>
    <param name="xID">DateTimePicker 对象的唯一ID(在1和8000之间)。</param>
    <param name="oPoint">DateTimePicker 对象在画布坐标中的原点。</param>
    <param name="oDimension">DateTimePicker 对象在画布坐标中的尺寸。</param>
    <param name="dwStyle">
      表示 DateTimePicker 对象样式的常量，可以通过 X# 样式常量或 Windows API 样式常量指定。可以使用 _Or() 运算符组合样式。
    </param>
    <param name="lDataAware">如果 DateTimePicker 对象是数据感知的，则为 TRUE；否则为 FALSE。如果省略，将默认为 TRUE。</param>
    <param name="nResourceID">DateTimePicker 对象的资源ID。</param>
    <remarks>
      <note type="tip">
        请参阅 Microsoft Win32 软件开发工具包文档，了解有关特定样式常量的详细信息。
      </note>
    </remarks>
  </DateTimePicker.ctor>

  <DateTimePicker.DateRange>
    <summary>
      设置 DateTimePicker 控件允许的日期范围的 DateRange 对象。
    </summary>
    <value>设置 DateTimePicker 控件允许的日期范围的 DateRange 对象。</value>
  </DateTimePicker.DateRange>

  <DateTimePicker.Format>
    <summary>
      设置 DateTimePicker 控件的显示格式。赋值需要一个包含以下任一片段的字符串：
    </summary>
    <value>设置 DateTimePicker 控件的显示格式。赋值需要一个包含以下任一片段的字符串：</value>
    <remarks> 
      设置 DateTimePicker 控件的显示格式。赋值需要一个包含以下任一片段的字符串： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>"d"</term>
          <description>一位或两位的日。</description>
        </item>
        <item>
          <term>"dd"</term>
          <description>两位的日。单位位的日值前面加0。</description>
        </item>
        <item>
          <term>"ddd"</term>
          <description>三个字符的星期几缩写。</description>
        </item>
        <item>
          <term>"dddd"</term>
          <description>完整的星期几名称。</description>
        </item>
        <item>
          <term>"h"</term>
          <description>12小时制中的一位或两位的小时。</description>
        </item>
        <item>
          <term>"hh"</term>
          <description>12小时制中的两位的小时。单位位的小时值前面加0。</description>
        </item>
        <item>
          <term>"H"</term>
          <description>24小时制中的一位或两位的小时。</description>
        </item>
        <item>
          <term>"HH"</term>
          <description>24小时制中的两位的小时。单位位的小时值前面加0。</description>
        </item>
        <item>
          <term>"m"</term>
          <description>一位或两位的分钟。</description>
        </item>
        <item>
          <term>"mm"</term>
          <description>两位的分钟。单位位的分钟值前面加0。</description>
        </item>
        <item>
          <term>"M"</term>
          <description>一位或两位的月份。</description>
        </item>
        <item>
          <term>"MM"</term>
          <description>两位的月份。单位位的月份值前面加0。</description>
        </item>
        <item>
          <term>"MMM"</term>
          <description>三个字符的月份缩写。</description>
        </item>
        <item>
          <term>"MMMM"</term>
          <description>完整的月份名称。</description>
        </item>
        <item>
          <term>"t"</term>
          <description>一位字母的AM/PM缩写(即，AM显示为"A")。</description>
        </item>
        <item>
          <term>"tt"</term>
          <description>两位字母的AM/PM缩写(即，AM显示为"AM")。</description>
        </item>
        <item>
          <term>"y"</term>
          <description>一位年份(即，1999显示为"9")。</description>
        </item>
        <item>
          <term>"yy"</term>
          <description>年份的最后两位(即，1999显示为"99")。</description>
        </item>
        <item>
          <term>"yyy"</term>
          <description>完整的年份(即，1999显示为"1999")。</description>
        </item>
      </list>
    </remarks>
    <example> 
      本示例仅在日期时间选择器控件上显示当前时间： 
      <code language="X#">
        oDTPicker:Format := "hh:mm:ss" // 10:23:14
      </code>
      本示例显示一个字符串以及日期： 
      <code language="X#">
        ODTPicker:Format := "'Today is' dddd, MMMM d, yyy"
        // Today is Friday, April 9, 1999
      </code>
    </example>
  </DateTimePicker.Format>

  <DateTimePicker.IsNone>
    <exclude />
  </DateTimePicker.IsNone>

  <DateTimePicker.IsTimePicker>
    <exclude />
  </DateTimePicker.IsTimePicker>

  <DateTimePicker.MCBackgroundColor>
    <summary>
      描述 MonthCalendar 弹出窗口的背景颜色(在月份之间)，如果 DateTimePicker 处于日期模式。
    </summary>
    <value>描述 MonthCalendar 弹出窗口的背景颜色(在月份之间)，如果 DateTimePicker 处于日期模式。</value>
  </DateTimePicker.MCBackgroundColor>

  <DateTimePicker.MCFont>
    <summary>
      指定 MonthCalendar 弹出窗口的字体的 Font 对象，如果 DateTimePicker 处于日期模式。
    </summary>
    <value>指定 MonthCalendar 弹出窗口的字体的 Font 对象，如果 DateTimePicker 处于日期模式。</value>
  </DateTimePicker.MCFont>

  <DateTimePicker.MCMonthBackgroundColor>
    <summary>
      描述 MonthCalendar 弹出窗口的背景颜色(在月份区域内)，如果 DateTimePicker 处于日期模式。
    </summary>
    <value>描述 MonthCalendar 弹出窗口的背景颜色(在月份区域内)，如果 DateTimePicker 处于日期模式。</value>
  </DateTimePicker.MCMonthBackgroundColor>

  <DateTimePicker.MCTextColor>
    <summary>
      描述 MonthCalendar 弹出窗口的文本颜色，如果 DateTimePicker 处于日期模式。
    </summary>
    <value>描述 MonthCalendar 弹出窗口的文本颜色，如果 DateTimePicker 处于日期模式。</value>
  </DateTimePicker.MCTextColor>

  <DateTimePicker.MCTitleBackgroundColor>
    <summary>
      描述 MonthCalendar 弹出窗口的标题背景颜色，如果 DateTimePicker 处于日期模式。
    </summary>
    <value>描述 MonthCalendar 弹出窗口的标题背景颜色，如果 DateTimePicker 处于日期模式。</value>
  </DateTimePicker.MCTitleBackgroundColor>

  <DateTimePicker.MCTitleTextColor>
    <summary>
      描述 MonthCalendar 弹出窗口的标题文本颜色，如果 DateTimePicker 处于日期模式。
    </summary>
    <value>描述 MonthCalendar 弹出窗口的标题文本颜色，如果 DateTimePicker 处于日期模式。</value>
  </DateTimePicker.MCTitleTextColor>

  <DateTimePicker.MCTrailingTextColor>
    <summary>
      描述 MonthCalendar 弹出窗口的尾随和前导天的颜色，即不属于当前月份的那些天，如果 DateTimePicker 处于日期模式。
    </summary>
    <value>描述 MonthCalendar 弹出窗口的尾随和前导天的颜色，即不属于当前月份的那些天，如果 DateTimePicker 处于日期模式。</value>
  </DateTimePicker.MCTrailingTextColor>

  <DateTimePicker.NullFormat>
    <exclude />
  </DateTimePicker.NullFormat>

  <DateTimePicker.ParentNotify>
    <exclude />
  </DateTimePicker.ParentNotify>

  <DateTimePicker.PerformValidations>
    <exclude />
  </DateTimePicker.PerformValidations>

  <DateTimePicker.SelectedDate>
    <summary>
      指定当前选择的日期。
    </summary>
    <value>指定当前选择的日期。</value>
  </DateTimePicker.SelectedDate>

  <DateTimePicker.SelectedTime>
    <summary>
      指定当前选择的时间的字符串(格式为"HH:MM:SS")。
    </summary>
    <value>指定当前选择的时间的字符串(格式为"HH:MM:SS")。</value>
  </DateTimePicker.SelectedTime>

  <DateTimePicker.SetDateTime>
    <exclude />
  </DateTimePicker.SetDateTime>

  <DateTimePicker.TextValue>
    <summary>
      字符串格式的当前值。这在内部是必需的，以允许 DateTimePicker 控件与数据库字段的绑定。
    </summary>
    <value>字符串格式的当前值。这在内部是必需的，以允许 DateTimePicker 控件与数据库字段的绑定。</value>
  </DateTimePicker.TextValue>

  <DateTimePicker.Value>
    <exclude />
  </DateTimePicker.Value>

  <DateTimeSelectionEvent>
    <summary>
      提供有关日期时间选择事件的信息，该事件在用户在 DateTimePicker 控件中选择日期或时间时生成。
    </summary>
    <remarks>
      当在 DateTimePicker 控件中选择日期时，会触发此事件。
    </remarks>
  </DateTimeSelectionEvent>

  <DateTimeSelectionEvent.ctor>
    <inheritdoc />
  </DateTimeSelectionEvent.ctor>

  <DateTimeSelectionEvent.SelectedDate>
    <summary>
      指示用户在控件中选择的日期的日期值
    </summary>
    <value>指示用户在控件中选择的日期的日期值</value>
  </DateTimeSelectionEvent.SelectedDate>

  <DateTimeSelectionEvent.SelectedTime>
    <summary>
      指示用户在控件中选择的时间的字符串值
    </summary>
    <value>指示用户在控件中选择的时间的字符串值</value>
  </DateTimeSelectionEvent.SelectedTime>

  <DDECallbackDelegate.ctor>
    <exclude />
  </DDECallbackDelegate.ctor>

  <DDECallbackDelegate.BeginInvoke>
    <exclude />
  </DDECallbackDelegate.BeginInvoke>

  <DDECallbackDelegate.EndInvoke>
    <exclude />
  </DDECallbackDelegate.EndInvoke>

  <DDECallbackDelegate.Invoke>
    <exclude />
  </DDECallbackDelegate.Invoke>

  <DialogWindow>
    <summary>
      创建一个对话框窗口(通常也称为对话框框)，允许应用程序和最终用户进行交互。这种对话框可以是模态的，也可以是非模态的(请参阅下面的描述)。
    </summary>
    <remarks> 
      对话框窗口是呈现用户 I/O 控件的窗口。它们还有一个结果代码，指示用户对话框交互的结果(例如，如果用户在对话框中按下了 OK 或 Cancel 按钮)。<br />
      大多数窗口系统区分模态和非模态对象。<br />
      模态对象必须在当前执行线程继续之前被确认；相反，非模态对象不会影响当前执行线程。
      当对话框框是模态的时，必须进一步区分系统模态和应用程序模态对象。
      系统模态对象必须在任何正在运行的应用程序创建的任何窗口(包括 Windows 桌面)中的任何执行之前被确认，应用程序模态对象，
      另一方面，必须在当前应用程序中的任何执行之前被确认(即，用户可以访问由其他应用程序创建的窗口)。<br />
      默认情况下，对话框窗口是应用程序模态的。但是，通过在 DialogWindow:Init() 方法的 <paramref name="lModal" /> 标志中分配 FALSE ，
      可以使其成为非模态的。<br />
      您也可能只想创建一个非模态的对话框框。
    </remarks>
  </DialogWindow>

  <DialogWindow.ctor>
    <summary>
      构造一个对话框窗口。
    </summary>
    <param name="oOwner">拥有对话框窗口的窗口。</param>
    <param name="xResourceID">所需对话框窗口的资源ID。</param>
    <param name="lModal">TRUE创建一个模态对话框窗口；FALSE，一个非模态的。默认为 TRUE。</param>
    <remarks>
      <note type="tip"> 
        在不使用 Window Editor 创建窗口时，DialogWindow 类和所有其他 Window 类之间存在差异。 使用其他窗口类，可以编写如下代码 - 
        <code language="X#">
          LOCAL oDW AS DataWindow
          oDW := DataWindow{ oOwner }
          oDW:Show( )
        </code>
        但是，这段代码不会工作 - 
        <code language="X#">
          LOCAL oDW AS DialogWindow
          oDW := DialogWindow{ oOwner }
          oDW:Show( )
        </code>
        可以使用生成的资源为空白的 DialogWindow 并从中继承。另一种选择是这样做 - 
        <code language="X#">
          oWin := DialogWindow{ oOwner, "IDD_DEFDLG2", TRUE }
          oWin:Size := Dimension{ 100 , 100 }
          oWin:Show( SHOWCENTERED )
        </code>
        或 
        <code language="X#">
          oWin := DialogWindow{ oOwner, "IDD_DEFDLG", FALSE }
          oWin:Size := Dimension{ 100 , 100 }
          oWin:Show( )
        </code>
        这两段代码之间的区别是：<br />
        1 第一个使用"IDD_DEFDLG2"资源ID并将模态属性设置为 TRUE。这将创建一个普通样式的对话框窗口，被称为弹出式对话框。
        2 第二个使用"IDD_DEFDLG"资源ID并将模态属性设置为 FALSE。这是作为选项卡页使用的对话框窗口样式，被称为子对话框。
      </note>
    </remarks>
  </DialogWindow.ctor>

  <DialogWindow.Activate>
    <inheritdoc />
  </DialogWindow.Activate>

  <DialogWindow.Active>
    <inheritdoc />
  </DialogWindow.Active>

  <DialogWindow.ButtonClick>
    <summary>
      当鼠标点击复选框、按钮或单选按钮时，提供一个被调用的方法。
    </summary>
    <param name="oControlEvent">描述哪个按钮被点击的 ControlEvent 对象。</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      按钮点击事件与 MenuEvents 一样，会传播到对话框窗口的所有者。<br />
      有关命令事件传播的深入讨论，请参阅程序员指南。<br />
      当用户点击单选按钮时，必须提供代码来打开(并关闭所有其他单选按钮)单选按钮。类似地，当单击复选框时，必须确保反转复选框的状态。 
    </remarks>
  </DialogWindow.ButtonClick>

  <DialogWindow.ChangeFont>
    <summary>
      更改此对话框窗口使用的字体。
    </summary>
    <param name="oFont">要使用的新字体。</param>
    <param name="lRescale">指定 TRUE 以调整和重新定位此对话框窗口中的所有控件并更改它们的字体；否则，FALSE。如果省略，缺省值为 FALSE。</param>
    <returns>
      先前分配给对话框窗口的字体。
    </returns>
  </DialogWindow.ChangeFont>

  <DialogWindow.ClipperKeys>
    <exclude />
  </DialogWindow.ClipperKeys>

  <DialogWindow.ControlFocusChange>
    <summary>当输入焦点从控件到控件或从控件返回到控件时，提供一个被调用的方法。</summary>
    <param name="oControlFocusChangeEvent">描述生成 ControlFocusChangeEvent 对象的哪个控件并且它是否刚刚获得或失去了键盘焦点。</param>
    <remarks>
      如果 ControlFocusChange() 用于验证一个控件(并且还将焦点返回到另一个控件)，
      则不应在另一个控件获得焦点之前调用 Control:SetFocus()。<br />
      在包含许多编辑控件的复杂对话框窗口中，当焦点正在改变时，抓取编辑控件的文本是有意义的，这样，如果需要，其他控件就可以使用它来更新。
      请参阅 ButtonClick() 方法，以了解在此方法中使用类似语法的示例。<br />
      请注意，所有控件都会通过此方法，不仅仅是 SingleLineEdit 和 MultiLineEdit 控件。
      如果要控制 Combobox 的选择，那么应该查看 ListBoxSelect() 回调方法。
    </remarks>
    <seealso cref="T:VO.ControlFocusChangeEvent" />
    <param name="oControlFocusChangeEvent">** 缺少参数文档 **</param>
  </DialogWindow.ControlFocusChange>

  <DialogWindow.DeActivate>
    <inheritdoc />
  </DialogWindow.DeActivate>

  <DialogWindow.Default>
    <inheritdoc />
  </DialogWindow.Default>

  <DialogWindow.Destroy>
    <summary>
      释放为对话框窗口及其派生对象分配的内存资源。
    </summary>
    <remarks>
      此方法立即释放在应用程序中显式创建的 DialogWindow 对象的资源。<br />
      DialogWindow:Destroy() 还会处理为派生类分配的资源，并按照必要的顺序对其进行解分配。
    </remarks>
  </DialogWindow.Destroy>

  <DialogWindow.EditChange>
    <summary>
      当编辑控件中的文本更改时，提供一个被调用的方法。
    </summary>
    <param name="oControlEvent">描述哪个编辑控件被更改的 ControlEvent 对象。</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </DialogWindow.EditChange>

  <DialogWindow.EditFocusChange>
    <summary>
      当输入焦点从编辑控件到编辑控件或从编辑控件返回到编辑控件时，提供一个被调用的方法。
    </summary>
    <param name="oEditFocusChangeEvent">描述生成 EditFocusChangeEvent 对象的哪个编辑控件并且它是否刚刚获得或失去了键盘焦点。</param>
    <seealso cref="T:VO.EditFocusChangeEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      如果 DialogWindow:EditFocusChange() 用于验证编辑控件(并且如果无效，还将焦点返回到它)，则不应在另一个控件获得焦点之前调用 Control:SetFocus()。<br />
      在包含许多编辑控件的复杂对话框窗口中，当焦点正在改变时，抓取编辑 控件的文本是有意义的，这样，如果需要，其他控件就可以使用它来更新。 
    </remarks>
  </DialogWindow.EditFocusChange>

  <DialogWindow.EndDialog>
    <summary>
      从视图中移除此对话框窗口(将控制权返回到创建对话框窗口的例程)并发布指示它是如何关闭的结果代码。
    </summary>
    <param name="iResult">应该发布的结果代码。默认为0。</param>
    <example>
      <note type="tip">
        然后，可以将此结果代码传递给显示对话框窗口的例程，如果该例程调用了 DialogWindow:Result。
      </note>
      以下示例指示 EndDialog() 如果按下了 Cancel 按钮，则返回0，如果按下了 OK，则返回1： 
      <code language="X#">
        METHOD ButtonClick(oEvent) CLASS MyDialogWindow
            IF oEvent:nControlID == ID_OK
                SELF:EndDialog(1)
            ENDIF

            IF oEvent:nControlID == ID_CANCEL
                SELF:EndDialog(0)
            ENDIF
      </code>
    </example>
  </DialogWindow.EndDialog>

  <DialogWindow.ExecModal>
    <summary>
      允许程序员更好地控制对话框窗口中的 Windows 消息处理。
    </summary>
    <remarks>
      通常，对话框窗口会导致程序执行在窗口显示时暂停，然后一旦窗口关闭，程序就会继续。ExecModal( ) 的默认行为维持了预期的行为。<br />
      但是，程序员可以创建一个新类，该类继承自 DialogWindow，并实现一个新的 ExecModal() 方法，以更改此行为。
    </remarks>
    <example> 
        例如，程序员可以使用以下版本，该版本不执行任何操作： 
        <code language="X#">
          METHOD ExecModal() CLASS DialogWindow
              RETURN NIL
        </code>
        现在，在调用 Show() 方法后，程序控制立即返回。这对于需要使用函数 ApplicationExec(EXECWHILEEVENT) 控制窗口调度程序循环的代码非常有用： 
        <code language="X#">
          METHOD xyz() CLASS xyz
              LOCAL oPDlg AS ProgressDialog // 继承自 DialogWindow

              oPDlg := ProgressDialog{SELF, "处理中!"}
              oPDlg:Count := oServer:Reccount
              oPDlg:Show()

              // ProgressDialog 是模态的，用户在处理期间
              // 除了代码允许的操作外不能做任何事情。
              // 在这个例子中，你可以中止循环。

              oServer:GoTop()

              DO WHILE oServer:EOF
                  IF ! oPDlg:STEP() // 如果按下中止按钮则为 FALSE
                  EXIT
                  ENDIF
                  // 执行某些操作
                  oServer:Skip()
              ENDDO

              oPDlg:EndDialog()
        </code>
    </example>
  </DialogWindow.ExecModal>

  <DialogWindow.Font>
    <summary>
      在此对话框窗口中使用的字体。
    </summary>
    <value>在此对话框窗口中使用的字体。</value>
  </DialogWindow.Font>

  <DialogWindow.Handle>
    <summary>
      返回对话框窗口的句柄。
    </summary>
    <param name="nHandleType">所需句柄的类型。指定 0 获取窗口句柄，指定 2 获取窗口设备上下文。如果省略，0 为默认。</param>
    <returns>
      描述底层系统对象的窗口的句柄。
    </returns>
    <remarks>
      此方法提供了窗口的句柄，然后可以通过 Windows API 调用使用它。
    </remarks>
  </DialogWindow.Handle>

  <DialogWindow.HelpRequest>
    <exclude />
  </DialogWindow.HelpRequest>

  <DialogWindow.HorizontalScroll>
    <summary>
      当水平滚动条滚动时，提供一个被调用的方法。
    </summary>
    <param name="oScrollEvent">描述滚动类型和新位置的 ScrollEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      此事件处理程序的默认行为是更新滚动条的拇指位置；可以通过自己的事件处理程序实现更改。<br />
      此事件处理程序仅适用于 HorizontalScrollBar 和 WindowHorizontalScrollBar 对象。<br />
      如果应用程序有垂直滚动条，使用 WindowVerticalScrollBar 事件处理程序。
    </remarks>
  </DialogWindow.HorizontalScroll>

  <DialogWindow.IsModal>
    <exclude />
  </DialogWindow.IsModal>

  <DialogWindow.LastFocus>
    <exclude />
  </DialogWindow.LastFocus>

  <DialogWindow.ListBoxClick>
    <summary>
      提供一个方法，当此对话框窗口拥有的列表框中的项目被双击时，该方法将被调用。
    </summary>
    <param name="oControlEvent">描述双击的列表框中包含的项目的 ControlEvent 对象。</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </DialogWindow.ListBoxClick>

  <DialogWindow.ListBoxSelect>
    <summary>
      提供一个方法，当此窗口拥有的列表框中的项目被单击时，该方法将被调用。
    </summary>
    <param name="oControlEvent">描述单击的列表框中包含的项目的 ControlEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <seealso cref="T:VO.ControlEvent" />
  </DialogWindow.ListBoxSelect>

  <DialogWindow.Owner>
    <exclude />
  </DialogWindow.Owner>

  <DialogWindow.PostShowDialog>
    <exclude />
  </DialogWindow.PostShowDialog>

  <DialogWindow.Result>
    <summary>
      当此对话框窗口关闭时，由 DialogWindow:EndDialog() 方法返回的系统的数值结果代码。
    </summary>
    <value>当此对话框窗口关闭时，由 DialogWindow:EndDialog() 方法返回的系统的数值结果代码。</value>
    <remarks> 
      当此对话框窗口关闭时，由 DialogWindow:EndDialog() 方法返回的系统的数值结果代码
      (例如，如果按下了取消按钮，则可能会返回 0，如果按下了确定按钮，则可能会返回 1)。 
      <note type="tip">
        DialogWindow:Result 应该由显示对话框窗口的所有者的方法调用，以确定关闭对话框窗口的操作。
      </note>
    </remarks>
  </DialogWindow.Result>

  <DialogWindow.Show>
    <inheritdoc />
  </DialogWindow.Show>

  <DialogWindow.ShowModal>
    <summary>这是显示 DialogWindow 的工作方法</summary>
    <param name="lActive">** 缺少参数文档 **</param>
  </DialogWindow.ShowModal>

  <DialogWindow.StatusMessage>
    <summary>
      在 shell 窗口的状态栏中显示一条消息。
    </summary>
    <param name="oHyperLabel">包含状态消息的描述(HyperLabel:Description)的超链接标签。</param>
    <param name="kMessageType">
      指示要在状态栏上显示的消息的类型和优先级的常量值。<br />
      有关更多信息，请参见备注部分。
    </param>
    <remarks>
      最高优先级的消息(MESSAGEMENU)始终优先于并替换较低优先级的消息。
      <list type="table">  
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>MESSAGEMENU</term>
          <description>优先级4(最高优先级)：与菜单选择相关联的消息。</description>
        </item>
        <item>
          <term>MESSAGEERROR</term>
          <description>优先级3：错误消息。</description>
        </item>
        <item>
          <term>MESSAGECONTROL</term>
          <description>优先级2：与控件相关联的消息。</description>
        </item>
        <item>
          <term>MESSAGEPERMANENT</term>
          <description> 优先级1(最低优先级)：状态栏上显示的默认消息；当更高优先级的消息优先并重新显示时，当没有其他消息优先时重新显示。这是<b>默认</b>。 </description>
        </item>
      </list>
    </remarks>
  </DialogWindow.StatusMessage>

  <DialogWindow.VerticalScroll>
    <summary>
      提供一个方法，当垂直滚动条滚动时，该方法将被调用。
    </summary>
    <param name="oScrollEvent">描述滚动类型和新位置的 ScrollEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      此事件处理程序的默认行为是更新滚动条的拇指位置；可以通过自己的事件处理程序实现更改。<br />
      此事件处理程序仅适用于 HorizontalScrollBar 和 WindowHorizontalScrollBar 对象。<br />
      如果应用程序有水平滚动条，使用 HorizontalScrollBar 事件处理程序。
    </remarks>
  </DialogWindow.VerticalScroll>

  <Dimension>
    <summary>
      创建一个 Dimension 对象，该对象用于使用有序对坐标(宽度，高度或x，y)描述二维对象的大小。
    </summary>
    <remarks>
      <note type="tip">
        当使用 Dimension 描述不规则形状的对象时，它指定可以完全包围对象的最小边界框的大小。
      </note>
    </remarks>
  </Dimension>

  <Dimension.ctor>
    <summary>
      构造一个维度。
    </summary>
    <param name="nWidth">维度的宽度，默认为0，从 CLASS Pair 继承。</param>
    <param name="nHeight">维度的高度，默认为0，从 CLASS Pair 继承。</param>
  </Dimension.ctor>

  <Dimension.Height>
    <summary>
      代表此维度高度的数值值。
    </summary>
    <value>代表此维度高度的数值值。</value>
  </Dimension.Height>

  <Dimension.Width>
    <summary>
      代表此维度宽度的数值值。
    </summary>
    <value>代表此维度宽度的数值值。</value>
  </Dimension.Width>

  <DragDropClient>
    <summary>
      创建用于拖放操作的客户端。
    </summary>
    <remarks>
      在 Windows 中，“拖放”是一种技术，用户可以通过视觉(使用鼠标)或通过另一种系统接受的方法从一个位置移动文件到另一个位置。
      拖放操作中的客户端是一个具有关联所有者窗口的实用对象，该窗口接受拖放的文件。<br />
      创建一个拖放操作客户端会自动使其所有者窗口能够接受拖放加载。拖放操作客户端中的事件处理程序处理与拖放操作相关的事件。 <br />
      重要！当您调用 Window:EnableDragDropClient(TRUE) 时，窗口将成为 DragDropClient，并继承 DragDropClient 的所有方法。
      当发生 DragLeave、DragOver 或 Drop 事件时(请参见下面的示例)，这些回调方法会在 Window 对象上调用。
    </remarks>
    <example> 
      下面的示例演示了如何使用 DragDropClient 类： 
      <code language="X#">
        METHOD Init(oOwner) CLASS StandardShellWindow
            SUPER:Init(oOwner)
            SELF:Size     := Dimension{300,100}
            SELF:Origin   := Point{0,20}
            SELF:Caption  := "Non-MDI ChildWindow"

            SELF:EnableMinBox()
            SELF:EnableMaxBox()
            SELF:EnableSystemMenu
            SELF:EnableBorder()
            SELF:EnableDragDropClient() // 将窗口设置为DragDropClient
            SELF:Show()

        METHOD DragOver(oDragEvent) CLASS StandardShellWindow
            LOCAL iCount AS INT
            LOCAL iAcceptDrop AS LOGIC
            // 检查拖放到窗口上的文件
            // 只有所有文件都是.DBF时才接受
            lAcceptDrop := TRUE

            FOR iCount := 1 TO oDragEvent:FileCount
                IF RAT(".DBF", oDragEvent:FileName(iCount)) == 0
                    lAcceptDrop := FALSE
                EXIT
                ENDIF
            NEXT

            RETURN lAcceptDrop

        METHOD DragLeave() CLASS StandardShellWindow
        // 拖放尝试期间执行的任何操作都会被撤销
        METHOD Drop(oDragEvent) CLASS StandardShellWindow
            LOCAL nNumFiles := oDragEvent:FileCount
            // 拖放的条目数
            LOCAL nFile AS INT
            // 对于每个被拖放的项目，如果它是一个文件，就打开它
            FOR nFile := 1 TO nNumFiles
                IF File(oDragEvent:FileName(nFile))
                    SELF:DoOpenFile(oDragEvent:FileName(nFile))
                ENDIF
            NEXT
      </code>
    </example>
  </DragDropClient>

  <DragDropClient.ctor>
    <summary> 
      构造一个拖放操作客户端。 <br />
      重要！通常，不应在应用程序代码中调用此方法。而是使用 Window:EnableDragDropClient(TRUE) 来创建一个拖放操作客户端。
    </summary>
    <param name="oOwner">拥有此拖放操作客户端的窗口。</param>
  </DragDropClient.ctor>

  <DragDropClient.Destroy>
    <exclude />
  </DragDropClient.Destroy>

  <DragDropClient.Dispatch>
    <inheritdoc />
  </DragDropClient.Dispatch>

  <DragDropClient.DragLeave>
    <summary>
      通知应用程序鼠标已离开拖放操作客户端的窗口的客户区。
    </summary>
    <param name="oEvent">一个空事件，满足事件处理程序的协议要求，即事件处理程序的参数必须是一个事件。</param>
    <seealso cref="T:VO.Event" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      当在明显的拖放操作(即，DragDropClient:DragOver() 返回 TRUE)期间，鼠标离开拖放操作客户端的窗口的客户区时，系统会调度此方法。
      这意味着用户已经考虑好不执行操作。<br />
      您的 DragLeave() 的实现应该撤销拖放操作期间执行的任何操作，以防用户只是在前往其他客户区。
    </remarks>
  </DragDropClient.DragLeave>

  <DragDropClient.DragOver>
    <summary>
      通知应用程序发生了 DragOver 事件，并接受或拒绝拖放。
    </summary>
    <param name="oDragEvent">确定鼠标位置(在画布坐标中)，以及拖放加载中的文件数和名称的拖动事件。</param>
    <returns>
      客户端可以通过从此方法返回 FALSE 来拒绝拖放操作(通常是因为不接受某种文件类型)。然后，Windows 会将指针更改为禁止符号。<br />
      如果接受了拖放，该方法将返回 TRUE。
    </returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      当在拖放操作期间，鼠标在拖放操作客户端的窗口的客户区内拖动时，系统会调度此方法。<br />
      在一次操作中，DragDropClient:DragOver() 可能会多次调用，直到用户最终放下加载或离开客户区。
      Windows会显示特殊的指针，以便用户可以直观地了解操作的进度。
    </remarks>
  </DragDropClient.DragOver>

  <DragDropClient.Drop>
    <summary>
      检索有关从拖动事件中的加载的信息，并对选择中的每个文件执行操作。
    </summary>
    <param name="oDragEvent">确定鼠标位置(在画布坐标中)，以及拖放加载中的文件数和名称的拖动事件。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      当用户松开鼠标按钮，将加载放在拖放操作客户端的窗口的客户区内时，系统会调度此方法。<br />
      此方法是必需的，以正确处理拖放操作。<br />
      它从拖动事件中检索有关加载的信息，并对选择中的每个文件执行操作。
      如果拖放操作客户端是一个 shell 窗口，它可能会为选择中的每个文件打开一个数据浏览器。
      </remarks>
  </DragDropClient.Drop>

  <DragDropClient.Owner>
    <exclude />
  </DragDropClient.Owner>

  <DragDropServer>
    <summary>
      创建用于拖放操作的服务器。
    </summary>
    <remarks>
      在 Windows 中，“拖放”是一种技术，用户可以通过视觉(使用鼠标)或通过另一种系统接受的方法从一个位置移动文件到另一个位置。<br />
      拖放操作中的服务器是拖放操作的源。
      用户通常使用鼠标选择要拖动的一组文件(但是，应用程序可以选择任何合理的选择方法)。
      选择后，应用程序通过将文件名存储在一个数组中来创建拖放加载；然后调用 DragDropServer:StartDrag() 方法。<br />
      当您调用 Window:EnableDragDropServer(TRUE) 时，窗口将成为 DragDropServer。DragDropServer 是 Window 的一个属性，称为 Window:DragDropServer。
    </remarks>
  </DragDropServer>

  <DragDropServer.ctor>
    <summary> 
      构造一个拖放操作服务器。 <br />
      重要！通常，不应在应用程序代码中调用此方法。而是使用 Window:EnableDragDropServer(TRUE) 来使窗口成为拖放操作服务器。
    </summary>
    <param name="oOwner">拥有此拖放操作服务器的窗口。</param>
    <remarks>
      一旦定义为服务器，GUI 就会将其识别为拖放操作的可能源。
    </remarks>
  </DragDropServer.ctor>

  <DragDropServer.Destroy>
    <exclude />
  </DragDropServer.Destroy>

  <DragDropServer.StartDrag>
    <summary>
      通知 GUI 拖放操作已开始。
    </summary>
    <param name="acFilesToDrag">要拖动的文件的文件名数组。</param>
    <returns>
      如果拖放成功，则返回 TRUE；否则，返回 FALSE(例如，如果用户将文件放在非拖放操作客户端上)。
    </returns>
    <remarks>
      当用户开始拖动操作时，通常是通过拖动鼠标。DragDropServer:StartDrag() 是模态的；一旦调用，只有在用户放下文件时，才会将控制返回给程序。
    </remarks>
    <example> 
      下面的示例演示了如何使用 DragDropServer:StartDrag() 方法： 
      <code language="X#">
        CLASS MyChildWindow INHERIT ChildAppWindow
            HIDDEN aDragList AS ARRAY

            METHOD Init(oOwner) CLASS MyChildAppWindow
                SUPER:Init(oOwner)
                EnableDragDropServer(TRUE) // 将窗口设置为DragDropServer

            METHOD MouseDrag(oEvent) CLASS MyChildWindow
                LOCAL ListLength AS INT
                LOCAL lResult AS LOGIC
                ListLength := ALen(aDragList)
                // aDragList已经填充了文件名列表
                IF ListLength &gt; 0 // 如果有文件要拖动
                    lResult := SELF:DragDropServer:StartDrag(aDragList)
                ENDIF
      </code>
    </example>
  </DragDropServer.StartDrag>

  <DragEvent>
    <summary>
      提供有关拖放事件的信息，这使得拖放客户端(接收窗口)能够跟踪鼠标在拖放操作期间的进度，并识别用户可以放置的文件。
    </summary>
    <remarks>
      拖放是一种GUI约定，用于将对象从一个位置移动到另一个位置。在 Windows 中，这种约定只支持文件。
      当用户将一组先前选择的文件拖动到新位置时，会发生拖放事件。
      拖放事件发生在将要放置选择的目标窗口中(而不是在进行选择的窗口中)。
      <note type="tip">
        拖放事件不会发生在拖放服务器(文件源)中，只会发生在拖放客户端(目标)中。
        当拖放进入客户端区域时，拖放事件会传递给客户端的 DragOver() 方法。
        如果拖放在没有放置文件的情况下离开客户端，并且拖放客户端在 DragOver() 方法中返回了 TRUE，那么一个通用事件会传递给 DragDropClient:DragLeave()。
        此时，查询事件是否正在离开客户端已不再相关或正确。如果用户放置了文件，拖放事件会传递给 DragDropClient:Drop()。
      </note>
    </remarks>
  </DragEvent>

  <DragEvent.ctor>
    <inheritdoc />
  </DragEvent.ctor>

  <DragEvent.Control>
    <summary>
      当在具有 WS_EX_ACCEPTFILES 设置的控件内发生拖放事件时，返回控件。如果 WS_EX_ACCEPTFILES 为 TRUE，控件接受文件并触发调用其父级 Drop() 方法。
    </summary>
    <value>
      当在具有 WS_EX_ACCEPTFILES 设置的控件内发生拖放事件时，返回控件。如果 WS_EX_ACCEPTFILES 为 TRUE，控件接受文件并触发调用其父级 Drop() 方法。
    </value>
  </DragEvent.Control>

  <DragEvent.FileCount>
    <summary>
      一个数字值，表示生成此拖放事件的拖放加载中的文件数量。
    </summary>
    <value>一个数字值，表示生成此拖放事件的拖放加载中的文件数量。</value>
  </DragEvent.FileCount>

  <DragEvent.FileName>
    <summary>
      返回生成此拖放事件的拖放加载中指定文件的名称。
    </summary>
    <param name="nfile">拖放加载数组中所需文件的位置；此数组中的文件编号从1开始(参见 DragEvent:FileCount)。</param>
  </DragEvent.FileName>

  <DragEvent.Origin>
    <summary>
      一个点，表示生成此拖放事件时鼠标在画布坐标中的位置。
    </summary>
    <value>一个点，表示生成此拖放事件时鼠标在画布坐标中的位置。</value>
  </DragEvent.Origin>

  <DrawObject>
    <summary>
      提供所有 X# DrawObject 对象的基类，这些对象都是从它派生的。
    </summary>
    <remarks>
      DrawObject 类提供了可绘制对象的协议(例如，Window 类调用 DrawObject 的方法来管理可绘制对象)。
      这个协议提供了一种在窗口上维护绘制对象数组以便后续显示的方法。<br />
      DrawObject 层次结构中的每个对象都应该提供 BoundingBox 属性(用于标识可以包围绘制对象的最小区域)和 Draw() 方法(用于指定如何绘制对象)。<br />
      当应用程序完成了对对象的使用，必须使用 Destroy() 方法显式销毁它。
    </remarks>
  </DrawObject>

  <DrawObject.ctor>
    <summary>
      构造一个 DrawObject 对象。
    </summary>
    <param name="oPoint">DrawObject 对象在画布坐标中的原点。</param>
  </DrawObject.ctor>

  <DrawObject.BoundingBox>
    <summary>
      一个边界框，表示(在所有者窗口的画布坐标中)可以包围此 DrawObject 对象的最小矩形。
    </summary>
    <value>一个边界框，表示(在所有者窗口的画布坐标中)可以包围此 DrawObject 对象的最小矩形。</value>
  </DrawObject.BoundingBox>

  <DrawObject.Destroy>
    <summary>
      提供一个方法来取消实例化 DrawObject 对象。
    </summary>
    <remarks>
      DrawObject:Destroy() 取消实例化 DrawObject 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。<br />
      当应用程序完成了对对象的使用，必须使用这个方法显式销毁它。
    </remarks>
  </DrawObject.Destroy>

  <DrawObject.Draw>
    <summary>
      显示一个 DrawObject 对象。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      <note type="tip">
        DrawObject:Draw() 方法的默认实现没有效果。您应该从 DrawObject 派生您的类，并重载 Draw() 方法以包含绘制新对象的代码。
        然后，可以通过 Window:Draw() 调用这个方法。
      </note>
      要显示一个 DrawObject 对象，调用 Window:Draw()，并将 DrawObject 对象作为其参数。窗口通过询问每个对象来绘制自己来进行绘制，例如： 
      <code language="X#">
        METHOD Expose(oEvent) CLASS MyWindow
            LOCAL oEllipse AS ELLIPSEOBJECT
            oEllipse := EllipseObject{Point{10,10}, Dimension{50,100}}
            SELF:Draw(oEllipse)
            // Calls the method Draw() on oEllipse
      </code>
    </remarks>
  </DrawObject.Draw>

  <DrawObject.Handle>
    <summary>
      返回 DrawObject 对象的句柄。
    </summary>
    <param name="nHandleType"> 所需句柄的类型。0 是唯一支持的选项，如果省略 <paramref name="nHandle" />，则为默认值。 </param>
    <returns>
      一个句柄，用于在对象所要绘制的窗口的设备上下文中绘制。X# 将在必要时释放此句柄。您不应该将其保存到变量中。
    </returns>
    <remarks>
      <note type="tip">这个方法只在重写的 DrawObject:Draw() 方法中才会生效。</note>
    </remarks>
  </DrawObject.Handle>

  <DrawObject.HitTest>
    <summary>
      确定给定点是否位于 DrawObject 对象的边界框内。
    </summary>
    <param name="oPoint">要测试是否包含的点。</param>
    <returns>
      如果点位于 DrawObject 对象的边界框内，则为 TRUE；否则为 FALSE。
    </returns>
    <remarks> 
      当需要的不是默认行为时，应该由从 DrawObject 派生的类中的对象提供这个方法。<br /> 
      当调用 HitTest() 时，默认情况下会执行以下操作： 
      <code language="X#">
        RETURN(SELF:BoundingBox()):PtInRect(oPoint)
      </code>
    </remarks>
  </DrawObject.HitTest>

  <DrawObject.Origin>
    <summary>
      一个点，表示 DrawObject 对象在画布坐标中的原点。
    </summary>
    <value>一个点，表示 DrawObject 对象在画布坐标中的原点。</value>
  </DrawObject.Origin>

  <DrawObject.RasterOperation>
    <summary>
      一个常量，指示 DrawObject 对象正在使用的光栅操作：
    </summary>
    <value>一个常量，指示 DrawObject 对象正在使用的光栅操作：</value>
    <remarks> 
      以下常量之一，指示 DrawObject 对象正在使用的光栅操作： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>ROPBACKGROUND</term>
          <description>使用窗口的背景颜色绘制此对象。</description>
        </item>
        <item>
          <term>ROPINVERT</term>
          <description>反转当前显示的对象。此操作可用于弹性带、移动对象等。</description>
        </item>
        <item>
          <term>ROPOVERWRITE</term>
          <description> 覆盖当前显示。这是<b>默认值</b>。 </description>
        </item>
        <item>
          <term>ROPXOR</term>
          <description>与当前窗口内容进行异或操作。</description>
        </item>
      </list>
      此属性允许您指定绘制如何影响窗口上已经存在的任何内容。例如，XOR 操作对于您想要能够删除的临时绘制很有用，从而恢复原始图像。 
    </remarks>
  </DrawObject.RasterOperation>

  <DrawObject.Size>
    <summary>
      一个维度，表示 DrawObject 对象的大小。
    </summary>
    <value>一个维度，表示 DrawObject 对象的大小。</value>
  </DrawObject.Size>

  <Edit>
    <summary>
      提供所有 X# 编辑控件的基类，这些控件都是从它派生的。
    </summary>
    <remarks>
      Edit 类为输入、删除和选择文本提供了简单的文本编辑功能。此外，您可以指定编辑控件是否应该有边框，是否应该是只读的，或者是否应该受到密码保护。<br />
      此类层次结构中的编辑控件将其包含的文本视为一系列编号的字符。在这些编辑控件中，选择是字符编号的有序对。
      例如，如果编辑控件包含文本"samarkand"，那么选择(3,7)将选择文本"mark"。<br />
      此外，对于每个控件，文本限制是您希望编辑控件保持的最大字符数。<br />
      换行(Chr(10))、制表符(Chr(9))和空字符(Chr(0))的非图形字符占用一个字符位置。
    </remarks>
  </Edit>

  <Edit.ctor>
    <summary>
      构造一个编辑控件。
    </summary>
    <param name="oOwner">拥有编辑控件的窗口。</param>
    <param name="xID">编辑控件的ID。</param>
    <param name="oPoint">编辑控件在画布坐标中的原点。</param>
    <param name="oDimension">编辑控件在画布坐标中的尺寸。</param>
    <param name="kStyle">编辑控件的样式，指定为以下常量之一：</param>
    <param name="nResourceID">编辑控件的资源ID。</param>
    <remarks>
      <include file="Gui.xml" path="doc/EditConstants/*" />
    </remarks>
  </Edit.ctor>

  <Edit.CanUndo>
    <summary>
      确定是否可以调用 Edit:Undo() 方法来撤销此编辑控件的最后一次修改。
    </summary>
    <returns>
      如果可以调用 Edit:Undo()，则为 TRUE；否则为 FALSE。
    </returns>
    <remarks>
      这个方法通常用于修改撤销菜单命令，以反映不同可能性的状态。
    </remarks>
  </Edit.CanUndo>

  <Edit.Caption>
    <summary>
      单行或多行编辑控件不显示标题文本。它可以用于存储一般文本信息。
    </summary>
    <value>单行或多行编辑控件不显示标题文本。它可以用于存储一般文本信息。</value>
  </Edit.Caption>

  <Edit.Clear>
    <summary>
      删除此编辑控件中的当前选择。
    </summary>
    <remarks>
      如果当前选择引用光标位置(例如，{5,5})，则不会删除任何文本。
    </remarks>
  </Edit.Clear>

  <Edit.Copy>
    <summary>
      将此编辑控件中的当前选择复制到剪贴板。
    </summary>
    <remarks>
      如果当前选择引用光标位置(例如，{5,5})，则不会复制任何文本。
    </remarks>
  </Edit.Copy>

  <Edit.Cut>
    <summary>
      删除此编辑控件中的当前选择，并将其复制到剪贴板。
    </summary>
    <remarks>
      如果当前选择引用光标位置(例如，{5,5})，则不会删除任何文本。
    </remarks>
  </Edit.Cut>

  <Edit.Font>
    <exclude />
  </Edit.Font>

  <Edit.IsPassword>
    <exclude />
  </Edit.IsPassword>

  <Edit.Margins>
    <summary>
      一个 Dimension 对象，指定编辑控件的左右边距。
    </summary>
    <value>一个 Dimension 对象，指定编辑控件的左右边距。</value>
  </Edit.Margins>

  <Edit.Modified>
    <summary>
      一个逻辑值，指示可编辑控件是否正在被修改。
    </summary>
    <value>一个逻辑值，指示可编辑控件是否正在被修改。</value>
    <remarks>
      一个逻辑值，指示可编辑控件是否正在被修改。<br />
      当您编辑文本时，它被设置为 TRUE。<br />
      当编辑完成并且焦点转移到另一个控件时，Edit:Modified 被重置为 FALSE。
    </remarks>
  </Edit.Modified>

  <Edit.Paste>
    <summary>
      用指定的字符串(如果指定)或剪贴板的内容替换此编辑控件中的当前选择。
    </summary>
    <param name="cNewString">要放置在编辑控件中的文本。如果未指定，将使用剪贴板的内容。</param>
    <remarks>
      如果当前选择引用光标位置(例如，{5,5})，则在该位置插入文本，并且不会删除任何文本。
    </remarks>
  </Edit.Paste>

  <Edit.ReadOnly>
    <summary>
      一个逻辑值，指定编辑控件的只读状态。
    </summary>
    <value>一个逻辑值，指定编辑控件的只读状态。</value>
    <remarks>
      一个逻辑值，指定编辑控件的只读状态。<br />
      此属性允许您在运行时更改只读状态。<br />
      请注意，通过 Edit:SetStyle(ES_READONLY) 在运行时更改 ReadOnly 样式的操作不会被编辑控件尊重。
    </remarks>
  </Edit.ReadOnly>

  <Edit.SelectAll>
    <exclude />
  </Edit.SelectAll>

  <Edit.SelectedText>
    <summary>
      一个字符串，表示此编辑控件中当前选择的文本。
    </summary>
    <value>一个字符串，表示此编辑控件中当前选择的文本。</value>
  </Edit.SelectedText>

  <Edit.Selection>
    <summary>
      编辑控件中光标的位置。
    </summary>
    <value>编辑控件中光标的位置。</value>
    <remarks>
      编辑控件中光标的位置。例如，选择{5,10}表示从位置5到9的文本(包括9)被选择，而选择{5,5}表示光标位于第五个字符的前面。
    </remarks>
  </Edit.Selection>

  <Edit.SelectNone>
    <exclude />
  </Edit.SelectNone>

  <Edit.SetSelectionFocus>
    <exclude />
  </Edit.SetSelectionFocus>

  <Edit.TextLimit>
    <summary>
      一个数字值，表示此编辑控件可以容纳的最大字符数。
    </summary>
    <value>一个数字值，表示此编辑控件可以容纳的最大字符数。</value>
    <remarks>
      一个数字值，表示此编辑控件可以容纳的最大字符数。值为0表示没有设置限制。如果指定的限制小于缓冲区中已有的文本大小，现有文本将被截断。
    </remarks>
  </Edit.TextLimit>

  <Edit.TextValue>
    <summary>
      一个字符串，表示控件中保存的值。
    </summary>
    <value>一个字符串，表示控件中保存的值。</value>
    <remarks>
      一个字符串，表示控件中保存的值。<br />
      例如，在标准编辑控件中，值可以是"Jones"或"$14,683.00"。<br />
      Edit:TextValue 的赋值也会改变 Edit:CurrentText 和 Edit:Value。<br />
      请注意，字符串的格式取决于编辑字段规范中保存的图片描述；反过来，与数据服务器链接的编辑字段继承字段规范，因此也继承图片描述。
    </remarks>
  </Edit.TextValue>

  <Edit.Undo>
    <summary>
      撤销对此编辑控件中文本的最后一次修改。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法只会撤销最后一次更改，撤销不会嵌套。
    </remarks>
  </Edit.Undo>

  <Edit.Value>
    <summary>
      Edit:Value 包含上一次编辑操作后的文本。<br />
      Edit:TextValue 的赋值也会改变 Edit:CurrentText 和 Edit:TextValue。<br />
      对于不可编辑的控件(FixedIcon 、固定文本、分组框)，Edit:Value 设置为 NULL_STRING。
    </summary>
    <value>
      Edit:Value 包含上一次编辑操作后的文本。<br />
      Edit:TextValue 的赋值也会改变 Edit:CurrentText 和 Edit:TextValue。<br />
      对于不可编辑的控件(FixedIcon 、固定文本、分组框)，Edit:Value 设置为 NULL_STRING。
    </value>
  </Edit.Value>

  <EditFocusChangeEvent>
    <summary>
      提供有关 EditFocusChangeEvent 的信息，该事件在编辑控件(例如，SingleLineEdit、MultiLineEdit 或 EditWindow)获得或失去键盘焦点时生成。
    </summary>
  </EditFocusChangeEvent>

  <EditFocusChangeEvent.ctor>
    <inheritdoc />
  </EditFocusChangeEvent.ctor>

  <EditFocusChangeEvent.GotFocus>
    <summary>
      一个逻辑值，表示编辑控件是否刚刚获得键盘焦点(TRUE)或刚刚失去它(FALSE)。
    </summary>
    <value>一个逻辑值，表示编辑控件是否刚刚获得键盘焦点(TRUE)或刚刚失去它(FALSE)。</value>
  </EditFocusChangeEvent.GotFocus>

  <EditFocusChangeEvent.HyperLabel>
    <summary> 
      与编辑控件焦点变化事件相关联的超链接。从超链接中，您可以检索有关编辑控件焦点变化事件的其他信息，例如： 
      <code language="X#">
        cCaption      := oEditFocusChangeEvent:HyperLabel:Caption
        cDescription  := oEditFocusChangeEvent:HyperLabel:Description
        cHelpContext  := oEditFocusChangeEvent:HyperLabel:HelpContext
      </code>
    </summary>
    <value>
      与编辑控件焦点变化事件相关联的超链接。从超链接中，您可以检索有关编辑控件焦点变化事件的其他信息，例如：
      <code language="X#">
        cCaption      := oEditFocusChangeEvent:HyperLabel:Caption
        cDescription  := oEditFocusChangeEvent:HyperLabel:Description
        cHelpContext  := oEditFocusChangeEvent:HyperLabel:HelpContext
      </code>
    </value>
  </EditFocusChangeEvent.HyperLabel>

  <EditWindow>
    <summary>
      在 Window 层次结构的一部分创建一个编辑控件，从而允许使用事件处理程序自定义编辑控件的行为。
    </summary>
    <remarks>
      当在 Window 层次结构的一部分创建一个编辑控件时，它可以捕获事件。<br />
      例如，您可能希望自定义编辑控件的外观(如更改背景和前景颜色)或修改它们的默认键处理。<br />
      通过 ControlWindow 类操作控件需要更多的开销，而通过 Control 的子类创建的控件不需要。
      因此，建议仅在需要特殊处理时使用控件窗口(例如，覆盖某些事件的处理或在控件上调用某个窗口方法)。
    </remarks>
  </EditWindow>

  <EditWindow.ctor>
    <summary>
      创建一个编辑窗口。
    </summary>
    <param name="oOwner">拥有编辑窗口的窗口。</param>
    <param name="xID">编辑窗口的ID。</param>
    <param name="oPoint">编辑窗口在画布坐标中的原点。</param>
    <param name="oDimension">编辑窗口在画布坐标中的尺寸。</param>
    <param name="nResourceID">编辑窗口的资源ID。</param>
  </EditWindow.ctor>

  <EditWindow.AsString>
    <summary>
      返回编辑窗口的内容。
    </summary>
    <remarks>
      此方法返回的内容与 EditWindow:TextValue 相同。EditWindow:AsString() 将编辑窗口呈现为可识别的字符串。
    </remarks>
  </EditWindow.AsString>

  <EditWindow.Clear>
    <summary>
      删除编辑窗口中的当前选择。
    </summary>
    <remarks>
      如果当前选择引用光标位置(例如，{5,5})，则不会删除任何文本。
    </remarks>
  </EditWindow.Clear>

  <EditWindow.Control>
    <summary>
      此属性继承自 ControlWindow 类，但不适用于 EditWindow。它返回 NULL_OBJECT。
    </summary>
    <value>此属性继承自 ControlWindow 类，但不适用于 EditWindow。它返回 NULL_OBJECT。</value>
  </EditWindow.Control>

  <EditWindow.ControlID>
    <summary>
      此属性继承自 EditControl 类，但不适用于 EditWindow。它的返回值是 NIL。
    </summary>
    <value>此属性继承自 EditControl 类，但不适用于 EditWindow。它的返回值是 NIL。</value>
  </EditWindow.ControlID>

  <EditWindow.Copy>
    <summary>
      将编辑窗口中当前选择的文本复制到剪贴板。
    </summary>
    <remarks>
      如果当前选择引用光标位置(例如，{5,5})，则不会复制任何文本。
    </remarks>
  </EditWindow.Copy>

  <EditWindow.Cut>
    <summary>
      删除编辑窗口中当前选择的文本并将其复制到剪贴板。
    </summary>
    <remarks>
      如果当前选择引用光标位置(例如，{5,5})，则不会删除任何文本。
    </remarks>
  </EditWindow.Cut>

  <EditWindow.Destroy>
    <summary>
      释放为 EditWindow 对象及其派生对象分配的内存资源。
    </summary>
    <remarks>
      此方法立即释放显式在应用程序中创建的 EditWindow 对象的资源。
      EditWindow:Destroy() 还会处理为派生类分配的资源，并按照必要的顺序释放它们。
    </remarks>
  </EditWindow.Destroy>

  <EditWindow.GetLine>
    <summary>
      获取编辑窗口中指定行的文本。
    </summary>
    <param name="nLineNumber">编辑窗口中所需行的位置。指定以下值之一：</param>
    <param name="Value">位置</param>
    <param name="0">编辑窗口中的当前行(即，当前包含文本光标的行)。这是默认值。</param>
    <param name="1">编辑窗口中的第一行。</param>
    <param name="n">编辑窗口中的第n行。</param>
    <param name="nMaxLength">您期望字符串在任何语言中的最大长度。如果未指定，系统会替换为255。如果设置得太低，Windows 会截断资源字符串。</param>
    <returns>
      指定行的文本。
    </returns>
  </EditWindow.GetLine>

  <EditWindow.Length>
    <summary>
      一个数字值，表示编辑窗口中的字符数。
    </summary>
    <value>一个数字值，表示编辑窗口中的字符数。</value>
  </EditWindow.Length>

  <EditWindow.LineCount>
    <summary>
      一个数字值，表示编辑窗口中的文本行数。
    </summary>
    <value>一个数字值，表示编辑窗口中的文本行数。</value>
  </EditWindow.LineCount>

  <EditWindow.LineDown>
    <summary>
      将编辑窗口中的文本向下滚动一行。
    </summary>
  </EditWindow.LineDown>

  <EditWindow.LineUp>
    <summary>
      将编辑窗口中的文本向上滚动一行。
    </summary>
  </EditWindow.LineUp>

  <EditWindow.PageDown>
    <summary>
      将编辑窗口中的文本向下滚动一页。
    </summary>
    <remarks>
      一页是当前编辑窗口中当前字体可以容纳的行数。
    </remarks>
  </EditWindow.PageDown>

  <EditWindow.PageUp>
    <summary>
      将编辑窗口中的文本向上滚动一页。
    </summary>
    <remarks>
      一页是当前编辑窗口中当前字体可以容纳的行数。
    </remarks>
  </EditWindow.PageUp>

  <EditWindow.Paste>
    <summary>
      用剪贴板的内容替换编辑窗口中当前选择的文本。
    </summary>
    <param name="cNewString">要放置在编辑窗口中的文本。如果未指定，将使用剪贴板的内容。</param>
    <remarks>
      如果当前选择引用光标位置(例如，{5,5})，则在该位置插入文本，并且不会删除任何文本。
    </remarks>
  </EditWindow.Paste>

  <EditWindow.ScrollHorizontal>
    <summary>
      将编辑窗口中的当前行向右或向左滚动指定数量的字符。
    </summary>
    <param name="nChars">要滚动的字符数。正值向右滚动；负值向左滚动。</param>
  </EditWindow.ScrollHorizontal>

  <EditWindow.ScrollVertical>
    <summary>
      将编辑窗口中的当前行向上或向下滚动指定数量的行。
    </summary>
    <param name="nLines">要滚动的行数。正值向上滚动；负值向下滚动。</param>
  </EditWindow.ScrollVertical>

  <EditWindow.Selection>
    <summary>
      一个 Selection 对象，表示编辑窗口中当前选择的文本。
    </summary>
    <value>一个 Selection 对象，表示编辑窗口中当前选择的文本。</value>
    <remarks>
      一个 Selection 对象，表示编辑窗口中当前选择的文本。<br />
      例如，Selection 值为{5,10}表示从位置5到9(包括9)的文本被选择，而Selection值为{5,5}表示光标位于第五个字符的前面。
    </remarks>
  </EditWindow.Selection>

  <EditWindow.TextLimit>
    <summary>
      一个数字值，表示编辑窗口可以容纳的最大字符数。
    </summary>
    <value>一个数字值，表示编辑窗口可以容纳的最大字符数。</value>
    <remarks>
      一个数字值，表示编辑窗口可以容纳的最大字符数。值为0表示没有设置限制。如果指定的限制小于缓冲区中已有的文本大小，现有文本将被截断。
    </remarks>
  </EditWindow.TextLimit>

  <EditWindow.TextValue>
    <summary>
      一个字符串，表示编辑窗口中保存的值。
    </summary>
    <value>一个字符串，表示编辑窗口中保存的值。</value>
    <remarks>
      一个字符串，表示编辑窗口中保存的值。例如，值可以是"Jones"或"$14,683.00"。
    </remarks>
  </EditWindow.TextValue>

  <EditWindow.Undo>
    <summary>
      撤销对编辑窗口中文本的最后一次修改。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法只会撤销最后一次更改，撤销不会嵌套。
    </remarks>
  </EditWindow.Undo>

  <EditWindow.Value>
    <summary>
      编辑窗口中编辑字段的值，以编辑窗口持有的任何数据类型。
    </summary>
    <value>编辑窗口中编辑字段的值，以编辑窗口持有的任何数据类型。</value>
    <remarks>
      编辑窗口中编辑字段的值，以编辑窗口持有的任何数据类型。<br />
      例如，值可以是字符串"Jones"或数字14683。<br />
      编辑窗口的数据类型由其字段规范确定；反过来，与数据服务器链接的编辑窗口继承字段规范，因此也继承数据类型。
    </remarks>
  </EditWindow.Value>

  <EllipseObject>
    <summary>
      创建一个 EllipseObject 对象；这种类型的实体是 DrawObject 层次结构的一部分，该层次结构提供了一种显示和操作各种对象的方法。
    </summary>
    <example> 
      要绘制一个 EllipseObject 对象，请调用 Window:Draw()，并将 EllipseObject 对象作为其参数。窗口通过询问每个对象自己绘制来进行绘制，例如： 
      <code language="X#">
        METHOD Expose(oEvent) CLASS MyWindow
            LOCAL oEllipse AS OBJECT
            oEllipse := EllipseObject{Point{10,10}, Dimension{20,40}}
            SELF:Draw(oEllipse)
      </code>
    </example>
  </EllipseObject>

  <EllipseObject.ctor>
    <summary>
      构造一个 EllipseObject 对象。
    </summary>
    <param name="oPoint">EllipseObject 对象在画布坐标中的原点。</param>
    <param name="oDimension">EllipseObject 对象在画布坐标中的尺寸。</param>
    <param name="oPen">用于绘制 EllipseObject 对象的笔。默认情况下，使用当前笔。</param>
    <param name="oBrush">用于填充 EllipseObject 对象的刷子。默认情况下，使用当前刷子。</param>
  </EllipseObject.ctor>

  <EllipseObject.Draw>
    <summary>
      绘制此 EllipseObject 对象。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      应用程序代码中不应直接调用此方法—它在 X# 中由 Window:Draw() 调用。<br />
      请参阅 EllipseObject 类的描述，了解使用 Draw() 方法的示例。 
    </remarks>
  </EllipseObject.Draw>

  <Error>
    <summary>
      创建一个 Error 对象，其中包含有关运行时错误的信息。
    </summary>
    <remarks>
      Error 对象是一个简单的对象，其中包含有关运行时错误的信息。Error 对象没有方法，只有导出的实例变量。<br />
      当发生运行时错误时，X# 会创建一个新的 Error 对象，并将其作为参数传递给使用 ErrorBlock() 函数指定的错误处理程序块。
      在错误处理程序中，可以查询 Error 对象以确定错误条件的性质。<br />
      Error 对象也可以通过 BREAK 语句返回到 BEGIN SEQUENCE 结构的 RECOVER 语句。同样，Error 对象也可以传递给 DataServer 或 DataWindow 对象的错误方法。
      在这里，Error 对象可以用于查询本地错误处理。<br />
      有关更详细的信息和示例，请参见程序员指南中的"错误和异常处理"。
    </remarks>
  </Error>

  <ErrorBox>
    <summary>
      向用户显示一个错误消息框。
    </summary>
    <remarks>
      错误消息框是一个窗口，其中包含标题栏中的文本"Error"，消息的文本，以及一个警告图标。<br />
      错误消息框是应用程序模态的—用户必须在继续应用程序之前确认它们。当错误消息框关闭时，焦点将返回到其所有者窗口。
    </remarks>
    <example> 
      以下示例创建并显示一个错误消息框(其所有者是oMyWin)，向用户显示文本"Oops, We have an error!"： 
      <code language="X#">
        METHOD Start() CLASS App
          oMyWin := TopAppWindow{}
          oMyWin:Show()

          oErrBox := ErrorBox{oMyWin, "Oops, We have an error!"}
          oErrBox:Show()
          SELF:Exec()
      </code>
    </example>
  </ErrorBox>

  <ErrorBox.ctor>
    <summary>
      构造一个错误消息框。
    </summary>
    <param name="uParent">拥有错误框的窗口。如果未指定所有者，错误框将是应用程序模态的(即，应用程序将在用户确认错误框之前被挂起)。</param>
    <param name="uText">在错误框中显示的描述。如果未指定文本，将使用系统定义的'Error!'错误消息文本。</param>
    <param name="oHyperLabel">包含描述(HyperLabel:Description)的超链接标签，该描述将在错误框中显示。</param>
  </ErrorBox.ctor>

  <Event>
    <summary>
      提供所有 X# 事件的基类。
    </summary>
    <remarks>
      系统调度程序将事件分派到适当窗口的事件处理程序。Event 类总是映射到 GUI 的事件或消息结构。<br />
      事件是瞬时对象，它们携带信息到窗口，指示系统事件已发生。例如，窗口已被显示的信息将作为 Event 对象传递给该窗口的 Expose() 事件处理程序。
    </remarks>
  </Event>

  <Event.ctor>
    <summary>
      构造一个事件。
    </summary>
    <remarks>
      <note type="Warning">X# 实例化事件。</note>
    </remarks>
    <param name="_hWnd">事件发生的窗口的句柄，或者是一个 Event 对象。运行时会检查 _hWnd 是否是一个指针。如果不是，它会假设它是一个事件对象，并从这个对象克隆值。</param>
    <param name="_uMsg">发生的消息(WM_..)</param>
    <param name="_wParam">消息的 WPARAM</param>
    <param name="_lParam">消息的 LPARAM</param>
    <param name="_oWindow">与事件关联的窗口的 Window 对象。</param>
  </Event.ctor>

  <Event.Handle>
    <summary>
      事件发生的窗口的指针
    </summary>
    <value>事件发生的窗口的指针</value>
  </Event.Handle>

  <Event.hWnd>
    <summary>
      事件发生的窗口的指针
    </summary>
    <value>事件发生的窗口的指针</value>
  </Event.hWnd>

  <Event.lParam>
    <summary>
      表示给定事件关联的 Windows API 消息的 LPARAM 的长整数。
    </summary>
    <value>表示给定事件关联的 Windows API 消息的 LPARAM 的长整数。</value>
    <remarks>
      表示给定事件关联的 Windows API 消息的 LPARAM 的长整数。<br />
      这可以在 EventContext 类的 Dispatch() 方法中使用，用于处理自定义消息。
    </remarks>
  </Event.lParam>

  <Event.Message>
    <summary>
      表示给定事件关联的 Windows API 消息的 DWORD。
    </summary>
    <value>表示给定事件关联的 Windows API 消息的 DWORD。</value>
    <remarks>
      表示给定事件关联的 Windows API 消息的 DWORD。<br />
      这可以在 EventContext 类的 Dispatch() 方法中使用，用于处理自定义消息。
    </remarks>
  </Event.Message>

  <Event.oWindow>
    <summary>
      表示事件发生的窗口或控件的对象。这对于区分来自附加到不同控件的相同上下文菜单的类似菜单事件非常有用。
    </summary>
    <value>表示事件发生的窗口或控件的对象。这对于区分来自附加到不同控件的相同上下文菜单的类似菜单事件非常有用。</value>
  </Event.oWindow>

  <Event.uMsg>
    <summary>
      表示给定事件关联的 Windows API 消息的 DWORD。
    </summary>
    <value>表示给定事件关联的 Windows API 消息的 DWORD。</value>
    <remarks>
      表示给定事件关联的 Windows API 消息的 DWORD。<br />
      这可以在 EventContext 类的 Dispatch() 方法中使用，用于处理自定义消息。
    </remarks>
  </Event.uMsg>

  <Event.Window>
    <summary>
      表示事件发生的窗口或控件的对象。这对于区分来自附加到不同控件的相同上下文菜单的类似菜单事件非常有用。
    </summary>
    <value>表示事件发生的窗口或控件的对象。这对于区分来自附加到不同控件的相同上下文菜单的类似菜单事件非常有用。</value>
  </Event.Window>

  <Event.wParam>
    <summary>
      表示给定事件关联的 Windows API 消息的 WPARAM 的 DWORD。
    </summary>
    <value>表示给定事件关联的 Windows API 消息的 WPARAM 的 DWORD。</value>
    <remarks>
      表示给定事件关联的 Windows API 消息的 WPARAM 的 DWORD。<br />
      这可以在 EventContext 类的 Dispatch() 方法中使用，用于处理自定义消息。
    </remarks>
  </Event.wParam>

  <EventContext>
    <summary>
      提供所有 X# 事件处理类的基类，包含任何接收事件的对象所需的元素。
    </summary>
    <remarks>
      EventContext 类提供：<br />
      一个调度程序<br />
      一个默认事件处理程序<br />
      一个启用调度程序的方法
    </remarks>
  </EventContext>

  <EventContext.ctor>
    <summary>
      构造一个事件上下文。
    </summary>
  </EventContext.ctor>

  <EventContext.Destroy>
    <summary>
      永久销毁事件上下文。
    </summary>
    <remarks>
      当不再需要 EventContext 对象时，可以使用此方法。
      EventContext:Destroy() 会取消实例化 EventContext 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </EventContext.Destroy>

  <EventContext.Override>
    <summary>这是一个兼容性方法，不再使用或需要。</summary>
  </EventContext.Override>

  <EventContext.SelfPtrStruc>
    <exclude />
  </EventContext.SelfPtrStruc>

  <ExplorerWindow>
    <summary>
      创建一个资源管理器窗口。
    </summary>
    <remarks>
      资源管理器窗口是一个两或四个窗格的分割窗口，模仿 Microsoft Windows 应用程序窗口的功能，例如文件管理器或资源管理器。<br />
      资源管理器窗口包含一个列表视图控件和一个树视图控件，以及可选的固定文本控件。这些控件的编程接口可以直接用于操作窗口。
      一个两窗格资源管理器窗口包含一个并排的列表视图和树视图，中间由一个可以拖动的垂直分割条分隔。
      一个四窗格资源管理器窗口包含一个并排的列表视图和树视图，以及每个上方的固定文本，作为标签。<br />
      列表视图和树视图之间由一个可以拖动的垂直分割条分隔。
      固定文本标签与列表视图和树视图之间由一个不可拖动的水平分割条分隔。窗格垂直对齐。
    </remarks>
  </ExplorerWindow>

  <ExplorerWindow.ctor>
    <summary>
      构造一个资源管理器窗口对象。
    </summary>
    <param name="oOwner">拥有资源管理器窗口的窗口。</param>
    <param name="lLabels">
      一个逻辑值，<br />
      如果要创建一个四窗格资源管理器窗口(四窗格资源管理器窗口包含'标签'，或固定文本控件)，则为 TRUE，<br />
      如果要创建一个两窗格资源管理器窗口，则为 FALSE。<br />
      如果省略，将使用默认值TRUE。
    </param>
    <param name="symTreeViewClassName">树视图类的符号名称。</param>
    <param name="symListViewClassName">列表视图类的符号名称。</param>
  </ExplorerWindow.ctor>

  <ExplorerWindow.Destroy>
    <inheritdoc />
  </ExplorerWindow.Destroy>

  <ExplorerWindow.LabelLeft>
    <summary>
      四窗格资源管理器窗口中的左侧固定文本控件。在两窗格资源管理器窗口中，这将返回 NULL_OBJECT。
    </summary>
    <value>四窗格资源管理器窗口中的左侧固定文本控件。在两窗格资源管理器窗口中，这将返回 NULL_OBJECT。</value>
  </ExplorerWindow.LabelLeft>

  <ExplorerWindow.LabelRight>
    <summary>
      四窗格资源管理器窗口中的右侧固定文本控件。在两窗格资源管理器窗口中，这将返回 NULL_OBJECT。
    </summary>
    <value>四窗格资源管理器窗口中的右侧固定文本控件。在两窗格资源管理器窗口中，这将返回 NULL_OBJECT。</value>
  </ExplorerWindow.LabelRight>

  <ExplorerWindow.ListView>
    <summary>
      两或四窗格资源管理器窗口中的列表视图控件。
    </summary>
    <value>两或四窗格资源管理器窗口中的列表视图控件。</value>
  </ExplorerWindow.ListView>

  <ExplorerWindow.ListViewColumnClick>
    <inheritdoc />
  </ExplorerWindow.ListViewColumnClick>

  <ExplorerWindow.TreeView>
    <summary>
      两或四窗格资源管理器窗口中的树视图控件。
    </summary>
    <value>两或四窗格资源管理器窗口中的树视图控件。</value>
  </ExplorerWindow.TreeView>

  <ExposeEvent>
    <summary>
      提供有关 ExposeEvent 的信息，用于通知窗口可能需要重新绘制。
    </summary>
    <remarks>
      当窗口：<br />
      首次显示<br />
      移动或关闭<br />
      如果这个新暴露的区域中有任何其他窗口，它们需要重新绘制。系统会自动向这些窗口发送 ExposeEvent，以通知它们必须重新绘制新暴露的区域。
      调整大小<br />
       会发送到窗口的 Expose() 事件处理程序，负责重新绘制暴露的区域。如果您希望应用程序在窗口暴露时执行某些操作，可以在这个事件处理程序中放置自己的代码。
    </remarks>
    <example> 
      以下示例根据窗口的不同部分暴露的不同区域打印不同的消息： 
      <code language="X#">
        METHOD Expose(oEE) CLASS MyWindow
            LOCAL oBB AS BOUNDINGBOX
            oBB := oEE:ExposedArea

            IF oBB:Bottom() &lt; 20
              SELF:TextPrint("In the 20's",Point{0,20})
            ENDIF

            IF oBB:Bottom() &gt; 40
              SELF:TextPrint("In the 40's",Point{0,40})
            ENDIF
      </code>
    </example>
  </ExposeEvent>

  <ExposeEvent.ctor>
    <inheritdoc />
  </ExposeEvent.ctor>

  <ExposeEvent.ExposedArea>
    <summary>
      一个边界框，表示导致此暴露事件的暴露区域，以画布坐标表示。<br />
      使用这个方法优化你的重绘例程，这样它们只会绘制需要刷新的区域。
    </summary>
    <value>
      一个边界框，表示导致此暴露事件的暴露区域，以画布坐标表示。<br />
      使用这个方法优化你的重绘例程，这样它们只会绘制需要刷新的区域。
    </value>
  </ExposeEvent.ExposedArea>

  <FixedBitmap>
    <summary>
      创建一个 FixedBitmap 对象。<br />
      与 Bitmap 类创建的位图不同，固定位图是静态的—每次发生 ExposeEvent 时都不需要重新显示。<br />
      固定位图对象可以动态创建，也可以从资源实体创建。
    </summary>
    <example> 
      此示例从资源实体创建一个固定位图，并将其位置更改为对话框窗口的左下角： 
      <code language="X#">
        CLASS MyDialogWindow INHERIT DialogWindow
            HIDDEN OMyFBitmap AS OBJECT

            METHOD Init(oWindow) CLASS MyDialogWIndow
                SUPER:Init(oWindow,ID_MYDIALOG)

                OMyFBitmap := FixedBitmap{SELF,MYBITMAP}
                OMyFBitmap:Origin := Point{10,10}

                SELF:Show()
      </code>
      在Windows中，固定位图等同于具有SS_BITMAP样式的静态对象。这些通常在资源实体中指定如下： 
      <code language="X#">
        RESOURCE IDI_FIXEDBITMAP BITMAP fixed.bmp
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 80

        STYLE WS_POPUP | WS_DLGFRAME

        BEGIN
            BITMAP IDI_FIXEDBITMAP -1, 8, 8, 0, 0
        END
      </code>
    </example>
  </FixedBitmap>

  <FixedBitmap.ctor>
    <summary>
      构造一个 FixedBitmap 对象。
    </summary>
    <param name="uOwner">拥有固定位图的窗口。</param>
    <param name="uID">固定位图的ID。</param>
    <param name="uPoint">固定位图在画布坐标中的原点。</param>
    <param name="uDimension">固定位图在画布坐标中的尺寸。</param>
    <param name="uResID">与此 FixedBitmap 静态控件关联的位图图像的资源ID对象或数字资源ID。</param>
    <param name="oResourceID">固定位图的 ResourceID 对象或固定位图的资源ID。</param>
  </FixedBitmap.ctor>

  <FixedBitmap.AsString>
    <summary>
      返回固定位图的标识标签。
    </summary>
  </FixedBitmap.AsString>

  <FixedBitmap.SetBitmap>
    <summary>
      将位图图像与 FixedBitmap 静态控件关联。
    </summary>
    <param name="oBitmap">要与此静态控件关联的位图对象。</param>
  </FixedBitmap.SetBitmap>

  <FixedIcon>
    <summary>
      创建一个 FixedIcon 对象。<br />
      与 Icon 类创建的图标不同，FixedIcon 是静态的 — 每次发生 ExposeEvent 时都不需要重新显示。<br />
      FixedIcon 对象可以动态创建，也可以从资源实体创建。
    </summary>
    <example> 
      此示例从资源实体创建一个 FixedIcon ，并将其位置更改为对话框窗口的左下角： 
      <code language="X#">
        CLASS MyDialogWindow INHERIT DialogWindow
            HIDDEN OMyFIcon AS OBJECT

            METHOD Init(oWindow) CLASS MyDialogWIndow
                SUPER:Init(oWindow,ID_MYDIALOG)

                OMyFIcon := FixedIcon{SELF,MYICON}
                OMyFIcon:Origin := Point{10,10}

                SELF:Show()
      </code>
      在Windows中，FixedIcon 等同于具有 SS_ICON 样式的静态对象。这些通常在资源实体中指定如下： 
      <code language="X#">
        RESOURCE IDI_FIXEDICON ICON fixed.ico
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 80

        STYLE WS_POPUP | WS_DLGFRAME

        BEGIN
          ICON IDI_FIXEDICON -1, 8, 8, 0, 0
        END
      </code>
    </example>
  </FixedIcon>

  <FixedIcon.ctor>
    <summary>
      构造一个 FixedIcon 对象。
    </summary>
    <param name="uOwner">拥有 FixedIcon 的窗口。</param>
    <param name="uID">FixedIcon 的ID。</param>
    <param name="uPoint">FixedIcon 在画布坐标中的原点。</param>
    <param name="uResID">FixedIcon 的 ResourceID 对象或 FixedIcon 的资源ID。</param>
  </FixedIcon.ctor>

  <FixedIcon.AsString>
    <summary>
      返回 FixedIcon 的标识标签。
    </summary>
  </FixedIcon.AsString>

  <FixedIcon.Destroy>
    <summary>
      提供一种方法来取消实例化 FixedIcon 对象。
    </summary>
    <remarks>
      当不再需要 FixedIcon 对象时，可以使用此方法。<br />
      FixedIcon:Destroy() 取消实例化 FixedIcon 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </FixedIcon.Destroy>

  <FixedIcon.SetIcon>
    <exclude />
  </FixedIcon.SetIcon>

  <FixedImage>
    <summary>
      提供 FixedBitmap 和 FixedIcon 的子类的基类。
    </summary>
    <remarks>
      FixedImage 是 FixedBitmap 和 FixedIcon 子类的基类。
    </remarks>
  </FixedImage>

  <FixedImage.ctor>
    <summary>
      构造一个 FixedImage 控件。
    </summary>
    <param name="uOwner">拥有控件的窗口。</param>
    <param name="uID">控件的唯一ID(在1和8000之间)。</param>
    <param name="uPoint">控件在画布坐标中的原点。</param>
    <param name="uDimension">控件在画布坐标中的尺寸。</param>
    <param name="uResID">控件的资源ID。</param>
  </FixedImage.ctor>

  <FixedImage.Destroy>
    <summary>
      提供一种方法来取消实例化 FixedImage 对象。
    </summary>
    <remarks>
      当不再需要 FixedImage 对象时，可以使用此方法。<br />
      FixedImage:Destroy() 取消实例化 FixedImage 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </FixedImage.Destroy>

  <FixedText>
    <summary>
      创建一个 FixedText 对象。
    </summary>
    <remarks>
      与 Window:TextPrint() 显示的文本不同，FixedText 对象的固定文本是静态的—每次发生 ExposeEvent 时都不需要重新显示。<br />
      FixedText 对象可以动态创建，也可以从资源实体创建。
      <note type="tip">
        FixedText 对象中的文本可以通过分配 TextControl:TextValue 进行更改。
        在这种情况下，可能需要调整 FixedText 对象的大小，因为控件的大小决定了显示文本的剪切区域。
      </note>
      <note type="tip">
        从 Visual Obejcts 版本 2.7 开始，FixedText 控件支持 DrawText 和 Transparent 选项。这些选项默认为打开。<br />
        如果需要旧的行为，请将 EXPORTed 变量 lUseDrawText 设置为 FALSE。默认情况下，它为 TRUE。<br />
        如果启用了 WinXP 主题，并且要停止绘制 FixedText 控件后面的主题，请将 EXPORTed 变量 lDrawThemeBackground 设置为 FALSE。默认情况下，它为 TRUE。
      </note>
    </remarks>
    <example> 
      此示例在窗口上放置了一些固定文本： 
      <code language="X#">
        CLASS MyWindow INHERIT TopAppWindow
            HIDDEN MyFT AS OBJECT

            METHOD Init() CLASS MyWindow
                p := Point{10,10}
                d := Dimension{10,10}

                MyFT:= FixedText{SELF,1,p,d,"The text"}

                SELF:Show()
                MyFT:Show()
      </code>
      在 Windows 中，固定文本等同于具有 SS_LEFT、SS_CENTER、SS_RIGHT 样式的静态对象。 这些通常在资源实体中指定如下： 
      <code language="X#">
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 80
        STYLE WS_POPUP | WS_DLGFRAME

        BEGIN
            LTEXT "Left justified" -1, 8, 8, 120, 12
            CTEXT "Centered" -1, 8, 24, 120, 12
            RTEXT "Right justified" -1, 8, 36, 120, 12
            DEFPUSHBUTTON "OK" IDB_OK, 64, 60, 32, 14, WS_GROUP
        END
      </code>
    </example>
  </FixedText>

  <FixedText.ctor>
    <summary>
      构造一个 FixedText 对象。
    </summary>
    <param name="oOwner">拥有 FixedText 对象的窗口。</param>
    <param name="xID">FixedText 对象的唯一ID。</param>
    <param name="oPoint">FixedText 对象在画布坐标中的原点。</param>
    <param name="oDimension">FixedText 对象在画布坐标中的尺寸。</param>
    <param name="cText">要在 FixedText 对象中打印的信息文本。默认为 NULL_STRING。</param>
    <param name="lDataAware">指定 FixedText 对象是否为数据感知的逻辑值。</param>
    <param name="nResourceID">FixedText 对象的资源ID。</param>
  </FixedText.ctor>

  <FixedText.Destroy>
    <summary>
      提供一种方法来取消实例化 FixedText 对象。
    </summary>
    <remarks>
      当不再需要 FixedText 对象时，可以使用此方法。<br />
      FixedText:Destroy() 取消实例化 FixedText 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </FixedText.Destroy>

  <FixedText.Dispatch>
    <inheritdoc />
  </FixedText.Dispatch>

  <FixedText.lDrawThemeBackground>
    <exclude />
  </FixedText.lDrawThemeBackground>

  <FixedText.lUseDrawText>
    <exclude />
  </FixedText.lUseDrawText>

  <FixedText.SetDrawStyle>
    <summary>
      设置 FixedText 对象中文本的对齐样式。
    </summary>
    <param name="dwDrawStyle">要设置的样式。请参阅备注部分的表格。</param>
    <param name="lEnable">一个逻辑值，用于设置样式。TRUE 打开样式，FALSE 关闭样式。</param>
    <remarks>
      <list>
        <listheader>
          <term>值</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>DT_BOTTOM</term>
          <description>将文本对齐到矩形的底部。此值必须与 DT_SINGLELINE 组合使用。</description>
        </item>
        <item>
          <term>DT_CALCRECT</term>
          <description>
            确定矩形的宽度和高度。如果有多行文本，DrawText 使用 lpRect 参数指向的矩形的宽度，并扩展矩形的底部以限定最后一行的文本。
            如果只有一行文本，DrawText 修改矩形的右侧，以便它限定最后一个字符所在的行。在任何情况下，DrawText 返回格式化文本的高度，但不绘制文本。
          </description>
        </item>
        <item>
          <term>DT_CENTER</term>
          <description>在矩形中水平居中文本。</description>
        </item>
        <item>
          <term>DT_EDITCONTROL</term>
          <description>
            复制多行编辑控件的文本显示特性。具体来说，计算平均字符宽度的方法与编辑控件相同，函数不会显示部分可见的最后一行。
            如果需要，用省略号替换给定字符串的一部分，以使结果适合指定的矩形。除非指定了 DT_MODIFYSTRING 标志，否则不会修改给定的字符串。
            可以指定 DT_END_ELLIPSIS 以替换字符串末尾的字符，或者指定 DT_PATH_ELLIPSIS 以替换字符串中间的字符。
            如果字符串包含反斜杠(\)字符，DT_PATH_ELLIPSIS 尽可能保留最后一个反斜杠后的文本。
          </description>
        </item>
        <item>
          <term>DT_EXPANDTABS</term>
          <description>
            展开制表符。默认每个制表符的字符数为八个。
            包括字体外部行距在行高中。通常，外部行距不包括在一行文本的高度中。
          </description>
        </item>
        <item>
          <term>DT_LEFT</term>
          <description>将文本对齐到左边。</description>
        </item>
        <item>
          <term>DT_MODIFYSTRING</term>
          <description>
            修改给定的字符串以匹配显示的文本。
            除非指定了 DT_END_ELLIPSIS 或 DT_PATH_ELLIPSIS 标志，否则此标志无效。
          </description>
        </item>
        <item>
          <term>DT_NOCLIP</term>
          <description>不进行裁剪的绘制。使用 DT_NOCLIP 时，DrawText 会变得更快。</description>
        </item>
        <item>
          <term>DT_NOPREFIX</term>
          <description>
            关闭前缀字符的处理。
            通常，DrawText 会解释前缀字符&amp;作为一个指令，用于下划线紧跟其后的字符，并解释前缀字符&amp;&amp;作为一个指令，用于打印单个&amp;。
            通过指定 DT_NOPREFIX，这种处理被关闭。
          </description>
        </item>
        <item>
          <term>DT_RIGHT</term>
          <description>将文本对齐到右边。</description>
        </item>
        <item>
          <term>DT_RTLREADING</term>
          <description>
            对于双向文本，在 hdc 选择的字体是希伯来语或阿拉伯语字体时，按照从右到左的阅读顺序进行布局。所有文本的默认阅读顺序都是从左到右。
          </description>
        </item>
        <item>
          <term>DT_SINGLELINE</term>
          <description>仅在一行上显示文本。回车符和换行符不会断行。</description>
        </item>
        <item>
          <term>DT_TABSTOP</term>
          <description>
            设置制表符停止。uFormat 参数的高字节(低字节的高字节)指定每个制表符的字符数。默认每个制表符的字符数为八个。
          </description>
        </item>
        <item>
          <term>DT_TOP</term>
          <description>上对齐文本(仅限单行)。</description>
        </item>
        <item>
          <term>DT_VCENTER</term>
          <description>垂直居中文本(仅限单行)。</description>
        </item>
        <item>
          <term>DT_WORDBREAK</term>
          <description>
            断词。根据 lpRect 参数指定的矩形，如果一个词会超出边缘，自动在词之间断行。回车换行序列也会断行。
          </description>
        </item>
        <item>
          <term></term>
          <description></description>
        </item>
        <item>
          <term></term>
          <description></description>
        </item>
      </list>
    </remarks>
  </FixedText.SetDrawStyle>

  <FixedText.SetStandardStyle>
    <summary>
      设置 FixedText 对象中文本的对齐样式。
    </summary>
    <param name="kTextStyle"> 
      文本对齐样式，指定为以下常量之一： 
      <list type="Table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>FT_CENTERED</term>
          <description>居中对齐的文本</description>
        </item>
        <item>
          <term>FT_LEFTALIGN</term>
          <description>左对齐的文本(这是默认值。)</description>
        </item>
        <item>
          <term>FT_RIGHTALIGN</term>
          <description>右对齐的文本</description>
        </item>
      </list>
    </param>
  </FixedText.SetStandardStyle>

  <FocusChangeEvent>
    <summary>
      提供有关 FocusChangeEvent 的信息，用于指示窗口焦点的变化(即，获得或失去焦点)。
    </summary>
    <remarks>
      当窗口获得或失去焦点时，调度程序会生成一个 FocusChangeEvent 并将其发送到 Window:FocusChange()。<br />
      当输入焦点发生变化时，失去焦点的窗口会收到一个 FocusChangeEvent(告诉它正在失去焦点)，而获得焦点的窗口会收到一个 FocusChangeEvent(告诉它正在获得焦点)。<br />
      有焦点的窗口在用户按键盘时会收到 KeyEvents。这类似于活动窗口，但活动窗口会收到鼠标事件，而不是 KeyEvents。<br />
      提示：使用光标的应用程序应该使用 FocusChangeEvent 来确定是否创建或销毁光标。
    </remarks>
    <example> 
      以下示例在窗口获得焦点时锁定附加的数据服务器： 
      <code language="X#">
        METHOD FocusChange(oFCE) CLASS TopAppWindow
            IF(oFCE:GotFocus)
                Server:RLock()
            ELSE
                Server:Unlock()
            ENDIF
      </code>
    </example>
  </FocusChangeEvent>

  <FocusChangeEvent.ctor>
    <inheritdoc />
  </FocusChangeEvent.ctor>

  <FocusChangeEvent.GotFocus>
    <summary>
      一个逻辑值，确定窗口是否已经获得键盘焦点(TRUE)或即将失去它(FALSE)。
    </summary>
    <value>一个逻辑值，确定窗口是否已经获得键盘焦点(TRUE)或即将失去它(FALSE)。</value>
  </FocusChangeEvent.GotFocus>

  <Font>
    <summary>
      创建一个字体，描述字符在窗口上的显示方式。
    </summary>
    <remarks> 
      X# 提供了一组预定义的字体，使用 Font:Init() 方法定义。此外，如果需要，还可以通过指定特定的大小和样式来创建字体。<br />
      尽管您为新字体提供了具体的信息，但 GUI 实际上会选择最符合提供的描述的实际字体。<br />
      每个窗口都有一个当前选择的字体。当它们打印或调整文本大小时，Window:TextPrint() 和 Window:SizeText() 会使用这个字体。 
      <note type="tip">
        取消选择字体：在 Windows 中，应在销毁窗口之前取消选择当前字体。
        为此，使用 Window:Font 来分配先前的字体，例如。但是，只有在当前选择的字体不是默认字体时，才需要这样做。<br />
        字体间距：字体的间距可以是可变的或固定的。<br />
        在可变间距字体中，字符是按比例间隔的(例如，可变间距字体使用更多的空间来打印“M”比“i”)。
        在固定间距字体中，每个字符使用相同的空间，无论字符宽度如何。固定间距字体最常用于终端和打字机，或用于显示程序文本。<br />
        不一定支持可变间距字体。这取决于个别字体。
      </note>
    </remarks>
    <example> 
      以下文本说明了如何以斜体形式写一些文本： 
      <code language="X#">
        ...
        oMyFont         := Font{FONTROMAN10}
        oMyFont:Italic  := TRUE
        oOldFont        := oMyWindow:Font
        oMyWindow:Font  := oMyFont

        oMyWindow:TextPrint("斜体文本",Point{10,10})

        oMyWindow:Font  := oOldFont
      </code>
    </example>
  </Font>

  <Font.ctor>
    <summary>
      构造一个字体。
    </summary>
    <param name="kFont">
      要创建的标准字体，指定为备注部分中的表格中的常量之一或指示字体系列的常量。指定以下常量之一：
    </param>
    <param name="oDimension">字体的尺寸，以画布坐标或字体的窗口点大小指定。</param>
    <param name="sTypeFace">特定的字体名称。</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>kStandardFont</term>
          <description>点大小/字体</description>
        </listheader>
        <item>
          <term>FONTMODERN8</term>
          <description>8点Courier</description>
        </item>
        <item>
          <term>FONTMODERN10</term>
          <description>10点Courier</description>
        </item>
        <item>
          <term>FONTMODERN12</term>
          <description>12点Courier</description>
        </item>
        <item>
          <term>FONTROMAN8</term>
          <description>8点Times Roman</description>
        </item>
        <item>
          <term>FONTROMAN10</term>
          <description>10点Times Roman</description>
        </item>
        <item>
          <term>FONTROMAN12</term>
          <description>12点Times Roman</description>
        </item>
        <item>
          <term>FONTROMAN14</term>
          <description>14点Times Roman</description>
        </item>
        <item>
          <term>FONTROMAN18</term>
          <description>18点Times Roman</description>
        </item>
        <item>
          <term>FONTROMAN24</term>
          <description>24点Times Roman</description>
        </item>
        <item>
          <term>FONTSWISS8</term>
          <description>8点Helvetica</description>
        </item>
        <item>
          <term>FONTSWISS10</term>
          <description>10点Helvetica</description>
        </item>
        <item>
          <term>FONTSWISS12</term>
          <description>12点Helvetica</description>
        </item>
        <item>
          <term>FONTSWISS14</term>
          <description>14点Helvetica</description>
        </item>
        <item>
          <term>FONTSWISS18</term>
          <description>18点Helvetica</description>
        </item>
        <item>
          <term>FONTSWISS24</term>
          <description>24点Helvetica</description>
        </item>
        <item>
          <term>FONTSYSTEM8</term>
          <description>8点默认系统字体</description>
        </item>
        <item>
          <term></term>
          <description></description>
        </item>
      </list>
      <list type="table">
        <listheader>
          <term>kFamiliy</term>
          <description>字体系列</description>
        </listheader>
        <item>
          <term>FONTANY</term>
          <description>任何可显示的字体。这是默认值。 </description>
        </item>
        <item>
          <term>FONTDECORATIVE</term>
          <description>系统相关的装饰字体，例如FormalScrp421 BT。</description>
        </item>
        <item>
          <term>FONTMODERN</term>
          <description>类似于Courier。 </description>
        </item>
        <item>
          <term>FONTROMAN</term>
          <description>类似于Times Roman</description>
        </item>
        <item>
          <term>FONTSCRIPT</term>
          <description>类似于手写脚本，例如BrushScript</description>
        </item>
        <item>
          <term>FONTSWISS</term>
          <description>类似于Helvetica。</description>
        </item>
      </list>
      定义所需的字体可能是复杂的，有两个原因：不同的计算机可能安装了不同的字体集，同一个字体在不同的计算机上可能有不同的名称。<br />
      例如，Helvetica 字体系列在不同的系统上可能被称为 Helvetica，Helv，Helvetica，Arial，Swiss 或 MS Sans Serif，取决于您使用的系统。
      这里的标准名称是 FontSwiss。<br />
      为了确保程序在每台计算机上都能工作，无论每台计算机上都有哪些字体可用，Font类提供了自动方法，用于找到与您指定的字体最合理的匹配。
      实际上，只要使用最常见的名称，您就不会遇到问题，因为所有版本的Windows都包含标准字体。 <br />
      例如，要创建一个10点Times New Roman 的字体和一个8点 Helvetica 的字体： 
      <code language="X#">
        oFontRoman := Font{FONTROMAN10} //
        oFontSwiss := Font{FONTSWISS8} //
      </code>
      系统允许您引用安装在机器上的任何字体。例如，要创建一个12点 Palatino 的字体， 
      <code language="X#">
        oMyFont := Font{,Dimension{12,12},"Palatino"} // 
      </code> 
      或一个16点Arial的字体： 
      <code language="X#">
        oMyFont := Font{, 16, "Arial"} // 
      </code>
      当然，这种方法容易受到字体不可用的影响。如果 Palatino 不可用，系统会选择一个合理的类似字体，如果从未听说过 Palatino，这可能不是一个好的匹配。
      为了帮助系统找到一个合理的匹配，您可以指定 Palatino 属于哪个字体系列：
      <code language="X#">
        oMyFont := Font{FONTROMAN, Dimension{12,12},"Palatino"}
      </code>
      在这种情况下，如果 Palatino 不可用，我们会得到 Times Roman。 您只能指定系列。例如，要创建一个10点字体，无论在脚本系列中可用的是什么： 
      <code language="X#">
        oMyFont := Font{FONTSCRIPT,Dimension{10,10}}
      </code>
    </remarks>
  </Font.ctor>

  <Font.Bold>
    <summary>
      一个逻辑值，确定字体是否以粗体显示(如果是，为 TRUE；否则，为 FALSE)。
    </summary>
    <value>一个逻辑值，确定字体是否以粗体显示(如果是，为 TRUE；否则，为 FALSE)。</value>
    <remarks>
      <note type="tip">
        对于任何字体，Font:Light，Font:Normal 和 Font:Bold 属性中只能有一个为 TRUE。
      </note>
    </remarks>
  </Font.Bold>

  <Font.CharSet>
    <exclude />
  </Font.CharSet>

  <Font.ClipPrecision>
    <exclude />
  </Font.ClipPrecision>

  <Font.ConvPntToDim>
    <summary>
      将字体的指定点大小转换为 Dimension 对象。
    </summary>
    <param name="nPntSize">Windows 字体的点大小。</param>
    <param name="hDCConv">要转换点大小的设备上下文的句柄。如果省略，将默认为窗口画布。</param>
    <returns>
      表示指定点大小的 Dimension 对象。
    </returns>
    <remarks>
      此方法将 Windows 字体的点大小转换为适合在窗口画布上绘制的 X# Dimension 对象。
    </remarks>
  </Font.ConvPntToDim>

  <Font.Create>
    <exclude />
  </Font.Create>

  <Font.Destroy>
    <summary>
      提供一种方法，用于取消实例化 Font 对象。
    </summary>
    <remarks>
      当不再需要 Font 对象时，可以使用此方法。Font:Destroy() 会取消实例化 Font 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </Font.Destroy>

  <Font.Escapement>
    <exclude />
  </Font.Escapement>

  <Font.FaceName>
    <exclude />
  </Font.FaceName>

  <Font.Handle>
    <summary>
      返回字体的句柄。
    </summary>
    <param name="nHandleType"> 所需句柄的类型。0是唯一支持的选项，如果省略 <paramref name="nHandle" />，则默认为0。 </param>
    <returns>
      描述底层系统对象的句柄。
    </returns>
    <remarks>
      此方法提供了 Windows GDI 对象的句柄，可以在 Windows API GDI 调用中使用。
    </remarks>
  </Font.Handle>

  <Font.Height>
    <exclude />
  </Font.Height>

  <Font.Italic>
    <summary>
      一个逻辑值，确定字体是否以斜体显示(如果是，为 TRUE；否则，为 FALSE)。
    </summary>
    <value>一个逻辑值，确定字体是否以斜体显示(如果是，为 TRUE；否则，为 FALSE)。</value>
  </Font.Italic>

  <Font.Light>
    <summary>
      一个逻辑值，确定字体是否以轻体显示(如果是，为 TRUE；否则，为 FALSE)。Light 是粗体的反义词。
    </summary>
    <value>一个逻辑值，确定字体是否以轻体显示(如果是，为 TRUE；否则，为 FALSE)。Light 是粗体的反义词。</value>
    <remarks>
      <note type="tip">
        对于任何字体，Font:Light，Font:Normal 和 Font:Bold 属性中只能有一个为 TRUE。
      </note>
    </remarks>
  </Font.Light>

  <Font.Normal>
    <summary>
      一个逻辑值，确定字体是否以普通字体显示(如果是，为 TRUE；否则，为 FALSE)。
    </summary>
    <value>一个逻辑值，确定字体是否以普通字体显示(如果是，为 TRUE；否则，为 FALSE)。</value>
    <remarks>
      <note type="tip">
        对于任何字体，Font:Light，Font:Normal 和 Font:Bold 属性中只能有一个为 TRUE。
      </note>
    </remarks>
  </Font.Normal>

  <Font.Orientation>
    <exclude />
  </Font.Orientation>

  <Font.OutPrecision>
    <exclude />
  </Font.OutPrecision>

  <Font.PitchAndFamily>
    <exclude />
  </Font.PitchAndFamily>

  <Font.PitchFixed>
    <summary>
      一个逻辑值，确定字体是否以固定间距字体显示(如果是，为 TRUE；否则，为 FALSE)。
    </summary>
    <value>一个逻辑值，确定字体是否以固定间距字体显示(如果是，为 TRUE；否则，为 FALSE)。</value>
    <remarks>
      <note type="tip">对于任何字体，Font:PitchFixed 或 Font:PitchVariable 属性中只能有一个为 TRUE。</note>
    </remarks>
  </Font.PitchFixed>

  <Font.PitchVariable>
    <summary>
      一个逻辑值，确定字体是否以可变间距字体显示(如果是，为 TRUE；否则，为 FALSE)。
    </summary>
    <value>一个逻辑值，确定字体是否以可变间距字体显示(如果是，为 TRUE；否则，为 FALSE)。</value>
    <remarks>
      <note type="tip">对于任何字体，Font:PitchFixed 或 Font:PitchVariable 属性中只能有一个为 TRUE。</note>
    </remarks>
  </Font.PitchVariable>

  <Font.PointSize>
    <exclude />
  </Font.PointSize>

  <Font.Quality>
    <exclude />
  </Font.Quality>

  <Font.Size>
    <exclude />
  </Font.Size>

  <Font.SizeText>
    <exclude />
  </Font.SizeText>

  <Font.Strikethru>
    <summary>
      一个逻辑值，确定字体是否以删除线字体显示(如果是，为 TRUE；否则，为 FALSE)。删除线字体在每个字符上放置一条线。
    </summary>
    <value>一个逻辑值，确定字体是否以删除线字体显示(如果是，为 TRUE；否则，为 FALSE)。删除线字体在每个字符上放置一条线。</value>
  </Font.Strikethru>

  <Font.Underline>
    <summary>
      一个逻辑值，确定字体是否以下划线字体显示(如果是，为 TRUE；否则，为 FALSE)。
    </summary>
    <value>一个逻辑值，确定字体是否以下划线字体显示(如果是，为 TRUE；否则，为 FALSE)。</value>
  </Font.Underline>

  <Font.Weight>
    <exclude />
  </Font.Weight>

  <Font.Width>
    <exclude />
  </Font.Width>

  <FormattedTextObject>
    <summary>
      提供一种方法，用于格式化一个字符串，指定位置(原点)、字体和颜色。
    </summary>
    <remarks>
      一个 FormattedTextObject 对象具有与 TextObject 对象相同的行为，但它识别像 tab(Chr(9))、
      carriage return(Chr(13)) 和 newline(Chr(10)) 这样的字符，并能够适当地翻译它们。<br />
      您可以使用 FormattedTextObject:TabSize 来更改 FormattedTextObject 对象的默认 tab，并使用 Window:Draw() 方法来显示它。
    </remarks>
    <example> 
      这个例子使用一个格式化文本对象在"Hello"下面打印"World"： 
      <code language="X#">
        oFT := FormattedTextObject{Point{10,10},"Hello" + Chr(10) + "World"}
        ?oFT
      </code>
    </example>
  </FormattedTextObject>

  <FormattedTextObject.ctor>
    <summary>
      构造一个 FormattedTextObject 对象。
    </summary>
    <param name="oPoint">FormattedTextObject 对象在画布坐标中的原点。默认为 Point{16, 16}。</param>
    <param name="cText">在FormattedTextObject 对象中显示的文本。</param>
    <param name="oFont">FormattedTextObject 对象使用的字体。默认为系统字体。</param>
    <param name="oColor">FormattedTextObject 对象使用的颜色。默认为当前窗口的颜色选择。(有关指定颜色的详细信息，请参阅 Color:Init() 方法。)</param>
  </FormattedTextObject.ctor>

  <FormattedTextObject.Draw>
    <summary>
      在窗口上绘制一个 FormattedTextObject 对象。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      此方法在系统内部由 Window:Draw() 调用。 
    </remarks>
  </FormattedTextObject.Draw>

  <FormattedTextObject.TabSize>
    <summary>
      一个数字值，表示 FormattedTextObject 对象的 tab 大小(以字符为单位)。默认 tab 大小为8。
    </summary>
    <value>一个数字值，表示 FormattedTextObject 对象的 tab 大小(以字符为单位)。默认 tab 大小为8。</value>
  </FormattedTextObject.TabSize>

  <FSError>
    <exclude />
  </FSError>

  <FSError.ctor>
    <exclude />
  </FSError.ctor>

  <GroupBox>
    <summary>
      创建一个分组框，可以用来将相关的控件组合在一起。
    </summary>
    <remarks> 
      一个分组框是一个单行框，带有一个适当的标题，用于标识组的性质。它应该在窗口表面上的相关控件周围绘制，并且可以包含一个或多个选择集。
      使用 TextControl的Init() 方法创建一个分组框。此外，可以使用 TextControl 的 TextValue 赋值方法更改分组框的标题。 
      <note type="tip">
        CUA 风格：根据 CUA 指南，您不应该将分组框用于一个或多个推按钮或列表框的集合。
        相反，分组框在"打印文件"对话框中会更有用，例如，可以将一些选项(如"副本"编辑控件和"打印颜色"复选框)组合在一起。
      </note>
    </remarks>
  </GroupBox>

  <GroupBox.ctor>
    <summary>
      构造一个分组框。
    </summary>
    <param name="oOwner">拥有分组框的窗口。</param>
    <param name="xID">分组框的唯一ID(在1和8000之间)。</param>
    <param name="oPoint">分组框在画布坐标中的原点。</param>
    <param name="oDimension">分组框在画布坐标中的尺寸。</param>
    <param name="cText">分组框的标题。默认为 NULL_STRING。</param>
    <param name="lDataAware">一个逻辑值，指定分组框是否是数据感知的。</param>
    <param name="nResourceID">分组框的资源ID。</param>
  </GroupBox.ctor>

  <GroupBox.AsString>
    <summary>
      返回分组框的标识标签。
    </summary>
    <remarks>
      GroupBox:AsString() 将分组框控件呈现为一个可识别的字符串，格式为&lt;ClassName&gt; - &lt;Caption&gt;。
    </remarks>
  </GroupBox.AsString>

  <GroupBox.CurrentText>
    <summary>
      此属性用于覆盖从 TextControl 类继承的功能，因为它不适用于分组框。
    </summary>
    <value>此属性用于覆盖从 TextControl 类继承的功能，因为它不适用于分组框。</value>
  </GroupBox.CurrentText>

  <GroupBox.Destroy>
    <summary>
      提供一种方法，用于取消实例化一个 GroupBox 对象。
    </summary>
    <remarks>
      当不再需要一个 GroupBox 对象时，可以使用此方法。<br />
      GroupBox:Destroy() 会取消实例化 GroupBox 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </GroupBox.Destroy>

  <HelpDisplay>
    <summary>
      在使用的帮助系统中创建一个链接。
    </summary>
    <remarks>
      HelpDisplay 类允许您轻松为应用程序提供在线帮助。GUI 提供的帮助系统资源可以保留在内存中，直到删除 HelpDisplay 对象。
      因此，在应用程序终止之前，请确保删除或使 HelpDisplay 对象超出范围。<br />
      HelpDisplay 提供了一种在给定主题上显示帮助的方法。但是，应用程序仍然需要一种方法来确定需要哪个主题的帮助。
      对于大型应用程序，大多数 GUI 风格指南建议从菜单栏提供帮助命令。这些命令可以通过 MenuCommandEvent 处理，以响应地显示适当的帮助信息。
      另一种方法是使用推按钮来获取特定主题的帮助。使用推按钮和 ButtonClick() 事件处理，您可以在按下帮助按钮时，编程应用程序显示相关的帮助信息。
      实际上，应用程序的帮助功能应该结合菜单命令和按钮，以提供帮助。<br />
      上下文相关的帮助意味着用户在选择帮助键或鼠标序列时，会收到与当前活动相关的帮助。例如，当响应对话框窗口时，用户可能需要焦点控件的帮助。 
      X# 应用程序可以为以下内容提供上下文相关的帮助：<br />
      屏幕的特定区域(如标题栏和画布区域) 菜单命令 控件(如推按钮、编辑控件和工具栏按钮)<br />
      为了支持一个可移植的上下文相关的帮助系统，X# 提供了 HelpRequestEvent 类，Window:HelpDisplay 属性和 Window:HelpRequest() 事件处理方法。
      (HelpRequest() 确定帮助触发器的来源，即请求帮助的特定项目，并将此信息传递给 GUI 的帮助系统。)<br />
      有关如何为应用程序编程在线帮助系统的更多信息，请参阅程序员指南中的"GUI类"章节。 
      <note type="tip">
        EXPORTed 变量 DefaultPageOnContents 是一个 LOGIC，默认为 TRUE。
        它用于确定是否在请求 HelpContents 时应显示默认页面。如果设置为 FALSE，'HelpContents'将显示内容选项卡，但保留当前主题的显示。仅适用于 HTML 帮助。
      </note>
    </remarks>
    <example> 
      下面的例子处理了两个常见的菜单命令，帮助索引和使用帮助： 
      <code language="X#">
        CLASS MyWindow INHERIT TopAppWindow
            METHOD Init() CLASS MyWindow
                SUPER:Init()
                SELF:HelpDisplay := HelpDisplay{"mywind.hlp"}

            METHOD MenuCommand(oMCE) CLASS MyWindow
                LOCAL nItemID := oMCE:ItemID

                DO CASE
                    CASE nItemID = IDM_MENU_HELP_INDEX_ID
                        SELF:HelpDisplay:Show("HelpIndex")

                    CASE nItemID = IDM_MENU_HELP_USINGHELP_ID
                        SELF:HelpDisplay:Show("HelpOnHelp")

                    OTHERWISE
                        SUPER:MenuCommand(oMCE)
                ENDCASE
      </code>
    </example>
  </HelpDisplay>

  <HelpDisplay.ctor>
    <summary>
      为指定的帮助数据库构造一个帮助显示。
    </summary>
    <param name="cFileName">要连接到的帮助数据库的文件名。</param>
    <param name="oOwnerWindow">拥有此帮助显示的窗口对象，如果有的话。</param>
    <param name="lWin32Processing">当为 TRUE 时，这将告诉 X# 使用标准的 WIN32 帮助处理</param>
    <remarks>
      X# 2.8 已添加对使用基于 WM_HELP 消息的标准 Win32 帮助处理的支持，自 Windows95 以来。
      在这种模式下，禁用了类似 VO 的在线帮助，这意味着 SHIFT-F1 和鼠标帮助不起作用。
      另一方面，Windows 标准帮助光标得到了充分支持，标题栏上的帮助按钮也是如此。<br />
      参见：Window:EnableHelpButton() 和 Window:EnableHelpCursor()<br />
      此外，只有在这种模式下才支持文本弹出窗口。
    </remarks>
  </HelpDisplay.ctor>

  <HelpDisplay.DefaultPageOnContents>
    <exclude />
  </HelpDisplay.DefaultPageOnContents>

  <HelpDisplay.Destroy>
    <exclude />
  </HelpDisplay.Destroy>

  <HelpDisplay.EnableHTMLHelp>
    <exclude />
  </HelpDisplay.EnableHTMLHelp>

  <HelpDisplay.HelpError>
    <summary>
      确定上一次 HelpDisplay 操作是否成功。
    </summary>
    <returns>
      <para>以下常量之一，指示上一次调用 HelpDisplay 的操作的成功或失败：</para>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>HDCANTOPENFILE</term>
          <description>帮助操作无法打开帮助数据库。</description>
        </item>
        <item>
          <term>HDINVALIDKEY</term>
          <description>在 HelpDisplay:Show() 中使用了无效的键。</description>
        </item>
        <item>
          <term>HDOK</term>
          <description>操作成功。</description>
        </item>
        <item>
          <term>HDOUTOFMEMORY</term>
          <description>
            由于内存不足或其他系统资源，操作失败。
          </description>
        </item>
        <item>
          <term>HDUNKNOWN</term>
          <description>无法确定上一次操作失败的原因。</description>
        </item>
      </list>
    </returns>
  </HelpDisplay.HelpError>

  <HelpDisplay.Show>
    <summary>
      指示帮助系统提供与给定关键字相关联的帮助主题。
    </summary>
    <param name="cKeyword">
      要在应用程序帮助文件中查找的关键字。请参阅备注部分的表格。
    </param>
    <param name="symLookupType">
      控制查找类型。默认为 HH_KEYWORD_LOOKUP。
      用于调用帮助文件中的关联链接。关联链接不在索引中显示，关键字在索引中显示。仅适用于 HTML 帮助。<br />
      第二个参数 symLookupType 也可以是一个指向 _winHelpInfo 结构的 PTR，它将随着 WM_HELP 消息一起发送。
    </param>
    <remarks> 
      下面的保留关键字不对应于应用程序帮助文件中编码的任何内容。 相反，它们是由系统提供的，旨在为您提供访问某些标准帮助特性的方式: 
      <list type="table">
        <listheader>
          <term>保留关键字</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>HelpIndex</term>
          <description>显示应用程序帮助文件中定义的内容或索引主题(以最后显示的为准)。</description>
        </item>
        <item>
          <term>HelpOnHelp</term>
          <description>
            显示 Windows 帮助文件中定义的内容主题(通常为 WINHELP.HLP，其中内容主题为如何使用帮助)。
            这在 .CHM 帮助中不可用。
          </description>
        </item>
        <item>
          <term>HelpSearch</term>
          <description>
            显示帮助导航窗格中的搜索选项卡。仅适用于 HTML 帮助。
          </description>
        </item>
        <item>
          <term># followed by a number.</term>
          <description>
            数字代表测试弹出帮助的ID。仅适用于 HTML 帮助，并且必须启用 Win32Processing 模式。
          </description>
        </item>
        <item>
          <term>~ followed by a keyword.</term>
          <description>
            这强制执行 HH_ALINK_LOOKUP。用于调用帮助文件中的关联链接。关联链接不显示在索引中，关键字显示。仅适用于 HTML 帮助。
          </description>
        </item>
      </list>
    </remarks>
    <returns> 
      如果查找操作正确执行，则返回 TRUE；否则返回 FALSE。 
      <note type="tip">返回 TRUE 并不意味着键已找到。</note>
    </returns>
    <remarks>
      当查找无效或未知键时，GUIs 的行为不同。
      虽然大多数都会向用户显示警告消息(例如，键未找到)，但您应该假设这种行为是未定义的，并确保被查找的键存在于帮助数据库中。
    </remarks>
  </HelpDisplay.Show>

  <HelpDisplay.Win32Processing>
    <exclude />
  </HelpDisplay.Win32Processing>

  <HelpRequestEvent>
    <summary>
      提供关于 HelpRequestEvent 的信息，用于描述请求帮助的上下文和项组合(例如，控件、菜单命令和窗口特定区域的帮助)。
    </summary>
  </HelpRequestEvent>

  <HelpRequestEvent.ctor>
    <inheritdoc />
  </HelpRequestEvent.ctor>

  <HelpRequestEvent.HelpContext>
    <summary>
      一个字符串，表示生成此控件事件的控件的帮助上下文ID。
    </summary>
    <value>一个字符串，表示生成此控件事件的控件的帮助上下文ID。</value>
    <remarks> 
      一个字符串，表示生成此控事件的控件的帮助上下文ID。这个ID包含在控件的超链接标签中。 
      <note type="tip">
        帮助上下文ID指示了系统在哪里查找关于此控件的帮助信息。
      </note>
    </remarks>
  </HelpRequestEvent.HelpContext>

  <HelpRequestEvent.HelpInfo>
    <summary>
      如果帮助请求来自 WM_HELP 消息，则为指向 _winHelpInfo 结构的 PTR；否则为 Null_Ptr。
    </summary>
    <value>如果帮助请求来自 WM_HELP 消息，则为指向 _winHelpInfo 结构的 PTR；否则为 Null_Ptr。</value>
  </HelpRequestEvent.HelpInfo>

  <HelpRequestEvent.HelpType>
    <summary>
      一个常量，指示请求帮助的项类型—菜单、控件或窗口区域：
    </summary>
    <value>一个常量，指示请求帮助的项类型—菜单、控件或窗口区域：</value>
    <remarks> 
      下列常量之一，指示请求帮助的项类型—菜单、控件或窗口区域： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>HELPCONTROL</term>
          <description>请求控件的帮助。</description>
        </item>
        <item>
          <term>HELPMENU</term>
          <description>请求菜单命令的帮助。</description>
        </item>
        <item>
          <term>HELPWINDOW</term>
          <description>请求窗口区域或画布上的点的帮助。</description>
        </item>
        <item>
          <term>HELPINFO</term>
          <description>帮助请求来自 WM_HELP 消息。</description>
        </item>
      </list>
    </remarks>
  </HelpRequestEvent.HelpType>

  <HelpRequestEvent.HyperLabel>
    <summary>
      连接到帮助请求事件的超链接标签。
    </summary>
    <value>连接到帮助请求事件的超链接标签。</value>
    <remarks> 
      连接到帮助请求事件的超链接标签。从超链接标签中，您可以检索关于帮助请求事件的更多信息—例如： 
      <code language="X#">
        cCaption := oHelpRequestEvent:HyperLabel:Caption
        cDescription := oHelpRequestEvent:HyperLabel:Description
        cHelpContext := oHelpRequestEvent:HyperLabel:HelpContext
      </code>
    </remarks>
  </HelpRequestEvent.HyperLabel>

  <HelpRequestEvent.ItemID>
    <summary>
      一个数值，表示用户请求帮助的项的ID。
    </summary>
    <value>一个数值，表示用户请求帮助的项的ID。</value>
    <remarks> 
      一个数值，表示用户请求帮助的项的ID。 这个ID的确切含义取决于项的类型： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>ID 返回</description>
        </listheader>
        <item>
          <term>HELPCONTROL</term>
          <description>控件的唯一ID。</description>
        </item>
        <item>
          <term>HELPMENU</term>
          <description>菜单命令的唯一ID。</description>
        </item>
        <item>
          <term>HELPWINDOW</term>
          <description>
            窗口区域的唯一ID。HelpRequestEvent:WindowRegion 访问确定了帮助指针位于窗口的哪个区域(可能是系统菜单、边框、画布、未知等)。
          </description>
        </item>
      </list>
    </remarks>
  </HelpRequestEvent.ItemID>

  <HelpRequestEvent.Position>
    <summary>
      鼠标指针在画布坐标系中的位置。
    </summary>
    <value>鼠标指针在画布坐标系中的位置。</value>
    <remarks>
      鼠标指针在画布坐标系中的位置。
      这个方法是为了支持类型为 HelpWindow 的帮助请求(参照 HelpRequestEvent:HelpType 赋值)以允许画布的特定区域有不同的帮助信息显示。
      HelpRequestEvent:WindowRegion 访问应该用于确定帮助指针是否在画布上。返回的点在其他情况下不相关。
    </remarks>
  </HelpRequestEvent.Position>

  <HelpRequestEvent.WindowRegion>
    <summary>
      一个常量，指示帮助指针在生成此 HelpRequestEvent 时所在的窗口区域：
    </summary>
    <value>一个常量，指示帮助指针在生成此 HelpRequestEvent 时所在的窗口区域：</value>
    <remarks> 
      下列常量之一，指示帮助指针在生成此 HelpRequestEvent 时所在的窗口区域： 
      <note type="tip">
        返回值仅为类型为 HelpWindow 的 HelpRequestEvents 定义(参照 HelpRequestEvent:ItemID 访问)。
      </note>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>REGIONBORDER</term>
          <description>窗口边框</description>
        </item>
        <item>
          <term>REGIONCANVAS</term>
          <description>窗口区域或画布上的点</description>
        </item>
        <item>
          <term>REGIONCAPTION</term>
          <description>窗口标题</description>
        </item>
        <item>
          <term>REGIONMAXBOX</term>
          <description>最大化框</description>
        </item>
        <item>
          <term>REGIONMENUBAR</term>
          <description>菜单命令</description>
        </item>
        <item>
          <term>REGIONMINBOX</term>
          <description>最小化框</description>
        </item>
        <item>
          <term>REGIONSIZEBOX</term>
          <description>大小框</description>
        </item>
        <item>
          <term>REGIONSYSTEMMENUBOX</term>
          <description>系统菜单</description>
        </item>
        <item>
          <term>REGIONUNKNOWN</term>
          <description>帮助系统无法确定本地化的上下文</description>
        </item>
      </list>
    </remarks>
  </HelpRequestEvent.WindowRegion>

  <HLError>
    <exclude />
  </HLError>

  <HLError.ctor>
    <exclude />
  </HLError.ctor>

  <HorizontalScrollBar>
    <summary>
      创建一个独立于其所有者窗口的水平滚动条。
    </summary>
    <remarks> 
      X# 中有两种类型的水平滚动条：常规(使用 CLASS HorizontalScrollBar 创建)和窗口(使用 AppWindow:EnableHorizontalScroll() 方法创建)。<br />
      两种类型都有一个所有者窗口，并且可以使用 Window:HorizontalScroll() 进行操作。
      然而，窗口水平滚动条不同之处在于，它自动沿着其所有者窗口的画布区域的底部对齐，并且根据其所有者窗口的大小自动调整大小。
      水平滚动条允许用户通过移动滑块位置、点击滚动条两端的按钮以改变数值(根据 ScrollBar:UnitSize)，
      或点击滚动条内部以改变数值(根据 ScrollBar:BlockSize)，来更新一个短整数数值。<br />
      最小和最大允许的数值由与滚动条关联的 Range 对象的 Min 和 Max 值表示。<br />
      ScrollBar:Value 访问表示当前选定的数值。滚动条可以绑定到服务器中的一个数值字段。
      <note type="tip">
        默认情况下，Window:HorizontalScroll() 更新滚动条的滑块位置(可以被拖拽的标记)。如果需要，可以使用自己的实现来更改此行为。
      </note>
      在 Windows 中，水平滚动条等同于具有 SBS_HORZ 样式的滚动条。它们通常在资源实体中指定如下： 
      <code language="X#">
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 120
        STYLE WS_POPUP | WS_DLGFRAME
        BEGIN
            CONTROL "", IDS_RED,    "scrollbar", SBS_HORZ, 10, 16, 100, 20
            CONTROL "", IDS_BLUE,   "scrollbar", SBS_HORZ, 10, 46, 100, 20
            CONTROL "", IDS_GREEN,  "scrollbar", SBS_HORZ, 10, 76, 100, 20
        END
      </code>
    </remarks>
  </HorizontalScrollBar>

  <HorizontalScrollBar.ctor>
    <summary>
      构造一个水平滚动条。
    </summary>
    <param name="oOwner">拥有水平滚动条的窗口。</param>
    <param name="xID">水平滚动条的唯一ID(1到8000之间)。</param>
    <param name="oPoint">水平滚动条在画布坐标中的原点。</param>
    <param name="oDimension">水平滚动条在画布坐标中的尺寸。</param>
    <param name="nResourceID">水平滚动条的资源ID。</param>
  </HorizontalScrollBar.ctor>

  <HorizontalScrollBar.Destroy>
    <summary>
      提供一种方法来取消实例化 HorizontalScrollBar 对象。
    </summary>
    <remarks>
      当不再需要 HorizontalScrollBar 对象时，可以使用此方法。
      HorizontalScrollBar:Destroy() 取消实例化 HorizontalScrollBar 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </HorizontalScrollBar.Destroy>

  <HorizontalSelectionSlider>
    <summary>
      创建一个水平选择滑块控件。
    </summary>
    <remarks>
      一个水平选择滑块是一个控件，它包含一个拇指、可选的刻度线和一个选择条。用户可以使用鼠标或方向键移动水平选择滑块的拇指。
    </remarks>
  </HorizontalSelectionSlider>

  <HorizontalSelectionSlider.ctor>
    <summary>
      构造一个水平选择滑块。
    </summary>
    <param name="oOwner">拥有水平选择滑块的窗口。</param>
    <param name="xID">水平选择滑块的唯一ID(1到8000之间)。</param>
    <param name="nResourceID">水平选择滑块的资源ID。</param>
    <param name="oPoint">水平选择滑块在画布坐标中的原点。</param>
    <param name="oDimension">水平选择滑块在画布坐标中的尺寸。</param>
  </HorizontalSelectionSlider.ctor>

  <HorizontalSlider>
    <summary>
      创建一个水平滑块控件。
    </summary>
    <remarks>
      一个水平滑块是一个控件，它包含一个拇指和可选的刻度线。用户可以使用鼠标或方向键移动水平滑块的拇指。
    </remarks>
  </HorizontalSlider>

  <HorizontalSlider.ctor>
    <summary>
      构造一个水平滑块。
    </summary>
    <param name="oOwner">拥有水平滑块的窗口。</param>
    <param name="xID">水平滑块的唯一ID(1到8000之间)。</param>
    <param name="nResourceID">水平滑块的资源ID。</param>
    <param name="oPoint">水平滑块在画布坐标中的原点。</param>
    <param name="oDimension">水平滑块在画布坐标中的尺寸。</param>
  </HorizontalSlider.ctor>

  <HorizontalSpinner>
    <summary>
      创建一个带有水平箭头按钮的微调器。
    </summary>
    <remarks>
      一个水平微调器是一对左右指向的箭头按钮，可以点击以更改一个值，例如在另一个控件中显示的数字。<br />
      水平微调器可以独立存在，但通常与另一个控件一起使用，称为客户端。
    </remarks>
  </HorizontalSpinner>

  <HorizontalSpinner.ctor>
    <summary>
      构造一个水平微调器。
    </summary>
    <param name="oOwner">拥有水平微调器的窗口。</param>
    <param name="xID">水平微调器的唯一ID(1到8000之间)。</param>
    <param name="nResourceID">水平微调器的资源ID。</param>
    <param name="oPoint">水平微调器在画布坐标中的原点。</param>
    <param name="oDimension">水平微调器在画布坐标中的尺寸。</param>
    <param name="kStyle">水平微调器的样式。</param>
  </HorizontalSpinner.ctor>

  <HotKey>
    <summary>
      创建一个热键。
    </summary>
    <remarks>
      一个热键是一个对象，可以应用于热键编辑控件，为窗口设置一个有效的键组合。当按下键组合时，系统会激活给定的窗口。
    </remarks>
  </HotKey>

  <HotKey.ctor>
    <summary>
      构造一个热键。
    </summary>
    <param name="bKey">热键的虚拟键码。</param>
    <param name="lAlt">指定是否要使用 Alt 键作为热键。</param>
    <param name="lCtl">指定是否要使用 Ctl 键作为热键。</param>
    <param name="lShift">指定是否要使用 Shift 键作为热键。</param>
    <param name="lExt">指定是否要使用扩展键(数字键盘上的键)作为热键。</param>
  </HotKey.ctor>

  <HotKey.AltKey>
    <summary>
      一个逻辑值，如果 Alt 键对于热键是有效的，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果 Alt 键对于热键是有效的，则为 TRUE。</value>
  </HotKey.AltKey>

  <HotKey.CtrlKey>
    <summary>
      一个逻辑值，如果 Ctl 键对于热键是有效的，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果 Ctl 键对于热键是有效的，则为 TRUE。</value>
  </HotKey.CtrlKey>

  <HotKey.ExtendedKey>
    <summary>
      一个逻辑值，如果扩展键对于热键是有效的，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果扩展键对于热键是有效的，则为 TRUE。</value>
  </HotKey.ExtendedKey>

  <HotKey.Key>
    <summary>
      热键的虚拟键码。
    </summary>
    <value>热键的虚拟键码。</value>
  </HotKey.Key>

  <HotKey.ShiftKey>
    <summary>
      一个逻辑值，如果 Shift 键对于热键是有效的，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果 Shift 键对于热键是有效的，则为 TRUE。</value>
  </HotKey.ShiftKey>

  <HotKeyEdit>
    <summary>
      创建一个热键编辑。
    </summary>
    <remarks>
      一个热键编辑是一个控件，可以用于将一个键组合应用于窗口，以便在按下组合键时，系统会激活窗口。
    </remarks>
  </HotKeyEdit>

  <HotKeyEdit.ctor>
    <summary>
      构造一个热键编辑。
    </summary>
    <param name="oOwner">拥有热键编辑的窗口。</param>
    <param name="xID">热键编辑的唯一ID(1到8000之间)。</param>
    <param name="nResourceID">热键编辑的资源ID。</param>
    <param name="oPoint">热键编辑在画布坐标中的原点。</param>
    <param name="oDimension">热键编辑在画布坐标中的尺寸。</param>
    <param name="kStyle">热键编辑的样式。</param>
  </HotKeyEdit.ctor>

  <HotKeyEdit.ApplyHotKey>
    <summary>
      将与此控件关联的 HotKey 对象应用于特定窗口。
    </summary>
    <param name="oWindow">要将 HotKey 对象应用于的窗口。</param>
    <returns> 
      一个数字值，指示将 HotKey 对象应用于窗口的结果。结果可以是以下值之一： 
      <list type="table">
        <listheader>
          <term>值</term>
          <description>结果</description>
        </listheader>
        <item>
          <term>-1</term>
          <description>操作失败，因为 HotKey 对象无效。</description>
        </item>
        <item>
          <term>0</term>
          <description>操作失败，因为窗口无效。</description>
        </item>
        <item>
          <term>1</term>
          <description>操作成功，且没有其他窗口具有相同的 HotKey 对象。</description>
        </item>
        <item>
          <term>2</term>
          <description>操作成功，但另一个窗口已经具有相同的 HotKey 对象。</description>
        </item>
      </list>
    </returns>
  </HotKeyEdit.ApplyHotKey>

  <HotKeyEdit.Create>
    <summary>
      为 X# 热键编辑对象创建底层窗口控件。
    </summary>
    <returns>
      如果成功，返回控件的窗口句柄。如果控件创建失败，返回空句柄(NULL_PTR)。
    </returns>
    <remarks>
      Create() 方法为在运行时创建的控件(即，使用 Window Editor 设计的控件)创建底层窗口控件。<br />
      通常，不需要直接调用 Create()—CA-X# 将在需要窗口句柄时在内部创建对象。
    </remarks>
    <example>
      <code language="X#">
        Method CreateHotKeyEdit() class MyDataWindow
            local oHK as HotKeyEdit
            // Init creates the X# HotKeyEdit Object
            oHK := HotKeyEdit{self, 100, Point{10,10}, Dimension{100,20}}
            // Calling Create forces the Windows control to be created
            oHK:Create()
      </code>
    </example>
  </HotKeyEdit.Create>

  <HotKeyEdit.HotKey>
    <summary>
      与此热键编辑关联的 HotKey 对象。
    </summary>
    <value>与此热键编辑关联的 HotKey 对象。</value>
  </HotKeyEdit.HotKey>

  <HotKeyEdit.Rule>
    <summary>
      与此热键编辑关联的 HotKeyRule 对象。
    </summary>
    <value>与此热键编辑关联的 HotKeyRule 对象。</value>
  </HotKeyEdit.Rule>

  <HotKeyRule>
    <summary>
      创建一个热键规则。
    </summary>
    <remarks>
      一个热键规则是一个对象，可以应用于热键编辑控件，定义窗口的无效键组合。热键规则还定义了当键组合无效时如何修改键组合。
    </remarks>
  </HotKeyRule>

  <HotKeyRule.ctor>
    <exclude />
  </HotKeyRule.ctor>

  <HotKeyRule.AltKeyInvalid>
    <summary>
      一个逻辑值，如果 Alt 键对于热键是无效的，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果 Alt 键对于热键是无效的，则为 TRUE。</value>
  </HotKeyRule.AltKeyInvalid>

  <HotKeyRule.CtrlAltKeysInvalid>
    <summary>
      一个逻辑值，如果 Ctrl+Alt 键组合对于热键是无效的，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果 Ctrl+Alt 键组合对于热键是无效的，则为 TRUE。</value>
  </HotKeyRule.CtrlAltKeysInvalid>

  <HotKeyRule.CtrlKeyInvalid>
    <summary>
      一个逻辑值，如果 Ctl 键对于热键是无效的，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果 Ctl 键对于热键是无效的，则为 TRUE。</value>
  </HotKeyRule.CtrlKeyInvalid>

  <HotKeyRule.ShiftAltKeysInvalid>
    <summary>
      一个逻辑值，如果 Shift+Alt 键组合对于热键是无效的，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果 Shift+Alt 键组合对于热键是无效的，则为 TRUE。</value>
  </HotKeyRule.ShiftAltKeysInvalid>

  <HotKeyRule.ShiftCtrlAltKeysInvalid>
    <summary>
      一个逻辑值，如果 Shift+Alt+Ctrl 键组合对于热键是无效的，则为 TRUE。
    </summary>
    <value>
      一个逻辑值，如果 Shift+Alt+Ctrl 键组合对于热键对象是无效的，则为 TRUE。
    </value>
  </HotKeyRule.ShiftCtrlAltKeysInvalid>

  <HotKeyRule.ShiftCtrlKeysInvalid>
    <summary>
      一个逻辑值，如果 Shift+Ctrl 键组合对于热键是无效的，则为 TRUE。
    </summary>
    <value>
      一个逻辑值，如果 Shift+Ctrl 键组合对于热键对象是无效的，则为 TRUE。
    </value>
  </HotKeyRule.ShiftCtrlKeysInvalid>

  <HotKeyRule.ShiftKeyInvalid>
    <summary>
      一个逻辑值，如果 Shift 键对于热键是无效的，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果 Shift 键对于热键是无效的，则为 TRUE。</value>
  </HotKeyRule.ShiftKeyInvalid>

  <HotKeyRule.UnmodifiedKeysInvalid>
  <summary>
    一个逻辑值，如果 Shift 键对于热键是无效的，则为 TRUE。
  </summary>
  <value>一个逻辑值，如果 Shift 键对于热键是无效的，则为 TRUE。</value>
  </HotKeyRule.UnmodifiedKeysInvalid>

  <HotKeyRule.UseAltKeyOnInvalid>
    <summary>
      一个逻辑值，如果未修改的键组合(没有Shift、Alt 或 Ctrl 键)对于热键是无效的，则为 TRUE。
    </summary>
    <value>
      在热键编辑中输入无效的键组合时要使用 Alt 键，则为 TRUE。
    </value>
  </HotKeyRule.UseAltKeyOnInvalid>

  <HotKeyRule.UseCtrlKeyOnInvalid>
    <summary>
      一个逻辑值，如果在热键编辑中输入无效的键组合时要使用 Alt 键，则为 TRUE。
    </summary>
    <value>
      在热键编辑中输入无效的键组合时要使用 Ctrl 键，则为 TRUE。
    </value>
  </HotKeyRule.UseCtrlKeyOnInvalid>

  <HotKeyRule.UseExtendedKeyOnInvalid>
    <summary>
      一个逻辑值，如果在热键编辑中输入无效的键组合时要使用 Ctrl 键，则为 TRUE。
    </summary>
    <value>
      一个逻辑值，如果在热键编辑中输入无效的键组合时要使用扩展键，则为 TRUE。
    </value>
  </HotKeyRule.UseExtendedKeyOnInvalid>

  <HotKeyRule.UseShiftKeyOnInvalid>
    <summary>
      一个逻辑值，如果在热键编辑中输入无效的键组合时要使用 Shift 键，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果在热键编辑中输入无效的键组合时要使用 Shift 键，则为 TRUE。</value>
  </HotKeyRule.UseShiftKeyOnInvalid>

  <HTTPCgiContext>
    <summary>
      创建使用公共网关接口(CGI)的 HTTP 服务器应用程序。
    </summary>
  </HTTPCgiContext>

  <HTTPCgiContext.ctor>
    <summary>
      构造一个 HTTPCgiContext 对象。
    </summary>
  </HTTPCgiContext.ctor>

  <HTTPCgiContext.Close>
    <summary>
      关闭 CGI 会话并进行所有必要的清理。
    </summary>
    <remarks>
      此方法释放所有文件句柄并将 CGI 进程从其控制台分离。
    </remarks>
    <example>
      请参阅 HTTPCgiContext:Write() 示例。
    </example>
  </HTTPCgiContext.Close>

  <HTTPCgiContext.ReadClient>
    <summary>
      从客户端的 HTTP 请求主体中读取数据。
    </summary>
    <param name="pBuffer">指向接收请求信息的缓冲区区域的指针。 </param>
    <param name="nSize">指示缓冲区中可用字节数的数值。 </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      ReadClient() 从 We 客户端的 HTTP 请求主体中读取信息。
      它可用于从使用 POST 方法的 HTML 表单中读取数据。
      Init() 方法在内部使用 ReadClient() 来读取 POST 请求的数据，并将其存储在属性 aArgs 中，可以通过 GetParams() 方法检索。
    </remarks>
  </HTTPCgiContext.ReadClient>

  <HTTPCgiContext.Write>
    <summary>
      向客户端发送原始的 HTTP 实体数据。
    </summary>
    <param name="cHTTPEntity">包含要发送到客户端的 Internet 浏览器的数据的字符串。如果省略，将发送一个换行符，'&lt;br&gt;'。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法将给定缓冲区中的数据发送到发出请求的客户端。
    </remarks>
    <example> 
      以下 CGI 应用程序向客户端的 Internet 浏览器显示字符串"Hello World"： 
      <code language="X#">
        FUNCTION Start
            LOCAL oCGI AS HTTPCGIContext
            LOCAL cHtml AS STRING
            LOCAL cValue AS STRING

            oCGI := HTTPCGIContext{}
            cHtml := oCGI:HTTPMsg("Hello World")
            oCGI:Write(cHtml)
            oCGI:Close()

            RETURN
      </code>
    </example>
  </HTTPCgiContext.Write>

  <HTTPCgiContext.WriteClient>
    <summary>
      向客户端发送原始的 HTTP 实体数据。
    </summary>
    <param name="cHTTPEntity">包含要发送到客户端的 Internet 浏览器的数据的字符串。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法将给定缓冲区中的数据发送到发出请求的客户端。
    </remarks>
  </HTTPCgiContext.WriteClient>

  <HTTPCgiContext.WriteContentFile>
    <summary>
      向客户端发送指定内容类型的原始的 HTTP 头和数据。
    </summary>
    <param name="cFile">文件名，包括驱动器号和路径。</param>
    <param name="cType">内容类型(例如，'image'，'text'或'application')。</param>
    <param name="cSubType"> 
      内容子类型(例如，如果 <paramref name="cType" /> 是'image'，则为'jpeg'或'gif'，
      如果 <paramref name="cType" /> 是'application'，则为'zip'，如果 <paramref name="cType" /> 是'text'，则为'html')。 
    </param>
    <returns>
      如果找到文件，返回文件大小(以字节为单位)；否则，返回0。
    </returns>
    <remarks>
      此方法将发送指定的内容文件和适当的回复头到发出请求的客户端。
    </remarks>
    <example> 
      以下 CGI 应用程序可用于为客户端的 Internet 浏览器创建下载链接。适当的 HTML 文件可能如下所示： 
      <code language="html">
        &lt;html&gt;
        &lt;body&gt;
        &lt;h1&gt;CGI下载测试&lt;/h1&gt;
        &lt;p&gt;&lt;a href="/voscript/votest.exe"&gt;
        下载文件test.zip
        &lt;/a&gt;&lt;/p&gt;
        &lt;/body&gt;
        &lt;/html&gt;
      </code>
      votest.exe 的源代码： 
      <code language="X#">
        FUNCTION Start
            LOCAL oCGI AS HTTPCGIContext
            LOCAL cFile AS STRING
            LOCAL cRet AS STRING

            oCGI := HTTPCGIContext{}
            cFile := oCGI:GetServerVariable("PATH_TRANSLATED") + "\downloads\test.zip"

            IF File(cFile)
                oCGI:WriteContentFile(cFile, "application", "zip")
            ELSE
                cFile := FPathName()
                cRet := "文件 " + cFile + "未找到"
                oCGI:Write(oCGI:HTTPMsg(cRet))
            ENDIF

            oCGI:Close()

            RETURN
      </code>
      要测试此应用程序，只需在浏览器URL中输入以下命令行： 
      <code language="X#">
        http://localhost/scripts/votest.exe
      </code>
    </example>
  </HTTPCgiContext.WriteContentFile>

  <HTTPCgiContext.WriteImage>
    <summary>
      向客户端发送指定图像文件的原始的 HTTP 头和数据。
    </summary>
    <param name="cFile">图像文件名，包括驱动器号和路径。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      WriteImage() 将发送指定的图像文件和适当的回复头到发出请求的客户端。
    </remarks>
    <example> 
      以下 CGI 应用程序向客户端的 Internet 浏览器显示图像"vo.jpg"。可以通过在浏览器URL中输入以下命令行来测试： 
      <code language="X#">
        http://localhost/scripts/votest.exe
      </code> 
      要将应用程序连接到HTML文件，可以使用以下代码： 
      <code language="html">
        &lt;html&gt;
        &lt;body&gt;
        &lt;h1&gt;CGI应用程序测试&lt;/h1&gt;
        &lt;img src="/scripts/votest.exe"&gt;
        &lt;/body&gt;
        &lt;/html&gt;
      </code>
      votest.exe的源代码： 
      <code language="X#">
        FUNCTION Start
            LOCAL oCGI AS HTTPCGIContext
            LOCAL cFile AS STRING
            LOCAL cRet AS STRING

            oCGI := HTTPCGIContext{}
            cFile:=oCGI:GetServerVariable("PATH_TRANSLATED") +"\images\vo.jpg"

            IF File(cFile)
                oCGI:WriteImage(cFile)
            ELSE
                cFile := FPathName()
                cRet := "文件 " + cFile + " 未找到"
                oCGI:Write(SELF:HTTPMsg(cRet))
            ENDIF

            oCGI:Close()

            RETURN
      </code>
    </example>
  </HTTPCgiContext.WriteImage>

  <HTTPContextAbstract>
    <summary>
      提供创建 Internet 服务器应用程序的基类，使用 CGI(公共网关接口)或 ISAPI(Internet 服务器 API)。
    </summary>
  </HTTPContextAbstract>

  <HTTPContextAbstract.ctor>
    <summary>
      构造一个 HTTPContextAbstract 对象。
    </summary>
  </HTTPContextAbstract.ctor>

  <HTTPContextAbstract.BinRoot>
    <summary>
      Internet 应用程序(DLL或EXE)的完全限定目录。
    </summary>
    <value>Internet 应用程序(DLL或EXE)的完全限定目录。</value>
  </HTTPContextAbstract.BinRoot>

  <HTTPContextAbstract.DelParamValue>
    <summary>
      从传递给该请求的参数列表中删除指定的参数。
    </summary>
    <param name="cValueName">包含要删除的参数的名称的字符串。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法从基于当前查询字符串创建的参数列表中删除指定的参数。
    </remarks>
  </HTTPContextAbstract.DelParamValue>

  <HTTPContextAbstract.Error>
    <summary>
      运行应用程序中发生的最后一个错误的编号。
    </summary>
    <value>运行应用程序中发生的最后一个错误的编号。</value>
  </HTTPContextAbstract.Error>

  <HTTPContextAbstract.GetBinRoot>
    <summary>
      确定当前 CGI 应用程序的绝对路径名。
    </summary>
    <returns>
      包含路径名的字符串。
    </returns>
    <remarks>
      GetBinRoot() 确定当前 CGI 应用程序的完全指定路径名，包括驱动器号。
    </remarks>
    <example> 
      以下 CGI 应用程序可用作间谍程序，以检索服务器的实际路径名： 
      <code language="X#">
        FUNCTION Start
            LOCAL oCGI AS HTTPCGIContext
            LOCAL cHtml AS STRING
            LOCAL cValue AS STRING

            oCGI    := HTTPCGIContext{}
            cValue  := oCGI:GetBinRoot()
            cHtml   := oCGI:HTTPMsg("CGI脚本已启动 来自: " + cValue)

            oCGI:Write(cHtml)
            oCGI:Close()

            RETURN
      </code>
    </example>
  </HTTPContextAbstract.GetBinRoot>

  <HTTPContextAbstract.GetParams>
    <summary>
      返回 HTTP 请求的参数。
    </summary>
    <returns>
      包含值及其名称的数组。
    </returns>
    <remarks> 
      此方法可用于检索 HTTP 请求的所有参数，作为一个二维数组，其中每个元素都包含以下格式的值对： 
      {<paramref name="cValueName" />, <paramref name="cValue" />} 
    </remarks>
  </HTTPContextAbstract.GetParams>

  <HTTPContextAbstract.GetParamValue>
    <summary>
      从传递给该请求的参数列表中检索指定的参数。
    </summary>
    <param name="cValueName">包含要查找的参数的名称的字符串。</param>
    <param name="nPosition"> 确定查询字符串中参数的出现次数的整数值。如果未指定 <paramref name="nPosition" />，默认值为1。 </param>
    <include file="Gui.xml" path="doc/ReturnsString/*" />
    <remarks> 
      GetParamValue() 解析查询字符串的所有值，并返回 <paramref name="nPosition" /> 的值，
      即查询字符串中 <paramref name="cValueName" /> 的第n次出现。 
    </remarks>
    <example> 
      以下 CGI 应用程序可用作 HTML 表单处理的脚本，以在 Internet 浏览器中显示值"value1"： 
      <code language="X#">
        FUNCTION Start
            LOCAL oCGI AS HTTPCGIContext
            LOCAL cHtml AS STRING
            LOCAL cValue AS STRING

            oCGI    := HTTPCGIContext{}
            cValue  := oCGI:GetParamValue("value1")
            cHtml   := oCGI:HTTPMsg("Value1 is :" + cValue)

            oCGI:Write(cHtml)
            oCGI:Close()

            RETURN
      </code>
    </example>
  </HTTPContextAbstract.GetParamValue>

  <HTTPContextAbstract.GetServerVariable>
    <summary>
      检索当前 Internet 服务器的指定环境值。
    </summary>
    <param name="cValueName">包含要查找的环境变量的名称的字符串。</param>
    <include file="Gui.xml" path="doc/ReturnsString/*" />
    <remarks> GetServerVariable() 返回由 <paramref name="cValueName" /> 指定的当前环境设置。 </remarks>
    <example> 
      以下 CGI 应用程序可用于显示环境值 PATH_TRANSLATED： 
      <code language="X#">
        FUNCTION Start
            LOCAL oCGI AS HTTPCGIContext
            LOCAL cHtml AS STRING
            LOCAL cValue AS STRING

            oCGI    := HTTPCGIContext{}
            cValue  := oCGI:GetServerVariable("PATH_TRANSLATED")
            cHtml   :=oCGI:HTTPMsg("PATH_TRANSLATED is :" + Value)

            oCGI:Write(cHtml)
            oCGI:Close()

            RETURN
      </code>
    </example>
  </HTTPContextAbstract.GetServerVariable>

  <HTTPContextAbstract.HTTPErrorMessage>
    <summary>
      创建 HTML 代码以显示错误对象的所有值。
    </summary>
    <param name="oError">当前错误对象实例。</param>
    <returns>
      包含 HTML 代码的字符串，用于在 Internet 浏览器中显示错误。
    </returns>
    <remarks>
      此方法基于 X# 错误对象的值创建 HTML 代码。
    </remarks>
    <example> 
      以下示例演示如何捕获运行时错误并在浏览器中显示它们： 
      <code language="X#">
        FUNC Start()
            LOCAL oCGI AS HTTPCGIContext
            LOCAL cHtml AS STRING
            LOCAL cValue AS STRING
            LOCAL oOldError AS USUAL
            LOCAL oError AS USUAL
            LOCAL x

            oCGI := HTTPCgiContext{}
            oOldError := ErrorBlock( {|oErr| ; __MyError(oErr)} )

            BEGIN SEQUENCE
                x := 0
                cHtml += x // error occurs here
                RECOVER USING oError
                cHtml := oCGI:HTTPErrorMessage(oError)
            END SEQUENCE

            ErrorBlock( oOldError )
            oCGI:Write(cHtml)
            oCGI:Close()

            RETURN

        STATIC FUNC __MyError (oError)
            LOCAL cRepl AS STRING

            cRepl := "Module " + ProcName(1)
            cRepl += ", line " + NTrim(ProcLine(1))

            IF SLen(oError:Description)&gt; 0
                oError:Description += "(" + cRepl + ")"
            ELSE
                oError:Description := cRepl
            ENDIF

            _Break(oError)
      </code>
    </example>
  </HTTPContextAbstract.HTTPErrorMessage>

  <HTTPContextAbstract.HTTPMsg>
    <summary>
      创建 HTML 代码以显示指定的消息。
    </summary>
    <param name="cMsg">要显示的消息。</param>
    <returns>
      包含 HTML 代码的字符串，用于在 Internet 浏览器中显示消息。
    </returns>
    <remarks>
      HTTPMsg() 创建 HTML 代码以显示指定的消息。
    </remarks>
    <example>
      参见 HTTPContextAbstract:GetServerVariable() 示例。
    </example>
  </HTTPContextAbstract.HTTPMsg>

  <HTTPContextAbstract.HTTPRequestItems>
    <summary>
      创建 HTML 代码以显示查询字符串的所有项。
    </summary>
    <returns>
      包含 HTML 代码的字符串，用于在 Internet 浏览器中显示查询字符串的所有项。
    </returns>
    <remarks>
      HTTPRequestItems() 创建 HTML 代码以显示查询字符串的所有项。
    </remarks>
    <example> 
      以下 CGI 应用程序可用于调试对表单处理请求的项： 
      <code language="X#">
        FUNCTION Start
            LOCAL oCGI AS HTTPCGIContext
            LOCAL cHtml AS STRING

            oCGI  := HTTPCGIContext{}
            cHtml := oCGI:HTTPRequestItems()

            oCGI:Write(cHtml)
            oCGI:Close()

            RETURN
      </code>
    </example>
  </HTTPContextAbstract.HTTPRequestItems>

  <HTTPContextAbstract.HTTPServerVariables>
    <summary>
      创建 HTML 代码以显示 Internet 服务器的所有环境变量。
    </summary>
    <returns>
      包含 HTML 代码的字符串，用于在 Internet 浏览器中显示所有环境变量。
    </returns>
    <example> 
      以下 CGI 应用程序可用于显示服务器的环境： 
      <code language="X#">
        FUNCTION Start
            LOCAL oCGI AS HTTPCGIContext
            LOCAL cHtml AS STRING

            oCGI  := HTTPCGIContext{}
            cHtml := oCGI:HTTPServerVariables()

            oCGI:Write(cHtml)
            oCGI:Close()

            RETURN
      </code>
      HTTPContextAbstract:HTTPErrorMessage(), HTTPContextAbstract:HTTPMsg(),HTTPContextAbstract:HTTPRequestItems() 
    </example>
  </HTTPContextAbstract.HTTPServerVariables>

  <HTTPContextAbstract.QueryString>
    <summary>
      HTTP 请求的查询字符串。
    </summary>
    <value>HTTP 请求的查询字符串。</value>
  </HTTPContextAbstract.QueryString>

  <HTTPContextAbstract.ServerPath>
    <summary>
      服务器主目录的完全限定目录名。
    </summary>
    <value>服务器主目录的完全限定目录名。</value>
  </HTTPContextAbstract.ServerPath>

  <HTTPContextAbstract.SetParamValue>
    <summary>
      更改或添加传递给该请求的参数列表的指定参数。
    </summary>
    <param name="cValueName">包含参数名称的字符串。</param>
    <param name="cValue">新值。</param>
    <param name="nPosition"> 整数值，确定查询字符串中参数的出现次数。如果未指定 <paramref name="nPosition" />，默认值为1。 </param>
    <returns>
      如果已更改值，则为 TRUE；否则为 FALSE。
    </returns>
    <remarks> 
      此方法解析查询字符串的所有值，并更改 <paramref name="nPosition" /> 的值，即查询字符串中 <paramref name="cValueName" /> 的第n次出现。
      如果未找到相应的值名称，将在列表中添加一个新值。
    </remarks>
    <example> 
      以下 CGI 应用程序可用作 HTML 表单处理的脚本，以在 Internet 浏览器中显示值"value1"： 
      <code language="X#">
        FUNCTION Start
            LOCAL oCGI AS HTTPCGIContext
            LOCAL cHtml AS STRING
            LOCAL cValue AS STRING

            oCGI := HTTPCGIContext{}

            IF oCGI:SetParamValue("xyz", "123")
                CValue  := oCGI:GetParamValue("xyz")
                cHtml   := oCGI:HTTPMsg("Value xyz changed" + "to :" + cValue)
            ELSE
                CValue  := oCGI:GetParamValue("xyz")
                CHtml   := oCGI:HTTPMsg("New value is :" + cValue)
            ENDIF

            oCGI:Write(cHtml)
            oCGI:Close()

            RETURN
      </code>
    </example>
  </HTTPContextAbstract.SetParamValue>

  <HTTPExtensionContext>
    <summary>
      创建使用 Microsoft 的 Internet 信息服务器 API(ISAPI) 的 HTTP 服务器应用程序。
    </summary>
    <remarks>
      此类定义了使用 ISAPI(Internet服务器API) 的各种 X# HTTP 服务器应用程序的通用协议-属性和行为。
    </remarks>
  </HTTPExtensionContext>

  <HTTPExtensionContext.ctor>
    <summary>
      构造一个 HTTPExtensionContext 对象。
    </summary>
    <param name="pExtControlBlock">指向包含对 ISAPI DLL 的请求的所有数据的 _WINEXTENSION_CONTROL_BLOCK 结构的指针。</param>
    <remarks> 
      只能在 ISAPI 扩展 DLL 的入口点函数 HttpExtensionProc() 中创建 HTTPExtensionContext 对象。
      Init() 方法需要一个有效的 <paramref name="pExtControlBlock" /> 指针，
      因为 HTTPExtensionContext 类是 _WINEXTENSION_CONTROL_BLOCK 结构中包含的 ISAPI 回调函数的一层。
    </remarks>
    <example> 
      以下函数可用于创建一个 ISAPI DLL(votest.dll)，以在客户端的 Internet 浏览器中显示字符串"Hello World"： 
      <code language="X#">
        FUNC HttpExtensionProc( pECB AS WINEXTENSION_CONTROL_BLOCK) AS DWORD PASCAL
            //
            // Entry point for all ISAPI requests
            //
            LOCAL cHtml AS STRING
            LOCAL nRet AS DWORD
            LOCAL oISAPI AS StdHTTPContext

            oISAPI:= StdHTTPContext{pECB}
            cHtml := oISAPI:HTTPMsg("Hello World")

            IF oISAPI:Write(cHtml)
                nRet := HSE_STATUS_SUCCESS
            ELSE
                nRet := oISAPI:StatusCode
            ENDIF

            RETURN nRet
      </code>
      适当的HTML文件可能如下所示： 
      <code language="html">
        &lt;html&gt;
        &lt;body&gt;
        &lt;h1&gt;ISAPI DLL Test&lt;/h1&gt;
        &lt;p&gt;&lt;a href="/voscript/votest.dll"&gt;
        Click here to start the DLL
        &lt;/a&gt;&lt;/p&gt;
        &lt;/body&gt;
        &lt;/html&gt;
      </code>
    </example>
  </HTTPExtensionContext.ctor>

  <HTTPExtensionContext.ECB>
    <summary>
      指向 _WINEXTENSION_CONTROL_BLOCK 结构的指针。
    </summary>
    <value>指向 _WINEXTENSION_CONTROL_BLOCK 结构的指针。</value>
  </HTTPExtensionContext.ECB>

  <HTTPExtensionContext.GetServerVariable>
    <summary>
      从当前 Internet 服务器检索指定的环境值。
    </summary>
    <param name="cValueName">包含要查找的环境变量的名称的字符串。</param>
    <include file="Gui.xml" path="doc/ReturnsString/*" />
    <remarks> GetServerVariable() 返回由 <paramref name="cValueName" /> 指定的当前环境设置。 </remarks>
    <example>
      参见 HTTPContextAbstract:GetServerVariable() 示例。
    </example>
  </HTTPExtensionContext.GetServerVariable>

  <HTTPExtensionContext.ReadClient>
    <summary>
      从客户端的 HTTP 请求主体中读取数据。
    </summary>
    <param name="pBuffer">指向要接收请求信息的缓冲区区域的指针。 </param>
    <param name="nSize">指示缓冲区中可用字节数的数值。 </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </HTTPExtensionContext.ReadClient>

  <HTTPExtensionContext.ServerSupportFunction>
    <summary>
      为 HTTP 响应 DLL 提供辅助功能。
    </summary>
    <param name="nRequest">包含 ISAPI 应用程序请求的 HTTP 服务器扩展请求(HSER)类型的 DWORD 值，该类型指示 ISAPI 应用程序请求的功能。有效值为：</param>
    <param name="pBuffer">指向包含所请求支持功能所需的主要参数的缓冲区的指针。</param>
    <param name="nSize"> 指示缓冲区中可用字节数的数值。默认为 <paramref name="pBuffer" /> 的长度。 </param>
    <param name="cData">包含辅助参数的数据的字符串。</param>
    <returns>
      如果已更改值，则为 TRUE；否则为 FALSE。
    </returns>
    <remarks>
      此方法提供了几个支持功能，这些功能不直接由 _WINEXTENSION_CONTROL_BLOCK 结构的标准回调函数直接覆盖。
    </remarks>
    <example> 
      以下函数可用于创建一个 ISAPI DLL(votest.dll)，以显示不同别名的翻译路径名： 
      <code language="X#">
        FUNC HttpExtensionProc(pECB AS WINEXTENSION_CONTROL_BLOCK) AS DWORD PASCAL
        //
        // Entry point for all ISAPI requests
        //
        LOCAL cHtml AS STRING
        LOCAL nRet AS DWORD
        LOCAL oISAPI AS StdHTTPContext
        LOCAL DIM abTemp[256] AS BYTE
        LOCAL cTemp AS STRING

        oISAPI  := StdHTTPContext{pECB}
        cTemp   := oISAPI:QueryString
        MemCopy(@abTemp[1], PTR(_CAST, cTemp), SLen(cTemp) + 1)

        IF oISAPI:ServerSupportFunction( ;
            HSE_REQ_MAP_URL_TO_PATH, @abTemp[1], 256, "")
            cHtml := "The path for " + cTemp + " is " + Psz2String(@abTemp[1])
        ELSE
            cHtml := "Error calling ServerSupportFunction()"
        ENDIF

        cHtml := oISAPI:HTTPMsg(cHtml)

        IF oISAPI:Write(cHtml)
            nRet := HSE_STATUS_SUCCESS
        ELSE
            nRet := oISAPI:StatusCode
        ENDIF

        RETURN nRet
      </code>
      适当的HTML文件可能如下所示： 
      <code language="html">
        &lt;html&gt;
        &lt;body&gt;
        &lt;h1&gt;ISAPI DLL Test&lt;/h1&gt;
        &lt;p&gt;&lt;a href="/voscript/votest.dll&amp;/scripts"&gt;
        Display translated name for scripts
        &lt;/a&gt;&lt;/p&gt;
        &lt;/body&gt;
        &lt;/html&gt;
      </code>
    </example>
  </HTTPExtensionContext.ServerSupportFunction>

  <HTTPExtensionContext.StatusCode>
    <summary>
      表示 HTTP 状态代码的数值。
    </summary>
    <value>表示 HTTP 状态代码的数值。</value>
  </HTTPExtensionContext.StatusCode>

  <HTTPExtensionContext.Write>
    <summary>
      将 HTTP 实体(包括响应头)发送到客户端。
    </summary>
    <param name="cHTTPEntity">要发送到客户端 Internet 浏览器的数据的字符串。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks> 
      该方法将 HTTP 服务器响应头(包括状态、服务器版本、消息时间和 MIME 版本)发送到客户端，紧接着是 <paramref name="cHTTPEntity" /> 指定的 HTTP 数据。 
    </remarks>
    <example>
      请参阅 HTTPExtensionContext:WriteClient() 示例。
    </example>
  </HTTPExtensionContext.Write>
  
  <HTTPExtensionContext.WriteClient>
    <summary>
      将原始的 HTTP 实体数据发送到客户端。
    </summary>
    <param name="cHTTPEntity">包含要发送到客户端 Internet 浏览器的数据的字符串。</param>
    <param name="nFlag">
      一个数字值，指示应如何处理 I/O 操作。支持以下标志：<br />
      I/O 操作应该同步进行。这是默认值。<br />
      I/O 操作应该异步进行。
      ISAPI 应用程序应该调用 ServerSupportFunction(HSE_REQ_IO_COMPLETION) 方法，并提交一个回调函数和上下文值，以处理异步操作的完成。
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      该方法将给定缓冲区中的数据发送到发出请求的客户端。
    </remarks>
    <example> 
      以下函数可用于创建一个 ISAPI DLL(votest.dll)，用于显示指定的图像文件： 
      <code language="X#">
        FUNC HttpExtensionProcx( pECB AS WINEXTENSION_CONTROL_BLOCK) AS DWORD PASCAL
            LOCAL cHtml AS STRING
            LOCAL nRet AS DWORD
            LOCAL oISAPI AS StdHTTPContext
            LOCAL cTemp AS STRING
            LOCAL cContent AS STRING
            LOCAL nSize AS INT

            oISAPI:= StdHTTPContext{pECB}
            cTemp := oISAPI:QueryString

            IF File(cTemp)
                cContent  := MemoRead(cTemp)
                nSize     := SLen(cContent)
                cHtml     := "Content-type: image/" + Lower(Right(cTemp,3)) + CRLF

                cHtml += "Content-length: " + NTrim(nSize)
                Html  += CRLF + CRLF

                IF oISAPI:Write(cHtml)
                    ISAPI:WriteClient(cContent)
                    Ret := HSE_STATUS_SUCCESS
                ELSE
                    nRet := oISAPI:StatusCode
                ENDIF
            ELSE
                cTemp := FPathName()
                cHtml := "File " + cTemp + " not found"
                cHtml := oISAPI:HTTPMsg(cHtml)

                IF oISAPI:Write(cHtml)
                    nRet := HSE_STATUS_SUCCESS
                ELSE
                    nRet := oISAPI:StatusCode
                ENDIF
            ENDIF
            RETURN nRet
      </code>
      适当的HTML文件可能如下所示： <code language="html">
        &lt;html&gt;
        &lt;body&gt;
        &lt;h1&gt;DLL Image Test&lt;/h1&gt;
        ...
        &lt;img src="/scripts/votest.dll?/vosample/vo.jpg"&gt;
        &lt;/body&gt;
        &lt;/html&gt;
      </code>
    </example>
  </HTTPExtensionContext.WriteClient>

  <HTTPExtensionContext.WriteContentFile>
    <summary>
      将指定内容类型的 HTTP 头和数据发送到客户端。
    </summary>
    <param name="cFile">文件名，包括驱动器号和路径。</param>
    <param name="cType">内容类型(例如，'image'，'text'或'application')。</param>
    <param name="cSubType"> 
      内容子类型(例如，如果 <paramref name="cType" /> 为'image'，则为'jpeg'或'gif'，
      如果 <paramref name="cType" /> 为'application'，则为'zip'，如果 <paramref name="cType" /> 为'text'，则为'html')。 
    </param>
    <returns>
      如果找到文件，返回文件大小(以字节为单位)；否则，返回0。
    </returns>
    <remarks>
      该方法将指定的内容文件和适当的回复头发送到发出请求的客户端。
    </remarks>
    <example>
      请参阅 HTTPCgiContext:WriteContentFile() 示例。
    </example>
  </HTTPExtensionContext.WriteContentFile>

  <HTTPExtensionContext.WriteImage>
    <summary>
      将指定图像文件的原始 HTTP 头和数据发送到客户端。
    </summary>
    <param name="cFile">图像文件名，包括驱动器号和路径。</param>
    <returns>
      如果找到文件，返回文件大小(以字节为单位)；否则，返回0。
    </returns>
    <remarks>
      该方法将指定的图像文件和适当的回复头发送到发出请求的客户端。
    </remarks>
    <example>
      请参阅 HTTPCgiContext:WriteImage() 示例。
    </example>
  </HTTPExtensionContext.WriteImage>

  <HTTPFilterContext>
    <summary>
      提供对 HTTP 通信服务器的低级访问。
    </summary>
    <remarks>
      HTTPFilterContext 类提供对 HTTP 通信流的低级访问。例如，可以使用该类来过滤 Web 服务器发送到客户端的数据，并交换该数据的某些部分，以实现页面计数器。
    </remarks>
  </HTTPFilterContext>

  <HTTPFilterContext.ctor>
    <summary>
      构造一个 HTTPFilterContext 对象。
    </summary>
    <param name="pFilterContext">指向包含对 ISAPI DLL 的请求的所有数据的 _WINHTTP_FILTER_CONTEXT 结构的指针。</param>
    <remarks> 
      HTTPFilterContext 对象只能在 ISAPI 扩展 DLL 的入口点函数 HttpFilterProc() 中创建。
      Init() 方法需要一个有效的 <paramref name="pFilterContext" /> 指针，
      因为 HTTPFilterContext 类是 _WINHTTP_FILTER_CONTEXT 结构中包含的 ISAPI Filter Callback 函数的一层。 
    </remarks>
    <example> 
      以下函数可用于创建一个 ISAPI 过滤器 DLL： 
      <code language="X#">
        CLASS MyFilter INHERIT HTTPFilterContext
            FUNC HttpFilterProc(pFCB AS WINHTTP_FILTER_CONTEXT, dwNotify AS DWORD, pData AS PTR) AS DWORD PASCAL
            LOCAL nRet AS DWORD
            LOCAL oFilter AS MyFilter

            oFilter := MyFilter{pFCB}

            DO CASE
                CASE dwNotify == SF_NOTIFY_URL_MAP
                    nRet := oFilter:OnUrlMap(pData)
                CASE dwNotify == SF_NOTIFY_SEND_RAW_DATA
                    nRet := oFilter:OnSendRawData(pData)
                CASE dwNotify == SF_NOTIFY_END_OF_NET_SESSION
                    nRet := oFilter:OnEndSession(pFCB)
                CASE dwNotify == SF_NOTIFY_READ_RAW_DATA
                    nRet := oFilter:OnReadRawData(pData)
                CASE dwNotify == SF_NOTIFY_PREPROC_HEADERS
                    nRet :=oFilter:OnPreprocHeaders(pData)
                CASE dwNotify == SF_NOTIFY_LOG
                    nRet := oFilter:OnLog(pData)
                CASE dwNotify == SF_NOTIFY_AUTHENTICATION
                    nRet := oFilter:OnAuthentication(pData)
                OTHERWISE
                    nRet := SF_STATUS_REQ_NEXT_NOTIFICATION
            ENDCASE

            RETURN nRet
      </code>
      通过覆盖 HTTPFilterContext 类的 OnUrlMap() 和 OnRawSendData() 事件处理程序来实现过滤器。 
    </example>
  </HTTPFilterContext.ctor>

  <HTTPFilterContext.AddResponseHeaders>
    <summary>
      向 HTTP 响应添加一个头。
    </summary>
    <param name="cNewHeader">包含要添加的头的字符串。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      该调用方法用于向 HTTP 响应添加一个头。
    </remarks>
  </HTTPFilterContext.AddResponseHeaders>

  <HTTPFilterContext.AllocMem>
    <summary>
      分配在通信终止时未释放的内存。
    </summary>
    <param name="nBytes">要分配的内存缓冲区的大小(以字节为单位)。</param>
    <returns>
      如果成功，返回一个分配的缓冲区的指针；否则，返回 NULL_PTR。
    </returns>
    <remarks>
      该方法分配在通信终止时未释放的内存。当发生 end-of-net-session时，Internet 信息服务器(IIS)将自动释放内存缓冲区。
    </remarks>
  </HTTPFilterContext.AllocMem>

  <HTTPFilterContext.Error>
    <summary>
      运行应用程序中发生的最后一个错误的编号。
    </summary>
    <value>运行应用程序中发生的最后一个错误的编号。</value>
  </HTTPFilterContext.Error>

  <HTTPFilterContext.FCB>
    <summary>
      指向 _WINHTTP_FILTER_CONTEXT 结构的指针。
    </summary>
    <value>指向 _WINHTTP_FILTER_CONTEXT 结构的指针。</value>
  </HTTPFilterContext.FCB>

  <HTTPFilterContext.FilterContext>
    <summary>
      指向 _WINHTTP_FILTER_CONTEXT 结构的 pFilterContext 成员的指针。
    </summary>
    <value>指向 _WINHTTP_FILTER_CONTEXT 结构的 pFilterContext 成员的指针。</value>
  </HTTPFilterContext.FilterContext>

  <HTTPFilterContext.GetServerVariable>
    <summary>
      从当前的 Internet 服务器中检索指定的环境值。
    </summary>
    <param name="cValueName">包含所需环境变量的名称的字符串。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks> 该方法返回由 <paramref name="cValueName" /> 指定的当前环境设置。 </remarks>
    <example>
      请参阅 HTTPContextAbstract:GetServerVariable() 示例。
    </example>
  </HTTPFilterContext.GetServerVariable>

  <HTTPFilterContext.OnAuthentication>
    <summary>
      由过滤器 DLL 调用的事件处理程序方法，用于对客户端进行身份验证。
    </summary>
    <param name="pFCB">指向 _WINHTTP_FILTER_CONTEXT 结构的指针。</param>
    <returns>
      以下通知类型之一：
      <ul style="list-style: none; columns: 1;">
        <li>SF_STATUS_REQ_FINISHED</li>
        <li>过滤器已处理了 HTTP 请求。服务器应该断开会话。</li>

        <li>SF_STATUS_REQ_FINISHED_KEEP_CONN</li>
        <li>与 SF_STATUS_REQ_FINISHED 相同，只是如果已经协商了该选项，服务器应该保持 TCP 会话打开。</li>

        <li>SF_STATUS_REQ_NEXT_NOTIFICATION</li>
        <li>应该调用通知链中的下一个过滤器。</li>

        <li>SF_STATUS_REQ_ERROR</li>
        <li>发生错误。服务器应该使用 Win32 API SetLastError() 函数向客户端指示错误。</li>

        <li>SF_STATUS_REQ_READ_NEXT</li>
        <li>过滤器是一个不透明的流过滤器；协商会话参数。仅对原始读取通知有效。</li>
      </ul>
    </returns>
    <remarks>
      覆盖此方法以实现自己的身份验证。默认设置为不活动。
    </remarks>
  </HTTPFilterContext.OnAuthentication>

  <HTTPFilterContext.OnEndSession>
    <summary>
      由过滤器 DLL 调用的事件处理程序方法，用于通知过滤器会话结束。
    </summary>
    <param name="pFilterContext">指向 _WINHTTP_FILTER_CONTEXT 结构的指针。</param>
    <returns>
      以下通知类型之一：
      <ul style="list-style: none; columns: 1;">
        <li>SF_STATUS_REQ_FINISHED</li>
        <li>过滤器已处理了 HTTP 请求。服务器应该断开会话。</li>

        <li>SF_STATUS_REQ_FINISHED_KEEP_CONN</li>
        <li>与 SF_STATUS_REQ_FINISHED 相同，只是如果已经协商了该选项，服务器应该保持 TCP 会话打开。</li>

        <li>SF_STATUS_REQ_NEXT_NOTIFICATION</li>
        <li>应该调用通知链中的下一个过滤器。</li>

        <li>SF_STATUS_REQ_ERROR</li>
        <li>发生错误。服务器应该使用 Win32 API SetLastError() 函数向客户端指示错误。</li>

        <li>SF_STATUS_REQ_READ_NEXT</li>
        <li>
          过滤器是一个不透明的流过滤器；协商会话参数。仅对原始读取通知有效。
          如果不成功，应返回通知类型 SF_STATUS_REQ_ERROR。在这种情况下，服务器应该使用 Windows 函数 SetLastError() 向客户端指示错误
        </li>
      </ul>
    </returns>
    <remarks>
      覆盖此方法以提供自己的会话结束实现。默认设置为不活动。
    </remarks>
    <example> 
      以下事件处理程序在过滤器接收到 SF_NOTIFY_END_OF_NET_SESSION 通知时，将输出调试字符串写入 Win32 调试消息窗口： 
      <code language="X#">
        METHOD OnEndSession (pData) CLASS MyFilter
            LOCAL nRet AS DWORD
            LOCAL pContext AS _WINHTTP_FILTER_CONTEXT

            nRet := SF_STATUS_REQ_NEXT_NOTIFICATION

            IF IsPtr(pData)
                pContext := pData
            ELSE
                RETURN nRet
            ENDIF

            DebOut32("Session ended " + AsString(pContext) )

            RETURN nRet
      </code>
    </example>
  </HTTPFilterContext.OnEndSession>

  <HTTPFilterContext.OnLog>
    <summary>
      由过滤器 DLL 调用的事件处理程序方法，用于通知过滤器服务器正在将信息写入服务器日志。
    </summary>
    <param name="pFilterLog">指向 _WINHTTP_FILTER_LOG 结构的指针。</param>
    <returns>
      以下通知类型之一：
      <ul style="list-style: none; columns: 1;">
        <li>SF_STATUS_REQ_FINISHED</li>
        <li>过滤器已处理了 HTTP 请求。服务器应该断开会话。</li>

        <li>SF_STATUS_REQ_FINISHED_KEEP_CONN</li>
        <li>与 SF_STATUS_REQ_FINISHED 相同，只是如果已经协商了该选项，服务器应该保持 TCP 会话打开。</li>

        <li>SF_STATUS_REQ_NEXT_NOTIFICATION</li>
        <li>应该调用通知链中的下一个过滤器。</li>

        <li>SF_STATUS_REQ_ERROR</li>
        <li>发生错误。服务器应该使用 Win32 API SetLastError() 函数向客户端指示错误。</li>

        <li>SF_STATUS_REQ_READ_NEXT</li>
        <li>
          过滤器是一个不透明的流过滤器；协商会话参数。仅对原始读取通知有效。如果不成功，应返回通知类型 SF_STATUS_REQ_ERROR。
          在这种情况下，服务器应该使用 Windows 函数 SetLastError() 向客户端指示错误
        </li>
      </ul>
    </returns>
    <remarks>
      覆盖此方法以提供自己的日志记录到服务器文件的方法。默认设置为不活动。
    </remarks>
  </HTTPFilterContext.OnLog>

  <HTTPFilterContext.OnPreprocHeaders>
    <summary>
      过滤器 DLL 调用的事件处理程序方法，用于通知过滤器服务器已预处理客户端标头。
    </summary>
    <param name="pHeaders">指向 _WINHTTP_FILTER_PREPROC_HEADERS 结构的指针。</param>
    <returns>
      以下通知类型之一：
      <ul style="list-style: none; columns: 1;">
        <li>SF_STATUS_REQ_FINISHED</li>
        <li>过滤器已处理了 HTTP 请求。服务器应该断开会话。</li>

        <li>SF_STATUS_REQ_FINISHED_KEEP_CONN</li>
        <li>与 SF_STATUS_REQ_FINISHED 相同，只是如果已经协商了该选项，服务器应该保持 TCP 会话打开。</li>

        <li>SF_STATUS_REQ_NEXT_NOTIFICATION</li>
        <li>应该调用通知链中的下一个过滤器。</li>

        <li>SF_STATUS_REQ_ERROR</li>
        <li>发生错误。服务器应该使用 Win32 API SetLastError() 函数向客户端指示错误。</li>

        <li>SF_STATUS_REQ_READ_NEXT</li>
        <li>
          过滤器是一个不透明的流过滤器；协商会话参数。仅对原始读取通知有效。如果不成功，应返回通知类型 SF_STATUS_REQ_ERROR。
          在这种情况下，服务器应该使用 Windows 函数 SetLastError() 向客户端指示错误
        </li>
      </ul>
    </returns>
    <remarks>
      覆盖此方法以提供自己的处理客户端标头的方法。默认设置为不活动。
    </remarks>
  </HTTPFilterContext.OnPreprocHeaders>

  <HTTPFilterContext.OnReadRawData>
    <summary>
      过滤器 DL L调用的事件处理程序方法，允许过滤器查看原始数据。返回的数据将包含标头和数据。
    </summary>
    <param name="pRawData">指向 _WINHTTP_FILTER_RAW_DATA 结构的指针。</param>
    <returns>
      以下通知类型之一：
      <ul style="list-style: none; columns: 1;">
        <li>SF_STATUS_REQ_FINISHED</li>
        <li>过滤器已处理了 HTTP 请求。服务器应该断开会话。</li>

        <li>SF_STATUS_REQ_FINISHED_KEEP_CONN</li>
        <li>与 SF_STATUS_REQ_FINISHED 相同，只是如果已经协商了该选项，服务器应该保持 TCP 会话打开。</li>

        <li>SF_STATUS_REQ_NEXT_NOTIFICATION</li>
        <li>应该调用通知链中的下一个过滤器。</li>

        <li>SF_STATUS_REQ_ERROR</li>
        <li>发生错误。服务器应该使用 Win32 API SetLastError() 函数向客户端指示错误。</li>

        <li>SF_STATUS_REQ_READ_NEXT</li>
        <li>
          过滤器是一个不透明的流过滤器；协商会话参数。仅对原始读取通知有效。如果不成功，应返回通知类型 SF_STATUS_REQ_ERROR。
          在这种情况下，服务器应该使用 Windows 函数 SetLastError() 向客户端指示错误
        </li>
      </ul>
    </returns>
    <remarks>
      覆盖此方法以不同方式处理原始数据。
    </remarks>
  </HTTPFilterContext.OnReadRawData>

  <HTTPFilterContext.OnSendRawData>
    <summary>
      过滤器 DLL 调用的事件处理程序方法，允许过滤器发送原始数据。返回的数据将包含标头和数据。
    </summary>
    <param name="pRawData">指向 _WINHTTP_FILTER_RAW_DATA 结构的指针。</param>
    <returns>
      以下通知类型之一：
      <ul style="list-style: none; columns: 1;">
        <li>SF_STATUS_REQ_ERROR</li>
        <li>发生错误。服务器应该使用 Win32 API SetLastError() 函数向客户端指示错误。</li>

        <li>SF_STATUS_REQ_NEXT_NOTIFICATION</li>
        <li>
          应该调用通知链中的下一个过滤器。如果不成功，应返回通知类型 SF_STATUS_REQ_ERROR。
          在这种情况下，服务器应该使用 Windows 函数 SetLastError() 向客户端指示错误
        </li>
      </ul>
    </returns>
    <remarks>
      覆盖此方法以更改默认的通知处理程序，并以不同方式处理原始数据。
    </remarks>
  </HTTPFilterContext.OnSendRawData>

  <HTTPFilterContext.OnUrlMap>
    <summary>
      过滤器 DLL 调用的事件处理程序方法，当服务器正在将逻辑 URL 映射到物理路径时。
    </summary>
    <param name="pURLMap">指向 _WINHTTP_FILTER_URL_MAP 结构的指针。</param>
    <returns>
      以下通知类型之一：
      <ul style="list-style: none; columns: 1;">
        <li>SF_STATUS_REQ_ERROR</li>
        <li>发生错误。服务器应该使用 Win32 API SetLastError() 函数向客户端指示错误。</li>

        <li>SF_STATUS_REQ_NEXT_NOTIFICATION</li>
        <li>
          应该调用通知链中的下一个过滤器。如果不成功，应返回通知类型 SF_STATUS_REQ_ERROR。
          在这种情况下，服务器应该使用 Windows 函数 SetLastError() 向客户端指示错误
        </li>
      </ul>
    </returns>
    <remarks>
      覆盖此方法以不同方式处理 URL 映射。默认设置为不活动。
    </remarks>
    <example> 
      以下事件处理程序在过滤器接收到 SF_NOTIFY_END_OF_NET_SESSION 通知时，将输出调试字符串写入 Win32 调试消息窗口： 
      <code language="X#">
        METHOD OnUrlMap (pData) CLASS MyFilter
            LOCAL nRet AS DWORD
            LOCAL pFUM AS _WINHTTP_FILTER_URL_MAP

            nRet := SF_STATUS_REQ_NEXT_NOTIFICATION

            IF IsPtr(pData)
                pFUM := pData
            ELSE
                RETURN nRet
            ENDIF

            DebOut32(pFUM.pszPhysicalPath)

            RETURN nRet
      </code>
    </example>
  </HTTPFilterContext.OnUrlMap>

  <HTTPFilterContext.ServerSupportFunction>
    <summary>
      扩展过滤器功能的方法。
    </summary>
    <param name="nRequest">一个 DWORD 值，包含 Filter Request 类型，指示请求的功能。有效值为：</param>
    <param name="pBuffer">指向包含所请求支持函数所需的主要参数的缓冲区的指针。</param>
    <param name="nSize"> 数值，指示缓冲区中可用的字节数。默认为 <paramref name="pBuffer" /> 的大小+1。 </param>
    <param name="cData">包含辅助参数数据的字符串。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      该方法提供了几个支持函数，这些函数不直接由 _WINHTTP_FILTER_CONTEXT 结构的标准回调函数直接覆盖。
    </remarks>
  </HTTPFilterContext.ServerSupportFunction>

  <HTTPFilterContext.WriteClient>
    <summary>
      将原始的 HTTP 实体数据发送到客户端。
    </summary>
    <param name="cHTTPEntity">包含要发送到客户端的 Internet 浏览器的数据的字符串。如果未指定，默认为换行符，'&lt;br&gt;'。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      该方法将给定缓冲区中的数据发送到发出请求的客户端。
    </remarks>
  </HTTPFilterContext.WriteClient>

  <HyperLink>
    <summary>
      创建一个超链接控件。
    </summary>
    <remarks> 
      该类的意图是，文本将显示为指向 www 地址的超链接或指向@的电子邮件地址，因此光标将显示为普通手型。<br />
      当单击控件时，它将尝试使用 OpenLink 回调方法“打开”控件的文本。<br />
      如果文本是 www 地址，它将打开默认浏览器，并尝试导航到该地址。如果文本包含@，它将被视为电子邮件地址，并打开默认电子邮件客户端。
      <note type="tip">
        超链接和 SysLink 类之间的区别在于文本的使用方式。<br />
        在超链接控件中，所有文本都作为超链接传递，而在 SysLink 控件中，可以混合显示文本和超链接文本。<br />
        此外，在超链接控件中，所有显示的文本都会通过 ShellExecute 方法传递，您必须确保其中没有任何内容会导致此操作失败。
      </note>
    </remarks>
    <example>
      <code language="X#">
        oFont1              := Font{,8,"Microsoft Sans Serif"}
        oFont1:Underline    := TRUE
        oHL1                := HyperLink{ SELF, -1, Point{190, 25 },  Dimension{0, 0 }, "http://www.grafxsoft.com" }
        oHL1:font           := oFont1
        oHL1:size           := Dimension{150,20}
        oHL1:textcolor      := Color{ COLORBLUE }
        oHL1:font:underline := TRUE
        oHL1:Show( )
      </code>
    </example>
  </HyperLink>

  <HyperLink.ctor>
    <summary>
      构造一个超链接控件。
    </summary>
    <param name="oOwner">拥有超链接的窗口。</param>
    <param name="xID">超链接控件的唯一ID(介于1和8000之间)。</param>
    <param name="oPoint">超链接控件在画布坐标中的原点。</param>
    <param name="oDimension">超链接控件在画布坐标中的尺寸。</param>
    <param name="cText">要在屏幕上显示的字符串。</param>
  </HyperLink.ctor>

  <HyperLink.Dispatch>
    <inheritdoc />
  </HyperLink.Dispatch>

  <HyperLink.OpenLink>
    <summary>
      每当鼠标在超链接控件上单击时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      该方法在鼠标在超链接控件上单击时自动调用。 
    </remarks>
  </HyperLink.OpenLink>

  <IApplicationObject>
    <summary>
      在 ASP 应用程序的所有用户之间共享信息。
    </summary>
    <remarks>
      通过使用 IApplication 对象，您可以在给定应用程序的所有用户之间共享信息。基于 ASP 的应用程序包含虚拟目录及其子目录中的所有 .ASP 文件。<br />
      因为 IApplication 对象可以被多个用户共享，所以有 _Lock() 和 _Unlock() 方法来确保多个用户的访问。
    </remarks>
  </IApplicationObject>

  <IApplicationObject.ctor>
    <summary>
      构造一个 IApplicationObject 对象实例。
    </summary>
    <param name="oIScrContext">一个 IScriptingContext 对象。</param>
    <param name="pIAppObj">指向 IApplication Interface 对象结构的指针。</param>
    <remarks>
      当 Internet 信息服务器(IIS)加载适当的 .ASP 文件时，IScriptingContext:OnStartPage() 方法会自动创建一个 IApplicationObject 实例。<br />
      因此，您不必自己创建这个对象。而是通过 IScriptingContext:Application 属性在 ASP 组件应用程序中使用它。
    </remarks>
  </IApplicationObject.ctor>

  <IApplicationObject._Lock>
    <summary>
      锁定 IApplicationObject 实例的所有变量。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      防止其他客户端访问 IApplicationObject 对象中存储的变量，直到调用 _Unlock() 方法。
    </remarks>
    <example>
      请参阅 IApplicationObject:GetValue() 示例。
    </example>
  </IApplicationObject._Lock>

  <IApplicationObject._UnLock>
    <summary>
      释放 IApplicationObject 实例的所有变量。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      释放由 _Lock() 方法先前锁定的 IApplicationObject 对象中的变量。
    </remarks>
    <example>
      请参阅 IApplicationObject:GetValue() 示例。
    </example>
  </IApplicationObject._UnLock>

  <IApplicationObject.GetValue>
    <summary>
      检索存储在 IApplication 对象中的变量的值。
    </summary>
    <param name="cVarName">要获取的变量的名称。</param>
    <returns>
      如果成功，类型为 USUAL 的值；否则，NIL。
    </returns>
    <remarks>
      该方法检索存储在 IApplication 对象中的变量的值。
    </remarks>
    <example> 
      以下源代码可用于显示应用程序范围的值“GlobalVar”： 
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent

        PROCEDURE InitProc() _INIT 3
            goASPComponent := ASPComponent{}

        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL cRet AS STRING

                IF SELF:Application:_Lock()
                  cRet := SELF:Application:GetValue("GlobalVar")
                  SELF:Application:_UnLock()
                ENDIF

                RETURN SELF:Response:_Write(cRet)
      </code>
      ASP code: 
      <code language="asp">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        Application("GlobalVar") = "Hello world"
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IApplicationObject.GetValue>

  <IApplicationObject.PutValue>
    <summary>
      将变量的值存储到 IApplication 对象中。
    </summary>
    <param name="cVarName">所需变量的名称。</param>
    <param name="xValue"> 要分配给 <paramref name="cVarName" /> 的新值。 </param>
    <returns>
      如果已更改值，则为 TRUE；否则，为 FALSE。
    </returns>
    <remarks>
      该方法分配存储在 IApplication 对象中的变量的值。
    </remarks>
  </IApplicationObject.PutValue>

  <Icon>
    <summary>
      创建一个图标，它是系统在其所有者窗口中被图标化时系统显示的小位图。
    </summary>
    <remarks> 
      X# 提供了一组预定义的图标，定义在 Icon:Init() 中。使用 AppWindow:Icon 属性为每个应用程序窗口分配一个图标。 
      Visual Object 包括一个图标编辑器，它生成标准系统图标文件。还有一个大型的系统图标库。<br />
      这些图标文件与系统上的标准格式兼容，因此任何其他图标文件或图标编辑器也可以使用。<br />
      要使用这样的图标文件，使用 RESOURCE 语句创建一个图标资源，并在实例化图标时引用它。<br />
      有关使用和编辑标准图标的更多信息，请参阅IDE用户指南。
      <note
        type="tip">图标的大小和颜色范围是系统相关的。
      </note>
    </remarks>
    <example>
      以下示例演示了一个标准图标的使用：
      <code language="X#">
        CLASS MyWindow INHERIT TopAppWindow
            METHOD Init() CLASS MyWindow
                SUPER:Init()
                SELF:Icon := Icon{ICONASTERISK}
      </code>
      此代码片段强调了三件事：<br />
      任何继承的类的 Init() 方法都必须调用 SUPER:Init()。<br />
      伪变量 Icon 是 AppWindow 类中的一个访问/分配对。<br />
      ICONASTERISK 标识了一个标准图标。<br />
      以下示例提供了一个具有自定义图标的应用程序窗口：
      <code language="X#">
        CLASS MyTopAppWin INHERIT TopAppWindow
            METHOD Init CLASS MyTopAppWin
                SUPER:Init()
                SELF:Icon := Icon{IDI_APPICON}
                RESOURCE IDI_APPICON ICON app.ico
      </code>
      在 Windows 中，使用关键字 ICON 在资源实体中定义图标，引用由图标编辑器创建的文件的名称。
    </example>
  </Icon>

  <Icon.ctor>
    <summary>
      构造一个图标。
    </summary>
    <param name="xResourceID">所需图标的资源ID，一个已有Icon对象的句柄，或者下表中的图标常量之一</param>
    <param name="kLoadOption">可选的常量，表示加载选项。默认为 LR_DEFAULTCOLOR。</param>
    <param name="iWidth">可选的位图宽度。默认为位图的宽度。</param>
    <param name="iHeight">可选的位图高度。默认为位图的高度。</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>常量 图标</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>ICONASTERISK</term>
          <description>用于指示“注意”。</description>
        </item>
        <item>
          <term>ICONEXCLAMATION</term>
          <description>用于指示警告。</description>
        </item>
        <item>
          <term>ICONHAND</term>
          <description>用于指示错误条件。</description>
        </item>
        <item>
          <term>ICONQUESTIONMARK</term>
          <description>用于指示需要更多信息。</description>
        </item>
        <item>
          <term>ICONSTANDARD</term>
          <description>一个空白的、正方形的图标。这是默认的。</description>
        </item>
      </list>
    </remarks>
  </Icon.ctor>

  <Icon.Destroy>
    <summary>
      提供一个方法来去实例化一个 Icon 对象。
    </summary>
    <remarks>
      当一个 Icon 对象不再需要时，可以使用这个方法。
      Icon:Destroy() 去实例化 Icon 对象，并允许您关闭和释放对象打开或创建的任何资源，而不需要等待垃圾回收器。
    </remarks>
  </Icon.Destroy>

  <Icon.Handle>
    <summary>
      返回一个图标的句柄。
    </summary>
    <param name="nHandleType"> 需要的句柄类型。零(0)是唯一支持的选项，默认如果 <paramref name="nHandle" /> 被省略。 </param>
    <returns>
      描述基础系统对象的句柄。
    </returns>
    <remarks>
      这个方法提供了一个到 Windows GDI 对象的句柄，可以然后被用于 Windows API GDI 调用。
    </remarks>
  </Icon.Handle>

  <Icon.Size>
    <exclude />
  </Icon.Size>

  <IDispatch>
    <summary>
      提供一个帮助类，用于将返回的 OLE 自动化接口转换为 OLEAutoObject。
    </summary>
    <remarks>
      <br />重要！这个类仅用于内部实现，不打算直接使用。 </remarks>
  </IDispatch>

  <ImageList>
    <summary>
      创建一个图像列表。
    </summary>
    <remarks>
      图像列表是一个对象，基本上是一个大小相同的图标和/或位图的集合。<br />
      图像列表提供了一种管理图标和位图的方式，而不是作为单个对象。<br />
      它们通常用于标签、列表视图和树视图控件，这些控件通过它们在列表中的顺序索引来引用特定的图像。<br />
      图像列表用于控件的图像操作；因此，方法如 BeginDrag()、DragMove()、EndDrag() 和 Handle() 由系统使用，通常不应该直接使用。
    </remarks>
  </ImageList>

  <ImageList.ctor>
    <summary>
      构造一个图像列表对象。
    </summary>
    <param name="nImages">这个图像列表将包含的图像数量。</param>
    <param name="oDimension">一个 Dimension 对象，表示图像列表中的图像大小。</param>
    <param name="oImage">向 ImageList 添加一个 Icon 或 Bitmap 对象。</param>
    <param name="wColor">
      要使用的颜色掩码。这个参数是一个位标志的集合，指定要创建的图像列表类型。这个参数可以是以下值的组合，但只能包括一个 ILC_COLOR 值。
    </param>
    <param name="nGrow">系统需要为新图像腾出空间时，图像列表可以增长的图像数量。</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>值</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>ILC_COLOR</term>
          <description>
            如果没有指定其他 ILC_COLOR* 标志，则使用默认行为。通常，默认是 ILC_COLOR4，但对于较旧的显示驱动程序，默认是 ILC_COLORDDB。
          </description>
        </item>
        <item>
          <term>ILC_COLOR4</term>
          <description>使用4位(16色)的设备独立位图(DIB)部分作为图像列表的位图。</description>
        </item>
        <item>
          <term>ILC_COLOR8</term>
          <description>使用8位DIB部分。用于颜色表的颜色与半色调调色板相同。</description>
        </item>
        <item>
          <term>ILC_COLOR16</term>
          <description>使用16位(32/64k色)的DIB部分。</description>
        </item>
        <item>
          <term>ILC_COLOR24</term>
          <description>使用24位DIB部分。</description>
        </item>
        <item>
          <term>ILC_COLOR32</term>
          <description>使用32位DIB部分。</description>
        </item>
        <item>
          <term>ILC_COLORDDB</term>
          <description>使用设备相关位图。</description>
        </item>
        <item>
          <term>ILC_MASK</term>
          <description>使用掩码。图像列表包含两个位图，其中一个是用于掩码的单色位图。如果不包括这个值，图像列表只包含一个位图。</description>
        </item>
        <item>
          <term>ILC_MIRROR</term>
          <description>
            版本6.00。Microsoft Windows 可以镜像显示语言，如希伯来语或阿拉伯语，这些语言从右到左阅读。
            然后，如果图像列表是在镜像版本的 Windows 上创建的，那么图像列表中的图像将被镜像，即它们将被翻转，以便从右到左显示。
            使用这个标志在镜像版本的 Windows上，指示图像列表不要自动镜像图像。
          </description>
        </item>
        <item>
          <term>ILC_PERITEMMIRROR</term>
          <description>版本6.00。指定这个标志，如果 ILC_MIRROR 用于包含一条图像的图像列表。ILC_MIRROR 必须被指定，这个标志才有效。</description>
        </item>
      </list>
      注意：如果您传递第四个参数，您应该总是包括ICL_MASK在值中。 
    </remarks>
  </ImageList.ctor>

  <ImageList.Add>
    <summary>
      向图像列表添加图标或位图。
    </summary>
    <param name="oImage">要添加到图像列表的图标或位图。</param>
    <returns>
      添加的图像在图像列表中的索引。
    </returns>
  </ImageList.Add>

  <ImageList.AddMask>
    <summary>
      向图像列表添加图像，并从指定的位图生成掩码。
    </summary>
    <param name="oBitmap">用于图像列表掩码的位图对象。</param>
    <param name="oMaskColor">掩码的颜色。</param>
    <returns>
      如果成功，返回第一个新图像的索引；否则，返回-1。
    </returns>
  </ImageList.AddMask>

  <ImageList.BeginDrag>
    <summary>
      开始图像列表的拖拽操作。
    </summary>
    <param name="nIndex">要拖拽的图像在图像列表中的索引。如果省略，则使用图像列表中的第一个图像。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ImageList.BeginDrag>

  <ImageList.CreateOverlayImage>
    <summary>
      从图像列表中的图像创建叠加图像。
    </summary>
    <param name="nListIndex">用于创建叠加图像的图像在图像列表中的索引。</param>
    <param name="nImageIndex">新叠加图像的索引。这个值可以是1到4之间的值。如果省略，则新叠加图像将是列表中的第一个。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      叠加图像是另一个图像之上的图像。这种技术通常用于列表视图和树视图控件。图像列表最多可以有四个叠加图像。
    </remarks>
  </ImageList.CreateOverlayImage>

  <ImageList.Destroy>
    <exclude />
  </ImageList.Destroy>

  <ImageList.DragEnter>
    <summary>
      在给定的窗口和位置开始拖拽操作。
    </summary>
    <param name="oPoint">** 缺少参数文档 **</param>
    <param name="oWindow">** 缺少参数文档 **</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ImageList.DragEnter>

  <ImageList.DragLeave>
    <summary>
      结束拖拽操作。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ImageList.DragLeave>

  <ImageList.DragMove>
    <summary>
      将图像列表拖拽到指定的位置。
    </summary>
    <param name="oPoint">要拖拽图像列表到的点。</param>
    <param name="oWindow">图像列表将被拖拽到的窗口。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ImageList.DragMove>

  <ImageList.EndDrag>
    <summary>
      结束图像列表的拖拽操作。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ImageList.EndDrag>

  <ImageList.Handle>
    <summary>
      返回图像列表的 Windows 句柄，可以在 Windows 中使用。
    </summary>
    <returns>
      图像列表的句柄(一个指针)。
    </returns>
  </ImageList.Handle>

  <ImageList.ImageCount>
    <summary>
      ImageList 对象中的图像数量。
    </summary>
    <value>ImageList 对象中的图像数量。</value>
  </ImageList.ImageCount>

  <ImageList.ImageSize>
    <exclude />
  </ImageList.ImageSize>

  <InfoBox>
    <summary>
      向用户显示信息性消息框。
    </summary>
    <remarks> 
      信息性消息框是一个显示用户定义标题的窗口，在标题栏中显示信息性消息的文本，并显示信息图标。<br />
      这些框通常用于向用户提供有用的信息。<br />
      当信息框消失时，焦点将返回到所有者窗口。 
      <note type="tip">
        信息框是应用程序模态的—用户必须确认它才能继续使用应用程序。
      </note>
    </remarks>
    <example> 
      以下示例显示了一个信息框： 
      <code language="X#">
        METHOD Start() CLASS App
            oMyWin := TopAppWindow{}
            oMyWin:Show()

            oSomeInfo := InfoBox{oMyWin, "Info", "Message box"}
            oSomeInfo:Show()

            SELF:Exec()
      </code>
    </example>
  </InfoBox>

  <InfoBox.ctor>
    <summary>
      构造一个信息性消息框。
    </summary>
    <param name="uParent">拥有信息框的窗口。如果省略，Windows 桌面将是默认所有者。</param>
    <param name="uCaption">在信息框的标题栏中显示的标题文本。如果省略，将默认显示'Info Box'。</param>
    <param name="uText">
      在信息框显示时要打印的信息文本，或者包含信息框的标题和描述的超链接。<br />
      如果省略，将默认显示 NULL_STRING。
    </param>
  </InfoBox.ctor>

  <IntegerFS>
    <summary>
      创建一个整数字段规范，它包含整数数据类型信息。
    </summary>
  </IntegerFS>

  <IntegerFS.ctor>
    <summary>
      构造一个整数字段规范。
    </summary>
    <param name="oHLName">包含字段名称和其他属性(例如，标题、描述和帮助上下文)的超链接，用于创建新的整数字段规范。</param>
    <param name="uLength">字段的长度。如果未指定，将默认为10。</param>
  </IntegerFS.ctor>

  <IPAddress>
    <summary>
      编辑控件，用于编辑由4个数字组成的IP地址
    </summary>
  </IPAddress>

  <IPAddress.ctor>
    <summary>
      构造一个 IPAddress 对象。
    </summary>
    <param name="oOwner">拥有 IPAddress 对象的窗口。</param>
    <param name="xID">IPAddress 对象的唯一ID(在1和8000之间)。</param>
    <param name="oPoint">IPAddress 对象在画布坐标中的原点。</param>
    <param name="oDimension">IPAddress 对象在画布坐标中的尺寸。</param>
    <param name="dwStyle">
      表示 IPAddress 对象的样式的常量，可以通过 X# 样式常量或 Windows API 样式常量指定。样式可以使用 _Or() 运算符组合。
    </param>
    <param name="lDataAware">一个逻辑值，如果 IPAddress 对象是数据感知的，则为 TRUE；否则为 FALSE。如果省略，将默认为 TRUE。</param>
    <param name="nResourceID">IPAddress 对象的资源ID。</param>
    <remarks>
      <note type="tip">请参阅 Microsoft Win32 软件开发工具包文档，了解有关特定样式常量的详细信息。</note>
    </remarks>
  </IPAddress.ctor>

  <IPAddress.Address>
    <summary>
      一个长整型值，表示当前的IP地址。这等于将IP地址解释为4字节整数。
    </summary>
    <value>一个长整型值，表示当前的IP地址。这等于将IP地址解释为4字节整数。</value>
  </IPAddress.Address>

  <IPAddress.EditHandle>
    <exclude />
  </IPAddress.EditHandle>

  <IPAddress.Field1>
    <summary>
      一个数值，表示当前IP地址的第一个字段。对于IP地址"130.119.121.147"，这个访问将返回130。
    </summary>
    <value>一个数值，表示当前IP地址的第一个字段。对于IP地址"130.119.121.147"，这个访问将返回130。</value>
  </IPAddress.Field1>

  <IPAddress.Field2>
    <summary>
      一个数值，表示当前IP地址的第二个字段。对于IP地址"130.119.121.147"，这个访问将返回119。
    </summary>
    <value>一个数值，表示当前IP地址的第二个字段。对于IP地址"130.119.121.147"，这个访问将返回119。</value>
  </IPAddress.Field2>

  <IPAddress.Field3>
    <summary>
      一个数值，表示当前IP地址的第三个字段。对于IP地址"130.119.121.147"，这个访问将返回121。
    </summary>
    <value>一个数值，表示当前IP地址的第三个字段。对于IP地址"130.119.121.147"，这个访问将返回121。</value>
  </IPAddress.Field3>

  <IPAddress.Field4>
    <summary>
      一个数值，表示当前IP地址的第四个字段。对于IP地址"130.119.121.147"，这个访问将返回147。
    </summary>
    <value>一个数值，表示当前IP地址的第四个字段。对于IP地址"130.119.121.147"，这个访问将返回147。</value>
  </IPAddress.Field4>

  <IPAddress.SetRange>
    <summary>
      设置每个字段的允许输入范围。
    </summary>
    <param name="iFieldIndex">正在设置范围的字段的索引(在1和4之间)。</param>
    <param name="iLower">范围的下限。</param>
    <param name="iUpper">范围的上限。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      SetRange 允许您分别设置四个输入字段的允许范围。
    </remarks>
  </IPAddress.SetRange>

  <IPAddress.TextValue>
    <summary>
      表示IP地址的字符串。
    </summary>
    <value>表示IP地址的字符串。</value>
    <example> 
      以下示例演示了IP地址的设置和读取： 
      <code language="X#">
        oDCIPAddress1:TextValue := '192.168.0.1'
        ? oDCIPAddress1:TextValue // '192.168.0.1'
      </code>
    </example>
  </IPAddress.TextValue>

  <IPAddress.Value>
    <exclude />
  </IPAddress.Value>

  <IpcClient>
    <summary>
      注册一个应用程序作为客户端，能够从指定的服务器应用程序请求和接收数据。
    </summary>
    <remarks>
      在 X# 中，IPC...类提供了一种实现 DDE 对话的方式，DDE(动态数据交换)是一种使用共享内存在应用程序之间交换数据的IPC类型。
      IPC 由 Windows 中的一个底层 DLL 管理，DDE 管理库来管理。<br />
      在这样的对话中，有一个客户端和一个服务器。
      客户端请求服务器关于特定主题和项目的数据，服务器提供请求的数据。
      应用程序在请求成为客户端或服务器(或两者)后，一旦新数据可用，就立即交换更新。这些交换不一定由用户发起。<br />
      每个IPC客户端必须唯一地标识它希望与之通信的服务器，然后请求数据更新。
      在初始传输之后，客户端通过 IpcDataUpdateEvent 被通知服务器中传输的数据的任何更改。
    </remarks>
  </IpcClient>

  <IpcClient.ctor>
    <summary>
      构造一个 IpcClient 对象。
    </summary>
    <param name="cServerName">要与之通信的服务器。</param>
  </IpcClient.ctor>

  <IpcClient.ChangeData>
    <summary>
      告诉远程服务器某个数据值已经改变。这将导致服务器接收到一个 IpcDataUpdateEvent。然后，服务器有责任更新自身。
    </summary>
    <param name="cTopic">
      数据已经改变的 IPC 主题的名称。这个方法会导致系统通过发送一个 IpcDataUpdateEvent 来通知IPC服务器数据的改变。
      当服务器询问事件哪个主题已经改变时，事件会用你给这个参数的值回答。
    </param>
    <param name="cItem">要改变的项目的名称。</param>
    <param name="cStringData">已经改变的数据。</param>
  </IpcClient.ChangeData>

  <IpcClient.ClientError>
    <summary>
      处理 ClientErrorEvent，如果发生一个。如果需要对错误进行特殊处理，可以在派生的 IpcClient 类中提供这个事件处理程序。
    </summary>
    <param name="oIpcClientErrorEvent">发生的错误的类型。请参阅 IpcClientErrorEvent 类，了解错误类型的列表。</param>
    <returns>
      如果 DDE 对话要继续，返回 TRUE；否则，返回 FALSE。
    </returns>
    <example> 
      以下示例演示了如何通过 ClientError() 方法处理客户端错误事件： 
      <code language="X#">
        METHOD ClientError(oICEE) CLASS MyClient
            LOCAL Err := oICEE:ErrorType
                DO CASE
                CASE Err == IPCSERVERNOTFOUND
                ...
      </code>
    </example>
  </IpcClient.ClientError>

  <IpcClient.DataUpdate>
    <summary>
      每当请求的数据发生变化时调用。在 IpcServer 调用其 UpdateTopic() 方法之后，它被调用。
    </summary>
    <param name="oIpcDataUpdateEvent">将主题名称、项目名称和已更改数据作为字符串存储。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </IpcClient.DataUpdate>

  <IpcClient.Destroy>
    <summary>
      提供一个方法来去实例化一个 IpcClient 对象。
    </summary>
    <remarks>
      当一个 IpcClient 对象不再需要时，可以使用这个方法。
      IpcClient:Destroy() 去实例化 IpcClient 对象，并允许您关闭和释放对象打开或创建的任何资源，而不需要等待垃圾回收器。
    </remarks>
  </IpcClient.Destroy>

  <IpcClient.Dispatch>
    <inheritdoc />
  </IpcClient.Dispatch>

  <IpcClient.Execute>
    <summary>
      向服务器发送一个消息，告诉它远程执行命令字符串。作为这个调用的结果，服务器会收到一个 IpcExecuteRequestEvent。
    </summary>
    <remarks>
      <note type="tip">在 Windows 中，项目不会被传递给服务器。</note>
    </remarks>
    <param name="cTopic">服务器执行命令的 IPC 主题的名称。</param>
    <param name="cItem">服务器执行命令的 IPC 项目的名称。</param>
    <param name="cCommand">服务器要执行的命令。</param>
  </IpcClient.Execute>

  <IpcClient.IdInst>
    <exclude />
  </IpcClient.IdInst>

  <IpcClient.RequestData>
    <summary>
      从服务器请求特定主题的更新。
    </summary>
    <param name="oIpcTopic">正在请求数据的IPC主题。</param>
    <param name="continuous">
      如果设置为 TRUE，服务器每次更改数据时都会向客户端发送数据；<br />
      如果设置为 FALSE，服务器只会发送一次更新。默认为 FALSE。
    </param>
  </IpcClient.RequestData>

  <IpcClientErrorEvent>
    <summary>
      提供有关 IpcClientErrorEvent 的信息，用于指示 IPC 服务器发生的错误事件的类型。
    </summary>
    <remarks>
      IpcClientErrorEvent 事件被发送到 IpcClient:ClientError()。
    </remarks>
  </IpcClientErrorEvent>

  <IpcClientErrorEvent.ctor>
    <exclude />
  </IpcClientErrorEvent.ctor>

  <IpcClientErrorEvent.ErrorType>
    <summary>
      发生的错误事件的类型，由下表中的常量之一定义：
    </summary>
    <value>发生的错误事件的类型，由下表中的常量之一定义：</value>
    <remarks> 
      发生的错误事件的类型，由以下常量定义： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>IPCITEMNOTFOUND</term>
          <description>服务器没有该名称的项目。</description>
        </item>
        <item>
          <term>IPCOUTOFMEMORY</term>
          <description>系统内存不足，因此无法完成操作。</description>
        </item>
        <item>
          <term>IPCSERVERNOTFOUND</term>
          <description>指定的服务器或主题未找到。</description>
        </item>
      </list>
    </remarks>
  </IpcClientErrorEvent.ErrorType>

  <IpcDataRequestEvent>
    <summary>
      提供有关 IpcDataRequestEvent 的信息，用于存储已请求数据的主题名称(和长度)和项目名称(和长度)。
    </summary>
    <remarks>
      IpcDataRequestEvent 事件被发送到 IpcServer:DataRequest()。
    </remarks>
  </IpcDataRequestEvent>

  <IpcDataRequestEvent.ctor>
    <exclude />
  </IpcDataRequestEvent.ctor>

  <IpcDataRequestEvent.Item>
    <summary>
      一个字符串，表示已请求数据的项目名称。
    </summary>
    <value>一个字符串，表示已请求数据的项目名称。</value>
  </IpcDataRequestEvent.Item>

  <IpcDataRequestEvent.Topic>
    <summary>
      一个字符串，表示已请求数据的主题名称。
    </summary>
    <value>一个字符串，表示已请求数据的主题名称。</value>
  </IpcDataRequestEvent.Topic>

  <IpcDataUpdateEvent>
    <summary>
      提供有关 IpcDataUpdateEvent 的信息，用于存储主题名称、项目名称和新数据的信息。
    </summary>
    <remarks>
      IpcDataUpdateEvent 事件被发送到 IpcServer:DataUpdate() 和 IpcClient:DataUpdate()。
    </remarks>
  </IpcDataUpdateEvent>

  <IpcDataUpdateEvent.ctor>
    <exclude />
  </IpcDataUpdateEvent.ctor>

  <IpcDataUpdateEvent.AsString>
    <summary>
      一个字符串，包含已更改的数据。
    </summary>
    <value>一个字符串，包含已更改的数据。</value>
  </IpcDataUpdateEvent.AsString>

  <IpcDataUpdateEvent.GetData>
    <summary>
      启用程序处理已更改的数据。
    </summary>
    <returns>
      一个字符串，包含已更改的数据。
    </returns>
  </IpcDataUpdateEvent.GetData>

  <IpcDataUpdateEvent.Item>
    <summary>
      一个字符串，表示已请求数据更新的项目名称。
    </summary>
    <value>一个字符串，表示已请求数据更新的项目名称。</value>
  </IpcDataUpdateEvent.Item>

  <IpcDataUpdateEvent.Topic>
    <summary>
      一个字符串，表示已请求数据更新的主题名称。
    </summary>
    <value>一个字符串，表示已请求数据更新的主题名称。</value>
  </IpcDataUpdateEvent.Topic>

  <IpcEvent>
    <summary>
      提供所有 Ipc 事件类的基类。
    </summary>
  </IpcEvent>

  <IpcEvent.ctor>
    <exclude />
  </IpcEvent.ctor>

  <IpcEvent.dwData1>
    <exclude />
  </IpcEvent.dwData1>

  <IpcEvent.dwData2>
    <exclude />
  </IpcEvent.dwData2>

  <IpcEvent.dwFmt>
    <exclude />
  </IpcEvent.dwFmt>

  <IpcEvent.dwType>
    <exclude />
  </IpcEvent.dwType>

  <IpcEvent.hConv>
    <exclude />
  </IpcEvent.hConv>

  <IpcEvent.hData>
    <exclude />
  </IpcEvent.hData>

  <IpcEvent.hsz1>
    <exclude />
  </IpcEvent.hsz1>

  <IpcEvent.hsz2>
    <exclude />
  </IpcEvent.hsz2>

  <IpcEvent.Item>
    <summary>
      一个字符串，表示已请求事件的项目名称。
    </summary>
    <value>一个字符串，表示已请求事件的项目名称。</value>
  </IpcEvent.Item>

  <IpcEvent.oIPCObject>
    <exclude />
  </IpcEvent.oIPCObject>

  <IpcEvent.Topic>
    <summary>
      一个字符串，表示已请求事件的主题名称。
    </summary>
    <value>一个字符串，表示已请求事件的主题名称。</value>
  </IpcEvent.Topic>

  <IpcExecuteRequestEvent>
    <summary>
      提供有关 IpcExecuteRequestEvent 的信息，用于存储主题名称、项目名称和命令字符串的信息。
    </summary>
    <remarks>
      <note type="tip">
        在 Windows 中，项目字符串总是为空的，不应该使用。
      </note>
      IpcExecuteRequestEvent 事件被发送到 IpcServer:ExecuteRequest()。 
    </remarks>
  </IpcExecuteRequestEvent>

  <IpcExecuteRequestEvent.ctor>
    <exclude />
  </IpcExecuteRequestEvent.ctor>

  <IpcExecuteRequestEvent.Command>
    <summary>
      一个字符串，表示命令名称。
    </summary>
    <value>一个字符串，表示命令名称。</value>
  </IpcExecuteRequestEvent.Command>

  <IpcExecuteRequestEvent.Item>
    <summary>
      一个字符串，表示项目名称。
      在Windows中没有项目。提供对其他环境的兼容性。
    </summary>
    <value>
      一个字符串，表示项目名称。
      在 Windows 中没有项目。提供对其他环境的兼容性。
    </value>
  </IpcExecuteRequestEvent.Item>

  <IpcExecuteRequestEvent.Topic>
    <summary>
      一个字符串，表示主题名称。
    </summary>
    <value>一个字符串，表示主题名称。</value>
  </IpcExecuteRequestEvent.Topic>

  <IpcServer>
    <summary>
      注册一个应用程序作为服务器，能够访问特定主题上的数据，并更新已注册的主题和已注册的客户端应用程序。
    </summary>
    <remarks>
      在 X# 中，IPC...类提供了一种实现 DDE 对话的方法，DDE兼容应用程序之间的通信。<br />
      DDE(动态数据交换)是一种使用共享内存在应用程序之间交换数据的 IPC 类型。IPC 由 Windows 的 DDE 管理库管理，这是一个基础 DLL。<br />
      在这样的对话中，有一个客户端和一个服务器。客户端请求关于特定主题和项目的数据，服务器提供请求的数据。
      应用程序在请求成为客户端或服务器(或两者)后，一旦新数据可用，就立即交换更新。这些交换不一定由用户发起。<br />
      每个 IPC 客户端必须唯一地标识它希望与之通信的服务器，然后请求数据更新。
      在初始传输之后，通过 IpcDataUpdateEvent 对象通知客户端服务器上传输的数据的任何更改。
    </remarks>
  </IpcServer>

  <IpcServer.ctor>
    <summary>
      构造一个 IpcServer 对象。
    </summary>
    <param name="cServName">唯一标识服务器的名称，客户端使用。</param>
  </IpcServer.ctor>

  <IpcServer.AddTopic>
    <summary>
      将一个主题添加到服务器支持的主题列表中。
    </summary>
    <param name="oIpcTopic">要添加到服务器支持的主题列表中的 IPC 主题。</param>
    <remarks>
      应该为每个支持的主题调用一次。
    </remarks>
  </IpcServer.AddTopic>

  <IpcServer.DataRequest>
    <summary>
      每当客户端请求数据或调用 IpcServer:UpdateTopic() 时调用。
    </summary>
    <param name="oIpcDataRequestEvent">存储主题名称和项目名称。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <returns>
      一个包含指向数据的指针和数据字符串的长度的对象(由 Windows 的 DDE 管理库创建为全局内存对象，它通过数据句柄返回给应用程序)。
    </returns>
  </IpcServer.DataRequest>

  <IpcServer.DataUpdate>
    <summary>
      每当客户端调用 IpcClient:ChangeData() 时调用。
    </summary>
    <param name="oIpcDataUpdateEvent">存储主题名称、项目名称和更改的数据的字符串。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      当调用此方法时，服务器应该更新自身。这个功能由开发人员在重写的方法中提供，而不是由 X# 提供。 </remarks>
  </IpcServer.DataUpdate>

  <IpcServer.Destroy>
    <summary>
      提供一种去实例化 IpcServer 对象的方法。
    </summary>
    <remarks>
      当不再需要一个 IpcServer 对象时，可以使用这个方法。
      IpcServer:Destroy() 去实例化 IpcServer 对象，并允许您关闭和释放任何由对象打开或创建的资源，而不需要等待垃圾回收器。
    </remarks>
  </IpcServer.Destroy>

  <IpcServer.Dispatch>
    <inheritdoc />
  </IpcServer.Dispatch>

  <IpcServer.ExecuteRequest>
    <summary>
      当客户端调用 IpcClient:Execute() 时调用。服务器应该采取适当的操作在本地执行命令。
    </summary>
    <param name="oIpcExecuteRequestEvent">存储主题名称、项目名称和要执行的命令的字符串。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </IpcServer.ExecuteRequest>

  <IpcServer.idInst>
    <exclude />
  </IpcServer.idInst>

  <IpcServer.UpdateTopic>
    <summary>
      请求服务器更新特定主题和项目。
    </summary>
    <param name="cTopic">要更新的 IPC 主题。</param>
    <param name="cItem">要更新的 IPC 项目。</param>
    <remarks>
      这将导致调用 IpcServer:DataRequest()。然后与主题和项目对应的客户端将使用新值进行更新。
    </remarks>
  </IpcServer.UpdateTopic>

  <IpcTopic>
    <summary>
      创建一个 IPC 服务器支持的主题(和项目)，IPC 客户端可以请求。这些对象由 IpcServer:AddTopic() 和 IpcClient:RequestData() 使用。
    </summary>
  </IpcTopic>

  <IpcTopic.ctor>
    <summary>
      构造一个 IpcTopic 对象。
    </summary>
    <param name="cTopicString">要创建的 IPC 主题。</param>
  </IpcTopic.ctor>

  <IpcTopic.AddItem>
    <summary>
      将一个项目添加到与主题关联的项目列表中。
    </summary>
    <param name="cItemString">要添加到与主题关联的项目列表中的 IPC 项目。</param>
  </IpcTopic.AddItem>

  <IpcTopic.aItemList>
    <exclude />
  </IpcTopic.aItemList>

  <IpcTopic.cTopicName>
    <exclude />
  </IpcTopic.cTopicName>

  <IpcTopic.DeleteItem>
    <summary>
      从与主题关联的项目列表中删除一个项目。
    </summary>
    <param name="cItemString">要删除的 IPC 项目。</param>
  </IpcTopic.DeleteItem>

  <IpcTopic.Destroy>
    <exclude />
  </IpcTopic.Destroy>

  <IpcTopicData>
    <summary>
      创建一个全局内存对象，并将数据句柄返回给应用程序。
    </summary>
    <remarks>
      IpcTopicData 对象包含一个指向数据的指针和数据字符串的长度(由 Windows 的 DDE 管理库创建为全局内存对象，它通过数据句柄返回给应用程序)。
    </remarks>
  </IpcTopicData>

  <IpcTopicData.ctor>
    <summary>
      构造一个 IpcTopicData 对象。
    </summary>
    <param name="ptrString">数据字符串的指针。</param>
    <param name="nLength">要传输的字符数。如果未指定，将使用数据字符串的整个长度。</param>
    <remarks>
      IpcTopicData 对象用于在 IpcServer 对象的数据请求调用中传输数据。
    </remarks>
  </IpcTopicData.ctor>

  <IpcTopicData.Data>
    <exclude />
  </IpcTopicData.Data>

  <IpcTopicData.Destroy>
    <exclude />
  </IpcTopicData.Destroy>

  <IpcTopicData.Length>
    <exclude />
  </IpcTopicData.Length>

  <IpcTopicData.liLen>
    <exclude />
  </IpcTopicData.liLen>

  <IpcTopicData.ptrData>
    <exclude />
  </IpcTopicData.ptrData>

  <IReadCookie>
    <summary>
      提供一个类，用于检索在 HTTP 请求中由客户端浏览器发送的 cookie 的值。
    </summary>
    <remarks>
      IReadCookie 类使您能够检索在 HTTP 请求中由客户端浏览器发送的 cookie 的值。
    </remarks>
  </IReadCookie>

  <IReadCookie.ctor>
    <summary>
      构造一个 IReadCookie 对象实例。
    </summary>
    <param name="pICookie">指向 IReadCookie 接口对象结构的指针。</param>
    <param name="oIServer">IServer 对象实例。</param>
    <remarks>
      IReadCookie 对象实例可以通过 IRequest:GetCookies() 方法创建，因为它直接与 HTTP 请求相关联。
      因此，您不必自己创建这个对象。相反，通过 IScriptingContext:Request:GetCookies() 方法用于 ASP 组件应用程序。
    </remarks>
    <example>
      请参阅 IReadCookie:GetItem() 示例。
    </example>
  </IReadCookie.ctor>

  <IReadCookie.GetEnum>
    <summary>
      从 cookie 对象中检索项目的数量。
    </summary>
    <returns>
      如果成功，返回 cookie 项目的数量(类型为 INT)；否则，返回0。
    </returns>
    <remarks>
      此方法检索存储在 cookie 对象中的项目的数量。
    </remarks>
    <example>
      请参阅 IReadCookie:GetItem() 示例。
    </example>
  </IReadCookie.GetEnum>

  <IReadCookie.GetHasKeys>
    <summary>
      指示 cookie 对象是否有键。
    </summary>
    <returns>
      如果当前 cookie 有键，则返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      此方法返回一个逻辑值，指示 cookie 是否有键。
    </remarks>
  </IReadCookie.GetHasKeys>

  <IReadCookie.GetItem>
    <summary>
      从 cookie 对象中检索指定的项目。
    </summary>
    <param name="cItemName">要检索的变量(项目)的名称。</param>
    <returns>
      如果成功，返回一个字符串值；否则，返回 NULL_STRING。
    </returns>
    <remarks> 此方法从 cookie 对象中检索指定的项目，<paramref name="cItemName" />。 </remarks>
    <example> 
      以下示例显示了适当请求的cookie集合： 
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent
        PROCEDURE InitProc() _INIT 3
            goASPComponent := ASPComponent{}

        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL oCookie AS IReadCookie
                LOCAL aTemp AS ARRAY
                LOCAL aRet AS ARRAY
                LOCAL n,i AS INT
                LOCAL cName AS STRING
                LOCAL cRet AS STRING

                oCookie := SELF:Request:GetCookies()

                IF oCookie == NULL_OBJECT
                    n     := oCookie:GetEnum()
                    aRet  := ArrayCreate(n)

                    FOR i := 1 TO n
                        aTemp     := ArrayCreate(2)
                        cName     := oCookie:GetName(i)
                        aTemp[1]  := cName
                        aTemp[2]  := oCookie:GetItem(cName)
                        aRet[i]   := aTemp
                    NEXT
                ENDIF

                cRet := GetHTTPValueTable(aTemp)

                RETURN SELF:Response:_Write(cRet)
      </code>
    </example>
  </IReadCookie.GetItem>

  <IReadCookie.GetName>
    <summary>
      从 cookie 对象中检索指定的项目的名称。
    </summary>
    <param name="nItem">Cookie 项目集合中的项目的编号(位置)。</param>
    <returns>
      如果成功，返回项目名称(类型为 STRING)；否则，返回 NULL_STRING。
    </returns>
    <remarks> 此方法从 cookie 对象中检索指定的项目的名称，<paramref name="nItem" />。 </remarks>
    <example>
      参见 IReadCookie:GetItem() 示例。
    </example>
  </IReadCookie.GetName>

  <IRequest>
    <summary>
      用于在 HTTP 请求期间从客户端浏览器传递给服务器的值。
    </summary>
    <remarks>
      IRequest 类用于从客户端浏览器传递给服务器的值。这些变量由集合在内部存储，按以下顺序排列：<br />
      1. QueryString<br />
      2. Form<br />
      3. Cookies<br />
      4. ClientCertificate<br />
      5. ServerVariables<br />
      IRequest 类提供以下类型的方法：<br />
      用于将这些集合作为包含每个集合的值{name, value}对的数组检索(例如，GetForms())。<br />
      用于检索这些集合中的某个值的方法(例如，GetForm("firstname"))。<br />
      无需知道它属于哪个集合就可以检索值的方法(例如，GetItem("firstname"))。
    </remarks>
  </IRequest>

  <IRequest.ctor>
    <summary>
      构造一个 IRequest 对象实例。
    </summary>
    <param name="oIScrContext">一个 IScriptingContext 对象。</param>
    <param name="pIRequest">一个 IRequest 接口对象结构的指针。</param>
    <remarks>
      当 Internet 信息服务器(IIS)加载适当的 .ASP 文件时，IScriptingContext:OnStartPage() 方法会自动创建一个IRequest对象实例。
      因此，您不必自己创建这个对象。而是通过 IScriptingContext:Request 属性将其用于 ASP 组件应用程序。
    </remarks>
  </IRequest.ctor>

  <IRequest.GetClientCertificate>
    <summary>
      从 IRequest 对象的客户端证书集合中检索值。
    </summary>
    <param name="cVarName">证书字段的名称。</param>
    <param name="n"> 位置，如果在集合中存在多个具有相同名称的变量，<paramref name="cVarName" />。 </param>
    <returns>
      如果成功，返回一个字符串值；否则，返回 NULL_STRING。
    </returns>
    <remarks>
      GetClientCertificate() 方法从 Web 浏览器发出的请求中检索一个证书字段(在 X.509 标准中指定)。
      如果 Web 浏览器使用 SSL3.0/PCT1 协议(即，URL以"https://"开头而不是"http://")连接到服务器，并且服务器请求证书，浏览器会发送证书字段。
      如果没有发送证书，集合数组为空，返回值为 NULL_STRING。
    </remarks>
  </IRequest.GetClientCertificate>

  <IRequest.GetClientCertificates>
    <summary>
      从 IRequest 对象的客户端证书集合中检索证书字段。
    </summary>
    <returns>
      如果成功，返回一个两维数组，其中包含名称-值对；否则，返回一个空数组。
    </returns>
    <remarks>
      GetClientCertificates() 方法从 Web 浏览器发出的请求中检索所有证书字段(在 X.509 标准中指定)，并将其作为一个两维数组返回。
      如果 Web 浏览器使用 SSL3.0/PCT1 协议(即，URL以"https://"开头而不是"http://")连接到服务器，并且服务器请求证书，浏览器会发送证书字段。
      如果没有发送证书，集合数组为空。
    </remarks>
  </IRequest.GetClientCertificates>

  <IRequest.GetCookies>
    <summary>
      从 IRequest 对象的 cookie 集合中检索值。
    </summary>
    <returns>
      IReadCookie 对象实例。
    </returns>
    <remarks>
      此方法从 IRequest 对象的 cookie 集合中检索一个 IReadCookie 对象实例。
    </remarks>
    <example> 
      以下示例演示了此方法的使用： 
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent

        PROCEDURE InitProc() _INIT 3
            goASPComponent := ASPComponent{}

        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL oCookie AS IReadCookie
                LOCAL aTemp AS ARRAY
                LOCAL aRet AS ARRAY
                LOCAL n,i AS INT
                LOCAL cName AS STRING
                LOCAL cRet AS STRING

                oCookie := SELF:Request:GetCookies()

                IF oCookie == NULL_OBJECT
                ELSE
                    n     := oCookie:GetEnum()
                    aRet  := ArrayCreate(n)

                    FOR i := 1 UPTO n
                        aTemp     := ArrayCreate(2)
                        cName     := oCookie:GetName(i)
                        aTemp[1]  := cName
                        aTemp[2]  := oCookie:GetItem(cName)
                        aRet[i]   := aTemp
                    NEXT
                ENDIF

                cRet := GetHTTPValueTable(aTemp)

                RETURN SELF:Response:_Write(cRet)
      </code>
      ASP代码： 
      <code language="asp">
        &lt;%
        Response.Cookies("mycookie")("value1") = "Hello"
        Response.Cookies("mycookie")("value2") = "World"
        Response.Cookies("value1") = "X#"
        Response.Cookies("value2") = "rules"
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
      结果将是： 
    </example>
  </IRequest.GetCookies>

  <IRequest.GetForm>
    <summary>
      从 IRequest 对象的表单集合中检索值。
    </summary>
    <param name="cVarName">表单字段的名称。</param>
    <param name="n"> 位置，如果在集合中存在多个具有相同名称的变量，<paramref name="cVarName" />。 </param>
    <returns>
      如果成功，返回一个字符串值；否则，返回 NULL_STRING。
    </returns>
    <remarks>
      GetForm() 方法从使用 POST 方法的表单通过 HTTP 请求主体发布的表单值中检索一个表单值。如果没有发送表单值，集合数组为空，返回值为 NULL_STRING。
    </remarks>
    <example> 
      以下示例演示了此方法的使用： 
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent

        PROCEDURE InitProc() _INIT 3
            goASPComponent := ASPComponent{}

        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL cRet AS STRING
                cRet := SELF:Request:GetForm("Value1")
                RETURN SELF:Response:_Write("Value1=" + cRet)
      </code>
      HTML代码： 
      <code language="html">
        &lt;form action="response.asp?Action=FORM" method="post"&gt;
        &lt;p&gt;Value1: &lt;input type="text" name="Value1" size="4"&gt;&lt;/p&gt;
        &lt;p&gt;&lt;input type="submit" value="Execute POST Request"&gt; &lt;/p&gt;
        &lt;/form&gt;
      </code>
      ASP代码(response.asp)： 
      <code language="asp">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IRequest.GetForm>

  <IRequest.GetForms>
    <summary>
      从 IRequest 对象的表单集合中检索所有值。
    </summary>
    <returns>
      如果成功，返回一个两维数组，其中包含名称-值对；否则，返回一个空数组。
    </returns>
    <remarks>
      GetForms()方法从使用 POST 方法的表单通过 HTTP 请求主体发布的所有值中检索所有值，并将其作为一个两维数组返回。如果没有发送表单值，集合数组为空。
    </remarks>
    <example> 
      以下示例演示了此方法的使用： 
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent

        PROCEDURE InitProc() _INIT 3
            goASPComponent := ASPComponent{}

        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL aTemp AS ARRAY
                LOCAL cRet AS STRING

                aTemp := SELF:Request:GetForms()
                cRet  := GetHTTPValueTable(aTemp)

                RETURN SELF:Response:_Write(cRet)
      </code>
      HTML代码： 
      <code language="html">
        &lt;form action="response.asp?Action=FORM" method="post"&gt;
        &lt;p&gt;Value1: &lt;input type="text" name="Value1" size="4"&gt;&lt;/p&gt;
        &lt;p&gt;Value2: &lt;input type="text" name="Value2" size="5"&gt;&lt;/p&gt;
        &lt;p&gt;Value2: &lt;input type="text" name="Value2" size="5"&gt;&lt;/p&gt;
        &lt;p&gt;&lt;input type="submit" value="Execute POST Request"&gt; &lt;/p&gt;
        &lt;/form&gt;
      </code>
      ASP代码(response.asp)： 
      <code language="asp">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IRequest.GetForms>

  <IRequest.GetItem>
    <summary>
      从 HTTP 请求主体中检索任何值。
    </summary>
    <param name="cVarName">变量的名称。</param>
    <returns>
      如果成功，返回一个字符串值；否则，返回 NULL_STRING。
    </returns>
    <remarks>
      此方法返回一个值，该值发布到 HTTP 请求主体。集合按以下顺序搜索：QueryString，Form，Cookies，ClientCertificate，ServerVariables。
    </remarks>
    <example> 
      以下示例演示了此方法的使用： 
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent

        PROCEDURE InitProc() _INIT 3
          goASPComponent := ASPComponent{}

        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL cRet AS STRING
                cRet := SELF:Request:GetItem("Value1")
                RETURN SELF:Response:_Write("Value1=" + cRet)
      </code>
      HTML代码： 
      <code language="html">
        &lt;form action="response.asp?Action=FORM" method="post"&gt;
        &lt;p&gt;Value1: &lt;input type="text" name="Value1" size="4"&gt;&lt;/p&gt;
        &lt;p&gt;&lt;input type="submit" value="Execute POST Request"&gt; &lt;/p&gt;
        &lt;/form&gt;
      </code>
      ASP代码(response.asp)： 
      <code language="asp">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IRequest.GetItem>

  <IRequest.GetQueryString>
    <summary>
      从 HTTP 请求的查询字符串中检索值。
    </summary>
    <param name="cVarName">变量的名称。</param>
    <param name="n"> 位置，如果在集合中存在多个具有相同名称的变量，<paramref name="cVarName" />。 </param>
    <returns>
      如果成功，返回一个字符串值；否则，返回 NULL_STRING。
    </returns>
    <remarks>
      GetQueryString() 方法从 HTTP 请求的查询字符串中检索变量的值(即，在HTTP 请求中的问号(？)后编码的值)。
    </remarks>
    <example> 
      以下示例演示了此方法的使用： 
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent

        PROCEDURE InitProc() _INIT 3
            goASPComponent := ASPComponent{}

        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL cRet AS STRING
                cRet := SELF:Request:GetQueryString("Action")
                RETURN SELF:Response:_Write("Action=" + cRet)
      </code>
      HTML代码： 
      <code language="X#">
        &lt;html&gt;
        &lt;p&gt;
        &lt;a href="response.asp?Action=TEST&amp;Display=Yes"&gt;
        Start
        &lt;/a&gt;&lt;/p&gt;
        ...
        &lt;/html&gt;
      </code>
      ASP代码(response.asp)： 
      <code language="asp">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IRequest.GetQueryString>

  <IRequest.GetQueryStrings>
    <summary>
      从 HTTP 查询字符串中检索所有值。
    </summary>
    <returns>
      如果成功，返回一个两维数组，其中包含名称-值对；否则，返回一个空数组。
    </returns>
    <remarks>
      GetQueryStrings() 方法从 HTTP 查询字符串(即，通过 GET 方法编码的值)中检索所有值，并将其作为一个两维数组返回。如果没有发送值，数组为空。
    </remarks>
    <example> 
      以下示例演示了此方法的使用： 
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent

        PROCEDURE InitProc() _INIT 3
            goASPComponent := ASPComponent{}

        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL aTemp AS ARRAY
                LOCAL cRet AS STRING

                aTemp := SELF:Request:GetQueryStrings()
                cRet := GetHTTPValueTable(aTemp)

                RETURN SELF:Response:_Write(cRet)
      </code>
      HTML代码： 
      <code language="html">
        &lt;html&gt;
        &lt;p&gt;
        &lt;a href="response.asp?Action=TEST&amp;Display=Yes"&gt;
        Start
        &lt;/a&gt;&lt;/p&gt;
        ...
        &lt;/html&gt;
      </code>
      ASP代码(response.asp)： 
      <code language="asp">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IRequest.GetQueryStrings>

  <IRequest.GetServerVariable>
    <summary>
      从 IRequest 对象的环境变量集合中检索值。
    </summary>
    <param name="cVarName">
      环境变量的名称。
      有效的名称是：
    </param>
    <param name="AUTH_TYPE">REMOTE_HOST</param>
    <param name="CONTENT_LENGTH">REQUEST_METHOD</param>
    <param name="CONTENT_TYPE">SCRIPT_MAP</param>
    <param name="GATEWAY_INTERFACE">SCRIPT_NAME</param>
    <param name="HTTP_HeaderName">SERVER_NAME</param>
    <param name="LOGON_USER">SERVER_PORT</param>
    <param name="PATH_INFO">SERVER_PORT_SECURE</param>
    <param name="PATH_TRANSLATED">SERVER_PROTOCOL</param>
    <param name="QUERY_STRING">SERVER_SOFTWARE</param>
    <param name="REMOTE_ADDR">URL</param>
    <returns>
      如果成功，返回一个字符串值；否则，返回 NULL_STRING。
    </returns>
    <remarks>
      GetServerVariable() 方法从 IRequest 对象的环境变量集合中检索一个值。
    </remarks>
    <example> 
      以下示例演示了此方法的使用： 
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent

        PROCEDURE InitProc() _INIT 3
            goASPComponent := ASPComponent{}

        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL cRet AS STRING
                cRet := ;
                SELF:Request:GetServerVariable("PATH_TRANSLATED")
                RETURN SELF:Response:_Write("Path name: " + cRet)
      </code>
      HTML code: 
      <code language="X#">
        &lt;html&gt;
        &lt;p&gt;
        &lt;a href="response.asp"&gt;
        Display Path
        &lt;/a&gt;&lt;/p&gt;
        ...
        &lt;/html&gt;
      </code>
      ASP code (response.asp): 
      <code language="X#">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IRequest.GetServerVariable>

  <IRequest.GetServerVariables>
    <summary>
      检索 IRequest 对象的所有环境变量。
    </summary>
    <returns>
      如果成功，返回一个包含名称-值对的二维数组；否则，返回一个空数组。
    </returns>
    <remarks>
      GetServerVariables() 方法将服务器环境的所有值作为二维数组检索。
    </remarks>
    <example> 
      以下示例演示了此方法的使用： 
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent

        PROCEDURE InitProc() _INIT 3
            goASPComponent := ASPComponent{}

        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL aTemp AS ARRAY
                LOCAL cRet AS STRING

                aTemp := SELF:Request:GetServerVariables()
                cRet := GetHTTPValueTable(aTemp)

                RETURN SELF:Response:_Write(cRet)
      </code>
      HTML code: 
      <code language="html">
        &lt;html&gt;
        &lt;p&gt;
        &lt;a href="response.asp"&gt;
        Display Server Environment
        &lt;/a&gt;&lt;/p&gt;
        ...
        &lt;/html&gt;
      </code>
      ASP code (response.asp): 
      <code language="asp">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IRequest.GetServerVariables>

  <IResponse>
    <summary>
      将输出发送到客户端。
    </summary>
    <remarks>
      IResponse 类用于将输出发送到客户端。
    </remarks>
  </IResponse>

  <IResponse.ctor>
    <summary>
      构造一个 IResponse 对象实例。
    </summary>
    <param name="oIScrContext">一个 IScriptingContext 对象。</param>
    <param name="pIRequest">一个指向 IResponse 接口对象结构的指针。</param>
    <remarks>
      当 Internet 信息服务器(IIS)加载适当的 .ASP 文件时，IScriptingContext:OnStartPage() 方法会自动创建一个 IResponse 对象实例。
      因此，您不必自己创建这个对象。而是通过 IScriptingContext:Request 属性将其用于 ASP 组件应用程序。
    </remarks>
  </IResponse.ctor>

  <IResponse._AddHeader>
    <summary>
      向 HTTP 响应添加一个 HTML 头。
    </summary>
    <param name="cHeaderName">包含 HTTP 头名称的字符串。</param>
    <param name="cHeader">包含 HTTP 头的字符串。</param>
    <returns>
      如果值已添加，返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      此方法向 HTTP 响应添加一个 HTML 头。
    </remarks>
  </IResponse._AddHeader>

  <IResponse._AppendToLog>
    <summary>
      将字符串添加到当前请求的Web服务器日志条目的末尾。
    </summary>
    <param name="cMessage">要添加到日志条目的字符串。</param>
    <returns>
      如果值已添加，返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      此方法将字符串添加到当前请求的 Web 服务器日志条目的末尾。日志条目最多可以包含80个字节。
    </remarks>
  </IResponse._AppendToLog>

  <IResponse._Clear>
    <summary>
      清除当前响应的任何缓冲的 HTML 输出。
    </summary>
    <returns>
      如果值已更改，返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      此方法清除当前响应的任何缓冲的 HTML 输出。
    </remarks>
  </IResponse._Clear>

  <IResponse._End>
    <summary>
      使服务器停止处理脚本并返回当前响应。
    </summary>
    <returns>
      如果值已更改，返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      此方法使服务器停止处理脚本并返回当前响应。
    </remarks>
  </IResponse._End>

  <IResponse._Flush>
    <summary>
      立即发送缓冲的输出。
    </summary>
    <returns>
      如果值已更改，返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      此方法立即将缓冲的输出发送到客户端。
    </remarks>
  </IResponse._Flush>

  <IResponse._Redirect>
    <summary>
      使浏览器尝试连接到不同的 URL。
    </summary>
    <param name="cNewURL">一个新的 URL 值，类型为 STRING。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks> 此方法停止服务器处理当前脚本，然后使浏览器尝试连接到 <paramref name="cNewURL" />。 </remarks>
  </IResponse._Redirect>

  <IResponse._Write>
    <summary>
      向 HTTP 输出写入指定的字符串。
    </summary>
    <param name="cOut">包含 HTTP 输出的字符串。</param>
    <param name="nSize"> 要写入的字节数。如果省略，将默认为 <paramref name="cOut" /> 的长度。 </param>
    <returns>
      如果值已更改，返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      此方法向 HTTP 输出写入数据。
    </remarks>
  </IResponse._Write>

  <IResponse.GetBuffer>
    <summary>
      检索 IResponse 对象的 Buffer 标志属性的当前值。
    </summary>
    <returns>
      如果当前 HTTP 输出的值已缓冲，返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      此方法检索 IResponse 对象的 Buffer 标志属性的当前值。
    </remarks>
  </IResponse.GetBuffer>

  <IResponse.GetContentType>
    <summary>
      检索 IResponse 对象的 ContentType 属性的当前值。
    </summary>
    <returns>
      如果成功，返回 IResponse 对象的内容类型，类型为 STRING；否则，返回 NULL_STRING。
    </returns>
    <remarks>
      此方法检索 IResponse 对象的 ContentType 属性的当前值。
    </remarks>
  </IResponse.GetContentType>

  <IResponse.GetCookies>
    <summary>
      检索 IResponse 对象的 cookie 集合。
    </summary>
    <returns>
      一个 IWriteCookie 对象实例。
    </returns>
    <remarks>
      此方法检索 IResponse 对象的只写 cookie 集合，返回一个 IWriteCookie 对象实例。
    </remarks>
  </IResponse.GetCookies>

  <IResponse.GetExpires>
    <summary>
      检索 IResponse 对象的 Expires 属性的当前值。
    </summary>
    <returns>
      IResponse 对象的过期值，类型为 LONG。
    </returns>
    <remarks>
      此方法检索 IResponse 对象的 Expires 属性的当前值。此属性指定页面在浏览器上缓存的时间长度。如果用户在过期前返回同一页面，将显示缓存的版本。
    </remarks>
  </IResponse.GetExpires>

  <IResponse.GetExpiresAbsolute>
    <summary>
      检索 IResponse 对象的 ExpiresAbsolute 属性的当前值。
    </summary>
    <returns>
      IResponse 对象的过期值，类型为 DATE。
    </returns>
    <remarks>
      此方法检索 IResponse 对象的 ExpiresAbsolute 属性的当前值。此属性指定页面在浏览器上缓存的过期日期。
      如果用户在该日期和时间之前返回同一页面，将显示缓存的版本。
      如果未指定时间，页面将在当天午夜过期。如果未指定日期，页面将在脚本运行的那一天的给定时间过期。
    </remarks>
  </IResponse.GetExpiresAbsolute>

  <IResponse.GetStatus>
    <summary>
      检索 IResponse 对象的 Status 属性的当前值。
    </summary>
    <returns>
      IResponse 对象的 Status 属性的当前值，类型为 STRING。
    </returns>
    <remarks>
      此方法检索 IResponse 对象的 Status 属性的当前值。状态指定服务器返回的状态行的值。状态值在 HTTP 规范中定义。
    </remarks>
  </IResponse.GetStatus>

  <IResponse.PutBuffer>
    <summary>
      设置 IResponse 对象的 Buffer 标志属性的当前值。
    </summary>
    <param name="lNew">Buffer 标志属性的新值。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法设置 IResponse 对象的 Buffer 标志属性的值。
    </remarks>
  </IResponse.PutBuffer>

  <IResponse.PutContentType>
    <summary>
      设置 IResponse 对象的 ContentType 属性的当前值。
    </summary>
    <param name="cType">一般内容类别。</param>
    <param name="cSubType">特定内容类型。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法设置 IResponse 对象的 ContentType 属性的值，作为描述内容类型的字符串。<br />
      此字符串通常格式为，类型/子类型，其中类型是一般内容类别，子类型是特定内容类型。<br />
      有关支持的所有内容类型的完整列表，请参阅您的 Web 浏览器文档或当前的 HTTP 规范。
    </remarks>
    <example> 
      以下示例演示了此方法的使用： 
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent

        PROCEDURE InitProc() _INIT 3
            goASPComponent := ASPComponent{}

        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL aTemp AS ARRAY
                LOCAL cRet AS STRING
                ...
                SELF:Response:PutContentType(/gif)
                SELF:Response:PutContentType(text/html)
                RETURN SELF:Response:_Write("Hello world")
      </code>
    </example>
  </IResponse.PutContentType>

  <IResponse.PutExpires>
    <summary>
      设置 IResponse 对象的 Expires 属性的当前值。
    </summary>
    <param name="nMinutes">以分钟为单位的新过期值。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法设置 IResponse 对象的 Expires 属性的当前值。此属性指定页面在浏览器上缓存的时间长度。如果用户在过期前返回同一页面，将显示缓存的版本。
    </remarks>
  </IResponse.PutExpires>

  <IResponse.PutExpiresAbsolute>
    <summary>
      设置 IResponse 对象的 Expires 属性的当前值。
    </summary>
    <param name="dNew">新的过期值，类型为 DATE。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法设置 IResponse 对象的 ExpiresAbsolute 属性的新值。此属性指定页面在浏览器上缓存的过期日期。<br />
      如果用户在该日期返回同一页面，将显示缓存的版本。如果未指定时间，页面将在当天午夜过期。<br />
      如果未指定日期，页面将在脚本运行的那一天的给定时间过期。
    </remarks>
  </IResponse.PutExpiresAbsolute>

  <IResponse.PutStatus>
    <summary>
      为 IResponse 对象的 Status 属性设置新值。
    </summary>
    <param name="cNew">新的状态值，类型为 STRING。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法为 IResponse 对象的 Status 属性设置新值。状态指定服务器返回的状态行的值。状态值在 HTTP 规范中定义。
    </remarks>
  </IResponse.PutStatus>

  <IScriptingContext>
    <summary>
      检索 Active Server Pages (ASP)内置对象。
    </summary>
    <remarks>
      此类公开了您的组件可以使用的方法，以检索 Active Server Pages (ASP)内置对象。
    </remarks>
  </IScriptingContext>

  <IScriptingContext.ctor>
    <summary>
      构造一个 IScriptingContext 对象实例。
    </summary>
  </IScriptingContext.ctor>

  <IScriptingContext.Application>
    <summary>
      一个 IApplicationObject 对象实例。
    </summary>
    <value>一个 IApplicationObject 对象实例。</value>
  </IScriptingContext.Application>

  <IScriptingContext.ASPApp>
    <summary>
      一个 ASPAppAbstract 对象实例。
    </summary>
    <value>一个 ASPAppAbstract 对象实例。</value>
  </IScriptingContext.ASPApp>

  <IScriptingContext.GetApplication>
    <summary>
      检索内置的 IApplicationObject 实例。
    </summary>
    <returns>
      如果成功，返回一个 IApplicationObject 实例；否则，返回 NULL_OBJECT。
    </returns>
    <remarks>
      GetApplication() 方法基于 IApplicationObject 接口指针的内置构建创建一个新的 IApplicationObject 实例。
      当 Internet 信息服务器加载适当的ASP脚本文件时，此方法由 OnStartPage() 方法在内部调用。您可以通过 Application 属性访问创建的实例，
      <paramref name="oIAppObj" />。 
    </remarks>
  </IScriptingContext.GetApplication>

  <IScriptingContext.GetRequest>
    <summary>
      检索内置的 IRequest 实例。
    </summary>
    <returns>
      如果成功，返回一个 IRequest 实例；否则，返回 NULL_OBJECT。
    </returns>
    <remarks>
      此方法基于 IRequest 接口指针的内置构建创建一个新的 IRequest 实例。
      当 Internet 信息服务器加载适当的 ASP 脚本文件时，此方法由 OnStartPage() 方法在内部调用。
      您可以通过 Request 属性访问创建的实例，<paramref name="oIRequest" />。 
    </remarks>
  </IScriptingContext.GetRequest>

  <IScriptingContext.GetResponse>
    <summary>
      检索内置的 IResponse 对象实例。
    </summary>
    <returns>
      如果成功，返回一个 IResponse 实例；否则，返回 NULL_OBJECT。
    </returns>
    <remarks>
      此方法基于 IResponse 接口指针的内置构建创建一个新的 IResponse 实例。
      当 Internet 信息服务器加载适当的 ASP 脚本文件时，此方法由 OnStartPage() 方法在内部调用。
      您可以通过 Response 属性访问创建的实例，<paramref name="oIResponse" />。 
    </remarks>
  </IScriptingContext.GetResponse>

  <IScriptingContext.GetServer>
    <summary>
      检索内置的 IServer 对象实例。
    </summary>
    <returns>
      如果成功，返回一个 IServer 实例；否则，返回 NULL_OBJECT。
    </returns>
    <remarks>
      此方法基于 IServer 接口指针的内置构建创建一个新的 IServer 实例。
      当 Internet 信息服务器加载适当的 ASP 脚本文件时，此方法由 OnStartPage() 方法在内部调用。
      您可以通过 Server 属性访问创建的实例，<paramref name="oIServer" />。 
    </remarks>
  </IScriptingContext.GetServer>

  <IScriptingContext.GetSession>
    <summary>
      检索内置的 ISessionObject 对象实例。
    </summary>
    <returns>
      如果成功，返回一个 ISessionObject 实例；否则，返回 NULL_OBJECT。
    </returns>
    <remarks>
      此方法基于 ISessionObject 接口指针的内置构建创建一个新的 ISessionObject 实例。
      当 Internet 信息服务器加载适当的 ASP 脚本文件时，此方法由 OnStartPage() 方法在内部调用。
      您可以通过 Session 属性访问创建的实例，<paramref name="oISessionObject" />。 
    </remarks>
  </IScriptingContext.GetSession>

  <IScriptingContext.GetVariantString>
    <summary>
      将 VARIANT 字符串转换为 X# 字符串的辅助方法。
    </summary>
    <param name="pString">指向 IDispatch 对象的指针。</param>
    <returns>
      如果成功，返回一个转换后的 X# STRING；否则，返回 NULL_STRING。
    </returns>
    <remarks>
      此方法将 VARIANT 转换为动态的 X# 字符串值。此方法可用于实现带有 STRING 参数的 ASSIGN 方法。
    </remarks>
    <example> 
      以下示例是ASP组件的Action属性的典型实现： 
      <code language="X#">
        CLASS ASPComponent INHERIT IScriptingContext
            PROTECT cAction AS STRING

        ASSIGN Action(cNew) CLASS ASPComponent
            SELF:cAction := SELF:GetVariantString(cNew)
            RETURN SELF:cAction

        ACCESS Action CLASS ASPComponent
            RETURN SELF:cAction
      </code>
    </example>
  </IScriptingContext.GetVariantString>

  <IScriptingContext.HTTPErrorMessage>
    <summary>
      创建 HTML 代码以在 Internet 浏览器中显示 X# 错误对象的所有值。
    </summary>
    <param name="oError">当前 Error 对象实例。</param>
    <returns>
      包含在 Internet 浏览器中显示错误的 HTML 代码的字符串。
    </returns>
    <remarks>
      此方法基于 X# Error 对象的值创建 HTML 代码，并在运行时发生错误时自动调用。如果要修改默认错误消息的设计，只需重载此方法。
    </remarks>
    <example> 
      以下示例演示如何重载默认的错误处理方法以创建自定义的 HTML 输出： 
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent

        PROCEDURE InitProc() _INIT 3
            goASPComponent := ASPComponent{}

        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPErrorMessage(oError) CLASS ASPComponent
                LOCAL cRet AS STRING

                IF IsObject(oError)
                    cRet := SUPER:HTTPErrorMessage(oError)
                ENDIF

                RETURN cRet

            METHOD HTTPGoBackLink (cCaption) CLASS ASPComponent
                LOCAL cRef AS STRING
                LOCAL cRet AS STRING

                IF !IsString(cCaption)
                    cCaption := "Back"
                ENDIF

                cRef := SELF:oRequest:GetServerVariable("HTTP_REFERER")
                cRet += '&lt;p&gt;&lt;a href="'
                cRet += cRef + '"&gt;'
                cRet += cCaption
                cRet += '&lt;/a&gt;&lt;/p&gt;'

                RETURN cRet
      </code>
    </example>
  </IScriptingContext.HTTPErrorMessage>

  <IScriptingContext.HTTPQueryString>
    <summary>
      创建 HTML 代码以显示查询字符串的所有项。
    </summary>
    <returns>
      包含显示查询字符串的所有项的 HTML 代码的字符串。
    </returns>
    <remarks>
      HTTPQueryString() 方法创建 HTML 代码以显示查询字符串的所有项。
    </remarks>
    <example> 
      以下源代码可用于创建一个用于显示查询字符串项的 ASP 组件： 
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent

        PROCEDURE InitProc() _INIT 3
            goASPComponent := ASPComponent{}

        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL cRet AS STRING
                cRet := SELF:HTTPQueryString()
                RETURN SELF:Response:_Write(cRet)
      </code>
      ASP代码: 
      <code language="asp">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IScriptingContext.HTTPQueryString>

  <IScriptingContext.HTTPServerVariables>
    <summary>
      创建 HTML 代码以显示 Internet 服务器的所有环境变量。
    </summary>
    <returns>
      包含显示所有环境变量的 HTML 代码的字符串。
    </returns>
    <remarks>
      HTTPServerVariables() 方法创建 HTML 代码以显示 Internet 服务器的所有环境变量。
    </remarks>
    <example> 
      以下源代码可用于创建一个用于显示服务器环境的ASP组件： 
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent

        PROCEDURE InitProc() _INIT 3
            goASPComponent := ASPComponent{}

        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL cRet AS STRING
                cRet := SELF:HTTPServerVariables()
                RETURN SELF:Response:_Write(cRet)
      </code>
      ASP代码: 
      <code language="asp">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IScriptingContext.HTTPServerVariables>

  <IScriptingContext.OnEndPage>
    <summary>
      ASP 组件的清理(退出)方法。
    </summary>
    <remarks> 
      当服务器完成对 ASP 页面上的脚本的处理时，它会调用所有实现了 OnEndPage() 的组件的 OnEndPage() 方法。服务器在处理该页面的脚本后调用此方法。 
      <note type="tip">
        如果要重载此方法以进行自己的去初始化操作，请首先调用 SUPER 方法。
      </note>
    </remarks>
  </IScriptingContext.OnEndPage>

  <IScriptingContext.OnStartPage>
    <summary>
      ASP组件的入口点。
    </summary>
    <param name="pDispatch">指向 IDispatch 接口对象的指针。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      当用户在基于 ASP 的应用程序中请求 Web 页面时，服务器会调用该页面上所有组件的 OnStartPage() 方法(除了那些具有应用程序范围的组件)。<br />
      此方法为以下内置接口创建对象实例：
      ISessionObject IApplicationObject IRequest IResponse IServer 
      <note type="tip">
        如果要重载此方法以进行自己的初始化操作，请首先调用 SUPER 方法。
      </note>
    </remarks>
    <example> 
      以下源代码显示了如何重载 OnStartPage() 以进行自己的目的： 
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent

        PROCEDURE InitProc() _INIT 3
            goASPComponent := ASPComponent{}

        CLASS ASPComponent INHERIT IscriptingContext
            LOCAL p AS PTR

        METHOD OnStartPage(pDispatch) CLASS ASPComponent
            IF SUPER:OnStartPage(pDispatch)
                SELF:p := MemAlloc(100)
            ENDIF

        METHOD OnEndPage() CLASS ASPComponent
            SUPER:OnEndPage()

            IF SELF:p != NULL_PTR
                MemFree(SELF:p)
                SELF:p := NULL_PTR
            ENDIF
      </code>
      ASP代码: 
      <code language="asp">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IScriptingContext.OnStartPage>

  <IScriptingContext.Request>
    <summary>
      一个 IRequest 对象实例。
    </summary>
    <value>一个 IRequest 对象实例。</value>
  </IScriptingContext.Request>

  <IScriptingContext.Response>
    <summary>
      一个 IResponse 对象实例。
    </summary>
    <value>一个 IResponse 对象实例。</value>
  </IScriptingContext.Response>

  <IScriptingContext.Server>
    <summary>
      一个 IServer 对象实例。
    </summary>
    <value>一个 IServer 对象实例。</value>
  </IScriptingContext.Server>

  <IScriptingContext.Session>
    <summary>
      一个 ISession 对象实例。
    </summary>
    <value>一个 ISession 对象实例。</value>
  </IScriptingContext.Session>

  <IScriptingContext.WriteImage>
    <summary>
      为 ASP 组件创建显示图像的 HTML 代码。
    </summary>
    <param name="cFile">图像文件名，包括驱动器号和路径。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      WriteImage()为 ASP 组件创建显示图像的 HTML 代码。
    </remarks>
  </IScriptingContext.WriteImage>

  <IServer>
    <summary>
      在服务器上提供实用方法。
    </summary>
    <remarks>
      IServer 类提供了在服务器上作为实用函数的方法。
    </remarks>
  </IServer>

  <IServer.ctor>
    <summary>
      构造一个 IServer 对象实例。
    </summary>
    <param name="oIScrContext">一个 IScriptingContext 对象。</param>
    <param name="pIServer">指向 IServer 接口对象结构的指针。</param>
    <remarks>
      当 Internet 信息服务器(IIS)加载适当的 .ASP 文件时，IScriptingContext:OnStartPage() 方法会自动创建一个 IServer 对象实例。
      因此，您不必自己创建此对象。而是通过 IScriptingContext:Server 属性在 ASP 组件应用程序中使用它。
    </remarks>
  </IServer.ctor>

  <IServer._HTMLEncode>
    <summary>
      对指定的字符串应用 HTML 编码。
    </summary>
    <param name="cHTML">要编码的 HTML 字符串。</param>
    <returns>
      如果成功，返回一个已编码的 HTML 文本作为 STRING；否则，返回 NULL_STRING。
    </returns>
    <remarks> 
      此方法对指定的字符串 <paramref name="cHTML" /> 应用 HTML 编码。 
    </remarks>
    <example> 
      对方法_HTMLEncode()的以下调用 
      <code language="X#">
        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL cEncode AS STRING
                ...
                cEncode := SELF:Server:_HTMLEncode("&lt;/html&gt;")
                ...
      </code>
      产生的输出(cEncode)如下： 
      <code language="html">
        &amp;lt;/html&amp;gt;
      </code>
    </example>
  </IServer._HTMLEncode>

  <IServer._MapPath>
    <summary>
      将指定的相对或虚拟路径映射到服务器上的相应物理目录。
    </summary>
    <param name="cPath">路径的别名。</param>
    <returns>
      如果成功，返回包括驱动器号在内的完整指定路径；否则，返回 NULL_STRING。
    </returns>
    <remarks> 
      _MapPath() 方法将指定的相对或虚拟路径 <paramref name="cPath" /> 映射到服务器上的相应物理目录。<br />
      如果 <paramref name="cPath" /> 以斜杠(/)或反斜杠(\)开头，此方法返回一个路径，就好像 <paramref name="cPath" /> 是一个完整的虚拟路径一样。<br />
      如果 <paramref name="cPath" /> 不以斜杠开头，_MapPath() 会返回相对于正在处理的 .ASP 文件的目录的路径。 
    </remarks>
    <example> 
      对方法_MapPath()的以下调用 
      <code language="X#">
        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL cPath AS STRING
                ...
                cPath := SELF:Server:_MapPath("/cgi-bin")
                ...
      </code>
      产生的输出(cPath)如下： 
      <code language="X#">
        c:\inetsrv\scripts
      </code> 
      然而，对 
      <code language="X#">
        cPath := SELF:Server:_MapPath("test")
      </code> 
      的调用产生的输出(cPath)如下： 
      <code language="X#">
        c:\inetsrv\wwwroot\vosample\test
      </code>
    </example>
  </IServer._MapPath>

  <IServer._URLEncode>
    <summary>
      对指定的字符串应用 URL 编码。
    </summary>
    <param name="cURL">要编码的 URL 字符串。</param>
    <returns>
      如果成功，返回一个已编码的 URL 文本作为 STRING；否则，返回 NULL_STRING。
    </returns>
    <remarks> 此方法对指定的字符串 cURL 应用 URL 编码。 </remarks>
    <example> 
      对方法 _URLEncode() 的以下调用 
      <code language="X#">
        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL cEncode AS STRING
                ...
                cEncode := SELF:Server:_URLEncode("X#")
                ...
      </code>
      产生的输出(cEncode)为：
      <code language="X#">
        Visual+Objects
      </code>
    </example>
  </IServer._URLEncode>

  <IServer.GetScriptTimeOut>
    <summary>
      检索 IServer 对象的脚本超时值。
    </summary>
    <returns>
      如果成功，返回以分钟为单位的超时值(类型为 LONG)；否则，返回0。
    </returns>
    <remarks>
      此方法检索 IServer 对象的脚本超时值，以秒为单位。
    </remarks>
  </IServer.GetScriptTimeOut>

  <IServer.PutScriptTimeOut>
    <summary>
      设置 IServer 对象的脚本超时值。
    </summary>
    <param name="nValue">新的以秒为单位的超时值。</param>
    <returns>
      如果成功，返回 TRUE；否则，返回FALSE。
    </returns>
    <remarks> 
      此方法设置 IServer 对象的脚本超时值，以秒为单位。 
      <note type="tip">
        该属性不能设置为小于注册表设置中指定的值。<br />
        例如，如果设置为60，而注册表设置包含120秒的默认值，脚本将在120秒后超时。<br />
        然而，如果 <paramref name="nValue" /> 设置为200，脚本将在200秒后超时。
      </note>
    </remarks>
  </IServer.PutScriptTimeOut>
  
  <ISessionObject>
    <summary>
      存储特定用户会话所需的信息。
    </summary>
    <remarks>
      ISessionObject 对象实例可用于存储特定用户会话所需的信息。存储在 ISessionObject 实例中的变量在整个用户会话期间都会保留。
      当用户在应用程序的页面之间切换时，它们不会被丢弃。
    </remarks>
  </ISessionObject>

  <ISessionObject.ctor>
    <summary>
      构造一个 ISessionObject 对象实例。
    </summary>
    <param name="oIScrContext">一个 IScriptingContext 对象。</param>
    <param name="pISessObj">指向 ISession 接口对象结构的指针。</param>
    <remarks>
      当 Internet 信息服务器(IIS)加载适当的 .ASP 文件时，IScriptingContext:OnStartPage() 方法会自动创建一个 ISessionObject 对象实例。
      因此，您不必自己创建此对象。而是通过 IScriptingContext:Session 属性在 ASP 组件应用程序中使用它。
    </remarks>
  </ISessionObject.ctor>

  <ISessionObject.Abandon>
    <summary>
      销毁当前会话中存储的所有对象，并释放它们的资源。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法销毁当前会话中存储的所有对象，并释放它们的资源。
    </remarks>
  </ISessionObject.Abandon>

  <ISessionObject.GetSessionID>
    <summary>
      检索会话的ID值。
    </summary>
    <returns>
      如果成功，返回ID值(类型为 STRING)；否则，返回 NULL_STRING。
    </returns>
    <remarks>
      GetSessionID() 方法检索会话的ID值，作为 STRING。
    </remarks>
  </ISessionObject.GetSessionID>

  <ISessionObject.GetTimeout>
    <summary>
      检索用户会话的超时值。
    </summary>
    <returns>
      如果成功，返回以分钟为单位的超时值(类型为 LONG)；否则，返回0。
    </returns>
    <remarks>
      GetTimeout() 方法检索 ISessionObject 对象实例的超时值。
    </remarks>
  </ISessionObject.GetTimeout>

  <ISessionObject.GetValue>
    <summary>
      检索存储在 ISessionObject 对象实例中的变量的值。
    </summary>
    <param name="cVarName">所需变量的名称。</param>
    <returns>
      如果成功，返回变量的值(类型为 USUAL)；否则，返回 NIL。
    </returns>
    <remarks>
      此方法检索存储在 ISessionObject 对象实例中的变量的值。
    </remarks>
    <example> 
      以下源代码可用于显示会话值"SessionVar"： 
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent

        PROCEDURE InitProc() _INIT 3
            goASPComponent := ASPComponent{}

        CLASS ASPComponent INHERIT IScriptingContext
            METHOD HTTPResponse CLASS ASPComponent
                LOCAL cRet AS STRING
                cRet := SELF:Session:GetValue("SessionVar")
                RETURN SELF:Response:_Write(cRet)
      </code>
      ASP代码： 
      <code language="asp">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        Session("SessionVar") = 111
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </ISessionObject.GetValue>

  <ISessionObject.PutTimeout>
    <summary>
      设置用户会话的超时值。
    </summary>
    <param name="nValue">新的以分钟为单位的超时值。</param>
    <returns>
      如果成功，返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      此方法设置 ISessionObject 对象实例的超时值。
    </remarks>
  </ISessionObject.PutTimeout>

  <ISessionObject.PutValue>
    <summary>
      将变量的值存储到 ISessionObject 实例中。
    </summary>
    <param name="cVarName">所需变量的名称。</param>
    <param name="xValue">新的值。</param>
    <returns>
      如果成功，返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      此方法将存储在 ISessionObject 对象实例中的变量的值设置为新值。
    </remarks>
  </ISessionObject.PutValue>

  <IUnknown>
    <summary>
      为 OLE 自动化的内部实现提供一个辅助类。
    </summary>
    <remarks>
      <br />重要！此类仅用于内部实现，不应直接使用。 
    </remarks>
  </IUnknown>

  <IUnknown.ctor>
    <summary> 
      为 OLE 自动化的内部实现提供一个辅助方法。 <br />
      重要！此方法仅用于内部实现，不应直接使用。 
    </summary>
  </IUnknown.ctor>

  <IUnknown.AddRef>
    <summary> 为 OLE 自动化的内部实现提供一个辅助方法。 <br />重要！此方法仅用于内部实现，不应直接使用。 </summary>
  </IUnknown.AddRef>

  <IUnknown.Destroy>
    <summary> 为 OLE 自动化的内部实现提供一个辅助方法。 <br />重要！此方法仅用于内部实现，不应直接使用。 </summary>
  </IUnknown.Destroy>

  <IUnknown.Release>
    <summary> 
      为 OLE 自动化的内部实现提供一个辅助方法。 <br />
      重要！此方法仅用于内部实现，不应直接使用。 
    </summary>
  </IUnknown.Release>

  <IWriteCookie>
    <summary>
      为 HTTP 响应的只写 cookie 集合提供一个类，用于修改 cookie 的值和属性。
    </summary>
    <remarks>
      IWriteCookie 类使您能够修改存储在 HTTP 响应的只写 cookie 集合中的 cookie 的值和属性。
    </remarks>
  </IWriteCookie>

  <IWriteCookie.ctor>
    <summary>
      构造一个 IWriteCookie 对象实例。
    </summary>
    <param name="pICookie">指向 IWriteCookie 接口对象结构的指针。</param>
    <param name="oIServer">一个 IServer 对象实例。</param>
    <remarks>
      IWriteCookie 对象实例可以通过 IResponse:GetCookies() 方法创建，因为它直接与 HTTP 请求相关联。
      因此，您不必自己创建此对象。而是通过 IScriptingContext:Response:GetCookies() 方法将其用于 ASP 组件应用程序。
    </remarks>
  </IWriteCookie.ctor>

  <IWriteCookie.PutDomain>
    <summary>
      设置 cookie 对象的 Domain 属性。
    </summary>
    <param name="cDomain">新的域值，类型为 STRING。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法设置 IWriteCookie 对象的 Domain 属性的新值。此属性确定是否仅将 cookie 发送到此域的请求。
    </remarks>
  </IWriteCookie.PutDomain>

  <IWriteCookie.PutExpires>
    <summary>
      设置 cookie 对象的 Expires 属性的当前值。
    </summary>
    <param name="dNew">新的过期值，类型为 DATE。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法设置 IWriteCookie 对象的 Expires 属性的新值。此属性指定 cookie 的过期日期。
    </remarks>
  </IWriteCookie.PutExpires>

  <IWriteCookie.PutItem>
    <summary>
      将指定的 cookie 添加到只写 cookie 集合。
    </summary>
    <param name="cName">要添加到 cookie 的项目的名称，类型为 STRING。</param>
    <param name="cValue">要添加到 cookie 的项目的值，类型为 STRING。</param>
    <param name="aValue"> 包含要添加到 cookie 的项目的值的数组。 <paramref name="cName" /> 被视为键名，cookie 被视为字典 cookie。 </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks> 
      此方法向 IWriteCookie 对象添加一个新项目。
      如果第二个参数是一个 STRING，那么 cookie 被视为简单 cookie，<paramref name="cValue" /> 是 cookie 的值。
      否则，cookie 被视为字典 cookie，<paramref name="aValues" /> 包含 cookie 的键 <paramref name="cName" /> 的值。
    </remarks>
  </IWriteCookie.PutItem>
  
  <IWriteCookie.PutPath>
    <summary>
      设置 cookie 对象的 Path 属性。
    </summary>
    <param name="cPath">新的路径值，类型为 STRING。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法设置 IWriteCookie 对象的 Path 属性的新值。此属性确定是否仅将 cookie 发送到此路径的请求。如果未设置此属性，将使用应用程序路径。
    </remarks>
  </IWriteCookie.PutPath>

  <IWriteCookie.PutSecure>
    <summary>
      设置 cookie 对象的 Secure 属性。
    </summary>
    <param name="lSecure">新的 Secure 属性的逻辑值。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法设置 IWriteCookie 对象的 Secure 属性的新值。此属性指定 cookie 是否安全。
    </remarks>
  </IWriteCookie.PutSecure>

  <KeyEvent>
    <summary>
      提供有关 KeyEvent 的信息，用于封装有关按下的键的信息。
    </summary>
    <remarks>
      KeyEvent 事件在使用键盘时发生，并发送到 Window:KeyDown() 和 Window:KeyUp()。
    </remarks>
    <example> 
      此示例在用户按下 Enter 键时将文本光标向下移动一行。 <paramref name="oCursorPoint" /> 定义了文本光标的当前位置。 
      <code language="X#">
        METHOD KeyDown(aKeyEvt) CLASS TopAppWindow
            IF(aKeyEvt:KeyCode() = KeyEnter)
                ts            := SELF:TextSize('A'):Height() + 2
                oCursorPoint  := Point{10,oCursorPoint:Y() - ts}
            ENDIF
      </code>
    </example>
  </KeyEvent>

  <KeyEvent.ctor>
    <inheritdoc />
  </KeyEvent.ctor>

  <KeyEvent.ASCIIChar>
    <summary>
      一个表示导致此 KeyEvent 的键的正常 ASCII 代码的数字值。
    </summary>
    <value>一个表示导致此 KeyEvent 的键的正常 ASCII 代码的数字值。</value>
    <remarks>
      一个表示导致此 KeyEvent 的键的正常 ASCII 代码的数字值(这包括所有可打印的字符，以及从 Ctrl+A 到 Ctrl+Z 的 Control 键组合)。<br />
      如果按下的是不可打印且不是 Control 键的键，此值为 NIL—您应该调用 KeyEvent:KeyCode() 来检查键(生成 NIL 的键包括功能键、编辑键和方向键)。
    </remarks>
  </KeyEvent.ASCIIChar>

  <KeyEvent.KeyCode>
    <summary>
      一个常量，表示按下的键的代码：
    </summary>
    <value>一个常量，表示按下的键的代码：</value>
    <remarks> 
      以下常量之一，表示按下的键的代码： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>KEYALT</term>
          <description>Alt键</description>
        </item>
        <item>
          <term>KEYARROWDOWN</term>
          <description>向下箭头键</description>
        </item>
        <item>
          <term>KEYARROWLEFT</term>
          <description>向左箭头键</description>
        </item>
        <item>
          <term>KEYARROWRIGHT</term>
          <description>向右箭头键</description>
        </item>
        <item>
          <term>KEYARROWUP</term>
          <description>向上箭头键</description>
        </item>
        <item>
          <term>KEYBACKSPACE</term>
          <description>退格键</description>
        </item>
        <item>
          <term>KEYCANCEL</term>
          <description>取消键</description>
        </item>
        <item>
          <term>KEYCAPSLOCK</term>
          <description>大写锁定键</description>
        </item>
        <item>
          <term>KEYCONTROL</term>
          <description>控制键</description>
        </item>
        <item>
          <term>KEYDELETE</term>
          <description>删除键</description>
        </item>
        <item>
          <term>KEYEND</term>
          <description>结束键</description>
        </item>
        <item>
          <term>KEYENTER</term>
          <description>回车键</description>
        </item>
        <item>
          <term>KEYESCAPE</term>
          <description>退出键</description>
        </item>
        <item>
          <term>KEYF1...KEYF16</term>
          <description>功能键1-16</description>
        </item>
        <item>
          <term>KEYHOME</term>
          <description>主页键</description>
        </item>
        <item>
          <term>KEYINSERT</term>
          <description>插入键</description>
        </item>
        <item>
          <term>KEYNUMLOCK</term>
          <description>数字锁定键</description>
        </item>
        <item>
          <term>KEYPAGEDOWN</term>
          <description>向下翻页键</description>
        </item>
        <item>
          <term>KEYPAGEUP</term>
          <description>向上翻页键</description>
        </item>
        <item>
          <term>KEYPAUSE</term>
          <description>暂停键</description>
        </item>
        <item>
          <term>KEYPRINT</term>
          <description>打印键</description>
        </item>
        <item>
          <term>KEYRETURN</term>
          <description>返回键</description>
        </item>
        <item>
          <term>KEYSHIFT</term>
          <description>Shift键</description>
        </item>
        <item>
          <term>KEYSPACE</term>
          <description>空格键</description>
        </item>
        <item>
          <term>KEYTAB</term>
          <description>制表键</description>
        </item>
      </list>
      KeyEvent:KeyCode 提供对底层键盘硬件的访问。如果 KeyEvent:ASCIIChar 访问方法返回 NIL，请使用此属性。
    </remarks>
  </KeyEvent.KeyCode>

  <KeyEvent.RepeatCount>
    <summary>
      一个数字值，确定用户是否重复按下键或长时间按下键。
    </summary>
    <value>一个数字值，确定用户是否重复按下键或长时间按下键。</value>
    <remarks>
      一个数字值，确定用户是否重复按下键或长时间按下键。<br />
      如果重复按下键，返回按下键的次数；否则，返回1。<br />
      当用户长时间按下键时，多个 KeyEvent 可以被转换为一个 RepeatCount 大于1的 KeyEvent。
    </remarks>
  </KeyEvent.RepeatCount>

  <KeyEvent.System>
    <summary>
      一个逻辑值，确定是否同时按下了 Alt 键和另一个键(如果是，返回 TRUE；否则，返回 FALSE)。
    </summary>
    <value>一个逻辑值，确定是否同时按下了 Alt 键和另一个键(如果是，返回 TRUE；否则，返回 FALSE)。</value>
    <remarks>
      一个逻辑值，确定是否同时按下了 Alt 键和另一个键(如果是，返回 TRUE；否则，返回 FALSE)。
    </remarks>
  </KeyEvent.System>

  <LineObject>
    <summary>
      创建一个 LineObject 对象；这种类型的实体是 DrawObject 层次结构的一部分，它提供了一种显示和操作各种对象的方法。
    </summary>
    <example> 
      要绘制一个 LineObject 对象，调用 Window:Draw() 并将 LineObject 对象作为其参数。窗口通过询问每个对象来绘制自己来完成绘制，例如： 
      <code language="X#">
        METHOD Expose(oEvent) CLASS MyWindow
            LOCAL oLine AS OBJECT
            oLine := LineObject{Point{10,10},Point{20,20}}
            SELF:Draw(oLine)
      </code>
    </example>
  </LineObject>

  <LineObject.ctor>
    <summary>
      构造一个 LineObject 对象。
    </summary>
    <param name="oPoint1">表示线的起始点的点。</param>
    <param name="oPoint2">表示线的结束点的点。</param>
    <param name="oPen">用于绘制 LineObject 对象的笔。如果省略，将使用当前笔。</param>
    <remarks> 由 <paramref name="oPen" /> 指定的笔在被选中时不应被删除。 </remarks>
  </LineObject.ctor>

  <LineObject.BoundingBox>
    <summary>
      一个边界框，表示完全包围此 LineObject 对象的最小矩形。
    </summary>
    <value>一个边界框，表示完全包围此 LineObject 对象的最小矩形。</value>
  </LineObject.BoundingBox>

  <LineObject.Destroy>
    <exclude />
  </LineObject.Destroy>

  <LineObject.Draw>
    <summary>
      在窗口上绘制 LineObject 对象。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      不应在应用程序代码中直接调用此方法—它在 X# 中由 Window:Draw() 调用。请参阅类描述中使用 Draw() 方法的示例。 
    </remarks>
  </LineObject.Draw>

  <LineObject.Origin>
    <summary>
      一个点，表示 LineObject 对象在其所有者窗口上的起始坐标的画布坐标。
    </summary>
    <value>一个点，表示 LineObject 对象在其所有者窗口上的起始坐标的画布坐标。</value>
  </LineObject.Origin>

  <LineObject.Pen>
    <summary>
      与此 LineObject 对象关联的笔。
    </summary>
    <value>与此 LineObject 对象关联的笔。</value>
    <remarks> 
      与此 LineObject 对象关联的笔。 <br />
      更改笔的最常见原因是临时以不同的颜色重新绘制现有线，以突出用户选择的事实。
      在 Windows 中，由 <paramref name="oPen" /> 指定的笔在被选中时不应被删除。 
    </remarks>
  </LineObject.Pen>

  <LineObject.Size>
    <summary>
      一个维度，表示此 LineObject 对象的大小。
    </summary>
    <value>一个维度，表示此 LineObject 对象的大小。</value>
  </LineObject.Size>

  <ListBox>
    <summary>
      创建一个列表框。
    </summary>
    <remarks> 
      列表框和组合框向用户显示一系列项目或选择。<br />
      列表框方法将允许您添加、排列、删除和查询项目列表。当选择了其中一个项目时，
      ListBox:CurrentItem, ListBox:CurrentItemNo, ListBox:TextValue 和 ListBox:Value 将被更新。<br />
      在 FillUsing() 方法中，可以使用一维或二维数组，每个项目的行。<br />
      在二维数组中，第一个元素称为显示值，第二个元素称为返回值。当选择一个项目时，ListBox:TextValue 包含第一个元素(显示值)，ListBox:Value 包含第二个元素(返回值)。
      如果没有选择项目，ListBox:TextValue 为 NULL_STRING，ListBox:Value 为 NIL。<br /><br />

      列表框可以绑定到服务器上的字段(字符、日期、逻辑、数值或备忘录)。
      字段的数据值存储在 ListBox:Value 中。<br />
      列表框将数据值与 FillUsing() 数组中指定的第二个元素值进行比较，如果找到匹配，将第一个元素(显示值)存储在 ListBox:TextValue 中。<br />
      在“无匹配”情况下，列表框不显示选择的项目，
      ListBox:CurrentItem 为 NULL_STRING，ListBox:CurrentItemNo 设置为 0，ListBox:TextValue 和 ListBox:Value 反映字段内容。<br />
      如果选择了项目，ListBox:CurrentItemNo 设置为1到 ListBox:ItemCount 之间的一个数字，并且相应的第二个元素被存储为 ListBox:Value 和字段的数据值。
      <note type="tip">
        所有数组索引引用都从1开始。
      </note>
      您还可以创建一个多选列表框，它允许您在列表框中管理多个项目。<br />
      列表框中的任意数量的项目可以一起选择(称为多选)。每次用户单击一个项目时，都会切换该项目的选中状态。<br />
      通过选择 LBOXMULTIPLESEL 样式创建一个多选列表框。
      此类列表框的某些属性和方法专门适用于多选列表框，
      包括 SelectedCount 访问、ChangeSelected()、ClearSelection()、DeselectItem()、FirstSelected()、NextSelected() 和 SelectItem()。
    </remarks>
    <example> 
      此示例创建并填充了一个列表框，其中包含一系列动物： 
      <code language="X#">
        CLASS MyWindow INHERIT TopAppWindow
            HIDDEN oLB AS OBJECT

            METHOD Init() CLASS MyWindow
                SUPER:Init()
                oLB := ListBox{SELF,42,Point{10,10},;
                Dimension{100,40}}
                oLB:AddItem("Pig")
                oLB:AddItem("Cow")
                oLB:AddItem("Horse")
                oLB:Show()
      </code>
      一个 X# 列表框相当于一个具有 LBS_NOTIFY 和 LBS_SORT 样式的 Windows 列表框。 列表框通常在资源实体中指定，如下所示： 
      <code language="X#">
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 80
        STYLE WS_POPUP | WS_DLGFRAME
        BEGIN
            LISTBOX IDL_ITEMLIST, 10, 10, 90, 40
        END
      </code>
    </example>
  </ListBox>

  <ListBox.ctor>
    <summary>
      构造一个列表框。
    </summary>
    <param name="oOwner">拥有列表框的窗口。</param>
    <param name="xID">列表框的唯一ID(1到8000之间)。</param>
    <param name="oPoint">列表框在画布坐标中的原点。</param>
    <param name="oDimension">列表框在画布坐标中的尺寸。</param>
    <param name="kStyle">列表框的样式，指定为下面列出的常量之一：</param>
    <param name="nResourceID">列表框的资源ID。</param>
    <remarks>
      <include file="Gui.xml" path="doc/LBStyles/*" />
    </remarks>
  </ListBox.ctor>

  <ListBox.AddItem>
    <summary>
      在指定位置向列表框添加一个新项目。
    </summary>
    <param name="cItem">要插入的项目。</param>
    <param name="nItemNumber">要在列表框中插入新项目的位置。指定下面列出的值之一。</param>
    <param name="uRetValue"> 指定项目的关联值。默认为<paramref name="cItem" />。 </param>
    <returns>
      如果添加了项目，将返回列表框中的位置(值为1表示列表框中的第一个位置)。如果无法添加项目，将返回0。
    </returns>
    <remarks>
      <table>
        <tr>
          <th>值</th>
          <th>位置</th>
        </tr>
        <tr>
          <td>0</td>
          <td>在未排序的列表框中，将新项目添加到列表的末尾；如果已排序，将新项目插入由列表框确定的位置。这是默认值。</td>
        </tr>
        <tr>
          <td>1</td>
          <td>列表框中的第一个位置。</td>
        </tr>
        <tr>
          <td>n</td>
          <td>列表框中的第n个位置。</td>
        </tr>
      </table>
    </remarks>
  </ListBox.AddItem>

  <ListBox.Caption>
    <summary>
      表示列表框标题的字符串。
    </summary>
    <value>表示列表框标题的字符串。</value>
  </ListBox.Caption>

  <ListBox.ChangeSelected>
    <summary>
      将多选列表框中的一系列项目更改为指定的选择。
    </summary>
    <param name="oRange">表示选定项目的 Range 对象。</param>
    <param name="lEnabled">选定项目的状态。如果未指定，将默认为 TRUE。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法适用于多选列表框(即，使用 LBOXMULTIPLESEL 样式创建的列表框)。
    </remarks>
  </ListBox.ChangeSelected>

  <ListBox.ClearSelection>
    <summary>
      清除多选列表框中的所有选择。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法适用于多选列表框(即，使用 LBOXMULTIPLESEL 样式创建的列表框)。
    </remarks>
  </ListBox.ClearSelection>

  <ListBox.Create>
    <exclude />
  </ListBox.Create>

  <ListBox.CurrentItem>
    <summary>
      表示当前选择的列表框或组合框项目的字符串。
    </summary>
    <value>表示当前选择的列表框或组合框项目的字符串。</value>
    <remarks>
      如果与可用显示项目匹配，ListBox:CurrentItem 访问还会更改 ListBox:CurrentItemNo，ListBox:CurrentText，ListBox:TextValue 和 ListBox:Value。
    </remarks>
  </ListBox.CurrentItem>

  <ListBox.CurrentItemNo>
    <summary>
      一个数字值，介于1和 ListBox:ItemCount 之间，表示当前选择的项目。
    </summary>
    <value>一个数字值，介于1和 ListBox:ItemCount 之间，表示当前选择的项目。</value>
    <remarks>
      如果没有选择项目，它为0。<br />
      ListBox:CurrentItemNo 还会更改 ListBox:CurrentItem，ListBox:TextValue 和 ListBox:Value。<br />
      如果分配的 ListBox:CurrentItemNo 为零(0)，或者超过 ListBox:ItemCount，那么将不会选择任何项目。<br />
      如果 ListBox:CurrentItemNo 分配表示一个更改，那么 ListBox:ValueChanged 将设置为 TRUE。
    </remarks>
  </ListBox.CurrentItemNo>

  <ListBox.CurrentText>
    <summary>
      ListBox:CurrentText 设置为 NULL_STRING，因为列表框没有文本编辑。
    </summary>
    <value>ListBox:CurrentText 设置为 NULL_STRING，因为列表框没有文本编辑。</value>
  </ListBox.CurrentText>
  
  <ListBox.DeleteItem>
    <summary>
      从列表框中删除一个项目。
    </summary>
    <param name="uItemNumber">要删除的项目的编号。指定下面列出的值之一</param>
    <param name="nItem">要删除的项目的编号。指定下面列出的值之一</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <table>
        <tr>
          <th>值</th>
          <th>位置</th>
        </tr>
        <tr>
          <td>0</td>
          <td>当前选择的项目。这是默认值。</td>
        </tr>
        <tr>
          <td>1</td>
          <td>列表框中的第一个项目。</td>
        </tr>
        <tr>
          <td>n</td>
          <td>列表框中的第n个项目。</td>
        </tr>
      </table>
    </remarks>
  </ListBox.DeleteItem>
  
  <ListBox.DeselectItem>
    <summary>
      取消选择列表框中指定项目的选择。
    </summary>
    <param name="nItem">要取消选择的项目编号。零(0)表示当前项目。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      通常，用户会取消选择，但此方法也允许程序这样做。
      此方法适用于多选列表框(即，使用 LBOXMULTIPLESEL 样式创建的列表框)。
    </remarks>
  </ListBox.DeselectItem>

  <ListBox.Destroy>
    <summary>
      提供一种方法来取消实例化 ListBox 对象。
    </summary>
    <remarks>
      当不再需要 ListBox 对象时，可以使用此方法。
      ListBox:Destroy() 取消实例化 ListBox 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </ListBox.Destroy>

  <ListBox.EnableItemDrag>
    <summary>
      将列表框转换为可拖动列表框。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ListBox.EnableItemDrag>

  <ListBox.FillUsing>
    <summary>
      使用数组或数据服务器指定要在列表框中显示的值集。这些值充当列表框中可以输入的值的约束，并且可选地作为程序值和显示值之间的翻译。
    </summary>
    <param name="oList">String/Usual 对的排序列表</param>
    <param name="aContents">
      包含要放入列表框中的值的数组。可以使用二维数组来定义在选择列表项时返回给程序的值，与在列表中显示的文本字符串分开；
      这个“其他”值是 ListBox:Value 属性中返回的值，如果控件与数据库字段关联，也是存储在数据库中的值。
      因此，数组可以以以下两种格式之一指定： 
      <list type="table">
        <item>
          <term>1.</term>
          <description>包含值列表的一维数组。</description>
        </item>
        <item>
          <term>2.</term>
          <description>
            两个元素数组的数组，每个数组包含要在列表中显示的字符串和返回给程序的相应值。
            请注意，二维数组的结构与 DBServer:GetLookupTable() 返回的结构相同，而一维数组与 DBServer:GetArray() 返回的结构相匹配。
            或者，要使用的数据服务器来提供值集。
          </description>
        </item>
      </list>
    </param>
    <param name="symField1">要用于显示值的字段的符号名称。如果未指定，将使用第一个字段的值。</param>
    <param name="symField2">要用于返回给程序的值的字段的符号名称。如果未指定，将使用第一个字段的值。</param>
    <remarks> 
      列表框显示字段的有效值集。根据使用的列表框类型，值集可能充当对可以检索的值的约束，或者仅充当建议。
      可以指定两个值集，允许在显示的“人类可读”表示和内部的程序值之间进行翻译。<br />
      FillUsing() 方法提供了一种一次性指定要包含在列表中的值的方法，而不是使用 AddItem() 方法逐个构造列表。 
      <note type="tip">
        列表框控件可以与数据库字段关联，就像任何其他控件一样。不要将此主要字段链接与将列表框链接到用于填充列表的辅助服务器的可能性混淆。
      </note>
    </remarks>
    <example> 
      创建一个包含不同货币的列表框，向用户显示显式表示，但在内部使用不同的表示： 
      <code language="X#">
        METHOD Init(...) CLASS OrderWindow
            ...
            oLBCurrency := ListBox{SELF,LBCURRENCY_ID}
            oLBCurrency:FillUsing({;
                                    {"U.S. Dollars",    "USD"},;
                                    {"Can. Dollars",    "CDN"},;
                                    {"Mexican Pesos",   "MEX"},;
                                    {"Yen",             "YEN"},;
                                    {"British Pounds",  "UK"},;
                                    {"German Marks",    "DM"};
                                  })
            oLBCurrency:Show()
      </code>
      创建一个显示产品表中可用产品的列表框： 
      <code language="X#">
        METHOD Init(...) CLASS OrderWindow
            ...
            oLBProducts := ListBox{SELF,LBPRODUCTS_ID}
            oLBProducts:FillUsing(oDBProducts,#ProdName,#ProdNo)
            oLBProducts:Show()
      </code>
    </example>
  </ListBox.FillUsing>

  <ListBox.FirstSelected>
    <summary>
      返回多选列表框中选择的第一个项目的位置，如果没有选择任何项目，则返回0。
    </summary>
    <remarks>
      ListBox:FirstSelected() 在选择的第一个项目上放置一个虚拟光标。
      此方法适用于多选列表框(即，使用 LBOXMULTIPLESEL 样式创建的列表框)。
    </remarks>
  </ListBox.FirstSelected>

  <ListBox.GetItemValue>
    <summary>
      检索指定列表框项目的值。
    </summary>
    <param name="nItemNumber">所需项目的编号。指定下面列出的值之一：</param>
    <returns>
      指定项目的关联值。
    </returns>
    <remarks>
      <table>
        <tr>
          <th>值</th>
          <th>位置</th>
        </tr>
        <tr>
          <td>0</td>
          <td>当前选择的项目。</td>
        </tr>
        <tr>
          <td>1</td>
          <td>列表框中的第一个项目。</td>
        </tr>
        <tr>
          <td>n</td>
          <td>列表框中的第n个项目。</td>
        </tr>
      </table>
    </remarks>
    <example>
      <code language="X#">
        METHOD ListBoxClick(oControlEvent) CLASS EmailWindow
            LOCAL oControl := oControlEvent:Control AS Control

            SUPER:ListBoxClick(oControlEvent)

            IF IsInstanceOf(oControl, #ListBox)
                SELF:DialClient(oControl:GetItemValue(0))
            ENDIF

            RETURN NIL
      </code>
    </example>
  </ListBox.GetItemValue>

  <ListBox.IsSelected>
    <summary>
      确定指定索引位置的列表框项目是否被选择。
    </summary>
    <param name="iIdx">列表框项目的索引位置。</param>
    <returns>
      如果选择，返回 TRUE；否则，返回 FALSE。
    </returns>
  </ListBox.IsSelected>

  <ListBox.ItemCount>
    <exclude />
  </ListBox.ItemCount>

  <ListBox.ListFiles>
    <summary>
      使用指定路径或文件名填充列表框，显示所有与指定路径或文件名匹配的文件的名称。
    </summary>
    <param name="sStartDir">起始目录的路径或文件名。</param>
    <param name="oFixedText"> 自动设置为 <paramref name="sStartDir" /> 的驱动/目录的固定文本。 </param>
    <param name="FileTypes">指定要显示的文件的属性的常量之一：</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <list type="table">
        <listheader>
          <term>Windows API Constant </term>
          <description>Description</description>
        </listheader>
        <item>
          <term>DDL_ARCHIVE</term>
          <description>包括已存档的文件。</description>
        </item>
        <item>
          <term>DDL_DIRECTORY</term>
          <description>包括子目录，用方括号([ ])括起来。</description>
        </item>
        <item>
          <term>DDL_DRIVES</term>
          <description>包括驱动器，以[-x-]的形式列出，其中x是驱动器号。</description>
        </item>
        <item>
          <term>DDL_EXCLUSIVE</term>
          <description>仅包括具有指定属性的文件。 </description>
        </item>
        <item>
          <term></term>
          <description>
            <note type="tip">默认情况下，包括读写文件，即使没有指定 DDL_READWRITE。</note>
          </description>
        </item>
        <item>
          <term>DDL_HIDDEN</term>
          <description>包括隐藏文件。</description>
        </item>
        <item>
          <term>DDL_READONLY</term>
          <description>包括只读文件。</description>
        </item>
        <item>
          <term>DDL_READWRITE</term>
          <description>包括没有指定其他属性的读写文件。</description>
        </item>
        <item>
          <term>DDL_SYSTEM</term>
          <description>包括系统文件。</description>
        </item>
        <item>
          <term>DDL_POSTMSGS</term>
          <description>将消息发布到应用程序的消息队列。 </description>
        </item>
      </list>
    </remarks>
  </ListBox.ListFiles>

  <ListBox.Modified>
    <summary>
      一个逻辑值，对于列表框，设置为 FALSE，因为它不包含可以编辑的文本。
    </summary>
    <value>一个逻辑值，对于列表框，设置为 FALSE，因为它不包含可以编辑的文本。</value>
  </ListBox.Modified>

  <ListBox.MultiSelection>
    <summary>
      用于标识 ListBox 是否支持多选。
    </summary>
    <value>用于标识 ListBox 是否支持多选。</value>
  </ListBox.MultiSelection>

  <ListBox.NextSelected>
    <summary>
      在调用 ListBox:FirstSelected() 之后，用于在多选列表框中循环遍历剩余的选择的项目。
    </summary>
    <returns>
      列表框中下一个选择的项目的位置，如果没有选择任何项目或没有剩余的项目，则返回0。
    </returns>
    <remarks>
      此方法适用于多选列表框(即，使用 LBOXMULTIPLESEL 样式创建的列表框)。
    </remarks>
  </ListBox.NextSelected>

  <ListBox.SelectedCount>
    <summary> 
      一个数字值，表示当前在多选列表框中选择的项目的总数。 
      <note type="tip">
        此属性适用于多选列表框(即，使用 LBOXMULTIPLESEL 样式创建的列表框)。
      </note>
    </summary>
    <value>
      一个数字值，表示当前在多选列表框中选择的项目的总数。
      此属性适用于多选列表框(即，使用 LBOXMULTIPLESEL 样式创建的列表框)。
    </value>
  </ListBox.SelectedCount>

  <ListBox.SelectedFiles>
    <summary>
      表示先前由 ListFiles() 方法填充的列表框中选择的文件的字符串。
    </summary>
    <value>表示先前由 ListFiles() 方法填充的列表框中选择的文件的字符串。</value>
  </ListBox.SelectedFiles>

  <ListBox.SelectItem>
    <summary>
      打开列表框中项目的选择。
    </summary>
    <param name="nItemId">要选择的项目编号。零(0)表示当前项目。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      通常，用户会打开和关闭选择，但此方法也使程序能够这样做。
      此方法适用于多选列表框(即，使用 LBOXMULTIPLESEL 样式创建的列表框)。
    </remarks>
  </ListBox.SelectItem>

  <ListBox.SetTabs>
    <exclude />
  </ListBox.SetTabs>

  <ListBox.TextValue>
    <summary>
      一个字符串，表示当前选择的项目的显示值(第一个数组的元素)。
    </summary>
    <value>一个字符串，表示当前选择的项目的显示值(第一个数组的元素)。</value>
    <remarks>
      一个字符串，表示当前选择的项目的显示值(第一个数组的元素)，格式与附加到列表框(或组合框)的字段规范的图片子句相匹配。
      例如，ListBox:TextValue 可以是"Jones"，"01/15/95"或"8"。
      ListBox:TextValue 分配还会更改 ListBox:CurrentItem，ListBox:CurrentItemNo，ListBox:Modified，ListBox:Value 和 ListBox:ValueChanged。
      如果分配不匹配任何显示项目，则 ListBox:TextValue 和 ListBox:Value 将设置为无法匹配的文本，并且 ListBox:CurrentItemNo 将设置为0。
      如果控件绑定到服务器中的字段，并且字段数据值不匹配数组的第二个元素，则 ListBox:TextValue 和 ListBox:Value 包含字段的数据值。
    </remarks>
  </ListBox.TextValue>

  <ListBox.Value>
    <summary>
      一个值(FillUsing() 数组的第二个元素)表示当前选择的项目，格式与附加到列表框(或组合框)的字段规范的图片子句相匹配。
      例如，TextValue 可以是"Jones"，"01/15/95"或"8"。<br />
      如果没有选择项目并且列表框未绑定到服务器中的字段，则 ListBox:Value 设置为 NIL。<br />
      ListBox:Value 分配还会更改 ListBox:CurrentItem，ListBox:CurrentItemNo，ListBox:TextValue 和 ListBox:ValueChanged。<br />
      如果分配的文本不匹配任何返回值选项，则 ListBox:CurrentItemNo 将设置为0，并且 ListBox:TextValue 和 ListBox:Value 将设置为分配的文本。<br />
      在列表框中，ListBox:Value 通常是返回值之一，除非控件绑定到一个字段，实际内容不是允许的选择之一，并且存在无法匹配的情况；
      在这种情况下，ListBox:TextValue 和 ListBox:Value 将包含字段的数据值。<br />
      ListBox:Value 的数据类型由列表框的字段规范确定；反过来，链接到数据服务器的控件继承字段规范和数据类型，
      因此 ListBox:Value 能够自动从和向这个字段读取和写入，当控件通过将其名称设置为附加到数据窗口的服务器的字段的名称，使其成为数据感知时。
      <note type="tip">
        ListBox:Value 可能不总是与控件的状态一致，如向最终用户指示的那样。<br />
        例如，如果字段的数据值不是列表框返回值的允许选择之一，控件将处于"无法匹配"的情况。
        在这种情况下，列表框将恢复到其初始未选择的状态，ListBox:CurrentItemNo 设置为0。
      </note>
    </summary>
    <value>
      一个值(FillUsing() 数组的第二个元素)表示当前选择的项目，格式与附加到列表框(或组合框)的字段规范的图片子句相匹配。
      例如，TextValue 可以是"Jones"，"01/15/95"或"8"。<br />
      如果没有选择项目并且列表框未绑定到服务器中的字段，则 ListBox:Value 设置为 NIL。<br />
      ListBox:Value 分配还会更改 ListBox:CurrentItem，ListBox:CurrentItemNo，ListBox:TextValue 和 ListBox:ValueChanged。<br />
      如果分配的文本不匹配任何返回值选项，则 ListBox:CurrentItemNo 将设置为0，并且 ListBox:TextValue 和 ListBox:Value 将设置为分配的文本。<br />
      在列表框中，ListBox:Value 通常是返回值之一，除非控件绑定到一个字段，实际内容不是允许的选择之一，并且存在无法匹配的情况；
      在这种情况下，ListBox:TextValue 和 ListBox:Value 将包含字段的数据值。<br />
      ListBox:Value 的数据类型由列表框的字段规范确定；反过来，链接到数据服务器的控件继承字段规范和数据类型，
      因此 ListBox:Value 能够自动从和向这个字段读取和写入，当控件通过将其名称设置为附加到数据窗口的服务器的字段的名称，使其成为数据感知时。
      <note type="tip">
        ListBox:Value 可能不总是与控件的状态一致，如向最终用户指示的那样。<br />
        例如，如果字段的数据值不是列表框返回值的允许选择之一，控件将处于"无法匹配"的情况。
        在这种情况下，列表框将恢复到其初始未选择的状态，ListBox:CurrentItemNo 设置为0。
      </note>
    </value>
  </ListBox.Value>

  <ListBox.ValueChanged>
    <summary>
      一个逻辑值，表示在选择过程中，列表框的值是否已从先前选择的项目更改。<br />
      TRUE 表示它已从先前选择的项目更改，而 FALSE 表示它未从先前选择的项目更改。<br />
      列表框的值可能会通过单击不同的项目，或通过 ListBox:TextValue 或 ListBox:Value 分配而更改。
    </summary>
    <value>
      一个逻辑值，表示在选择过程中，列表框的值是否已从先前选择的项目更改。<br />
      TRUE 表示它已从先前选择的项目更改，而 FALSE 表示它未从先前选择的项目更改。<br />
      列表框的值可能会通过单击不同的项目，或通过 ListBox:TextValue 或 ListBox:Value 分配而更改。
    </value>
  </ListBox.ValueChanged>

  <ListView>
    <summary>
      创建一个列表视图控件。
      重要 - Microsoft 注意 - 在视觉样式下，网格线不总是正确显示。
    </summary>
    <remarks>
      列表视图是一个显示一系列列表视图项目的控件，每个项目由图像和文本标签组成。列表视图提供了几种排列项目和显示单个项目的方式。
    </remarks>
  </ListView>

  <ListView.ctor>
    <summary>
      构造一个列表视图。
    </summary>
    <param name="oOwner">拥有列表视图的窗口。</param>
    <param name="xID">列表视图的唯一ID(在1和8000之间)。</param>
    <param name="oPoint">列表视图在画布坐标中的原点。</param>
    <param name="oDimension">列表视图在画布坐标中的尺寸。</param>
    <param name="kStyle">列表视图的样式。</param>
    <param name="nResourceID">列表视图的资源ID。</param>
  </ListView.ctor>

  <ListView.AddColumn>
    <summary>
      在列表视图的列列表的末尾添加一个新的 ListViewColumn 对象。
    </summary>
    <param name="oListViewColumn">要添加到列表视图的 ListViewColumn 对象。</param>
    <returns>
      如果成功添加列，则为 TRUE；否则为 FALSE。
    </returns>
    <example>
      <code language="X#">
        SELF:oDClvPlayers:AddColumn(ListViewColumn{15, HyperLabel{ String2Symbol("cName" ), "Recipient"}})
      </code>
    </example>
  </ListView.AddColumn>

  <ListView.AddGroup>
    <summary>
      将图像设置为列表视图的背景。
    </summary>
    <param name="iGroupId">组的编号。</param>
    <param name="cGroupName">组的名称</param>
    <param name="dwAlign"> 
      组的对齐方式。可用的选项包括 - 
      <list type="table">
        <item>
          <term>LVGA_HEADER_LEFT</term>
          <description></description>
        </item>
        <item>
          <term>LVGA_HEADER_RIGHT</term>
          <description></description>
        </item>
        <item>
          <term>LVGA_HEADER_CENTER</term>
          <description></description>
        </item>
      </list>
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">
        列表视图分组需要视觉样式。<br />
        如果未启用或不可用视觉样式，这些功能将不起作用。<br />
        如果启用了组视图，只有属于组的项目才会显示。
      </note>
    </remarks>
  </ListView.AddGroup>

  <ListView.AddItem>
    <summary>
      在列表视图的最后添加一个新的 ListViewItem 对象。
    </summary>
    <param name="oListViewItem">要添加到列表视图的 ListViewItem 对象。</param>
    <returns>
      如果成功添加项目，则为 TRUE；否则为 FALSE。
    </returns>
    <example> 
      下面的示例显示了如何填充一个 ListView 控件。请注意，它还在每个项目中存储了记录编号，以便在选择任何给定项目时稍后检索： 
      <code language="X#">
        LOCAL cCoachName AS string
        LOCAL oItem AS ListViewItem

        DO WHILE !SELF:oCoachesServer:eof
            cCoachName := Trim( SELF:oCoachesServer:FIELDGET( #LastName ) ) + ", " + ;
                          Trim( SELF:oCoachesServer:FIELDGET( #FirstName ) ) + " " + ;
                          SELF:oCoachesServer:FIELDGET( #MiddleInit )
            oItem:SetText( SELF:oCoachesServer:FIELDGET( #Season ),     #cSeason )
            oItem:SetValue( SELF:oCoachesServer:RecNo,                  #cCoachName )
            oItem:SetText( CoachName,                                   #cCoachName )
            oItem:SetText( SELF:oCoachesServer:FIELDGET( #Gender ),     #cGender )
            oItem:SetText( SELF:oCoachesServer:FIELDGET( #ClubCode ),   #cClubCode )
            oItem:SetText( SELF:oCoachesServer:FIELDGET( #TeamNr ),     #cTeamNr )
            oItem:SetText( SELF:oCoachesServer:FIELDGET( #HomePhone ),  #cHomePhone )
            oItem:SetText( SELF:oCoachesServer:FIELDGET( #WorkPhone ),  #cWorkPhone )

            SELF:oDClvCoaches:AddItem( oItem )
            SELF:oCoachesServer:skip()
        ENDDO
      </code>
    </example>
  </ListView.AddItem>

  <ListView.Arrange>
    <summary>
      在图标视图中对齐列表视图项目。
    </summary>
    <param name="kAlignment">描述如何对齐列表视图项目的以下常量之一：</param>
    <returns>
      如果成功排列项目，则为 TRUE；否则为 FALSE。
    </returns>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>LVA_ALIGNLEFT</term>
          <description>将项目沿窗口的左边缘对齐。</description>
        </item>
        <item>
          <term>LVA_ALIGNTOP</term>
          <description>将项目沿窗口的顶边缘对齐。</description>
        </item>
        <item>
          <term>LVA_DEFAULT</term>
          <description>根据列表视图的当前对齐样式(默认设置)对齐项目。</description>
        </item>
        <item>
          <term>LVA_SNAPTOGRID</term>
          <description>项目将捕捉到最近的网格位置。</description>
        </item>
      </list>
    </remarks>
  </ListView.Arrange>

  <ListView.BackgroundColor>
    <summary>
      一个 Color 对象，用于在列表视图中绘制背景。
    </summary>
    <value>一个 Color 对象，用于在列表视图中绘制背景。</value>
  </ListView.BackgroundColor>

  <ListView.CheckBoxes>
    <summary>
      一个逻辑值，确定列表视图中是否使用复选框。
    </summary>
    <value>一个逻辑值，确定列表视图中是否使用复选框。</value>
  </ListView.CheckBoxes>

  <ListView.ColumnCount>
    <summary>
      一个数字值，表示列表视图中的列数。
    </summary>
    <value>一个数字值，表示列表视图中的列数。</value>
  </ListView.ColumnCount>

  <ListView.ColumnOrderArray>
    <summary>
      一个 ListViewColumn 对象符号名称的数组，表示列表视图中列的顺序。
    </summary>
    <value>一个 ListViewColumn 对象符号名称的数组，表示列表视图中列的顺序。</value>
  </ListView.ColumnOrderArray>

  <ListView.CurrentView>
    <summary>
      一个符号名称，表示列表视图的当前视图。
    </summary>
    <value>一个符号名称，表示列表视图的当前视图。</value>
    <remarks> 
      一个符号名称，表示列表视图的当前视图。以下是有效的视图： 
      <list type="bullet">
        <item>#IconView</item>
        <item>#SmallIconView</item>
        <item>#ListView</item>
        <item>#ReportView</item>
      </list>
    </remarks>
  </ListView.CurrentView>

  <ListView.DeleteAll>
    <summary>
      删除列表视图的所有项目。
    </summary>
    <returns>
      如果成功删除所有项目，则为 TRUE；否则为 FALSE。
    </returns>
  </ListView.DeleteAll>

  <ListView.DeleteAllColumns>
    <summary>
      从列表视图中删除所有列。
    </summary>
    <returns>
      如果成功删除所有项目，则为 TRUE；否则为 FALSE。
    </returns>
  </ListView.DeleteAllColumns>

  <ListView.DeleteColumn>
    <summary>
      从列表视图中删除一个 ListViewColumn 对象。
    </summary>
    <param name="oListViewColumn">要从列表视图中删除的 ListViewColumn 对象。</param>
    <returns>
      如果成功删除列，则为 TRUE；否则为 FALSE。
    </returns>
  </ListView.DeleteColumn>

  <ListView.DeleteItem>
    <summary>
      从列表视图中删除一个 ListViewItem 对象。
    </summary>
    <param name="nItem">要从列表视图中删除的 ListViewItem 对象的索引。</param>
    <returns>
      如果成功删除项目，则为 TRUE；否则为 FALSE。
    </returns>
  </ListView.DeleteItem>

  <ListView.Destroy>
    <inheritdoc />
  </ListView.Destroy>

  <ListView.DragDropEnabled>
    <summary>
      一个逻辑值，如果列表视图启用了拖放，则为 TRUE。如果启用了拖放，项目可以在控件内部和外部拖动。
    </summary>
    <value>一个逻辑值，如果列表视图启用了拖放，则为 TRUE。如果启用了拖放，项目可以在控件内部和外部拖动。</value>
  </ListView.DragDropEnabled>

  <ListView.DragImageList>
    <summary>
      一个 ImageList 对象，其中包含在列表视图的拖放操作期间显示的单个图像。
    </summary>
    <value>一个 ImageList 对象，其中包含在列表视图的拖放操作期间显示的单个图像。</value>
  </ListView.DragImageList>

  <ListView.EditItemLabel>
    <summary>
      开始在列表视图中的项目上编辑标签。
    </summary>
    <param name="nItem">要编辑其标签的 ListViewItem 对象的索引。</param>
  </ListView.EditItemLabel>

  <ListView.EnableDragDrop>
    <summary>
      启用或禁用列表视图的拖放功能。
    </summary>
    <param name="lEnable">TRUE 表示启用拖放，FALSE 表示禁用。默认值为 TRUE。</param>
    <returns>
      如果成功启用或禁用拖放，则为 TRUE；否则为 FALSE。
    </returns>
  </ListView.EnableDragDrop>

  <ListView.EnableGroupView>
    <summary>
      在 ListView 控件中启用或禁用分组视图。
    </summary>
    <param name="lSetting">逻辑值。TRUE 表示启用分组视图，FALSE 表示禁用。默认值为 TRUE。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">
        列表视图分组需要视觉样式。如果未启用或不可用视觉样式，这些功能将不起作用。
        如果启用分组视图，只有属于组的项目才会显示。
      </note>
    </remarks>
  </ListView.EnableGroupView>

  <ListView.EnableSort>
    <summary>
      注册一个用户定义的方法，用于在列表视图中对项目进行排序。
    </summary>
    <param name="symMethodName">
      要用于在列表视图中对项目进行排序的用户定义方法的符号名称。<br />
      调用此方法时，该方法接收两个 ListViewItem 对象作为参数。<br />
      该方法应确定哪个 ListView 项目应该在列表视图中排在前面。<br />
      如果第一个项目在第二个项目之前，该方法应返回-1；如果第二个项目在第一个项目之前，该方法应返回1；如果项目相等，该方法应返回0。
    </param>
    <returns>
      执行排序的用户定义方法的符号名称。
    </returns>
  </ListView.EnableSort>

  <ListView.EnsureVisible>
    <summary>
      确保列表视图中的项目可见，如果需要滚动。
    </summary>
    <param name="nItem">要使其可见的列表视图项目的索引。</param>
    <param name="lPartiallyVisible">TRUE表示指定的项目只能部分可见。如果要使项目完全可见，请指定 FALSE。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ListView.EnsureVisible>

  <ListView.FullRowSelect>
    <summary>
      一个逻辑值，确定在选择列表视图项目时是否高亮整行。
    </summary>
    <value>一个逻辑值，确定在选择列表视图项目时是否高亮整行。</value>
  </ListView.FullRowSelect>

  <ListView.GetAllItems>
    <summary>
      获取所有 Listview 项目的数组
    </summary>
    <returns>
      所有 Listview 项目的数组
    </returns>
  </ListView.GetAllItems>

  <ListView.GetAllSelectedItems>
    <summary>
      获取所有选定的 Listview 项目的数组
    </summary>
    <returns>
      所有选定的 Listview 项目的数组
    </returns>
  </ListView.GetAllSelectedItems>

  <ListView.GetColumn>
    <summary>
      返回特定的 ListViewColumn 对象。
    </summary>
    <param name="xColumnID">
      列表视图中的列表视图列的数字位置。列从左到右编号，
      或列表视图列的符号名称。
    </param>
    <returns>
      ListViewColumn 对象。
    </returns>
  </ListView.GetColumn>

  <ListView.GetExLVStyle>
    <exclude />
  </ListView.GetExLVStyle>

  <ListView.GetExStyle>
    <summary>
      一个逻辑值，确定是否启用或禁用指定的扩展列表视图样式。
    </summary>
    <param name="kExStyle">要查询的扩展列表视图样式。 (请参阅 Microsoft Win32 软件开发工具包文档，了解有效常量的列表。)</param>
    <returns>
      TRUE，如果设置了扩展 ListView 样式；否则，FALSE。
    </returns>
  </ListView.GetExStyle>

  <ListView.GetGroupTextColor>
    <summary>
      获取在显示 ListView 控件时用于标题的文本颜色。
    </summary>
    <returns>
      颜色对象。
    </returns>
    <remarks>
      <note type="tip">
        列表视图分组需要视觉样式。如果未启用或不可用视觉样式，这些功能将不起作用。
        如果启用分组视图，只有属于组的项目才会显示。
      </note>
    </remarks>
  </ListView.GetGroupTextColor>

  <ListView.GetItemAtPosition>
    <summary>
      返回特定位置的 ListViewItem 对象，如果存在的话。
    </summary>
    <param name="oPoint">要查找列表视图项目的点。</param>
    <returns>
      指定点处的 ListViewItem 对象。
    </returns>
  </ListView.GetItemAtPosition>

  <ListView.GetItemAttributes>
    <summary>
      根据其项目索引返回一个 ListViewItem 对象。
    </summary>
    <param name="nItem">要返回的列表视图项目的索引。</param>
    <returns>
      由项目索引指定的 ListViewItem 对象。
    </returns>
    <example>
      <code language="X#">
        nCount := SELF:oDClvClaims:ItemCount

        FOR x := 1 UPTO nCount
            oLVI := SELF:oDClvClaims:GetItemAttributes(x)

            IF oLVI != NULL_OBJECT
                IF oLVI:Checked // 使用设置为YES的ListView的"checkbox"属性
                    nValue := oLVI:GetValue( #dSvcDate )
                    SELF:oBillingsServer:GoTo( nValue )
                    // 在这里进行一些处理
                    DO CASE
                        CASE cClaims == "P"
                            oLVI:StateImageIndex := 1 // ImageList在PostInit()方法中预定义
                        CASE cClaims == "X"
                            oLVI:StateImageIndex := 2
                        CASE cClaims == "S"
                            oLVI:StateImageIndex := 6
                    ENDCASE

                    SELF:oDClvClaims:SetItemAttributes(oLVI)
                ENDIF
            ENDIF
        NEXT x
      </code>
    </example>
  </ListView.GetItemAttributes>

  <ListView.GetItemBoundingBox>
    <summary>
      返回其项目索引的 ListViewItem 对象的边界框。
    </summary>
    <param name="nItem">要获取其边界框的列表视图项目的索引。</param>
    <returns>
      由项目索引指定的 ListViewItem 对象的边界框。
    </returns>
  </ListView.GetItemBoundingBox>

  <ListView.GetItemPosition>
    <summary>
      返回其项目索引的 ListViewItem 对象的原点。
    </summary>
    <param name="nItem">要获取其原点的列表视图项目的索引。</param>
    <returns>
      由项目索引指定的列表视图项目的原点。
    </returns>
  </ListView.GetItemPosition>

  <ListView.GetItemSpacing>
    <summary>
      返回图标视图或小图标视图中列表视图项目之间的间距。
    </summary>
    <param name="symView">要获取其间距的视图的符号名称。此值可以是 #IconView 或 #SmallIconView。如果省略，将报告图标视图的间距。</param>
    <returns>
      项目之间的间距量。
    </returns>
  </ListView.GetItemSpacing>

  <ListView.GetNextItem>
    <summary>
      检索具有所有指定属性的下一个列表视图项目。
    </summary>
    <param name="kRelationship">描述与指定项目的物理关系的以下常量之一。请参见下表，了解可能的值</param>
    <param name="lDisabled">TRUE 表示列表视图项目的图像应禁用。如果省略，将使用默认值FALSE。</param>
    <param name="lDropTarget">TRUE 表示列表视图项目应为拖放目标。如果省略，将使用默认值FALSE。</param>
    <param name="lFocused">TRUE 表示列表视图项目应为焦点。如果省略，将使用默认值FALSE。</param>
    <param name="lSelected">TRUE 表示列表视图项目应为选定。如果省略，将使用默认值FALSE。</param>
    <param name="nItemStart">开始搜索的项目的索引。如果省略，将从开头开始搜索。</param>
    <returns>
      作为搜索结果返回的列表视图项目。
    </returns>
    <remarks>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>LV_GNIABOVE</term>
          <description>搜索位于指定项目上方的项目</description>
        </item>
        <item>
          <term>LV_GNIBELOW</term>
          <description>搜索位于指定项目下方的项目</description>
        </item>
        <item>
          <term>LV_GNIBYITEM</term>
          <description>按索引搜索后续项目 (默认值)</description>
        </item>
        <item>
          <term>LV_GNILEFT</term>
          <description>搜索位于指定项目左侧的项目</description>
        </item>
        <item>
          <term>LV_GNIRIGHT</term>
          <description>搜索位于指定项目右侧的项目</description>
        </item>
      </list>
    </remarks>
    <example> 
      下面的示例显示了如何遍历 ListView 中的所有项目以进行进一步处理。请注意，GetNextItem() 方法的最后一个参数是从零开始的： 
      <code language="X#">
        LOCAL oLVI AS ListViewItem
        nCount := SELF:oDClvPlayers:ItemCount

        FOR x := 1 UPTO nCount
            oLVI    := SELF:oDClvPlayers:GetNextItem( LV_GNIBYITEM,,,,,x-1 )
            cID     := AllTrim( oLVI:GetText( #cPlayerID ) )
            nRecNo  := oLVI:GetValue( #cPlayerID )
        NEXT x
      </code>
    </example>
  </ListView.GetNextItem>

  <ListView.GetSelectedColumn>
    <exclude />
  </ListView.GetSelectedColumn>

  <ListView.GetSelectedItem>
    <summary>
      检索当前选定的 ListViewItem 对象。
    </summary>
    <returns>
      当前选定的 ListViewItem 对象。
    </returns>
  </ListView.GetSelectedItem>

  <ListView.GridLines>
    <summary>
      一个逻辑值，确定列表视图中是否显示网格线。
    </summary>
    <value>一个逻辑值，确定列表视图中是否显示网格线。</value>
    <remarks>
      一个逻辑值，确定列表视图中是否显示网格线。<br />
      重要 - Microsoft注意 - 在视觉样式下，网格线不总是正确显示。
      有关更多信息，请参见http://support.microsoft.com/default.aspx?scid=kb;en-us;813791。
    </remarks>
  </ListView.GridLines>

  <ListView.HasGroup>
    <summary>
      一个逻辑值，确定指定ID的组是否存在于 ListView 控件中。
    </summary>
    <param name="iGroupId">组的编号。</param>
    <returns>
      如果存在，返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      <note type="tip">
        列表视图分组需要视觉样式。如果未启用或不可用视觉样式，这些功能将不起作用。
        如果启用分组视图，只有属于组的项目才会显示。
      </note>
    </remarks>
  </ListView.HasGroup>

  <ListView.HeaderDragDrop>
    <summary>
      一个逻辑值，确定是否可以通过拖放列标题在列表视图中重新排列列。
    </summary>
    <value>一个逻辑值，确定是否可以通过拖放列标题在列表视图中重新排列列。</value>
  </ListView.HeaderDragDrop>

  <ListView.InsertColumn>
    <summary>
      在列表视图中的特定列索引后插入一个新的 ListViewColumn 对象。
    </summary>
    <param name="oListViewColumn">要在列表视图中插入的 ListViewColumn 对象。</param>
    <param name="nInsertAfter">要在其后插入新列的位置。如果省略，新列将添加到列列表的末尾。</param>
    <returns>
      如果成功插入列，则为 TRUE；否则为 FALSE。
    </returns>
  </ListView.InsertColumn>

  <ListView.InsertItem>
    <summary>
      在列表视图中的特定项目索引后插入一个新的 ListViewItem 对象。
    </summary>
    <param name="oListViewItem">要在列表视图中插入的 ListViewItem 对象。</param>
    <param name="nInsertAfter">要在其后插入新项目的位置。如果省略，新项目将添加为最后一个项目。</param>
    <returns>
      如果成功插入项目，则为 TRUE；否则为 FALSE。
    </returns>
  </ListView.InsertItem>

  <ListView.IsGroupViewEnabled>
    <summary>
      一个逻辑值，确定是否启用了 ListView 分组。
    </summary>
    <value>一个逻辑值，确定是否启用了 ListView 分组。</value>
    <remarks> 
      一个逻辑值，确定是否启用了 ListView 分组。 
      <note type="tip">
        列表视图分组需要视觉样式。如果未启用或不可用视觉样式，这些功能将不起作用。
        如果启用分组视图，只有属于组的项目才会显示。
      </note>
    </remarks>
  </ListView.IsGroupViewEnabled>

  <ListView.ItemCount>
    <summary>
      一个数字值，表示列表视图中的项目数量。
    </summary>
    <value>一个数字值，表示列表视图中的项目数量。</value>
  </ListView.ItemCount>

  <ListView.ItemsPerPage>
    <summary>
      一个数字值，表示可以在列表视图的可见区域中垂直容纳的项目数量。
    </summary>
    <value>一个数字值，表示可以在列表视图的可见区域中垂直容纳的项目数量。</value>
  </ListView.ItemsPerPage>

  <ListView.LargeImageList>
    <summary>
      一个包含大图像的图像列表，用于在图标视图中显示列表视图的每个项目。
    </summary>
    <value>一个包含大图像的图像列表，用于在图标视图中显示列表视图的每个项目。</value>
    <example> 
      这个例子通常会出现在窗口的PostInit()方法中。
      在下面的例子中，当ListView被填充时，每个项目都将被分配一个图像索引，这取决于所讨论的播放器是否活动。 
      <code language="X#">
        LOCAL oImageList AS ImageList

        oImageList := ImageList{2, Dimension{32, 32}}

        oImageList:Add(SmIconCheck{})
        oImageList:Add(SmIconCross{})

        SELF:oDClvPlayers:LargeImageList := oImageList
      </code>
    </example>
  </ListView.LargeImageList>

  <ListView.RedrawRange>
    <summary>
      重绘列表视图项目的范围。
    </summary>
    <param name="oRange">要重绘的列表视图项目索引的范围。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ListView.RedrawRange>

  <ListView.RemoveAllGroups>
    <summary>
      从 ListView 控件中删除所有分组。
    </summary>
    <remarks>
      <note type="tip">
        列表视图分组需要视觉样式。如果未启用或不可用视觉样式，这些功能将不起作用。
        如果启用分组视图，只有属于组的项目才会显示。
      </note>
    </remarks>
  </ListView.RemoveAllGroups>

  <ListView.RemoveGroup>
    <summary>
      从 ListView 控件中删除具有指定ID的分组。
    </summary>
    <param name="iGroupId">分组的编号。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">
        列表视图分组需要视觉样式。如果未启用或不可用视觉样式，这些功能将不起作用。
        如果启用分组视图，只有属于组的项目才会显示。
      </note>
    </remarks>
  </ListView.RemoveGroup>

  <ListView.Scroll>
    <summary>
      滚动列表视图的内容。
    </summary>
    <param name="oDimension">表示要滚动列表视图的量的维度。正宽度值向右滚动，负宽度值向左滚动。此外，正高度值向上滚动，负高度值向下滚动。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ListView.Scroll>

  <ListView.SearchString>
    <summary>
      与列表视图关联的增量搜索字符串。
    </summary>
    <value>与列表视图关联的增量搜索字符串。</value>
    <remarks>
      与列表视图关联的增量搜索字符串。
      增量搜索字符串是用户在列表视图具有输入焦点时键入的字符序列。当用户键入一个字符时，该字符将附加到搜索字符串，并寻找匹配的项目。
      如果系统找到匹配项，它将选择该项目。搜索字符串有一个超时期；如果用户在超时期过去之前键入另一个字符，字符串将被重置。
    </remarks>
  </ListView.SearchString>

  <ListView.Seek>
    <summary>
      在列表视图中搜索特定的列表视图项目。
    </summary>
    <param name="uValue"> 要搜索的值。 <paramref name="kSeekType" /> 必须是 LV_SEEKVALUE。 </param>
    <param name="cText"> 要搜索的字符串。 <paramref name="kSeekType" /> 必须是 LV_SEEKTEXT。 </param>
    <param name="oPoint"> 搜索开始的列表视图客户区中的点。该点的最近的列表视图项目将在由 <paramref name="kSeekType" /> 指定的方向中返回。 </param>
    <param name="kSeekType">
      一个常量，指定要执行的搜索类型。LV_SEEKVALUE 导致对常规值的搜索。LV_SEEKTEXT 导致对文本字符串的搜索。
      如果搜索是在 Point 对象上，此参数可以是 LV_SEEKUP 或 LV_SEEKDOWN，以指定在相应方向中搜索。
      在这种情况下，如果省略了参数，将假定为 LV_SEEKDOWN。
    </param>
    <param name="nStart">要开始搜索的列表视图项目的索引。如果省略，搜索将从第一个项目开始。</param>
    <param name="lWrap">TRUE的值在找不到匹配项时在第一个列表视图项目处继续搜索。如果省略，将使用默认值 FALSE，该值禁用包装。</param>
    <param name="lPartial"> 
      TRUE的值如果列表视图项目标签以 <paramref name="cText" /> 开头，则产生一个匹配项。<br />
      如果省略，将使用默认值 FALSE，该值禁用部分搜索。 
    </param>
    <returns>
      作为搜索结果返回的列表视图项目。
    </returns>
  </ListView.Seek>

  <ListView.SelectedCount>
    <summary>
      一个数字值，表示在列表视图中选择的项目数量。
    </summary>
    <value>一个数字值，表示在列表视图中选择的项目数量。</value>
  </ListView.SelectedCount>

  <ListView.SelectItem>
    <summary>
      在列表视图中选择或取消选择特定的项目。
    </summary>
    <param name="nItem">要在列表视图中选择或取消选择的列表视图项目的索引。</param>
    <param name="lSelect">在列表视图中选择(TRUE)或取消选择(FALSE)项目。默认设置为TRUE。</param>
    <returns>
      如果选择了列表视图项目，则为 TRUE；否则为 FALSE。
    </returns>
  </ListView.SelectItem>

  <ListView.SelectNextItem>
    <summary>
      选择当前选择项目后的下一个列表视图项目。
    </summary>
    <returns>
      如果选择成功，则为 TRUE；否则为 FALSE。
    </returns>
  </ListView.SelectNextItem>
  
  <ListView.SetBackgroundImage>
    <summary>
      将图像设置为列表视图的背景。
    </summary>
    <param name="uImage">
      要在列表视图的背景中使用的图像。可以是以下四种类型之一。<br />
      Object  一个BitMap对象<br />
      PTR     一个图像句柄<br />
      String  一个URL或文件名作为字符串<br />
      NIL     如果要删除背景
    </param>
    <param name="dwFlags">
      可以设置的标志以创建所需的样式。可以通过将它们与_Or()组合来使用多个样式<br />
      _Or( LVBKIF_SOURCE_HBITMAP, LVBKIF_STYLE_TILE )<br />
      _Or( LVBKIF_SOURCE_URL, LVBKIF_STYLE_TILE )
    </param>
    <param name="xOffSet">控制图像的x放置。</param>
    <param name="yOffSet">控制图像的y放置。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">
        使用此方法需要链接 OLE 库或调用 CoInitialize()。<br />
        如果调用了 CoInitialize()，它还需要稍后调用 CoUnitialize()。
      </note>
    </remarks>
  </ListView.SetBackgroundImage>

  <ListView.SetColumnFormat>
    <summary>
      为列表视图设置所需的扩展样式。
    </summary>
    <param name="nCol">列的索引号。</param>
    <param name="dwFlag">
      可以设置的标志以创建所需的样式。可以通过将它们与_Or()组合来使用多个样式<br />
      可用的样式有 -<br />
      HDF_CENTER          将列对齐到中心。<br />
      HDF_LEFT            将列对齐到左侧。这是默认设置。<br />
      HDF_RIGHT           将列对齐到右侧。<br />
      HDF_BITMAP          在列头的左侧添加一个位图。<br />
      HDF_BITMAP_ON_RIGHT 在列头的右侧添加一个位图。<br />
      HDF_SORTDOWN        在标题中显示向下的箭头 - 仅适用于视觉主题<br />
      HDF_SORTUP          在标题中显示向上的箭头 - 仅适用于视觉主题
    </param>
    <param name="nImage">
      在列头中显示的图像列表中的图像的编号。默认值为无图像。
    </param>
    <returns>
      如果启用了样式，则为 TRUE；否则为 FALSE。
    </returns>
  </ListView.SetColumnFormat>

  <ListView.SetExLVStyle>
    <exclude />
  </ListView.SetExLVStyle>

  <ListView.SetExStyle>
    <summary>
      为列表视图设置所需的扩展样式。
    </summary>
    <param name="kExStyle">要设置的扩展列表视图样式。 (请参阅 Microsoft Win32 软件开发工具包文档，了解有效常量的列表。)</param>
    <param name="lNewVal">一个逻辑值，确定是否应启用(TRUE)或禁用(FALSE)指定的扩展样式。</param>
    <returns>
      如果启用了扩展样式，则为 TRUE；否则为 FALSE。
    </returns>
  </ListView.SetExStyle>

  <ListView.SetGroupName>
    <summary>
      设置列表视图组的名称。
    </summary>
    <param name="iGroupId">组的编号。</param>
    <param name="cGroupName">组的名称</param>
    <param name="dwAlign">
      组的对齐方式。<br />
      可用的选项有 -<br />
      LVGA_HEADER_LEFT<br />
      LVGA_HEADER_RIGHT<br />
      LVGA_HEADER_CENTER<br />
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">
        列表视图分组需要视觉样式。如果未启用或不可用视觉样式，这些功能将不起作用。
        如果启用分组视图，只有属于组的项目才会显示。
      </note>
    </remarks>
  </ListView.SetGroupName>

  <ListView.SetGroupTextColor>
    <summary>
      设置在按组显示 ListView 控件时用于标题的文本颜色。
    </summary>
    <param name="oColor">所需的颜色对象。</param>
    <remarks>
      <note type="tip">
        列表视图分组需要视觉样式。如果未启用或不可用视觉样式，这些功能将不起作用。
        如果启用分组视图，只有属于组的项目才会显示。
      </note>
    </remarks>
  </ListView.SetGroupTextColor>

  <ListView.SetItemAttributes>
    <summary>
      使用新属性更新 ListViewItem 对象。
    </summary>
    <param name="oListViewItem">要更改其属性的 ListViewItem 对象。</param>
    <example>
      <code language="X#">
        nCount := SELF:oDClvClaims:ItemCount

        FOR x := 1 UPTO nCount
            oLVI := SELF:oDClvClaims:GetItemAttributes(x)

            IF oLVI != NULL_OBJECT
                IF oLVI:Checked // 使用ListView的"checkbox"属性设置为YES
                    nValue := oLVI:GetValue( #dSvcDate )
                    SELF:oBillingsServer:GoTo( nValue )
                    // 在这里进行一些处理
                    DO CASE
                        CASE cClaims == "P"
                            oLVI:StateImageIndex := 1 // ImageList在PostInit()方法中预定义
                        CASE cClaims == "X"
                            oLVI:StateImageIndex := 2
                        CASE cClaims == "S"
                            oLVI:StateImageIndex := 3
                    ENDCASE

                    SELF:oDClvClaims:SetItemAttributes(oLVI)
                ENDIF
            ENDIF
        NEXT x
      </code>
    </example>
  </ListView.SetItemAttributes>

  <ListView.SetItemGroupId>
    <summary>
      一个逻辑值，确定具有指定ID的组是否存在于 ListView 控件中。
    </summary>
    <param name="uLVI">项目索引或 ListViewItem。</param>
    <param name="nId">组的编号。</param>
    <remarks>
      <note type="tip">
        列表视图分组需要视觉样式。如果未启用或不可用视觉样式，这些功能将不起作用。
        如果启用分组视图，只有属于组的项目才会显示。
      </note>
    </remarks>
  </ListView.SetItemGroupId>

  <ListView.SetItemPosition>
    <summary>
      将列表视图项目移动到图标视图或小图标视图中的新位置。
    </summary>
    <param name="nItem">要更改其位置的列表视图项目的索引。</param>
    <param name="oPoint">列表视图项目的新位置。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ListView.SetItemPosition>

  <ListView.SetSelectedColumn>
    <summary>
      将列显示为选定。
    </summary>
    <param name="nIndex">列的索引号。</param>
  </ListView.SetSelectedColumn>

  <ListView.SmallImageList>
    <summary>
      一个包含小图像的图像列表，用于在列表视图、报表视图或小图标视图中显示列表视图的每个项目。此列表中的图标必须在其他地方定义
    </summary>
    <value>一个包含小图像的图像列表，用于在列表视图、报表视图或小图标视图中显示列表视图的每个项目。此列表中的图标必须在其他地方定义</value>
    <example> 
      这个例子通常会出现在窗口的 PostInit() 方法中。
      在下面的例子中，当 ListView 被填充时，每个项目都将被分配一个图像索引，这取决于所讨论的播放器是否活动。 
      <code language="X#">
        LOCAL oImageList AS ImageList

        oImageList := ImageList{2, Dimension{16, 16}}

        oImageList:Add(SmIconCheck{})
        oImageList:Add(SmIconCross{})

        SELF:oDClvPlayers:SmallImageList := oImageList
      </code>
    </example>
  </ListView.SmallImageList>

  <ListView.SortItems>
    <summary>
      使用 EnableSort() 指定的用户定义排序方法对列表视图项目进行排序。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ListView.SortItems>

  <ListView.StateImageList>
    <summary>
      一个包含状态图像的图像列表，用于在列表视图的每个项目中显示。
    </summary>
    <value>一个包含状态图像的图像列表，用于在列表视图的每个项目中显示。</value>
  </ListView.StateImageList>

  <ListView.TextBackgroundColor>
    <summary>
      一个 Color 对象，用于在列表视图中绘制文本背景。
    </summary>
    <value>一个 Color 对象，用于在列表视图中绘制文本背景。</value>
  </ListView.TextBackgroundColor>

  <ListView.TextColor>
    <summary>
      一个 Color 对象，用于在列表视图中绘制文本。
    </summary>
    <value>一个 Color 对象，用于在列表视图中绘制文本。</value>
  </ListView.TextColor>

  <ListView.TopItem>
    <summary>
      一个数字值，表示列表视图或报表视图中顶部可见项目的索引。
    </summary>
    <value>一个数字值，表示列表视图或报表视图中顶部可见项目的索引。</value>
  </ListView.TopItem>

  <ListView.TrackSelection>
    <exclude />
  </ListView.TrackSelection>

  <ListView.Update>
    <summary>
      更新列表视图项目。
    </summary>
    <param name="nItem">要更新其位置的列表视图项目的索引。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ListView.Update>

  <ListView.ViewAs>
    <summary>
      更改列表视图的当前视图。
    </summary>
    <param name="symView">列表视图的新视图的符号名称。可以是以下值之一：</param>
  </ListView.ViewAs>

  <ListView.ViewBoundingBox>
    <summary>
      当在图标视图或小图标视图中时，包围列表视图所有项目的边界框。
    </summary>
    <value>当在图标视图或小图标视图中时，包围列表视图所有项目的边界框。</value>
  </ListView.ViewBoundingBox>

  <ListView.ViewOrigin>
    <summary>
      表示列表视图当前视图原点的 Point 对象，当在图标视图或小图标视图中时。
    </summary>
    <value>表示列表视图当前视图原点的 Point 对象，当在图标视图或小图标视图中时。</value>
  </ListView.ViewOrigin>

  <ListView_CompareDelegate.ctor>
    <exclude />
  </ListView_CompareDelegate.ctor>

  <ListView_CompareDelegate.BeginInvoke>
    <exclude />
  </ListView_CompareDelegate.BeginInvoke>

  <ListView_CompareDelegate.EndInvoke>
    <exclude />
  </ListView_CompareDelegate.EndInvoke>

  <ListView_CompareDelegate.Invoke>
    <exclude />
  </ListView_CompareDelegate.Invoke>

  <ListViewColumn>
    <summary>
      创建一个列表视图列。
    </summary>
    <remarks>
      列表视图列是添加到列表视图控件的对象。虽然列表视图控件不一定要在列或报表视图中显示，但至少必须添加一个列才能向控件添加项目。
    </remarks>
  </ListViewColumn>

  <ListViewColumn.ctor>
    <summary>
      构造一个列表视图列。
    </summary>
    <param name="nWidth">列表视图列的字符宽度。如果省略，宽度为16个字符。</param>
    <param name="xColumnID">列的 HyperLabel 对象或列的符号或字符串名称。</param>
    <param name="kAlignment">可选的常量，表示列表视图列的对齐方式。如果省略，将默认为左对齐。</param>
    <remarks>
      有效的常量是：<br />
      LVCFMT_RIGHT<br />
      LVCFMT_CENTER<br />
      LVCFMT_LEFT<br />
    </remarks>
  </ListViewColumn.ctor>

  <ListViewColumn.Alignment>
    <summary>
      表示列表视图列的对齐方式的常量。可以使用以下值之一：<br />
      LVCFMT_LEFT<br />
      LVCFMT_CENTER<br />
      LVCFMT_RIGHT
    </summary>
    <value>
      表示列表视图列的对齐方式的常量。可以使用以下值之一：<br />
      LVCFMT_LEFT<br />
      LVCFMT_CENTER<br />
      LVCFMT_RIGHT<br />
    </value>
  </ListViewColumn.Alignment>

  <ListViewColumn.Caption>
    <summary>
      在列表视图列标题中显示的标题。
    </summary>
    <value>在列表视图列标题中显示的标题。</value>
  </ListViewColumn.Caption>

  <ListViewColumn.Destroy>
    <inheritdoc />
  </ListViewColumn.Destroy>

  <ListViewColumn.FieldSpec>
    <summary>
      列表视图列的 FieldSpec 对象。
    </summary>
    <value>列表视图列的 FieldSpec 对象。</value>
  </ListViewColumn.FieldSpec>

  <ListViewColumn.GetPixWidth>
    <exclude />
  </ListViewColumn.GetPixWidth>

  <ListViewColumn.HyperLabel>
    <summary>
      列表视图列的 HyperLabel 对象。
    </summary>
    <value>列表视图列的 HyperLabel 对象。</value>
  </ListViewColumn.HyperLabel>

  <ListViewColumn.NameSym>
    <summary>
      列表视图列的符号名称。
    </summary>
    <value>列表视图列的符号名称。</value>
  </ListViewColumn.NameSym>

  <ListViewColumn.Owner>
    <exclude />
  </ListViewColumn.Owner>

  <ListViewColumn.SetPixWidth>
  </ListViewColumn.SetPixWidth>

  <ListViewColumn.Width>
    <summary>
      表示列表视图列的字符宽度的数字值。
    </summary>
    <value>表示列表视图列的字符宽度的数字值。</value>
    <remarks>
      <para>对于自动调整大小，可以使用以下值之一：</para>
      <list type="table">
        <item>
          <term>LVCSW_AUTOSIZE</term>
          <description>列表视图列自动调整为具有最大宽度的条目(-1)。</description>
        </item>
        <item>
          <term>LVCSW_AUTOSIZE_HEADER</term>
          <description>列表视图列自动调整为其标题的宽度(-2)。</description>
        </item>
      </list>
    </remarks>
  </ListViewColumn.Width>

  <ListViewColumnClickEvent>
    <summary>
      提供有关列表视图列单击事件的信息，该事件在列表视图控件的列标题被单击时生成。
    </summary>
    <remarks>
      只有在报表视图中，列标题才会显示，列表视图控件才会生成此事件。<br />
      此事件返回被单击的 ListViewColumn 对象。在响应此事件时，常见的操作是对列中的项目进行排序。
    </remarks>
  </ListViewColumnClickEvent>

  <ListViewColumnClickEvent.ctor>
    <inheritdoc />
  </ListViewColumnClickEvent.ctor>

  <ListViewColumnClickEvent.ListViewColumn>
    <summary>
      被单击其标题的 ListViewColumn 对象。
    </summary>
    <value>被单击其标题的 ListViewColumn 对象。</value>
  </ListViewColumnClickEvent.ListViewColumn>

  <ListViewDeleteEvent>
    <summary>
      提供有关列表视图删除事件的信息，该事件在列表视图控件的项目被删除时生成。
    </summary>
    <remarks>
      每当列表视图控件的项目被删除时，列表视图控件都会生成此事件。<br />
      此 Event 对象打包的信息包括哪个项目被删除，以便应用程序可以处理存储在 ListViewItem 对象中的任何信息。
    </remarks>
  </ListViewDeleteEvent>

  <ListViewDeleteEvent.ctor>
    <inheritdoc />
  </ListViewDeleteEvent.ctor>

  <ListViewDeleteEvent.ListViewItem>
    <summary>
      被删除的 ListViewItem 对象。
    </summary>
    <value>被删除的 ListViewItem 对象。</value>
  </ListViewDeleteEvent.ListViewItem>

  <ListViewDragEvent>
    <summary>
      提供有关列表视图拖动事件的信息，该事件在列表视图控件的项目被拖动时生成。
    </summary>
    <remarks>
      每当列表视图控件的项目被拖动时，列表视图控件都会生成此事件。<br />
      用户可以使用鼠标的右键或左键生成事件，并根据当前使用的鼠标按钮采取不同的行动。
    </remarks>
  </ListViewDragEvent>

  <ListViewDragEvent.ctor>
    <inheritdoc />
  </ListViewDragEvent.ctor>

  <ListViewDragEvent.IsLeftButton>
    <summary>
      一个逻辑值，如果这是左键拖动，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果这是左键拖动，则为 TRUE。</value>
  </ListViewDragEvent.IsLeftButton>

  <ListViewDragEvent.IsRightButton>
    <summary>
      一个逻辑值，如果这是右键拖动，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果这是右键拖动，则为 TRUE。</value>
  </ListViewDragEvent.IsRightButton>

  <ListViewDragEvent.ListViewItem>
    <summary>
      正在被拖动的 ListViewItem 对象。
    </summary>
    <value>正在被拖动的 ListViewItem 对象。</value>
  </ListViewDragEvent.ListViewItem>

  <ListViewDragEvent.Position>
    <summary>
      一个 Point 对象，描述列表视图控件坐标中拖动的初始位置。
    </summary>
    <value>一个 Point 对象，描述列表视图控件坐标中拖动的初始位置。</value>
  </ListViewDragEvent.Position>

  <ListViewEditEvent>
    <summary>
      提供有关列表视图编辑事件的信息，该事件在列表视图控件的项目标签被编辑时生成。
    </summary>
    <remarks>
      每当列表视图控件的项目标签被编辑时，列表视图控件都会生成此事件。<br />
      实际上，对于任何编辑操作，此事件都会生成两次：一次在编辑开始时，一次在编辑结束时。<br />
      此对象的属性可以确定编辑是开始还是结束。
    </remarks>
  </ListViewEditEvent>

  <ListViewEditEvent.ctor>
    <inheritdoc />
  </ListViewEditEvent.ctor>

  <ListViewEditEvent.EditBeginning>
    <summary>
      一个逻辑值，如果编辑开始，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果编辑开始，则为 TRUE。</value>
  </ListViewEditEvent.EditBeginning>

  <ListViewEditEvent.EditEnding>
    <summary>
      一个逻辑值，如果编辑结束，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果编辑结束，则为 TRUE。</value>
  </ListViewEditEvent.EditEnding>

  <ListViewEditEvent.EditText>
    <summary>
      包含列表视图项目的新标签文本的字符串值，该项目的标签在编辑后被编辑。
    </summary>
    <value>包含列表视图项目的新标签文本的字符串值，该项目的标签在编辑后被编辑。</value>
  </ListViewEditEvent.EditText>

  <ListViewEditEvent.ListViewItem>
    <summary>
      正在被编辑的 ListViewItem 对象。
    </summary>
    <value>正在被编辑的 ListViewItem 对象。</value>
  </ListViewEditEvent.ListViewItem>

  <ListViewItem>
    <summary>
      创建一个列表视图项目。
    </summary>
    <remarks>
      列表视图项目描述列表视图控件中的项目。
    </remarks>
  </ListViewItem>

  <ListViewItem.ctor>
    <summary>
      构造一个列表视图项目。
    </summary>
  </ListViewItem.ctor>

  <ListViewItem.Checked>
    <exclude />
  </ListViewItem.Checked>

  <ListViewItem.Destroy>
    <exclude />
  </ListViewItem.Destroy>

  <ListViewItem.Disabled>
    <summary>
      一个逻辑值，如果列表视图项目的图像以禁用方式显示，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果列表视图项目的图像以禁用方式显示，则为 TRUE。</value>
  </ListViewItem.Disabled>

  <ListViewItem.DropTarget>
    <summary>
      一个逻辑值，如果列表视图项目被突出显示为拖放操作的目标，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果列表视图项目被突出显示为拖放操作的目标，则为 TRUE。</value>
  </ListViewItem.DropTarget>

  <ListViewItem.Focused>
    <summary>
      一个逻辑值，如果列表视图项目被聚焦，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果列表视图项目被聚焦，则为 TRUE。</value>
  </ListViewItem.Focused>

  <ListViewItem.GetText>
    <summary>
      检索列的文本标签。
    </summary>
    <param name="symColumnName">要检索其文本的列的符号名称。</param>
    <param name="nRefImageIndex">如果这是对数值变量的引用，则获取此列的图像索引。</param>
    <returns>
      指定列的文本标签。
    </returns>
    <example>
      <code language="X#">
        oLVI := SELF:oDClvClaims:GetItemAttributes( nItemNr )

        IF oLVI != NULL_OBJECT
            cCity := oLVI:GetText( #cCity )
        ENDIF
      </code>
    </example>
  </ListViewItem.GetText>

  <ListViewItem.GetValue>
    <summary>
      检索列的值。
    </summary>
    <param name="symColumnName">要检索其值的列的符号名称。</param>
    <returns>
      指定列的值。
    </returns>
    <example>
      <code language="X#">
        nCount := SELF:oDClvClaims:ItemCount

        FOR x := 1 UPTO nCount
            oLVI := SELF:oDClvClaims:GetItemAttributes(x)

            IF oLVI != NULL_OBJECT
                nValue := oLVI:GetValue( #nItems )
                nTotal += nValue
            ENDIF
        NEXT x
      </code>
    </example>
  </ListViewItem.GetValue>

  <ListViewItem.ImageIndex>
    <summary>
      一个数字值，表示列表视图项目在图像列表中的索引。
    </summary>
    <value>一个数字值，表示列表视图项目在图像列表中的索引。</value>
  </ListViewItem.ImageIndex>

  <ListViewItem.Indent>
    <summary>
      设置列表视图项目的缩进。
    </summary>
    <value>设置列表视图项目的缩进。</value>
    <remarks>
      <note type="tip">
        这仅在详细视图中可用，且仅当项目有关联图像时。
      </note>
    </remarks>
  </ListViewItem.Indent>

  <ListViewItem.ItemIndex>
    <summary>
      一个数字值，表示列表视图项目在列表视图控件中的索引。
    </summary>
    <value>一个数字值，表示列表视图项目在列表视图控件中的索引。</value>
  </ListViewItem.ItemIndex>

  <ListViewItem.OverlayImageIndex>
    <summary>
      一个数字值，表示列表视图项目在图像列表中的覆盖图像的索引。
    </summary>
    <value>一个数字值，表示列表视图项目在图像列表中的覆盖图像的索引。</value>
    <remarks>
      一个数字值，表示列表视图项目在图像列表中的覆盖图像的索引。
      覆盖图像是绘制在项目主图像上的图像。列表视图最多可以有四个覆盖图像，因此这个值可以在1到4的范围内。
    </remarks>
  </ListViewItem.OverlayImageIndex>

  <ListViewItem.Selected>
    <summary>
      一个逻辑值，如果列表视图项目被选中，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果列表视图项目被选中，则为 TRUE。</value>
  </ListViewItem.Selected>

  <ListViewItem.SetText>
    <summary>
      设置列的文本标签。
    </summary>
    <param name="cNewText">要添加到列的文本。</param>
    <param name="symColumnName">要设置其文本的列的符号名称。</param>
    <param name="nImageIndex">一个数字值，表示列表视图的列图像在图像列表中的索引。</param>
    <remarks>
      <note type="tip">
        SubItemImages 仅在 ListView 控件具有样式 LVS_EX_SUBITEMIMAGES 时才有效。您可以使用 ListView:SetExLVStyle(LVS_EX_SUBITEMIMAGES) 设置这个样式。
      </note>
    </remarks>
    <example>
      请参阅 ListView:AddItem() 方法的示例语法。
    </example>
  </ListViewItem.SetText>

  <ListViewItem.SetValue>
    <summary>
      设置列的值。
    </summary>
    <param name="uNewValue">要添加到列的值。</param>
    <param name="symColumnName">要设置其值的列的符号名称。</param>
    <example>
      请参阅 ListView:AddItem() 方法的示例语法。
    </example>
  </ListViewItem.SetValue>

  <ListViewItem.StateImageIndex>
    <summary>
      一个数字值，表示列表视图项目在状态图像列表中的索引。
    </summary>
    <value>一个数字值，表示列表视图项目在状态图像列表中的索引。</value>
    <remarks>
      一个数字值，表示列表视图项目在状态图像列表中的索引。状态图像是绘制在项目主图像旁边的图像。
    </remarks>
    <example>
      <code language="X#">
        nCount := SELF:oDClvClaims:ItemCount

        FOR x := 1 UPTO nCount
            oLVI := SELF:oDClvClaims:GetItemAttributes(x)

            IF oLVI != NULL_OBJECT
                IF oLVI:Checked // 使用ListView的"checkbox"属性设置为YES
                    nValue := oLVI:GetValue( #dSvcDate )
                    SELF:oBillingsServer:GoTo( nValue )
                    // 在这里进行一些处理
                    DO CASE
                        CASE cClaims == "P"
                            oLVI:StateImageIndex := 1 // ImageList在PostInit()方法中预定义
                        CASE cClaims == "X"
                            oLVI:StateImageIndex := 2
                        CASE cClaims == "S"
                            oLVI:StateImageIndex := 3
                    ENDCASE

                    SELF:oDClvClaims:SetItemAttributes(oLVI)
                ENDIF
            ENDIF
        NEXT x
      </code>
    </example>
  </ListViewItem.StateImageIndex>

  <ListViewItemEvent>
    <summary>
      提供有关操作列表视图项目时生成的事件的信息。
    </summary>
    <remarks>
      当 ListView 控件的 ListViewItem 更改、删除或拖动时，将生成 ListViewItem 事件。
    </remarks>
  </ListViewItemEvent>

  <ListViewItemEvent.ctor>
    <inheritdoc />
  </ListViewItemEvent.ctor>

  <ListViewItemEvent.ListViewItem>
    <summary>
      受列表视图项目事件影响的 ListViewItem 对象。
    </summary>
    <value>受列表视图项目事件影响的 ListViewItem 对象。</value>
  </ListViewItemEvent.ListViewItem>

  <ListViewKeyEvent>
    <summary>
      提供有关列表视图键盘事件的信息，这些事件在列表视图控件具有输入焦点时按键时生成。
    </summary>
    <remarks>
      当列表视图控件具有输入焦点时按键时，将生成此事件。此事件的信息与此事件一起打包，包括按下的键的虚拟键码。
    </remarks>
  </ListViewKeyEvent>

  <ListViewKeyEvent.ctor>
    <inheritdoc />
  </ListViewKeyEvent.ctor>

  <ListViewKeyEvent.KeyCode>
    <summary>
      按下的键的虚拟键码。
    </summary>
    <value>按下的键的虚拟键码。</value>
  </ListViewKeyEvent.KeyCode>

  <ListViewMouseEvent>
    <summary>
      提供有关列表视图鼠标事件的信息，这些事件在列表视图控件中的鼠标按钮被单击或双击时生成。
    </summary>
    <remarks>
      当在列表视图控件中发生鼠标单击或双击时，将生成此事件。事件的属性不仅确定事件在物理上发生的位置，还确定事件与控件中的项目的关系。
    </remarks>
  </ListViewMouseEvent>

  <ListViewMouseEvent.ctor>
    <summary>构造一个 ListViewMouseEvent 对象。</summary>
    <param name="oControlNotifyEvent">事件发生时发生的 ControlNotifyEvent。</param>
  </ListViewMouseEvent.ctor>

  <ListViewMouseEvent.ButtonID>
    <summary>
      一个常量，表示单击的鼠标按钮。该值可以是 BUTTONLEFT 或 BUTTONRIGHT。
    </summary>
    <value>一个常量，表示单击的鼠标按钮。该值可以是 BUTTONLEFT 或 BUTTONRIGHT。</value>
  </ListViewMouseEvent.ButtonID>

  <ListViewMouseEvent.IsLeftButton>
    <summary>
      一个逻辑值，如果这是一个左键事件，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果这是一个左键事件，则为 TRUE。</value>
  </ListViewMouseEvent.IsLeftButton>

  <ListViewMouseEvent.IsRightButton>
    <summary>
      一个逻辑值，如果这是一个右键事件，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果这是一个右键事件，则为 TRUE。</value>
  </ListViewMouseEvent.IsRightButton>

  <ListViewMouseEvent.ListViewItem>
    <summary>
      如果鼠标单击发生在项目上，则为被单击的 ListViewItem 对象；否则为 null 对象。
    </summary>
    <value>如果鼠标单击发生在项目上，则为被单击的 ListViewItem 对象；否则为 null 对象。</value>
  </ListViewMouseEvent.ListViewItem>

  <ListViewMouseEvent.PointAboveClientArea>
    <summary>
      一个逻辑值，如果单击发生在列表视图控件的客户区域上方，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在列表视图控件的客户区域上方，则为 TRUE。</value>
  </ListViewMouseEvent.PointAboveClientArea>

  <ListViewMouseEvent.PointBelowClientArea>
    <summary>
      一个逻辑值，如果单击发生在列表视图控件的客户区域下方，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在列表视图控件的客户区域下方，则为 TRUE。</value>
  </ListViewMouseEvent.PointBelowClientArea>

  <ListViewMouseEvent.PointLeftOfClientArea>
    <summary>
      一个逻辑值，如果单击发生在列表视图控件的客户区域左侧，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在列表视图控件的客户区域左侧，则为 TRUE。</value>
  </ListViewMouseEvent.PointLeftOfClientArea>

  <ListViewMouseEvent.PointNowhere>
    <summary>
      一个逻辑值，如果单击发生在列表视图控件内部但不在项目上，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在列表视图控件内部但不在项目上，则为 TRUE。</value>
  </ListViewMouseEvent.PointNowhere>

  <ListViewMouseEvent.PointOnItem>
    <summary>
      一个逻辑值，如果单击发生在列表视图控件中的列表视图项目上，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在列表视图控件中的列表视图项目上，则为 TRUE。</value>
  </ListViewMouseEvent.PointOnItem>

  <ListViewMouseEvent.PointOnItemImage>
    <summary>
      一个逻辑值，如果单击发生在列表视图控件中的列表视图项目的图像上，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在列表视图控件中的列表视图项目的图像上，则为 TRUE。</value>
  </ListViewMouseEvent.PointOnItemImage>

  <ListViewMouseEvent.PointOnItemLabel>
    <summary>
      一个逻辑值，如果单击发生在列表视图控件中的列表视图项目的标签上，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在列表视图控件中的列表视图项目的标签上，则为 TRUE。</value>
  </ListViewMouseEvent.PointOnItemLabel>

  <ListViewMouseEvent.PointOnItemStateImage>
    <summary>
      一个逻辑值，如果单击发生在列表视图控件中的列表视图项目的状态图像上，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在列表视图控件中的列表视图项目的状态图像上，则为 TRUE。</value>
  </ListViewMouseEvent.PointOnItemStateImage>

  <ListViewMouseEvent.PointRightOfClientArea>
    <summary>
      一个逻辑值，如果单击发生在列表视图控件的客户区域右侧，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在列表视图控件的客户区域右侧，则为 TRUE。</value>
  </ListViewMouseEvent.PointRightOfClientArea>

  <ListViewMouseEvent.Position>
    <summary>
      一个 Point 对象，描述在列表视图控件坐标中单击发生的位置。
    </summary>
    <value>一个 Point 对象，描述在列表视图控件坐标中单击发生的位置。</value>
  </ListViewMouseEvent.Position>

  <LogFile>
    <summary>
      为 Internet 服务器应用程序提供日志记录功能。
    </summary>
    <remarks>
      LogFile 类提供了日志输出和错误协议功能。
    </remarks>
  </LogFile>

  <LogFile.ctor>
    <summary>
      构造一个 LogFile 对象实例。
    </summary>
    <param name="cName">日志文件名。如果未指定，日志文件名将与应用程序名相同。扩展名为.LOG。</param>
    <param name="lWinLogPath">
      指定日志文件是否应在 Windows 的 LogFileDirectory 指定的目录中创建(TRUE)，或者日志文件是否应在应用程序的目录中创建(FALSE)。默认为 FALSE。
    </param>
    <param name="lAppend">
      确定日志消息是否应附加到文件末尾(TRUE)，或者是否应将任何现有的日志文件由该对象的日志消息覆盖(FALSE)。默认为 TRUE。
    </param>
  </LogFile.ctor>

  <LogFile.Append>
    <summary>
      一个逻辑值，确定文本是否应附加到文件末尾。
    </summary>
    <value>一个逻辑值，确定文本是否应附加到文件末尾。</value>
  </LogFile.Append>

  <LogFile.DebugMsg>
    <summary>
      向日志文件添加一条消息。
    </summary>
    <param name="cMsg">包含消息的字符串。</param>
    <remarks>
      此方法向日志文件添加一条消息。
    </remarks>
  </LogFile.DebugMsg>

  <LogFile.DumpError>
    <summary>
      向日志文件添加运行时错误描述。
    </summary>
    <param name="oError">错误对象实例。</param>
    <remarks>
      此方法向日志文件添加错误描述。
    </remarks>
    <example> 
      下面是一个常见的 CGI 应用程序框架，它使用 LogFile 类来记录错误消息和应用程序进度信息： 
      <code language="X#">
        CLASS MyFilter INHERIT LogFile
        CLASS StdHTTPContext INHERIT HTTPCGIContext

        FUNCTION Start
            LOCAL oCGI AS StdHTTPContext
            LOCAL cHtml AS STRING
            LOCAL oOldError AS USUAL
            LOCAL oError AS USUAL
            LOCAL oLogFile AS LogFile

            oLogFile := LogFile{}

            #IFDEF __DEBUG__
                oCGI:DebugMsg("CGI application started")
            #ENDIF

            oCGI := StdHTTPContext{}
            oOldError := ErrorBlock( {|oErr|__MyError(oErr)} )

            BEGIN SEQUENCE
                cHtml := oCGI:HTTPResponse()

                IF SLen(cHtml) &gt; 0
                    //
                    // Default behavior, return a HTML
                    //
                    oCGI:Write(cHtml)
                ENDIF

                RECOVER USING oError

                cHtml := oCGI:HTTPErrorMessage(oError)
                oCGI:Write(cHtml)
                oLogFile:DumpError(oError)
            END SEQUENCE

            ErrorBlock( oOldError )
            oCGI:Close()

            #IFDEF __DEBUG__
                oCGI:DebugMsg("CGI application finished")
            #ENDIF

            RETURN

        STATIC FUNC __MyError (oError)
            LOCAL cRepl AS STRING

            cRepl := "Module " + ProcName(1)
            cRepl += ", line " + NTrim(ProcLine(1))

            IF SLen(oError:Description) &gt; 0
                oError:Description += "(" + cRepl + ")"
            ELSE
                oError:Description := cRepl
            ENDIF

            BREAK(oError)
      </code>
    </example>
  </LogFile.DumpError>

  <LogFile.FName>
    <summary>
      代表日志消息文件名的字符串。
    </summary>
    <value>代表日志消息文件名的字符串。</value>
  </LogFile.FName>

  <LogFile.Log2File>
    <exclude />
  </LogFile.Log2File>

  <LogFile.ServerPath>
    <summary>
      代表 Internet 服务器应用程序的完整路径规范的字符串。
    </summary>
    <value>代表 Internet 服务器应用程序的完整路径规范的字符串。</value>
  </LogFile.ServerPath>

  <LogicFS>
    <summary>
      创建一个逻辑字段规范，其中包含逻辑数据类型信息。
    </summary>
  </LogicFS>

  <LogicFS.ctor>
    <summary>
      构造一个逻辑字段规范。
    </summary>
    <param name="oHLName">包含字段名称和其他属性(例如，标题，描述和帮助上下文)的超链接标签，用于创建新的逻辑字段规范。</param>
  </LogicFS.ctor>

  <Menu>
    <summary>
      创建一个菜单。菜单由用户选择执行的项目组成；菜单项可以是字符串，位图或另一个菜单。
    </summary>
    <remarks>
      菜单在应用程序中提供了最高级别的用户控制。<br />
      在最基本的级别上，菜单是一系列在菜单栏中显示的项目(例如，字符串“OpenFile”，一个问号位图表示帮助等)。
      当选择这些项目时，它们执行一个操作，例如，打开一个文件，退出应用程序或获取帮助。<br />
      菜单栏中的项目也可能包含另一个菜单，作为另一种类型的项目。
      当创建一个子菜单时，通常会指定一个标题(这是在菜单栏中显示的文本)和属于该子菜单的项目集(当在菜单栏中激活标题时，这些项目会显示)。
      例如，一个子菜单可能有标题“File”和项目名“Open”，“Save”和“Exit”。<br />
      像菜单一样，子菜单可以包含字符串，位图和其他菜单。使用子菜单可以使您拥有多维菜单。此外，就像任何菜单一样，它们可以从资源实体创建。<br />
      菜单上的每个项目都由一个唯一的ID标识。然后，您可以使用该ID在程序中引用该项目(例如，禁用或删除一个项目)。 <br />
      菜单命令可以通过鼠标或加速键选择，并且可以根据需要添加，删除，插入和追加。<br />
      菜单上的项目可以被灰暗(或灰色)以表示它们被禁用，也可以被选中以表示它们被启用/选中。
      您还可以在菜单上添加分隔符(分隔符是在子菜单的项目之间插入的单行，以将相似的命令分组在一起)。<br />
      通常，菜单会与定义快捷键(例如，Ctrl+S 表示文件保存)的加速表和提供常用菜单命令的工具栏相关联。
      工具栏和加速键通常由菜单携带；将菜单分配给窗口通常也会自动分配工具栏和加速键。<br />
      X# 中的菜单生成以下事件—MenuInitEvent，MenuSelectEvent 和 MenuCommandEvent。它们被分派到拥有生成事件的菜单的窗口。<br />
      这些事件的事件处理程序方法如下： <br />
      Window:MenuInit() 在显示菜单之前调用。 <br />
      Window:MenuSelect() 在突出显示菜单命令时调用。<br />
      当用户选择菜单命令以执行时，如果有匹配的方法，将调用菜单命令的名称的窗口方法。<br />
      如果没有匹配的方法，将调用 Window:MenuCommand()。菜单命令也会向上传播到窗口所有权层次结构。<br />
      有关如何使用命令事件的深入讨论，请参阅程序员指南。<br />
      在 Windows 中，菜单通常是在资源实体中创建的(您也可以使用 Menu 的 Append...或 Insert...方法动态构造菜单)。
      例如，在 Windows 中，菜单可以在资源实体中创建如下： 
      <code language="X#">
        RESOURCE IDM_DEMO MENU

        BEGIN
            POPUP "&amp;File"

            BEGIN
                MENUITEM "&amp;New", IDMI_NEW
                MENUITEM "&amp;Open...", IDMI_OPEN
                MENUITEM "&amp;Save", IDMI_SAVE
                MENUITEM "Save &amp;As...", IDMI_SAVEAS
                MENUITEM SEPARATOR
                MENUITEM "E&amp;xit", IDMI_EXIT
                MENUITEM "A&amp;bout Demo...", IDMI_ABOUT
            END
        END
      </code>
      通过使用菜单编辑器，构造菜单的最简单方法是。它生成了上面示例中的资源，以及用于实例化菜单的子类，加速表和工具栏。 
    </remarks>
  </Menu>

  <Menu.ctor>
    <summary>
      构造一个菜单。
    </summary>
    <param name="xResourceID">菜单的资源ID。如果未指定，系统将创建一个空菜单。</param>
  </Menu.ctor>

  <Menu.Accelerator>
    <summary>
      与此菜单一起使用的加速表。
    </summary>
    <value>与此菜单一起使用的加速表。</value>
    <remarks>
      与此菜单一起使用的加速表。菜单编辑器生成的代码创建了一个加速表，并将其分配给菜单；当菜单分配给窗口时，相应的加速表也被分配。
    </remarks>
  </Menu.Accelerator>

  <Menu.AddChild>
    <exclude />
  </Menu.AddChild>

  <Menu.AppendItem>
    <summary>
      在此菜单的末尾添加一个字符串。
    </summary>
    <param name="nItemID">
      新菜单项的ID。
    </param>
    <param name="xNewItem">
      以下之一：oBitmap，cNewItem，oHyperLabel，oSubmenu
    </param>
    <remarks>
      <paramref name="oBitmap" /> 新菜单项的显示位图。 <br />
      <paramref name="cNewItem" /> 新菜单项的显示文本。 <br />
      <paramref name="oHyperLabel" /> 新菜单项的显示标题的超链接标签。 <br />
      <paramref name="oSubMenu" /> 新菜单项的显示子菜单。它作为子菜单添加；这是构造分层菜单的方法。 
      <note type="tip"> 
        如果指定了 <paramref name="nItemID" /> 为 MENUSEPARATOR，第二个参数是不需要的。
      </note>
    </remarks>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      在菜单中添加新项目后，您必须重新分配菜单给所有者窗口的 Menu 属性，才能使更改生效。
    </remarks>
  </Menu.AppendItem>

  <Menu.CheckItem>
    <summary>
      在指定菜单项的左侧放置一个检查标记。
    </summary>
    <param name="nItemID">菜单命令的ID。</param>
    <returns>
      如果选中，返回 MF_CHECKED，如果未选中，返回 MF_UNCHECKED
    </returns>
    <remarks> 
      在菜单项旁边放置一个检查标记表示其状态。
      这样的命令的状态通常由用户看到的检查标记表示，该检查标记根据命令是打开还是关闭而显示或不显示。<br />
      您以后可以使用 Menu:UncheckItem() 方法从菜单项中删除检查标记。 
      <note type="tip">
        您也可以使用此方法在子菜单上选中一个菜单项。
      </note>
    </remarks>
  </Menu.CheckItem>

  <Menu.Children>
    <exclude />
  </Menu.Children>

  <Menu.DeleteChild>
    <exclude />
  </Menu.DeleteChild>

  <Menu.DeleteItem>
    <summary>
      从此菜单中删除一个项目，从内存中删除它。(要删除位图或字符串，请指定一个ID；要删除子菜单，请指定Menu对象。)
    </summary>
    <param name="xItemIdOrMenu">要删除的菜单项的ID或要删除的子菜单。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </Menu.DeleteItem>

  <Menu.Destroy>
    <summary>
      提供一个方法来取消实例化 Menu 对象。
    </summary>
    <remarks>
      当不再需要 Menu 对象时，可以使用此方法。Menu:Destroy() 取消实例化 Menu 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </Menu.Destroy>

  <Menu.DisableAutoUpdate>
    <exclude />
  </Menu.DisableAutoUpdate>

  <Menu.DisableItem>
    <summary>
      禁用指定的菜单项(直到后续调用 Menu:EnableItem())。
    </summary>
    <param name="nItemID">要禁用的菜单项的ID。</param>
    <returns>
      一个 LONG，指示项目的先前状态。如果项目不存在，返回值为-1。
    </returns>
    <remarks> 
      禁用的菜单项不活动，因此它们不会向其所有者窗口发送事件。请注意，在 Windows 下，禁用的菜单命令是灰暗的。 
      <note type="tip">
        您也可以使用此方法在子菜单上禁用一个菜单项。
      </note>
    </remarks>
  </Menu.DisableItem>

  <Menu.EnableItem>
    <summary>
      启用先前禁用的菜单项。
    </summary>
    <param name="nItemID">要启用的菜单项的ID。</param>
    <returns>
      一个LONG，指示项目的先前状态。如果项目不存在，返回值为-1。
    </returns>
    <remarks> 
      启用菜单项允许它生成事件，并在用户操作菜单命令时将事件发送到其所有者窗口。禁用的菜单项的灰暗效果被移除，菜单项恢复到其正常外观。
      默认情况下，菜单项是启用的，直到被禁用，因此除非之前调用了 DisableItem()，否则不需要调用此 EnableItem() 方法。 
      <note type="tip">
        您也可以使用此方法在菜单的子菜单上启用一个菜单项。
      </note>
    </remarks>
  </Menu.EnableItem>

  <Menu.GetAutoUpdate>
    <exclude />
  </Menu.GetAutoUpdate>

  <Menu.GetSubMenu>
    <exclude />
  </Menu.GetSubMenu>

  <Menu.Handle>
    <summary>
      返回菜单的句柄。
    </summary>
    <param name="nHandleType"> 所需句柄的类型。零(0)是唯一支持的选项，如果省略 <paramref name="nHandle" />，则默认为零。 </param>
    <returns>
      描述底层系统对象的句柄。
    </returns>
    <remarks>
      此方法提供了一个句柄到 Windows GDI 对象，然后可以通过 Windows API GDI 调用使用。
    </remarks>
  </Menu.Handle>

  <Menu.HyperLabel>
    <summary>
      返回附加到菜单项的超链接标签，如果没有，则返回NIL。
    </summary>
    <param name="nItemID">菜单项的唯一ID。</param>
  </Menu.HyperLabel>

  <Menu.InsertItem>
    <summary>
      在指定菜单项之前插入一个新的菜单项。
    </summary>
    <param name="nItemID">新菜单项的ID或要添加的子菜单(只是另一个 Menu 对象)。这是构造分层菜单的方法。</param>
    <param name="xNewItem"> 
      以下之一： <br />
      <paramref name="cNewItem" /> 新菜单项的显示标题。 <br />
      <paramref name="oHyperLabel" /> 新菜单项的显示标题的超链接标签。 <br />
      <paramref name="oBitmap" /> 新菜单项的显示位图。 
    </param>
    <param name="nBeforeID">新项目应在其之前插入的菜单项的ID。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      在菜单中插入新项目后，您必须重新分配菜单给所有者窗口的 Menu 属性，才能使更改生效。
    </remarks>
  </Menu.InsertItem>

  <Menu.Items>
    <exclude />
  </Menu.Items>

  <Menu.MakeMenuRtol>
    <summary>
      反转菜单中菜单项的顺序。只有在使用国际化的双向版本的 Windows 时才需要这样做。
    </summary>
    <param name="lRToL">如果为 TRUE，菜单项从右到左显示；如果为 FALSE，菜单项从左到右显示。如果省略，缺省值为 TRUE。</param>
    <remarks>
      只有在使用国际化的双向版本的 Windows 时，此方法才有效。
    </remarks>
  </Menu.MakeMenuRtol>

  <Menu.MenuItems>
    <exclude />
  </Menu.MenuItems>

  <Menu.Name>
    <summary>
      返回存储在菜单命令的超链接标签中的名称的字符串，如果没有，则返回 NIL。
    </summary>
    <param name="nItemID">菜单项的ID。</param>
  </Menu.Name>

  <Menu.Name>
    <summary>
      返回存储在菜单命令的超链接标签中的符号名称的字符串，如果没有，则返回 NIL。
    </summary>
    <param name="nItemID">菜单项的ID。</param>
  </Menu.Name>

  <Menu.NameSym>
    <exclude />
  </Menu.NameSym>

  <Menu.PostInit>
    <summary>
      实现窗口的自定义初始化代码。
    </summary>
    <remarks>
      此方法用于自定义数据服务器的初始化代码。
      自定义的初始化代码不会被生成的默认初始化代码覆盖。
      在 Init() 方法的末尾自动生成了对 PostInit() 的调用。
    </remarks>
  </Menu.PostInit>

  <Menu.PreInit>
    <summary>
      实现服务器的自定义初始化代码。
    </summary>
    <remarks> 
      此方法用于自定义服务器的初始化代码。 自定义的初始化代码不会被生成的默认初始化代码覆盖。 在 Init() 方法的开始自动生成了对 PreInit() 的调用。
      此类中 PostInit() 的默认实现是空的。 
      <note type="tip">
        在 .Net 中，通常不允许或建议在父类构造函数调用之前运行类中的代码。
        窗口编辑器中生成的代码这样做(在 SUPER() 调用之前调用 PreInit())。
        我们建议您非常小心，不要触摸从父类继承的受保护实例变量，因为这些变量可能未初始化和/或您分配给它们的值可能在父类的构造函数中被覆盖。
      </note>
    </remarks>
  </Menu.PreInit>

  <Menu.RegisterItem>
    <summary>
      注册此菜单项的超链接。
    </summary>
    <param name="nItemID">菜单项的ID。</param>
    <param name="oHyperLabel">要为菜单项注册的超链接。</param>
    <param name="hParentMenu">正在注册的菜单项的句柄。如果注册的项目包含子菜单，则需要此参数。</param>
    <param name="nPosition">
      正在注册的菜单项的偏移量。
      正在注册的菜单项的子菜单的偏移量(例如，如果菜单包含项目'文件'，'编辑'和'查看'，并且偏移量为1，则将'编辑'子菜单注册到'编辑'菜单项)。
      如果注册的项目包含子菜单，则需要此参数。
    </param>
  </Menu.RegisterItem>

  <Menu.SetAutoUpdate>
    <summary>
      在菜单上的指定子菜单后附加一个部分。此部分会自动跟踪当前打开的MDI子窗口，并在子菜单上显示它们的名称。
    </summary>
    <param name="nMenuNumber">
      要在其后附加新部分的子菜单的偏移量
      (例如，如果菜单包含项目'文件'，'编辑'和'查看'，并且偏移量为1，则新部分将附加到'编辑'子菜单)。默认值为0(第一个菜单项)。
    </param>
    <remarks>
      在 MDI 应用程序中，通常有一个菜单，其中包含任何当前打开的 MDI 子窗口的标题。
      更新新部分后，您必须重新分配菜单给所有者窗口的 Menu 属性，更改才能生效。
    </remarks>
  </Menu.SetAutoUpdate>

  <Menu.SetParent>
    <exclude />
  </Menu.SetParent>

  <Menu.ShowAsPopup>
    <summary>
      将菜单显示为本地弹出菜单。
    </summary>
    <param name="oOwner">拥有本地弹出菜单的窗口。</param>
    <param name="oPoint">相对于客户区域的点，用于显示菜单。如果省略，菜单将显示在当前鼠标光标位置。</param>
    <param name="kButton">指示菜单将跟踪的按钮常量。值可以是 PM_LEFTBUTTON 和 PM_RIGHTBUTTON。如果省略，菜单将跟踪左鼠标按钮。</param>
    <param name="kAlignment">
      指示菜单将如何与菜单的显示位置对齐的对齐常量。值可以是 PM_ALIGNCENTER，PM_ALIGNLEFT 和 PM_ALIGNRIGHT。如果省略，菜单将对齐到显示位置的左侧。
    </param>
    <param name="oNotOverlap">**缺少参数文档**</param>
    <returns>
      如果成功显示菜单，则返回 TRUE；否则，返回 FALSE。
    </returns>
  </Menu.ShowAsPopup>

  <Menu.ToolBar>
    <summary>
      与菜单对应的工具栏。
    </summary>
    <value>与菜单对应的工具栏。</value>
    <remarks>
      与菜单对应的工具栏。菜单编辑器生成的代码创建一个工具栏，并将其分配给菜单；当菜单分配给窗口时，相应的工具栏也会被分配。
    </remarks>
  </Menu.ToolBar>

  <Menu.UncheckItem>
    <summary>
      从菜单项中移除用户看到的复选标记。通常，您会在该项上的 MenuCommandEvent 响应中执行此操作。
    </summary>
    <param name="nItemID">菜单项的ID。</param>
    <returns>
      如果成功移除，则返回 TRUE；否则，返回 FALSE。
    </returns>
  </Menu.UncheckItem>

  <Menu.UnregisterItem>
    <summary>
      取消注册此菜单项的超链接。
    </summary>
    <param name="nItemID">菜单项的ID。</param>
  </Menu.UnregisterItem>

  <MenuCommandEvent>
    <summary>
      提供有关 MenuCommandEvent 的信息，当用户直接执行菜单项或通过使用加速键时生成时。
    </summary>
    <remarks>
      MenuCommandEvent 事件被传递给 Window:MenuCommand()，后者会调度菜单项超链接指示的方法。
    </remarks>
  </MenuCommandEvent>

  <MenuCommandEvent.ctor>
    <inheritdoc />
  </MenuCommandEvent.ctor>

  <MenuCommandEvent.AsString>
    <summary>
      返回所选菜单项的标题。
    </summary>
    <remarks>
      菜单项资源提供标题。
    </remarks>
  </MenuCommandEvent.AsString>

  <MenuCommandEvent.HyperLabel>
    <summary>
      与生成此 MenuCommandEvent 的菜单项连接的超链接。
    </summary>
    <value>与生成此 MenuCommandEvent 的菜单项连接的超链接。</value>
    <remarks>
      与生成此 MenuCommandEvent 的菜单项连接的超链接。从超链接，您可以检索有关菜单项的其他信息。
    </remarks>
  </MenuCommandEvent.HyperLabel>

  <MenuCommandEvent.ItemID>
    <summary>
      一个数字值，表示生成此 MenuCommandEvent 的菜单项的ID。
    </summary>
    <value>一个数字值，表示生成此 MenuCommandEvent 的菜单项的ID。</value>
  </MenuCommandEvent.ItemID>

  <MenuCommandEvent.Menu>
    <summary>
      生成此 MenuCommandEvent 的 Menu 对象。
    </summary>
    <value>生成此 MenuCommandEvent 的 Menu 对象。</value>
  </MenuCommandEvent.Menu>

  <MenuCommandEvent.Name>
    <summary>
      一个字符串，表示存储在生成此 MenuCommandEvent 的菜单项的超链接中的名称。
    </summary>
    <value>一个字符串，表示存储在生成此 MenuCommandEvent 的菜单项的超链接中的名称。</value>
  </MenuCommandEvent.Name>

  <MenuCommandEvent.NameSym>
    <summary>
      一个符号，表示存储在生成此 MenuCommandEvent 的菜单项的超链接中的名称。
    </summary>
    <value>一个符号，表示存储在生成此 MenuCommandEvent 的菜单项的超链接中的名称。</value>
  </MenuCommandEvent.NameSym>

  <MenuInitEvent>
    <summary>
      提供有关 MenuInitEvent 的信息，当用户第一次激活菜单时生成。
    </summary>
    <remarks>
      在显示下拉菜单之前，系统会生成 MenuInitEvent 对象，允许应用程序在显示菜单项之前初始化这些项。
      例如，您可能希望在程序尚未准备好处理的情况下将项目变暗，或者您可能希望检查或取消检查某些项目。
      MenuInitEvent 事件被传递给 Window:MenuInit()。
      如果您使用 Menu 访问更改菜单，您不需要调用窗口的 Menu assign。当菜单显示时，它是修改后的版本。
      如果加速键调用子菜单，将生成 MenuInitEvent 事件。
    </remarks>
  </MenuInitEvent>

  <MenuInitEvent.ctor>
    <inheritdoc />
  </MenuInitEvent.ctor>

  <MenuInitEvent.Menu>
    <summary>
      生成此 MenuInitEvent 的 Menu 对象。
    </summary>
    <value>生成此 MenuInitEvent 的 Menu 对象。</value>
  </MenuInitEvent.Menu>

  <MenuSelectEvent>
    <summary>
      提供有关 MenuSelectEvent 的信息，当用户在菜单上突出显示菜单项时生成。
    </summary>
    <remarks> 
      MenuSelectEvent 事件使程序能够预期用户可以激活一个项目或提供状态信息。 
      <note type="tip">
        当实际选择菜单项(因此执行)时，系统会生成 MenuCommandEvent。
      </note>
      当执行加速键时，将生成 MenuSelectEvent 事件，随后紧接着生成 MenuCommandEvent 事件，以模拟鼠标路由——您必须通过这些选择来选择选项。
      因此，加速键生成的事件与使用鼠标生成的事件相同。
    </remarks>
    <example> 
      下面的示例根据当前选择的命令在状态栏中打印不同的帮助行： 
      <code language="X#">
        CLASS MyWindow INHERIT TopAppWindow
            METHOD MenuSelect(oMSE) CLASS MyWindow
                LOCAL j := oMSE:ItemID

                DO CASE
                    CASE j = IDMI_RED
                        TextPrint("选择红色笔", Point{10,10})
                    CASE j = IDMI_GREEN
                        TextPrint("选择绿色笔", Point{10,10})
                    CASE j = IDMI_BLUE
                        TextPrint("选择蓝色笔", Point{10,10})
                ENDCASE
      </code>
    </example>
  </MenuSelectEvent>

  <MenuSelectEvent.ctor>
    <inheritdoc />
  </MenuSelectEvent.ctor>

  <MenuSelectEvent.AsString>
    <summary>
      返回所选菜单项的标题。
    </summary>
    <remarks>
      菜单项资源提供标题。
    </remarks>
  </MenuSelectEvent.AsString>

  <MenuSelectEvent.HyperLabel>
    <summary>
      与生成此 MenuSelectEvent 的菜单项连接的超链接。
    </summary>
    <value>与生成此 MenuSelectEvent 的菜单项连接的超链接。</value>
  </MenuSelectEvent.HyperLabel>

  <MenuSelectEvent.ItemID>
    <summary>
      一个数字值，表示生成此 MenuSelectEvent 的菜单项的ID。
    </summary>
    <value>一个数字值，表示生成此 MenuSelectEvent 的菜单项的ID。</value>
  </MenuSelectEvent.ItemID>

  <MenuSelectEvent.Menu>
    <summary>
      生成此 MenuSelectEvent 的 Menu 对象。
    </summary>
    <value>生成此 MenuSelectEvent 的 Menu 对象。</value>
  </MenuSelectEvent.Menu>

  <MenuSelectEvent.Name>
    <summary>
      一个字符串，表示存储在生成此 MenuSelectEvent 的菜单项的超链接中的名称。
    </summary>
    <value>一个字符串，表示存储在生成此 MenuSelectEvent 的菜单项的超链接中的名称。</value>
  </MenuSelectEvent.Name>

  <MenuSelectEvent.NameSym>
    <summary>
      一个符号，表示存储在生成此 MenuSelectEvent 的菜单项的超链接中的名称。
    </summary>
    <value>一个符号，表示存储在生成此 MenuSelectEvent 的菜单项的超链接中的名称。</value>
  </MenuSelectEvent.NameSym>

  <MinMaxInfoEvent>
    <summary>
      提供有关 MinMaxInfoEvent 的信息，当窗口的大小或位置即将更改时生成。
      MinMaxInfoEvent 对象描述了最大化窗口的宽度、高度和位置，以及窗口的最小和最大高度和宽度。
    </summary>
    <remarks>
      MinMaxInfoEvent 事件包含有关窗口的大小和位置的信息。它还允许通过分配新值来覆盖这些默认值。
    </remarks>
  </MinMaxInfoEvent>

  <MinMaxInfoEvent.ctor>
    <inheritdoc />
  </MinMaxInfoEvent.ctor>

  <MinMaxInfoEvent.MaxPosition>
    <exclude />
  </MinMaxInfoEvent.MaxPosition>

  <MinMaxInfoEvent.MaxSize>
    <exclude />
  </MinMaxInfoEvent.MaxSize>

  <MinMaxInfoEvent.MaxTrackSize>
    <exclude />
  </MinMaxInfoEvent.MaxTrackSize>

  <MinMaxInfoEvent.MinTrackSize>
    <exclude />
  </MinMaxInfoEvent.MinTrackSize>

  <ModelessDialog>
    <summary>
      创建一个无模式对话框窗口(通常也称为对话框框)，用于呈现用户输入和输出的一组控件。
    </summary>
  </ModelessDialog>

  <ModelessDialog.ctor>
    <summary>
      创建一个无模式对话框框。
    </summary>
    <param name="oOwner">拥有无模式对话框框的窗口。</param>
    <param name="xResourceID">无模式对话框框的资源ID。</param>
  </ModelessDialog.ctor>

  <ModelessDialog.Destroy>
    <summary>
      提供一种方法来取消实例化 ModelessDialog 对象。
    </summary>
    <remarks>
      当不再需要 ModelessDialog 对象时，可以使用此方法。
      ModelessDialog:Destroy() 取消实例化 ModelessDialog 对象，并允许您关闭和释放对象打开或创建的任何资源，而无需等待垃圾收集器。
    </remarks>
  </ModelessDialog.Destroy>

  <MoneyFS>
    <summary>
      创建一个货币字段规范，其中包含货币数据类型信息。
    </summary>
  </MoneyFS>

  <MoneyFS.ctor>
    <summary>
      构造一个货币字段规范。
    </summary>
    <param name="oHLName">包含字段名称和其他属性(例如，标题，描述和帮助上下文)的超链接标签，用于创建新的货币字段规范。</param>
    <param name="uLength">字段的长度。如果未指定，将使用默认值12。</param>
    <param name="uDecimals">字段中的小数位数。如果未指定，将使用默认值2。</param>
  </MoneyFS.ctor>

  <MonthCalendar>
    <summary>
      封装一个独立的 MonthCalendar 控件。
    </summary>
    <remarks> 
      MonthCalendar 控件显示一个月历，允许用户浏览月份并选择特定日期。 
      <note type="tip">
        需要 COMCTL32.DLL 的 4.70 或更高版本才能使用 MonthCalendar 控件。
      </note>
    </remarks>
  </MonthCalendar>

  <MonthCalendar.ctor>
    <summary>
      构造一个 MonthCalendar 对象。
    </summary>
    <param name="oOwner">拥有 MonthCalendar 对象的窗口。</param>
    <param name="xID">MonthCalendar 对象的唯一ID(在1和8000之间)。</param>
    <param name="oPoint">MonthCalendar 对象在画布坐标中的原点。</param>
    <param name="oDimension">MonthCalendar 对象在画布坐标中的尺寸。</param>
    <param name="dwStyle">
      表示 MonthCalendar 对象的样式的常量，可以通过 X# 样式常量或 Windows API 样式常量指定。可以使用 _Or() 运算符组合样式。
    </param>
    <param name="lDataAware">一个逻辑值，如果 MonthCalendar 对象是数据感知的，则为 TRUE；否则为 FALSE。默认值为 TRUE。</param>
    <param name="nResourceID">MonthCalendar 对象的资源ID。</param>
    <remarks>
      <note type="tip">请参阅 Microsoft Win32 软件开发工具包文档，了解有关特定样式常量的详细信息。</note>
    </remarks>
  </MonthCalendar.ctor>

  <MonthCalendar.BackgroundColor>
    <summary>
      描述 MonthCalendar 控件背景颜色(在月份之间)的 Color 对象。
    </summary>
    <value>描述 MonthCalendar 控件背景颜色(在月份之间)的 Color 对象。</value>
  </MonthCalendar.BackgroundColor>

  <MonthCalendar.Dispatch>
    <inheritdoc />
  </MonthCalendar.Dispatch>

  <MonthCalendar.FirstDayOfWeek>
    <summary>
      一个整数，指定一周的第一天(星期一=0，星期二=1，依此类推)。
    </summary>
    <value>一个整数，指定一周的第一天(星期一=0，星期二=1，依此类推)。</value>
  </MonthCalendar.FirstDayOfWeek>

  <MonthCalendar.MaxSelCount>
    <summary>
      MonthCalendar 控件中可以选择的最大天数。
    </summary>
    <value>MonthCalendar 控件中可以选择的最大天数。</value>
    <remarks> MonthCalendar 控件中可以选择的最大天数。 <note type="tip">
      此属性仅适用于打开了 MultiSelect 样式(MCS_MULTISELECT)的 MonthCalendar 控件。</note>
    </remarks>
  </MonthCalendar.MaxSelCount>

  <MonthCalendar.MonthBackgroundColor>
    <summary>
      描述 MonthCalendar 控件背景颜色(在月份区域内)的 Color 对象。
    </summary>
    <value>描述 MonthCalendar 控件背景颜色(在月份区域内)的 Color 对象。</value>
  </MonthCalendar.MonthBackgroundColor>

  <MonthCalendar.MonthDelta>
    <summary>
      用户单击滚动按钮时控件滚动的月份数。
    </summary>
    <value>用户单击滚动按钮时控件滚动的月份数。</value>
  </MonthCalendar.MonthDelta>

  <MonthCalendar.Range>
    <summary>
      设置 MonthCalendar 控件的最小和最大允许日期的 DateRange 对象。
    </summary>
    <value>设置 MonthCalendar 控件的最小和最大允许日期的 DateRange 对象。</value>
  </MonthCalendar.Range>

  <MonthCalendar.Selection>
    <summary>
      当前选择的日期。在多重选择的情况下，返回的是开始日期。
    </summary>
    <value>当前选择的日期。在多重选择的情况下，返回的是开始日期。</value>
  </MonthCalendar.Selection>

  <MonthCalendar.SelectionRange>
    <summary>
      代表当前选择日期范围的 DateRange 对象。
    </summary>
    <value>代表当前选择日期范围的 DateRange 对象。</value>
  </MonthCalendar.SelectionRange>

  <MonthCalendar.TextColor>
    <summary>
      指定 MonthCalendar 控件文本颜色的 Color 对象。
    </summary>
    <value>指定 MonthCalendar 控件文本颜色的 Color 对象。</value>
  </MonthCalendar.TextColor>

  <MonthCalendar.TextValue>
    <summary>
      当前日期选择的字符串格式。
    </summary>
    <value>当前日期选择的字符串格式。</value>
    <remarks>
      当前日期选择的字符串格式。这在内部是必需的，以允许 MonthCalendar 控件与数据库字段的绑定。
    </remarks>
  </MonthCalendar.TextValue>

  <MonthCalendar.TitleBackgroundColor>
    <summary>
      指定 MonthCalendar 控件标题背景颜色的 Color 对象。
    </summary>
    <value>指定 MonthCalendar 控件标题背景颜色的 Color 对象。</value>
  </MonthCalendar.TitleBackgroundColor>

  <MonthCalendar.TitleTextColor>
    <summary>
      指定 MonthCalendar 控件标题文本颜色的 Color 对象。
    </summary>
    <value>指定 MonthCalendar 控件标题文本颜色的 Color 对象。</value>
  </MonthCalendar.TitleTextColor>

  <MonthCalendar.Today>
    <summary>
      MonthCalendar 控件指定的“今天”日期。
    </summary>
    <value>MonthCalendar 控件指定的“今天”日期。</value>
  </MonthCalendar.Today>

  <MonthCalendar.TrailingTextColor>
    <summary>
      描述 MonthCalendar 控件尾部和前导天的颜色的 Color 对象，即不属于当前月份的天。
    </summary>
    <value>描述 MonthCalendar 控件尾部和前导天的颜色的 Color 对象，即不属于当前月份的天。</value>
  </MonthCalendar.TrailingTextColor>

  <MonthCalendar.Value>
    <summary>
      当前选择的日期。
    </summary>
    <value>当前选择的日期。</value>
  </MonthCalendar.Value>

  <MonthCalSelectionEvent>
    <summary>
      提供有关 MonthCalSelectionEvent 的信息，当用户在 MonthCalendar 控件中选择日期时生成。
    </summary>
    <remarks>
      当在 MonthCalendar 控件中选择日期时，将生成此事件。
    </remarks>
  </MonthCalSelectionEvent>

  <MonthCalSelectionEvent.ctor>
    <inheritdoc />
  </MonthCalSelectionEvent.ctor>

  <MonthCalSelectionEvent.Explicit>
    <summary>
      一个逻辑值，指示用户在 MonthCalendar 控件中进行了显式日期选择。
    </summary>
    <value>一个逻辑值，指示用户在 MonthCalendar 控件中进行了显式日期选择。</value>
  </MonthCalSelectionEvent.Explicit>

  <MonthCalSelectionEvent.Selection>
    <summary>
      一个日期值，指示用户在控件中选择的日期。
    </summary>
    <value>一个日期值，指示用户在控件中选择的日期。</value>
  </MonthCalSelectionEvent.Selection>

  <MouseEvent>
    <summary>
      提供有关 MouseEvent 的信息，当鼠标发生 MouseEvent时，包括鼠标的位置以及用户按下了哪个鼠标按钮。
    </summary>
    <remarks>
      MouseEvent 事件被传递给以下 Window 类的事件处理程序：
      MouseButtonDown()，MouseButtonUp()，MouseButtonDoubleClick()，MouseMove() 和 MouseDrag()。
    </remarks>
  </MouseEvent>

  <MouseEvent.ctor>
    <inheritdoc />
  </MouseEvent.ctor>

  <MouseEvent.ButtonID>
    <summary>
      以下常量之一，指示生成 MouseEvent 时用户按下的鼠标按钮：
    </summary>
    <value>以下常量之一，指示生成 MouseEvent 时用户按下的鼠标按钮：</value>
    <remarks> 
      以下常量之一，指示生成 MouseEvent 时用户按下的鼠标按钮： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>BUTTONCONTROL</term>
          <description>键盘上的 Control 键正在使用。</description>
        </item>
        <item>
          <term>BUTTONLEFT</term>
          <description>正在使用鼠标的左键。</description>
        </item>
        <item>
          <term>BUTTONMIDDLE</term>
          <description>正在使用鼠标的中键。</description>
        </item>
        <item>
          <term>BUTTONRIGHT</term>
          <description>正在使用鼠标的右键。</description>
        </item>
        <item>
          <term>BUTTONSHIFT</term>
          <description>键盘上的 Shift 键正在被按下。</description>
        </item>
        <item>
          <term>BUTTONX1</term>
          <description>正在使用五键鼠标的 ButtonX1。</description>
        </item>
        <item>
          <term>BUTTONX2</term>
          <description>正在使用五键鼠标的 ButtonX2。</description>
        </item>
      </list>
      如果用户同时按下多个鼠标按钮，MouseEvent:ButtonID 访问方法在 Window:MouseDrag() 事件处理程序中不起作用。
      要处理多个按钮，调用 MouseEvent 的方法(如 IsLeftButton() 和 IsRightButton())，这些方法报告单独的按钮。
      </remarks>
  </MouseEvent.ButtonID>

  <MouseEvent.Height>
    <exclude />
  </MouseEvent.Height>

  <MouseEvent.IsControlButton>
    <summary>
      一个逻辑值，指示生成 MouseEvent 时用户是否按下了 Control 键。
    </summary>
    <value>一个逻辑值，指示生成 MouseEvent 时用户是否按下了 Control 键。</value>
    <remarks>
      一个逻辑值，指示生成 MouseEvent 时用户是否按下了 Control 键。如果是，返回 TRUE；否则，返回 FALSE。
    </remarks>
  </MouseEvent.IsControlButton>

  <MouseEvent.IsLeftButton>
    <summary>
      一个逻辑值，指示生成 MouseEvent 时用户是否按下了鼠标的左键。
    </summary>
    <value>一个逻辑值，指示生成 MouseEvent 时用户是否按下了鼠标的左键。</value>
    <remarks>
      一个逻辑值，指示生成 MouseEvent 时用户是否按下了鼠标的左键。如果是，返回 TRUE；否则，返回 FALSE。
    </remarks>
  </MouseEvent.IsLeftButton>

  <MouseEvent.IsMiddleButton>
    <summary>
      一个逻辑值，指示生成 MouseEvent 时用户是否按下了鼠标的中键。
    </summary>
    <value>一个逻辑值，指示生成 MouseEvent 时用户是否按下了鼠标的中键。</value>
    <remarks>
      一个逻辑值，指示生成 MouseEvent 时用户是否按下了鼠标的中键。如果是，返回 TRUE；否则，返回 FALSE。
    </remarks>
  </MouseEvent.IsMiddleButton>

  <MouseEvent.IsRightButton>
    <summary>
      一个逻辑值，指示生成 MouseEvent 时用户是否按下了鼠标的右键。
    </summary>
    <value>一个逻辑值，指示生成 MouseEvent 时用户是否按下了鼠标的右键。</value>
    <remarks>
      一个逻辑值，指示生成 MouseEvent 时用户是否按下了鼠标的右键。如果是，返回 TRUE；否则，返回 FALSE。
    </remarks>
  </MouseEvent.IsRightButton>

  <MouseEvent.IsShiftButton>
    <summary>
      一个逻辑值，指示生成 MouseEvent 时用户是否按下了 Shift 键。
    </summary>
    <value>一个逻辑值，指示生成 MouseEvent 时用户是否按下了 Shift 键。</value>
    <remarks>
      一个逻辑值，指示生成 MouseEvent 时用户是否按下了 Shift 键。如果是，返回 TRUE；否则，返回 FALSE
    </remarks>
  </MouseEvent.IsShiftButton>

  <MouseEvent.IsXButton1>
    <summary>
      一个逻辑值，指示生成 MouseEvent 时用户是否按下了 XButton1。
    </summary>
    <value>一个逻辑值，指示生成 MouseEvent 时用户是否按下了 XButton1。</value>
    <remarks>
      五键鼠标有左、中、右、XButton1 和 XButton2。
      一个逻辑值，指示生成 MouseEvent 时用户是否按下了 XButton1。如果是，返回 TRUE；否则，返回 FALSE
    </remarks>
  </MouseEvent.IsXButton1>

  <MouseEvent.IsXButton2>
    <summary>
      一个逻辑值，指示生成 MouseEvent 时用户是否按下了 XButton2。
    </summary>
    <value>一个逻辑值，指示生成 MouseEvent 时用户是否按下了 XButton2。</value>
    <remarks>
      五键鼠标有左、中、右、XButton1 和 XButton2。
      一个逻辑值，指示生成 MouseEvent 时用户是否按下了 XButton2。如果是，返回 TRUE；否则，返回 FALSE
    </remarks>
  </MouseEvent.IsXButton2>

  <MouseEvent.Position>
    <summary>
      一个点，表示生成 MouseEvent 时鼠标指针在窗口上的位置，以画布坐标表示。
    </summary>
    <value>一个点，表示生成 MouseEvent 时鼠标指针在窗口上的位置，以画布坐标表示。</value>
  </MouseEvent.Position>

  <MouseEvent.Size>
    <exclude />
  </MouseEvent.Size>

  <MouseEvent.Width>
    <exclude />
  </MouseEvent.Width>

  <MoveEvent>
    <summary>
      提供有关 MoveEvent 的信息，用于通知程序用户正在移动窗口的过程。
    </summary>
    <remarks>
      当用户或程序在屏幕上移动窗口时，将生成 MoveEvent 事件。MoveEvent 事件将传递给 Window:Move()。
      虃虽然大多数程序不关心 MoveEvent 事件；虽然这可能是相当不寻常的行为，但程序可能希望将窗口锚定在屏幕的某个特定区域，例如。
    </remarks>
  </MoveEvent>

  <MoveEvent.ctor>
    <inheritdoc />
  </MoveEvent.ctor>

  <MoveEvent.Origin>
    <summary>
      一个点，表示 MoveEvent 生成后窗口的新位置。
    </summary>
    <value>一个点，表示 MoveEvent 生成后窗口的新位置。</value>
    <remarks>
      一个点，表示 MoveEvent 生成后窗口的新位置。
      对于顶级应用程序窗口和 shell 窗口，点在桌面坐标中给出。对于所有其他窗口，它在所有者窗口的画布坐标中给出。在这个意义上，桌面拥有顶级窗口。
    </remarks>
  </MoveEvent.Origin>

  <MultiLineEdit>
    <summary>
      创建一个多行编辑控件，用于在服务器的变量或字段中显示和输入信息。多行编辑控件可以绑定到任何类型的数据服务器字段(字符、日期、逻辑、数值或备忘录)。
    </summary>
    <remarks>
      多行编辑控件提供的一些功能包括滚动行和页，并检索指定的行(除了从 Edit 类继承的简单编辑基元)。
    </remarks>
    <example> 
      这个例子创建并初始化一个多行编辑控件： 
      <code language="X#">
        CLASS MyWindow INHERIT TopAppWindow
            HIDDEN oMyMLE AS OBJECT

            METHOD Init() CLASS MyWindow
                SUPER:Init()
                p := Point{10, 10}
                d := Dimension{100, 100}
                oMyMLE := MultiLineEdit{SELF,100,p,d}
                SELF:Show()
                oMyMLE:Show()
                oMyMLE:TextValue := "New York" + _CHR(10) + "Boston"
      </code>
      在Windows中，多行编辑控件等同于使用ES_MULTILINE样式创建的编辑控件。这些通常在资源实体中指定，如下所示： 
      <code language="X#">
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 80
        STYLE WS_POPUP | WS_DLGFRAME
        BEGIN
            EDITTEXT IDE_TEXT,10,10,90,45, ES_MULTILINE
            DEFPUSHBUTTON "OK" IDB_OK,64,60,32,14, WS_GROUP
        END
      </code>
    </example>
  </MultiLineEdit>

  <MultiLineEdit.ctor>
    <summary>
      构造一个多行编辑控件。
    </summary>
    <param name="oOwner">拥有多行编辑控件的窗口。</param>
    <param name="xID">多行编辑控件的唯一ID(1到8000之间)。</param>
    <param name="oPoint">多行编辑控件在画布坐标中的原点。</param>
    <param name="oDimension">多行编辑控件在画布坐标中的尺寸。</param>
    <param name="kStyle">多行编辑控件的样式，指定为下面列出的常量之一。</param>
    <param name="nResourceID">多行编辑控件的资源ID。</param>
    <remarks>
      <include file="Gui.xml" path="doc/EditConstants/*" />
    </remarks>
  </MultiLineEdit.ctor>

  <MultiLineEdit.CurrentText>
    <summary>
      一个字符串，表示当前显示在编辑框中的文本。
      MultiLineEdit:CurrentText 分配也会改变 MultiLineEdit:TextValue 和 MultiLineEdit:Value，当焦点转移到另一个控件时。
    </summary>
    <value>
      一个字符串，表示当前显示在编辑框中的文本。
      MultiLineEdit:CurrentText 分配也会改变 MultiLineEdit:TextValue 和 MultiLineEdit:Value，当焦点转移到另一个控件时。
    </value>
  </MultiLineEdit.CurrentText>

  <MultiLineEdit.Destroy>
    <summary>
      提供一种方法，用于取消实例化一个 MultiLineEdit 对象。
    </summary>
    <remarks>
      当不再需要一个 MultiLineEdit 对象时，可以使用这个方法。
      MultiLineEdit:Destroy() 取消实例化 MultiLineEdit 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </MultiLineEdit.Destroy>

  <MultiLineEdit.Dispatch>
    <inheritdoc />
  </MultiLineEdit.Dispatch>
  
  <MultiLineEdit.GetLine>
    <summary>
      在多行编辑控件中，获取指定位置的文本行。
    </summary>
    <param name="nLineNumber">
      多行编辑控件中的位置，指定所需字符串所在的行。指定以下值之一：
      <list>
        <item>
          <term>0</term>
          <description>多行编辑控件中的当前行(即，当前包含文本光标的行)。这是默认值。</description>
        </item>
        <item>
          <term>1</term>
          <description>多行编辑控件中的第一行。</description>
        </item>
        <item>
          <term>n</term>
          <description>多行编辑控件中的第n行。</description>
        </item>
      </list>
    </param>
    <param name="nMaxLength">从指定行提取的最大字符数。默认值是返回整行，包括文本中的任何实际空格，但不包括由于自动换行而显示的任何空格。</param>
    <returns>
      指定行的文本。
    </returns>
  </MultiLineEdit.GetLine>

  <MultiLineEdit.GetLineLength>
    <summary>
      在多行编辑控件中，获取指定位置的文本行的长度。
    </summary>
    <param name="nLineNumber">
      多行编辑控件中的位置，指定所需字符串所在的行。指定以下值之一：
      <list>
        <item>
          <term>0</term>
          <description>多行编辑控件中的当前行(即，当前包含文本光标的行)。这是默认值。</description>
        </item>
        <item>
          <term>1</term>
          <description>多行编辑控件中的第一行。</description>
        </item>
        <item>
          <term>n</term>
          <description>多行编辑控件中的第n行。</description>
        </item>
      </list>
    </param>
    <returns>
      指定行的长度。
    </returns>
  </MultiLineEdit.GetLineLength>

  <MultiLineEdit.LineCount>
    <summary>
      一个数值，表示多行编辑控件中的行数。
    </summary>
    <value>一个数值，表示多行编辑控件中的行数。</value>
  </MultiLineEdit.LineCount>

  <MultiLineEdit.LineDown>
    <summary>
      在多行编辑控件中，将光标从当前位置向下移动一行。
    </summary>
  </MultiLineEdit.LineDown>

  <MultiLineEdit.LineUp>
    <summary>
      在多行编辑控件中，将光标从当前位置向上移动一行。
    </summary>
  </MultiLineEdit.LineUp>

  <MultiLineEdit.PageDown>
    <summary>
      在多行编辑控件中，将光标从当前位置向下移动一页。
    </summary>
    <remarks>
      一页是当前多行编辑控件中适合的行数，以当前字体表示。
    </remarks>
  </MultiLineEdit.PageDown>

  <MultiLineEdit.PageUp>
    <summary>
      在多行编辑控件中，将光标从当前位置向上移动一页。
    </summary>
    <remarks>
      一页是当前多行编辑控件中适合的行数，以当前字体表示。
    </remarks>
  </MultiLineEdit.PageUp>

  <MultiLineEdit.ScrollHorizontal>
    <summary>
      在多行编辑控件中，将文本向右或向左滚动指定数量的字符。
    </summary>
    <param name="nChars">要滚动的字符数。正值将光标向右移动；负值将光标向左移动。默认值是不移动。</param>
  </MultiLineEdit.ScrollHorizontal>

  <MultiLineEdit.ScrollVertical>
    <summary>
      在多行编辑控件中，将文本向上或向下滚动指定数量的行。
    </summary>
    <param name="nLines">要滚动的行数。正值将光标向上移动；负值将光标向下移动。默认值是不移动，或零(0)行。</param>
  </MultiLineEdit.ScrollVertical>

  <MultiLineEdit.Value>
    <summary>
      MultiLineEdit:Value 包含上一次编辑操作后存储的文本。
      MultiLineEdit:TextValue 分配也会改变 MultiLineEdit:CurrentText，MultiLineEdit:TextValue 和 MultiLineEdit:ValueChanged。
    </summary>
    <value>
      MultiLineEdit:Value 包含上一次编辑操作后存储的文本。
      MultiLineEdit:TextValue 分配也会改变 MultiLineEdit:CurrentText，MultiLineEdit:TextValue 和 MultiLineEdit:ValueChanged。
    </value>
  </MultiLineEdit.Value>

  <MultiMediaContainer>
    <summary>
      实现一个用于显示多媒体数据的容器窗口。
    </summary>
    <remarks>
      MultiMediaContainer 类显示一个子窗口，能够显示各种类型的多媒体数据，如位图、视频和音频文件。
      MultiMediaContainer 对象可以用于数据绑定，从数据库(如Jasmine)显示多媒体数据。它们也可以独立使用。
    </remarks>
  </MultiMediaContainer>

  <MultiMediaContainer.ctor>
    <summary>
      实例化一个 MultiMediaContainer 控件。
    </summary>
    <param name="oOwner">拥有控件的窗口。</param>
    <param name="xID">控件的唯一ID(在1和8000之间)。</param>
    <param name="oPoint">控件在画布坐标中的原点。</param>
    <param name="oDimension">控件在画布坐标中的尺寸。</param>
    <param name="nResourceID">控件的资源ID。</param>
    <remarks>
      这个方法实例化一个 MultiMediaContainer 对象。根据分配给它的文件，MultiMediaContainer 对象尝试显示多媒体数据。
      对于视频或音频数据，它会创建一个 MCI 子窗口。对于图像，X# 图像支持尝试在控件的客户区域显示图像。
    </remarks>
  </MultiMediaContainer.ctor>

  <MultiMediaContainer.Destroy>
    <summary>
      提供一个方法来取消实例化一个 MultiMediaContainer 对象。
    </summary>
    <remarks>
      当不再需要一个 MultiMediaContainer 对象时，可以使用这个方法。MultiMediaContainer:Destroy() 取消实例化 MultiMediaContainer 对象，
      并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </MultiMediaContainer.Destroy>

  <MultiMediaContainer.Dispatch>
    <summary>
      当控件获得焦点时，为系统内部事件提供原型分发器，将各种事件路由到它们的适当事件处理程序。
    </summary>
    <param name="oEvent">要处理的事件。</param>
    <seealso cref="T:VO.Event" />
    <returns>
      代表处理事件的事件处理程序的数值。
    </returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      MultiMediaContainer:Dispatch() 作为一个内部回调方法，将事件分发到各种事件处理程序。
      通常不需要直接调用这个方法。如果要处理额外的事件，通常应该为派生类编写自己的 Dispatch() 方法。
      通常，派生类的 Dispatch() 方法应该调用 SUPER:Dispatch()，以支持继承的事件处理。
      </remarks>
  </MultiMediaContainer.Dispatch>

  <MultiMediaContainer.FileName>
    <summary>
      包含多媒体数据的文件的名称，作为一个字符串。主要和次要的MIME类型是从文件扩展名派生的。
    </summary>
    <value>包含多媒体数据的文件的名称，作为一个字符串。主要和次要的MIME类型是从文件扩展名派生的。</value>
  </MultiMediaContainer.FileName>

  <MultiMediaContainer.MajorType>
    <summary>
      当前多媒体文件的主要MIME类型，例如，"image"。
    </summary>
    <value>当前多媒体文件的主要MIME类型，例如，"image"。</value>
  </MultiMediaContainer.MajorType>

  <MultiMediaContainer.MCISendMessage>
    <summary>
      向包含的 MCI 窗口发送 MCIWNDM_XXX 消息。
    </summary>
    <param name="dwMsg">消息ID。</param>
    <param name="wParam">第一个 SendMessage 参数，作为 DWORD。默认值为0。</param>
    <param name="lParam">第二个 SendMessage 参数，作为 LONG。默认值为0。</param>
    <returns>
      结果值(作为LONG)。
    </returns>
    <remarks>
      如果关联的文件包含视频或音频信息(例如，.AVI或.WAV文件)，MultiMediaContainer 类会创建一个 MCI 窗口。
      使用 MCISendMessage() 方法，您可以向这个窗口发送 Win32 SDK 帮助文档中记录的 MCIWNDM_XXX 消息。
      使用这些消息，您可以以编程方式改变窗口的外观和行为，播放多媒体数据等。 
      <note type="tip">
        请查阅 Microsoft Win32 软件开发工具包文档，了解有关 MCIWNDM_XXX 消息和命令的详细信息。
      </note>
    </remarks>
    <example> 
      这段代码片段开始播放视频或音频文件： 
      <code language="X#">
        oDCMM:MCISendMessage(MCIWNDM_PLAYFROM)
        </code>
      这段代码片段逐步推进数据： 
      <code language="X#">
        oDCMM:MCISendMessage(MCI_STEP, 0, 1)
      </code> 
      这段代码片段从窗口中移除工具栏： 
      <code language="X#">
        oDCMM:MCISendMessage(MCIWNDM_CHANGESTYLES, MCIWNDF_NOPLAYBAR, MCIWNDF_NOPLAYBAR)
      </code>
    </example>
  </MultiMediaContainer.MCISendMessage>

  <MultiMediaContainer.MinorType>
    <summary>
      当前多媒体文件的次要MIME类型，例如，"x-msvideo"。
    </summary>
    <value>当前多媒体文件的次要MIME类型，例如，"x-msvideo"。</value>
  </MultiMediaContainer.MinorType>

  <MultiMediaContainer.Size>
    <summary>
      定义控件大小的 Dimension 对象。
    </summary>
    <value>定义控件大小的 Dimension 对象。</value>
  </MultiMediaContainer.Size>

  <NamedArg>
    <summary>
      提供一个支持 OLE 命名参数的类。
    </summary>
    <remarks>
      OLE 支持命名参数的概念。在方法调用时，可以将 OLE 自动化服务器定义的参数名附加到实际参数值。
      这允许您以任何顺序传递参数，并且可以省略参数，因为服务器可以使用它们的名称唯一地识别参数。
      NamedArg 类用于模拟这种参数传递方式。
    </remarks>
    <example> 
      下面的示例显示了如何使用命名参数简化调用 Word.Application 类的 PrintOut 方法，该方法有很多参数。 
      <code language="X#">
        FUNCTION Start
            LOCAL oApp AS OBJECT
            LOCAL oDocs AS OBJECT
            LOCAL oDoc AS OBJECT
            ?
            oApp OleAutoObject{}
            oAppVisible TRUE
            oDocs oAppDocuments
            ?
            oDoc oDocsOpen
            ?
            oAppPrintOutNamedArg{#Background TRUE} ;
            NamedArg{#PrintToFile TRUE} ;
            NamedArg{#OutputFileName “C}
            
            DO WHILE oAppBackgroundPrintingStatus
                ?
                DoEvents
            ENDDO
            ?
            oDocCloseFALSE
            oAppQuit
            wait
            RETURN NIL
      </code>
    </example>
  </NamedArg>

  <NamedArg.ctor>
    <summary>
      构造一个 NamedArg 对象。
    </summary>
    <param name="symArgName">表示 OLE 参数名的符号。</param>
    <param name="uValue">指定参数的值。</param>
    <example> 
      这个示例显示了如何只传递 Point 参数给 FormatFont() 方法，这个方法通常需要超过15个参数： 
      <code language="X#">
        LOCAL o AS OLEAutoObject
        o: = OLEAutoObject{"Word.Basic"}
        o:FormatFont(NamedArg{#Points, 18})
      </code>
    </example>
  </NamedArg.ctor>

  <NamedArg.ArgName>
    <summary>
      表示命名参数的名称的符号。
    </summary>
    <value>表示命名参数的名称的符号。</value>
  </NamedArg.ArgName>

  <NamedArg.Value>
    <summary>
      命名参数的值。
    </summary>
    <value>命名参数的值。</value>
  </NamedArg.Value>

  <NumberFS>
    <summary>
      创建一个数字字段规范，它保存了数字数据类型的信息。
    </summary>
  </NumberFS>

  <NumberFS.ctor>
    <summary>
      构造一个数字字段规范。
    </summary>
    <param name="oHLName">包含字段名称和其他属性(即，标题，描述和帮助上下文)的超链接标签，用于创建新的数字字段规范。</param>
    <param name="uLength">字段的长度。如果没有指定，缺省值为12。</param>
    <param name="uDecimals">字段中的小数位数。如果没有指定，缺省值为2。</param>
  </NumberFS.ctor>

  <ObjCodeBlock>
    <exclude />
  </ObjCodeBlock>

  <ObjCodeBlock.ctor>
    <exclude />
  </ObjCodeBlock.ctor>

  <ObjCodeBlock.Eval>
    <exclude />
  </ObjCodeBlock.Eval>

  <OLEAppDocStorage>
    <summary>
      为 OLE 对象提供一个应用文档文件存储的封装。
    </summary>
    <remarks>
      每当一个 OLEObject 被插入到窗口编辑器中的表单中，OLE 对象的持久信息都会被存储在一个应用文档文件中。
      OLEAppDocStorage 类封装了一个应用文档文件。
    </remarks>
  </OLEAppDocStorage>

  <OLEAppDocStorage.ctor>
    <summary>
      构造一个 OLEAppDocStorage 对象。
    </summary>
    <param name="cDocFile">应用文档文件的名称。</param>
    <param name="cForm">表单的名称。</param>
    <param name="cObject">OLEObject 的名称。</param>
    <remarks>
      所有插入到窗口编辑器中的表单中的 OLE 对象都会被保存在一个特殊的文件中，这个文件被称为应用文档文件。
      当在运行时重新创建 OLE 对象时，持久信息会从应用文档文件中加载，使用 OLEObject:CreateFromAppDocStorage()。
    </remarks>
    <example> 
      下面的代码是由窗口编辑器生成的，用于从关联的应用文档文件中加载OLE对象： 
      <code language="X#">
        oDCOLEObject1:CreateFromAppDocStorage(OLEAppDocStorage{"C:\CAVO2x\DATA\Application 5.MDF", "dw", "OLEObject1"}
      </code>
    </example>
  </OLEAppDocStorage.ctor>

  <OLEAppDocStorage.DocFile>
    <summary>
      表示应用文档文件的名称的字符串。
    </summary>
    <value>表示应用文档文件的名称的字符串。</value>
  </OLEAppDocStorage.DocFile>

  <OLEAppDocStorage.Form>
    <summary>
      表示表单的名称的字符串。
    </summary>
    <value>表示表单的名称的字符串。</value>
  </OLEAppDocStorage.Form>

  <OLEAppDocStorage.OLEObject>
    <summary>
      表示 OLEObject 的名称的字符串。
    </summary>
    <value>表示 OLEObject 的名称的字符串。</value>
  </OLEAppDocStorage.OLEObject>

  <OLEAutoObject>
    <summary>
      提供一个类来定义 OLE 自动化服务器。
    </summary>
    <remarks>
      一个 OLE 自动化服务器在 X# 应用程序中通过这个类的实例表示。<br />
      可以在运行时使用这个类创建OLE自动化服务器，而不需要在编译时有关于特定服务器的任何信息。
      所有的自动化服务器的方法、属性和变量都可以通过 OLEAutoObject 对象访问。<br />
      OLE 自动化服务器的方法映射到 X# 方法，读取访问的属性和变量使用 Access 方法，写入访问的属性和变量使用 Assign 方法。<br />
      虽然在运行时动态创建自动化服务器通常非常方便，但你可能也想考虑使用IDE中的自动化服务器生成器为特定的自动化服务器生成基类。<br />
      生成的 OLE 自动化服务器基类继承自 OLEAutoObject，并为特定的服务器提供编译时信息，从而引入编译时检查并加快运行时方法调用的速度。<br />
      在内部，这个类使用一个方法描述对象数组(类型 cOleMethod)来存储 OLE 自动化服务器支持的属性和方法的描述。
    </remarks>
  </OLEAutoObject>

  <OLEAutoObject.ctor>
    <summary>
      构造一个 OLE 自动化服务器。
    </summary>
    <param name="ObjId">一个字符串，IDispatch 对象，接口指针或 OleAutoObject，指定自动化服务器。</param>
    <param name="nLangID">支持多语言的自动化服务器的语言ID。默认值为零。</param>
    <param name="lNoFuncArray">保留。默认值为FALSE。</param>
    <param name="fROTCheck">X# 是否应返回一个对已运行服务器的引用(TRUE)或创建服务器的新实例(FALSE)。默认值为 FALSE。</param>
    <remarks> 
      Init() 初始化一个 OLEAutoObject 并尝试将其链接到指定的自动化服务器。<br />
      通常，你会使用自动化服务器(OLE 定义的 PROGID)的名称作为字符串(例如，&lt;cServer&gt;)。
      但是，你也可以将其指定为 IDispatch 类的对象(例如，&lt;oIDispatch&gt;)。这是为了处理 OLE 自动化中的接口层次结构。<br />
      一个方法、属性或变量可能会返回一个 OLE 接口，它又表示一个具有自己的方法、属性和变量的自动化对象。<br />
      自动化类的调用逻辑会自动将返回的 OLE 自动化接口转换为一个新的 OLEAutoObject 对象，<br />
      首先创建一个 IDispatch 对象，然后创建一个新的 OLEAutoObject 对象，并将 IDispatch 对象传递给它的 Init() 方法。
      备用参数是一个 IDispatch 指针或一个 OleAutoObject。IDispatch 指针和 IDispatch 对象一样处理。
      当你传入一个 OleAutoObject 时，X# 会创建一个指向同一个 COM 接口的第二个 OleAutoObject。<br />
      X# 会确保引用计数调整以反映两个 VO 对象传递给同一个 OLE 对象的事实。<br />
      OLE 自动化服务器可能支持不同的语言来命名方法、属性和变量。
      所需的语言通过 <paramref name="nLangID" /> 参数指定。值零告诉服务器使用它的默认语言。<br />
      有关支持的语言、它们的标识符和默认语言的详细信息，请参阅你特定的自动化服务器的文档。
      <paramref name="lNoFuncArray" /> 参数必须被视为保留。<br />
      它只被 OLEAutoObject 的生成子类使用，以防止 Init() 方法创建 OLEAutoObject:aFuncDesc(一个包含自动化服务器的所有方法、属性和变量的描述的数组)。
      因为这个数组对于生成的 OLEAutoObject 的子类不是必需的，所以它们在调用 Init() 方法时使用这个参数的值为 TRUE。<br />
      默认值，通常使用的值，是 FALSE。
      <paramref name="fROTCheck" /> 参数确定 X# 是否会创建服务器的新实例，还是尝试查看服务器是否已经运行。
      默认行为是创建一个新的服务器(fROTCheck = FALSE)。<br />
      当你为这个参数指定 TRUE 时，X# 会检查 OLE Running Objects Table，并尝试通过调用 GetActiveObject() API 函数来附加到已经运行的服务器。
      当这个操作失败时，X# 会创建一个新的服务器。 
    </remarks>
    <example> 
      这个例子创建一个Word应用程序自动化服务器： 
      <code language="X#">
        FUNCTION Start()
            LOCAL oApp AS OBJECT
            LOCAL oDocs AS OBJECT
            LOCAL oDoc AS OBJECT

            ? "Starting Word"
            oApp := OleAutoObject{"Word.Application"}
            oApp:Visible := TRUE
            oDocs := oApp:Documents

            ? "Loading Document"
            oDoc := oDocs:Open("C:\Cavo28\whatsnew.rtf")

            ? "Printing Document"
            oApp:PrintOut(NamedArg{#Background, TRUE}, ;
            NamedArg{#PrintToFile, TRUE}, ;
            NamedArg{#OutputFileName, "C:\TEST.TXT"})

            DO WHILE oApp:BackgroundPrintingStatus != 0
                ? "."
                DoEvents()
            ENDDO

            ? "Closing WORD"
            oDoc:Close(FALSE)
            oApp:Quit()

            wait "Done"

            RETURN NIL
      </code>
    </example>
  </OLEAutoObject.ctor>

  <OLEAutoObject.aFuncDesc>
    <summary>
      注意 在 X# 2.7b1 中，这个访问已经不再可用。
    </summary>
    <value>注意 在 X# 2.7b1 中，这个访问已经不再可用。</value>
    <remarks>
      一个包含 OLE 自动化服务器的方法、属性和变量的描述的数组。这个数组只能由 OLEAutoObject 类使用，用户不能操纵它。
      这个数组只存在于 OLEAutoObject 类的实例中。继承自 OLEAutoObject 的生成的自动化服务器类不需要这个数组，因为方法信息是生成的，并且扩展到代码中。
      这个数组被用作一种哈希表。数组中的位置是根据方法或属性的名称计算的。数组中的元素是 cOleMethod 类的对象。这个类用于描述 OleAutoObject 的方法。
    </remarks>
  </OLEAutoObject.aFuncDesc>

  <OLEAutoObject.DateTimeAsDate>
    <summary>
      一个 OLE 日期实际上是一个 DateTime 组合，通常在 SQL 数据库中称为时间戳。
      这个 DateTime 组合不能存储在 DBF 日期字段中，也不被 Date FieldSpec 识别为一个有效的日期。<br />
      当返回一个 OLE 日期字段时，它是一个 OleDateTime 类的实例，可以从中提取值。
      但是，通过将 DateTimeAsDate 设置为 TRUE，所有的 OLE 日期都将以标准格式返回为 VO 日期。
    </summary>
    <value>
      一个 OLE 日期实际上是一个 DateTime 组合，通常在 SQL 数据库中称为时间戳。
      这个 DateTime 组合不能存储在 DBF 日期字段中，也不被 Date FieldSpec 识别为一个有效的日期。<br />
      当返回一个 OLE 日期字段时，它是一个 OleDateTime 类的实例，可以从中提取值。
      但是，通过将 DateTimeAsDate 设置为 TRUE，所有的 OLE 日期都将以标准格式返回为 VO 日期。
    </value>
  </OLEAutoObject.DateTimeAsDate>

  <OLEAutoObject.Destroy>
    <summary>
      提供一个方法来取消实例化一个 OLE 自动化服务器。
    </summary>
    <remarks>
      OLEAutoObject:Destroy() 关闭一个 OLE 自动化会话，并释放与之关联的所有数据。
      这个方法由 OLEAutoObject:Axit() 自动调用，后者由垃圾收集器触发，但你也可以直接调用 OLEAutoObject:Destroy()，如下面的例子所示。
    </remarks>
    <example> 
      这个例子展示了如何在完成对自动化服务器的工作后销毁它： 
      <code language="X#">
        LOCAL o AS OLEAutoObject
        o := OLEAutoObject{"Word.Basic"}
        //
        // Work with automation object
        //
        // Shut down
        o:Destroy()
      </code>
    </example>
  </OLEAutoObject.Destroy>

  <OLEAutoObject.dwFuncs>
    <summary>
      OLE 自动化服务器定义的方法的数量。
    </summary>
    <value>OLE 自动化服务器定义的方法的数量。</value>
  </OLEAutoObject.dwFuncs>

  <OLEAutoObject.dwVars>
    <summary>
      OLE 自动化服务器的属性和变量的数量。
    </summary>
    <value>OLE 自动化服务器的属性和变量的数量。</value>
  </OLEAutoObject.dwVars>

  <OLEAutoObject.fInit>
    <summary>
      OLEAutoObject 对象的实例化并不意味着 OLE 自动化已经成功启动。<br />
      例如，将一个自动化应用程序从一个 PC 移动到另一个 PC，如果新 PC 上没有安装 OLE 自动化服务器，那么应用程序会出现故障。
      在这种情况下，如果在实例化后尝试使用 OLEAutoObject，会导致运行时错误。<br />
      创建对象后，OLEAutoObject:fInit 让你检查 OLE 自动化服务器是否已经成功初始化。<br />
      如果 OLE 自动化服务器已经成功初始化，它会返回 TRUE；否则，它会返回 FALSE。
    </summary>
    <value>
      OLEAutoObject 对象的实例化并不意味着 OLE 自动化已经成功启动。<br />
      例如，将一个自动化应用程序从一个 PC 移动到另一个 PC，如果新 PC 上没有安装 OLE 自动化服务器，那么应用程序会出现故障。
      在这种情况下，如果在实例化后尝试使用 OLEAutoObject，会导致运行时错误。<br />
      创建对象后，OLEAutoObject:fInit 让你检查 OLE 自动化服务器是否已经成功初始化。<br />
      如果OLE自动化服务器已经成功初始化，它会返回 TRUE；否则，它会返回 FALSE。
    </value>
    <example> 
      这个例子在实例化后如果无法成功初始化自动化服务器，会显示一个错误消息： 
      <code language="X#">
        LOCAL o AS OLEAutoObject
        o := OLEAutoObject{"Word.Basic"}
        IF !o:fInit
            MessageBox(0, "Error initializing automation server", "Error", 0)
        RETURN
        ENDIF
      </code>
    </example>
  </OLEAutoObject.fInit>

  <OLEAutoObject.No>
    <summary> 
      提供一个自动调用的一般错误拦截，每当对一个不存在的方法进行引用时。 <br />
      重要！NoMethod() 不应该直接调用；它是由系统自动调用来处理无效引用的。 
    </summary>
  </OLEAutoObject.No>

  <OLEAutoObject.NoIVarGet>
    <summary> 
      提供一个自动调用的一般错误拦截，每当对一个不存在的访问属性进行引用时。 
      <include file="Gui.xml" path="doc/NoIVar/*" />
    </summary>
    <param name="symIVar">被引用的变量的符号名称。</param>
  </OLEAutoObject.NoIVarGet>

  <OLEAutoObject.NoIVarPut>
    <summary> 
      提供一个自动调用的一般错误拦截，每当对一个不存在的赋值属性进行引用时。 
      <include file="Gui.xml" path="doc/NoIVar/*" />
    </summary>
    <param name="symIVar">被引用的变量的符号名称。</param>
    <param name="uValue">要赋值的值。</param>
  </OLEAutoObject.NoIVarPut>

  <OLEAutoObjectFromFile>
    <summary>
      提供一个类来从文件创建一个 OLE 自动化服务器。
    </summary>
    <remarks>
      <b style="color:red">重要！</b>为了使这个类工作，自动化服务器必须实现 IPersistFile 接口——大多数自动化服务器都没有。
      OLEAutoObjectFromFile 类让你从一个文件创建一个自动化服务器对象。
      OLE 会确定一个特定文件属于哪个自动化服务器，并自动启动服务器并在其中打开文件。 
    </remarks>
  </OLEAutoObjectFromFile>

  <OLEAutoObjectFromFile.ctor>
    <summary>
      从文件创建一个 OLE 自动化服务器。
    </summary>
    <param name="cFName">要从中创建 OLE 自动化服务器的文件的名称。</param>
    <param name="nLangID">支持多语言的自动化服务器的语言ID。默认值为零。</param>
    <remarks> 
      Init() 初始化一个 OLEAutoObjectFromFile，并尝试将其链接到文件 <paramref name="cFName" /> 注册的自动化服务器。<br />
      OLE 自动化服务器可能支持不同的语言来命名方法、属性和变量。
      所需的语言通过 <paramref name="nLangID" /> 参数指定。值零告诉服务器使用它的默认语言。<br />
      有关支持的语言、它们的标识符和默认语言的详细信息，请参阅你特定的自动化服务器的文档。<br />
      重要！为了使这个类工作，自动化服务器必顶部实现 IPersistFile 接口——大多数自动化服务器都没有。
    </remarks>
  </OLEAutoObjectFromFile.ctor>

  <OLEAutoObjectFromFile.cFileName>
    <summary>
      一个表示自动化服务器绑定的文件的文件名的字符串。
    </summary>
    <value>一个表示自动化服务器绑定的文件的文件名的字符串。</value>
  </OLEAutoObjectFromFile.cFileName>

  <OLEAutoObjectFromFile.Destroy>
    <summary>
      提供一个方法来取消实例化一个 OLE 自动化服务器。
    </summary>
    <remarks>
      OLEAutoObjectFromFile:Destroy() 关闭一个 OLE 自动化会话，并释放与之关联的所有数据。
      这个方法由 OLEAutoObject:Axit() 自动调用，后者由垃圾收集器触发，但你也可以直接调用 OLEAutoObjectFromFile:Destroy()。
    </remarks>
  </OLEAutoObjectFromFile.Destroy>

  <OleBinary>
    <summary>
      提供一个类来支持将二进制信息传递给 Ole 服务器
    </summary>
    <remarks> 
      这个类用于将二进制信息传递给 OleServer，比如文件的内容。
      在大多数情况下，Ole Server 会期望一个字节数组。VO 会为每个 OleBinary 参数生成一个字节数组。 
      <note type="tip">
        VO 2.8 SP2 引入了这个类。然而：这个补丁没有附带一个新的存储库，所以你不能直接引用这个类，而必须使用 CreateInstance() 语法。
      </note>
    </remarks>
    <example> 
      下面的例子显示了如何使用OleBinary对象将二进制文件的内容传递给一个服务器 
      <code language="X#">
        LOCAL oServer AS OBJECT
        LOCAL cData AS STRING
        oServer := OleAutoObject{"Some.Server"}
        cData := MemoRead("MyFile.bin")
        oServer:Upload("MyFile.bin", CreateInstance(#OleBinary, cData))
      </code>
    </example>
  </OleBinary>

  <OleBinary.ctor>
    <summary>
      构造一个 NamedArg 对象。
    </summary>
    <param name="uValue">
      这可以是一个字符串、SafeArray 或另一个 OleBinary 对象。<br />
      如果传入的是 SafeArray，那么类会创建 SafeArray 的一个克隆。你仍然是原始 SafeArray 的所有者。<br />
      如果传入的是 OleBinary，那么它会克隆该对象。
    </param>
  </OleBinary.ctor>

  <OleBinary.AsString>
    <summary>
      返回 OleBinary 对象的字符串表示当类型已知时，它可以是一个文本，比如'Word文档'或'位图'。否则，它是从内容中的十六进制转储
    </summary>
  </OleBinary.AsString>

  <OleBinary.ProgId>
    <summary>
      当类能够确定二进制信息的内容时，这个访问返回内容中的 ProgId。
    </summary>
    <value>当类能够确定二进制信息的内容时，这个访问返回内容中的 ProgId。</value>
  </OleBinary.ProgId>

  <OleBinary.SafeArray>
    <summary>
      这设置/返回存储在该对象中的 SafeArray 的副本。
    </summary>
    <value>这设置/返回存储在该对象中的 SafeArray 的副本。</value>
    <remarks>
      <note type="tip">
        如果你调用这个访问，你就要负责销毁 SafeArray
        如果你分配一个新的 SafeArray，那么对象会创建这个 SafeArray 的一个克隆。你仍然是原始 SafeArray 的所有者。
      </note>
    </remarks>
  </OleBinary.SafeArray>

  <OleBinary.Value>
    <summary>
      读取/更新对象的内容作为一个字符串。
    </summary>
    <value>读取/更新对象的内容作为一个字符串。</value>
  </OleBinary.Value>

  <OLEControl>
    <summary>
      提供一个容器和包装器，用于 OLE 控件(OCX)。
    </summary>
    <remarks>
      OLEControl 类实现了 OLE 控件(OCX，ActiveX)的包装器和容器。<br />
      OLE 控件基本上是一个带有附加自动化接口的 OLE 对象，通过这个接口，你可以编程 OCX 并设置事件处理程序来处理OLE控件实例化的事件。
      为了满足第一个要求，OLEControl 从 OLEObject 派生，因此继承了 OLEObject 的所有功能。<br />
      自动化接口由 OLEAutoObject 提供，它是 OLEControl 的一个受保护的成员变量，使用 OLEControl:InitAutoObject() 初始化。
    </remarks>
  </OLEControl>

  <OLEControl.CreateEmbedding>
    <summary>
      从程序ID创建一个 OLE 控件。
    </summary>
    <param name="cProgID">OLE 控件的程序ID。</param>
    <param name="cLicKey">OLE 控件程序的许可证密钥。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      由 OLE 服务器提供的每个对象都是通过其程序ID唯一标识的。<br />
      这些程序ID存储在系统注册表中，如 OLE 服务器的文档中所述。
      OLEControl:CreateEmbedding() 从其程序ID创建一个嵌入式 OLE 控件，并将其加载到 OLEControl 容器中。
    </remarks>
    <example> 
      下面的代码在一个已经存在的 OLEControl 容器上的数据窗口中，通过创建一个具有程序ID Word.Document.6的对象来响应按钮点击事件： 
      <code language="X#">
        METHOD PushButton1() CLASS dw
            oDCOLEControl1:CreateEmbedding("Word.Document.6")
      </code>
    </example>
  </OLEControl.CreateEmbedding>

  <OLEControl.CreateFromAppDocStorage>
    <summary>
      从应用程序文档文件存储创建一个 OLE 控件。
    </summary>
    <param name="oOLEAppDocStorage">包含对象的 OLEAppDocStorage 对象。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      在窗口编辑器中插入到表单中的所有 OLE 控件都保存在一个特殊的文件中，称为应用程序文档文件。
      当在运行时重新创建 OLE 控件时，将从应用程序文档文件中使用 OLEControl:CreateFromAppDocStorage() 加载的持久信息，包括 OLEAutoObject。
    </remarks>
  </OLEControl.CreateFromAppDocStorage>

  <OLEControl.Destroy>
    <summary>
      提供一个方法来取消实例化一个 OLEControl 对象。
    </summary>
    <param name="oEvent">要处理的事件。</param>
    <seealso cref="T:VO.Event" />
    <remarks>
      当不再需要一个 OLEControl 对象时，可以使用这个方法。<br />
      OLEControl:Destroy() 取消实例化 OLEControl 对象，并允许你关闭和释放由对象打开或创建的所有资源，而不必等待垃圾收集器。
      关联的OLE控件会自动关闭，OLE 控件的服务器会关闭，除非它正在为其他客户端提供服务。
    </remarks>
  </OLEControl.Destroy>

  <OLEControl.Dispatch>
    <summary>
      当控件获得焦点时，提供系统内部事件的原型分发程序；将各种事件路由到它们适当的事件处理程序。
    </summary>
    <param name="oEvent">要处理的事件。</param>
    <seealso cref="T:VO.Event" />
    <returns>
      如果事件被处理，返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      OLEControl:Dispatch() 作为一个内部回调，将事件分派到各种事件处理程序。
      通常不需要直接调用这个方法。如果你想处理其他事件，你可以为派生类编写自己的 Dispatch() 方法。
      通常，派生类的 Dispatch() 应该调用 SUPER:Dispatch()，以支持继承的事件处理。
    </remarks>
  </OLEControl.Dispatch>

  <OLEControl.InitAutoObject>
    <summary>
      初始化 OLEAutoObject。
    </summary>
    <returns>
      SELF
    </returns>
    <remarks>
      在创建 OLE 控件后，必须初始化 OLEAutoObject。OLEControl:CreateFromAppDocStorage() 会自动完成这个过程。
      但是，如果你使用其他 Create 方法，确保使用 OLEControl:InitAutoObject() 正确初始化 OLEAutoObject。
    </remarks>
  </OLEControl.InitAutoObject>

  <OLEControl.No>
    <summary> 
      提供一个通用的错误拦截，当引用一个不存在的方法时，系统会自动调用它。 <br />
      重要！不应该直接调用 NoMethod()；系统会自动调用它来处理无效的引用。 
    </summary>
  </OLEControl.No>

  <OLEDataWindow>
    <summary>
      创建一个能够承载 OLE 对象的数据窗口。
    </summary>
    <remarks>
      注意：这个类的方法中的功能现在已经合并到 DataWindow 类和 Window 类中。类名仅保留为向后兼容，但它的所有方法都已经移动到父类之一
      一个 OLE 数据窗口是一个通过一些功能增强的常规数据窗口，用于支持 OLE 对象。
    </remarks>
  </OLEDataWindow>

  <OLEDataWindow.ctor>
    <summary>
      注意：这个方法中的功能现在已经合并到 Window 类。<br />
      构造一个 OLE 数据窗口。
    </summary>
    <param name="oOwner">
      拥有 OLE 数据窗口的窗口。<br />
      以下窗口类型可以是所有者：App、ShellWindow、TopAppWindow、ChildAppWindow、DialogWindow、DataDialog，或另一个 DataWindow。<br />
      OLE 数据窗口的行为由其所有者的类型决定。
    </param>
    <param name="oSource"> 
      定义 OLE 数据窗口布局的资源的ID。或者指定子数据窗口的位置和大小的资源ID。<br />
      指定这个参数会在其所有者数据窗口上创建一个新的OLE数据窗口作为子数据窗口(只有数据窗口所有者可以有子数据窗口)。 
      它应该引用其所有者数据窗口的资源实体中定义的一个控件。 <br />
      如果省略 <paramref name="oSource" /> 或者 <paramref name="oOwner" /> 不是数据窗口，数据窗口会作为一个模态 DialogWindow 创建。 
    </param>
    <param name="nResourceID">** 缺少参数文档 **</param>
    <remarks>
      一个 OLE 数据窗口是一个增强的数据窗口，可以用来承载 OLE 对象。它提供了 OLE 对象所需的附加功能。<br />
      有关更多详细信息，请参阅 OLEDataWindow 类的特定方法。
    </remarks>
  </OLEDataWindow.ctor>

  <OLEDataWindow.DeActivate>
    <summary> 
      注意：这个方法中的功能现在已经合并到 Window 类。 提供一个在 OLE 数据窗口被停用时调用的方法。 <br />
      重要！Deactivate() 是 X# 使用的一个回调方法。通常，不应该在应用程序代码中调用它。
    </summary>
    <param name="oEvent">需要一个空事件，以维持所有事件处理程序都有一个事件作为参数的协议。</param>
    <seealso cref="T:VO.Event" />
    <remarks>
      这个事件处理程序通常在另一个应用程序或窗口被激活时调用。<br />
      默认情况下，OLEDataWindow 上的所有 OLE 对象控件都会被停用。<br />
      如果 Window:MouseTrapOn() 保持打开状态，那么鼠标事件就不能被定向到其他应用程序或窗口。
    </remarks>
  </OLEDataWindow.DeActivate>

  <OLEDataWindow.DeactivateAllOLEObjects>
    <summary>
      注意：这个方法中的功能现在已经合并到 Window 类。<br />
      停用所有当前活动的 OLE 对象。
    </summary>
    <remarks>
      DeactivateAllOLEObjects() 方法会停用任何当前(就地)活动的 OLE 对象。每当数据窗口本身被停用时，这个方法就会自动调用。
    </remarks>
  </OLEDataWindow.DeactivateAllOLEObjects>

  <OLEDataWindow.MouseButtonDown>
    <summary>
      注意：这个方法中的功能现在已经合并到 Window 类。<br />
      提供一个在鼠标指针位于窗口上并且点击了鼠标按钮时调用的事件处理程序。
    </summary>
    <param name="oMouseEvent">包含鼠标按钮点击时鼠标状态信息的MouseEvent对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      默认情况下，这个方法会在处理 MouseEvent 之前停用窗口上的所有 OLE 对象控件。<br />
      使用 Window:MouseTrapOn() 方法可以强制将在画布区域外生成的 MouseEvent 定向到这个窗口。
    </remarks>
  </OLEDataWindow.MouseButtonDown>

  <OLEDataWindow.Notify>
    <summary> 
      注意：这个方法中的功能现在已经合并到 DataWindow 类。 提供一个反映连接到 OLE 数据窗口的服务器中发生的事件的事件处理程序。 <br />
      重要！Notify() 是由服务器自动调用的，通常不应该由应用程序代码调用。
    </summary>
    <returns> 
      SELF，除非对 <paramref name="kNotifyName" /> 指定了 NOTIFYINTENTTOMOVE。在这种情况下，如果成功，返回 TRUE；否则，返回 FALSE。
    </returns>
    <include file="VOSDK.xml" path="doc/commonblocks/notify/*" />
  </OLEDataWindow.Notify>

  <OLEDataWindow.UpdateActiveObject>
    <summary>
      注意：这个方法中的功能现在已经合并到 DataWindow 类。<br />
      更新任何就地活动的 OLE 对象的工具栏。
    </summary>
    <remarks>
      OLEDataWindow:UpdateActiveObject() 会调用 OLE 数据窗口包含的任何当前激活的 OLE 对象的 UpdateTools() 方法。
      它首先确定哪个 OLE 对象控件是就地活动的，然后用 OLE 服务器的工具栏替换 X# 容器应用程序的工具栏。
      在响应容器应用程序的调整大小时，这个方法会导致 OLE 对象服务器重新排列其工具栏。
    </remarks>
  </OLEDataWindow.UpdateActiveObject>

  <OLEDataWindow.ViewAs>
    <summary>
      注意：这个方法中的功能现在已经合并到 DataWindow 类。<br />
      指定 OLE 数据窗口的视图模式，可以是浏览视图或表单视图。
    </summary>
    <param name="symViewMode">
      指定要使用的视图模式。使用以下符号之一：
      <list>
        <item>
          <term>符号</term>
          <description>描述</description>
        </item>
        <item>
          <term>#BrowseView</term>
          <description>多个记录同时显示，作为电子表格中的行，每个字段对应一个列。</description>
        </item>
        <item>
          <term>#FormView</term>
          <description>一次只显示一个记录，其字段在单独的控件中显示。</description>
        </item>
      </list>
    </param>
    <remarks>
      当窗口切换到新的视图模式时，如果之前没有定义布局，会自动生成一个布局。<br />
      由于它需要一个参数，所以 OLEDataWindow:ViewAs() 很少直接与按钮或菜单命令连接；
      而是使用从 DataWindow 继承的 OLEDataWindow:ViewForm() 和 OLEDataWindow:ViewTable() 方法。<br />
      除了 DataWindow 基类提供的功能，OLEDataWindow 类的实现还会在更改视图时停用任何激活的 OLE 对象。
    </remarks>
  </OLEDataWindow.ViewAs>

  <OleDateTime>
    <summary>
      提供一个封装 OLE 对象使用的 DateTime 值。
    </summary>
    <remarks>
      OLE 日期是日期和时间的组合，有时在 SQL 数据库中被称为时间戳。OleDateTime 类提供了一种让 X# 封装这种类型的值的方法。
    </remarks>
  </OleDateTime>

  <OleDateTime.ctor>
    <summary>
      构造一个 OleDateTime 对象。
    </summary>
    <param name="uDate">这可以作为一个数字或 VO 日期传递。</param>
    <remarks>
      OleDateTime 类有两种初始化方式：<br />
      - 使用 VO 日期，此时时间部分设置为00:00:00.00<br />
      - 使用数字，此时整数被视为从1899年12月30日到指定日期的天数。小数部分被视为一天的一部分，用于设置对象的时间部分。
    </remarks>
  </OleDateTime.ctor>

  <OleDateTime.AsReal8>
    <summary>
      返回 DateTime 值作为 Real8(COM中使用的格式)。
    </summary>
  </OleDateTime.AsReal8>

  <OleDateTime.AsString>
    <summary>
      返回 DateTime 值作为字符串。
    </summary>
  </OleDateTime.AsString>

  <OleDateTime.DateVal>
    <summary>
      DateTime 对象的日期部分的值，作为一个 Date。
    </summary>
    <value>DateTime 对象的日期部分的值，作为一个 Date。</value>
  </OleDateTime.DateVal>

  <OleDateTime.TimeString>
    <summary>
      DateTime 对象的时间部分的值，作为一个字符串。
    </summary>
    <value>DateTime 对象的时间部分的值，作为一个字符串。</value>
  </OleDateTime.TimeString>

  <OleDateTime.TimeVal>
    <summary>
      DateTime 对象的时间部分的数值，作为一个 Float。
    </summary>
    <value>DateTime 对象的时间部分的数值，作为一个 Float。</value>
  </OleDateTime.TimeVal>

  <OLEDBStorage>
    <summary>
      提供一个数据库存储的封装，用于 OLE 对象。
    </summary>
    <remarks>
      X# 支持在 DBF 数据库中存储 OLE 对象的能力。<br />
      要为 OLEObject 容器分配一个新值，您需要将一个 OLEDBStorage 对象传递给 OLEObject:CreateFromDBStorage()。<br />
      要在数据库中保存 OLE 对象，您需要将一个 OLEDBStorage 对象传递给 OLEObject:SaveToDBStorage()。
      通常，您会在 FieldGet() 调用的结果中获得 OLEDBStorage 对象。
    </remarks>
  </OLEDBStorage>

  <OLEDBStorage.ctor>
    <summary>
      构造一个 OLEDBStorage 对象。
    </summary>
    <param name="ptrRootStg">指向根存储的指针。</param>
    <param name="cSubStgName">表示子存储名称的字符串。</param>
    <remarks>
      OLEDBStorage 对象通常是 FieldGet() 调用的结果。通常不需要直接调用此方法。
    </remarks>
  </OLEDBStorage.ctor>

  <OLEDBStorage.RootStorage>
    <summary>
      指向根存储对象的指针。
    </summary>
    <value>指向根存储对象的指针。</value>
    <remarks>
      <br />重要！此属性仅用于内部目的，不应直接使用。 
    </remarks>
  </OLEDBStorage.RootStorage>

  <OLEDBStorage.SubStorageName>
    <summary>
      表示对象子存储名称的字符串。
    </summary>
    <value>表示对象子存储名称的字符串。</value>
    <remarks>
      <br />重要！此属性仅用于内部目的，不应直接使用。 
    </remarks>
  </OLEDBStorage.SubStorageName>

  <OLEDragEvent>
    <summary>
      存储有关 OLE 拖放事件的信息。
    </summary>
    <remarks>
      使用 ChildAppWindow:EnableOLEDropTarget() 注册为 OLE 拖放目标的窗口可以处理 OLE 拖放事件，并在响应这些事件时创建新的 OLE 对象。
      在关联的处理程序中，可以通过将 OLEDragEvent 对象作为参数传递给 OLEObject:CreateFromOLEDragEvent() 来创建一个新的 OLE 对象。
    </remarks>
  </OLEDragEvent>

  <OleDragEvent.ctor>
    <summary>
      构造一个 OLEDragEvent。
    </summary>
    <param name="DragInfo">指向 DRAGINFO 结构的指针。</param>
  </OleDragEvent.ctor>

  <OleDragEvent.DataObject>
    <summary>
      指向 OLE 对象数据的指针。
    </summary>
    <value>指向 OLE 对象数据的指针。</value>
  </OleDragEvent.DataObject>

  <OleDragEvent.Effect>
    <summary>
      指示拖放操作的效果的常量：
    </summary>
    <value>指示拖放操作的效果的常量：</value>
    <remarks> 
      以下常量之一，指示拖放操作的效果： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>DROPEFFECT_COPY</term>
          <description>复制操作</description>
        </item>
        <item>
          <term>DROPEFFECT_LINK </term>
          <description>
            创建一个新的链接
          </description>
        </item>
        <item>
          <term>DROPEFFECT_MOVE </term>
          <description>移动操作</description>
        </item>
        <item>
          <term>DROPEFFECT_NONE </term>
          <description>无效果</description>
        </item>
      </list>
      OLEDragEvent:Effect 控制拖放操作的鼠标光标外观，并可以在处理 OLEDragEvent 时设置。 
    </remarks>
  </OleDragEvent.Effect>

  <OleDragEvent.ObjectName>
    <summary>
      表示 OLE 对象名称的字符串。通过检查对象和/或服务器名称，容器应用程序可以有选择地允许或禁止特定对象或服务器作为拖放源。
    </summary>
    <value>表示 OLE 对象名称的字符串。通过检查对象和/或服务器名称，容器应用程序可以有选择地允许或禁止特定对象或服务器作为拖放源。</value>
  </OleDragEvent.ObjectName>

  <OleDragEvent.Position>
    <summary>
      指定事件位置的 Point 对象。
    </summary>
    <value>指定事件位置的 Point 对象。</value>
  </OleDragEvent.Position>

  <OleDragEvent.ServerName>
    <summary>
      表示 OLE 服务器名称的字符串。通过检查对象和/或服务器名称，容器应用程序可以有选择地允许或禁止特定对象或服务器作为拖放源。
    </summary>
    <value>表示 OLE 服务器名称的字符串。通过检查对象和/或服务器名称，容器应用程序可以有选择地允许或禁止特定对象或服务器作为拖放源。</value>
  </OleDragEvent.ServerName>

  <OLEInterface>
    <summary>
      提供 OLE 自动化的内部实现的基类。
    </summary>
    <remarks>
      <br />重要！此类仅用于内部实现，不应直接使用。 
    </remarks>
  </OLEInterface>

  <OLEObject>
    <summary>
      提供一个 OLE 对象的容器和封装。
    </summary>
    <remarks>
      OLEObject 类充当 OLE 对象的容器和封装，由 OLE 服务器提供并由其管理。<br />
      OLEObject 本身只是一个窗口控件，可以容纳一个 OLE 对象。
      OLE 对象是通过 Create 方法之一(例如 OLEObject:CreateFromPasteDialog() 或 OLEObject:CreateFromAppDocStorage())创建的。
      一些属性，如 OLEObject:AllowInPlace，控制 OLEObject 的基本行为。<br />
      请注意，OLEObject 是由 X# 提供的一个类，而 OLE 对象是由其服务器提供的，并且“生活”在 OLEObject 容器中。<br />
      使用 OLEObject:DetachFromServer()，可以销毁当前的 OLE 对象，但可以通过再次调用 Create 方法来重用同一个 OLEObject 容器。
    </remarks>
  </OLEObject>

  <OLEObject.ctor>
    <summary>
      构造一个 OLEObject。
    </summary>
    <param name="oOwner">拥有 OLEObject 的窗口。</param>
    <param name="nID">OLEObject 的唯一ID，介于1和8000之间。</param>
    <param name="nResourceID">OLEObject 的资源ID。</param>
    <param name="oPoint">OLEObject 在画布坐标中的原点。</param>
    <param name="oDimension">OLEObject 在画布坐标中的尺寸。</param>
    <param name="lDataAware">一个逻辑值，如果 OLEObject 是数据感知的，则为 TRUE，否则为 FALSE。</param>
    <example> 
      以下代码是由 Window Editor 生成的。它首先从资源创建一个 OLEObject 容器，然后分配一个 HyperLabel，最后从应用程序文档文件加载 OLE 对象： 
      <code language="X#">
        oDCOLEObject1 := OLEObject{SELF, ;
                                  ResourceID{DW_OLEOBJECT1, _GetInst()}}
                                  oDCOLEObject1:HyperLabel := HyperLabel{#OLEObject1, ;
                                  NULL_STRING, NULL_STRING, NULL_STRING}

        oDCOLEObject1:CreateFromAppDocStorage(OLEAppDocStorage{ ;
                                              "C:\CAVO2x\DATA\Application 5.MDF", "dw", "OLEObject1"})
      </code>
    </example>
  </OLEObject.ctor>

  <OLEObject.Activate>
    <summary>
      激活 OLE 对象。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      该方法将关联的 OLE 对象置于活动状态，通常允许用户编辑对象。
    </remarks>
    <example> 
      以下代码显示了一个按钮的单击事件处理程序，该处理程序激活了位于相同数据窗口上的 OLEObject： 
      <code language="X#">
        METHOD PushButton1() CLASS dw
            oDCOLEObject1:Activate("Word.Document.6")
      </code>
    </example>
  </OLEObject.Activate>

  <OLEObject.ActivateOnDblClk>
    <summary>
      一个逻辑值，如果通过双击激活 OLE 对象，则为 TRUE，否则为 FALSE。此属性的默认值为 TRUE。
    </summary>
    <value>一个逻辑值，如果通过双击激活 OLE 对象，则为 TRUE，否则为 FALSE。此属性的默认值为 TRUE。</value>
  </OLEObject.ActivateOnDblClk>

  <OLEObject.AddVerbMenu>
    <summary>
      将 OLE 对象的动作菜单插入到现有菜单中。
    </summary>
    <param name="hMenu">现有菜单的句柄。</param>
    <param name="iPos">应该插入菜单的位置。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      一个 OLE 对象通常支持用户可以对对象执行的几个操作(称为动作)。
      例如，AVI 对象可以支持 Play 和 Edit 动作。
      对象的动作可以通过其动作菜单调用，该菜单使用 OLEObject:AddVerbMenu() 添加到现有菜单中，并由对象完全管理。
    </remarks>
    <example> 
      以下代码将动作菜单插入到容器应用程序的ID为1的弹出菜单的第二个位置。
      请注意，MDI 子窗口的系统菜单在最大化时会计为单独的弹出菜单： 
      <code language="X#">
        LOCAL hObjMenu AS PTR

        IF oParent:IsZoomed()
            hObjMenu := oParent:Menu:GetSubMenu(2)
        ELSE
            hObjMenu := oParent:Menu:GetSubMenu(1)
        ENDIF

        SELF:AddVerbMenu(hObjMenu, 2)
      </code>
    </example>
  </OLEObject.AddVerbMenu>

  <OLEObject.AllowInPlace>
    <summary>
      如果激活 OLE 对象(无论是通过调用 OLEObject:Activate() 还是通过双击对象)，服务器通常会将对象置于编辑模式。
      此编辑可以在 X# 容器应用程序内(原地激活)或在服务器管理的单独窗口中(出处激活)进行。
      在原地激活期间，服务器的和容器的菜单和工具栏会合并，对象可以在容器的用户界面上下文中编辑。
      OLEObject:AllowInPlace 是一个逻辑值，如果允许在原地激活对象，则为 TRUE，否则为 FALSE。此属性的默认值为 FALSE。 
      <note type="tip">
        即使 OLEObject:AllowInPlace 为 TRUE，服务器也可以拒绝原地激活。
      </note>
    </summary>
    <value>
      如果激活 OLE 对象(无论是通过调用 OLEObject:Activate() 还是通过双击对象)，服务器通常会将对象置于编辑模式。
      此编辑可以在 X# 容器应用程序内(原地激活)或在服务器管理的单独窗口中(出处激活)进行。
      在原地激活期间，服务器的和容器的菜单和工具栏会合并，对象可以在容器的用户界面上下文中编辑。
      OLEObject:AllowInPlace 是一个逻辑值，如果允许在原地激活对象，则为 TRUE，否则为 FALSE。此属性的默认值为 FALSE。
      即使OLEObject:AllowInPlace 为 TRUE，服务器也可以拒绝原地激活。
    </value>
  </OLEObject.AllowInPlace>

  <OLEObject.AllowResize>
    <summary>
      一个逻辑值，如果 OLE 对象在运行时可调整大小和移动，则为 TRUE。此属性的默认值为 FALSE。
    </summary>
    <value>一个逻辑值，如果 OLE 对象在运行时可调整大小和移动，则为 TRUE。此属性的默认值为 FALSE。</value>
  </OLEObject.AllowResize>

  <OLEObject.AutoSizeOnCreate>
    <summary>
      一个逻辑值，确定 OLE 对象的初始大小是否由对象的服务器控制。
      如果 OLEObject:AutoSizeOnCreate 为 TRUE，Create 方法会请求对象的服务器提供首选对象大小。
      如果这个大小是有意义的，OLEObject 容器会调整自身大小。此属性的默认值为 TRUE。
    </summary>
    <value>
      一个逻辑值，确定 OLE 对象的初始大小是否由对象的服务器控制。
      如果 OLEObject:AutoSizeOnCreate 为 TRUE，Create 方法会请求对象的服务器提供首选对象大小。
      如果这个大小是有意义的，OLEObject 容器会调整自身大小。此属性的默认值为 TRUE。
    </value>
  </OLEObject.AutoSizeOnCreate>

  <OLEObject.CreateEmbedding>
    <summary>
      从程序ID创建一个 OLE 对象。
    </summary>
    <param name="cProgID">OLE 对象的程序ID。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      每个由 OLE 服务器提供的对象都是通过其程序ID唯一标识的。
      这些程序ID存储在系统注册表中，如 OLE 服务器的文档中所述。
      OLEObject:CreateEmbedding() 从其程序ID创建一个嵌入式 OLE 对象，并将其加载到 OLEObject 容器中。
    </remarks>
    <example> 
      以下代码在按钮点击时响应，通过在数据窗口上的已存在的 OLEObject 容器中创建一个具有程序ID Word.Document.6 的对象： 
      <code language="X#">
        METHOD PushButton1() CLASS dw
            oDCOLEObject1:CreateEmbedding("Word.Document.6")
      </code>
    </example>
  </OLEObject.CreateEmbedding>

  <OLEObject.CreateEmbeddingFromFile>
    <summary>
      从文件创建一个 OLE 对象。
    </summary>
    <param name="cFileName">包含对象的文件。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      如果一个 OLE 对象是作为文件(如保存的文档)给出的，您可以使用 OLEObject:CreateEmbeddingFromFile() 创建一个嵌入式OLE对象，
      并将其加载到其 OLEObject 容器中。
    </remarks>
    <example> 
      以下代码在按钮点击时响应，从文件\WINWORD\SAMPLE.DOC创建一个对象： 
      <code language="X#">
        METHOD PushButton1() CLASS dw
            oDCOLEObject1:CreateEmbeddingFromFile("\WINWORD\SAMPLE.DOC")
      </code>
    </example>
  </OLEObject.CreateEmbeddingFromFile>

  <OLEObject.CreateFromAppDocStorage>
    <summary>
      从应用程序文档文件存储创建一个 OLE 对象。
    </summary>
    <param name="oOLEAppDocStorage">包含对象的 OLEAppDocStorage 对象。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      在 Window Editor 中插入到表单中的所有 OLE 对象都保存在一个特殊的文件中，称为应用程序文档文件。
      当在运行时重新创建 OLE 对象时，将从应用程序文档文件中的持久信息使用 OLEObject:CreateFromAppDocStorage() 加载。
    </remarks>
    <example> 
      以下代码是由 Window Editor 生成的，用于从关联的应用程序文档文件加载 OLE对象。 
      <code language="X#">
        oDCOLEObject1:CreateFromAppDocStorage(OLEAppDocStorage{"C:\CAVO25\DATA\Application 5.MDF", "dw", "OLEObject1"})
      </code>
    </example>
  </OLEObject.CreateFromAppDocStorage>

  <OLEObject.CreateFromDBStorage>
    <summary>
      从数据库存储创建一个 OLE 对象。
    </summary>
    <param name="oOLEDBStorage">描述数据库存储的 OLEDBStorage 对象。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      X# 支持在 DBF 数据库中存储 OLE 对象的能力。
      要为 OLEObject 容器分配一个新值，您需要将一个 OLEDBStorage 对象传递给 OLEObject:CreateFromDBStorage()。
      要在数据库中保存 OLE 对象的持久信息，您需要将一个 OLEDBStorage 对象传递给 OLEObject:SaveToDBStorage()。
      通常，您会在 FieldGet() 调用的结果中获得 OLEDBStorage 对象。
    </remarks>
    <example> 
      以下代码显示了如何使用从 FieldGet() 调用中接收的 OLEDBStorage 对象来创建一个 OLE 对象，并将其插入到 OLEObject 容器中： 
      <code language="X#">
        LOCAL oDBStg AS OLEDBStorage
        oDBStg := FieldGet(FieldPos(#PaintObject))
        oOLEContainer:CreateFromDBStorage(oDBStg)
      </code>
    </example>
  </OLEObject.CreateFromDBStorage>

  <OLEObject.CreateFromInsertDialog>
    <summary>
      从标准的插入对象对话框创建一个 OLE 对象。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      OLEObject:CreateFromInsertDialog() 会打开标准的插入对象对话框，允许用户选择一个对象类型，然后使用该类型创建一个新的 OLE 对象，
      并将其加载到此 OLEObject 容器中。
    </remarks>
    <example>
      以下代码首先实例化一个新的 OLEObject 容器，然后使用 OLEObject:CreateFromInsertDialog() 为容器创建一个 OLE 对象。
      如果 OLE 对象创建失败，例如因为用户点击了对话框的取消按钮，那么 OLEObject 容器将被销毁：
      <code language="X#">
        LOCAL oOLE AL OLEObject
        oOLE              := DraggableOLEObject{SELF}
        oOLE:AllowInPlace := TRUE
        oOLE:AllowResize  := TRUE

        IF oOLE:CreateFromInsertDialog()
            oOLE:Show()
            oOLE:SetFocus()
        ELSE
            oOLE:Destroy()
        ENDIF
      </code>
    </example>
  </OLEObject.CreateFromInsertDialog>

  <OLEObject.CreateFromOLEDragEvent>
    <summary>
      从 OLEDragEvent 创建一个 OLE 对象。
    </summary>
    <param name="oOLEDragEvent">OLEDragEvent 对象。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      使用 ChileAppWindow:EnableOLEDropTarget() 注册为 OLE 拖放目标的窗口可以处理 OLE 拖放事件，并在响应这些事件时创建新的 OLE 对象。
      在关联的处理程序中，可以通过将 OLEDragEvent 对象作为参数传递给 OLEObject:CreateFromOLEDragEvent() 来创建一个新的 OLE 对象。
    </remarks>
    <example> 
      以下代码将数据窗口启用为拖放目标，并在其 OLEDrop 处理程序中创建一个新的 OLE 对象。它还检查 OLE 对象的名称，只允许 WordPad 文档： 
      <code language="X#">
        METHOD EnableOLEDropTarget CLASS DropTargetDataWindow
            SELF:EnableOLEDropTarget(TRUE)

        METHOD OLEDrop(oOLEDragEvent) CLASS MyChild
            LOCAL oOLE AS OLEObject
            LOCAL lRet AS LOGIC

            IF oOLEDragEvent:ObjectName == "WordPad Document"
                oOLE              := OLEObject{SELF}
                oOLE:AllowInPlace := TRUE
                oOLE:AllowResize  := TRUE

                IF oOLE:CreateFromOLEDragEvent(oOLEDragEvent)
                    oOLE:Origin := oOLEDragEvent:Position
                    oOLE:Show()
                    oOLE:SetFocus()
                ENDIF
            ENDIF
      </code>
    </example>
  </OLEObject.CreateFromOLEDragEvent>

  <OLEObject.CreateFromPasteDialog>
    <summary>
      从标准的粘贴特殊对话框创建一个 OLE 对象。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      OLEObject:CreateFromPasteDialog() 会打开标准的粘贴特殊对话框，允许用户从剪贴板中选择一个对象，
      然后使用该对象创建一个新的 OLE 对象，并将其加载到此 OLEObject 容器中。
    </remarks>
    <example>
      以下代码首先实例化一个新的 OLEObject 容器，然后使用 OLEObject:CreateFromPasteDialog() 为容器创建一个 OLE 对象。
      如果 OLE 对象创建失败，例如因为用户点击了对话框的取消按钮，那么 OLEObject 容器将被销毁：
      <code language="X#">
        LOCAL oOLE AS OLEObject
        oOLE              := DraggableOLEObject{SELF}
        oOLE:AllowInPlace := TRUE
        oOLE:AllowResize  := TRUE

        IF oOLE:CreateFromPasteDialog()
            oOLE:Show()
            oOLE:SetFocus()
        ELSE
            oOLE:Destroy()
        ENDIF
      </code>
      DataWindow:PasteSpecial(), OLEObject:CreateEmbedding(), OLEObject:CreateEmbeddingFromFile(),
      OLEObject:CreateFromAppDocStorage(), OLEObject:CreateFromDBStorage(),
      OLEObject:CreateFromInsertDialog(), OLEObject:CreateFromOLEDragEvent(), OLEObject:CreateLink() 
    </example>
  </OLEObject.CreateFromPasteDialog>

  <OLEObject.CreateLink>
    <summary>
      创建一个 OLE 对象，作为一个到文件的链接。
    </summary>
    <param name="cFileName">包含 OLE 对象的文件的名称。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      链接的 OLE 对象存储在容器的存储之外。这允许其他应用程序也可以使用和更改 OLE 对象。
      OLEObject:CreateLink() 会创建一个新的链接的 OLE 对象，并将其加载到此 OLEObject 容器中。
    </remarks>
    <example> 
      以下代码将一个链接的 OLE 对象从一个文本文档创建到一个 OLEObject 中： 
      <code language="X#">
        oMyTextObject:CreateLink("\WINWORD\SAMPLE.DOC")
      </code>
    </example>
  </OLEObject.CreateLink>

  <OLEObject.Deactivate>
    <summary>
      停用一个 OLE 对象。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <example> 
      以下代码显示了一个按钮的点击事件处理程序，该处理程序停用了位于相同数据窗口上的一个 OLEObject： 
      <code language="X#">
        METHOD PushButton1() CLASS dw
            oDCOLEObject1:Deactivate("Word.Document.6")
      </code>
    </example>
  </OLEObject.Deactivate>

  <OLEObject.Destroy>
    <summary>
      提供一个方法来取消实例化一个 OLEObject。
    </summary>
    <remarks>
      当不再需要一个 OLEObject 对象时，可以使用这个方法。
      OLEObject:Destroy() 会取消实例化 OLEObject 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
      关联的 OLE 对象会自动关闭，除非它正在为其他客户端提供服务。
    </remarks>
  </OLEObject.Destroy>

  <OLEObject.DetachFromServer>
    <summary>
      移除一个包含的 OLE 对象，并切断与其服务器的链接。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      由于 OLEObject 作为任何 OLE 对象的容器，因此可以通过使用 Create 方法之一，删除当前对象，切断对象的服务器的链接，
      并在容器中加载一个新的 OLE 对象。在这个过程中，OLEObject:DetachFromServer() 会移除当前的 OLE 对象，并切断对象的服务器的链接。
    </remarks>
  </OLEObject.DetachFromServer>

  <OLEObject.Dispatch>
    <summary>
      为系统内部的事件提供原型调度程序，当控件具有焦点时，将各种事件路由到它们的适当事件处理程序。
    </summary>
    <param name="oEvent">要处理的事件。</param>
    <seealso cref="T:VO.Event" />
    <returns>
      如果事件被处理，返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      OLEObject:Dispatch() 作为内部回调，将事件分派到各种事件处理程序。通常不需要直接调用此方法。
      如果要处理其他事件，可以为派生类编写自己的 Dispatch() 方法。通常，派生类的 Dispatch() 应该调用 SUPER:Dispatch()，以支持继承的事件处理。
    </remarks>
  </OLEObject.Dispatch>

  <OLEObject.DoVerb>
    <summary>
      执行 OLE 对象的动作。
    </summary>
    <param name="iVerb">动作的数字ID。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      一个 OLE 对象通常支持用户可以对对象执行的几个动作(称为动词)。例如，AVI 对象可以支持播放和编辑动作。
      可以通过对象的动词菜单或直接调用 OLEObject:DoVerb() 来调用对象的动词。
    </remarks>
  </OLEObject.DoVerb>

  <OLEObject.ExportToStorage>
    <summary>
      将一个 OLE 对象导出到用户管理的存储文件。
    </summary>
    <param name="cFileName">存储文件的名称。</param>
    <param name="cStorageName">存储的名称。</param>
    <example> 
      以下示例来自\CAVO25\SAMPLES\OLE\CONT中的 OLE 容器应用程序： 
      <code language="X#">
        METHOD FileSave() CLASS Container
            LOCAL oOle AS OBJECT
            LOCAL oOD AS SaveAsDialog
            LOCAL i AS INT
            LOCAL s AS STRING
            (oOD := SaveAsDialog{SELF, "*.CDF"}):Show()
            s := oOD:FileNAme

            IF !Empty(oOD:FileName)
                SELF:Caption := oOD:FileName

                FOR i:= 1 TO ALen(aOLEObjects)
                    oOle := aOLEObjects[i]
                    oOle:ExportToStorage(oOd:FileName, "CONTAINEROBJECT_"+AllTrim(AsString(i)))
                NEXT
            ENDIF
      </code>
    </example>
  </OLEObject.ExportToStorage>

  <OLEObject.HyperLabel>
    <summary>
      OLE 对象的 HyperLabel 对象。
    </summary>
    <value>OLE 对象的 HyperLabel 对象。</value>
  </OLEObject.HyperLabel>

  <OLEObject.ImportFromStorage>
    <summary>
      从用户管理的存储文件导入一个 OLE 对象。
    </summary>
    <param name="cFileName">存储文件的名称。</param>
    <param name="cStorageName">存储的名称。</param>
    <example> 
      以下示例来自\CAVO25\SAMPLES\OLE\CONT中的 OLE 容器应用程序： 
      <code language="X#">
        METHOD FileLoad() CLASS ContainerShell
            LOCAL oOle AS DraggableOleObject
            LOCAL oOD AS OpenDialog
            LOCAL aStgNames AS ARRAY
            LOCAL i AS INT
            LOCAL oCont AS Container
            (oOD := OpenDialog{SELF, "*.CDF"}):Show()
            aStgNames := {}

            IF (!Empty(oOD:FileName) .and. GetStorageNames(oOD:FileName, aStgNames))
                oCont := SELF:FileNew()
                oCont:Caption := oOD:FileName

                IF (oCont != NULL_OBJECT)
                    FOR i:=1 TO ALen(aStgNames)
                        oOle := DraggableOleObject{oCont}

                        IF (oOle:ImportFromStorage(oOD:Filename, aStgNames[i]))
                            oCont:SetupOLEObject(oOle, NIL, TRUE)
                        ELSE
                            oOle:Destroy()
                        ENDIF
                    NEXT
                ENDIF
            ENDIF
      </code>
    </example>
  </OLEObject.ImportFromStorage>

  <OLEObject.IsInPlaceActive>
    <summary>
      一个逻辑值，指示关联的 OLE 对象的激活状态。
    </summary>
    <value>一个逻辑值，指示关联的 OLE 对象的激活状态。</value>
  </OLEObject.IsInPlaceActive>

  <OLEObject.LongName>
    <summary>
      容器应用程序可以询问 OLE 对象的长和短版本的对象名称，以及其服务器的名称。OLEObject:LongName 返回对象名称的长版本。
    </summary>
    <value>容器应用程序可以询问 OLE 对象的长和短版本的对象名称，以及其服务器的名称。OLEObject:LongName 返回对象名称的长版本。</value>
  </OLEObject.LongName>

  <OLEObject.No>
    <summary> 
      提供一个通用的错误拦截，每当引用一个不存在的方法时，系统会自动调用它。 <br />
      重要！不应直接调用 NoMethod()；系统会调用它来处理无效的引用。 </summary>
  </OLEObject.No>

  <OLEObject.NoIVarGet>
    <summary> 
      提供一个通用的错误拦截，每当对不存在的访问属性进行访问引用时，系统会自动调用它。 
      <include file="Gui.xml" path="doc/NoIVar/*" />
    </summary>
    <param name="symIVar">被引用的变量的符号名称。</param>
  </OLEObject.NoIVarGet>

  <OLEObject.NoIVarPut>
    <summary> 提供一个通用的错误拦截，每当对不存在的分配属性进行分配引用时，系统会自动调用它。 <include file="Gui.xml" path="doc/NoIVar/*" />
    </summary>
    <param name="symIVar">被引用的变量的符号名称。</param>
    <param name="uValue">要分配的值。</param>
  </OLEObject.NoIVarPut>

  <OLEObject.ReadOnly>
    <summary>
      一个逻辑值，如果 OLE 对象是只读的，则为 TRUE。只读对象不能在运行时由用户编辑。此属性的默认值为 FALSE。
    </summary>
    <value>一个逻辑值，如果 OLE 对象是只读的，则为 TRUE。只读对象不能在运行时由用户编辑。此属性的默认值为 FALSE。</value>
  </OLEObject.ReadOnly>

  <OLEObject.Redraw>
    <summary>
      使 OLE 对象重新绘制自己。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </OLEObject.Redraw>

  <OLEObject.Repaint>
    <summary>
      使 OLE 对象无效，以便向对象发送 ExposeEvent。
    </summary>
    <remarks>
      ExposeEvent 触发 OLEObject 容器及其包含的 OLE 对象的重绘。
    </remarks>
  </OLEObject.Repaint>

  <OLEObject.SaveToDBStorage>
    <summary>
      将 OLE 对象保存到数据库存储。
    </summary>
    <param name="oOLEDBStorage">用于保存操作的 OLEDBStorage 对象。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      X# 支持在 DBF 数据库中存储 OLE 对象的能力。
      要为 OLEObject 容器分配一个新值，您需要将一个 OLEDBStorage 对象传递给 OLEObject:CreateFromDBStorage()。
      要在数据库中保存 OLE 对象的持久信息，您需要将一个 OLEDBStorage 对象传递给 OLEObject:SaveToDBStorage()。
      通常，您会在 FieldGet() 调用的结果中获得 OLEDBStorage 对象。
    </remarks>
    <example> 
      以下代码显示了如何从数据库加载一个 OLE 对象并将其保存回去： 
      <code language="X#">
        LOCAL oDBStg AS OLEDBStorage
        oDBStg := FieldGet(FieldPos(#PaintObject))
        oOLEContainer:CreateFromDBStorage(oDBStg)
        // 对OLE对象进行一些编辑
        oOLEContainer:SaveToDBStorage(oDBStg)
      </code>
    </example>
  </OLEObject.SaveToDBStorage>

  <OLEObject.ServerName>
    <summary>
      容器应用程序可以询问 OLE 对象的长和短版本的对象名称，以及其服务器的名称。OLEObject:ServerName 返回 OLE 对象的服务器名称。
    </summary>
    <value>容器应用程序可以询问 OLE 对象的长和短版本的对象名称，以及其服务器的名称。OLEObject:ServerName 返回 OLE 对象的服务器名称。</value>
  </OLEObject.ServerName>

  <OLEObject.SetHostNames>
    <summary>
      设置容器应用程序和当前文档的名称。
    </summary>
    <param name="cApp">容器应用程序的名称。</param>
    <param name="cDoc">当前文档的名称。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      在服务器的窗口中进行原地编辑时，这些名称用于标识 OLE 对象容器应用程序和其所在的文档。
    </remarks>
  </OLEObject.SetHostNames>

  <OLEObject.ShortName>
    <summary>
      容器应用程序可以询问 OLE 对象的长和短版本的对象名称，以及其服务器的名称。OLEObject:ShortName 返回 OLE 对象的短版本名称。
    </summary>
    <value>容器应用程序可以询问 OLE 对象的长和短版本的对象名称，以及其服务器的名称。OLEObject:ShortName 返回 OLE 对象的短版本名称。</value>
  </OLEObject.ShortName>

  <OLEObject.UpdateTools>
    <summary>
      更新容器的工具栏。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      每当 OLE 对象处于原地激活状态时，服务器的工具栏可以替换 X# 容器应用程序的工具栏。
      在响应容器应用程序的调整大小时，OLEObject:UpdateToolbars() 会导致 OLE 对象服务器重新排列其工具栏。
    </remarks>
    <example> 
      以下代码显示了 X# 容器应用程序如何在调整大小事件中使用 OLEObject:UpdateToolbars()： 
      <code language="X#">
        METHOD Resize(oResizeEvent) CLASS MyShell
            LOCAL oOLE AS OBJECT
            LOCAL oChild AS MyChild

            SUPER:Resize(oResizeEvent)
            oChild := SELF:GetActiveMDIChildObject()

            IF oChild != NULL_OBJECT
                oOLE := oChild:GetActiveOLEObject()

                IF oOLE != NULL_OBJECT
                    oOLE:UpdateTools()
                ENDIF
            ENDIF
      </code>
    </example>
  </OLEObject.UpdateTools>

  <OLEShellWindow>
    <summary>
      创建一个包含对原地激活 OLE 对象的支持的专用外壳窗口。
    </summary>
    <remarks>
      注意：此类的方法中的功能现已合并到 ShellWindow 类中。仅为向后兼容而保留类名。
    </remarks>
  </OLEShellWindow>

  <OLEShellWindow.ctor>
    <summary>
      注意 -<br />
      构造一个 OLE 外壳窗口。
    </summary>
    <param name="oOwner">拥有 OLE 外壳窗口的窗口。</param>
  </OLEShellWindow.ctor>

  <OLEShellWindow.Dispatch>
    <summary>
      注意 -<br />

      为系统内具有焦点的 OLE 外壳窗口提供原型调度程序，将各种事件路由到其适当的事件处理程序。
    </summary>
    <param name="oEvent">要处理的事件。</param>
    <seealso cref="T:VO.Event" />
    <returns>
      如果事件已处理，则返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      此方法作为内部回调，将事件分派到各种事件处理程序。通常不需要直接调用此方法。<br />
      如果要处理其他事件，可以为派生类编写自己的 Dispatch() 方法。
      通常，派生类的 Dispatch() 方法应该调用 SUPER:Dispatch()，以支持继承的事件处理。<br />
      除了 ShellWindow 基类提供的功能外，OLEShellWindow 类的实现还包括对处理原地激活 OLE 对象的支持。
      例如，每当调整大小时，外壳窗口会自动要求激活的 OLE 对象更新其工具栏。
    </remarks>
  </OLEShellWindow.Dispatch>

  <OpenDialog>
    <summary>
      向用户显示标准的“文件打开”对话框。
    </summary>
    <remarks>
      这种类型的对话框向用户显示一个文件名列表。它允许用户从列表中选择一个名称(或输入一个现有文件的名称)，并在必要时指定驱动器和/或目录。
      如果用户输入的文件名不存在，Windows 会显示一个模态对话框，指示指定驱动器、目录和文件类型的文件名不存在。
    </remarks>
  </OpenDialog>

  <OpenDialog.ctor>
    <summary>
      构造一个标准的“文件打开”对话框。
    </summary>
    <param name="oOwnWnd">拥有对话框的窗口。</param>
    <param name="cInitPath">首次显示对话框时选择的文件的名称(例如*.*或*.TXT)。默认值是*.*，表示所有文件及其扩展名。</param>
    <param name="dwFlag">保留供将来使用。</param>
    <remarks>
      <note type="tip">
        如果要使用:SetFilter() 方法，必须将 cFileName 指定为""，因为如果不这样做，过滤器将不起作用，而是使用默认的"*.*"，这样就会显示所有文件。
      </note>
    </remarks>
  </OpenDialog.ctor>

  <Pair>
    <summary>
      提供所有 X# 对象的基类，这些对象包含有序对的值。
    </summary>
    <remarks>
      <br />重要！Pair 是一个抽象类，不应直接使用，而应使用它的子类之一，包括 Dimension、Point、Range 和 Selection。 
    </remarks>
    <example> 
      在这个例子中，分数被表示为整数的有序对： 
      <code language="X#">
        CLASS Fraction INHERIT Pair
            HIDDEN Num
            HIDDEN Denom

            METHOD Init(nVal1,nVal2) CLASS Fraction
                SUPER:Init(nVal1,nVal2)
                Num := nVal1
                Denom := nVal2

            METHOD Numerator() CLASS Fraction
                RETURN SELF:Num

            METHOD Denominator() CLASS Fraction
                RETURN SELF:Denom
      </code>
    </example>
  </Pair>

  <Pair.ctor>
    <summary>
      构造一个有序对。
    </summary>
    <param name="uInt1">有序对的第一个值。默认值为0。</param>
    <param name="uInt2">有序对的第二个值。默认值为0。</param>
    <param name="Int1">有序对的第一个值。默认值为0。</param>
    <param name="Int2">有序对的第二个值。默认值为0。</param>
  </Pair.ctor>

  <PaletteDialog>
    <summary>
      向用户显示标准的颜色调色板对话框，允许用户定义自定义颜色。
    </summary>
    <remarks>
      这种类型的对话框向用户显示一系列可用颜色的调色板，以“盒子”的形式。用户可以通过点击一个盒子来选择颜色。
      它还允许用户创建和选择自定义颜色。
    </remarks>
  </PaletteDialog>

  <PaletteDialog.ctor>
    <summary>
      构造一个标准的颜色调色板对话框。
    </summary>
    <param name="uOwner">拥有调色板对话框的窗口。</param>
    <param name="oColor">PaletteDialog 对象初始选择的颜色。默认值是黑色。(有关指定颜色的详细信息，请参阅 Color:Init() 方法。)</param>
  </PaletteDialog.ctor>

  <Pen>
    <summary>
      创建一个笔，它可以用来以特定颜色、样式和宽度绘制线条。笔由 Window:LineTo() 方法和 DrawObject 层次结构使用。
    </summary>
    <remarks>
      X# 提供了一组预定义的笔，这些笔在 Pen:Init() 方法中指定(使用默认颜色和宽度)。此外，如果需要，还可以通过指定颜色、线样式和宽度来创建笔。
      每个窗口都有一个当前笔，可以使用 Window:Pen 属性设置或更改。窗口的笔在后续的线条和矩形绘制操作中使用，并且在它是当前选择时不应该被删除。
    </remarks>
    <example> 
      以下示例创建一个笔并绘制一条线： 
      <code language="X#">
        oMyPen      := Pen{Color{COLORRED}, LINESOLID, 1}
        oOldPen     := oMyWin:Pen
        oMyWin:Pen  := oMyPen
        oMyWin:MoveTo(Point{100,100})
        oMyWin:LineTo(Point{200,100})
        oMyWin:Pen  := oOldPen
      </code>
    </example>
  </Pen>

  <Pen.ctor>
    <summary>
      构造一个笔。
    </summary>
    <param name="uColor">笔的颜色。默认值是黑色。(有关指定颜色的详细信息，请参阅 Color:Init() 方法。)</param>
    <param name="uLineStyle">
      笔的样式，指定为以下常量之一：
    </param>
    <param name="uWidth">笔的宽度，以画布坐标表示。默认值是1。</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>LINECLEAR</term>
          <description>
            不可见，可以简化程序逻辑。
            这是一个快捷方式，可以在不调用 MoveTo() 和 LineTo() 函数的情况下改变点的位置(如在Pen类的代码示例中)。
          </description>
        </item>
        <item>
          <term>LINEDASHDOT</term>
          <description>交替的破折号/点模式。</description>
        </item>
        <item>
          <term>LINEDASHDOTDOT</term>
          <description>一个由破折号后跟两个点组成的重复序列。</description>
        </item>
        <item>
          <term>LINEDASHED</term>
          <description>破折号。</description>
        </item>
        <item>
          <term>LINEDOTTED</term>
          <description>点。</description>
        </item>
        <item>
          <term>LINESOLID</term>
          <description>连续的线。这是默认值。</description>
        </item>
      </list>
    </remarks>
  </Pen.ctor>

  <Pen.Destroy>
    <summary>
      提供一种方法来取消实例化一个 Pen 对象。
    </summary>
    <remarks>
      当不再需要一个 Pen 对象时，可以使用这个方法。Pen:Destroy() 取消实例化 Pen 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </Pen.Destroy>

  <Pen.Handle>
    <summary>
      返回一个笔的句柄。
    </summary>
    <param name="uType">
      所需句柄的类型。如果省略 nHandle 参数，0是唯一支持的选项，也是默认值。
    </param>
    <returns>
      描述底层系统对象的句柄。
    </returns>
    <remarks>
      此方法提供了一个 Windows GDI 对象的句柄，可以通过 Windows API GDI 调用使用。
    </remarks>
  </Pen.Handle>

  <PieObject>
    <summary>
      构造一个 PieObject 对象。
    </summary>
  </PieObject>

  <PieObject.ctor>
    <summary>
      构造一个 PieObject 对象。
    </summary>
    <param name="oPoint">PieObject 对象在画布坐标中的位置。</param>
    <param name="oDimension">PieObject 对象在画布坐标中的尺寸。</param>
    <param name="oPen">用于绘制 PieObject 对象的笔。默认情况下，使用当前笔。</param>
    <param name="oBrush">用于填充 PieObject 对象的刷子。默认情况下，使用当前刷子。</param>
    <param name="iStartAngle">饼形形状的起始角度(0到360度)。</param>
    <param name="iEndAngle">饼形形状的结束角度(0到360度)。</param>
  </PieObject.ctor>

  <PieObject.Draw>
    <summary>
      绘制一个 PieObject 对象，它表示椭圆的一个扇形部分。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      这个方法不应该在应用程序代码中直接调用--它是由 Window:Draw() 在 X# 中调用的。 
    </remarks>
    <example> 
      若要绘制一个 PieObject 对象，调用 Window:Draw()，并将 PieObject 对象作为参数。窗口通过询问每个对象来绘制自己--例如： 
      <code language="X#">
        METHOD Expose(oEvent) CLASS MyWindow
            LOCAL oPie AS OBJECT

            oPie := PieObject{Point{10,10},;
                              Dimension{20,40},;
                              Pen{Color{COLORBLACK}},;
                              Brush{Color{COLORRED}}, 0, 180}
            SELF:Draw(oPie)
      </code>
    </example>
  </PieObject.Draw>

  <Point>
    <summary>
      创建一个点，用于描述窗口画布上的位置。
    </summary>
    <remarks>
      Point类不解释坐标--它们是屏幕还是画布坐标取决于上下文。
    </remarks>
    <example>
      有关使用 Point 类的示例，请参考 ResourceFile 类的示例。
    </example>
  </Point>

  <Point.ctor>
    <summary>
      构造一个点。
    </summary>
    <param name="nX">点的x坐标。默认值为0。</param>
    <param name="nY">点的y坐标。默认值为0。</param>
  </Point.ctor>

  <Point.ConvertToScreen>
    <exclude />
  </Point.ConvertToScreen>

  <Point.X>
    <summary>
      代表这个点的x坐标的整数。
    </summary>
    <value>代表这个点的x坐标的整数。</value>
  </Point.X>

  <Point.Y>
    <summary>
      代表这个点的y坐标的整数。
    </summary>
    <value>代表这个点的y坐标的整数。</value>
  </Point.Y>

  <Pointer>
    <summary>
      创建一个鼠标指针，用于在窗口中视觉上表示鼠标。
    </summary>
    <remarks>
      X# 提供了一组预定义的指针，定义在 Pointer:Init() 中。此外，如果需要，还可以从资源实体创建指针。<br />
      每个窗口都可以有自己的指针，可以设置、更改或查询各种指针特性。
      当指针从一个窗口的画布区域移动到另一个窗口时，GUI 会将指针表示更改为新窗口的表示。<br />
      提示：在 X# 中，Pointer 类对应于鼠标指针；使用 Cursor 类创建文本指针。
    </remarks>
    <example> 
      以下示例为应用窗口提供了一个自定义指针： 
      <code language="X#">
        CLASS MyTopAppWin INHERIT TopAppWindow
            METHOD Init CLASS MyTopAppWin
                SUPER:Init()
                SELF:Pointer := Pointer{IDC_APPCURSOR}
                RESOURCE IDC_APPCURSOR CURSOR app.cur
      </code>
      在Windows中，指针有时被称为鼠标指针。您可以在资源实体中创建一个指针。 
    </example>
  </Pointer>

  <Pointer.ctor>
    <summary>
      从资源实体加载一个指针。
    </summary>
    <param name="xResourceID">
      所需指针的资源ID。
      如果省略 nHandle 参数，0是唯一支持的选项，也是默认值。
    </param>
    <remarks>
      <list>
        <item>
          <term>Pointer</term>
          <description>描述</description>
        </item>
        <item>
          <term>POINTERARROW</term>
          <description>通常用于选择和指向对象的指针。这是默认值。</description>
        </item>
        <item>
          <term>POINTERCROSSHAIRS</term>
          <description>通常用于选择和绘制图形对象的指针。</description>
        </item>
        <item>
          <term>POINTERFOURARROW</term>
          <description>通常用于移动对象的指针。</description>
        </item>
        <item>
          <term>POINTERHOURGLASS</term>
          <description>通常用于指示延迟的指针。</description>
        </item>
        <item>
          <term>POINTERIBEAM</term>
          <description>通常用于文本输入的指针。</description>
        </item>
        <item>
          <term>POINTERICON</term>
          <description>用于移动图标的指针。</description>
        </item>
        <item>
          <term>POINTERUPARROW</term>
          <description>通常用于将选择拖动到新位置并“放置”或插入的指针。</description>
        </item>
      </list>
      <note type="tip">由 POINTERICON 资源ID指定的图标会呈现为正在移动的图标的外观。</note>
    </remarks>
  </Pointer.ctor>

  <Pointer.Confine>
    <summary>
      将这个指针的移动限制在一组给定的屏幕坐标中。
    </summary>
    <param name="oRect">表示指针可以移动的屏幕坐标集合的边界框。</param>
  </Pointer.Confine>

  <Pointer.Destroy>
    <summary>
      提供一种方法来取消实例化一个 Pointer 对象。
    </summary>
    <remarks>
      当不再需要一个 Pointer 对象时，可以使用这个方法。
      Pointer:Destroy() 取消实例化 Pointer 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </Pointer.Destroy>

  <Pointer.Handle>
    <summary>
      返回一个指针的句柄。
    </summary>
    <param name="nHandleType">
      所需句柄的类型。如果省略 nHandle 参数，0是唯一支持的选项，也是默认值。
    </param>
    <returns>
      描述底层系统对象的句柄。
    </returns>
    <remarks>
      此方法提供了一个 Windows GDI 对象的句柄，可以通过 Windows API GDI 调用使用。
    </remarks>
  </Pointer.Handle>

  <Pointer.Hide>
    <summary>
      隐藏这个指针，使其不可见。隐藏一个控件，使其不可见(直到后续调用 Pointer:Show())。
    </summary>
    <remarks>
      对 Pointer:Hide() 的多次调用需要对 Pointer:Show() 的多次调用，才能重新显示指针。
    </remarks>
  </Pointer.Hide>

  <Pointer.Position>
    <summary>
      一个点，表示这个指针在窗口上的位置，以屏幕坐标表示。
    </summary>
    <value>一个点，表示这个指针在窗口上的位置，以屏幕坐标表示。</value>
    <remarks>
      一个点，表示这个指针在窗口上的位置，以屏幕坐标表示。
      或者，您可以使用 Window 类的 MouseMove() 或 MouseDrag() 事件处理程序，并使用 Where() 来获取指针在屏幕坐标中的位置。
    </remarks>
  </Pointer.Position>

  <Pointer.Show>
    <summary>
      显示一个指针，使其可见。
    </summary>
    <remarks> 
      默认情况下，指针总是可见的，直到隐藏，因此不需要调用 Pointer:Show() 方法，除非之前调用了 Pointer:Hide()。 
      <note type="tip">
        对 Pointer:Hide() 的多次调用需要对 Pointer:Show() 的多次调用，才能重新显示指针。
      </note>
    </remarks>
  </Pointer.Show>

  <Printer>
    <summary>
      创建一个表示单个打印作业的对象。
    </summary>
    <remarks>
      在使用之前，必须检查 Printer 对象的有效性--使用 Printer:IsValid()。<br />
      要使用打印机，应用程序应该调用 Printer:Start()，它会重复调用 Printer:PrinterExpose()，直到打印的最后一页，最后一页返回 FALSE。Printer:Start() 在打印作业完成时返回。<br />
      您还可以：<br />
      使用 Window:CanvasArea 和 Window:WindowArea 确定页面的大小，分别返回可打印区域的大小和总页面大小<br />
      使用 Window:Size 缩放打印输出<br />
      使用 Window:Origin 确定原点(例如，创建边距)<br />
      只有当打印机存在于您的打印机中时，X# 才会打印正确的字体；否则，将使用最相似的字体。<br />
      打印是在打印机坐标中完成的，这是设备相关的。使用这里描述的方法来缩放和调整打印输出的大小。还要注意，对于业务打印，如管理报告、发票和通知信函，
      通常更方便的方法是使用 Report Editor 设计报告，然后使用 ReportQueue 类运行报告。<br />
      有关更多信息，请参阅程序员指南。
    </remarks>
    <example> 
      下面的示例打印文本“Hello World”： 
      <code language="X#">
        METHOD PrinterExpose(oPEE) CLASS PrinterClass
            SELF:TextPrint("Hello World",Point{30,30})
            RETURN FALSE // 没有更多要打印的内容

        CLASS PrinterClass INHERIT Printer
            METHOD Init() CLASS PrinterClass
                SUPER:Init()
                RETURN SELF

        METHOD MenuCommand(oMCE) CLASS StandardShellWindow
            LOCAL oPrinter AS PrinterClass

            IF(oMCE:ItemID = ;
                IDM_EMPTYSHELLMENU_FILE_PRINT_ID)
                // File Print menu item ID
                oPrinter := PrinterClass{}

                IF(oPrinter:IsValid())
                    oPrinter:Start()
                    oPrinter:Destroy()
                ENDIF
            ENDIF
      </code>
    </example>
  </Printer>

  <Printer.ctor>
    <summary>
      构造一个打印作业。
    </summary>
    <param name="cJobname">传递给 Print Manager 的名称，一个 Windows 应用程序，用于标识打印作业。如果省略，默认为 NULL_STRING。</param>
    <param name="oDevice">要使用的打印设备。如果省略，用户通过 Windows 安装的当前选择的打印机是默认打印机。</param>
  </Printer.ctor>

  <Printer.Abort>
    <summary>
      指示打印机中止当前的打印作业。
    </summary>
    <remarks>
      通常，您会在开始打印作业之前创建和显示一个对话框。如果用户在对话框窗口上按下一个按钮来取消作业，Window:ButtonClick() 事件处理程序会调用这个方法。
    </remarks>
    <example> 
      这个示例显示一个对话框，并开始一个打印作业。如果按下 Abort 按钮，Window:ButtonClick() 事件处理程序会中止作业： 
      <code language="X#">
        CLASS AbortDialog INHERIT DialogWindow
            HIDDEN oPrintJob AS OBJECT

            METHOD Init(oWindow,oPrinter) CLASS AbortDialog
                SUPER:Init(oWindow,ResourceID{IDD_ABORT})
                oPrintJob := oPrinter

            METHOD ButtonClick(oControlEvent) CLASS AbortDialog
                oPrintJob:Abort()
                SELF:EndDialog(1)

            METHOD FilePrint() CLASS TopAppWindow
                oPrinter := Printer{}

                IF(oPrinter:IsValid())
                    oDialog := AbortDialog{SELF,oPrinter}
                    oDialog:Show()
                    oPrinter:Start()
                ENDIF
      </code>
    </example>
  </Printer.Abort>

  <Printer.Aborted>
    <exclude />
  </Printer.Aborted>

  <Printer.BeginDoc>
    <exclude />
  </Printer.BeginDoc>

  <Printer.CanvasArea>
    <exclude />
  </Printer.CanvasArea>

  <Printer.Destroy>
    <summary>
      提供一种方法来取消实例化一个 Printer 对象。
    </summary>
    <remarks>
      当不再需要一个 Printer 对象时，可以使用这个方法。
      Printer:Destroy() 取消实例化 Printer 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </Printer.Destroy>

  <Printer.Handle>
    <summary>
      返回一个打印机的句柄。
    </summary>
    <param name="ServiceID">
      所需句柄的类型。0是唯一支持的选项，也是默认值，如果省略 nHandle 参数。
    </param>
    <returns>
      描述底层系统对象的句柄。
    </returns>
    <remarks>
      此方法提供了一个 Windows GDI 对象的句柄，可以通过 Windows API GDI 调用使用。
    </remarks>
  </Printer.Handle>

  <Printer.Idle>
    <summary>
      指示系统在打印时处理事件。
    </summary>
    <remarks>
      Printer:Idle() 会导致系统不断检查其他消息并处理它们，从而提供“后台打印”功能。如果不调用这个方法，系统会在打印操作完成时停止。
    </remarks>
  </Printer.Idle>

  <Printer.IsValid>
    <summary>
      确定打印机是否有效。
    </summary>
    <returns>
      如果有效，返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      在使用之前，必须检查 Printer 对象的有效性。
    </remarks>
  </Printer.IsValid>

  <Printer.lprAbort>
    <exclude />
  </Printer.lprAbort>

  <Printer.NewPage>
    <summary>
      指示附加打印机弹出到新的页面。
    </summary>
  </Printer.NewPage>

  <Printer.PrinterError>
    <summary>
      如果打印机发生错误，调用这个方法。PrintErrorEvent 用于识别发生的错误类型。
    </summary>
    <param name="oPerr">正在处理的打印机错误事件。</param>
    <returns>
      如果要重试打印作业(即，要忽略错误)，返回 TRUE；如果要取消打印作业，返回 FALSE。
    </returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </Printer.PrinterError>

  <Printer.PrinterExpose>
    <summary>
      每当需要重新绘制打印作业的每一页(或每一页的一部分)时调用。
    </summary>
    <param name="oPrinterExposeEvt">描述打印作业的哪一页(或每一页的一部分)需要绘制的暴露事件。</param>
    <returns>
      如果还有另一页(或每一页的一部分)要打印，返回 TRUE；如果已经打印了最后一页，返回 FALSE。
    </returns>
  </Printer.PrinterExpose>

  <Printer.Start>
    <summary>
      开始打印作业或连续部分的打印作业。
    </summary>
    <param name="oRange">
      要打印的页码范围。例如，要打印5到10页，包括5和10，指定 Start(Range{5,10})。如果省略，直到返回 FALSE，调用 Printer:PrinterExpose()。
    </param>
  </Printer.Start>

  <Printer.WindowArea>
    <exclude />
  </Printer.WindowArea>

  <PrinterErrorEvent>
    <summary>
      提供有关 PrinterErrorEvent 的信息，用于描述打印作业期间发生的错误(例如，内存或磁盘空间不足)。
    </summary>
    <remarks>
      默认情况下，事件处理程序显示一个文本框，用于“无磁盘空间”消息。错误处理程序不会自动中止，但会提示用户中止或重试。如果用户重试，系统会将控制权返回给打印管理器。但是，一些打印机的设备驱动程序可能会禁止这样的消息。
      所有其他错误应该导致打印机中止。
    </remarks>
  </PrinterErrorEvent>

  <PrinterErrorEvent.ctor>
    <inheritdoc />
  </PrinterErrorEvent.ctor>

  <PrinterErrorEvent.ErrorType>
    <summary>
      传递给 Printer:Expose() 方法的以下事件之一，当系统需要绘制并发送到打印管理器的另一页时：
    </summary>
    <value>传递给 Printer:Expose() 方法的以下事件之一，当系统需要绘制并发送到打印管理器的另一页时：</value>
    <remarks> 
      传递给 Printer:Expose() 方法的以下事件之一，当系统需要绘制并发送到打印管理器的另一页时： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>PRINTERERRORFATALDEVICEERROR</term>
          <description>打印机设备无法正确创建或初始化。</description>
        </item>
        <item>
          <term>PRINTERERRORGENERALERROR</term>
          <description>发生了一个一般的无法识别(系统特定)错误。</description>
        </item>
        <item>
          <term>PRINTERERRORNODISKSPACE</term>
          <description>Windows 打印管理器已经用完了磁盘空间来完成作业。这不一定是致命的。</description>
        </item>
        <item>
          <term>PRINTERERRORNOMEMSPACE</term>
          <description>内存不足以完成作业。</description>
        </item>
        <item>
          <term>PRINTERERRORUSERABORT</term>
          <description>用户或应用程序已中止作业。</description>
        </item>
      </list>
    </remarks>
  </PrinterErrorEvent.ErrorType>

  <PrinterExposeEvent>
    <summary>
      提供确定要绘制的页码的数量，以及要绘制的页码的区域的设施。
    </summary>
    <remarks>
      一些打印机驱动程序可能会请求以段(“带式打印机”)的形式绘制页码。
      PrinterExposeEvent:ExposedArea 定义要绘制的页码的区域，以打印机坐标的 BoundingBox 对象的形式。如果请求的是整个页码，那么边界框等于整个页码的大小。
    </remarks>
  </PrinterExposeEvent>

  <PrinterExposeEvent.ctor>
    <inheritdoc />
  </PrinterExposeEvent.ctor>

  <PrinterExposeEvent.ExposedArea>
    <summary>
      表示要打印的页码的区域，以打印机坐标的 BoundingBox 对象的形式。
    </summary>
    <value>表示要打印的页码的区域，以打印机坐标的 BoundingBox 对象的形式。</value>
    <remarks>
      表示要打印的页码的区域，以打印机坐标的 BoundingBox 对象的形式。
      Windows 将要打印的大小或部分页码测量为包含在边界框中的内容。这通常是整个页码，但对于内存有限的打印机(无法打印整个页码)，它是要打印的页码的区域。
    </remarks>
  </PrinterExposeEvent.ExposedArea>

  <PrinterExposeEvent.PageNo>
    <summary>
      表示要绘制的页码的数字值。
    </summary>
    <value>表示要绘制的页码的数字值。</value>
  </PrinterExposeEvent.PageNo>

  <PrintingDevice>
    <summary>
      创建一个对象，允许您为应用程序设置打印设备。它还允许您调用标准对话框来配置默认打印机并更改值，例如更改页面方向或纸张来源。
    </summary>
  </PrintingDevice>

  <PrintingDevice.ctor>
    <summary>
      构造一个 PrintingDevice 对象。
    </summary>
    <param name="uName">
      逗号分隔的字符串，表示要使用的打印机驱动程序。在 Windows 中，这个字符串应该以以下形式给出：<br />
      &lt;PrinterInfo&gt;,&lt;PrinterDriver&gt;,&lt;Port&gt;<br />
      例如，您可以指定：<br />
      'PostScript Printer,PSSCRIPT,LPT1:'<br />
      如果省略，将使用默认的打印机驱动程序。<br />
      注意：这个字符串的每一部分的开头和结尾都没有空格。空格只应该在参数中出现的地方使用。
    </param>
  </PrintingDevice.ctor>

  <PrintingDevice.Copies>
    <summary>
      如果设备支持多页复印，指定打印的副本数。
    </summary>
    <value>如果设备支持多页复印，指定打印的副本数。</value>
  </PrintingDevice.Copies>

  <PrintingDevice.Destroy>
    <summary>
      提供一种方法来取消实例化 PrintingDevice 对象。
    </summary>
    <remarks>
      当不再需要 PrintingDevice 对象时，可以使用这个方法。
      PrintingDevice:Destroy() 取消实例化 PrintingDevice 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </PrintingDevice.Destroy>

  <PrintingDevice.Device>
    <summary>
      指定要使用的打印设备。
    </summary>
    <value>指定要使用的打印设备。</value>
  </PrintingDevice.Device>

  <PrintingDevice.DeviceCapabilities>
    <summary>
      获取有关打印设备功能的信息。
    </summary>
    <param name="wCapability">
      要查询的功能，由Windows API设备功能常量指定。例如，您可以指定：'DC_PAPERS'<br />
      如果省略，将使用默认功能。
    </param>
    <returns> 
      一个包含 X# 动态数组或WORD的常规变量。由常量 CAPABILITY_NOT_AVAILABLE 表示的值表示检索值失败。<br />
      返回值根据 <paramref name="kCapability" /> 的不同而不同。<br />
      请参考 Windows SDK 主题 DeviceCapabilites 以获取返回值。<br />
      如果 SDK 指示返回值是一个数组或点结构，那么返回值将包含一个 VO 动态数组；否则，它将包含一个 word。 
    </returns>
    <remarks>
      这个方法提供了有关打印设备对象的功能的信息。
    </remarks>
    <example> 
      这是一个 ListBox FillUsing 方法的示例，用于使用包含可用纸张大小的二维数组填充列表框。第一维包含显示值，第二维包含返回值。 
      <code language="X#">
        SELF:oPrint //假定是一个Printer对象

        METHOD FillPaperSizesListBox() CLASS; MyPrintReportWindow
            LOCAL aDisplayValues, aReturnValues, aListBoxValues := {} AS ARRAY
            LOCAL i, wALen AS DWORD

            aDisplayValues  := SELF:oPrint:PrintingDevice:DeviceCapabilities(DC_PAPERNAMES)
            aReturnValues   := SELF:oPrint:PrintingDevice:DeviceCapabilities(DC_PAPERS)
            wALen           := ALen(aDisplayValues)

            FOR i := 1 UPTO wALen
                aAdd(aListBoxValues, {aDisplayValues[i], aReturnValues[i]})
            NEXT

            RETURN aListBoxValues
      </code>
      这个示例创建一个Printer对象，使用默认设备驱动程序。查询并显示各种设备功能。 
      <code language="X#">
        LOCAL uValue AS USUAL
        LOCAL oP, oPD AS OBJECT
        // 使用默认设备创建打印机对象并
        // 获取对PrintingDevice对象的引用
        oP := Printer{}
        oPD := oP:PrintingDevice
        // 列出可用纸张大小的名称
        uValue := oPD:DeviceCapabilities(DC_PAPERNAMES)
        QOut("Show "+"DC_PAPERNAMES")
        ShowValue(uValue)
        InKey(0)
        // 列出可用纸张的名称
        uValue := oPD:DeviceCapabilities(DC_PAPERNAMES)
        QOut("Show "+"DC_PAPERNAMES")
        ShowValue(uValue)
        InKey(0)
        // 销毁打印机对象(回收GDI资源)
        oP:Destroy()

        FUNCTION ShowValue(uValue)
            IF IsArray(uValue)
                AEval(uValue, {|u| ShowValue(u)});
                // 递归，直到找到单个元素
                ELSEIF IsNumeric(uValue) .AND.;
                uValue = CAPABILITY_NOT_AVAIALBLE
                QOut ("Device capability not available from driver")
            ELSE
                QOut(uValue)
            ENDIF
      </code>
    </example>
  </PrintingDevice.DeviceCapabilities>

  <PrintingDevice.Driver>
    <summary>
      表示要使用的打印机驱动程序的字符串。
    </summary>
    <value>表示要使用的打印机驱动程序的字符串。</value>
  </PrintingDevice.Driver>

  <PrintingDevice.GetDevMode>
    <summary>
      检索 DevMode 结构的指针。
    </summary>
    <returns>
      DevMode 结构的指针，如果结构不可访问，则为0。您应该将这个指针存储在一个类型为"AS _WINDEVMODE"的变量中。
    </returns>
    <remarks>
      DevMode 结构在 Win32 SDK 中有文档记录，并在 X# Win32 API 库中定义。
      这个结构位于底层 PrintingDevice 对象中，并通过与对象关联的设备驱动程序创建。
      对这个结构的成员的更新通过 PrintingDevice:UpdateDevMode() 方法应用。
    </remarks>
    <example> 
      这个示例访问并显示了DevMode结构的各种信息： 
      <code language="X#">
        oPD //假定是一个PrintingDevice对象。
        LOCAL structDevMode AS _WINDEVMODE
        LOCAL i AS DWORD
        LOCAL cDeviceName AS STRING
        LOCAL cOrientation AS STRING

        structDevMode := oPD:GetDevMode()

        FOR i := 1 TO CCHDEVICENAME
            cDeviceName:=cDeviceName+Chr(structDevMode.dmDeviceName[i])
        NEXT

        ?"Device name is "
        ??cDeviceName
        cOrientation := StringdmOrientation(structDevMode.dmOrientation)

        ?"Orientation is "
        ??cOrientation

        ?"PaperLength is "
        ??AllTrim(Str(structDevMode.dmPaperLength))

        ?"PaperWidth is "
        ??AllTrim(Str(structDevMode.dmPaperWidth))

        ?"Number of copies is "
        ??AllTrim(Str(structDevMode.dmCopies))

        ? "dmDefaultSource "
        ?structDevMode.dmDefaultSource

        Wait

        FUNCTION StringdmOrientation(nO AS SHORTINT) AS STRING
            IF nO = DMORIENT_LANDSCAPE
                RETURN "Landscape"

                ELSEIF nO = DMORIENT_PORTRAIT

                RETURN "Portrait"
            ELSE
                RETURN "Unknown"
            ENDIF
      </code>
    </example>
  </PrintingDevice.GetDevMode>

  <PrintingDevice.IsValid>
    <summary>
      确定打印设备是否有效。
    </summary>
    <returns>
      如果有效，返回 TRUE；否则，返回 FALSE。
    </returns>
  </PrintingDevice.IsValid>

  <PrintingDevice.Orientation>
    <summary>
      指定纸张的方向是纵向还是横向。
    </summary>
    <value>指定纸张的方向是纵向还是横向。</value>
  </PrintingDevice.Orientation>

  <PrintingDevice.PaperHeight>
    <summary>
      指定纸张的长度，以毫米的十分之一为单位。
    </summary>
    <value>指定纸张的长度，以毫米的十分之一为单位。</value>
    <remarks>
      指定纸张的长度，以毫米的十分之一为单位。这个参数可以覆盖 DevMode 结构的成员 PaperSize 指定的纸张长度，无论是自定义纸张大小还是如点阵打印机这样的设备，它可以打印各种页面大小。
    </remarks>
  </PrintingDevice.PaperHeight>

  <PrintingDevice.PaperSize>
    <summary>
      指定要打印的纸张的大小。
    </summary>
    <value>指定要打印的纸张的大小。</value>
    <remarks>
      指定要打印的纸张的大小。如果纸张的长度和宽度由 DevMode 结构的成员 PaperLength 和 PaperWidth 指定，可以将此成员设置为零。
      否则，dmPaperSize 成员可以设置为以下预定义值之一：
      <list type="table">
        <item>
          <term>DMPAPER_FIRST</term>
          <description>First</description>
        </item>
        <item>
          <term>DMPAPER_LETTER</term>
          <description>Letter, 8 1/2 x 11 in.</description>
        </item>
        <item>
          <term>DMPAPER_LETTERSMALL</term>
          <description>Letter Small, 8 1/2 x 11 in.</description>
        </item>
        <item>
          <term>DMPAPER_TABLOID</term>
          <description>Tabloid, 11 x 17 in.</description>
        </item>
        <item>
          <term>DMPAPER_LEDGER</term>
          <description> Ledger, 17 x 11 in.</description>
        </item>
        <item>
          <term>DMPAPER_LEGAL</term>
          <description>Legal, 8 1/2 x 14 in.</description>
        </item>
        <item>
          <term>DMPAPER_STATEMENT</term>
          <description>Statement, 5 1/2 x 8 1/2 in.</description>
        </item>
        <item>
          <term>DMPAPER_EXECUTIVE</term>
          <description>Executive, 7 1/2 x 10 1/2 in.</description>
        </item>
        <item>
          <term>DMPAPER_A3</term>
          <description>A3, 297 x 420 mm</description>
        </item>
        <item>
          <term>DMPAPER_A4</term>
          <description>A4, 210 x 297 mm</description>
        </item>
        <item>
          <term>DMPAPER_A4SMALL</term>
          <description>A4 Small, 210 x 297 mm</description>
        </item>
        <item>
          <term>DMPAPER_A5</term>
          <description>A5, 148 x 210 mm</description>
        </item>
        <item>
          <term>DMPAPER_B4</term>
          <description>B4, 250 x 354 mm</description>
        </item>
        <item>
          <term>DMPAPER_B5</term>
          <description>B5, 182 x 257 mm</description>
        </item>
        <item>
          <term>DMPAPER_FOLIO</term>
          <description>Folio, 8 1/2 x 13 in.</description>
        </item>
        <item>
          <term>DMPAPER_QUARTO</term>
          <description>Quarto, 215 x 275 mm</description>
        </item>
        <item>
          <term>DMPAPER_10X14</term>
          <description>10 x 14 in.</description>
        </item>
        <item>
          <term>DMPAPER_11X17</term>
          <description>11 x 17 in.</description>
        </item>
        <item>
          <term>DMPAPER_NOTE</term>
          <description>Note, 8 1/2 x 11 in.</description>
        </item>
        <item>
          <term>DMPAPER_ENV_9</term>
          <description>Envelope #9, 3 7/8 x 87/8in.</description>
        </item>
        <item>
          <term>DMPAPER_ENV_10</term>
          <description>Envelope #10, 4 1/8 x 91/2in.</description>
        </item>
        <item>
          <term>DMPAPER_ENV_11</term>
          <description>Envelope #11, 4 1/2 x 103/8in.</description>
        </item>
        <item>
          <term>DMPAPER_ENV_12</term>
          <description>Envelope #12, 4 1/2 x 11 in.</description>
        </item>
        <item>
          <term>DMPAPER_ENV_14</term>
          <description>Envelope #14, 5 x 11 1/2 in.</description>
        </item>
        <item>
          <term>DMPAPER_CSHEET</term>
          <description>C size sheet</description>
        </item>
        <item>
          <term>DMPAPER_DSHEET</term>
          <description>D size sheet</description>
        </item>
        <item>
          <term>DMPAPER_ESHEET</term>
          <description>E size sheet</description>
        </item>
        <item>
          <term>DMPAPER_ENV_DL</term>
          <description>Envelope DL, 110 x 220 mm</description>
        </item>
        <item>
          <term>DMPAPER_ENV_C3</term>
          <description>Envelope C3, 324 x 458 mm</description>
        </item>
        <item>
          <term>DMPAPER_ENV_C4</term>
          <description>Envelope C4, 229 x 324 mm</description>
        </item>
        <item>
          <term>DMPAPER_ENV_C5</term>
          <description>Envelope C5, 162 x 229 mm</description>
        </item>
        <item>
          <term>DMPAPER_ENV_C6</term>
          <description>Envelope C6, 114 x 162 mm</description>
        </item>
        <item>
          <term>DMPAPER_ENV_C65</term>
          <description>Envelope C65, 114 x 229 mm</description>
        </item>
        <item>
          <term>DMPAPER_ENV_B4</term>
          <description>Envelope B4, 250 x 353 mm</description>
        </item>
        <item>
          <term>DMPAPER_ENV_B5</term>
          <description>Envelope B5, 176 x 250 mm</description>
        </item>
        <item>
          <term>DMPAPER_ENV_B6</term>
          <description>Envelope B6, 176 x 125 mm</description>
        </item>
        <item>
          <term>DMPAPER_ENV_ITALY</term>
          <description>Envelope, 110 x 230 mm</description>
        </item>
        <item>
          <term>DMPAPER_ENV_MONARCH</term>
          <description>Envelope Monarch, 3 7/8 x 71/2 in.</description>
        </item>
        <item>
          <term>DMPAPER_ENV_PERSONAL</term>
          <description>Envelope, 3 5/8 x 6 1/2 in.</description>
        </item>
        <item>
          <term>DMPAPER_FANFOLD_US</term>
          <description>U.S. Standard Fanfold, 147/8 x 11 in.</description>
        </item>
        <item>
          <term>DMPAPER_FANFOLD_STD_GERMAN</term>
          <description>German Standard Fanfold, 81/2 x 12 in.</description>
        </item>
        <item>
          <term>DMPAPER_FANFOLD_LGL_GERMAN</term>
          <description>German Legal Fanfold, 81/2 x 13 in.</description>
        </item>
        <item>
          <term>DMPAPER_LAST</term>
          <description>German Legal Fanfold, 81/2 x 13 in.</description>
        </item>
        <item>
          <term>DMPAPER_USER</term>
          <description>User-defined</description>
        </item>
      </list>
    </remarks>
  </PrintingDevice.PaperSize>

  <PrintingDevice.PaperWidth>
    <summary>
      指定纸张的宽度，以毫米的十分之一为单位。此参数将覆盖 dmPaperSize 成员指定的纸张宽度。
    </summary>
    <value>指定纸张的宽度，以毫米的十分之一为单位。此参数将覆盖 dmPaperSize 成员指定的纸张宽度。</value>
  </PrintingDevice.PaperWidth>

  <PrintingDevice.Port>
    <summary>
      指定打印机的默认端口设置。
    </summary>
    <value>指定打印机的默认端口设置。</value>
  </PrintingDevice.Port>

  <PrintingDevice.SetUp>
    <summary>
      显示标准的 Windows 打印机设置对话框，允许用户配置或更改默认打印机，并设置页面方向、纸张大小和纸张来源(例如，手动进纸、上盘等)。
    </summary>
    <returns>
      如果按下 OK 按钮，返回 TRUE；如果按下取消按钮，关闭 Windows 打印机设置对话框，返回 FALSE。
    </returns>
  </PrintingDevice.SetUp>

  <PrintingDevice.UpdateDevMode>
    <summary>
      将对 DevMode 结构所做的更改应用到关联的设备驱动程序。
    </summary>
    <returns>
      一个逻辑值，指示更新的成功与否。
    </returns>
    <remarks>
      UpdateDevMode() 将 PrintingDevice 对象的 DevMode 结构中的信息复制到打印机驱动程序。
      通过 PrintingDevice:GetDevMode() 方法提供对结构的访问。您必须首先使用此方法获取指向结构的指针。
      此结构位于底层的 PrintingDevice 对象中。
    </remarks>
    <example> 
      本示例将方向更改为横向，并将要打印的副本数设置为10。 
      <code language="X#">
        // 假设oPD是一个PrintingDevice对象。
        LOCAL structDevMode AS _WINDEVMODE // AS为指针分配内存

        structDevMode               := oPD:GetDevMode() // 映射打印设备的devmode结构
        structDevMode.dmCopies      := 10
        structDevMode.dmOrientation := DMORIENT_PORTRAIT

        lSuccess := oPD:UpdateDevMode()

        IF !lSuccess
            ? "更新devmode时出错"
        ELSE
            ? "devmode成功更新"
        ENDIF

        InKey(0)
        // 销毁打印机对象(回收GDI资源)
        oP:Destroy()

        FUNCTION ShowValue(uValue)
            IF IsArray(uValue)
                AEval(uValue, {|u| ShowValue(u)}) // 递归，直到找到单个元素
                ELSEIF IsNumeric(uValue) .AND. uValue = CAPABILITY_NOT_AVAIALBLE
                QOut("驱动程序不可用的设备能力")
            ELSE
                QOut(uValue)
            ENDIF
      </code>
    </example>
  </PrintingDevice.UpdateDevMode>

  <ProgressBar>
    <summary>
      创建一个进度条。
    </summary>
    <remarks>
      进度条是一个控件，可用于指示操作的进度。它是一个水平条，随着操作的进行，从左到右填满，颜色为系统的高亮色。
    </remarks>
  </ProgressBar>

  <ProgressBar.ctor>
    <summary>
      构造一个进度条。
    </summary>
    <param name="oOwner">拥有进度条的窗口。</param>
    <param name="xID">进度条的唯一ID(1到8000之间)。</param>
    <param name="oPoint">进度条在画布坐标中的原点。</param>
    <param name="oDimension">进度条在画布坐标中的尺寸。</param>
    <param name="kStyle">进度条的样式。</param>
    <param name="lDataAware">一个逻辑值，指定进度条是否是数据感知的。</param>
    <param name="nResourceID">进度条的资源ID。</param>
  </ProgressBar.ctor>

  <ProgressBar.Advance>
    <summary>
      将进度条前进到一个新的位置。
    </summary>
    <param name="dwNewPosition">进度条前进的量。如果省略，进度条将按单位大小前进。</param>
    <returns>
      进度条前进的量。
    </returns>
  </ProgressBar.Advance>

  <ProgressBar.BackgroundColor>
    <summary>
      一个 Color 对象，指定进度条的背景颜色。
    </summary>
    <value>一个 Color 对象，指定进度条的背景颜色。</value>
  </ProgressBar.BackgroundColor>

  <ProgressBar.BarColor>
    <summary>
      一个 Color 对象，指定进度条控件的条颜色。
    </summary>
    <value>一个 Color 对象，指定进度条控件的条颜色。</value>
  </ProgressBar.BarColor>

  <ProgressBar.OldPosition>
    <summary>
      一个数值，表示进度条的前一个位置。
    </summary>
    <value>一个数值，表示进度条的前一个位置。</value>
  </ProgressBar.OldPosition>

  <ProgressBar.Position>
    <summary>
      一个数值，表示进度条的当前位置。
    </summary>
    <value>一个数值，表示进度条的当前位置。</value>
  </ProgressBar.Position>

  <ProgressBar.Range>
    <summary>
      一个 Range 对象，表示进度条当前使用的最小和最大值。
    </summary>
    <value>一个 Range 对象，表示进度条当前使用的最小和最大值。</value>
  </ProgressBar.Range>

  <ProgressBar.UnitSize>
    <summary>
      一个数值，表示当前与进度条关联的单位大小。
    </summary>
    <value>一个数值，表示当前与进度条关联的单位大小。</value>
  </ProgressBar.UnitSize>

  <PushButton>
    <summary>
      创建一个推按钮，用户点击时可以触发事件和相关操作。
    </summary>
    <remarks>
      与复选框和单选按钮不同，推按钮没有可识别的状态；它们总是准备好被点击。但是，您可以指定窗口上的一个推按钮为默认按钮，
      在这种情况下，可以通过按 Enter 键来激活它；默认推按钮通过其粗边框来指示。<br />
      在 Windows 中，推按钮相当于一个带有 BS_PUSHBUTTON 样式的按钮。样式 BS_DEFPUSHBUTTON 也非常有用，因为按钮在对话框中自动获得焦点。<br />
      在 Windows 中，推按钮可以在资源实体中创建，如下所示： 
      <code language="X#">
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 120
        STYLE WS_POPUP | WS_DLGFRAME
        BEGIN
            PUSHBUTTON "Cancel" IDB_CANCEL, 64, 50, 32, 14
            DEFPUSHBUTTON "OK" IDB_OK, 64, 80, 32, 14,; WS_GROUP
        END
      </code>
    </remarks>
  </PushButton>

  <PushButton.ctor>
    <summary>
      构造一个推按钮。
    </summary>
    <param name="oOwner">拥有推按钮的窗口。</param>
    <param name="xID">推按钮的唯一ID(1到8000之间)。</param>
    <param name="oPoint">推按钮在画布坐标中的原点。</param>
    <param name="oDimension">推按钮在画布坐标中的尺寸。</param>
    <param name="cText">在推按钮中显示的文本。默认为 NULL_STRING。</param>
    <param name="kStyle">
      推按钮的样式，由 Windows API 样式常量指定。
    </param>
    <param name="nResourceID">推按钮的资源ID。</param>
    <remarks>
      <note type="tip">详细信息，请参阅 Microsoft Win32 软件开发工具包文档中关于特定 Windows API 样式常量的详细信息。</note>
    </remarks>
  </PushButton.ctor>

  <PushButton.Destroy>
    <summary>
      提供一种方法来取消实例化 PushButton 对象。
    </summary>
    <remarks>
      当不再需要 PushButton 对象时，可以使用此方法。PushButton:Destroy() 取消实例化 PushButton 对象，
      并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </PushButton.Destroy>

  <PushButton.TextValue>
    <summary>
      PushButton:TextValue 设置为 PushButton:Caption 文本。
    </summary>
    <value>PushButton:TextValue 设置为 PushButton:Caption 文本。</value>
  </PushButton.TextValue>

  <PushButton.Value>
    <summary>
      PushButton:Value 始终返回 FALSE，因为它只有一个状态。
    </summary>
    <value>PushButton:Value 始终返回 FALSE，因为它只有一个状态。</value>
  </PushButton.Value>

  <RadioButton>
    <summary>
      创建一个单选按钮。
    </summary>
    <remarks> 
      单选按钮通常以相关组的形式呈现，并对只有一个选项适用的条件提供互斥的响应。(例如，单选按钮组可能允许您选择英寸、厘米或 Picas。)<br />
      每个单选按钮组中只能有一个单选按钮处于打开状态。当按下不同的按钮时，先前选择的按钮将关闭。
      在窗口编辑器中，对于每个单选按钮组，都会检查 Group 样式设置，以指定组中的第一个控件。如果您没有显式创建两个或更多组，
      那么整个窗口只会有一个组，一次只能选择一个单选按钮。<br />
      当单选按钮组使用窗口编辑器创建时，会生成代码，使其自动运行。标题用于指示组中哪个按钮被按下，所选按钮的组值存储在 RadioButton:Value 中。
      单选按钮可能不会像其他控件那样绑定到服务器的字段。相反，单选按钮组可能会绑定到一个字段。<br />
      在 Windows 中，单选按钮等同于一个带有 BS_RADIOBUTTON 样式的按钮。样式 BS_AUTORADIOBUTTON 也非常有用，因为按钮会自动打开和关闭，
      而无需在系统的 Window:ButtonClick() 事件处理程序中编写任何代码。<br />
      在 Windows 中，单选按钮可以在资源实体中创建，如下所示： 
      <code language="X#">
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 120
        STYLE WS_POPUP | WS_DLGFRAME
        BEGIN
            RADIOBUTTON "&amp;Black" IDB_BLACK, 10, 20, 40, 12
            RADIOBUTTON "&amp;Gray" IDB_GRAY, 10, 35, 40, 12
            RADIOBUTTON "&amp;White" IDB_WHITE, 10, 50, 40, 12
            CONTROL "&amp;Auto",IDB_AUTO, "button"; BS_AUTORADIOBUTTON, 10,65,40,12
        END
      </code>
    </remarks>
  </RadioButton>

  <RadioButton.ctor>
    <summary>
      构造一个单选按钮。
    </summary>
    <param name="oOwner">拥有单选按钮的窗口。</param>
    <param name="xID">单选按钮的唯一ID(1到8000之间)。</param>
    <param name="oPoint">单选按钮在画布坐标中的原点。</param>
    <param name="oDimension">单选按钮在画布坐标中的尺寸。</param>
    <param name="cText">单选按钮的标题文本。如果省略，默认为NULL_STRING。</param>
    <param name="kStyle">
      单选按钮的样式，由 Windows API 样式常量指定。
    </param>
    <remarks>
      <note type="tip">请查看 Microsoft Win32 软件开发工具包文档，以获取特定 Windows API 样式常量的详细信息。</note>
    </remarks>
    <param name="nResourceID">单选按钮的资源ID。</param>
  </RadioButton.ctor>

  <RadioButton.Destroy>
    <summary>
      提供一个方法来销毁一个 RadioButton 对象。
    </summary>
    <remarks>
      当不再需要一个 RadioButton 对象时，可以使用这个方法。
      RadioButton:Destroy() 销毁了 RadioButton 对象，允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </RadioButton.Destroy>

  <RadioButton.Pressed>
    <summary>
      一个逻辑值，表示单选按钮的当前状态(如果打开，则为 TRUE，如果关闭，则为 FALSE)。
    </summary>
    <value>一个逻辑值，表示单选按钮的当前状态(如果打开，则为 TRUE，如果关闭，则为 FALSE)。</value>
    <remarks>
      一个逻辑值，表示单选按钮的当前状态(如果打开，则为 TRUE，如果关闭，则为 FALSE)。RadioButton:Pressed 只能通过单击按钮来修改。
    </remarks>
  </RadioButton.Pressed>

  <RadioButton.TextValue>
    <summary>
      RadioButton:TextValue 设置为 RadioButton:Caption 文本。
    </summary>
    <value>RadioButton:TextValue 设置为 RadioButton:Caption 文本。</value>
    <remarks>
      RadioButton:TextValue 设置为 RadioButton:Caption 文本。RadioButton:TextValue 的赋值也会改变 RadioButton:Caption。
    </remarks>
  </RadioButton.TextValue>

  <RadioButton.Value>
    <summary>
      RadioButton:Value 包含 TRUE，如果单选按钮处于按下(ON)状态，或者 FALSE，如果单选按钮没有被按下(OFF)。
    </summary>
    <value>RadioButton:Value 包含 TRUE，如果单选按钮处于按下(ON)状态，或者 FALSE，如果单选按钮没有被按下(OFF)。</value>
  </RadioButton.Value>

  <RadioButtonGroup>
    <summary>
      一组单选按钮，被视为一个组合控件，呈现一组选项，并返回一个值。
    </summary>
    <remarks>
      单选按钮通常用于允许在特定选项列表中选择一个。然而，将多个单选按钮视为单独的控件需要对按钮的行为进行显式管理：
      当选择一个按钮时，程序必须关闭组中的其他按钮。<br />
      单独的单选按钮也不适合与数据库链接：数据库通常不会有多个字段表示链接的属性，而是一个可以取不同值的字段。<br />
      单选按钮组是一个更高级别的控件，它自动处理按钮的相互链接。它还以比单独的单选按钮更智能的方式链接到数据库：整个组被视为一个控件，它可以取一组特定的值。<br />
      由于单选按钮组是您处理的控件，它的组成单选按钮不是直接由程序引用的，所以像超链接标签、字段规范、标题、值和文本值这样的属性都附加到组。
      值要么是当前在序列中选择的单选按钮的编号，要么是通过 FillUsing() 方法在二维数组中为单选按钮指定的一个值。
      文本值是根据附加到组的字段规范的图片规范格式化的相同值(要获取在单选按钮旁边显示的标题，检索所选按钮并引用其标题属性。
      注意，组的字段规范的数据类型和图片规范被使用，而单选按钮的字段规范被忽略)。<br />
      单选按钮组的行为类似于列表框或组合框，当选项的数量少且固定时，可以作为受限制的单选列表框的替代。
      (尽管单选按钮组支持为单个按钮的个别按钮提供可变的标题字符串，但列表框通常是非常动态数据的更好选择。)<br />
      单选按钮组是空的，单选按钮是通过 FillUsing() 方法与之关联的。如果使用窗口编辑器创建单选按钮，
      生成的源代码中的 FillUsing() 方法定义了一个二维数组，每个按钮都有一行。第一个元素包含单选按钮的标题，第二个元素包含它的组值。<br />
      当按下按钮时，单选按钮组的 TextValue 包含第一个元素(按钮的标题)，Value 包含第二个元素(组的值)。<br />
      如果没有按钮被按下，RadioButtonGroup:TextValue 是 NULL_STRING，RadioButtonGroup:Value 是 NIL。<br />
      单选按钮组可以与服务器的字段绑定。字段的数据值存储在 RadioButtonGroup:Value 中。
      单选按钮组将字段的数据值与 FillUsing() 数组中指定的第二个元素的值进行比较，
      如果找到匹配，将第一个元素(按钮的标题)存储在 RadioButtonGroup:TextValue 中。<br />
      如果没有找到匹配，RadioButtonGroup:TextValue 是 NULL_STRING。<br />
      如果按下按钮，相应的第二个元素将存储在 RadioButtonGroup:Value 中，并且这个值将被写入服务器。
    </remarks>
  </RadioButtonGroup>

  <RadioButtonGroup.ctor>
    <summary>
      构造一个单选按钮组。
    </summary>
    <param name="oOwner">拥有单选按钮组的窗口。</param>
    <param name="xID">单选按钮组的唯一ID(1到8000之间)或单选按钮组的资源ID。</param>
    <param name="uPoint">单选按钮组的原点在画布坐标中的位置。</param>
    <param name="uDimension">单选按钮组在画布坐标中的尺寸。</param>
    <param name="cText">单选按钮组的标题文本。如果省略，默认为 NULL_STRING。</param>
    <remarks>
      请注意，在实例化之后，单选按钮组是"空的": 它不包含任何单选按钮。从视觉上看，它可能
      被绘制为围绕单选按钮，但逻辑上它不包含它们。要将组与其单选按钮关联，请使用 FillUsing() 方法。
    </remarks>
  </RadioButtonGroup.ctor>

  <RadioButtonGroup.Button>
    <summary>
      检索特定的单选按钮。
    </summary>
    <param name="nButtonPosition">在数组中的位置，该数组用于设置组(在 FillUsing() 中)。</param>
    <returns>
      数组中指定位置的 RadioButton 对象。请注意，数组中的单选按钮位置可能不对应于组框中显示的单选按钮的顺序。如果在指定位置没有单选按钮，则返回 NIL。
    </returns>
  </RadioButtonGroup.Button>

  <RadioButtonGroup.Buttons>
    <exclude />
  </RadioButtonGroup.Buttons>

  <RadioButtonGroup.Caption>
    <summary>
      一个字符串，表示单选按钮组中当前选中的单选按钮旁边显示的文本。
    </summary>
    <value>一个字符串，表示单选按钮组中当前选中的单选按钮旁边显示的文本。</value>
    <remarks>
      一个字符串，表示单选按钮组中当前选中的单选按钮旁边显示的文本。
      RadioButtonGroup:Caption 的赋值也会改变 RadioButtonGroup:CurrentText 的值。
    </remarks>
  </RadioButtonGroup.Caption>

  <RadioButtonGroup.Disable>
    <summary>
      禁用单选按钮组(直到后续调用 RadioButtonGroup:Enable())。
    </summary>
    <remarks>
      禁用的单选按钮组不活动(即，单选按钮不能被点击)，因此，它们不会向它们的所有者窗口发送事件。
      请注意，在 Windows 下，禁用的单选按钮组是灰暗的。
    </remarks>
  </RadioButtonGroup.Disable>

  <RadioButtonGroup.Enable>
    <summary>
      启用之前禁用的单选按钮组。
    </summary>
    <remarks>
      启用单选按钮组允许它生成事件，并在用户操作单选按钮组时将事件发送到其所有者窗口。禁用的单选按钮组的灰暗效果被移除，恢复到正常外观。
      默认情况下，单选按钮组是启用的，直到被禁用，所以除非之前调用了 Disable() 方法，否则不需要调用这个 Enable() 方法。
    </remarks>
  </RadioButtonGroup.Enable>

  <RadioButtonGroup.FillUsing>
    <summary>
      使用数组指定组成组的单选按钮和对应这些按钮的一组值。
    </summary>
    <param name="aContents">
      包含现有单选按钮或应该用于创建单选按钮的值的数组。可以使用二维数组来定义在选择单选按钮时返回给程序的值；这个“其他”值是在 RadioButtonGroup:Value 属性中返回的，如果控件与数据库字段关联，这个值也是存储在数据库中的。如果指定了一个一维数组，值将作为1,
      2, 3...返回。<br />
      因此，数组可以以两种格式之一指定：<br />
      1. 包含要链接到组的单选按钮对象的一维数组<br />
      2. 二维数组，每个元素包含一个 RadioButton 对象和返回给程序的对应值<br />
      注意：二维数组的结构与 DBServer:GetLookupTable() 返回的结构相同。
    </param>
    <remarks> 
      对于固定结构，可以将单个单选按钮作为常规控件创建，无论是动态地还是通过资源实体，然后通过 FillUsing() 方法将其分配给组。 
      <note type="tip">
        单选按钮组可以与数据库字段绑定，就像任何其他控件一样。
      </note>
    </remarks>
    <example> 
      创建一个单选按钮组，显示不同的货币，向用户显示一个明确的表示，但在内部使用不同的表示。 <br />
      下面的示例，通过资源实体显式创建了单选按钮。代码只是将单选按钮链接到组： 
      <code language="X#">
        RESOURCE OrderWindow DIALOG 7,11,239,196
        STYLE WS_CHILD
        FONT 8,"MS Sans Serif"
        BEGIN
        CONTROL "Currency",;
        ORDERWINDOW_CURRENCY,"Button";
        BS_GROUPBOX|WS_GROUP|WS_CHILD,;
        27,33,85,122
        CONTROL "U.S. Dollars",;
        ORDERWINDOW_THERADIOBUTTON1,"Button";
        BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
        38,45,57,11
        CONTROL "Can. Dollars",;
        ORDERWINDOW_THERADIOBUTTON2,"Button";
        BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
        38,63,69,11
        CONTROL "Mexican Pesos",;
        ORDERWINDOW_THERADIOBUTTON3,"Button";
        BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
        38,82,69,11
        CONTROL "Yen",;
        ORDERWINDOW_THERADIOBUTTON4,"Button";
        BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
        38,100,68,11
        CONTROL "British Pounds",;
        ORDERWINDOW_THERADIOBUTTON5,"Button";
        BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
        38,118,68,11
        CONTROL "German Marks",;
        ORDERWINDOW_THERADIOBUTTON6,"Button";
        BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
        38,137,69,11
        METHOD Init(oWindow,iCtlID,oServer) CLASS OrderWindow
        SUPER:Init(oWindow,ResourceID{"OrderWindow"},iCtlID)
        oCCTheRadioButton1 := RadioButton{SELF,;
        ResourceID{ORDERWINDOW_THERADIOBUTTON1}}
        RadioButton1:HyperLabel := {#TheRadioButton1,;
        "U.S. Dollars",,}
        oCCTheRadioButton2 := RadioButton{SELF,;
        ResourceID{ORDERWINDOW_THERADIOBUTTON2}}
        RadioButton2:HyperLabel := {#TheRadioButton2,;
        "Can. Dollars",,}
        oCCTheRadioButton3 := RadioButton{SELF,;
        ResourceID{ORDERWINDOW_THERADIOBUTTON3}}
        RadioButton3:HyperLabel := {#TheRadioButton3,;
        "Mexican Pesos",,}
        oCCTheRadioButton4 := RadioButton{SELF,;
        ResourceID{ORDERWINDOW_THERADIOBUTTON4}}
        RadioButton4:HyperLabel := {#TheRadioButton4,;
        "Yen",,}
        oCCTheRadioButton5 := RadioButton{SELF,;
        ResourceID{ORDERWINDOW_THERADIOBUTTON5}}
        RadioButton5:HyperLabel := {#TheRadioButton5,;
        "British Pounds",,}
        oCCTheRadioButton6 := RadioButton{SELF,;
        ResourceID{ORDERWINDOW_THERADIOBUTTON6}}
        RadioButton6:HyperLabel := {#TheRadioButton6,;
        "German Marks",,}
        oDCCCurrency := RadioButtonGroup{SELF,;
        ResourceID{ORDERWINDOW_CURRENCY}}
        oDCCCurrency:FieldSpec := ;
        FieldSpec{#Currency,STRING,3,0}
        oDCCurrency:FillUsing({;
        {oCCTheRadioButton1,"USD"},;
        {oCCTheRadioButton2,"CDN"},;
        {oCCTheRadioButton3,"MEX"},;
        {oCCTheRadioButton4,"YEN"},;
        {oCCTheRadioButton5,"UK"},;
        {oCCTheRadioButton6,"DM"};
        })
        oDCCurrency:HyperLabel := {#Currency,"Currency",,}
      </code>
    </example>
  </RadioButtonGroup.FillUsing>

  <RadioButtonGroup.Hide>
    <summary>
      隐藏单选按钮组，使其不可见(直到后续调用 RadioButtonGroup:Show())。
    </summary>
  </RadioButtonGroup.Hide>

  <RadioButtonGroup.SetFocus>
    <summary>
      将输入焦点传递给单选按钮组中选中的单选按钮。
    </summary>
  </RadioButtonGroup.SetFocus>

  <RadioButtonGroup.Show>
    <summary>
      显示单选按钮组，使其可见。
    </summary>
    <remarks>
      RadioButtonGroup:Show() 通常用于重新显示使用 RadioButtonGroup:Hide() 方法隐藏的单选按钮组。
    </remarks>
  </RadioButtonGroup.Show>

  <RadioButtonGroup.TextValue>
    <summary>
      RadioButtonGroup:TextValue 包含 FillUsing() 数组的第一个元素
    </summary>
    <value>RadioButtonGroup:TextValue 包含 FillUsing() 数组的第一个元素</value>
    <remarks>
      RadioButtonGroup:TextValue 包含 FillUsing() 数组的第一个元素(通常是单选按钮的标题文本)的值；
      如果没有选中的按钮，RadioButtonGroup:TextValue 被设置为 NULL_STRING。
    </remarks>
  </RadioButtonGroup.TextValue>

  <RadioButtonGroup.Value>
    <summary>
      包含与单选按钮组中选中的单选按钮关联的组值设置(在窗口编辑器属性窗口上指定)。
    </summary>
    <value>包含与单选按钮组中选中的单选按钮关联的组值设置(在窗口编辑器属性窗口上指定)。</value>
    <remarks> 
      包含与单选按钮组中选中的单选按钮关联的组值设置(在窗口编辑器属性窗口上指定)。<br />
      控件的 Value 的数据类型由其字段规范确定；反过来，与数据服务器链接的控件继承字段规范和数据类型，
      因此，数据服务器的字段的数据类型和数据类型。<br />
      当控件通过将其名称设置为附加到数据窗口的服务器的字段的名称，使其成为数据感知的，Value 能够自动从这个字段读取和写入这个字段。
      <note type="tip">
        RadioButtonGroup:Value 可能不总是与控件的状态一致，如向最终用户指示的那样。<br />
        例如，如果字段的数据值不在单选按钮组的组值设置中，控件将处于“无匹配”状态。在这种情况下，控件将恢复到其初始的未选中状态。
      </note>
    </remarks>
  </RadioButtonGroup.Value>

  <RadioButtonGroup.Values>
    <exclude />
  </RadioButtonGroup.Values>

  <Range>
    <summary>
      创建一个范围，表示滚动条上的拇指位置可以移动的坐标(或滚动单位)的最小值和最大值—向上或向下，向左或向右。
    </summary>
  </Range>

  <Range.ctor>
    <summary>
      构造一个范围。
    </summary>
    <param name="nMin">范围中的最小值。默认值为0。</param>
    <param name="nMax">范围中的最大值。默认值为0。</param>
  </Range.ctor>

  <Range.IsInRange>
    <exclude />
  </Range.IsInRange>

  <Range.Max>
    <summary>
      一个数字值，表示此范围中的最大值。
    </summary>
    <value>一个数字值，表示此范围中的最大值。</value>
  </Range.Max>

  <Range.Min>
    <summary>
      一个数字值，表示此范围中的最小值。
    </summary>
    <value>一个数字值，表示此范围中的最小值。</value>
  </Range.Min>

  <RectangleObject>
    <summary>
      创建一个 RectangleObject 对象；这个类是 DrawObject 层次结构的一部分，它提供了一种显示和操作各种几何对象的方法。
    </summary>
    <example>
      要绘制一个 RectangleObject 对象，调用 Window:Draw()，并将 RectangleObject 对象作为参数传递。
      窗口通过询问每个对象来绘制自己来完成绘制，例如： 
      <code language="X#">
        METHOD Expose(oEvent) CLASS MyWindow
            LOCAL oRectangle AS OBJECT
            oRectangle := RectangleObject{Point{10,10},;
            Dimension{20,40}}
            SELF:Draw(oRectangle)
      </code>
    </example>
  </RectangleObject>

  <RectangleObject.ctor>
    <summary>
      构造一个矩形。
    </summary>
    <param name="oPoint">矩形的原点，以画布坐标表示。</param>
    <param name="oDimension">矩形的尺寸，以画布坐标表示。</param>
    <param name="oPen"> 用于绘制矩形的笔。默认情况下，<paramref name="oPen" />设置为 NIL，这会导致使用当前的笔。 </param>
    <param name="oBrush">用于填充矩形的刷子。如果省略，那么默认值为 NIL，这会导致使用当前的刷子。</param>
  </RectangleObject.ctor>

  <RectangleObject.Draw>
    <summary>
      在窗口上绘制矩形。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      这个方法不应该在应用程序代码中直接调用——它是在 X# 中由 Window:Draw() 调用的。请参考类描述中使用 Draw() 方法的示例。 
    </remarks>
  </RectangleObject.Draw>

  <ReportQueue>
    <summary>
      管理 Report Editor 的报告活动，以及 Report Editor 窗口的外观。
    </summary>
    <remarks>
      ReportQueue 类允许应用程序使用报告定义文件(*.RET)创建和格式化的报告来创建、编辑、打印、预览和保存报告。
    </remarks>
  </ReportQueue>

  <ReportQueue.ctor>
    <summary>
      构造一个报告队列。
    </summary>
    <param name="oOwner">拥有 ReportQueue 对象的窗口。</param>
    <param name="cServerName">
      要使用的 Report Editor 服务器。如果未指定，那么默认值为'Report Editor'，这是 Report Editor 运行时引擎。
    </param>
    <remarks>
      <note type="tip">Report Editor 是唯一支持的服务器。</note>
      ReportQueue:Init()创建一个由窗口拥有的 ReportQueue 对象。然后，可以使用这个对象进行顺序报告任务。 
    </remarks>
    <example> 
      这个示例创建一个包含 ReportQueue 对象的 shell 窗口： 
      <code language="X#">
        CLASS MyShellWindow INHERIT ShellWindow
            HIDDEN oRQ AS OBJECT

            METHOD Start() CLASS App
                LOCAL oSW := MyShellWind{}
                oSW:Show()
                SELF:Exec()

            METHOD Init() CLASS MyShellWind
                SUPER:Init()
                // 初始化服务器
                oRQ := ReportQueue{SELF,"Report Editor"}
      </code>
    </example>
  </ReportQueue.ctor>

  <ReportQueue.ActiveFile>
    <summary>
      Report Editor 服务器刚刚使用的报告定义文件。这个信息可以在 AppWindow:ReportNotification() 方法中使用。
    </summary>
    <value>Report Editor 服务器刚刚使用的报告定义文件。这个信息可以在 AppWindow:ReportNotification() 方法中使用。</value>
  </ReportQueue.ActiveFile>

  <ReportQueue.Close>
    <summary>
      关闭一个报告。
    </summary>
    <remarks>
      当程序完成一个报告时，应该关闭报告，以减少 Report Editor 的内存使用。这不会关闭 Report Editor；只会关闭其中打开的报告。<br />
      ReportQueue 通过调用 ReportQueue:Open() 方法打开的报告的堆栈(但它没有可见性，无法看到用户通过 Report Editor菜单打开的额外文件)。
      一旦所有报告都关闭了(通过 ReportQueue:Close() 方法或 Report Editor菜单)，ReportQueue 就不知道有任何打开的报告，
      会拒绝进一步的打印、预览或导出“当前报告”的调用，直到下一次 ReportQueue:Open() 调用。<br />
      ReportQueue:Close() 会在拥有窗口的状态栏中显示其状态。
      即使 ReportQueue 认为 Report Editor 没有打开任何报告，Close() 方法仍然会向 Report Editor 发送 FILE.CLOSE 命令。
      这个命令会被 Report Editor 静默地忽略，所以调用 ReportQueue:Close() 总是安全的。<br />
      ReportQueue:Close() 方法完全关闭一个报告。ReportQueue:Close() 方法会关闭预览(如果打开)，并/或关闭报告定义，这取决于打开的窗口类型。
      当报告或视图关闭时(无论是 ReportQueue 还是用户发起的关闭)，Report Editor 都会通知 ReportQueue。
    </remarks>
    <example> 
      下面的示例关闭一个报告定义： 
      <code language="X#">
        LOCAL oReportQueue := ReportQueue{SELF, "Report Editor"}
        oReportQueue:Open("one.ret")
        oReportQueue:Close()
      </code>
    </example>
  </ReportQueue.Close>

  <ReportQueue.CloseAll>
    <summary>
      关闭所有报告。
    </summary>
    <remarks>
      CloseAll() 会在拥有窗口的状态栏中显示其状态。它会保持 Report Editor服务器和程序的运行。
      CloseAll() 可以在任何时候安全地调用，可能在异常处理程序和清理例程中都很有用。
    </remarks>
  </ReportQueue.CloseAll>

  <ReportQueue.ConnectToDB>
    <summary>
      连接到 ODBC 数据源。
    </summary>
    <param name="cDataSourceName">要连接的 ODBC 数据源的名称。如果未指定数据源，将显示一个对话框，以便可以选择一个。</param>
    <param name="cUserName">这个数据源的 ODBC 用户名。</param>
    <param name="cPassword">这个数据源的 ODBC 密码或授权字符串。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Report Editor 需要一个活动的数据库连接。在打开报告之前，必须为报告数据库创建一个数据源。
    </remarks>
    <example> 下面的示例连接到一个“CA Xbase”数据源： 
      <code language="X#">
        oRQ:ConnectToDB("CA Xbase")
      </code>
    </example>
  </ReportQueue.ConnectToDB>

  <ReportQueue.DataUpdate>
    <summary> 
      处理 DataUpdateEvent，如果发生的话。如果需要对事件进行特殊处理，可以在派生的 ReportQueue 类中提供这个事件处理程序。 <br />
      重要！你既不应该尝试调用这个方法，也不应该提供这个方法的替代实现。
      相反，你可以在你的 AppWindow:ReportNotification() 的派生版本中提供对事件的额外处理。
    </summary>
    <param name="oIpcDataUpdateEvent">将主题名称、项目名称和更改的数据存储为字符串。</param>
    <remarks>
      这个方法执行未完成的 ReportQueue 方法(包括命令，如 Print() 和 SaveToFile()，或 Report Editor外观方法)。
      一旦打开了一个报告，后续的命令方法可以接受一个报告参数数组，这些参数将被插入到 Report Editor 报告文本和/或报告查询中。
      Report Editor 的外观可以同步地改变，但是 Report Editor 执行命令是异步的，所有后续的命令和外观更改都会被排队在 ReportQueue 中，
      直到 Report Editor 通知它已经完成了前一个命令。<br />
      ReportQueue 方法在它们的拥有窗口的状态栏上发布消息，每当它们发送一个命令给 Report Editor 时，都会用一个确认替换它。
    </remarks>
  </ReportQueue.DataUpdate>

  <ReportQueue.Edit>
    <summary>
      将一个报告加载到 Report Editor 中进行编辑。
    </summary>
    <remarks>
      这个方法允许用户编辑报告定义(.RET)文件，并提供与 IDE 相同的环境。
    </remarks>
    <example> 
      下面的示例打开“sales.ret”报告文件，并允许用户编辑文件： 
      <code language="X#">
        oRQ:Open("sales.ret")
        oRQ:Edit()
      </code>
    </example>
  </ReportQueue.Edit>

  <ReportQueue.EventType>
    <summary> 
      以下常量之一，表示一个事件： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>
            REPORTCLOSEEVENT
          </term>
          <description>当前报告已关闭。</description>
        </item>
        <item>
          <term>
            REPORTCOMPLETEERROREVENT
          </term>
          <description>打印或导出任务已中止。</description>
        </item>
        <item>
          <term>
            REPORTCOMPLETEEVENT
          </term>
          <description>打印或导出任务已完成。</description>
        </item>
        <item>
          <term>
            REPORTFILESAVEEVENT
          </term>
          <description>报告定义已关闭。</description>
        </item>
        <item>
          <term>
            REPORTOPENEVENT
          </term>
          <description>请求的报告已打开。</description>
        </item>
        <item>
          <term>
            REPORTSERVERCLOSEEVENT
          </term>
          <description>Report Editor 已关闭。</description>
        </item>
        <item>
          <term>
            REPORTVIEWCLOSEEVENT
          </term>
          <description>报告预览已关闭(但报告本身仍然打开)。</description>
        </item>
      </list>
      它应该只在你的窗口类的 AppWindow:ReportNotification() 方法中使用。 </summary>
    <value>
      一个常量，表示一个事件
    </value>
  </ReportQueue.EventType>

  <ReportQueue.Filename>
    <summary>
      定义报告的 .RET 文件的名称。这个访问在打开报告的函数中不太可能被使用——因为文件名字符串应该已经在函数中。
      如果一个方法打开了一个报告，另一个方法需要使用这个打开的文件，那么这个访问就会很有用。
      请注意，这个访问获取的是 Report Editor 在下一个命令方法执行时打开的报告的文件名，而不是 ReportQueue:ActiveFile，
      后者可能是 Report Editor 正在处理的较早的报告。
    </summary>
    <value>
      定义报告的 .RET 文件的名称。这个访问在打开报告的函数中不太可能被使用——因为文件名字符串应该已经在函数中。
      如果一个方法打开了一个报告，另一个方法需要使用这个打开的文件，那么这个访问就会很有用。
      请注意，这个访问获取的是 Report Editor 在下一个命令方法执行时打开的报告的文件名，而不是 ReportQueue:ActiveFile，
      后者可能是 Report Editor 正在处理的较早的报告。
    </value>
  </ReportQueue.Filename>

  <ReportQueue.Hide>
    <summary>
      隐藏 Report Editor 窗口和图标，使它们不可见。
    </summary>
  </ReportQueue.Hide>

  <ReportQueue.NEW>
    <summary>
      在 Report Editor 中创建一个新的报告定义进行编辑。
    </summary>
    <param name="cSQLSelectStatement">定义报告的 SQL Select 语句字符串。</param>
    <param name="kReportStyle">
      以下常量之一，表示新报告的报告样式：
    </param>
    <remarks>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>RPTSTYLE_CROSSTAB </term>
          <description>创建一个交叉表报告。</description>
        </item>
        <item>
          <term>RPTSTYLE_FORM</term>
          <description>创建一个基于表单的报告</description>
        </item>
        <item>
          <term>RPTSTYLE_FREESTYLE</term>
          <description>创建一个自由样式的报告</description>
        </item>
        <item>
          <term>
            RPTSTYLE_LABEL
          </term>
          <description>创建一个标签报告</description>
        </item>
        <item>
          <term>
            RPTSTYLE_LETTER
          </term>
          <description>创建一个信件报告</description>
        </item>
        <item>
          <term>RPTSTYLE_TABULAR </term>
          <description>创建一个表格报告</description>
        </item> 如果没有指定报告样式，那么将显示一个包含所有上述报告样式的对话框。 
      </list>
      这个方法允许用户编辑报告定义(.RET)文件，并提供与IDE相同的环境。 
    </remarks>
    <example> 
      下面的示例创建一个新的报告定义文件，并允许用户编辑文件： 
      <code language="X#">
        oRQ:New("SELECT CUSTOMERS * FROM C:\CAVO2x\SAMPLES\CUSTOMER")
      </code>
    </example>
  </ReportQueue.NEW>

  <ReportQueue.Open>
    <summary>
      打开一个报告。
    </summary>
    <param name="cReportName">一个现有的报告编辑器报告定义文件。如果没有给出扩展名，将在指定的文件名后添加 .RET。</param>
    <remarks> 
      在调用 ReportQueue 命令方法(如 Print() 或 Preview())之前，必须调用 Open()。
      在打开第二个报告之前，我们建议您关闭第一个报告，以节省内存，尽管这不是必需的。 Open() 在所有者窗口的状态栏中显示其状态。 
      <note type="tip">
        报告编辑器需要一个活动的数据库连接。在打开报告之前，您必须为报告数据库创建一个数据源，并使用 ReportQueue:ConnectToDB() 连接到它。
      </note>
    </remarks>
    <example> 
      这个示例打开一个报告定义： 
      <code language="X#">
        LOCAL od AS OBJECT
        LOCAL ReportFile AS STRING
        od := OpenDialog{SELF,"*.ret"}
        od:Show()
        ReportFile := od:FileName
        od:Destroy()
        oRQ:ConnectToDB(...)
        oRQ:Open(ReportFile)
      </code>
    </example>
  </ReportQueue.Open>

  <ReportQueue.Origin>
    <summary>
      定义报告编辑器窗口的左上角显示位置，以画布坐标表示。<br />
      报告编辑器从这个点向下显示。这与 X# 应用程序使用的坐标系统相反，X# 应用程序将其窗口的原点放在左下角，并向上显示窗口。
    </summary>
    <value>
      定义报告编辑器窗口的左上角显示位置，以画布坐标表示。<br />
      报告编辑器从这个点向下显示。这与 X# 应用程序使用的坐标系统相反，X# 应用程序将其窗口的原点放在左下角，并向上显示窗口。
    </value>
  </ReportQueue.Origin>

  <ReportQueue.owner>
    <summary>
      拥有 ReportQueue 对象的窗口。这个访问允许使用 ReportQueue 的代码调用所有者的方法(最终从 AppWindow 派生)。
    </summary>
    <value>拥有 ReportQueue 对象的窗口。这个访问允许使用 ReportQueue 的代码调用所有者的方法(最终从 AppWindow 派生)。</value>
  </ReportQueue.owner>

  <ReportQueue.Preview>
    <summary>
      在屏幕上预览一个报告。
    </summary>
    <param name="aParams">
      一个报告参数数组，由报告编辑器报告文件理解。这些报告参数可以被报告编辑器插入到报告文本中，和/或在报告查询中用作选择条件。
      使用逗号来默认任何未使用的参数或重复使用先前提供的参数。
    </param>
    <param name="cPreviewTitle">表示预览窗口的标题的字符串。如果省略，窗口标题栏将不显示标题。</param>
    <param name="lMDIChild">逻辑值，指示预览窗口是否是 MDI 子窗口(TRUE)还是不是(FALSE)。如果省略，缺省值是 FALSE。</param>
    <remarks>
      方法的状态会显示在所有者窗口的状态栏中，显示“&lt;ServerName&gt; 已完成报告。”
      参数在 Preview() 方法之前传递到报告编辑器，并将在后续的 Print() 方法中使用。您可以选择让预览的人决定是否打印报告，而不是让程序请求打印。
    </remarks>
    <example> 
      下面的示例在屏幕上预览一个文件，然后打印它： 
      <code language="X#">
        oRQ:ConnectToDB(...)
        oRQ:Open("sales.ret")
        oRQ:Preview({"Spain","1993"})
        oRQ:Print()
      </code>
    </example>
  </ReportQueue.Preview>

  <ReportQueue.Print>
    <summary>
      将报告打印到报告编辑器选择的打印机。
    </summary>
    <param name="aParams">
      一个报告参数数组，由报告编辑器报告文件理解。这些报告参数可以被报告编辑器插入到报告文本中，和/或在报告查询中用作选择条件。
      使用逗号来默认任何未使用的参数或重复使用先前提供的参数。
    </param>
    <param name="oRange">
      要打印的页码范围。省略此参数以打印报告的所有页面。Range:Min 参数为零表示“从开始”，而 Range:Max 参数为零表示“到结束”。
    </param>
    <remarks>
      报告参数在打印命令之前传递到报告编辑器，并将在后续的 Print() 方法中使用。
    </remarks>
    <example> 
      这个示例从同一个报告定义中打印三个不同的报告： 
      <code language="X#">
        // 打印所有
        oRQ:ConnectToDB(...)
        oRQ:Open{"sales.ret"}
        // 再次默认为 1992
        oRQ:Print({"Spain","1992"})
        oRQ:Print({"Ireland"})
        // 第二和第三页
        oRQ:Print({,"1993"},Range{2,3})
        oRQ:Close()
      </code>
    </example>
  </ReportQueue.Print>

  <ReportQueue.ReportExit>
    <summary>
      退出报告编辑器。
    </summary>
  </ReportQueue.ReportExit>

  <ReportQueue.ReportServer>
    <summary>
      此 ReportQueue 当前使用的 Report Editor 服务器。该值在 ReportQueue:Init() 方法中设置。
    </summary>
    <value>此 ReportQueue 当前使用的 Report Editor 服务器。该值在 ReportQueue:Init() 方法中设置。</value>
    <remarks>
      <note type="tip">唯一支持的服务器是 "Report Editor"。</note>
    </remarks>
  </ReportQueue.ReportServer>

  <ReportQueue.SaveToFile>
    <summary>
      将报告保存到给定的文件名。
    </summary>
    <param name="cTarget">要保存报告的文件。</param>
    <param name="cFormat">另一个字符串，定义要保存的格式，可以是 RTF 或 TEXT。富文本格式保留所有的间距、表格对齐、字体等特性。默认是 RTF。</param>
    <param name="aParams">一个字符串参数数组，这些参数是报告编辑器报告文件理解的报告参数。请参阅 ReportQueue:Preview() 方法下的讨论。</param>
    <example> 
      这个示例将两个文件以 RTF 格式保存到磁盘： 
      <code language="X#">
        oRQ:Print({"Spain","1992"})
        oRQ:SaveToFile("spain92.rtf","RTF")
        oRQ:SaveToFile("spain93.rtf",,{,"1993"})
      </code>
    </example>
  </ReportQueue.SaveToFile>

  <ReportQueue.SetPapersize>
    <summary>
      设置报告的纸张大小。
    </summary>
    <param name="iSize">
      一个整数，表示预定义纸张大小之一(见下文)。
      如果省略，缺省值是 1(Letter 8 1/2 x 11 in)。
    </param>
    <remarks> 
      <list>
        <item>
          <term>A3</term>
          <description>297 x 420 mm</description>
          <value>8</value>
        </item>
        <item>
          <term>A4</term>
          <description>210 x 297 mm</description>
          <value>9</value>
        </item>
        <item>
          <term>A4 Small</term>
          <description>210 x 297 mm</description>
          <value>10</value>
        </item>
        <item>
          <term>A5</term>
          <description>148 x 210 mm</description>
          <value>11</value>
        </item>
        <item>
          <term>B4</term>
          <description>250 x 354</description>
          <value>12</value>
        </item>
        <item>
          <term>B5</term>
          <description>182 x 257 mm</description>
          <value>13</value>
        </item>
        <item>
          <term>C size sheet</term>
          <description></description>
          <value>24</value>
        </item>
        <item>
          <term>D size sheet</term>
          <description></description>
          <value>25</value>
        </item>
        <item>
          <term>E size sheet</term>
          <description></description>
          <value>26</value>
        </item>
        <item>
          <term>Envelope B4</term>
          <description>250 x 353 mm</description>
          <value>33</value>
        </item>
        <item>
          <term>Envelope B5</term>
          <description>176 x 250 mm</description>
          <value>34</value>
        </item>
        <item>
          <term>Envelope B6</term>
          <description>176 x 125 mm</description>
          <value>35</value>
        </item>
        <item>
          <term>Envelope</term>
          <description></description>
          <value></value>
        </item>
        <item>
          <term>Envelope C5</term>
          <description>162 x 229 mm</description>
          <value>28</value>
        </item>
        <item>
          <term>Envelope C3</term>
          <description>324 x 458 mm</description>
          <value>29</value>
        </item>
        <item>
          <term>Envelope C4</term>
          <description>229 x 324 mm</description>
          <value>30</value>
        </item>
        <item>
          <term>Envelope C6</term>
          <description>114 x 162 mm</description>
          <value>31</value>
        </item>
        <item>
          <term>Envelope C65</term>
          <description>114 x 229 mm</description>
          <value>32</value>
        </item>
        <item>
          <term>Envelope DL</term>
          <description>110 x 220 mm</description>
          <value>27</value>
        </item>
        <item>
          <term>Envelope</term>
          <description>110 x 230 mm</description>
          <value>36</value>
        </item>
        <item>
          <term>Envelope Monarch</term>
          <description>3.875 x 7.5 in</description>
          <value>37</value>
        </item>
        <item>
          <term>6 3/4 Envelope</term>
          <description>3 5/8 x 6 1/2 in</description>
          <value>38</value>
        </item>
        <item>
          <term>Envelope #9</term>
          <description>3 7/8 x 8 7/8</description>
          <value>19</value>
        </item>
        <item>
          <term>Envelope #10</term>
          <description>4 1/8 x 9 1/2</description>
          <value>20</value>
        </item>
        <item>
          <term>Envelope #11</term>
          <description>4 1/2 x 10 3/8</description>
          <value>21</value>
        </item>
        <item>
          <term>Envelope #12</term>
          <description>4 3/4 x 11</description>
          <value>22</value>
        </item>
        <item>
          <term>Envelope #14</term>
          <description>5 x 11 1/2</description>
          <value>23</value>
        </item>
        <item>
          <term>Executive</term>
          <description>7 1/4 x 10 1/2 in</description>
          <value>7</value>
        </item>
        <item>
          <term>Folio</term>
          <description>8 1/2 x 13 in</description>
          <value>14</value>
        </item>
        <item>
          <term>German Std Fanfold</term>
          <description>8 1/2 x 12 in</description>
          <value>40</value>
        </item>
        <item>
          <term>German Legal Fanfold</term>
          <description>8 1/2 x 13 in</description>
          <value>41</value>
        </item>
        <item>
          <term>Ledger</term>
          <description>17 x 11 in</description>
          <value>4</value>
        </item>
        <item>
          <term>Legal</term>
          <description>8 1/2 x 14 in</description>
          <value>5</value>
        </item>
        <item>
          <term>Letter</term>
          <description>8 1/2 x 11 in</description>
          <value>1</value>
        </item>
        <item>
          <term>Letter Small</term>
          <description>8 1/2 x 11 in</description>
          <value>2</value>
        </item>
        <item>
          <term>Note</term>
          <description>8 1/2 x 11 in</description>
          <value>18</value>
        </item>
        <item>
          <term>Quarto</term>
          <description>215 x 275 mm</description>
          <value>15</value>
        </item>
        <item>
          <term>Statement</term>
          <description>5 1/2 x 8 1/2 in</description>
          <value>6</value>
        </item>
        <item>
          <term>Tabloid</term>
          <description>11 x 17 in</description>
          <value>3</value>
        </item>
        <item>
          <term>US Std Fanfold</term>
          <description>14 7/8 x 11 in</description>
          <value>39</value>
        </item>
        <item>
          <term>10x14 in</term>
          <description></description>
          <value>16</value>
        </item>
        <item>
          <term>11x17 in</term>
          <description></description>
          <value>17</value>
        </item>
      </list>
      纸张大小应在调用 Print() 或 Preview() 之前设置。 
      <note type="tip">
        并非所有打印机都支持所有纸张大小。请查阅打印机文档，了解支持的纸张大小。
      </note>
    </remarks>
    <example>
      <code language="X#">
        oRQ:SetPrinterPaperSize(5) // 将纸张大小设置为 Legal 8 1/2 x 14in
      </code>
    </example>
  </ReportQueue.SetPapersize>

  <ReportQueue.SetPrinterOrientation>
    <summary>
      设置报告的打印机方向。
    </summary>
    <param name="bOrientation">二进制值，表示打印机方向是纵向(0)还是横向(1)。如果省略，缺省值是 0(纵向)。</param>
    <remarks>
      在调用 Print() 或 Preview() 之前，应设置纸张方向。
    </remarks>
    <example>
      <code language="X#">
        oRQ:SetPrinterOrientation(1) // 将方向设置为横向
      </code>
    </example>
  </ReportQueue.SetPrinterOrientation>

  <ReportQueue.SetReportQuery>
    <summary>
      设置报告的查询。
    </summary>
    <param name="sQueryName">要用于报告的查询的名称。</param>
    <remarks>
      对于包含多个查询的报告，可以使用此方法在运行报告时选择要使用的查询。
      要查看可用的查询，进入报告编辑器，选择查询，设置报告查询菜单项。如果该菜单项被禁用，那么只有默认查询(QUERY1)被定义。
      否则，将出现一个设置报告查询对话框，列出可用的查询。
      在调用 Print() 或 Preview() 之前，应设置报告查询。
    </remarks>
    <example>
      <code language="X#">
        oRQ:SetReportQuery("QUERY2") // 将报告查询设置为 QUERY2
      </code>
    </example>
  </ReportQueue.SetReportQuery>

  <ReportQueue.SetSQLFile>
    <summary>
      将 SQL 查询文件加载为报告的活动 SQL 查询。
    </summary>
    <param name="sQueryFile">要加载的查询文件的名称。</param>
    <remarks> 
      从磁盘加载一个 SQL 查询文件，以用作此报告的活动查询。应在调用 Print() 或 Preview() 之前加载 SQL 查询文件。 
      <note type="tip">
        不支持 Query-By-Example(.QBE)查询文件。
      </note>
    </remarks>
    <example>
      <code language="X#">
        oRQ:SetSQLFile("QUERY6.SQL")
      </code>
    </example>
  </ReportQueue.SetSQLFile>

  <ReportQueue.SetSQLText>
    <summary>
      将文本字符串设置为报告的活动 SQL 查询。
    </summary>
    <param name="sQuery">要用作活动 SQL 查询的查询字符串。</param>
    <remarks>
      在调用 Print() 或 Preview() 之前，应设置查询文本。
    </remarks>
    <example>
      <code language="X#">
        oRQ:SetSQLText("SELECT Customer.* FROM " + "C:\CAVO2x\Samples\Explorer\Customer WHERE " + "Customer.CustNum = 8")
      </code>
    </example>
  </ReportQueue.SetSQLText>

  <ReportQueue.Show>
    <summary>
      最小化或最大化报告编辑器窗口。
    </summary>
    <param name="kShowState">
      报告编辑器窗口区域应显示的状态。指定以下常量之一：
    </param>
    <remarks>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>SHOWICONIZED</term>
          <description>将报告编辑器窗口图标化或最小化。</description>
        </item>
        <item>
          <term>SHOWNORMAL</term>
          <description>将报告编辑器窗口恢复为正常大小。这是默认值。</description>
        </item>
        <item>
          <term>SHOWZOOMED</term>
          <description>将报告编辑器窗口最大化到全屏。</description>
        </item>
      </list>
    </remarks>
  </ReportQueue.Show>

  <ReportQueue.Size>
    <summary>
      一个维度，表示报告编辑器窗口的当前大小，以画布坐标表示。
    </summary>
    <value>一个维度，表示报告编辑器窗口的当前大小，以画布坐标表示。</value>
  </ReportQueue.Size>

  <ResizeEvent>
    <summary>
      提供关于 ResizeEvent 的信息，用于指示窗口已调整大小。
    </summary>
    <remarks>
      当窗口的大小发生变化时，系统会生成 ResizeEvent，并将它们发送到 Window:Resize() 事件处理程序。
    </remarks>
  </ResizeEvent>

  <ResizeEvent.ctor>
    <inheritdoc />
  </ResizeEvent.ctor>

  <ResizeEvent.Height>
    <summary>
      一个数字值，表示生成此调整大小事件的窗口的画布区域的新高度，以画布坐标表示。
    </summary>
    <value>一个数字值，表示生成此调整大小事件的窗口的画布区域的新高度，以画布坐标表示。</value>
  </ResizeEvent.Height>

  <ResizeEvent.Size>
    <summary>
      一个维度，表示生成此调整大小事件的窗口的画布区域的新大小，以画布坐标表示。
    </summary>
    <value>一个维度，表示生成此调整大小事件的窗口的画布区域的新大小，以画布坐标表示。</value>
  </ResizeEvent.Size>

  <ResizeEvent.Width>
    <summary>
      一个数字值，表示生成此调整大小事件的窗口的画布区域的新宽度，以画布坐标表示。
    </summary>
    <value>
      一个数字值，表示生成此调整大小事件的窗口的画布区域的新宽度，以画布坐标表示。
    </value>
  </ResizeEvent.Width>

  <ResourceFile>
    <summary>
      识别包含资源信息的文件。
    </summary>
    <remarks>
      此类用于创建可以用于识别资源实体的对象。
    </remarks>
    <example> 
      以下示例使用 ResourceFile、ResourceID 和 ResourceString 类的各种方法来显示嵌入在.EXE文件中的资源字符串： 
      <code language="X#">
        CLASS MyMenu INHERIT Menu
        CLASS MyResFile INHERIT ResourceFile
        CLASS MyTopAppWin INHERIT TopAppWindow
            DEFINE IDM_MYMENU             := "MyMenu"
            DEFINE IDM_MYMENU_GETSTR1_ID  := 1001
            DEFINE IDM_MYMENU_GETSTR2_ID  := 1002
            DEFINE IDM_MYMENU_QUIT_ID     := 1003
            DEFINE IDT_STR1               := 2001
            DEFINE IDT_STR2               := 2002

            RESOURCE IDM_MYMENU MENU

            BEGIN
                POPUP "&amp;Menu1"

                BEGIN
                    MENUITEM "Get String &amp;1", IDM_MYMENU_GETSTR1_ID
                    MENUITEM "Get String &amp;2", IDM_MYMENU_GETSTR2_ID
                    MENUITEM SEPARATOR
                    MENUITEM "&amp;QUIT", IDM_MYMENU_QUIT_ID
                END
            END

            RESOURCE STRINGTABLE

            BEGIN
                IDT_STR1 "The 1st String"
                IDT_STR2 "The second string is 35 chars long."
            END

        METHOD Start() CLASS App
            LOCAL oWin AS Window
            oWin := MyTopAppWin{SELF}
            oWin:Show()
            SELF:Exec()
        
        METHOD Init(oOwnerApp) CLASS MyTopAppWin
            LOCAL lRetVal AS LONG
            SUPER:Init(oOwnerApp)
            SELF:Menu := MyMenu{SELF}
            SELF:Caption := "Resource File Demo Application"
        
        METHOD Init(oOwner) CLASS MyMenu
            SUPER:Init(ResourceID{IDM_MYMENU})
            SELF:RegisterItem(IDM_MYMENU_GETSTR1_ID, HyperLabel{#GetStr1,,,})
            SELF:RegisterItem(IDM_MYMENU_GETSTR2_ID, HyperLabel{#GetStr2,,,})
            SELF:RegisterItem(IDM_MYMENU_QUIT_ID,    HyperLabel{#GoQuit,,,})
        
        METHOD Init(fName) CLASS MyResFile
            IF fName == NIL
                SUPER:Init()
            ELSE
                SUPER:Init(fName)
            ENDIF
        
        METHOD GetStr1() CLASS MyTopAppWin
            SELF:GetStrX(IDT_STR1, 0)
        
        METHOD GetStr2() CLASS MyTopAppWin
            SELF:GetStrX(IDT_STR2, 100)
        
        METHOD GetStrX(nStrX,dy) CLASS MyTopAppWin
            LOCAL oResFile, oResID, oResString AS OBJECT

            oResFile    := MyResFile{"c:\cavo\mytstprg.exe"}
            oResID      := ResourceID{nStrX ,oResFile}
            oResString  := ResourceString{oResID}

            SELF:TextPrint(AsString(nStrX),                 Point{10, 10 + dy})
            SELF:TextPrint(AsString(oResString:Length),     Point{10, 30 + dy})
            SELF:TextPrint(AsString(oResString:Value),      Point{10, 50 + dy})
            SELF:TextPrint(AsString(oResString:AsString()), Point{10, 70 + dy})
        
        METHOD GoQuit() CLASS MyTopAppWin
            SELF:Owner:Quit()
      </code>
    </example>
  </ResourceFile>

  <ResourceFile.ctor>
    <summary>
      构造一个资源文件对象。
    </summary>
    <param name="sName">资源文件的名称，可以是 .EXE 或 .DLL 文件。如果省略，缺省值是可执行程序(.EXE)文件的名称。</param>
  </ResourceFile.ctor>

  <ResourceFile.Destroy>
    <summary>
      提供一种方法来取消实例化 ResourceFile 对象。
    </summary>
    <remarks>
      当不再需要 ResourceFile 对象时，可以使用此方法。
      ResourceFile:Destroy() 取消实例化 ResourceFile 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </ResourceFile.Destroy>

  <ResourceFile.Handle>
    <exclude />
  </ResourceFile.Handle>

  <ResourceID>
    <summary>
      通过数字资源ID识别和创建 ResourceID。
    </summary>
    <remarks>
      此类用于识别存储为资源实体中的数字值的应用程序资源。资源可以是光标、图标、位图、字符串或字体。
    </remarks>
    <example>
      有关使用 ResourceID 类的示例，请参阅 ResourceFile 类示例。
    </example>
  </ResourceID>

  <ResourceID.ctor>
    <summary>
      构造一个 ResourceID 对象。
    </summary>
    <param name="xID">
      资源ID的唯一ID，介于1和8000之间，或描述资源的字符串。字符串只能识别资源块，如对话框或菜单。对于单个控件，必须使用数字ID。
    </param>
    <param name="xResourceFile">包含资源的资源文件。默认值是当前可执行文件。</param>
  </ResourceID.ctor>

  <ResourceID.Address>
    <exclude />
  </ResourceID.Address>

  <ResourceID.Handle>
    <exclude />
  </ResourceID.Handle>

  <ResourceID.ID>
    <exclude />
  </ResourceID.ID>

  <ResourceString>
    <summary>
      从资源实体中提取字符串。
    </summary>
    <remarks>
      您可以使用此功能提供语言无关的应用程序(例如，用法语文本替换德语文本并重新编译资源实体)。
    </remarks>
    <example>
      有关使用 ResourceString 类的示例，请参阅 ResourceFile 类示例。
    </example>
  </ResourceString>

  <ResourceString.ctor>
    <summary>
      从资源实体中加载资源字符串。
    </summary>
    <param name="xResourceID">所需字符串的资源ID。</param>
    <param name="nMaxLen">
      您期望字符串在任何语言中的最大长度。例如，如果将字符串翻译为法语，它可能比英语中的字符串长。默认值为255。
      如果设置得太低，Windows 会截断资源字符串。
    </param>
  </ResourceString.ctor>

  <ResourceString.AsString>
    <summary>
      返回存储在资源字符串中的文本。
    </summary>
  </ResourceString.AsString>

  <ResourceString.Destroy>
    <summary>
      提供一种方法来取消实例化 ResourceString 对象。
    </summary>
    <remarks>
      当不再需要 ResourceString 对象时，可以使用此方法。
      ResourceString:Destroy() 取消实例化 ResourceString 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </ResourceString.Destroy>

  <ResourceString.Length>
    <summary>
      一个数字值，表示 ResourceString 对象的长度——字符的数量。
    </summary>
    <value>一个数字值，表示 ResourceString 对象的长度——字符的数量。</value>
  </ResourceString.Length>

  <ResourceString.Value>
    <summary>
      ResourceString 对象中保存的值。
    </summary>
    <value>ResourceString 对象中保存的值。</value>
  </ResourceString.Value>

  <RichEdit>
    <summary>
      创建一个富文本编辑控件。
    </summary>
    <remarks>
      富文本编辑是用户可以输入和编辑文本的控件。文本可以分配字符和段落格式，以及背景和前景颜色。富文本编辑提供了打印和搜索文本和单词断的编程接口。
    </remarks>
  </RichEdit>

  <RichEdit.ctor>
    <summary>
      构造一个富文本编辑。
    </summary>
    <param name="oOwner">拥有富文本的窗口。</param>
    <param name="xID">富文本的唯一ID(介于1和8000之间)。</param>
    <param name="nResourceID">富文本的资源ID。</param>
    <param name="oPoint">富文本在画布坐标中的原点。</param>
    <param name="oDimension">富文本在画布坐标中的尺寸。</param>
    <param name="kStyle">富文本的样式。</param>
  </RichEdit.ctor>

  <RichEdit.Alignment>
    <summary>
      一个常量，表示富文本的段落对齐方式：
    </summary>
    <value>一个常量，表示富文本的段落对齐方式：</value>
    <remarks> 
      以下常量之一，表示富文本的段落对齐方式： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>REPARA_CENTER</term>
          <description>文本居中</description>
        </item>
        <item>
          <term>REPARA_LEFT</term>
          <description>文本左对齐</description>
        </item>
        <item>
          <term>REPARA_RIGHT</term>
          <description>文本右对齐</description>
        </item>
      </list>
    </remarks>
  </RichEdit.Alignment>

  <RichEdit.BackgroundColor>
    <summary>
      一个 Color 对象，表示富文本的背景颜色
    </summary>
    <value>一个 Color 对象，表示富文本的背景颜色</value>
  </RichEdit.BackgroundColor>

  <RichEdit.CanPaste>
    <summary>
      确定富文本是否可以粘贴指定的剪贴板格式。
    </summary>
    <param name="dwClipboardFormat">
      指定的剪贴板格式。如果未指定，它默认为0，这意味着富文本对象将尝试使用当前剪贴板上的任何格式。
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">请参阅 Microsoft Win32 软件开发工具包文档中的 SetClipboardData() 函数，了解有效格式常量的定义。</note>
    </remarks>
  </RichEdit.CanPaste>

  <RichEdit.ControlFont>
    <exclude />
  </RichEdit.ControlFont>

  <RichEdit.EnableAdvancedTypography>
    <summary>
      设置高级分行和行格式的能力。
    </summary>
    <param name="lEnable">TRUE 打开，False 关闭。</param>
  </RichEdit.EnableAdvancedTypography>

  <RichEdit.Font>
    <summary>
      一个 Font 对象，表示富文本中文本或部分文本的字体选择。
    </summary>
    <value>一个 Font 对象，表示富文本中文本或部分文本的字体选择。</value>
  </RichEdit.Font>

  <RichEdit.GetOption>
    <summary>
      确定富文本的特定选项的状态。
    </summary>
    <param name="kOption">表示要检查其状态的选项的以下常量之一：</param>
    <returns>
      如果选项已启用，则返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>REOPT_AUTOWORD</term>
          <description>双击自动选择单词</description>
        </item>
        <item>
          <term>REOPT_AUTOVSCROLL</term>
          <description>自动垂直滚动</description>
        </item>
        <item>
          <term>REOPT_AUTOHSCROLL</term>
          <description>自动水平滚动</description>
        </item>
        <item>
          <term>REOPT_NOHIDESEL</term>
          <description>失去焦点时不隐藏选择</description>
        </item>
        <item>
          <term>REOPT_READONLY</term>
          <description>不允许编辑文本</description>
        </item>
        <item>
          <term>REOPT_WANTRETURN</term>
          <description>捕获回车键</description>
        </item>
        <item>
          <term>REOPT_SAVESEL</term>
          <description>失去焦点时保存选择</description>
        </item>
        <item>
          <term>REOPT_SELBAR</term>
          <description>有选择栏</description>
        </item>
      </list>
    </remarks>
  </RichEdit.GetOption>

  <RichEdit.GetTabStops>
    <summary>
      设置富文本控件的制表符停止位置。
    </summary>
    <returns>
      一个制表值数组。
    </returns>
    <remarks>
      返回的制表数组包含制表值。每个制表值是一个子数组，包含两个值。<br />
      第一个是厘米为单位的制表位置。<br />
      第二个是由以下常量之一定义的制表对齐方式 -<br />
      RICHTAB_CENTER<br />
      RICHTAB_DECIMAL<br />
      RICHTAB_NORMAL<br />
      RICHTAB_RIGHT<br />
    </remarks>
  </RichEdit.GetTabStops>

  <RichEdit.GetTextRange>
    <summary>
      从富文本中检索一系列字符。
    </summary>
    <param name="oRange">要检索的字符范围。</param>
    <returns>
      代表检索到的字符范围的字符串。
    </returns>
  </RichEdit.GetTextRange>

  <RichEdit.GetWordBreak>
    <summary>
      在富文本中定位特定类型的单词断点。
    </summary>
    <param name="nCharPos">从哪个字符位置开始查找单词断点。</param>
    <param name="kWordBreakType">以下常量之一，表示要检索的单词断点类型：</param>
    <returns> 
      如果<paramref name="kWordBreakType" />是 REGWB_ISDELIMITER，这个函数返回一个逻辑值，该值为 TRUE，如果指定的字符是分隔符，否则为 FALSE。<br />
      如果<paramref name="kWordBreakType" />是任何其他值，该函数返回一个数值，表示单词断点的字符位置。
    </returns>
    <remarks>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>REGWB_ISDELIMITER</term>
          <description>确定指定的字符是否为分隔符。这个选项导致逻辑返回值。</description>
        </item>
        <item>
          <term>REGWB_LEFT</term>
          <description>找到指定位置之前开始的最近一个单词的字符。</description>
        </item>
        <item>
          <term>REGWB_LEFTBREAK</term>
          <description>找到指定位置之前的下一个单词结束。</description>
        </item>
        <item>
          <term>REGWB_MOVEWORDLEFT</term>
          <description>找到指定位置之前开始的下一个单词的字符。</description>
        </item>
        <item>
          <term>REGWB_RIGHT</term>
          <description>找到指定位置之后开始的最近一个单词的字符。</description>
        </item>
        <item>
          <term>REGWB_RIGHTBREAK</term>
          <description>找到指定位置之后的下一个单词结束。</description>
        </item>
        <item>
          <term>REGWB_MOVEWORDRIGHT</term>
          <description>找到指定位置之后开始的下一个单词的字符。</description>
        </item>
      </list>
    </remarks>
  </RichEdit.GetWordBreak>

  <RichEdit.HideSelection>
    <summary>
      隐藏富文本中的选择。
    </summary>
    <param name="lTemporary">一个逻辑值，如果选择将被临时隐藏，则为 TRUE，否则为 FALSE。如果省略，默认为 TRUE。</param>
  </RichEdit.HideSelection>

  <RichEdit.LineFromCharacter>
    <summary>
      从指定的字符位置确定富文本的行号。
    </summary>
    <param name="nCharacterPos">一个数值，指定你想获取行号的字符位置。</param>
    <returns>
      指定字符位置的行号。
    </returns>
  </RichEdit.LineFromCharacter>

  <RichEdit.LoadFromFile>
    <summary>
      从 RTF 文件加载数据到富文本控件中。
    </summary>
    <param name="cFileName">你想加载的文件名。</param>
    <param name="dwFormat">** 缺少参数文档 **</param>
    <returns>
      如果成功，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      如果成功，富文本控件的当前内容将被 RTF 文件的内容所替换。
    </remarks>
  </RichEdit.LoadFromFile>

  <RichEdit.Margin>
    <summary>
      设置富文本控件中当前选定文本的边距。
    </summary>
    <param name="nStart">整数，表示段落中第一行的缩进。</param>
    <param name="nRight">整数，表示段落的右边距。</param>
    <param name="nOffset"> 
      整数，表示第二行及后续行相对于<paramref name="nStart" />的缩进。<br />
      如果这个值是正数，会创建悬挂缩进(第一行是'出dent'的，而后续行是缩进的)。<br />
      如果这个值是负数，第一行是缩进的，而后续行是出 dent 的。
    </param>
    <returns>
      如果成功，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      这个方法等同于设置 RichEdit:PrimaryIndent、RichEdit:RightMargin 和 RichEdit:SecondaryIndent 属性。
    </remarks>
  </RichEdit.Margin>

  <RichEdit.Numbering>
    <summary>
      一个常量，表示当前与富文本关联的段落编号类型：
    </summary>
    <value>一个常量，表示当前与富文本关联的段落编号类型：</value>
    <remarks> 
      以下常量之一，表示当前与富文本关联的段落编号类型： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>REPARA_NUMBER</term>
          <description>段落编号</description>
        </item>
        <item>
          <term>REPARA_BULLET</term>
          <description>段落是项目符号</description>
        </item>
      </list>
    </remarks>
  </RichEdit.Numbering>

  <RichEdit.PasteSpecial>
    <summary>
      在富文本中粘贴特定的剪贴板格式。
    </summary>
    <param name="dwClipboardFormat">
      指定的剪贴板格式。请参考 Microsoft Win32 软件开发工具包文档中的 SetClipboardData() 函数，了解有效的格式常量定义。
    </param>
  </RichEdit.PasteSpecial>

  <RichEdit.PrimaryIndent>
    <summary>
      一个数值，表示富文本中段落第一行的缩进。
    </summary>
    <value>一个数值，表示富文本中段落第一行的缩进。</value>
  </RichEdit.PrimaryIndent>

  <RichEdit.Print>
    <summary>
      打印富文本的内容。
    </summary>
    <param name="oPrintingDevice">将接收输出的打印设备对象或打印设备名称。如果省略，将为用户弹出打印对话框，选择打印目标。</param>
    <param name="oRange">要打印的字符范围。如果省略，将打印整个字符范围。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </RichEdit.Print>

  <RichEdit.Protected>
    <summary>
      一个逻辑值，如果富文本中的文本受到修改保护，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果富文本中的文本受到修改保护，则为 TRUE。</value>
  </RichEdit.Protected>

  <RichEdit.RightMargin>
    <summary>
      一个数值，表示富文本的右边距。
    </summary>
    <value>一个数值，表示富文本的右边距。</value>
  </RichEdit.RightMargin>

  <RichEdit.SaveToFile>
    <summary>
      将当前控件的内容保存到RTF文件中。
    </summary>
    <param name="cFileName">你想保存到的文件名。</param>
    <param name="dwFormat">** 缺少参数文档 **</param>
    <returns>
      如果成功，则返回 TRUE；否则返回 FALSE。
    </returns>
  </RichEdit.SaveToFile>

  <RichEdit.SecondaryIndent>
    <summary>
      一个数值，表示富文本中段落第二行及后续行的缩进。
    </summary>
    <value>一个数值，表示富文本中段落第二行及后续行的缩进。</value>
  </RichEdit.SecondaryIndent>

  <RichEdit.Seek>
    <summary>
      在富文本中搜索指定的文本。
    </summary>
    <param name="cText">要搜索的文本。</param>
    <param name="oRange">要在其中搜索的字符范围。</param>
    <param name="lMatchCase">一个逻辑值，如果搜索区分大小写，则为 TRUE。如果省略，将默认为 FALSE。</param>
    <param name="lWholeWord">一个逻辑值，如果搜索必须匹配整个单词，则为 TRUE。如果省略，将默认为 FALSE。</param>
    <param name="lReturnRange">
      一个逻辑值，如果返回值将是找到的文本的数字字符位置，则为 FALSE；如果返回值将是表示找到的文本的字符范围的 Range 对象，则为 TRUE。
      如果省略，将默认为 FALSE。
    </param>
    <param name="lSearchUp">
      如果 lSearchUp 为 TRUE，则从当前选择的末尾到文档的开始进行搜索。<br />
      如果 lSearchUp 为 FALSE，则从当前选择的末尾到文档的末尾进行搜索。<br />
      如果省略，将默认为 FALSE。<br />
      对于 Rich Edit 1.0，lSearchUp 参数将被忽略。搜索总是从当前选择的末尾到文档的末尾。
    </param>
    <returns> 
      如果<paramref name="lReturnRange" />为 TRUE，则返回找到的文本的字符范围。<br />
      如果<paramref name="lReturnRange" />为 FALSE，则返回找到的文本的字符位置。
    </returns>
  </RichEdit.Seek>

  <RichEdit.SelectedText>
    <summary>
      一个字符串，表示富文本中当前选择的文本。
    </summary>
    <value>一个字符串，表示富文本中当前选择的文本。</value>
  </RichEdit.SelectedText>

  <RichEdit.Selection>
    <summary>
      一个 Selection 对象，表示富文本中当前选择的文本。
    </summary>
    <value>一个 Selection 对象，表示富文本中当前选择的文本。</value>
  </RichEdit.Selection>

  <RichEdit.SelectionType>
    <summary>
      一个常量，表示富文本中当前选择的类型：
    </summary>
    <value>一个常量，表示富文本中当前选择的类型：</value>
    <remarks> 
      以下常量之一，表示富文本中当前选择的类型： 
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>RESEL_EMPTY</term>
          <description>当前选择为空</description>
        </item>
        <item>
          <term>RESEL_TEXT</term>
          <description>当前选择为文本</description>
        </item>
      </list>
    </remarks>
  </RichEdit.SelectionType>

  <RichEdit.SetOption>
    <summary>
      设置富文本的选项。
    </summary>
    <param name="kOption">以下常量之一，表示要设置的选项：</param>
    <param name="symOperation"> 
      以下符号名称之一，表示要执行的操作： 
      <list type="table">
        <listheader>
          <term>Operation</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>#Add</term>
          <description>将此选项添加到当前选项。这是默认值。</description>
        </item>
        <item>
          <term>#Change</term>
          <description>更改为此选项，删除所有其他选项</description>
        </item>
        <item>
          <term>#Keep</term>
          <description>仅保留此选项</description>
        </item>
        <item>
          <term>#Remove</term>
          <description>仅删除此选项</description>
        </item>
      </list>
    </param>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>REOPT_AUTOWORD</term>
          <description>双击自动选择单词</description>
        </item>
        <item>
          <term>REOPT_AUTOVSCROLL</term>
          <description>自动垂直滚动</description>
        </item>
        <item>
          <term>REOPT_AUTOHSCROLL</term>
          <description>自动水平滚动</description>
        </item>
        <item>
          <term>REOPT_NOHIDESEL</term>
          <description>失去焦点时不隐藏选择</description>
        </item>
        <item>
          <term>REOPT_READONLY</term>
          <description>不允许编辑文本</description>
        </item>
        <item>
          <term>REOPT_WANTRETURN</term>
          <description>捕获回车键</description>
        </item>
        <item>
          <term>REOPT_SAVESEL</term>
          <description>失去焦点时保存选择</description>
        </item>
        <item>
          <term>REOPT_SELBAR</term>
          <description>有选择栏</description>
        </item>
      </list>
    </remarks>
  </RichEdit.SetOption>

  <RichEdit.SetTabStops>
    <summary>
      为富文本控件设置TabStops。
    </summary>
    <param name="aTabStops">一个值数组。</param>
    <remarks>
      Tab 数组包含标签值。每个标签值都是一个包含两个值的子数组。<br />
      第一个是cm中的标签位置。<br />
      第二个是由以下常量之一定义的标签对齐方式 -<br />
      RICHTAB_CENTER<br />
      RICHTAB_DECIMAL<br />
      RICHTAB_NORMAL<br />
      RICHTAB_RIGHT
    </remarks>
  </RichEdit.SetTabStops>

  <RichEdit.ShowSelection>
    <summary>
      在富文本中显示选择。
    </summary>
    <param name="lTemporary">一个逻辑值，如果选择将被临时显示，则为 TRUE，否则为 FALSE。如果省略，将默认为 TRUE。</param>
  </RichEdit.ShowSelection>

  <RichEdit.TabStopCount>
    <summary>
      一个数值，表示富文本中的制表位数。
    </summary>
    <value>一个数值，表示富文本中的制表位数。</value>
  </RichEdit.TabStopCount>

  <RichEdit.TextColor>
    <summary>
      一个 Color 对象，表示富文本的文本颜色。
    </summary>
    <value>一个 Color 对象，表示富文本的文本颜色。</value>
  </RichEdit.TextColor>

  <RichEdit.TextLimit>
    <summary>
      一个数值，表示富文本中的最大文本量。默认值为32KB。
    </summary>
    <value>一个数值，表示富文本中的最大文本量。默认值为32KB。</value>
  </RichEdit.TextLimit>

  <RichEdit.Value>
    <summary>
      一个字符串，表示富文本的文本内容
    </summary>
    <value>一个字符串，表示富文本的文本内容</value>
  </RichEdit.Value>

  <RichEdit.ValueAsText>
    <exclude />
  </RichEdit.ValueAsText>

  <RichEditCallback.ctor>
    <exclude />
  </RichEditCallback.ctor>

  <RichEditCallback.BeginInvoke>
    <exclude />
  </RichEditCallback.BeginInvoke>

  <RichEditCallback.EndInvoke>
    <exclude />
  </RichEditCallback.EndInvoke>

  <RichEditCallback.Invoke>
    <exclude />
  </RichEditCallback.Invoke>

  <RichEditProtectEvent>
    <summary>
      提供有关富文本保护事件的信息，当用户尝试在富文本控件中编辑受保护的文本时，会生成此事件。
    </summary>
    <remarks>
      当在富文本中尝试编辑受保护的文本时，富文本会生成此消息。通过调用 RichEdit:Protect() 来保护文本。
    </remarks>
  </RichEditProtectEvent>

  <RichEditProtectEvent.ctor>
    <exclude />
  </RichEditProtectEvent.ctor>

  <RichEditProtectEvent.Selection>
    <summary>
      一个 Selection 对象，表示富文本中的选择范围。
    </summary>
    <value>一个 Selection 对象，表示富文本中的选择范围。</value>
  </RichEditProtectEvent.Selection>

  <RichEditProtectEvent.SelectionRange>
    <summary>
      一个 Range 对象，表示富文本中的选择范围。
    </summary>
    <value>一个 Range 对象，表示富文本中的选择范围。</value>
  </RichEditProtectEvent.SelectionRange>

  <RichEditSelectionEvent>
    <summary>
      提供有关富文本选择事件的信息，当在富文本控件中更改选择时，会生成此事件。
    </summary>
    <remarks>
      当在富文本中更改选择时，富文本会生成此消息。事件的属性包括新选择的类型和新选择的范围。
    </remarks>
  </RichEditSelectionEvent>

  <RichEditSelectionEvent.ctor>
    <exclude />
  </RichEditSelectionEvent.ctor>

  <RichEditSelectionEvent.Selection>
    <summary>
      一个 Selection 对象，表示富文本中的选择范围。
    </summary>
    <value>一个 Selection 对象，表示富文本中的选择范围。</value>
  </RichEditSelectionEvent.Selection>

  <RichEditSelectionEvent.SelectionRange>
    <summary>
      一个 Range 对象，表示富文本中的新选择范围。
    </summary>
    <value>一个 Range 对象，表示富文本中的新选择范围。</value>
  </RichEditSelectionEvent.SelectionRange>

  <RichEditSelectionEvent.SelectionType>
    <summary>
      一个常量，表示富文本中新选择的类型：
    </summary>
    <value>一个常量，表示富文本中新选择的类型：</value>
    <remarks> 
      以下常量之一，表示富文本中新选择的类型： 
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>RESEL_EMPTY</term>
          <description>当前选择为空</description>
        </item>
        <item>
          <term>RESEL_TEXT</term>
          <description>当前选择为文本</description>
        </item>
      </list>
    </remarks>
  </RichEditSelectionEvent.SelectionType>

  <SaveAsDialog>
    <summary>
      提供标准的保存文件对话框功能。
    </summary>
  </SaveAsDialog>

  <SaveAsDialog.ctor>
    <summary>
      构造一个标准的 SaveAs 对话框。
    </summary>
    <param name="oOwnWnd">拥有 SaveAsDialog 对象的窗口。</param>
    <param name="cInitPath">在对话框中显示的预设文件名。例如，可以使用这个参数提示用户当前文件的名称。也可以指定通配符，如*.TXT。默认为 NULL_STRING。</param>
    <param name="dwFlag">保留供将来使用。</param>
  </SaveAsDialog.ctor>

  <ScrollBar>
    <summary>
      提供所有 X# 滚动条的基类，所有 X# 滚动条都是从这个类派生的。
    </summary>
    <remarks>
      滚动条有一个标记，称为拇指，可以在一定范围内的值上下拖动(或左右)。拇指可以在滚动条上的不同位置拖动，也可以按块或单位上下移动。<br />
      GUI 滚动条自动维护块和单位操作。当进行块或单位操作时，会生成一个 ScrollEvent，其中包含实际拇指位置和如果更新滚动条时拇指将假设的位置。
      根据发生的滚动类型，块和单位的数量将被加或减到当前位置。<br />
      默认情况下，滚动条的范围是(0,99)，单位大小为1，块大小为10，初始拇指位置为0。
    </remarks>
  </ScrollBar>

  <ScrollBar.>
    <summary>
      一个数值，表示滚动条的拇指位置。
    </summary>
    <value>一个数值，表示滚动条的拇指位置。</value>
    <remarks>
      一个数值，表示滚动条的拇指位置。例如，值可以是数字42。ScrollBar:Value 的赋值也会改变 ScrollBar:TextValue 和 ScrollBar:ThumbPosition。如果要分配的值超出了与滚动条关联的允许的最小-最大范围，值将被修改，使其为最小或最大值。
    </remarks>
  </ScrollBar.>

  <ScrollBar.ctor>
    <summary>
      构造一个滚动条。
    </summary>
    <param name="oOwner">拥有滚动条的窗口。</param>
    <param name="xID">滚动条的唯一ID(1到8000之间)。</param>
    <param name="oPoint">滚动条在画布坐标中的原点。</param>
    <param name="oDimension">滚动条在画布坐标中的尺寸。</param>
    <param name="oResourceID">滚动条的资源ID。</param>
    <param name="lDataAware">一个逻辑值，指定列表框是否是数据感知的。</param>
  </ScrollBar.ctor>

  <ScrollBar.BlockSize>
    <summary>
      一个数值，表示滚动条的块大小
    </summary>
    <value>一个数值，表示滚动条的块大小</value>
    <remarks>
      一个数值，表示滚动条的块大小。
      块大小用于计算当 BLOCKINCREMENT 或 BLOCKDECREMENT ScrollEvent 发生时拇指的新位置，
      这是 ScrollEvent:Type 访问识别的事件类型之一。
      BlockSize 最初设置为10，但可以在运行时修改以更改滚动条的行为。
    </remarks>
  </ScrollBar.BlockSize>

  <ScrollBar.Create>
    <inheritdoc />
  </ScrollBar.Create>

  <ScrollBar.Destroy>
    <summary>
      提供一个方法来取消实例化一个 ScrollBar 对象。
    </summary>
    <remarks>
      当不再需要一个 ScrollBar 对象时，可以使用这个方法。
      ScrollBar:Destroy() 取消实例化 ScrollBar 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </ScrollBar.Destroy>

  <ScrollBar.Hide>
    <inheritdoc />
  </ScrollBar.Hide>

  <ScrollBar.Modified>
    <summary>
      一个逻辑值，对于滚动条来说，它被设置为 FALSE，因为它不包含可以编辑的文本。
    </summary>
    <value>一个逻辑值，对于滚动条来说，它被设置为 FALSE，因为它不包含可以编辑的文本。</value>
  </ScrollBar.Modified>

  <ScrollBar.PageSize>
    <exclude />
  </ScrollBar.PageSize>

  <ScrollBar.Range>
    <summary>
      一个范围对象，表示滚动条的拇指当前使用的最小和最大值。
    </summary>
    <value>一个范围对象，表示滚动条的拇指当前使用的最小和最大值。</value>
  </ScrollBar.Range>

  <ScrollBar.SetInfo>
    <summary>
      一次调用，设置所有滚动条属性。
    </summary>
    <param name="oScrollRange">指定滚动位置的最小和最大值。</param>
    <param name="nThumbPosition">指定滚动条的位置。</param>
    <param name="nPageSize">指定页面大小。滚动条使用这个值来确定比例滚动条的适当大小。</param>
    <param name="lDisableNoScroll">如果滚动条的新参数使滚动条不必要，禁用滚动条而不是移除它。</param>
  </ScrollBar.SetInfo>

  <ScrollBar.SetThumbPosition>
    <summary>
      设置滚动条的拇指位置
    </summary>
    <param name="nPosition">拇指的新位置。</param>
    <param name="lNotifyOwner">
      是否应该通知所有者？当为 TRUE 时，所有者将收到一个 WM_HSCROLL 或 WM_VSCROLL，wParam 包含 SB_THUMBTRACK，lParam 包含滚动条的句柄。</param>
  </ScrollBar.SetThumbPosition>

  <ScrollBar.Show>
    <inheritdoc />
  </ScrollBar.Show>

  <ScrollBar.TextValue>
    <summary>
      一个字符串，表示滚动条的拇指位置。
    </summary>
    <value>一个字符串，表示滚动条的拇指位置。</value>
    <remarks>
      一个字符串，表示滚动条的拇指位置。例如，值可以是"42"。ScrollBar:TextValue 的赋值也会改变 ScrollBar:ThumbPosition 和 ScrollBar:Value。如果要分配的值超出了与滚动条关联的允许的最小-最大范围，值将被修改，使其为最小或最大值。
    </remarks>
  </ScrollBar.TextValue>

  <ScrollBar.ThumbPosition>
    <summary>
      一个数值(短整数)，表示滚动条的当前拇指位置。
    </summary>
    <value>一个数值(短整数)，表示滚动条的当前拇指位置。</value>
    <remarks>
      一个数值(短整数)，表示滚动条的当前拇指位置。
      例如，值可以是数字42。ScrollBar:ThumbPosition 的赋值也会改变 ScrollBar:TextValue 和 ScrollBar:Value。如果要分配的值超出了与滚动条关联的允许的范围，值将被修改，使其为范围对象定义的最小或最大值。当创建滚动条时，ThumbPosition 被初始化为99，或者如果99超过了最大值，就被初始化为最大值。
    </remarks>
  </ScrollBar.ThumbPosition>

  <ScrollBar.UnitSize>
    <summary>
      一个数值，表示当前与滚动条关联的单位大小。
    </summary>
    <value>一个数值，表示当前与滚动条关联的单位大小。</value>
    <remarks>
      一个数值，表示当前与滚动条关联的单位大小。
      单位大小用于计算当发生 UNITINCREMENT 或 UNITDECREMENT ScrollEvent 时的新拇指位置。
      当创建滚动条时，ScrollBar:UnitSize 被初始化为1。ScrollBar:UnitSize 可以在运行时更改，以更改滚动条的行为。
    </remarks>
  </ScrollBar.UnitSize>

  <ScrollBar.Value>
    <inheritdoc />
  </ScrollBar.Value>

  <ScrollEvent>
    <summary>
      提供有关 ScrollEvent 的信息，当操作滚动条时生成。
    </summary>
    <remarks>
      ScrollEvent 事件发送到 Window:VerticalScroll() 或 Window:HorizontalScroll()，取决于是垂直滚动条还是水平滚动条生成了事件。
      ScrollEvent 报告以下内容：是哪个滚动条引起了事件，请求的滚动类型是什么，滚动条是窗口还是独立的滚动条。
      它还报告了旧的滚动条位置和期望的位置。旧位置是用户操作前拇指所在的位置；期望的位置是用户新位置的拇指(如果拇指是直接操作的，或者从块和单位大小计算出来的)。
    </remarks>
    <example> 
      通常，当收到一个 ScrollEvent 时，您会使用类似以下的代码更新滚动条的拇指位置： 
      <code language="X#">
        aScrollEvt:ScrollBar:ThumbPosition := aScrollEvt:Position
      </code>
    </example>
  </ScrollEvent>

  <ScrollEvent.ctor>
    <inheritdoc />
  </ScrollEvent.ctor>

  <ScrollEvent.IsWindowScroll>
    <summary>
      一个逻辑值，指示生成此 ScrollEvent 的滚动条是窗口滚动条还是独立的滚动条。
    </summary>
    <value>一个逻辑值，指示生成此 ScrollEvent 的滚动条是窗口滚动条还是独立的滚动条。</value>
    <remarks>
      一个逻辑值，指示生成此 ScrollEvent 的滚动条是窗口滚动条还是独立的滚动条。
      如果是窗口滚动条生成了这个 ScrollEvent，返回 TRUE；如果是独立的滚动条生成了这个 ScrollEvent，返回 FALSE。
    </remarks>
  </ScrollEvent.IsWindowScroll>

  <ScrollEvent.OldPosition>
    <summary>
      一个数值，表示 ScrollEvent 发生时滚动条的旧位置(即，用户操作前拇指所在的位置)。
    </summary>
    <value>一个数值，表示 ScrollEvent 发生时滚动条的旧位置(即，用户操作前拇指所在的位置)。</value>
    <remarks>
      一个数值，表示 ScrollEvent 发生时滚动条的旧位置(即，用户操作前拇指所在的位置)。
      通过从 ScrollEvent:OldPosition 减去 ScrollEvent:Position，可以使用相对差异来滚动拇指。
    </remarks>
  </ScrollEvent.OldPosition>

  <ScrollEvent.Position>
    <summary>
      一个数值，表示 ScrollEvent 发生时滚动条的期望位置(即，用户新位置的拇指)。
    </summary>
    <value>一个数值，表示 ScrollEvent 发生时滚动条的期望位置(即，用户新位置的拇指)。</value>
    <remarks>
      一个数值，表示 ScrollEvent 发生时滚动条的期望位置(即，用户新位置的拇指)。
      通过从 ScrollEvent:OldPosition 减去 ScrollEvent:Position，可以使用相对差异来滚动拇指。
    </remarks>
  </ScrollEvent.Position>

  <ScrollEvent.ScrollBar>
    <summary>
      生成此 ScrollEvent 的滚动条。
    </summary>
    <value>生成此 ScrollEvent 的滚动条。</value>
  </ScrollEvent.ScrollBar>

  <ScrollEvent.ScrollBarID>
    <summary>
      生成此 ScrollEvent 的滚动条的ID。
    </summary>
    <value>生成此 ScrollEvent 的滚动条的ID。</value>
  </ScrollEvent.ScrollBarID>

  <ScrollEvent.TYPE>
    <summary>
      一个字符串，表示生成此 ScrollEvent 时发生的滚动操作的类型。
    </summary>
    <value>一个字符串，表示生成此 ScrollEvent 时发生的滚动操作的类型。</value>
    <remarks> 
      一个字符串，表示生成此 ScrollEvent 时发生的滚动操作的类型。 返回以下值中的一个： 
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>BLOCKDECREMENT</term>
          <description>
            拇指位置已减少一个块。在 Windows 中，水平滚动条上拇指位置左侧的阴影区域，或者垂直滚动条上拇指位置上方的阴影区域，是一个块的减量。
          </description>
        </item>
        <item>
          <term>BLOCKINCREMENT</term>
          <description>
            拇指位置已增加一个块。在 Windows 中，水平滚动条上拇指位置右侧的阴影区域，或者垂直滚动条上拇指位置下方的阴影区域，是一个块的增量。
          </description>
        </item>
        <item>
          <term>SCROLLEND</term>
          <description>滚动已完成。</description>
        </item>
        <item>
          <term>SCROLLTHUMBDRAG</term>
          <description>拇指正在被拖动(向上或向下)。</description>
        </item>
        <item>
          <term>UNITDECREMENT</term>
          <description>
            拇指位置已减少一个单位。在 Windows 中，水平滚动条上左箭头的鼠标单击，或者垂直滚动条上上箭头的鼠标单击，是一个单位的减量。
          </description>
        </item>
        <item>
          <term>UNITINCREMENT</term>
          <description>
            拇指位置已增加一个单位。在 Windows 中，水平滚动条上右箭头的鼠标单击，或者垂直滚动条上下箭头的鼠标单击，是一个单位的增量。
          </description>
        </item>
      </list>
    </remarks>
  </ScrollEvent.TYPE>

  <SelectDialog>
    <summary>
      显示一个标准的颜色调色板对话框，让用户选择颜色。
    </summary>
    <remarks>
      这种类型的对话框以一系列“框”形式呈现给用户，允许用户通过点击框来选择颜色。用户不允许创建或选择自定义颜色。
    </remarks>
  </SelectDialog>

  <SelectDialog.ctor>
    <summary>
      构造一个标准的颜色选择对话框。
    </summary>
    <param name="uOwner">拥有 SelectDialog 对象的窗口。</param>
    <param name="oColor">
      SelectDialog 对象的初始选择的颜色。默认是当前使用的颜色。(有关在窗口编辑器属性窗口上指定颜色的详细信息，请参阅 Color:Init() 方法。)</param>
  </SelectDialog.ctor>

  <Selection>
    <summary>
      创建一个选择，它表示编辑控件中的文本选择的开始和结束，作为一个有序对。
    </summary>
    <remarks>
      选择在编辑控件中(即，由 Edit 和 EditWindow 类使用)中使用。选择的开始是编辑控件中包含在选择中的第一个字符的位置。结束是不在选择中的第一个字符的位置。例如，要指定从位置5到9(包括)的文本，您会给出一个值 Selection{5,10}。
      要选择编辑控件中的所有字符(例如，单行编辑控件)，您会指定一个值 Selection{0,-1}。
      如果开始和结束点相同，选择就是指向光标的位置。例如，光标在第五个字符前面的位置就被称为 Selection{5,5}。
    </remarks>
  </Selection>

  <Selection.ctor>
    <summary>
      构造一个选择。
    </summary>
    <param name="nStart">选择的开始。如果省略，那么默认是{0,0}。</param>
    <param name="nFinish">选择的结束。如果省略，那么默认是{0,0}。</param>
  </Selection.ctor>

  <Selection.Finish>
    <summary>
      一个数值，表示选择中的结束值。
    </summary>
    <value>一个数值，表示选择中的结束值。</value>
  </Selection.Finish>

  <Selection.Start>
    <summary>
      一个数值，表示选择中的开始值。
    </summary>
    <value>一个数值，表示选择中的开始值。</value>
  </Selection.Start>

  <SelectionSlider>
    <summary>
      创建一个选择滑块。
    </summary>
    <remarks>
      选择滑块是一个控件，它包含一个拇指，可选的刻度线，和一个选择条。用户可以使用鼠标或方向键移动选择滑块的拇指。
    </remarks>
  </SelectionSlider>

  <SelectionSlider.ctor>
    <summary>
      构造一个选择滑块。
    </summary>
    <param name="oOwner">拥有选择滑块的窗口。</param>
    <param name="xID">选择滑块的唯一ID(1到8000之间)。</param>
    <param name="nResourceID">选择滑块的资源ID。</param>
    <param name="oPoint">选择滑块在画布坐标中的原点。</param>
    <param name="oDimension">选择滑块在画布坐标中的尺寸。</param>
  </SelectionSlider.ctor>

  <SelectionSlider.ClearSelection>
    <summary>
      清除选择滑块的选择条。
    </summary>
  </SelectionSlider.ClearSelection>

  <SelectionSlider.SelectionRange>
    <summary>
      一个范围对象，表示滑块的选择条当前使用的最小和最大值。
    </summary>
    <value>一个范围对象，表示滑块的选择条当前使用的最小和最大值。</value>
  </SelectionSlider.SelectionRange>

  <SelfPtr>
    <exclude />
  </SelfPtr>

  <SelfPtr.ptrSelf>
    <exclude />
  </SelfPtr.ptrSelf>

  <ShapeObject>
    <summary>
      提供一个中间类，所有 X# 二维对象都是它的子类。
    </summary>
    <remarks>
      <br />重要！ShapeObject 是一个抽象类，不应该直接使用，而是使用它的子类之一，包括 BitmapObject、EllipseObject 和 RectangleObject。 
    </remarks>
  </ShapeObject>

  <ShapeObject.ctor>
    <summary>
      构造一个 ShapeObject 对象。
    </summary>
    <param name="oPoint">ShapeObject 对象的原点，以画布坐标表示。</param>
    <param name="oDimension">ShapeObject 对象的尺寸，以画布坐标表示。</param>
    <param name="oPen">在 Draw() 中使用的笔。如果省略，将使用当前选择的笔。</param>
    <param name="oBrush">在 Draw() 中使用的刷子。如果省略，将使用当前选择的刷子。</param>
  </ShapeObject.ctor>

  <ShapeObject.BoundingBox>
    <summary>
      一个边界框，表示完全包围 ShapeObject 对象的最小矩形。
    </summary>
    <value>一个边界框，表示完全包围 ShapeObject 对象的最小矩形。</value>
  </ShapeObject.BoundingBox>

  <ShapeObject.Brush>
    <summary>
      ShapeObject 对象当前使用的刷子，用于绘制自身。
    </summary>
    <value>ShapeObjec t对象当前使用的刷子，用于绘制自身。</value>
  </ShapeObject.Brush>

  <ShapeObject.Destroy>
    <exclude />
  </ShapeObject.Destroy>

  <ShapeObject.Pen>
    <summary>
      ShapeObject 对象当前使用的笔，用于绘制自身。
    </summary>
    <value>ShapeObject 对象当前使用的笔，用于绘制自身。</value>
  </ShapeObject.Pen>

  <ShapeObject.Size>
    <summary>
      一个维度，表示 ShapeObject 对象当前的大小，以画布坐标表示。
    </summary>
    <value>一个维度，表示 ShapeObject 对象当前的大小，以画布坐标表示。</value>
  </ShapeObject.Size>

  <ShellWindow>
    <summary>
      创建一个 shell 窗口，为您的应用程序提供 MDI 支持。
    </summary>
    <remarks>
      shell 窗口类似于顶级应用程序窗口，但它充当 MDI 客户端窗口，该窗口的所有子窗口都充当 MDI 子窗口。
      子窗口的样式由其所有者的类型确定。默认情况下，其所有者是 shell 窗口的子应用程序窗口会自动充当 MDI 子窗口。如果您不希望这种行为，可以使用 ChildAppWindow:Init() 方法来禁止它。
      当激活子窗口时，其菜单会自动放置在父窗口上。当没有打开的子窗口时，将使用父窗口的菜单。MenuCommand 事件将发送到任何当前活动的子窗口。如果没有活动的子窗口，系统会将事件发送到父窗口的默认事件处理程序。有关事件传播的深入讨论，请参阅程序员指南。
      在 MDI 应用程序中，通常有一个下拉菜单，其中包含当前打开的 MDI 子窗口的标题。系统会检查当前活动的 MDI 窗口的名称；此外，当用户在此菜单上选择一个名称时，系统会激活相应的 MDI 窗口。
      使用 Menu:SetAutoUpdate() 方法来指定要使用的下拉菜单。
    </remarks>
  </ShellWindow>

  <ShellWindow.ctor>
    <summary>
      构造一个 shell 窗口。
    </summary>
    <param name="oOwner">拥有 shell 窗口的窗口。</param>
  </ShellWindow.ctor>

  <ShellWindow.ToolBar>
    <inheritdoc />
  </ShellWindow.ToolBar>

  <ShellWindow.Arrange>
    <summary>
      平铺、图标化或级联当前在此 shell 窗口中打开的所有子窗口。
    </summary>
    <param name="kArrangeStyle">
      一个数字，指示应如何排列窗口。可以是 ARRANGEASICONS、ARRANGECASCADE、ARRANGETILEVERTICAL、ARRANGETILEHORIZONTAL中的一个。
    </param>
  </ShellWindow.Arrange>

  <ShellWindow.Background>
    <summary>
      此属性继承自 Window 类，但不适用于 ShellWindow。
    </summary>
    <value>此属性继承自 Window 类，但不适用于 ShellWindow。</value>
  </ShellWindow.Background>

  <ShellWindow.CanvasErase>
    <summary>
      此方法继承自 Window 类，但不适用于 ShellWindow。
    </summary>
  </ShellWindow.CanvasErase>

  <ShellWindow.ChildToolBarLocation>
    <summary>
      指定子窗口工具栏的位置。
    </summary>
    <value>指定子窗口工具栏的位置。</value>
    <remarks> 
      指定子窗口工具栏的位置。有效的值包括： TBL_CHILD 子窗口的工具栏显示在子窗口中。这是<b>默认</b>设置。 
      TBL_SHELL 子窗口的工具栏显示在 shell 窗口中，并替换 shell 窗口的工具栏。 
    </remarks>
  </ShellWindow.ChildToolBarLocation>

  <ShellWindow.CloseAllChildren>
    <summary>
      向所有打开的 MDI 子窗口发送关闭消息。
    </summary>
  </ShellWindow.CloseAllChildren>

  <ShellWindow.Default>
    <inheritdoc />
  </ShellWindow.Default>

  <ShellWindow.Destroy>
    <summary>
      提供一个方法，用于释放为 ShellWindow 对象及其派生对象分配的内存资源。
    </summary>
    <remarks>
      此方法立即释放为应用程序中显式创建的 ShellWindow 对象分配的资源。
      ShellWindow:Destroy() 还会处理为派生类分配的资源，并按照必要的顺序释放它们。
    </remarks>
  </ShellWindow.Destroy>

  <ShellWindow.Dispatch>
    <inheritdoc />
  </ShellWindow.Dispatch>

  <ShellWindow.Draw>
    <summary>
      此方法继承自 Window 类，但不适用于 ShellWindow。
    </summary>
  </ShellWindow.Draw>

  <ShellWindow.EnableOleStatusMessages>
    <summary>
      控制 OLE 对象的状态消息显示。
    </summary>
    <param name="lEnable">一个逻辑值，指定是否启用(TRUE)或禁用(FALSE)状态消息显示。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      调用 ShellWindow:EnableOLEStatusMessage(TRUE) 后，浏览 OLE 对象的菜单项将调用 ShellWindow:OnOLEStatusMessage()，
      并将状态字符串作为参数传递。默认情况下，ShellWindow:OnOLEStatusMessage() 会在 shell 窗口的状态栏中显示状态字符串。
    </remarks>
  </ShellWindow.EnableOleStatusMessages>

  <ShellWindow.Foreground>
    <summary>
      此方法继承自 Window 类，但不适用于 ShellWindow。
    </summary>
    <value>此方法继承自 Window 类，但不适用于 ShellWindow。</value>
  </ShellWindow.Foreground>

  <ShellWindow.GetActiveChild>
    <summary>
      返回当前活动的 MDI 子窗口的窗口对象。
    </summary>
  </ShellWindow.GetActiveChild>

  <ShellWindow.Handle>
    <summary>
      返回 shell 窗口的句柄。
    </summary>
    <param name="nHandleType">所需句柄的类型。指定0获取窗口句柄，指定2获取窗口设备上下文。如果省略，0是默认值。</param>
    <returns>
      一个描述底层系统对象的窗口的句柄。
    </returns>
    <remarks>
      此方法提供窗口的句柄，可以通过 Windows API 调用使用。
    </remarks>
  </ShellWindow.Handle>

  <ShellWindow.HelpRequest>
    <summary>
      提供一个方法，当用户使用可用的上下文敏感帮助机制之一从应用程序请求帮助时，会调用该方法。
    </summary>
    <param name="oHelpRequestEvent">描述正在请求帮助的项目的 HelpRequestEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      只有在当前窗口(或其所有者之一)启用了帮助机制时，才会调用此事件处理程序。通过将 HelpDisplay 对象分配给窗口的 HelpDisplay 属性来启用帮助机制。
      此事件处理程序的默认实现是在生成 HelpRequestEvent 的控件、菜单命令或窗口区域的帮助主题时显示帮助。这是通过使用 HelpDisplay:Show(&lt;cKeyword&gt;) 来实现的，其中 &lt;cKeyword&gt;是 HyperLabel:HelpContext 属性或在没有超级标签可用的情况下由此事件处理程序生成的默认关键字。
      如果没有为项目生成超级标签，生成的关键字如下：
      HELPCONTROL 请求生成的关键字是 Control_xxxx，其中 xxxx 是控件的数字ID，以十进制表示。例如，OK 按钮可能生成的关键字是 Control_101。
      HELPMENU 请求生成的关键字是M enu_xxxx，其中 xxxx 是菜单命令的“清理”文本。清理文本已删除所有前导和尾随空格和和字符(&amp;)的字符。此外，所有空格序列都替换为一个下划线，并且字符串在第一个制表符处截断。
      例如，对于菜单命令： Save &amp;As\tF3 
      是 Menu_Save_As  HELPWINDOW  request 生成下表中列出的关键字之一，
      取决于拥有焦点的窗口区域。
      <table>
        <tr>
          <th>Keyword</th>
          <th>Region</th>
        </tr>
        <tr>
          <td>Window</td>
          <td>Any area of the window not explicitly identified in this table</td>
        </tr>
        <tr>
          <td>Window_Border</td>
          <td>Border</td>
        </tr>
        <tr>
          <td>Window_Caption</td>
          <td>Title bar</td>
        </tr>
        <tr>
          <td>Window_MaxBox</td>
          <td>Maximize button</td>
        </tr>
        <tr>
          <td>Window_MinBox</td>
          <td>Minimize button</td>
        </tr>
        <tr>
          <td>Window_SysMenuBox</td>
          <td>System menu button</td>
        </tr>
        <tr>
          <td>Window_Unknown</td>
          <td>Any area of the window not explicitly identified in this table</td>
        </tr>
        <tr>
          <td>Window_WindowCanvas</td>
          <td>Canvas area</td>
        </tr>
      </table>
      <note type="tip">
        如果生成 Window_Unknown 关键字，HelpRequest() 的默认行为是显示 HelpDisplay 中定义的 Contents 主题(即，HelpDisplay:Show("HelpIndex"))。
      </note> 
      如果接收到 HELPWINDOW 请求，同时 Window:HelpContext 已定义，Window:HelpRequest() 将使用 HelpContext 属性，而不管具有焦点的窗口区域是什么。有关如何为应用程序编程在线帮助系统的更多信息，请参阅程序员指南中的“GUI类”章节。
    </remarks>
  </ShellWindow.HelpRequest>

  <ShellWindow.LineTo>
    <summary>
      此方法继承自 Window 类，但不适用于 ShellWindow。
    </summary>
  </ShellWindow.LineTo>

  <ShellWindow.MoveTo>
    <summary>
      此方法继承自 Window 类，但不适用于 ShellWindow。
    </summary>
  </ShellWindow.MoveTo>

  <ShellWindow.OnOleStatusMessage>
    <summary>
      提供一个处理程序例程，用于处理 OLE 对象的状态消息。
    </summary>
    <param name="cMsgString">要显示的状态字符串。</param>
    <remarks>
      每当用户浏览一个 OLE 对象的菜单时，都会调用 ShellWindow:OnOLEStatusMessage()。默认实现会在 shell 窗口的状态栏中显示状态字符串。
      永远不应该直接调用此方法。相反，如果要更改默认实现，可以为派生类编写自己的 OnOLEStatusMessage()方法。
    </remarks>
  </ShellWindow.OnOleStatusMessage>

  <ShellWindow.Owner>
    <summary>
      shell 窗口的所有者，可以是 Window 或 App 对象。
    </summary>
    <value>shell 窗口的所有者，可以是 Window 或 App 对象。</value>
  </ShellWindow.Owner>

  <ShellWindow.PaintBoundingBox>
    <summary>
      此方法继承自 Window 类，但不适用于 ShellWindow。
    </summary>
  </ShellWindow.PaintBoundingBox>

  <ShellWindow.Pen>
    <summary>
      此方法继承自 Window 类，但不适用于 ShellWindow。
    </summary>
    <value>此方法继承自 Window 类，但不适用于 ShellWindow。</value>
  </ShellWindow.Pen>
  
  <ShellWindow.RePaint>
    <summary>
      此方法继承自 Window 类，但不适用于 ShellWindow。
    </summary>
  </ShellWindow.RePaint>

  <ShellWindow.RepaintBoundingBox>
    <summary>
      此方法继承自 Window 类，但不适用于 ShellWindow。
    </summary>
  </ShellWindow.RepaintBoundingBox>

  <ShellWindow.Resize>
    <inheritdoc />
  </ShellWindow.Resize>

  <ShellWindow.TextColor>
    <summary>
      此方法继承自 Window 类，但不适用于 ShellWindow。
    </summary>
    <value>此方法继承自 Window 类，但不适用于 ShellWindow。</value>
  </ShellWindow.TextColor>

  <ShellWindow.TextPrint>
    <summary>
      此方法继承自 Window 类，但不适用于 ShellWindow。
    </summary>
  </ShellWindow.TextPrint>

  <ShellWindow.ToolBarHeightChanged>
    <inheritdoc />
  </ShellWindow.ToolBarHeightChanged>

  <SingleLineEdit>
    <summary>
      创建一个单行编辑控件，用于在服务器的变量或字段中显示和输入信息。
      单行编辑控件可以绑定到任何类型(字符、日期、逻辑、数值或备忘录)的数据服务器字段。
    </summary>
  </SingleLineEdit>

  <SingleLineEdit.ctor>
    <summary>
      构造一个单行编辑控件。
    </summary>
    <param name="oOwner">拥有单行编辑控件的窗口。</param>
    <param name="xID">单行编辑控件的唯一ID(1到8000之间)。</param>
    <param name="oPoint">单行编辑控件在画布坐标中的原点。</param>
    <param name="oDimension">单行编辑控件在画布坐标中的尺寸。</param>
    <param name="kStyle">单行编辑控件的样式，指定为以下常量之一：</param>
    <param name="nResourceID">单行编辑控件的资源ID。</param>
    <remarks>
      <include file="Gui.xml" path="doc/EditConstants/*" />
      <note type="tip">
        除了上面指定的样式常量，您还可以使用任何 Windows API 样式常量。
        请参阅 Microsoft Win32 软件开发工具包文档，了解有关特定常量的详细信息。
      </note>
    </remarks>
  </SingleLineEdit.ctor>

  <SingleLineEdit.AutoFocusChange>
    <summary>
      一个逻辑值，控制光标是否应在编辑控件的末尾时跳到下一个控件。默认值为 FALSE。
    </summary>
    <value>一个逻辑值，控制光标是否应在编辑控件的末尾时跳到下一个控件。默认值为 FALSE。</value>
  </SingleLineEdit.AutoFocusChange>

  <SingleLineEdit.CreateFormattedString>
    <summary>
      根据提供的参数创建格式化文本。
    </summary>
    <param name="cPicture">作为字符串的图片子句。</param>
    <param name="cType">单行编辑控件的唯一ID(1到8000之间)。</param>
    <param name="cDefTempl">单行编辑控件在画布坐标中的原点。</param>
    <remarks>
      此方法允许开发人员以其他方式创建格式化文本，而不是使用内部类 __FormattedString，并且避免使用内部类直接赋值的需要。
    </remarks>
  </SingleLineEdit.CreateFormattedString>

  <SingleLineEdit.CurrentText>
    <summary>
      一个字符串，表示当前在编辑框中显示的文本。
    </summary>
    <value>一个字符串，表示当前在编辑框中显示的文本。</value>
    <remarks>
      一个字符串，表示当前在编辑框中显示的文本。当焦点转移到另一个控件时，SingleLineEdit:CurrentText 的赋值也会改变 SingleLineEdit:TextValue 和 SingleLineEdit:Value。
    </remarks>
  </SingleLineEdit.CurrentText>

  <SingleLineEdit.Destroy>
    <summary>
      提供一种方法来取消实例化一个 SingleLineEdit 对象。
    </summary>
    <remarks>
      当不再需要一个 SingleLineEdit 对象时，可以使用这个方法。SingleLineEdit:Destroy() 取消实例化 SingleLineEdit 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </SingleLineEdit.Destroy>

  <SingleLineEdit.Dispatch>
    <inheritdoc />
  </SingleLineEdit.Dispatch>

  <SingleLineEdit.FocusChange>
    <exclude />
  </SingleLineEdit.FocusChange>

  <SingleLineEdit.FocusSelect>
    <summary>
      控制编辑控件获得焦点时的选择。
    </summary>
    <value>控制编辑控件获得焦点时的选择。</value>
    <remarks>
      <para>有效值为：</para>
      <list type="table">
        <item>
          <term>FSEL_ALL</term>
          <description>选择控件的所有内容。</description>
        </item>
        <item>
          <term>FSEL_TRIM</term>
          <description> 选择修剪后的内容。这是<b>默认</b>。 </description>
        </item>
        <item>
          <term>FSEL_HOME</term>
          <description>不选择任何内容；光标定位在编辑控件的开头。</description>
        </item>
        <item>
          <term>FSEL_END</term>
          <description>不选择任何内容；光标定位在编辑控件的末尾。</description>
        </item>
      </list>
    </remarks>
  </SingleLineEdit.FocusSelect>

  <SingleLineEdit.OverWrite>
    <summary>
      一个常量，表示单行编辑控件的覆盖模式。
    </summary>
    <value>一个常量，表示单行编辑控件的覆盖模式。</value>
    <remarks> 
      一个常量，表示单行编辑控件的覆盖模式。此属性仅影响具有活动 PICTURE 子句的编辑控件。有效值为： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>OVERWRITE_NEVER</term>
          <description>编辑控件始终处于插入模式。</description>
        </item>
        <item>
          <term>OVERWRITE_ONKEY</term>
          <description>模式取决于 INSERT 键的状态。</description>
        </item>
        <item>
          <term>OVERWRITE_ALWAYS</term>
          <description>编辑控件始终处于覆盖模式。</description>
        </item>
      </list>
    </remarks>
  </SingleLineEdit.OverWrite>

  <SingleLineEdit.Picture>
    <summary>
      单行编辑控件的图片子句。
    </summary>
    <value>单行编辑控件的图片子句。</value>
    <remarks>
      单行编辑控件的图片子句。如果单行编辑控件附有字段规范，图片应该在字段规范中提供，而不是通过窗口编辑器的属性窗口提供。
      使用 SingleLineEdit:Picture 的赋值将覆盖字段规范的图片子句。
    </remarks>
  </SingleLineEdit.Picture>

  <SingleLineEdit.ScrollMode>
    <summary>
      指定滚动行为(例如，按下删除键时)。
    </summary>
    <value>指定滚动行为(例如，按下删除键时)。</value>
    <remarks>
      <para>指定滚动行为(例如，按下删除键时)。有效值为：</para>
      <list type="table">
        <item>
          <term>
            SCRMODE_FULL
          </term>
          <description> 滚动整个编辑控件的内容。这是<b>默认</b>。 </description>
        </item>
        <item>
          <term>
            SCRMODE_PART
          </term>
          <description>部分滚动在非编辑模板字符处停止。</description>
        </item>
        <item>
          <term>SCRMODE_NO</term>
          <description>无滚动。</description>
        </item>
      </list>
    </remarks>
  </SingleLineEdit.ScrollMode>

  <SingleLineEdit.TextValue>
    <exclude />
  </SingleLineEdit.TextValue>

  <SingleLineEdit.Undo>
    <inheritdoc />
  </SingleLineEdit.Undo>

  <SingleLineEdit.Value>
    <summary>
      SingleLineEdit:Value 包含在上一次编辑操作后存储的文本。SingleLineEdit:Value 的赋值也会改变 SingleLineEdit:CurrentText，SingleLineEdit:TextValue 和 SingleLineEdit:ValueChanged。
    </summary>
    <value>
      SingleLineEdit:Value 包含在上一次编辑操作后存储的文本。SingleLineEdit:Value 的赋值也会改变 SingleLineEdit:CurrentText，SingleLineEdit:TextValue 和 SingleLineEdit:ValueChanged。</value>
  </SingleLineEdit.Value>

  <Slider>
    <summary>
      创建一个滑块控件。
    </summary>
    <remarks>
      滑块是一个控件，它包含一个拇指和可选的刻度线。用户可以使用鼠标或方向键移动滑块的拇指。
    </remarks>
  </Slider>

  <Slider.ctor>
    <summary>
      构造一个滑块。
    </summary>
    <param name="oOwner">拥有滑块的窗口。</param>
    <param name="xID">滑块的唯一ID(1到8000之间)。</param>
    <param name="nResourceID">滑块的资源ID。</param>
    <param name="oPoint">滑块在画布坐标中的原点。</param>
    <param name="oDimension">滑块在画布坐标中的尺寸。</param>
  </Slider.ctor>

  <Slider.BlockSize>
    <summary>
      一个数值，确定滑块控件的块大小(或页面大小)。
    </summary>
    <value>一个数值，确定滑块控件的块大小(或页面大小)。</value>
    <remarks>
      一个数值，确定滑块控件的块大小(或页面大小)。块大小影响用户在拇指旁边点击时滑块的移动量。
    </remarks>
  </Slider.BlockSize>

  <Slider.ChannelBoundingBox>
    <summary>
      一个 BoundingBox 对象，确定滑块控件的通道的边界矩形的大小和位置。
    </summary>
    <value>一个 BoundingBox 对象，确定滑块控件的通道的边界矩形的大小和位置。</value>
    <remarks>
      一个 BoundingBox 对象，确定滑块控件的通道的边界矩形的大小和位置。 (通道是拇指移动的区域，也包含在选择范围内时的高亮显示。)
    </remarks>
  </Slider.ChannelBoundingBox>

  <Slider.ClearTicks>
    <summary>
      清除滑块的所有刻度线。
    </summary>
  </Slider.ClearTicks>

  <Slider.Create>
    <summary>
      创建 X# 滑块对象的基础窗口控件。
    </summary>
    <returns>
      如果成功，返回控件的窗口句柄。如果控件创建失败，返回一个空句柄(NULL_PTR)。
    </returns>
    <remarks>
      Create() 方法创建控件的基础窗口控件，这些控件不是从资源加载的(即，使用窗口编辑器设计的)而是在运行时创建的。通常，不需要直接调用 Create()—CA-X# 将在需要窗口句柄时在内部创建对象。
    </remarks>
    <example>
      <code language="X#">
        Method CreateSlider() class MyDataWindow
            local oSLDR as Slider
            // Init creates the X# Slider Object
            oSLDR := Slider{self, 100, Point{10,10}, Dimension{100,20}}
            // Calling Create forces the Windows control to be created
            oSLDR:Create()
      </code>
    </example>
  </Slider.Create>

  <Slider.GetTickPos>
    <summary>
      检索滑块控件中刻度线的位置。
    </summary>
    <param name="nIndex">从零开始的索引，标识刻度线。</param>
    <returns> 指定刻度线的位置，如果<paramref name="nIndex" />未指定有效索引，则返回-1。 </returns>
  </Slider.GetTickPos>

  <Slider.Range>
    <summary>
      一个 Range 对象，表示滑块的拇指当前使用的最小和最大值。
    </summary>
    <value>一个 Range 对象，表示滑块的拇指当前使用的最小和最大值。</value>
  </Slider.Range>

  <Slider.SetTickPos>
    <summary>
      设置滑块控件中刻度线的位置。
    </summary>
    <param name="nPosition">** 缺少参数文档 **</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </Slider.SetTickPos>

  <Slider.ThumbBoundingBox>
    <summary>
      一个 BoundingBox 对象，确定滑块控件的拇指的边界矩形的大小和位置。
    </summary>
    <value>一个 BoundingBox 对象，确定滑块控件的拇指的边界矩形的大小和位置。</value>
  </Slider.ThumbBoundingBox>

  <Slider.ThumbLength>
    <summary>
      一个数值，确定滑块控件中拇指的长度
    </summary>
    <value>一个数值，确定滑块控件中拇指的长度</value>
  </Slider.ThumbLength>

  <Slider.ThumbPosition>
    <summary>
      一个数值，确定滑块控件中拇指的当前位置。
    </summary>
    <value>一个数值，确定滑块控件中拇指的当前位置。</value>
  </Slider.ThumbPosition>

  <Slider.TickAlignment>
    <summary>
      <para>描述滑块上刻度线的对齐方式的符号。</para>
      <para>水平滑块的有效值为</para>
      <list type="bullet">
        <item>#Top</item>
        <item>#Bottom</item>
        <item>#Both</item>
      </list>
      <para>垂直滑块的有效值为</para>
      <list type="bullet">
        <item>#Left</item>
        <item>#Right</item>
        <item>#Both</item>
      </list>
    </summary>
    <value>描述滑块上刻度线的对齐方式的符号。水平滑块的有效值为 #Top#Bottom#Both 垂直滑块的有效值为 #Left#Right#Both</value>
  </Slider.TickAlignment>

  <Slider.TickCount>
    <summary>
      一个数值，表示滑块上的刻度线的数量。
    </summary>
    <value>一个数值，表示滑块上的刻度线的数量。</value>
  </Slider.TickCount>

  <Slider.UnitSize>
    <summary>
      一个数值，确定滑块控件的单位大小(或行大小)。
    </summary>
    <value>一个数值，确定滑块控件的单位大小(或行大小)。</value>
    <remarks>
      一个数值，确定滑块控件的单位大小(或行大小)。单位大小影响用户按下键盘上的光标左或光标右键时滑块的移动量。
    </remarks>
  </Slider.UnitSize>

  <SliderEvent>
    <summary>
      提供有关滑块事件的信息，当滑块的拇指被鼠标拖动或通过按方向键移动时，会生成此事件。
    </summary>
    <remarks>
      当滑块的拇指被鼠标拖动或通过按方向键移动时，会生成滑块事件。此事件对水平和垂直滑块都生成。
    </remarks>
  </SliderEvent>

  <SliderEvent.ctor>
    <inheritdoc />
  </SliderEvent.ctor>

  <SliderEvent.IsWindowScroll>
    <exclude />
  </SliderEvent.IsWindowScroll>

  <SliderEvent.Slider>
    <summary>
      生成此事件的滑块控件对象。
    </summary>
    <value>生成此事件的滑块控件对象。</value>
  </SliderEvent.Slider>

  <Spinner>
    <summary>
      创建一个微调器。
    </summary>
    <remarks>
      一个微调器是一对箭头按钮，可以点击以更改一个值，比如在另一个控件中显示的数字。一个微调器可以独立存在，但通常与另一个控件一起使用，称为客户端。
    </remarks>
  </Spinner>

  <Spinner.ctor>
    <summary>
      构造一个微调器。
    </summary>
    <param name="oOwner">拥有微调器的窗口。</param>
    <param name="xID">微调器的唯一ID(1到8000之间)。</param>
    <param name="oPoint">微调器在画布坐标中的原点。</param>
    <param name="oDimension">微调器在画布坐标中的尺寸。</param>
    <param name="kStyle">微调器的样式。</param>
    <param name="lDataAware">一个逻辑值，指定微调器是否是数据感知的。</param>
    <param name="nResourceID">微调器的资源ID。</param>
  </Spinner.ctor>

  <Spinner.Client>
    <summary>
      微调器的客户端控件。
    </summary>
    <value>微调器的客户端控件。</value>
  </Spinner.Client>

  <Spinner.IsHexBased>
    <exclude />
  </Spinner.IsHexBased>

  <Spinner.Position>
    <summary>
      微调器的数值。
    </summary>
    <value>微调器的数值。</value>
  </Spinner.Position>

  <Spinner.Range>
    <exclude />
  </Spinner.Range>

  <Spinner.ThumbPosition>
    <exclude />
  </Spinner.ThumbPosition>

  <SpinnerEvent>
    <summary>
      提供有关微调器事件的信息，当微调器的箭头按钮之一被点击时，会生成此事件。
    </summary>
    <remarks>
      一个微调器事件是在微调器控件的箭头按钮被点击时生成的。此事件对水平和垂直微调器都生成。
    </remarks>
  </SpinnerEvent>

  <SpinnerEvent.ctor>
    <inheritdoc />
  </SpinnerEvent.ctor>

  <SpinnerEvent.OldPosition>
    <summary>
      一个数值，表示与此事件关联的微调器在事件发生之前的位置。
    </summary>
    <value>一个数值，表示与此事件关联的微调器在事件发生之前的位置。</value>
  </SpinnerEvent.OldPosition>

  <SpinnerEvent.OldValue>
    <summary>
      一个数值，表示与此事件关联的微调器在事件发生之前的值。
    </summary>
    <value>一个数值，表示与此事件关联的微调器在事件发生之前的值。</value>
  </SpinnerEvent.OldValue>

  <SpinnerEvent.Position>
    <summary>
      一个数值，表示与此事件关联的微调器的新位置。
    </summary>
    <value>一个数值，表示与此事件关联的微调器的新位置。</value>
  </SpinnerEvent.Position>

  <SpinnerEvent.Spinner>
    <summary>
      生成此事件的微调器控件对象。
    </summary>
    <value>生成此事件的微调器控件对象。</value>
  </SpinnerEvent.Spinner>

  <SpinnerEvent.SpinnerID>
    <summary>
      生成此事件的微调器控件对象的唯一ID。
    </summary>
    <value>生成此事件的微调器控件对象的唯一ID。</value>
  </SpinnerEvent.SpinnerID>

  <SpinnerEvent.Type>
    <summary>
      一个数值，表示此事件发生时所进行的操作的类型。
    </summary>
    <value>一个数值，表示此事件发生时所进行的操作的类型。</value>
    <remarks> 
      一个数值，表示此事件发生时所进行的操作的类型： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>UNITDECREMENT</term>
          <description>位置已减少一个单位。</description>
        </item>
        <item>
          <term>UNITINCREMENT</term>
          <description>位置已增加一个单位。</description>
        </item>
        <item>
          <term>SCROLLTOTOPLEFT</term>
          <description>在垂直微调器中，滚动已达到最顶部位置；在水平微调器中，滚动已达到最左侧位置。</description>
        </item>
        <item>
          <term>SCROLLTOBOTTOMRIGHT</term>
          <description>在垂直微调器中，滚动已达到最底部位置；在水平微调器中，滚动已达到最右侧位置。</description>
        </item>
        <item>
          <term>SCROLLEND</term>
          <description>滚动已完成。</description>
        </item>
      </list>
    </remarks>
  </SpinnerEvent.Type>

  <SpinnerEvent.Value>
    <summary>
      一个数值，表示与此事件关联的微调器的新值。
    </summary>
    <value>一个数值，表示与此事件关联的微调器的新值。</value>
  </SpinnerEvent.Value>

  <SplitWindow>
    <summary>
      创建一个分割窗口。
    </summary>
    <remarks>
      一个分割窗口提供了一种简单且易于创建的方式，用于创建一个可以由分割条分隔的多个窗格窗口，分割条可以拖动以调整窗格的大小。每个窗格可以指定一个客户端窗口或控件，该窗口或控件会自动调整大小以适应窗格。
      使用Dimension对象来配置分割窗口窗格的布局。宽度指定了横向(水平)的窗格数量，高度指定了纵向(垂直)的窗格数量。窗格从左到右和从上到下编号。
      例如，一个布局为 Dimension{4, 3} 的分割窗口排列如下： 1 2 3 4 5 6 7 8 9 10 11 12 最大窗格总数为16。 
      <note type="tip">
        在这个版本的 X# 中，已经移除了对 CATO3*.DLL 文件的静态依赖，这些文件包含了 DataBrowser 和 SplitWindow 功能。
        不使用数据浏览器和/或分割窗口的应用程序不再需要这些 .DLL 文件。这导致了更小的内存占用，更快的应用程序启动，以及更小的安装包。
      </note>
    </remarks>
  </SplitWindow>

  <SplitWindow.ctor>
    <summary>
      构造一个 SplitWindow 对象。
    </summary>
    <param name="oOwner">拥有分割窗口的窗口。</param>
    <param name="lHorizontalDrag">一个逻辑值，如果水平分割条可以拖动，则为 TRUE。如果省略，缺省值为 ALSE，表示禁用水平分割条拖动。</param>
    <param name="lVerticalDrag">一个逻辑值，如果垂直分割条可以拖动，则为 TRUE。如果省略，缺省值为 FALSE，表示禁用垂直分割条拖动。</param>
    <param name="kAlignment">
      一个数值，指定如何在分割窗口中对齐分割条。
    </param>
    <remarks>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>
            SPLIT_HORZALIGN
          </term>
          <description>分割条水平对齐</description>
        </item>
        <item>
          <term>
            SPLIT_VERTALIGN
          </term>
          <description>分割条垂直对齐</description>
        </item>
      </list>
      如果省略，缺省对齐方式为垂直(SPLIT_VERTALIGN)。分割条可以水平或垂直对齐，但不能同时对齐。 
    </remarks>
  </SplitWindow.ctor>

  <SplitWindow.Background>
    <summary>
      分割窗口当前使用的背景刷。
    </summary>
    <value>分割窗口当前使用的背景刷。</value>
  </SplitWindow.Background>

  <SplitWindow.ChangeBackground>
    <summary>
      更改分割窗口的特定组件的背景刷。
    </summary>
    <param name="oBrush">要应用的新 Brush 对象。</param>
    <param name="kWhere">一个数值，指定新刷子将应用于分割窗口的哪个部分。</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>SPLIT_COLORWINDOW</term>
          <description>分割窗口背景刷</description>
        </item>
        <item>
          <term>SPLIT_COLORBAR</term>
          <description>分割条背景刷</description>
        </item>
        <item>
          <term>SPLIT_COLORFRAME</term>
          <description>分割条框架背景刷</description>
        </item>
      </list>
    </remarks>
  </SplitWindow.ChangeBackground>

  <SplitWindow.Destroy>
    <inheritdoc />
  </SplitWindow.Destroy>

  <SplitWindow.Dispatch>
    <inheritdoc />
  </SplitWindow.Dispatch>

  <SplitWindow.EnableStatusBar>
    <inheritdoc />
  </SplitWindow.EnableStatusBar>

  <SplitWindow.GetAllChildren>
    <inheritdoc />
  </SplitWindow.GetAllChildren>

  <SplitWindow.GetPaneClient>
    <summary>
      获取与分割窗口窗格索引关联的客户端窗口或控件。
    </summary>
    <param name="nPane">分割窗口窗格的索引。</param>
    <returns>
      一个对象，表示分割窗口窗格的客户端窗口。
    </returns>
  </SplitWindow.GetPaneClient>

  <SplitWindow.GetPaneSize>
    <summary>
      获取一个维度对象，表示窗格的当前大小。
    </summary>
    <param name="nPane">分割窗口窗格的索引。</param>
    <returns>
      一个维度对象，表示分割窗口窗格的大小。
    </returns>
  </SplitWindow.GetPaneSize>

  <SplitWindow.HidePane>
    <summary>
      隐藏分割窗口的特定窗格或所有窗格。
    </summary>
    <param name="nPane">要隐藏的分割窗口窗格的索引。如果省略，将隐藏所有窗格。</param>
  </SplitWindow.HidePane>

  <SplitWindow.HorizontalAlign>
    <summary>
      一个逻辑值，如果分割窗口的水平分割条对齐，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果分割窗口的水平分割条对齐，则为 TRUE。</value>
  </SplitWindow.HorizontalAlign>

  <SplitWindow.HorizontalDrag>
    <summary>
      一个逻辑值，如果分割窗口的水平分割条拖动已启用，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果分割窗口的水平分割条拖动已启用，则为 TRUE。</value>
  </SplitWindow.HorizontalDrag>

  <SplitWindow.Layout>
    <summary>
      一个维度对象，表示分割窗口窗格的数量和视觉布局。
    </summary>
    <value>一个维度对象，表示分割窗口窗格的数量和视觉布局。</value>
    <remarks>
      一个维度对象，表示分割窗口窗格的数量和视觉布局。维度的宽度表示水平对齐的窗格数量，而维度的高度表示垂直对齐的窗格数量。
    </remarks>
  </SplitWindow.Layout>

  <SplitWindow.Resize>
    <inheritdoc />
  </SplitWindow.Resize>

  <SplitWindow.RestoreUpdate>
    <summary>
      减少分割窗口维护的缓冲绘制计数。
    </summary>
    <remarks>
      每次调用 RestoreUpdate() 都应与对 SuspendUpdate() 的调用配对。如果绘制计数为零，延迟绘制将结束。
    </remarks>
  </SplitWindow.RestoreUpdate>

  <SplitWindow.SetPaneClient>
    <summary>
      设置与分割窗口窗格索引关联的客户端窗口或控件。
    </summary>
    <param name="oWindow">要与指定窗格关联的客户端窗口或控件。</param>
    <param name="nPane">分割窗口窗格的索引。</param>
  </SplitWindow.SetPaneClient>

  <SplitWindow.SetPaneSize>
    <summary>
      设置一个维度对象，表示指定窗格的当前大小。
    </summary>
    <param name="oDimension">一个维度对象，表示指定分割窗口窗格的新大小。</param>
    <param name="nPane">分割窗口窗格的索引。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </SplitWindow.SetPaneSize>

  <SplitWindow.Show>
    <inheritdoc cref="M:VO.Window.Show(XSharp.__Usual)" />
  </SplitWindow.Show>

  <SplitWindow.ShowPane>
    <summary>
      显示分割窗口的特定窗格或所有窗格。
    </summary>
    <param name="nPane">要显示的分割窗口窗格的索引。如果省略，将显示所有窗格。</param>
  </SplitWindow.ShowPane>

  <SplitWindow.SplitBarBackground>
    <summary>
      分割窗口中分割条当前使用的背景刷。
    </summary>
    <value>分割窗口中分割条当前使用的背景刷。</value>
  </SplitWindow.SplitBarBackground>

  <SplitWindow.SplitBarFrameBackground>
    <summary>
      分割窗口中分割条框架当前使用的背景刷。
    </summary>
    <value>分割窗口中分割条框架当前使用的背景刷。</value>
  </SplitWindow.SplitBarFrameBackground>

  <SplitWindow.SuspendUpdate>
    <summary>
      增加分割窗口维护的缓冲绘制计数。
    </summary>
    <remarks>
      每次调用 SuspendUpdate() 都应与对 RestoreUpdate() 的调用配对。如果绘制计数为零，延迟绘制将结束。
    </remarks>
  </SplitWindow.SuspendUpdate>

  <SplitWindow.ToolBarHeightChanged>
    <inheritdoc />
  </SplitWindow.ToolBarHeightChanged>

  <SplitWindow.VerticalAlign>
    <summary>
      一个逻辑值，如果垂直分割条在分割窗口中对齐，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果垂直分割条在分割窗口中对齐，则为 TRUE。</value>
  </SplitWindow.VerticalAlign>

  <SplitWindow.VerticalDrag>
    <summary>
      一个逻辑值，如果在分割窗口中启用垂直分割条的拖动，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果在分割窗口中启用垂直分割条的拖动，则为 TRUE。</value>
  </SplitWindow.VerticalDrag>

  <StandardColorDialog>
    <summary>
      提供所有 X# 颜色对话框的子类化的基类。
    </summary>
    <remarks>
      <br />重要！StandardColorDialog 是一个抽象类，不应直接使用，而应使用其子类之一，包括 PaletteDialog 和 SelectDialog。 
    </remarks>
  </StandardColorDialog>

  <StandardColorDialog.ctor>
    <summary>
      构造一个标准颜色对话框。
    </summary>
    <param name="oColor">表示标准颜色对话框中要显示的默认颜色的 Color 对象。如果省略，将使用默认颜色黑色。</param>
  </StandardColorDialog.ctor>

  <StandardColorDialog.Color>
    <summary>
      返回用户选择的颜色。
    </summary>
  </StandardColorDialog.Color>

  <StandardColorDialog.Destroy>
    <summary>
      提供一个方法，用于释放为 StandardColorDialog 对象及其派生对象分配的内存资源。
    </summary>
    <remarks>
      StandardColorDialog:Destroy() 释放了在应用程序中显式创建的 StandardColorDialog 对象的资源。此方法还负责分配给派生类的资源，并按照必要的顺序释放它们。
    </remarks>
  </StandardColorDialog.Destroy>

  <StandardColorDialog.Show>
    <summary>
      显示一个标准颜色对话框。要检索用户选择的值，使用 StandardColorDialog:Color() 方法。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </StandardColorDialog.Show>

  <StandardDialog>
    <summary>
      提供所有 X# 标准对话框的子类化的基类。
    </summary>
    <remarks>
      <br />
      重要！StandardDialog 是一个抽象类，不应直接使用，而应使用其子类之一，包括 OpenDialog、PaletteDialog、SaveAsDialog、SelectDialog 和 StandardFontDialog。
    </remarks>
  </StandardDialog>

  <StandardDialog.ctor>
    <summary>
      构造一个标准对话框。
    </summary>
  </StandardDialog.ctor>

  <StandardFileDialog>
    <summary>
      提供所有 X# 标准文件对话框的子类化的基类。
    </summary>
    <remarks>
      <br />重要！StandardFileDialog 是一个抽象类，不应直接使用，而应使用其子类之一，包括 OpenDialog 和 SaveAsDialog。 
    </remarks>
  </StandardFileDialog>

  <StandardFileDialog.ctor>
    <summary>
      构造一个标准文件对话框。
    </summary>
    <param name="uOwner">拥有标准文件对话框的窗口对象。如果省略，对话框不属于任何窗口。</param>
    <param name="cInitPath">
      表示在对话框中显示的初始文件或目录的字符串。例如，可以使用这个参数提示用户当前文件的名称。也可以指定通配符，如'*.TXT'。默认值是'*.*'。
    </param>
    <remarks>
      <note type="tip">
        如果要使用:SetFilter( ) 方法，必须将 cInitPath 指定为""，因为如果不这样做，过滤器将不起作用，而默认值"*.*"将生效，以显示所有文件。
      </note>
    </remarks>
  </StandardFileDialog.ctor>

  <StandardFileDialog.Caption>
    <summary>
      返回或更新对话框窗口中显示的标题。
    </summary>
    <value>返回或更新对话框窗口中显示的标题。</value>
    <example> 
      这个例子使用 Caption 分配为 OpenFile 对话框窗口设置一个标题: 
      <code language="X#">
        METHOD MyOpen() CLASS StandardShellWindow
            LOCAL oOpenDialog AS OpenDialog
            oOpenDialog:=OpenDialog{SELF}
            oOpenDialog:Caption:="My OpenFile Dialog"
            oOpenDialog:Show()
      </code>
    </example>
  </StandardFileDialog.Caption>

  <StandardFileDialog.DefExt>
    <summary>
      返回或更新对话框窗口中显示的默认文件扩展名。
    </summary>
    <value>返回或更新对话框窗口中显示的默认文件扩展名。</value>
  </StandardFileDialog.DefExt>

  <StandardFileDialog.Destroy>
    <inheritdoc />
  </StandardFileDialog.Destroy>

  <StandardFileDialog.Dispatch>
    <summary>
      拦截通常由 COMMDLG.DLL 中的对话框过程处理的消息。覆盖此方法以添加自定义处理。
    </summary>
    <param name="oEvt">一个 Event 对象。</param>
    <param name="hDlg">对话框的句柄。</param>
    <seealso cref="T:VO.Event" />
    <returns>
      一个长整数，指示消息是否应由 COMMDLG.DLL 中的对话框过程处理。返回一个非零值表示不需要进一步处理消息。返回零以继续处理此消息。
    </returns>
  </StandardFileDialog.Dispatch>

  <StandardFileDialog.FileName>
    <summary>
      一个字符串，表示用户选择的文件的名称。如果用户取消，文件名为 NULL_STRING。
    </summary>
    <value>一个字符串，表示用户选择的文件的名称。如果用户取消，文件名为 NULL_STRING。</value>
    <example>
      这个例子显示一个 OpenFile 对话框，其中的过滤器设置为只显示 DBF 和索引文件。多文件选择使用户可以选择一个 DBF 和一个索引。
      创建一个选定文件的 DBServer 对象，并返回给调用者。 
      <code language="X#">
        METHOD OpenDB() CLASS StandardShellWindow
            LOCAL oOpenDialog AS OpenDialog
            LOCAL uFileName AS USUAL
            LOCAL aoFileSpecs := {} AS ARRAY
            LOCAL lDone := .F. AS LOGIC
            LOCAL oDB AS Dbserver

            DO WHILE !lDone
                oOpenDialog:=OpenDialog{SELF}
                oOpenDialog:Caption:="Open DBF and Index"
                oOpenDialog:SetFilter ({"CUST*.*","ORD*.*","DET*.*"}, {"Customers", "Orders", "Details"})
                oOpenDialog:SetStyle(OFN_ALLOWMULTISELECT + OFN_HIDEREADONLY)
                oOpenDialog:InitialDirectory := "C:\CAVO2x\SAMPLES\GSTUTOR"
                oOpenDialog:Show()

                uFileName := oOpenDialog:FileName

                IF IsArray(uFileName) .AND. ALen(uFileName) &gt; 2
                    (TextBox{SELF,"File Selection Error",;
                    "Too many files selected"+CRLF+;
                    "Please select one DBF and one index"}):Show()
                ELSE
                    lDone := .T.
                ENDIF
            ENDDO
            
            // Open the selected DBF and index file
            uFileName := oOpenDialog:FileName

            IF IsArray(uFileName) // DBF and Index selected ?
                AEval(uFileName,{ | cFileName | AADD( ;
                                                      aoFileSpecs, FileSpec{cFileName} ) } )

                IF aoFileSpecs[1]:Extension != ".DBF"
                    aoFileSpecs[1]:= ArraySwap(aoFileSpecs, 2, aoFileSpecs[1])
                ENDIF

                RDDSetDefault("DBF"+SUBSTR(aoFileSpecs[2]:Extension, 2, 3) )
                oDB := DBServer{aoFileSpecs[1]}
                oDB:SetIndex(aoFileSpecs[2])

                ELSEIF LOGIC(_CAST, uFileName) // Anything selected at all?

                AADD(aoFileSpecs,FileSpec{uFileName})
                oDB := DBServer{aoFileSpecs[1]}
            ENDIF
            RETURN oDB
      </code>
    </example>
  </StandardFileDialog.FileName>

  <StandardFileDialog.FilterIndex>
    <summary>
      一个字符串，表示有效过滤器的索引。
    </summary>
    <value>一个字符串，表示有效过滤器的索引。</value>
  </StandardFileDialog.FilterIndex>

  <StandardFileDialog.help>
    <summary>
      提供一种在按下 HELP 按钮时显示帮助的方法。如果已向对话框对象发送了 SetStyle(OFN_SHOWHELP) 消息，HELP 按钮将被显示。
    </summary>
    <returns>
      一个长整数，指示消息是否应由 COMMDLG.DLL 中的对话框过程处理。该方法返回一个非零值，表示不需要进一步处理消息。它返回零，以继续处理此消息。
    </returns>
    <remarks>
      <note type="tip">
        如果使用 &lt;oStandardFileDialog&gt;:SetStyle(OFN_SHOWHELP)，对话框框中将创建一个"Help"按钮。
        需要创建一个 &lt;oStandardFileDialog&gt;:Help() 方法来处理用户点击"Help"按钮的事件。
      </note>
    </remarks>
  </StandardFileDialog.help>

  <StandardFileDialog.InitialDirectory>
    <summary>
      设置对话框窗口的初始目录。树形控件将根据需要进行初始定位。
    </summary>
    <value>设置对话框窗口的初始目录。树形控件将根据需要进行初始定位。</value>
    <example> 
      这个例子将初始目录设置为"C:\CAVO2x\SAMPLES": 
      <code language="X#">
        METHOD MyOpen() CLASS StandardShellWindow
            LOCAL oOpenDialog AS OpenDialog
            oOpenDialog := OpenDialog{SELF}
            oOpenDialog:InitialDirectory := "C:\CAVO2x\SAMPLES"
            oOpenDialog:Show()
      </code>
    </example>
  </StandardFileDialog.InitialDirectory>

  <StandardFileDialog.NoPlacesBar>
    <exclude />
  </StandardFileDialog.NoPlacesBar>

  <StandardFileDialog.ReadOnly>
    <summary>
      一个逻辑值，表示文件的只读属性是否已设置。
    </summary>
    <value>一个逻辑值，表示文件的只读属性是否已设置。</value>
  </StandardFileDialog.ReadOnly>

  <StandardFileDialog.SetFilter>
    <summary>
      设置标准对话框的单个或多个过滤器和描述。如果指定了多个过滤器，还可以指定过滤器索引。
    </summary>
    <param name="uFilter">
      一个过滤器字符串的数组。字符串内的分组过滤器必须由分号或单个过滤器字符串分隔。字符串内的分组过滤器必须由分号分隔。
    </param>
    <param name="uFilterDesc">一个过滤器描述的数组。</param>
    <param name="nIndex">如果多个过滤器生效，指定正在使用的初始过滤器的数字。</param>
    <remarks>
      可以通过指定一个或多个文件名过滤器及其描述来自定义 OpenFile 和 SaveAs 对话框的标准对话框。这些过滤器用作在列表中显示的文件名的掩码。
      每个过滤器字符串可以由几个由分号分隔的过滤器组成。如果设置了多个过滤器，可以指定一个索引，该索引指定初始显示的过滤器。
      <note type="tip">
        在上面的例子中，类的第二个参数已指定为""，因为如果不这样做，过滤器将不起作用，而默认值"*.*"将生效，以显示所有文件。
      </note>
    </remarks>
    <example> 
      这个例子为 OpenFile 对话框设置多个过滤器。一些过滤器字符串指定了过滤器组: 
      <code language="X#">
        METHOD MyOpen() CLASS StandardShellWindow
            LOCAL oOpenDialog AS OpenDialog

            oOpenDialog:= OpenDialog{SELF, ""}
            oOpenDialog:Caption:="Multiple Filters Test"
            oOpenDialog:SetFilter ( {"*.WRI;*.TXT", "*.PRG;*.CXX;*.C", "*.INI"}, {"Doc", "Program Source", "INI Files"},2)
            // 索引也可以独立设置:
            // oOpenDialog:SetFilter(,,2)
            oOpenDialog:InitialDirectory := "C:\CAVO28\Bin\"
            oOpenDialog:Show()
      </code>
    </example>
  </StandardFileDialog.SetFilter>

  <StandardFileDialog.SetStyle>
    <summary>
      设置对话框窗口的样式。
    </summary>
    <param name="kStyle">要查询的能力，由 Windows API OpenFileName 标志常量指定(例如，OFN_ALLOWMULTISELECT)。</param>
    <param name="lOnOff">一个逻辑值，指定样式设置是打开还是关闭。TRUE 表示打开样式设置; FALSE 表示关闭。默认值为 TRUE。</param>
    <remarks>
      可以通过使用 SetStyle() 方法来自定义 OpenFile 和 SaveAs 对话框的对话框窗口样式。请参考 Microsoft Win32 软件开发工具包中记录的 Windows API 常量。
    </remarks>
    <example> 
      这个例子从对话框窗口中移除只读复选框，允许多文件选择，并保留对话框之前生效的当前目录设置: 
      <code language="X#">
        METHOD MyOpen() CLASS StandardShellWindow
            LOCAL oOpenDialog AS OpenDialog
            oOpenDialog:=OpenDialog{SELF}
            oOpenDialog:SetStyle(OFN_ALLOWMULTISELECT)
            oOpenDialog:SetStyle(OFN_NOCHANGEDIR)
            oOpenDialog:SetStyle(OFN_HIDEREADONLY)
            oOpenDialog:Show()
      </code>
      <note type="tip">
        如果使用 &lt;oStandardFileDialog&gt;:SetStyle(OFN_SHOWHELP)，对话框框中将创建一个"Help"按钮。
        需要创建一个 &lt;oStandardFileDialog&gt;:Help() 方法来处理用户点击"Help"按钮的事件。
      </note>
    </example>
  </StandardFileDialog.SetStyle>

  <StandardFileDialog.SetStyleEx>
    <summary>
      设置对话框窗口的 Exstyle。
    </summary>
    <param name="kStyle">要查询的能力，由 Windows API OpenFileName 标志常量指定(例如，OFN_ALLOWMULTISELECT)。</param>
    <param name="lOnOff">一个逻辑值，指定样式设置是打开还是关闭。TRUE 表示打开样式设置; FALSE 表示关闭。默认值为 TRUE。</param>
  </StandardFileDialog.SetStyleEx>

  <StandardFileDialog.Show>
    <summary>
      显示一个标准文件对话框。要检索用户选择的值，使用特定子类的相关方法。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </StandardFileDialog.Show>

  <StandardFolderDialog>
    <summary>
      封装一个标准文件夹对话框。
    </summary>
    <remarks>
      标准文件夹对话框允许用户交互式地选择文件夹或目录。
    </remarks>
  </StandardFolderDialog>

  <StandardFolderDialog.ctor>
    <summary>
      构造一个标准文件夹对话框。
    </summary>
    <param name="oOwner">拥有标准文件夹对话框的窗口。</param>
    <param name="sCaption">标准文件夹对话框的标题。默认为'Browser Folder'。</param>
    <param name="sStartFolder">浏览的起始文件夹。</param>
    <param name="kType">
      以下常量的任意 _O Red组合：<br />
      仅返回文件系统目录(默认)。<br />
      不包括域级别以下的网络文件夹。<br />
      仅返回计算机。<br />
      仅返回打印机。<br />
      浏览对话框包括文件和文件夹。
    </param>
    <remarks>
      标准文件夹对话框允许用户浏览目录，以及打印机和计算机。
    </remarks>
  </StandardFolderDialog.ctor>

  <StandardFolderDialog.DialogCallBack>
    <exclude />
  </StandardFolderDialog.DialogCallBack>

  <StandardFolderDialog.FolderName>
    <summary>
      选择的文件夹或目录的名称(与 StandardFolderDialog:Result 相同)。
    </summary>
    <value>选择的文件夹或目录的名称(与 StandardFolderDialog:Result 相同)。</value>
  </StandardFolderDialog.FolderName>

  <StandardFolderDialog.Result>
    <summary>
      选择的文件夹或目录的名称(与 StandardFolderDialog:FolderName 相同)。
    </summary>
    <value>选择的文件夹或目录的名称(与 StandardFolderDialog:FolderName 相同)。</value>
  </StandardFolderDialog.Result>

  <StandardFolderDialog.Show>
    <summary>
      显示一个标准文件夹对话框。要检索用户选择的值，使用特定子类的相关方法。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      用户选择的项目可以通过 StandardFolderDialog:Result 属性检索。
    </remarks>
  </StandardFolderDialog.Show>

  <StandardFontDialog>
    <summary>
      提供标准字体对话框功能。
    </summary>
  </StandardFontDialog>

  <StandardFontDialog.ctor>
    <summary>
      构造一个标准字体对话框。
    </summary>
    <param name="uOwner">一个 Window 对象，用于标识要为其创建字体列表的设备(即，监视器)。</param>
    <param name="oPrinter">一个 Printer 对象，用于标识要为其创建字体列表的设备(即，打印机)。</param>
    <remarks>
      创建一个 StandardFontDialog 对象，其中包含为指定设备可用的字体列表。
    </remarks>
  </StandardFontDialog.ctor>

  <StandardFontDialog.EnableANSI>
    <summary>
      允许 ANSI 字体出现在标准字体对话框的字体列表中。
    </summary>
    <param name="bOnOff">一个逻辑值，指示 ANSI 字体是否出现在字体列表中。如果省略或未调用该方法，TRUE 是默认值。</param>
  </StandardFontDialog.EnableANSI>

  <StandardFontDialog.EnableEffects>
    <summary>
      允许更改字体效果，如下划线、删除线和颜色。
    </summary>
    <param name="bOnOff">一个逻辑值，指示是否可以通过标准字体对话框修改字体效果。如果省略或未调用该方法，TRUE 是默认值。</param>
    <remarks>
      调用 StandardFontDialog:EnableEffects() 方法时，会出现复选框，允许用户选择下划线和删除线字体属性。
      还会启用下拉框，允许用户选择文本的颜色。用户上次选择的颜色只有在调用 StandardFontDialog:EnableEffects(TRUE) 后才会生效。
    </remarks>
  </StandardFontDialog.EnableEffects>

  <StandardFontDialog.EnableFixedPitch>
    <summary>
      确定标准字体对话框的字体列表中是否只显示等宽字体。
    </summary>
    <param name="bOnOff">一个逻辑值，指示字体列表中是否只显示等宽字体。</param>
  </StandardFontDialog.EnableFixedPitch>

  <StandardFontDialog.EnableTrueType>
    <summary>
      确定标准字体对话框的字体列表中是否只显示 TrueType 字体。
    </summary>
    <param name="bOnOff">一个逻辑值，指示字体列表中是否只显示 TrueType 字体。</param>
  </StandardFontDialog.EnableTrueType>

  <StandardFontDialog.Flags>
    <summary>
      要为标准字体对话框窗口设置的 Windows API 样式常量。
    </summary>
    <value>要为标准字体对话框窗口设置的 Windows API 样式常量。</value>
    <remarks>
      <note type="tip">请参阅 Microsoft Win32 软件开发工具包文档，了解可用常量的详细信息。</note>
    </remarks>
  </StandardFontDialog.Flags>

  <StandardFontDialog.Font>
    <summary>
      上次在标准字体对话框窗口中选择的字体。
    </summary>
    <value>上次在标准字体对话框窗口中选择的字体。</value>
  </StandardFontDialog.Font>

  <StandardFontDialog.FontColor>
    <summary>
      上次在标准字体对话框窗口中选择的字体颜色。只有在调用 EnableEffects(TRUE) 后才会生效。
    </summary>
    <value>上次在标准字体对话框窗口中选择的字体颜色。只有在调用 EnableEffects(TRUE) 后才会生效。</value>
  </StandardFontDialog.FontColor>

  <StandardFontDialog.Show>
    <summary>
      显示一个标准字体对话框。要检索用户选择的值，使用 StandardFontDialog:Font 访问。
    </summary>
    <returns>
      如果用户选择了字体，则为 TRUE，如果用户按下取消，则为 FALSE。
    </returns>
  </StandardFontDialog.Show>

  <StatusBar>
    <summary>
      为窗口创建一个状态栏。
    </summary>
    <remarks> 
      状态栏通常出现在窗口的底部，用于向用户提供状态信息，而不占用太多的屏幕“房地产”。<br />
      Visual Object 的状态栏类有方法来显示以下类型的信息： <br />
      状态消息(永久或瞬时)<br />
      时间 <br />
      键盘状态(NumLock、CapsLock、ScrollLock 和 Insert键) <br />
      可用的虚拟内存 <br />
      屏幕坐标读数<br />
      调用各种 Display… 方法的顺序决定了对应项目在状态栏上从左到右的顺序。<br />
      任何瞬时状态消息都会覆盖 StatusBar:PermanentText 状态消息，但在五秒后会超时。 
      <note type="tip">
        您永远不会自己创建状态栏。相反，您通过调用 AppWindow:EnableStatusBar() 来要求窗口创建它。
        一旦您获取到由该方法返回的状态栏，您可以通过调用状态栏的各种 Display… 方法来自定义状态栏。<br />
        请注意，除了时间显示，状态栏项目需要您刷新它们。<br />
        例如，如果您打开了可用虚拟内存的显示，您必须在应用程序即将开始“占用内存”的任务时调用 StatusBar:RefreshMemoryDisplay() 方法。<br />
        因为您永远不会创建状态栏，所以您也永远不会销毁它们——窗口会自己做。
    </note>
    </remarks>
  </StatusBar>

  <StatusBar.ctor>
    <summary>
      构造一个状态栏。
    </summary>
    <param name="oOwner">拥有状态栏的窗口。</param>
    <param name="xID">控件的唯一ID(1到8000之间)。</param>
    <param name="oPoint">控件在画布坐标中的原点。</param>
    <param name="oDimension">控件在画布坐标中的尺寸。</param>
  </StatusBar.ctor>

  <StatusBar.AddItem>
    <summary>
      向状态栏添加一个新项目。
    </summary>
    <param name="oStatusBarItem">要添加到状态栏的新项目。</param>
  </StatusBar.AddItem>

  <StatusBar.AsString>
    <summary>
      一个字符串，表示最近的 StatusBar:PermanentText 状态消息，
    </summary>
    <value>一个字符串，表示最近的 StatusBar:PermanentText 状态消息，</value>
    <remarks>
      一个字符串，表示最近的 StatusBar:PermanentText 状态消息，即使状态栏当前显示一个瞬时消息。如果禁用了消息显示，StatusBar:AsString 返回 NIL。
      状态栏不会等待任何瞬时消息超时。如果消息是作为超链接而不是字符串提供的，则 AsString 会提取并返回超链接的描述。
    </remarks>
  </StatusBar.AsString>

  <StatusBar.Background>
    <summary>
      此属性用于覆盖从 Control 类继承的功能，因为它不适用于状态栏。
    </summary>
    <value>此属性用于覆盖从 Control 类继承的功能，因为它不适用于状态栏。</value>
  </StatusBar.Background>

  <StatusBar.ClearItems>
    <summary>
      移除状态栏的所有项目。
    </summary>
  </StatusBar.ClearItems>

  <StatusBar.ControlID>
    <summary>
      此属性用于覆盖从 Control 类继承的功能，因为它不适用于状态栏。
    </summary>
    <value>此属性用于覆盖从 Control 类继承的功能，因为它不适用于状态栏。</value>
  </StatusBar.ControlID>

  <StatusBar.ControlText>
    <summary>
      一个字符串，表示要在状态栏上显示的与控件关联的消息。这条消息优先于 StatusBar:PermanentText 消息。
    </summary>
    <value>一个字符串，表示要在状态栏上显示的与控件关联的消息。这条消息优先于 StatusBar:PermanentText 消息。</value>
  </StatusBar.ControlText>

  <StatusBar.Create>
    <exclude />
  </StatusBar.Create>

  <StatusBar.Destroy>
    <summary>
      提供一种方法来取消实例化一个 StatusBar 对象。
    </summary>
    <remarks>
      当不再需要一个 StatusBar 对象时，可以使用这个方法。StatusBar:Destroy() 取消实例化 StatusBar 对象，
      并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </StatusBar.Destroy>

  <StatusBar.Disable>
    <summary>
      禁用状态栏(直到后续调用 StatusBar:Enable())。
    </summary>
    <remarks>
      禁用的状态栏不活动，因此它们不会向它们的所有者窗口发送事件。
    </remarks>
  </StatusBar.Disable>

  <StatusBar.DisabledKeyIndicatorColor>
    <summary>
      状态栏用于指示键已禁用的颜色。默认为灰色。
    </summary>
    <value>状态栏用于指示键已禁用的颜色。默认为灰色。</value>
  </StatusBar.DisabledKeyIndicatorColor>

  <StatusBar.Dispatch>
    <inheritdoc />
  </StatusBar.Dispatch>

  <StatusBar.DisplayKeyboard>
    <summary>
      启用状态栏上的键盘状态显示。
    </summary>
    <remarks> 
      状态栏会自行刷新键盘状态，除了插入模式，您必须通过管理 StatusBar:InsertMode 属性来刷新它。 
      <note type="tip">
        在调用 StatusBar:Show() 之前，您必须调用这个方法。
      </note>
    </remarks>
  </StatusBar.DisplayKeyboard>

  <StatusBar.DisplayMemory>
    <summary>
      启用状态栏上的可用虚拟内存显示。您必须根据需要保持显示刷新，通过调用 StatusBar:RefreshMemoryDisplay()。
    </summary>
  </StatusBar.DisplayMemory>

  <StatusBar.DisplayMessage>
    <summary>
      启用状态栏上的消息显示。
    </summary>
  </StatusBar.DisplayMessage>

  <StatusBar.DisplayPosition>
    <summary>
      启用状态栏上的坐标对的显示。
    </summary>
    <remarks>
      通常是鼠标位置，但您可以提供任何您喜欢的 Pair 对象，比如一个 dimension 或一个 point。
      您必须根据需要保持显示刷新，通过将 pair 分配给状态栏的 Position 伪变量。 
      <note type="tip">
        在调用 StatusBar:Show() 之前，您必须调用这个方法。
      </note>
    </remarks>
  </StatusBar.DisplayPosition>

  <StatusBar.DisplayTime>
    <summary>
      在状态栏上启用数字时钟显示。
    </summary>
  </StatusBar.DisplayTime>

  <StatusBar.Enable>
    <summary>
      启用先前禁用的状态栏。
    </summary>
    <remarks>
      启用状态栏允许它生成事件，并在用户操作状态栏时将事件发送到其所有者窗口。禁用的状态栏的变暗效果被移除，状态栏恢复到正常外观。
      默认情况下，状态栏是启用的，直到禁用，因此除非之前调用了 StatusBar:Disable()，否则不需要调用这个 Enable() 方法。
    </remarks>
  </StatusBar.Enable>

  <StatusBar.ErrorMessageBeep>
    <summary>
      一个逻辑值，确定在发生错误时是否由错误系统发出蜂鸣声。TRUE 打开蜂鸣声；FALSE 关闭蜂鸣声。
    </summary>
    <value>一个逻辑值，确定在发生错误时是否由错误系统发出蜂鸣声。TRUE 打开蜂鸣声；FALSE 关闭蜂鸣声。</value>
  </StatusBar.ErrorMessageBeep>

  <StatusBar.ErrorText>
    <summary>
      一个字符串，表示要在状态栏上显示的错误消息。这条消息优先于 StatusBar:ControlText 和 StatusBar:PermanentText 消息。
    </summary>
    <value>一个字符串，表示要在状态栏上显示的错误消息。这条消息优先于 StatusBar:ControlText 和 StatusBar:PermanentText 消息。</value>
  </StatusBar.ErrorText>

  <StatusBar.GetItem>
    <exclude />
  </StatusBar.GetItem>

  <StatusBar.GetItemBoundingBox>
    <summary>
      获取描述状态栏项目区域的边界框。
    </summary>
    <param name="symItemName">要返回其边界框的状态栏项目的符号名称。如果省略，将返回主消息区域的边界框。</param>
    <returns>
      指定项目的边界框。
    </returns>
  </StatusBar.GetItemBoundingBox>

  <StatusBar.GetTipText>
    <exclude />
  </StatusBar.GetTipText>

  <StatusBar.Handle>
    <summary>
      返回状态栏的句柄。
    </summary>
    <param name="nHandleType"> 所需句柄的类型。如果省略 <paramref name="nHandle" />，则0是唯一支持的选项，也是默认值。 </param>
    <returns>
      一个句柄，描述底层系统对象的“窗口”(控件)。
    </returns>
    <remarks>
      此方法提供了一个窗口的句柄，然后可以通过 Windows API 调用使用。
    </remarks>
  </StatusBar.Handle>

  <StatusBar.Hide>
    <summary>
      隐藏状态栏，使其不可见(直到随后调用 StatusBar:Show())。
    </summary>
  </StatusBar.Hide>

  <StatusBar.HorizontalBorder>
    <summary>
      一个数字值，表示状态栏的顶部或底部边缘与其项目之间的水平边框的宽度。
    </summary>
    <value>一个数字值，表示状态栏的顶部或底部边缘与其项目之间的水平边框的宽度。</value>
  </StatusBar.HorizontalBorder>

  <StatusBar.InsertMode>
    <summary>
      一个逻辑值，指示程序是否处于插入模式。
    </summary>
    <value>一个逻辑值，指示程序是否处于插入模式。</value>
    <remarks> 
      一个逻辑值，指示程序是否处于插入模式。如果未启用插入模式，将返回NIL。 
      <note type="tip">
        状态栏会自动找出其他键的状态，比如 CapsLock，但它没有自动确定程序是在插入模式还是覆盖模式。只有程序知道这一点，程序必须设置它。
      </note>
    </remarks>
  </StatusBar.InsertMode>

  <StatusBar.ItemBorder>
    <summary>
      一个数字值，表示状态栏项目之间的边框的宽度。
    </summary>
    <value>一个数字值，表示状态栏项目之间的边框的宽度。</value>
  </StatusBar.ItemBorder>

  <StatusBar.KeyIndicatorColor>
    <summary>
      状态栏用于指示键处于打开状态的颜色对象。
    </summary>
    <value>状态栏用于指示键处于打开状态的颜色对象。</value>
    <remarks> 
      状态栏用于指示键处于打开状态的颜色对象。例如，键盘状态的模拟 LED，比如 NumLock。默认值是绿色。 
      <note type="tip">
        如果更改 StatusBar:KeyIndicatorColor，必须调用 StatusBar:Show() 方法，更改才能生效。
      </note>
    </remarks>
  </StatusBar.KeyIndicatorColor>

  <StatusBar.Length>
    <summary>
      一个数字值，表示要在状态栏上显示的消息的字符数。
    </summary>
    <value>一个数字值，表示要在状态栏上显示的消息的字符数。</value>
  </StatusBar.Length>

  <StatusBar.MenuText>
    <summary>
      一个字符串，表示要在状态栏上显示的与菜单选择相关的消息。
    </summary>
    <value>一个字符串，表示要在状态栏上显示的与菜单选择相关的消息。</value>
    <remarks>
      一个字符串，表示要在状态栏上显示的与菜单选择相关的消息。此消息优先于任何其他状态栏消息，包括 StatusBar:ControlText，StatusBar:ErrorText 或 StatusBar:PermanentText。
    </remarks>
  </StatusBar.MenuText>

  <StatusBar.ODDrawItem>
    <exclude />
  </StatusBar.ODDrawItem>

  <StatusBar.Origin>
    <summary>
      此属性提供了一个方法，用于覆盖从 Control 类继承的功能，因为它不适用于状态栏。
    </summary>
    <value>此属性提供了一个方法，用于覆盖从 Control 类继承的功能，因为它不适用于状态栏。</value>
  </StatusBar.Origin>

  <StatusBar.Owner>
    <summary>
      此属性提供了一个方法，用于覆盖从 Control 类继承的功能，因为它不适用于状态栏。
    </summary>
    <value>此属性提供了一个方法，用于覆盖从 Control 类继承的功能，因为它不适用于状态栏。</value>
  </StatusBar.Owner>

  <StatusBar.PermanentText>
    <summary>
      一个字符串，表示要在状态栏上显示的默认消息
    </summary>
    <value>一个字符串，表示要在状态栏上显示的默认消息</value>
    <remarks>
      一个字符串，表示要在状态栏上显示的默认消息；
      当更高优先级的消息(包括 StatusBar:ControlText，StatusBar:ErrorText 或 StatusBar:MenuText)优先时，它会被存储，
      当没有其他消息优先时，它会被重新显示。
    </remarks>
  </StatusBar.PermanentText>

  <StatusBar.Position>
    <summary>
      一个 pair，表示要在状态栏上显示的坐标。您选择的坐标单位是任意的。
    </summary>
    <value>一个 pair，表示要在状态栏上显示的坐标。您选择的坐标单位是任意的。</value>
  </StatusBar.Position>

  <StatusBar.RefreshMemoryDisplay>
    <summary>
      使状态栏的虚拟内存显示保持最新。
    </summary>
    <param name="kMemoryType">** 缺少参数文档 **</param>
    <remarks>
      状态栏从操作系统获取这些信息。如果您禁用了内存显示，将不会发生任何事情。
    </remarks>
  </StatusBar.RefreshMemoryDisplay>

  <StatusBar.SetFocus>
    <summary>
      此属性提供了一个方法，用于覆盖从 Control 类继承的功能，因为它不适用于状态栏。
    </summary>
  </StatusBar.SetFocus>

  <StatusBar.SetIcon>
    <exclude />
  </StatusBar.SetIcon>

  <StatusBar.setmessage>
    <summary>
      在状态栏的主消息区域显示一个字符串。
    </summary>
    <param name="cMessage">要在状态栏上显示的消息。</param>
    <param name="nMode">要在状态栏上显示的消息的类型。</param>
  </StatusBar.setmessage>

  <StatusBar.SetPair>
    <summary>
      设置一个 pair，表示要在状态栏上显示的坐标。
    </summary>
    <param name="oPoint">要设置的 point。</param>
    <remarks>
      您选择的坐标单位是任意的。
    </remarks>
  </StatusBar.SetPair>

  <StatusBar.SetText>
    <summary>
      为状态栏项目设置文本。
    </summary>
    <param name="cText">要设置的文本。</param>
    <param name="symItemName">状态栏项目的名称。</param>
  </StatusBar.SetText>

  <StatusBar.SetTipText>
    <exclude />
  </StatusBar.SetTipText>

  <StatusBar.SetValue>
    <exclude />
  </StatusBar.SetValue>

  <StatusBar.Show>
    <summary>
      显示一个状态栏，使其可见。
    </summary>
    <remarks>
      通常，使用 StatusBar:Hide() 方法隐藏的状态栏，也会调用 StatusBar:Show() 方法重新显示。
    </remarks>
  </StatusBar.Show>

  <StatusBar.Size>
    <summary>
      此属性提供了一个方法，用于覆盖从 Control 类继承的功能，因为它不适用于状态栏。
    </summary>
    <value>此属性提供了一个方法，用于覆盖从 Control 类继承的功能，因为它不适用于状态栏。</value>
  </StatusBar.Size>

  <StatusBar.TextValue>
    <summary>
      一个字符串，表示状态栏中保存的值。
    </summary>
    <value>一个字符串，表示状态栏中保存的值。</value>
    <remarks>
      一个字符串，表示状态栏中保存的值。例如，值可以是“Jones”或“$14,683.00”。
      请注意，字符串根据状态栏的字段规范格式化；反过来，与数据服务器链接的状态栏继承字段规范，因此也继承图片，图片来自服务器的字段。
    </remarks>
  </StatusBar.TextValue>

  <StatusBar.TimeOut>
    <summary>
      一个数字值，表示非永久消息在状态栏上显示的秒数。
    </summary>
    <value>一个数字值，表示非永久消息在状态栏上显示的秒数。</value>
  </StatusBar.TimeOut>

  <StatusBar.Timer>
    <exclude />
  </StatusBar.Timer>

  <StatusBar.Transient>
    <summary>
      一个字符串，表示要在状态栏上显示的错误消息。此消息优先于 StatusBar:ControlText 和 StatusBar:PermanentText 消息。
    </summary>
    <value>一个字符串，表示要在状态栏上显示的错误消息。此消息优先于 StatusBar:ControlText 和 StatusBar:PermanentText 消息。</value>
  </StatusBar.Transient>

  <StatusBar.VerticalBorder>
    <summary>
      一个数字值，表示状态栏的左侧或右侧边缘与其项目之间的垂直边框的高度。
    </summary>
    <value>一个数字值，表示状态栏的左侧或右侧边缘与其项目之间的垂直边框的高度。</value>
  </StatusBar.VerticalBorder>

  <StatusBarItem>
    <summary>
      创建一个状态栏项目。
    </summary>
    <remarks>
      状态栏项目是一个对象，可以添加到状态栏。它显示为状态栏的一个矩形部分，可以用于显示文本或图形信息。通过调用 StatusBar 类的适当方法，可以自动添加显示消息、数字对、键盘状态和内存信息的简单状态栏项目；这个类设计为允许添加用户定义的项目。
    </remarks>
  </StatusBarItem>

  <StatusBarItem.ctor>
    <summary>
      构造一个状态栏项目。
    </summary>
    <param name="symName">StatusBarItem 的名称</param>
    <param name="nWidth">StatusBarItem 的宽度(以像素为单位)</param>
    <param name="kStyle">
      StatusBarItem 的样式之一：<br />
      SBITEMFLAT<br />
      SBITEMRAISED<br />
      SBITEMSUNKEN
    </param>
    <param name="oIcon">可选的 Icon 对象，用于显示</param>
  </StatusBarItem.ctor>

  <StatusBarItem.Icon>
    <summary>
      StatusBarItem 的图标。
    </summary>
    <value>StatusBarItem 的图标。</value>
  </StatusBarItem.Icon>

  <StatusBarItem.NameSym>
    <summary>
      StatusBarItem 的符号名称。
    </summary>
    <value>StatusBarItem 的符号名称。</value>
  </StatusBarItem.NameSym>

  <StatusBarItem.Style>
    <summary>
      一个常量，确定状态栏项目的三维外观：
    </summary>
    <value>一个常量，确定状态栏项目的三维外观：</value>
    <remarks> 
      以下常量之一，确定状态栏项目的三维外观： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>SBITEMFLAT</term>
          <description>创建一个外观平坦的状态栏项目</description>
        </item>
        <item>
          <term>SBITEMSUNKEN</term>
          <description>创建一个外观凹陷的状态栏项目</description>
        </item>
        <item>
          <term>SBITEMRAISED</term>
          <description>创建一个外观凸起的状态栏项目</description>
        </item>
      </list>
    </remarks>
  </StatusBarItem.Style>

  <StatusBarItem.Value>
    <exclude />
  </StatusBarItem.Value>

  <StatusBarItem.Width>
    <summary>
      一个数字值，表示状态栏项目的宽度。
    </summary>
    <value>一个数字值，表示状态栏项目的宽度。</value>
  </StatusBarItem.Width>

  <StatusBarKeyItem>
    <summary>
      创建一个状态栏项目，用于显示 CapsLock、Numlock 和 Insert 键
    </summary>
  </StatusBarKeyItem>

  <StatusBarKeyItem.ctor>
    <summary>
      构造一个状态栏项目。
    </summary>
    <param name="symName">StatusBarItem 的名称</param>
    <param name="nWidth">StatusBarItem 的宽度(以像素为单位)</param>
    <param name="kStyle">
      StatusBarItem 的样式之一：<br />
      SBITEMFLAT<br />
      SBITEMRAISED<br />
      SBITEMSUNKEN
    </param>
    <param name="oIcon">可选的 Icon 对象，用于显示</param>
  </StatusBarKeyItem.ctor>

  <StatusBarKeyItem.ODDrawItem>
    <exclude />
  </StatusBarKeyItem.ODDrawItem>

  <StdSocket>
    <exclude />
  </StdSocket>

  <StdSocket.ctor>
    <inheritdoc />
  </StdSocket.ctor>

  <StdSocket.InternetStatus>
    <inheritdoc />
  </StdSocket.InternetStatus>

  <Stream>
    <summary>
      一个代表 ActiveXControl:StreamIn() 和 ActiveXControl:StreamOut() 方法中的流的类。
    </summary>
    <remarks>
      <note type="tip">Stream 对象由 OLE 运行时自动实例化。</note>
      一个 Stream 对象由 OLE 运行时系统自动实例化，并作为参数传递给 ActiveXControl:StreamIn() 和 ActiveXControl:StreamOut() 方法。
      Stream 对象包装了一个 OLE 流，允许您向流中写入和读取。
    </remarks>
  </Stream>

  <Stream.ctor>
    <summary>
      构造一个 Stream 对象实例。
    </summary>
    <param name="pStream">指向 OLE 流的指针。</param>
  </Stream.ctor>

  <Stream.Read>
    <summary>
      从流中读取下一个 USUAL 值。
    </summary>
    <returns>
      流中的下一个值(类型为 USUAL)。USUAL 可以保存任何 X# 数据，包括嵌套数组但不包括对象。
    </returns>
    <remarks>
      Stream:Read() 可以在 ActiveXControl:StreamIn 处理程序中使用，从流中读取 USUAL 值。
      您可以使用后续的 Stream:Read() 调用，读取之前的 Stream:Write() 调用保存到流中的所有值。
      Stream:Read() 和 Stream:Write() 操作应该是平衡的，并且按照相同的顺序进行。
    </remarks>
    <example> 
      这是日历 ActiveX 示例中的 StreamIn() 方法，位于应用程序库的示例选项卡页面上：
      <code language="X#">
        method StreamIn(oStream) class CalOCX
            local u as usual
            u := oStream:Read()

            if IsDate(u)
                curDate := u
            endif
      </code>
    </example>
  </Stream.Read>

  <Stream.Write>
    <summary>
      向流中写入一个 USUAL 值。
    </summary>
    <param name="uValue">要写入流中的 USUAL 值。</param>
    <returns>
      如果写入操作成功，则为 TRUE；否则为 FALSE。
    </returns>
    <remarks>
      Stream:Write() 可以在 ActiveXControl:StreamOut 处理程序中使用，将 USUAL 值写入流中。您可以使用后续的 Stream:Write() 调用，连续写入多个值。Stream:Read() 和 Stream:Write() 操作应该是平衡的，并且按照相同的顺序进行。
    </remarks>
    <example> 
      这是日历 ActiveX 示例中的 StreamOut() 方法，位于应用程序库的示例选项卡页面上：
      <code language="X#">
        method StreamOut(oStream) class CalOCX
            oStream:Write(oOCXWindow:CurrentDate)
            return
      </code>
    </example>
  </Stream.Write>
  
  <StringFS>
    <summary>
      创建一个字符串字段规范，其中包含字符串数据类型的信息。
    </summary>
  </StringFS>

  <StringFS.ctor>
    <summary>
      构造一个字符串字段规范。
    </summary>
    <param name="oHLName">包含字段名称和其他属性(如标题、描述和帮助上下文)的超链接，用于创建新的字符串字段规范。</param>
    <param name="uLength">字段的长度。如果未指定，将使用默认值10。</param>
  </StringFS.ctor>

  <strucPictureFuncFlags>
    <exclude />
  </strucPictureFuncFlags>

  <SysLink>
    <summary>
      创建一个 SysLink 控件。
    </summary>
    <remarks> 
      SysLink 控件在 XP 视觉主题下运行时提供超链接功能。 
      <note type="tip"> 
        此控件依赖于 COMCTL32.DLL 的6版或更高版本和WinXP主题。
        当 XP 主题不可用时，比如在 Windows 2000 上运行或在 XP 上以“经典”模式运行应用程序时，SysLink 控件会显示分配给它的完整文本 -
        任何超链接引用都被包含为文字。
        建议程序员应该测试 XP 主题支持，参见 IsThemeEnabled()，以确定应该分配给 SysLink 控件的文本。 因此，建议以这种方式调用它 - 
        <code language="X#">
          IF IsThemeEnabled()
              s := "Visit &lt;A HREF="+_chr(34)+;
                    "http://www.grafxsoft.com"+_chr(34)+"&gt;GrafX&lt;/A&gt; and &lt;A HREF="+;
                    _CHR(34)+"http://www.cavo.com"+_Chr(34)+"&gt;X#&lt;/A&gt; on the web!"
          ELSE
              s := "Visit http://www.grafxsoft.com and http://www.cavo.com"+;
                    " on the web!"
          ENDIF
        </code>
        HyperLink 和 SysLink 类的区别在于使用文本的方式。 
        在 HyperLink 控件中，所有的文本都作为超链接传递，而在SysLink控件中，您可以混合显示文本和超链接文本。 
      </note>
    </remarks>
    <example>
      例如，请参阅 Standard MDI 应用程序中的帮助“关于”屏幕。
    </example>
  </SysLink>

  <SysLink.ctor>
    <summary> 构造一个 SysLink 控件。 <br />重要！这个方法是由 X# 内部使用的。通常情况下，不应该在应用程序代码中调用它。 </summary>
    <param name="oOwner">拥有 SysLink 控件的窗口。</param>
    <param name="xID">SysLink 控件的唯一ID，介于1和8000之间。</param>
    <param name="oPoint">定位控件的 Point 对象。</param>
    <param name="oDimension">设置控件大小的 Dimension。</param>
    <param name="cText">要显示的文本(包括HTML标签)。</param>
    <param name="lDataAware">TRUE 设置控件为数据感知，FALSE 关闭此功能。默认值为 TRUE。</param>
  </SysLink.ctor>

  <SysLinkSelectEvent>
    <summary>
      提供有关 SysLink 控件被选中时生成的事件的信息。
    </summary>
  </SysLinkSelectEvent>

  <SysLinkSelectEvent.ctor>
    <summary>构造一个 ListViewMouseEvent 对象。</summary>
    <param name="oControlNotifyEvent">事件发生时的 ControlNotifyEvent。</param>
  </SysLinkSelectEvent.ctor>

  <SysLinkSelectEvent.ID>
    <exclude />
  </SysLinkSelectEvent.ID>

  <SysLinkSelectEvent.LinkIndex>
    <exclude />
  </SysLinkSelectEvent.LinkIndex>

  <SysLinkSelectEvent.URL>
    <exclude />
  </SysLinkSelectEvent.URL>

  <SystemMenu>
    <summary>
      创建一个系统菜单。
    </summary>
    <remarks>
      系统菜单用于提供一系列标准操作，如移动、关闭和调整窗口大小。不同的GUI约定规定了应该向系统菜单添加哪些项目。<br />
      应用程序窗口可以通过调用 AppWindow:EnableSystemMenu() 来拥有一个系统菜单。
      使用 Window:MenuCommand() 事件处理程序，可以像处理菜单一样操作系统菜单。<br />
      要访问窗口的系统菜单，必须先通过调用 AppWindow:EnableSystemMenu() 来启用系统菜单。然后可以使用它返回的系统菜单。
    </remarks>
    <example> 
      以下示例将 About 项添加到系统菜单中：
      <code language="X#">
        oSysMenu := oMyWin:EnableSystemMenu()
        oSysMenu:AppendItem(MENUSEPARATOR)
        oSysMenu:AppendItem(IDM_ABOUT,"About...")
        oSysMenu:RegisterItem(IDM_ABOUT,HyperLabel{#About})
      </code>
    </example>
  </SystemMenu>

  <SystemMenu.ctor>
    <summary> 
      构造一个系统菜单。 <br />
      重要！这个方法是由 X# 内部使用的。通常情况下，不应该在应用程序代码中调用它。
      要创建一个系统菜单对象，请存储 AppWindow:EnableSystemMenu() 方法的返回值。
    </summary>
    <param name="oOwner">
      拥有系统菜单的窗口。
      系统菜单的资源ID。如果未指定，系统将创建一个空菜单。
    </param>
  </SystemMenu.ctor>

  <SystemMenu.Destroy>
    <exclude />
  </SystemMenu.Destroy>

  <TabControl>
    <summary>
      创建一个选项卡控件。
    </summary>
    <remarks>
      选项卡控件是一个管理多个页面(无模式对话框窗口)的控件，可以类比为笔记本中的分隔符。
      通过使用选项卡控件，应用程序可以为对话框窗口或数据窗口的同一区域定义多个页面。当用户选择相应的选项卡时，将显示每个页面。
    </remarks>
  </TabControl>

  <TabControl.ctor>
    <summary>
      构造一个选项卡控件。
    </summary>
    <param name="oOwner">拥有选项卡控件的窗口。</param>
    <param name="xID">选项卡控件的唯一ID，介于1和8000之间。</param>
    <param name="nResourceID">选项卡控件的资源ID。</param>
    <param name="oPoint">选项卡控件的原点，以画布坐标表示。</param>
    <param name="oDimension">选项卡控件的尺寸，以画布坐标表示。</param>
    <param name="kStyle">选项卡控件的样式。</param>
  </TabControl.ctor>

  <TabControl.AddTipText>
    <summary>
      为选项卡添加要显示的提示文本。
    </summary>
    <param name="symTabName">要为其添加文本的选项卡的符号名称。</param>
    <param name="cText">要添加的文本。</param>
  </TabControl.AddTipText>

  <TabControl.AppendTab>
    <summary>
      在选项卡控件的末尾添加一个新的选项卡和选项卡页面。
    </summary>
    <param name="symTabName">新选项卡的符号名称。</param>
    <param name="cCaption">新选项卡的标题。</param>
    <param name="xPage">作为此选项卡页面的无模式对话框窗口或用于选项卡的类的符号名称。</param>
    <param name="nImage">在选项卡控件的图像列表中显示在新选项卡中的图像的索引。</param>
    <returns>
      如果成功添加了选项卡，则为 TRUE；否则为 FALSE。
    </returns>
  </TabControl.AppendTab>

  <TabControl.AutoSize>
    <summary>
      一个逻辑值，允许选项卡控件自动调整大小以适应最大选项卡页面的大小。默认值为 FALSE。
    </summary>
    <value>一个逻辑值，允许选项卡控件自动调整大小以适应最大选项卡页面的大小。默认值为 FALSE。</value>
  </TabControl.AutoSize>

  <TabControl.ChangeTipText>
    <summary>
      更改选项卡的当前提示文本。
    </summary>
    <param name="symTabName">要更改其提示文本的选项卡的符号名称。</param>
    <param name="cText">要替换当前提示文本的文本。</param>
    <returns>
      如果可以更改文本，则为 TRUE；否则为 FALSE。
    </returns>
  </TabControl.ChangeTipText>

  <TabControl.CreatePageInstance>
    <summary>
      动态创建一个选项卡页面。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="symPageClass">要创建的页面的类名</param>
    <param name="symTabName">要创建的选项卡的符号名称</param>
    <returns>
      新的页面对象
    </returns>
  </TabControl.CreatePageInstance>

  <TabControl.CurrentPage>
    <summary>
      当前显示的选项卡控件页面。
    </summary>
    <value>当前显示的选项卡控件页面。</value>
  </TabControl.CurrentPage>

  <TabControl.DeleteAllTabs>
    <summary>
      删除选项卡控件中的所有选项卡及其对应的页面。
    </summary>
    <returns>
      如果可以删除所有选项卡，则为 TRUE；否则为 FALSE。
    </returns>
  </TabControl.DeleteAllTabs>

  <TabControl.DeleteTab>
    <summary>
      从选项卡控件中删除一个选项卡和页面。
    </summary>
    <param name="symTabName">要删除的选项卡的符号名称。</param>
    <returns>
      如果可以删除选项卡，则为 TRUE；否则为 FALSE。
    </returns>
  </TabControl.DeleteTab>

  <TabControl.Destroy>
    <summary>
      提供一种方法来取消实例化一个选项卡控件对象。
    </summary>
    <remarks>
      当不再需要一个选项卡控件对象时，可以使用这个方法。
      TabControl:Destroy() 取消实例化选项卡控件对象，并允许您关闭和释放对象打开或创建的任何资源，而不需要等待垃圾收集器。
    </remarks>
  </TabControl.Destroy>

  <TabControl.FocusNextPage>
    <exclude />
  </TabControl.FocusNextPage>

  <TabControl.FocusPreviousPage>
    <exclude />
  </TabControl.FocusPreviousPage>

  <TabControl.FocusTab>
    <exclude />
  </TabControl.FocusTab>

  <TabControl.GetCaption>
    <summary>
      返回选项卡的当前标题。
    </summary>
    <param name="symTabName">要获取其标题的选项卡的符号名称。</param>
    <returns>
      指定选项卡的当前标题。
    </returns>
  </TabControl.GetCaption>

  <TabControl.GetPage>
    <exclude />
  </TabControl.GetPage>

  <TabControl.GetPageSymbol>
    <exclude />
  </TabControl.GetPageSymbol>

  <TabControl.GetTabBoundingBox>
    <summary>
      获取描述选项卡占用区域的边界框。
    </summary>
    <param name="symTabName">要获取其边界框的选项卡的符号名称。</param>
    <returns>
      指定选项卡占用的边界框。
    </returns>
  </TabControl.GetTabBoundingBox>

  <TabControl.GetTabImage>
    <summary>
      获取选项卡的当前图像。
    </summary>
    <param name="symTabName">要获取其图像的选项卡的符号名称。</param>
    <returns>
      指定选项卡的当前图像编号。
    </returns>
  </TabControl.GetTabImage>

  <TabControl.GetTabPage>
    <summary>
      获取指定的选项卡页面。
    </summary>
    <param name="xSymbolOrPosition">指定选项卡页面的符号或数字位置。</param>
    <returns>
      表示指定选项卡页面的模态对话框窗口对象。
    </returns>
  </TabControl.GetTabPage>

  <TabControl.GetTipText>
    <summary>
      获取选项卡的当前提示文本。
    </summary>
    <param name="symTabName">要获取其提示文本的选项卡的符号名称。</param>
    <returns>
      指定选项卡的当前提示文本。
    </returns>
  </TabControl.GetTipText>

  <TabControl.Hide>
    <summary>
      隐藏当前选项卡页面。
    </summary>
  </TabControl.Hide>

  <TabControl.ImageList>
    <summary>
      选项卡控件的图像列表。
    </summary>
    <value>选项卡控件的图像列表。</value>
  </TabControl.ImageList>

  <TabControl.InsertTab>
    <summary>
      在选项卡控件中的特定位置插入新的选项卡和选项卡页面。
    </summary>
    <param name="nPosition">新选项卡的数字位置。</param>
    <param name="symTabName">新选项卡的符号名称。</param>
    <param name="cCaption">新选项卡的标题。</param>
    <param name="xPage">用作此选项卡页面的模态对话框窗口或用于选项卡的类的符号名称。</param>
    <param name="nImage">在新选项卡中显示的图像在选项卡控件的图像列表中的索引。</param>
    <returns>
      如果成功添加选项卡，则为 TRUE；否则为 FALSE。
    </returns>
  </TabControl.InsertTab>

  <TabControl.IsTabPage>
    <exclude />
  </TabControl.IsTabPage>

  <TabControl.Move>
    <inheritdoc />
  </TabControl.Move>

  <TabControl.PadTabs>
    <summary>
      使用空格填充选项卡的标签和图标。
    </summary>
    <param name="dwWidth">水平填充的数量(以像素为单位)。</param>
    <param name="dwHeight">垂直填充的数量(以像素为单位)。</param>
  </TabControl.PadTabs>

  <TabControl.Pages>
    <exclude />
  </TabControl.Pages>

  <TabControl.RemoveTabImage>
    <summary>
      从选项卡控件的图像列表中移除一个图像。
    </summary>
    <param name="nImageIndex">要移除的图像在选项卡控件的图像列表中的索引。</param>
    <returns>
      如果成功移除图像，则为 TRUE；否则为 FALSE。
    </returns>
  </TabControl.RemoveTabImage>

  <TabControl.RemoveTipText>
    <summary>
      移除选项卡的当前提示文本。
    </summary>
    <param name="symTabName">要移除其提示文本的选项卡的符号名称。</param>
    <returns>
      如果成功移除文本，则为 TRUE；否则为 FALSE。
    </returns>
  </TabControl.RemoveTipText>

  <TabControl.Resize>
    <inheritdoc />
  </TabControl.Resize>

  <TabControl.RowCount>
    <summary>
      表示当前在选项卡控件中显示的选项卡的行数的数字值。
    </summary>
    <value>表示当前在选项卡控件中显示的选项卡的行数的数字值。</value>
  </TabControl.RowCount>

  <TabControl.SelectedTab>
    <summary>
      表示选项卡控件中当前选定的选项卡的符号名称。
    </summary>
    <value>表示选项卡控件中当前选定的选项卡的符号名称。</value>
  </TabControl.SelectedTab>

  <TabControl.SelectedTabPage>
    <summary>
      表示选项卡控件中当前选定的选项卡页面的模态对话框窗口对象。
    </summary>
    <value>表示选项卡控件中当前选定的选项卡页面的模态对话框窗口对象。</value>
  </TabControl.SelectedTabPage>

  <TabControl.SelectTab>
    <summary>
      选择一个选项卡并显示其页面。
    </summary>
    <param name="symTabName">要选择的选项卡的符号名称。</param>
  </TabControl.SelectTab>

  <TabControl.SetCaption>
    <summary>
      为选项卡设置新的标题。
    </summary>
    <param name="symTabName">要获取其标题的选项卡的符号名称。</param>
    <param name="cCaption">选项卡的新标题</param>
    <returns>
      如果成功更改标题，则为 TRUE；否则为 FALSE
    </returns>
  </TabControl.SetCaption>

  <TabControl.SetTabImage>
    <summary>
      动态更改选项卡页面的图像(索引)。
    </summary>
    <param name="symTabName">要更改其图像索引的页面的符号。</param>
    <param name="nImageIndex">图像列表中的新索引。</param>
    <returns>
      图像列表中的新索引。
    </returns>
  </TabControl.SetTabImage>

  <TabControl.SetTipText>
    <summary>
      更改选项卡的当前提示文本。
    </summary>
    <param name="symTabName">要更改其提示文本的选项卡的符号名称。</param>
    <param name="cText">替换当前提示文本的文本。</param>
    <returns>
      如果成功更改文本，则为 TRUE；否则为 FALSE。
    </returns>
  </TabControl.SetTipText>

  <TabControl.Show>
    <exclude />
  </TabControl.Show>

  <TabControl.TabCaption>
    <exclude />
  </TabControl.TabCaption>

  <TabControl.TabCount>
    <summary>
      表示选项卡控件中的选项卡总数的数字值。
    </summary>
    <value>表示选项卡控件中的选项卡总数的数字值。</value>
  </TabControl.TabCount>

  <TextBox>
    <summary>
      显示一个文本消息框给用户。
    </summary>
    <remarks>
      一个消息框是一个小窗口，显示一个标题，一个消息，一个图标(从预定义的图标集中选择)，和一个或多个按钮(从各种预定义的组合中选择)。它提供了一个简单的替代方案，当你只需要用户的简单响应时，就不需要对话框窗口。
      消息框不需要调整大小，定位，或事件处理。此外，消息框可以是应用程序模态的(直到用户确认消息框，应用程序中的任何处理都无法继续)，或者可以是相对于其所有者窗口的模态的(直到用户确认消息框，其所有者窗口中的任何处理都无法继续)。
    </remarks>
    <example> 
      以下示例处理一个QueryClose事件： 
      <code language="X#">
        METHOD QueryClose(oEvent) CLASS TopAppWindow
            oTB := TextBox{SELF, "Quit", "Do you really want to quit?"}
            oTB:TYPE := BOXICONQUESTIONMARK + BUTTONYESNO
            IF (oTB:Show() = BOXREPLYYES)
                RETURN TRUE // 退出应用程序。
            ELSE
                RETURN FALSE // 不要退出应用程序。
            ENDIF
      </code>
    </example>
  </TextBox>

  <TextBox.ctor>
    <summary>
      创建一个消息框。
    </summary>
    <param name="uParent">拥有消息框的窗口。如果省略，消息框是应用程序模态的(即，应用程序被挂起，直到用户确认消息框)。</param>
    <param name="uCaption">要在消息框的标题栏中显示的文本或包含消息框的标题和描述的超链接。如果省略，标题栏的默认值是 NULL_STRING。</param>
    <param name="uText">
      要在消息框中打印的信息。如果省略，消息框的默认值是 NULL_STRING。
    </param>
    <param name="nType"> 
      消息框类型。有效类型包括以下按钮组合和/或图标： <br />
      组1：按钮 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>按钮</description>
        </listheader>
        <item>
          <term>
            BOXABORTRETRYIGNORE
          </term>
          <description>
            中止，重试，和忽略
          </description>
        </item>
        <item>
          <term>
            BUTTONOKAY
          </term>
          <description>确定(这是默认值)。</description>
        </item>
        <item>
          <term>
            BUTTONOKAYCANCEL
          </term>
          <description>确定和取消</description>
        </item>
        <item>
          <term>
            BUTTONRETRYCANCEL
          </term>
          <description>重试和取消</description>
        </item>
        <item>
          <term>
            BUTTONYESNO
          </term>
          <description>是和否</description>
        </item>
        <item>
          <term>BUTTONYESNOCANCEL </term>
          <description>是，否，和取消</description>
        </item>
      </list> 
      组2：标准图标 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>图标</description>
        </listheader>
        <item>
          <term>
            BOXICONASTERISK
          </term>
          <description>一个由圆圈内的小写字母'i'组成的图标</description>
        </item>
        <item>
          <term>
            BOXICONEXCLAMATION
          </term>
          <description>一个感叹号</description>
        </item>
        <item>
          <term>BOXICONHAND </term>
          <description>一个警告图标</description>
        </item>
        <item>
          <term>BOXICONQUESTIONMARK </term>
          <description>一个问号</description>
        </item>
      </list>
    </param>
  </TextBox.ctor>

  <TextBox.Beep>
    <summary>
      一个逻辑值，指示在显示消息框时是否使用系统默认的蜂鸣声。TRUE 表示会有蜂鸣声；FALSE 表示不会有蜂鸣声。
    </summary>
    <value>一个逻辑值，指示在显示消息框时是否使用系统默认的蜂鸣声。TRUE 表示会有蜂鸣声；FALSE 表示不会有蜂鸣声。</value>
  </TextBox.Beep>

  <TextBox.Caption>
    <summary>
      一个字符串值，表示消息框的标题。
    </summary>
    <value>一个字符串值，表示消息框的标题。</value>
  </TextBox.Caption>

  <TextBox.Message>
    <summary>
      一个字符串值，表示消息框的消息。
    </summary>
    <value>一个字符串值，表示消息框的消息。</value>
  </TextBox.Message>

  <TextBox.Show>
    <summary>
      显示这个消息框并返回一个值，指示它是如何关闭的。
    </summary>
    <returns> 
      用户选择的按钮。 <para>可能的值包括：</para>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>按钮</description>
        </listheader>
        <item>
          <term>BOXREPLYABORT</term>
          <description>中止</description>
        </item>
        <item>
          <term>BOXREPLYCANCEL</term>
          <description>取消</description>
        </item>
        <item>
          <term>BOXREPLYIGNORE</term>
          <description>忽略</description>
        </item>
        <item>
          <term>BOXREPLYNO</term>
          <description>否</description>
        </item>
        <item>
          <term>BOXREPLYOKAY</term>
          <description>确定</description>
        </item>
        <item>
          <term>BOXREPLYRETRY</term>
          <description>重试</description>
        </item>
        <item>
          <term>BOXREPLYYES</term>
          <description>是</description>
        </item>
      </list>
    </returns>
  </TextBox.Show>

  <TextBox.Type>
    <summary>
      一个常量或常量组合，指示消息框中显示哪些按钮和/或图标
    </summary>
    <value>一个常量或常量组合，指示消息框中显示哪些按钮和/或图标</value>
    <remarks> 
      一个常量或常量组合，指示消息框中显示哪些按钮和/或图标。从这些组合中的每个组中添加一个项目，以创建您选择的组合。 <br />
      <para>组1：标准按钮组合</para>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>BOXABORTRETRYIGNORE</term>
          <description>中止，重试和忽略</description>
        </item>
        <item>
          <term>BUTTONOKAY</term>
          <description> 确定(这是<b>默认</b>。) </description>
        </item>
        <item>
          <term>BUTTONOKAYCANCEL</term>
          <description>确定和取消</description>
        </item>
        <item>
          <term>BUTTONRETRYCANCEL</term>
          <description>重试和取消</description>
        </item>
        <item>
          <term>BUTTONYESNO</term>
          <description>是和否</description>
        </item>
        <item>
          <term>BUTTONYESNOCANCEL</term>
          <description>是，否和取消</description>
        </item>
      </list>
      <para>组2：标准图标</para>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>BOXICONASTERISK</term>
          <description>一个由圆圈内的小写字母“i”组成的图标</description>
        </item>
        <item>
          <term>BOXICONEXCLAMATION</term>
          <description>一个感叹号</description>
        </item>
        <item>
          <term>BOXICONHAND</term>
          <description>一个警告图标</description>
        </item>
        <item>
          <term>BOXICONQUESTIONMARK</term>
          <description>一个问号</description>
        </item>
      </list>
    </remarks>
    <example> 
      此示例创建一个带有感叹号图标和确定和取消按钮的文本框： 
      <code language="X#">
        oTextBox:Type := BOXICONEXCLAMATION + BUTTONOKAYCANCEL
      </code>
    </example>
  </TextBox.Type>

  <TextControl>
    <summary>
      提供所有 X# 控件的基类。
    </summary>
    <remarks>
      对话框窗口中的文本控件在窗口关闭时被销毁。因此，建议如果在调用 DialogWindow:EndDialog() 后要使用文本，则应将文本保存在缓冲区中。
    </remarks>
    <example> 
      此示例在按钮被点击时将按钮的名称颜色更改为红色： 
      <code language="X#">
        METHOD ButtonClick(aControlEvent) CLASS TopAppWindow
            oPB := oControlEvent:Control
            oPB:TextColor := Color{COLORRED}
      </code>
    </example>
  </TextControl>

  <TextControl.ctor>
    <summary>
      创建一个文本控件。
    </summary>
    <param name="oOwner">拥有文本控件的窗口。</param>
    <param name="xId">文本控件的唯一ID，介于1和8000之间。</param>
    <param name="oPoint">文本控件在画布坐标中的原点。</param>
    <param name="oDimension">文本控件在画布坐标中的尺寸。</param>
    <param name="cRegclass">控件的窗口类名(例如，'ListBox')。</param>
    <param name="kStyle">
      表示控件的窗口样式的常量，可以通过 X# 样式常量或 Windows API 样式常量指定。样式可以使用 _Or() 运算符组合。
    </param>
    <remarks>
      <note type="tip">详细信息，请参阅 Microsoft Win32 软件开发工具包文档中有关特定 Windows API 常量的详细信息。</note>
    </remarks>
    <param name="lDataAware">
      一个逻辑值，指定文本控件是否是数据感知的。
      详细信息，请参阅在线帮助中 Button、CheckBox、ComboBox、DateTimePicker、Edit、FixedText、GroupBox、HotKeyEdit、IPAddress、ListBox、ListView、MonthCalendar、MultiLineEdit、PushButton、RadioButton、RadioButtonGroup、RichEdit 和 SingleLineEdit 子类的 TextControl:Init() 和相应的 Init() 方法主题。
    </param>
    <param name="nResourceID">文本控件的资源ID。</param>
  </TextControl.ctor>

  <TextControl.Caption>
    <summary>
      表示文本控件标题的字符串。
    </summary>
    <value>表示文本控件标题的字符串。</value>
  </TextControl.Caption>

  <TextControl.ControlFont>
    <summary>
      用于在控件中绘制文本的字体。
    </summary>
    <value>用于在控件中绘制文本的字体。</value>
  </TextControl.ControlFont>

  <TextControl.Create>
    <inheritdoc />
  </TextControl.Create>

  <TextControl.CurrentText>
    <summary>
      一个字符串，表示当前在文本控件中显示的文本。对于编辑控件，包括简单和下拉组合框关联的编辑框，
      它包含当前在编辑框中显示的文本。对于 FixedIcon 和组框控件，TextControl:CurrentText 包含 NULL_STRING。
    </summary>
    <value>
      一个字符串，表示当前在文本控件中显示的文本。
      对于编辑控件，包括简单和下拉组合框关联的编辑框，它包含当前在编辑框中显示的文本。
      对于 FixedIcon 和组框控件，TextControl:CurrentText 包含 NULL_STRING。
    </value>
  </TextControl.CurrentText>

  <TextControl.Destroy>
    <summary>
      提供一种方法来取消实例化任何 TextControl.Destroy 对象。
    </summary>
    <remarks>
      当不再需要 TextControl.Destroy 对象时，可以使用此方法。
      TextControl.Destroy:Destroy() 取消实例化 Control 对象，并允许您关闭和释放由对象打开或创建的任何资源，而无需等待垃圾收集器。
    </remarks>
  </TextControl.Destroy>

  <TextControl.EnableAutoComplete>
    <exclude />
  </TextControl.EnableAutoComplete>

  <TextControl.Font>
    <summary>
      更改文本控件的当前字体。
    </summary>
    <param name="oNewFont">用于在文本控件中绘制文本的字体。</param>
    <param name="lRescal">TRUE 根据新的字体大小重新调整控件。FALSE 不允许重新调整。如果省略，默认为 FALSE。</param>
    <returns>
      文本控件使用的先前字体。
    </returns>
  </TextControl.Font>

  <TextControl.Font>
    <summary>
      用于在控件中绘制文本的字体。<br />
      在 X# 的先前版本中，此 Access/Assign 称为 Font(没有下划线)。它已被重命名，以避免与 TextControl:Font() 方法的名称冲突
    </summary>
    <value>
      用于在控件中绘制文本的字体。<br />
      在 X# 的先前版本中，此 Access/Assign 称为 Font(没有下划线)。它已被重命名，以避免与 TextControl:Font() 方法的名称冲突
    </value>
  </TextControl.Font>

  <TextControl.Ime>
    <summary>
      返回并可选地设置此文本控件的输入法编辑器是否启用。
    </summary>
    <param name="symIme">TRUE 启用此文本控件的输入法编辑器；FALSE 禁用它。</param>
    <returns>
      如果未指定 &lt;symIme&gt;，TextControl:IME() 返回当前设置。如果指定了 &lt;lEnable&gt;，则返回先前的设置。
    </returns>
    <remarks>
      此方法适用于 Windows 的国际版本。
    </remarks>
  </TextControl.Ime>

  <TextControl.Length>
    <summary>
      一个表示控件中字符数的数字值。
    </summary>
    <value>一个表示控件中字符数的数字值。</value>
  </TextControl.Length>

  <TextControl.Modified>
    <summary>
      一个逻辑值，当标准编辑控件或可编辑组合框正在被修改时设置为 TRUE。
      当编辑完成并焦点转移到另一个控件时，TextControl:Modified 被重置为 FALSE。
      对于不可编辑的控件(FixedIcon 、固定文本或组框)，TextControl:Modified 始终为 FALSE。
    </summary>
    <value>
      一个逻辑值，当标准编辑控件或可编辑组合框正在被修改时设置为 TRUE。
      当编辑完成并焦点转移到另一个控件时，TextControl:Modified 被重置为 FALSE。
      对于不可编辑的控件(FixedIcon 、固定文本或组框)，TextControl:Modified 始终为 FALSE。
    </value>
  </TextControl.Modified>

  <TextControl.RemoveEditBalloonTip>
    <summary>
      从继承了此类的编辑控件中移除当前的 BallonTip。
    </summary>
    <param name="hControl">要从中移除 BalloonTip 的编辑控件的可选句柄。默认为调用方法的控件。</param>
  </TextControl.RemoveEditBalloonTip>

  <TextControl.SetCueBanner>
    <summary>
      向继承了此类的编辑控件中添加一个提示文本。
    </summary>
    <param name="cText">作为提示显示的文本。</param>
    <param name="hControl">要添加提示的编辑控件的可选句柄。默认为调用方法的控件。</param>
    <remarks>
      提示文本是在编辑控件中显示的文本，通常指示控件的用途或提示所需的输入类型。当控件获得焦点或其中有文本时，不再显示提示。
    </remarks>
  </TextControl.SetCueBanner>

  <TextControl.ShowEditBalloonTip>
    <summary>
      向继承了此类的编辑控件中添加一个 BallonTip。
    </summary>
    <param name="cTitle">在提示中显示的标题。</param>
    <param name="cText">在提示中显示的文本。</param>
    <param name="dwIcon">在提示中使用的图标。</param>
    <param name="hControl">要添加 BalloonTip 的编辑控件的可选句柄。默认为调用方法的控件。</param>
    <remarks> 
      dwIcon可以是： 
      <list type="table">
        <listheader>
          <term>值</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>TTI_ERROR</term>
          <description>使用错误图标。</description>
        </item>
        <item>
          <term>TTI_INFO</term>
          <description>使用信息图标。</description>
        </item>
        <item>
          <term>TTI_NONE</term>
          <description>不使用图标。</description>
        </item>
        <item>
          <term>TTI_WARNING</term>
          <description>使用警告图标</description>
        </item>
      </list> 
      可以在编辑控件上显示一个气球提示。<br />
      提示总是指向控件的当前光标位置，并且可以通过单击它、将焦点移动到除了分配了提示的控件之外的控件或在文本框中键入来关闭。
      显示提示会自动将焦点设置为最后一个光标位置的控件。一个窗体一次不能显示多个提示，<br />
      如果重复显示提示，先前的提示将首先被销毁。提示永远不会获得焦点，并且在关闭提示时不会发送任何消息。<br />
      如果在系统工具提示的超时值达到之前，提示没有被关闭，它会自动消失，将焦点留在控件上。
    </remarks>
  </TextControl.ShowEditBalloonTip>

  <TextControl.TextColor>
    <summary>
      用于在控件中绘制文本的颜色。 (有关在颜色对象中指定颜色对象的详细信息，请参阅 Color:Init() 方法。)
    </summary>
    <value>用于在控件中绘制文本的颜色。 (有关在颜色对象中指定颜色对象的详细信息，请参阅 Color:Init() 方法。)</value>
  </TextControl.TextColor>

  <TextControl.TextValue>
    <summary>
      一个字符串，表示控件中保存的值。
    </summary>
    <value>一个字符串，表示控件中保存的值。</value>
    <remarks>
      一个字符串，表示控件中保存的值。例如，在标准编辑控件中，值可以是“Jones”或“$14,683.00”。对于 FixedIcon 对象，TextValue 设置为 NULL_STRING，对于所有其他不可编辑的控件，TextValue 设置为 Caption 值。
      请注意，字符串的格式根据文本控件的字段规范中保存的图片子句进行格式化；反过来，与数据服务器链接的文本控件继承字段，因此也继承图片子句。
    </remarks>
  </TextControl.TextValue>

  <TextObject>
    <summary>
      创建一个文本绘制对象。
    </summary>
    <remarks>
      这是 DrawObject 层次结构的一部分。它允许程序员在给定颜色的特定点显示文本字符串。可以指定一个可选的字体。
    </remarks>
  </TextObject>

  <TextObject.ctor>
    <summary>
      创建一个 TextObject 对象。
    </summary>
    <param name="oPoint">TextObject 对象在画布坐标中的原点。如果省略，默认为(10,10)。</param>
    <param name="cText">要显示的文本。如果省略，默认为 NULL_STRING。</param>
    <param name="oFont">TextObject 对象要使用的字体。默认为系统字体。</param>
    <param name="oColor">TextObject 对象要使用的颜色。默认为当前使用的颜色。 (有关在颜色对象中指定颜色对象的详细信息，请参阅 Color:Init() 方法。)</param>
  </TextObject.ctor>

  <TextObject.BoundingBox>
    <summary>
      一个边界框，表示最小矩形(在所有者窗口的画布坐标中)包围此 TextObject 对象。
    </summary>
    <value>一个边界框，表示最小矩形(在所有者窗口的画布坐标中)包围此 TextObject 对象。</value>
  </TextObject.BoundingBox>

  <TextObject.Color>
    <exclude />
  </TextObject.Color>

  <TextObject.Destroy>
    <exclude />
  </TextObject.Destroy>

  <TextObject.DisplayText>
    <exclude />
  </TextObject.DisplayText>

  <TextObject.Draw>
    <summary> 
      在窗口上绘制 TextObject 对象。 <br />
      重要！当文本需要重新绘制时，X# 会调用此方法。不要从应用程序代码中调用此方法，而应使用 Window:Draw()。 
    </summary>
  </TextObject.Draw>

  <TextObject.Font>
    <exclude />
  </TextObject.Font>

  <ToolBar>
    <summary>
      创建一个工具栏。
    </summary>
    <remarks>
      工具栏为用户提供了一种选择菜单命令的替代方式。<br />
      虽然工具栏看起来更像是一组控件，而不是菜单，但它是作为菜单而不是作为控件构建和操作的。
      事实上，菜单、工具栏和按钮生成的事件并没有根本的不同：每个菜单命令、工具栏按钮或按钮都有一个符号名称；
      每种类型的事件都调用一个命名方法；
      每个都有一个在状态栏中显示的描述(“短帮助”)和一个在选择上下文帮助(Shift+F1)时显示的帮助上下文。<br />
      但是，由于工具栏是一个对象，能够生成许多事件，而且，由于它是作为整个窗口的一部分(而不是作为几个按钮)，
      它更像是一个菜单而不是一个常规控件。<br />
      此外，定义和使用工具栏的标准方式是作为其关联菜单的附属物；这是菜单编辑器生成的结构。<br />
      工具栏按钮可以以图标、图标加文本标题或仅文本的形式呈现。<br />
      按钮周围的边框提供了几种不同的外观，按钮之间的间隙可以调整。如果工具栏太小，无法显示所有的按钮，可能是因为其所有者窗口太小，
      它会自动显示滚动按钮。<br />
      工具栏的放置在一定程度上取决于其内容。<br />
      例如，只有文本的按钮是长而薄的，因此最好沿垂直边缘堆叠，而不是沿顶部或底部边缘。
      只有图标的按钮，没有间隙，沿顶部边缘看起来非常自然。图标和文本按钮，带有一个小间隙，沿底部边缘是有效的。<br />
      ToolBar 类还提供了 CoolBar/Band 支持，即带有分隔符带的工具栏(这个例子来自 Internet Explorer 的扁平样式工具栏带)。`
      分配工具栏给窗口的方式与分配菜单给窗口的方式相同，通过对 AppWindow:ToolBar() 的赋值。
      每个工具栏按钮都与一个菜单命令关联，并生成相应的菜单事件；因此，分配给窗口的菜单和工具栏必须协调。<br />
      管理工具栏的最方便的方式是在创建菜单时将其与菜单关联。然后，当菜单分配给窗口时，它的工具栏也会自动分配。
      这种自动的方法，与菜单编辑器创建的类定义相匹配，确保工具栏按钮的点击与预期的菜单命令事件相关联。
      <code language="X#">
        METHOD Init(oWOwner) CLASS MyWindow
            ...
            SELF:Menu := MyMenu{}
            ...
            METHOD Init() CLASS MyMenu
            ...
            SELF:ToolBar := ToolBar{}
      </code>
      (这也是加速键表的使用方法。因此，“菜单”实际上是菜单、加速键表和工具栏的组合，所有这些都是协调的，都一起使用。)<br />
      可以在任何窗口上放置工具栏，甚至是不能拥有菜单的窗口(例如对话框窗口和嵌套子窗口)。
      在这些情况下，分配菜单不会产生可见的菜单，但工具栏仍然是活动的。
      还可以将工具栏按钮与未包含在任何菜单中的菜单命令关联，只要菜单命令在 Menu:RegisterItem() 中注册。<br />
      工具栏占据窗口的客户区。一些窗口类型会自动适应这种空间冲突，但其他需要显式管理空间。<br />
      在业务应用程序中，工具栏最常见的用法是将其附加到shell窗口或数据窗口。
      这两种窗口类型都会自动适应工具栏，因此不需要进一步的操作。
      数据窗口最有可能是作为 shell 的子窗口使用，或者作为嵌套子窗口；在任何一种情况下，数据窗口都会适应工具栏。<br />
      将工具栏放在子窗口上特别有用：它可以将操作与它们应用的数据进行视觉关联。
      许多数据窗口可能会使用工具栏按钮，比如插入记录、删除记录、跳过下一个、跳过上一个、转到顶部、转到底部、查找、撤销、剪切、复制和粘贴。<br />
      对于一般的顶层窗口、子窗口和对话框窗口，空间管理是开发人员的责任。
      对于窗口上的工具栏，这有点棘手，特别是如果允许用户拖动工具栏：可用空间取决于窗口的调整大小和工具栏的放置。
      工具栏具有 ToolBar:ClientArea 访问，可以在暴露事件中调用，以确定剩余区域的形状。<br />
      似乎工具栏附加到窗口的控制事件的操作是非常明显的：点击打印按钮会向窗口发送一个 #Print 消息。
      但是，如果工具栏没有附加到子窗口，而是附加到shell窗口呢？或者如果它附加到子窗口，
      但是处理消息的方法属于 shell 窗口？或者工具栏附加到作为嵌套子窗体使用的数据窗口呢？<br />
      工具栏在其操作上与菜单是相同的。无论哪个窗口拥有工具栏或菜单，命令事件都首先发送到具有焦点的窗口；
      如果它不处理，就会发送到它的所有者，以及它的所有者，直到它被处理。如果没有窗口响应消息，shell 窗口会在其状态栏中显示一条消息。<br />
      更准确地说，给定工具栏或菜单命令的符号名称，响应链如下： 焦点窗口是否有一个方法，方法名正确？如果是，就调用它。 
      <note type="tip">
        这不一定是拥有工具栏或菜单的窗口。
      </note>
      检查它的所有者是否有匹配的方法，以及所有者的所有者，依此类推。<br />
      如果没有窗口有匹配的方法，消息就会发送到具有焦点的窗口的 MenuCommand() 方法。<br />
      默认实现的逻辑如下：如果它是窗口的所有者(如子窗口或子窗体)，就将方法传递给它的所有者；
      如果它是应用程序的所有者(如顶层或 shell 窗口)，就检查是否有一个窗口类与该名称匹配，如果有，就实例化它；如果没有，就显示消息。
      当然，MenuCommand() 方法可以用不同的逻辑替换(例如，低级 Windows 编程中经常使用的传统 CASE 语句)。<br />
      因此，有两种升级链：首先，系统沿着所有权链找到匹配的方法名；然后，它沿着 MenuCommand() 方法的升级链进行升级。
      如果没有窗口对方法做出响应，作为最后的手段，就会尝试窗口实例化；否则，它会失败。
      这意味着工具栏可以放在 shell 窗口、子窗口，甚至嵌套子窗口上：在任何情况下，它都是活动的，消息会发送到所有窗口，
      并沿着所有权链进行传播。
      请记住，任何时候只有一个菜单是可见的，具有菜单的子窗口会替换其 shell 的菜单；但工具栏不同，它们可以在任何类型的窗口上都可见。<br />
      窗口实例化的技巧意味着，如果我们在窗口编辑器中设计一个窗口，只需将其名称给予某个可见窗口的菜单或工具栏项，就可以打开它。 
      请注意，存在混淆用户的潜在风险，因为命令可能会引用不同的窗口
      (这个问题不仅限于工具栏，也适用于菜单)。<br />
      考虑一个订单窗口，其中包含有关订单的信息，以及一个嵌套的子窗口(在浏览视图中)，其中包含订单的行项目。
      如果菜单包含一个删除命令，这个命令是指什么？它是删除订单，删除订单及其所有行项目，还是只删除一个行项目？<br />
      从技术上讲，问题是清楚的：命令首先发送到具有焦点的最低级别窗口，因此如果用户位于行项目子窗口上，该窗口首先收到命令。
      如果它不对其做出响应，订单窗口和后来是 shell 窗口就会收到命令。
      但是，从用户的角度来看，这种行为并不明显。问题出在菜单命令或工具栏按钮的标题上：“删除”并不是很清晰。
      由于用户可能不知道行项目表是一个子窗口(它看起来只是一个窗口上的表)，因此在不同的位置(取决于光标的位置)获取不同的删除效果可能会令人困惑。
      因此，建议菜单命令和工具栏按钮的标签明确和清晰，例如“删除订单”和“删除项目”。
      即使更高级别的逻辑根据光标位置和数据禁用命令(例如，只要还有未发货的行项目，删除订单可能会变灰)，标签也应该清晰。
      </remarks>
    <example>
      有关适当代码的示例，请使用菜单编辑器生成一个简单的菜单，其中包含工具栏，然后使用窗口编辑器将此菜单分配给一个窗口。
    </example>
  </ToolBar>

  <ToolBar.ctor>
    <summary>
      创建一个工具栏。
    </summary>
    <param name="oOwner">拥有工具栏的窗口。</param>
    <param name="xID">工具栏的唯一ID(1到8000之间)。</param>
    <param name="oPoint">工具栏在画布坐标中的原点。</param>
    <param name="oDimension">工具栏在画布坐标中的尺寸。</param>
    <param name="nButtonSize">工具栏按钮的大小。默认为16。</param>
    <param name="lEnableBands">
      一个标志，指定工具栏是否支持带。<br />
      如果标志设置为 FALSE 或应用程序在旧版本的公共控件库上运行，那么带支持将被禁用。
      在这种情况下，带相关的方法(AddBand()，AddSubToolBarBand()等)将不可用。默认为 TRUE。
    </param>
    <remarks>
      通常，工具栏是通过将其附加到相应的菜单来分配给窗口的；
      当菜单分配给窗口时，工具栏也会被分配。(也可以通过 AppWindow:ToolBar 属性显式分配工具栏。)<br />
      实例化工具栏并不会使其可见和活动。工具栏只有在与窗口的分配方式相同的方式下附加到窗口时才会变得活动。
      为了减少“视觉噪音”(不希望的闪烁和闪烁)，应在将工具栏分配给窗口并使其可见之前完成按钮的配置和工具栏的布局。<br />
      要定义工具栏的按钮布局，可以使用 AppendItem() 和 InsertItem() 方法。
      请注意，项目ID必须与相应的菜单项ID协调。管理这种对应关系的最简单方法是使用菜单编辑器，它会自动生成相应的代码。<br />
      工具栏可以放置在任何类型的窗口上。但是，请注意，工具栏会占据窗口的一部分区域，留下较少的可用空间。
      Shell 窗口和数据窗口会自动适应工具栏，但如果将工具栏放在其他类型的窗口上，需要显式适应。
      可以使用 ToolBar:ClientArea 属性确定剩余空间的大小。
    </remarks>
  </ToolBar.ctor>

  <ToolBar.AddBand>
    <summary>
      使用此方法向工具栏添加一个带。
    </summary>
    <param name="sBandName">命名带的符号。</param>
    <param name="oControl">要包含在新带中的窗口或控件。</param>
    <param name="iPos">带的位置。默认为最后一个位置(-1)。</param>
    <param name="iMinWidth">带的最小宽度。</param>
    <param name="iMinHeight">带的最小高度。</param>
    <param name="sText">在带上显示的文本。</param>
    <param name="oForeColor">指定带前景色的Color对象。</param>
    <param name="oBackColor">指定带背景色的Color对象。</param>
    <param name="iImageIndex">指定要显示的图像的图像列表中的索引。</param>
    <param name="oBackBitmap">指定要作为带背景显示的位图的Bitmap对象。</param>
    <returns>
      如果操作成功，则返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      ToolBar:AddBand() 方法向工具栏添加一个新的带。带是工具栏控件或窗口的独立区域，可以由最终用户调整大小和移动。每个带可以包含一个文本、一个图像和一个控件。此外，还可以指定前景和背景颜色，以及一个背景位图。如果要创建一个作为控件的子工具栏的带，可以使用 ToolBar:AddSubToolBarBand()。
    </remarks>
    <example>
      有关带样式工具栏的示例，请参见 Private Eye 示例应用程序。
    </example>
  </ToolBar.AddBand>

  <ToolBar.AddSubToolBarBand>
    <summary>
      将一个新的带作为子工具栏添加到工具栏。
    </summary>
    <param name="symToolBar">命名主工具栏的符号。</param>
    <param name="iPos">子工具栏带的位置。默认为-1(最后一个位置)。</param>
    <param name="iMinWidth">子工具栏带的最小宽度。默认为100。</param>
    <param name="lFlat_dwStyle"> 
      现在可以向此参数传递一个 DWORD 值，这样就可以在 ReBar 控件中创建具有不同样式的 ToolBar。 
      <list type="table">
        <listheader>
          <term>样式</term>
          <description>值</description>
        </listheader>
        <item>
          <term>
            BSTYLE_TOOLTIPS
          </term>
          <description>0x0100</description>
        </item>
        <item>
          <term>
            TBSTYLE_WRAPABLE
          </term>
          <description>0x0200</description>
        </item>
        <item>
          <term>
            TBSTYLE_ALTDRAG
          </term>
          <description>0x0400</description>
        </item>
        <item>
          <term>
            TBSTYLE_FLAT
          </term>
          <description> 0x0800</description>
        </item>
        <item>
          <term>
            TBSTYLE_LIST
          </term>
          <description>0x1000</description>
        </item>
        <item>
          <term>
            TBSTYLE_CUSTOMERASE
          </term>
          <description> 0x2000</description>
        </item>
        <item>
          <term>
            TBSTYLE_REGISTERDROP
          </term>
          <description>0x4000</description>
        </item>
        <item>
          <term>
            TBSTYLE_TRANSPARENT
          </term>
          <description>0x8000</description>
        </item>
      </list>
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      AddSubToolBarBand() 方法创建一个新的带，该带包含自己的工具栏。这样，可以创建一个工具栏，它被分成几个带，每个带都包含一个子工具栏。
    </remarks>
  </ToolBar.AddSubToolBarBand>

  <ToolBar.AddTipText>
    <summary>
      添加一个字符串作为按钮的提示文本。
    </summary>
    <param name="nButtonID">要添加文本的按钮的按钮ID。</param>
    <param name="nMenuItemID">要添加文本的按钮的菜单项ID。</param>
    <param name="cText">要添加的文本。</param>
  </ToolBar.AddTipText>

  <ToolBar.AppendItem>
    <summary>
      将一个新的工具栏按钮项添加到工具栏的末尾，该按钮项来自可用按钮的列表。
    </summary>
    <param name="nButtonID">
      新的工具栏按钮项的ID。要在按钮组之间添加间隔，可以附加一个标记为 IDT_SEPARATOR 的项目。要查看可用的标准按钮项，可以在菜单编辑器中打开列表。对于自定义工具栏按钮，可以附加一个标记为 IDT_CUSTOMBITMAP 的项目。(例如，对于第一个按钮，&lt;nButtonID&gt; 是 IDT_CUSTOMBITMAP
      + 1；第二个按钮是 IDT_CUSTOMBITMAP + 2，依此类推。)
    </param>
    <param name="nMenuItemID">新的工具栏按钮项对应的菜单项的ID。</param>
    <param name="oBmp">
      包含一个或多个自定义位图的位图对象。位图中的每个按钮都必须是一个16色，20 x
      16像素的位图。位图中的第一个按钮必须在像素位置1和20处绘制，第二个按钮在位置21和40处绘制，第三个按钮在位置41和60处绘制，依此类推。(实际上，这是一个按钮的带。)可以将自定义按钮放在单独的位图资源文件中，并为每个按钮创建一个 Bitmap 对象。如果使用这种方法，&lt;nPosition&gt;设置为1。建议在一个位图文件中使用一个按钮的带，因为这样只使用一个句柄。后一种方法将为每个创建的对象使用一个句柄。
    </param>
    <param name="nPosition">
      自定义工具栏按钮在位图中的位置。如果在&lt;oBmp&gt;中使用的是按钮的带，那么第一个按钮是1，第二个按钮是2，依此类推。如果使用单独的位图，或者如果未指定，&lt;nPosition&gt;为1。
      下图说明了一个位图中包含的按钮的带，显示了每个按钮的像素位置和&lt;nPosition&gt;：
    </param>
    <param name="cTitle">
      如果在工具栏上显示按钮时使用的工具栏按钮的标题，可以指定标题。可以是 TB_TEXTANDICON 或 TB_TEXTONLY 样式。如果未指定，使用默认值 NULL_STRING。</param>
    <param name="nImgCount">在&lt;oBmp&gt;中传递的图像中的按钮数量。默认为1。</param>
    <param name="bState">
      按钮的初始状态，启用或禁用。如果启用，用户可以选择按钮。如果禁用，按钮会变暗(灰色)并且不能被选择；直到应用程序启用它，它仍然不可用。默认为启用(TBSTATE_ENABLED)。</param>
    <param name="bStyle">
      工具栏项的可选样式标志。默认情况下，样式会根据其他参数自动推导。但是，通过传递 Windows API 常量，可以强制执行特定的样式。默认为 TBSTYLE_BUTTON。
    </param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">请参阅 Microsoft Win32 软件开发工具包文档，了解有关特定 Windows API 常量的详细信息。</note>
      当按钮被点击时触发的事件，以及在状态栏中显示的描述，都是基于关联菜单的属性。因此，工具栏通过其关联菜单间接控制应用程序的操作。
      通过调用 ToolBar:AppendItem() 方法为每个标准工具栏按钮指定工具栏可能看起来有点麻烦。定义工具栏的推荐方法是使用菜单编辑器，它会自动生成布局工具栏的代码。
      请注意，用户可以使用配置对话框修改工具栏上的按钮项集。程序不需要关心哪些按钮存在，因为事件的发生就像是菜单选择一样。
      为了减少“视觉噪音”(不希望的闪烁和闪烁)，ToolBar:AppendItem() 方法不会立即反映使用 ToolBar:AppendItem() 方法添加的按钮。相反，必须调用 ToolBar:Update() 方法，使所有新的按钮一次性显示出来。ToolBar:Show() 方法会自动更新显示。对于一次性定义并附加到窗口的工具栏，不需要显式调用 ToolBar:Update()，这个方法只适用于在运行时更改其按钮配置的工具栏。
      </remarks>
    <example> 
      以下示例向工具栏添加了两个自定义位图： 
      <code language="X#">
        DEFINE BUTTON_ONE     := 1
        DEFINE BUTTON_TWO     := 2
        DEFINE FIRST_BUTTON   := IDT_CUSTOMBITMAP + BUTTON_ONE
        DEFINE SECOND_BUTTON  := IDT_CUSTOMBITMAP + BUTTON_TWO
        DEFINE MENUOPTIONONE  := 3000
        DEFINE MENUOPTIONTWO  := 3001

        LOCAL oBitmap AS Bitmap
        // IDB_BUTTONS是包含2个按钮的位图的资源定义
        oBitmap := Bitmap{IDT_BUTTONS}
        // 第一个 AppendItem() 方法使用位图对象中的第一个按钮位图，而第二个 AppendItem() 方法使用第二个位图。
        SELF:ToolBar:AppendItem(FIRST_BUTTON,MENUOPTIONONE,  oBitmap,1,"Button One")
        SELF:ToolBar:AppendItem(SECOND_BUTTON, MENUOPTIONTWO,oBitmap,2,"Button Two")
      </code>
    </example>
  </ToolBar.AppendItem>

  <ToolBar.AppendSubItem>
    <exclude />
  </ToolBar.AppendSubItem>

  <ToolBar.BandCount>
    <summary>
      工具栏中的带的数量。
    </summary>
    <value>工具栏中的带的数量。</value>
  </ToolBar.BandCount>

  <ToolBar.BandImageList>
    <summary>
      用于带的 Image List 对象。
    </summary>
    <value>用于带的 Image List 对象。</value>
  </ToolBar.BandImageList>

  <ToolBar.Bitmap>
    <summary>
      用于在工具栏上显示按钮的 Bitmap 对象(包含一个或多个按钮图像的位图带)。如果未分配，将使用默认位图。
    </summary>
    <value>用于在工具栏上显示按钮的 Bitmap 对象(包含一个或多个按钮图像的位图带)。如果未分配，将使用默认位图。</value>
  </ToolBar.Bitmap>

  <ToolBar.BorderStyle>
    <summary>
      此属性不再受支持。仅用于与现有 X#1.0 代码的兼容性。
    </summary>
    <value>此属性不再受支持。仅用于与现有 X#1.0 代码的兼容性。</value>
  </ToolBar.BorderStyle>

  <ToolBar.BoundingBox>
    <summary>
      表示包围工具栏的最小区域的画布坐标中的边界框。
    </summary>
    <value>表示包围工具栏的最小区域的画布坐标中的边界框。</value>
  </ToolBar.BoundingBox>

  <ToolBar.ButtonCount>
    <summary>
      表示当前工具栏上的按钮数量的数字值。
    </summary>
    <value>表示当前工具栏上的按钮数量的数字值。</value>
  </ToolBar.ButtonCount>

  <ToolBar.ButtonSize>
    <summary>
      表示工具栏上按钮的大小的 Dimension 对象。如果未分配，将使用默认的16 x 16按钮。
    </summary>
    <value>表示工具栏上按钮的大小的 Dimension 对象。如果未分配，将使用默认的16 x 16按钮。</value>
  </ToolBar.ButtonSize>

  <ToolBar.ButtonStyle>
    <summary>
      代表按钮显示方式的常量：
    </summary>
    <value>代表按钮显示方式的常量：</value>
    <remarks> 
      代表按钮显示方式的常量： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>TB_ICONONLY</term>
          <description> 仅显示图标。按钮非常小，可以在有限的空间中容纳许多个。这是<b>默认</b>值。 </description>
        </item>
        <item>
          <term>TB_TEXTANDICON</term>
          <description>同时显示文本和图标。按钮非常大，不能容纳太多个，但使用和理解都很容易。</description>
        </item>
        <item>
          <term>TB_TEXTONLY</term>
          <description>
            仅显示文本。图标宽，但低。在顶部或底部的工具栏上占用太多空间，但在左侧或右侧可能非常有用。
            带有文本标签的按钮并不太花哨，但在某些情况下，可能需要对抽象概念之间的细微区别进行引用，
            而找到可识别的图标可能并不容易(例如，对于 Lease，Secured Credit 和 Unsecured Credit 等选择)。
        </description>
        </item>
      </list>
    </remarks>
  </ToolBar.ButtonStyle>

  <ToolBar.ChangeTipText>
    <summary>
      更改按钮的当前提示文本。
    </summary>
    <param name="nID">要更改其提示文本的按钮的ID。这可以是按钮的ID或菜单项的ID，取决于&lt;symLookup&gt;的值。</param>
    <param name="cText">将替换当前提示文本的文本。</param>
    <param name="symLookUp">
      描述如何解释&lt;nID&gt;的符号。如果值为#ButtonID，&lt;nID&gt;是按钮的ID；否则，如果值为#MenuItemID，&lt;nID&gt;是按钮的菜单项的ID。如果省略，&lt;nID&gt;将被解释为按钮的ID。</param>
    <returns>
      如果可以更改文本，则为 TRUE；否则，为 FALSE。
    </returns>
  </ToolBar.ChangeTipText>

  <ToolBar.ClickItem>
    <summary>
      使按钮看起来像已被点击，表示已被选中。
    </summary>
    <param name="nMenuItemID">
      与被点击的按钮对应的菜单项的ID。这不是定义按钮外观的原始按钮ID；相反，它是定义按钮含义的菜单项ID。
    </param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
    <remarks>
      ClickItem() 和 UnclickItem() 用于指示状态(“粘性”按钮)。通常，工具栏按钮被点击(使按钮的中间部分变黑)和取消点击(使按钮的中间部分恢复为白色)以表示其对应的菜单项是否已被选中或取消选中。无论按钮是否启用，按钮都会保留其点击状态。
    </remarks>
  </ToolBar.ClickItem>

  <ToolBar.ClientArea>
    <summary>
      表示其父窗口的区域的边界框(组或字符框)，该区域在放置工具栏时仍然可用。
    </summary>
    <value>表示其父窗口的区域的边界框(组或字符框)，该区域在放置工具栏时仍然可用。</value>
    <remarks>
      表示其父窗口的区域的边界框(组或字符框)，该区域在放置工具栏时仍然可用。当工具栏以标准方式使用时，通常很少需要使用此属性；窗口会自动适应工具栏。但是，当将工具栏放置在常规窗口上时，例如 TopAppWindow，开发人员负责使窗口适应用户在移动工具栏时剩余的空间大小。因此，窗口可能会在暴露事件时向其工具栏询问剩余空间的大小。
    </remarks>
  </ToolBar.ClientArea>

  <ToolBar.Configure>
    <summary>
      此方法不再受支持。仅用于与现有 X#1.0 代码的兼容性。
    </summary>
  </ToolBar.Configure>

  <ToolBar.Create>
    <exclude />
  </ToolBar.Create>

  <ToolBar.DeleteItem>
    <summary>
      从工具栏中删除一个按钮。
    </summary>
    <param name="nMenuItemID">
      要删除的按钮对应的菜单项的ID。
      这不是定义按钮外观的原始按钮ID；而是定义按钮含义的菜单项ID。
    </param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
  </ToolBar.DeleteItem>

  <ToolBar.Destroy>
    <summary>
      提供一种取消实例化 ToolBar 对象的方法。
    </summary>
    <remarks>
      当不再需要 ToolBar 对象时，可以使用此方法。ToolBar:Destroy() 取消实例化 ToolBar 对象，并允许您关闭和释放对象打开或创建的任何资源，而无需等待垃圾收集器。
    </remarks>
  </ToolBar.Destroy>

  <ToolBar.DimItem>
    <summary>
      使一个按钮变暗。
    </summary>
    <param name="nMenuItemID">要使其变暗的按钮的菜单项的ID。</param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
  </ToolBar.DimItem>

  <ToolBar.DisableItem>
    <summary>
      禁用一个按钮。
    </summary>
    <param name="nMenuItemID">
      要禁用的按钮对应的菜单项的ID。
      这不是定义按钮外观的原始按钮ID；而是定义按钮含义的菜单项ID。
    </param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
    <remarks>
      通常，工具栏按钮与其对应的菜单项一起被禁用(变暗)和启用(变黑)。无论按钮是否启用，按钮都会保留其点击状态。
    </remarks>
  </ToolBar.DisableItem>

  <ToolBar.Divider>
    <summary>此字段反映构造函数参数 lEnableBands(当 lEnableBands = FALSE 时，Divider 为 TRUE)。</summary>
    <value>工具栏是否应具有分隔符或单独的带。</value>
  </ToolBar.Divider>

  <ToolBar.EnableBands>
    <summary>
      启用工具栏带支持。
    </summary>
    <param name="lEnable">指定工具栏分隔符带是否受支持的逻辑值。默认为 TRUE。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      此方法启用或禁用工具栏带支持。如果启用带(默认情况下)，工具栏内部使用 Rebar32 控件，并支持管理多个带。如果不需要或不想要带，可以在显示/创建工具栏之前发出 EnableBands(FALSE)。
      <note
        type="tip">如果禁用了带支持，与带相关的方法，如 ToolBar:AddBand()，将无法工作。</note>
    </remarks>
    <example>
      有关带样式工具栏的示例，请参见 Private Eye 示例应用程序。
    </example>
  </ToolBar.EnableBands>

  <ToolBar.EnableDrag>
    <summary>
      允许用户使用鼠标移动工具栏。
    </summary>
    <param name="lEnable">指示是否允许拖动的逻辑值。如果省略或未调用该方法，TRUE 是默认值。</param>
    <remarks>
      当拖动到边缘时，工具栏会吸附到边缘；如果留在窗口的中心区域，工具栏会浮动并且可以调整大小。
      EnableDrag() 方法只能在工具栏分配给窗口之前使用。
    </remarks>
  </ToolBar.EnableDrag>

  <ToolBar.EnableItem>
    <summary>
      启用已禁用的按钮。
    </summary>
    <param name="nMenuItemID">
      要启用的按钮对应的菜单项的ID。
      这不是定义按钮外观的原始按钮ID；而是定义按钮含义的菜单项ID。
    </param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
    <remarks>
      通常，工具栏按钮与其对应的菜单项一起被禁用和启用。无论按钮是否启用，按钮都会保留其点击状态。
    </remarks>
  </ToolBar.EnableItem>

  <ToolBar.Flat>
    <exclude />
  </ToolBar.Flat>

  <ToolBar.GapSize>
    <summary>
      此属性不再受支持。仅用于与现有 X#1.0 代码的兼容性。
    </summary>
    <value>此属性不再受支持。仅用于与现有 X#1.0 代码的兼容性。</value>
  </ToolBar.GapSize>

  <ToolBar.GetButtonCount>
    <exclude />
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
  </ToolBar.GetButtonCount>

  <ToolBar.GetButtonDescription>
    <summary>
      检索工具栏按钮的描述。
    </summary>
    <param name="nButtonID">工具栏按钮的ID。</param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
    <returns>
      从与工具栏按钮连接的超链接中获取的工具栏按钮的描述。
    </returns>
  </ToolBar.GetButtonDescription>

  <ToolBar.GetImageList>
    <summary>
      获取由传递的参数指定的 ImageList。
    </summary>
    <param name="symType">
      可以是 #IMAGELIST，#HOTIMAGELIST 或 #DISABLEDIMAGELIST，
      默认值为 #IMAGELIST
    </param>
    <param name="symTB">
      是工具栏(子工具栏)的名称
      默认为 #Maintoolbar
    </param>
    <remarks>
      您可以为每个子工具栏分配自己的 imagelist。此外，您可以为每个子工具栏分配单独的 HotImagelist 和 DisabledImagelist。
      此方法用于获取这些 ImageLists。
    </remarks>
  </ToolBar.GetImageList>

  <ToolBar.GetRows>
    <exclude />
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
  </ToolBar.GetRows>

  <ToolBar.GetState>
    <exclude />
  </ToolBar.GetState>

  <ToolBar.GetTipText>
    <summary>
      返回按钮的当前提示文本。
    </summary>
    <param name="nButtonID">要获取其提示文本的按钮的ID。这可以是按钮的ID或菜单项的ID，取决于&lt;symLookup&gt;的值。</param>
    <param name="symLookUp">
      描述如何解释&lt;nID&gt;的符号。如果值为#ButtonID，&lt;nID&gt;是按钮的ID；否则，如果值为#MenuItemID，&lt;nID&gt;是按钮的菜单项的ID。如果省略，&lt;nID&gt;将被解释为按钮的ID。</param>
    <returns>
      指定按钮的当前提示文本。
    </returns>
  </ToolBar.GetTipText>

  <ToolBar.Hide>
    <summary>
      隐藏工具栏，使其不可见。
    </summary>
    <remarks>
      工具栏保持隐藏，直到调用 ToolBar:Show() 方法。
    </remarks>
  </ToolBar.Hide>

  <ToolBar.HideItem>
    <summary>
      隐藏一个按钮。
    </summary>
    <param name="nMenuItemID">要隐藏的按钮的菜单项的ID。</param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
  </ToolBar.HideItem>

  <ToolBar.ImageCount>
    <summary>
      代表工具栏位图中的图像数量的数字值。如果已将自定义位图分配给工具栏，必须将此值分配为该位图中的图像数量。
    </summary>
    <value>代表工具栏位图中的图像数量的数字值。如果已将自定义位图分配给工具栏，必须将此值分配为该位图中的图像数量。</value>
  </ToolBar.ImageCount>

  <ToolBar.InsertItem>
    <summary>
      在可用按钮列表中的指定工具栏按钮项之前插入一个新的工具栏按钮项。
    </summary>
    <param name="nButtonID">
      新的工具栏按钮项的ID。要在按钮组之间添加间隔，追加一个标记为 IDT_SEPARATOR 的项。要查看可用的按钮项，参见附录A或在菜单编辑器中打开列表。</param>
    <param name="nMenuItemID">新的工具栏按钮项对应的菜单项的ID。</param>
    <param name="nBeforeID">新的工具栏按钮项应在其之前插入的工具栏按钮项的ID。如果省略，新的工具栏按钮项将在最后一个工具栏按钮项之后插入。</param>
    <param name="bState">** 缺少参数文档 **</param>
    <param name="bStyle">** 缺少参数文档 **</param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      触发按钮点击事件和在状态栏中显示的描述都基于关联菜单的属性。因此，工具栏间接地通过其关联的菜单控制应用程序的操作。
      通过为每个按钮调用此方法来指定工具栏可能看起来很麻烦。定义工具栏的推荐方法是使用菜单编辑器，它会自动生成布局工具栏的代码。
      请注意，用户可以使用配置对话框修改工具栏上的按钮项集。程序不需要关心哪些按钮存在，因为事件会像菜单选择一样进入。
      为了减少“视觉噪音”(不希望的闪烁和闪烁)，工具栏不会立即反映使用 InsertItem() 添加的按钮。相反，您必须调用 Update()，使所有新的按钮一次显示出来。Show() 方法会自动更新显示。对于一次定义并附加到窗口的工具栏，不需要显式调用 Update()，它仅用于在运行时更改其按钮配置的工具栏。
    </remarks>
  </ToolBar.InsertItem>

  <ToolBar.IsClicked>
    <summary>
      返回一个逻辑值，指示指定的按钮当前是否被点击或选中。
    </summary>
    <param name="nID">所需工具栏按钮项的ID。</param>
    <param name="symIDType">表示&lt;nButtonID&gt;代表的数据类型的符号。有效值为 #ButtonID 和 #MenuItemID。默认为 #ButtonID。</param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
    <returns>
      如果被点击(或选中)，则为 TRUE；否则为 FALSE。
    </returns>
    <example>
      <code language="X#">
        //检查第一个工具栏按钮是否被禁用
        oTB:IsClicked(1)
        //检查第一个工具栏按钮是否被禁用，为第一个参数指定按钮ID
        oTB:IsClicked(1, #ButtonID)
        //检查文件打开按钮是否被禁用，为第一个参数指定菜单项ID
        oTB:IsClicked(IDM_StandardShellMenu_File_Open_ID, #MenuItemID)
      </code>
    </example>
  </ToolBar.IsClicked>

  <ToolBar.IsDimmed>
    <summary>
      确定按钮是否被禁用。
    </summary>
    <param name="nID">要确定其状态的按钮的ID。这可以是按钮的ID或菜单项的ID，取决于&lt;symLookup&gt;的值。</param>
    <param name="symLookup">
      描述如何解释&lt;nID&gt;的符号。如果值为#ButtonID，&lt;nID&gt;是按钮的ID；否则，如果值为#MenuItemID，&lt;nID&gt;是按钮的菜单项的ID。如果省略，&lt;nID&gt;将被解释为按钮的ID。</param>
    <param name="symIDType">表示&lt;nButtonID&gt;代表的数据类型的符号。有效值为#ButtonID和#MenuItemID。默认为#ButtonID。</param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
    <returns>
      如果按钮被禁用，则为TRUE；否则为FALSE。
    </returns>
    <example>
      <code language="X#">
        //检查第一个工具栏按钮是否被禁用
        oTB:IsDimmed(1)
        //检查第一个工具栏按钮是否被禁用，为第一个参数指定按钮ID
        oTB:IsDimmed(1, #ButtonID)
        //检查文件打开按钮是否被禁用，为第一个参数指定菜单项ID
        oTB:IsDimmed(IDM_StandardShellMenu_File_Open_ID, #MenuItemID)
      </code>
    </example>
  </ToolBar.IsDimmed>

  <ToolBar.IsEnabled>
    <summary>
      返回一个逻辑值，指示指定的按钮当前是否被启用。
    </summary>
    <param name="nID">所需工具栏按钮项的ID。这可以是按钮的ID或菜单项的ID，取决于&lt;symLookup&gt;的值。</param>
    <param name="symIDType">表示&lt;nButtonID&gt;代表的数据类型的符号。有效值为 #ButtonID 和 #MenuItemID。默认为 #ButtonID。</param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
    <returns>
      如果启用，则为 TRUE；否则为 FALSE。
    </returns>
    <example>
      <code language="X#">
        //检查第一个工具栏按钮是否被启用
        oTB:IsEnabled(1)
        //检查第一个工具栏按钮是否被启用，为第一个参数指定按钮ID
        oTB:IsEnabled(1, #ButtonID)
        //检查文件打开按钮是否被启用，为第一个参数指定菜单项ID
        oTB:IsEnabled(IDM_StandardShellMenu_File_Open_ID, #MenuItemID)
      </code>
    </example>
  </ToolBar.IsEnabled>

  <ToolBar.IsHidden>
    <summary>
      确定按钮是否被隐藏。
    </summary>
    <param name="nID">要确定其状态的按钮的ID。这可以是按钮的ID或菜单项的ID，取决于&lt;symLookup&gt;的值。</param>
    <param name="symIDType">
      描述如何解释&lt;nID&gt;的符号。如果值为#ButtonID，&lt;nID&gt;是按钮的ID；否则，如果值为#MenuItemID，&lt;nID&gt;是按钮的菜单项的ID。如果省略，&lt;nID&gt;将被解释为按钮的ID。</param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
    <returns>
      如果按钮被隐藏，则为 TRUE；否则为 FALSE。
    </returns>
  </ToolBar.IsHidden>

  <ToolBar.IsPressed>
    <summary>
      确定按钮是否被按下。
    </summary>
    <param name="nID">要确定其状态的按钮的ID。这可以是按钮的ID或菜单项的ID，取决于&lt;symLookup&gt;的值。</param>
    <param name="symIDType">
      描述如何解释&lt;nID&gt;的符号。如果值为#ButtonID，&lt;nID&gt;是按钮的ID；否则，如果值为#MenuItemID，&lt;nID&gt;是按钮的菜单项的ID。如果省略，&lt;nID&gt;将被解释为按钮的ID。</param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
    <returns>
      如果按钮被按下，则为 TRUE；否则为 FALSE。
    </returns>
  </ToolBar.IsPressed>

  <ToolBar.Location>
    <summary>
      此属性不再受支持。仅用于与现有 X#1.0 代码的兼容性。
    </summary>
    <value>此属性不再受支持。仅用于与现有 X#1.0 代码的兼容性。</value>
  </ToolBar.Location>

  <ToolBar.Origin>
    <summary>
      表示工具栏在其所有者窗口上的原点的点。
    </summary>
    <value>表示工具栏在其所有者窗口上的原点的点。</value>
  </ToolBar.Origin>

  <ToolBar.Owner>
    <summary>
      拥有工具栏的窗口。
    </summary>
    <value>拥有工具栏的窗口。</value>
  </ToolBar.Owner>

  <ToolBar.PressItem>
    <summary>
      按下一个按钮。
    </summary>
    <param name="nMenuItemID">要按下的按钮的菜单项的ID。</param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
  </ToolBar.PressItem>

  <ToolBar.RemoveTipText>
    <summary>
      删除按钮的当前提示文本。
    </summary>
    <param name="nButtonID">要删除其提示文本的按钮的ID。这可以是按钮的ID或菜单项的ID，取决于&lt;symLookup&gt;的值。</param>
    <param name="symLookUp">
      描述如何解释&lt;nID&gt;的符号。如果值为#ButtonID，&lt;nID&gt;是按钮的ID；否则，如果值为#MenuItemID，&lt;nID&gt;是按钮的菜单项的ID。如果省略，&lt;nID&gt;将被解释为按钮的ID。</param>
    <returns>
      如果可以删除提示文本，则为 TRUE；否则为 FALSE。
    </returns>
  </ToolBar.RemoveTipText>

  <ToolBar.Rows>
    <summary>
      表示工具栏上的按钮行数的数字值。
      请注意，Rows现在有一个可选参数，&lt;symTB&gt;，用于指示要查询的工具栏或子工具栏。如果未指定，将假定为#MAINTOOLBAR。
    </summary>
    <value>
      表示工具栏上的按钮行数的数字值。
      请注意，Rows现在有一个可选参数，&lt;symTB&gt;，用于指示要查询的工具栏或子工具栏。如果未指定，将假定为#MAINTOOLBAR。
    </value>
    <example> 
      要设置主工具栏的行数，以下语句是等效的： 
      <code language="X#">
        oToolBar:Rows := 3
        oToolBar:[Rows, #MAINTOOLBAR] := 3
      </code>
      要设置(子)工具栏的行数，应该执行以下操作： 
      <code language="X#">
        oToolBar:[Rows, #MYTOOLBAR] := 4
      </code>
      这里，#MYTOOLBAR 是表示要更改的工具栏的符号名称。 有两种方法可以查询主工具栏的行数： 
      <code language="X#">
        nRows := oToolBar:Rows
        nRows := oToolBar:[Rows, #MAINTOOLBAR]
      </code>
      要查询由 #MYSUBTOOLBAR 表示的子工具栏的行数，可以执行以下操作： 
      <code language="X#">
        nRows := oToolBar:[Rows, #MYSUBTOOLBAR]
      </code>
    </example>
  </ToolBar.Rows>

  <ToolBar.SeparatorSize>
    <summary>
      此属性不再受支持。仅用于与现有X#1.0代码的兼容性。
    </summary>
    <value>此属性不再受支持。仅用于与现有X#1.0代码的兼容性。</value>
  </ToolBar.SeparatorSize>

  <ToolBar.SetImageList>
    <summary>
      设置工具栏使用的 ImageList。
    </summary>
    <param name="uImageList">可以是一个 Imagelist 或使用 LR_CREATEDIBSECTION 和背景 Color{192, 192, 192} 加载的位图。</param>
    <param name="symType">
      可以是 #IMAGELIST，#HOTIMAGELIST 或 #DISABLEDIMAGELIST，
      默认值为#IMAGELIST
    </param>
    <param name="symTB">
      是工具栏(子工具栏)的名称
      默认为 #Maintoolbar
    </param>
    <remarks>
      您可以为每个子工具栏分配自己的 imagelist。
      此外，您还可以为每个子工具栏分配一个单独的 HotImagelist 和 DisabledImagelist。
      如果分配的是位图，它会自动转换为兼容的 Imagelist。工具栏 imagelist 的位图必须使用 LR_CREATEDIBSECTION 参数加载，而不是 BMP_3DTRANSPARENT，后者用于 Ribbon。
      位图必须具有工具栏 ribbon 的默认 VO 背景颜色 Color{192, 192, 192}。
    </remarks>
  </ToolBar.SetImageList>

  <ToolBar.SetRows>
    <exclude />
  </ToolBar.SetRows>

  <ToolBar.SetState>
    <exclude />
  </ToolBar.SetState>

  <ToolBar.Show>
    <summary>
      显示工具栏，使其可见。
    </summary>
    <remarks>
      ToolBar:Show() 用于重新显示使用 ToolBar:Hide() 方法隐藏的工具栏。工具栏不必最初显示，只要它被分配给一个窗口，它就会变得可见。
    </remarks>
  </ToolBar.Show>

  <ToolBar.ShowBand>
    <exclude />
  </ToolBar.ShowBand>

  <ToolBar.ShowItem>
    <summary>
      显示一个按钮。
    </summary>
    <param name="nMenuItemID">要显示的按钮的菜单项的ID。</param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
  </ToolBar.ShowItem>

  <ToolBar.Size>
    <summary>
      表示工具栏的大小的维度。
    </summary>
    <value>表示工具栏的大小的维度。</value>
  </ToolBar.Size>

  <ToolBar.UnClickItem>
    <summary>
      使一个按钮看起来像是“点击出去”(返回到其正常状态)，在“点击进去”(指示已选择)后。
    </summary>
    <param name="nMenuItemID">
      对应于未点击的按钮的菜单项的ID。
      这不是定义按钮外观的原始按钮ID；而是定义按钮含义的菜单项ID。
    </param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
    <remarks>
      ToolBar:ClickItem() 和 ToolBar:UnclickItem() 用于指示状态(“粘性”按钮)。工具栏按钮通常被点击进去(这会使按钮的中间部分变黑)，然后点击出去(这会使按钮的中间部分恢复为白色)，以指示其对应的菜单项是否已被选中或取消选中。无论启用还是禁用，按钮都会保留其点击进去的状态。
    </remarks>
  </ToolBar.UnClickItem>

  <ToolBar.UnDimItem>
    <summary>
      取消禁用一个按钮。
    </summary>
    <param name="nMenuItemID">要取消禁用的按钮的菜单项的ID。</param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
  </ToolBar.UnDimItem>

  <ToolBar.UnPressItem>
    <summary>
      取消按下一个按钮。
    </summary>
    <param name="nMenuItemID">要取消按下的按钮的菜单项的ID。</param>
    <param name="symTB">表示要使用的工具栏的符号名称。默认为主工具栏。</param>
  </ToolBar.UnPressItem>

  <ToolBar.Update>
    <summary>
      此方法不再受支持。仅用于与现有X#1.0代码的兼容性。
    </summary>
  </ToolBar.Update>

  <TopAppWindow>
    <summary>
      创建一个顶级应用程序窗口。
    </summary>
    <remarks>
      顶级应用程序窗口是应用程序的主窗口；它没有所有者窗口。与其他应用程序窗口一样，顶级应用程序窗口可以有图标、标题、可调整大小的边框、菜单和系统菜单。一个应用程序可以有多个顶级应用程序窗口。
    </remarks>
    <example> 
      此示例创建一个带有标题“TopAppWindow”的顶级应用程序窗口： 
      <code language="X#">
        METHOD Start() CLASS App
            MyWin := TopAppWindow{}
            MyWin:Caption := "TopAppWindow"
            MyWin:Show()
            SELF:Exec()
      </code>
    </example>
  </TopAppWindow>

  <TopAppWindow.ctor>
    <summary>
      创建一个顶级应用程序窗口。
    </summary>
    <param name="oOwner">拥有顶级应用程序窗口的窗口，即应用程序本身。如果未指定，将使用 SELF。</param>
  </TopAppWindow.ctor>

  <TopAppWindow.Destroy>
    <inheritdoc />
  </TopAppWindow.Destroy>

  <TopAppWindow.Owner>
    <summary>
      顶级应用程序窗口的所有者，可以是 Window 或 App 对象。
    </summary>
    <value>顶级应用程序窗口的所有者，可以是 Window 或 App 对象。</value>
  </TopAppWindow.Owner>

  <TopAppWindow.Resize>
    <inheritdoc />
  </TopAppWindow.Resize>

  <TopAppWindow.ToolBarHeightChanged>
    <inheritdoc />
  </TopAppWindow.ToolBarHeightChanged>

  <TreeView>
    <summary>
      创建一个树形视图控件。
    </summary>
    <remarks>
      树形视图控件是一种显示树形视图项的控件，例如磁盘上的文件和目录。每个项由一个标签和一个可选的图标组成，每个项都可以有一个与之关联的子项列表。通过单击一个项，用户可以展开和折叠与之关联的子项列表。
    </remarks>
  </TreeView>

  <TreeView.ctor>
    <summary>
      构造一个树形视图。
    </summary>
    <param name="oOwner">拥有树形视图的窗口。</param>
    <param name="xID">树形视图的唯一ID(在1和8000之间)。</param>
    <param name="nResourceID">树形视图的资源ID。</param>
    <param name="oPoint">树形视图在画布坐标中的原点。</param>
    <param name="oDimension">树形视图在画布坐标中的尺寸。</param>
    <param name="kStyle">树形视图的样式。</param>
  </TreeView.ctor>

  <TreeView.AddItem>
    <summary>
      将一个新的树形视图项添加为指定父项的最后一个子项。
    </summary>
    <param name="symParentName">父树形视图项的符号名称。</param>
    <param name="oTreeViewItem">要添加的树形视图项。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeView.AddItem>

  <TreeView.Collapse>
    <summary>
      折叠一个树形视图项，隐藏其子项。
    </summary>
    <param name="symName">要折叠的树形视图项的符号名称。</param>
    <param name="oItem">要折叠的树形视图项的 TreeViewItem 对象。</param>
    <param name="lRemoveChildItems">一个逻辑值，指示在折叠项时是否会删除指定项的子树形视图项。如果省略，默认为 FALSE。</param>
    <param name="lAll">如果lAll为 TRUE(默认为 FALSE)，则对指定项的整个子树形视图项执行操作。</param>
    <param name="lForceNotify">
      如果 lForceNotify 为 TRUE(默认为 FALSE)，则会为每个更改了其展开状态的项发送一个通知消息 Window:TreeViewItemExpanding() 和 Window:TreeViewItemExpanded()。
      通常，窗口只会在首次展开项时发送这些消息。这取决于 TVIS_EXPANDEDONCE 状态。(有关更多详细信息，请参见 Platform SDK 中的 TVM_EXPAND 消息。)
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeView.Collapse>

  <TreeView.DeleteAll>
    <summary>
      删除树形视图的所有项。
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeView.DeleteAll>

  <TreeView.DeleteItem>
    <summary>
      删除一个树形视图项。
    </summary>
    <param name="symName">要删除的树形视图项的符号名称。</param>
    <param name="oItem">要删除的树形视图项的 TreeViewItem 对象。</param>
    <param name="lChildrenOnly">
      新的逻辑参数，默认为 FALSE。
      如果 lChildrenOnly 为 TRUE，只会删除子项
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeView.DeleteItem>

  <TreeView.Destroy>
    <exclude />
  </TreeView.Destroy>

  <TreeView.DragDropEnabled>
    <summary>
      一个逻辑值，如果树形视图启用了拖放，则为 TRUE。如果启用了拖放，可以在控件内外拖动项。
    </summary>
    <value>一个逻辑值，如果树形视图启用了拖放，则为 TRUE。如果启用了拖放，可以在控件内外拖动项。</value>
  </TreeView.DragDropEnabled>

  <TreeView.DragImageList>
    <summary>
      一个图像列表，其中包含树形视图在拖放操作期间显示的单个图像。
    </summary>
    <value>一个图像列表，其中包含树形视图在拖放操作期间显示的单个图像。</value>
  </TreeView.DragImageList>

  <TreeView.EditItemLabel>
    <summary>
      开始在树形视图中的项上编辑标签。
    </summary>
    <param name="symName">要编辑其标签的树形视图项的符号名称或 TreeViewItem 对象。</param>
  </TreeView.EditItemLabel>

  <TreeView.EnableDragDrop>
    <summary>
      启用或禁用树形视图的项的拖放。
    </summary>
    <param name="lEnable">一个逻辑值，确定是否启用或禁用拖放。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeView.EnableDragDrop>

  <TreeView.EnableSort>
    <summary>
      注册一个用户定义的方法，用于对树形视图中的项进行排序。
    </summary>
    <param name="symMethodName">
      将用于对树形视图中的项进行排序的用户定义方法的符号名称。调用此方法时，该方法将接收两个 TreeViewItem 对象作为参数。该方法应确定哪个树形视图项应该在树形视图中排在第一位。如果第一个项在第二个项之前，该方法应返回-1；如果第二个项在第一个项之前，该方法应返回1；如果项是等效的，该方法应返回0。</param>
    <returns>
      将用于执行排序的用户定义方法的符号名称。
    </returns>
  </TreeView.EnableSort>

  <TreeView.EnsureVisible>
    <summary>
      确保树形视图中的项可见，如果需要，展开其父项或滚动树形视图。
    </summary>
    <param name="symName">要使其可见的树形视图项的符号名称或 TreeViewItem 对象。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeView.EnsureVisible>

  <TreeView.Expand>
    <summary>
      展开树形视图中的项，显示其子项。
    </summary>
    <param name="symName">要展开的树形视图项的符号名称。</param>
    <param name="oItem">要展开的树形视图项。</param>
    <param name="lAll">如果lAll为TRUE(默认为FALSE)，则对指定项的整个子树形视图项执行操作。</param>
    <param name="lForceNotify">
      如果 lForceNotify 为 TRUE(默认为 FALSE)，则会为每个更改了其展开状态的项发送一个通知消息 Window:TreeViewItemExpanding() 和 Window:TreeViewItemExpanded()。
      通常，窗口只会在首次展开项时发送这些消息。这取决于 TVIS_EXPANDEDONCE 状态。(有关更多详细信息，请参见 Platform SDK 中的 TVM_EXPAND 消息。)
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeView.Expand>

  <TreeView.GetDropHighlight>
    <summary>
      返回拖放操作的目标树形视图项。
    </summary>
    <returns>
      拖放操作的目标树形视图项。
    </returns>
  </TreeView.GetDropHighlight>

  <TreeView.GetFirstChildItem>
    <summary>
      返回第一个子树形视图项。
    </summary>
    <param name="uItem">开始搜索的树形视图项或树形视图项的名称。</param>
    <param name="oItem">开始搜索的树形视图项。</param>
    <param name="symItem">
      开始搜索的树形视图项的符号名称。如果省略，默认从根项开始搜索。
      或者表示开始搜索的树形视图项的 TreeViewItem 对象。
    </param>
    <returns>
      从开始项开始的第一个树形视图项。
    </returns>
  </TreeView.GetFirstChildItem>

  <TreeView.GetFirstVisibleItem>
    <summary>
      返回第一个可见的树形视图项。
    </summary>
    <returns>
      第一个可见的树形视图项。
    </returns>
  </TreeView.GetFirstVisibleItem>

  <TreeView.GetItemAtPosition>
    <summary>
      返回特定位置的树形视图项(如果存在)。
    </summary>
    <param name="oPoint">要查找树形视图项的位置。</param>
    <returns>
      指定位置的树形视图项。
    </returns>
  </TreeView.GetItemAtPosition>

  <TreeView.GetItemAttributes>
    <summary>
      根据其符号名称返回树形视图项。
    </summary>
    <param name="symItem">要返回的树形视图项的符号名称。</param>
    <param name="oItem">要返回的树形视图项的 TreeViewItem 对象。</param>
    <returns>
      指定符号名称的树形视图项。
    </returns>
  </TreeView.GetItemAttributes>

  <TreeView.GetItemBoundingBox>
    <summary>
      返回树形视图项的边界框。
    </summary>
    <param name="symItem">要获取其边界框的树形视图项的符号名称。</param>
    <param name="oItem">要获取其边界框的树形视图项的 TreeViewItem 对象。</param>
    <param name="lTextOnly">逻辑值，确定返回的边界框是否仅包围列表视图项的文本占用的部分(TRUE)，还是整个列表视图项的长度(FALSE)。如果省略，默认为 FALSE。</param>
    <returns>
      指定符号名称或 TreeViewItem 对象的树形视图项的边界框。
    </returns>
  </TreeView.GetItemBoundingBox>

  <TreeView.GetNextSiblingItem>
    <summary>
      返回树形视图项的下一个兄弟项。
    </summary>
    <param name="symItem">要获取其下一个兄弟项的树形视图项的符号名称。</param>
    <param name="oItem">要获取其下一个兄弟项的树形视图项的 TreeViewItem 对象。</param>
    <returns>
      指定项的下一个兄弟树形视图项。
    </returns>
  </TreeView.GetNextSiblingItem>

  <TreeView.GetNextVisibleItem>
    <summary>
      返回树形视图项的下一个可见项。
    </summary>
    <param name="symItem">要获取其下一个可见项的树形视图项的符号名称。</param>
    <param name="oItem">要获取其下一个可见项的树形视图项的 TreeViewItem 对象。</param>
    <returns>
      指定项的下一个可见树形视图项。
    </returns>
  </TreeView.GetNextVisibleItem>

  <TreeView.GetParentItem>
    <summary>
      返回树形视图项的父项。
    </summary>
    <param name="symItem">要获取其父项的树形视图项的符号名称。</param>
    <param name="oItem">要获取其父项的树形视图项的 TreeViewItem 对象。</param>
    <returns>
      指定项的父树形视图项。
    </returns>
  </TreeView.GetParentItem>

  <TreeView.GetPreviousSiblingItem>
    <summary>
      返回树形视图项的上一个兄弟项。
    </summary>
    <param name="symItem">要获取其上一个兄弟项的树形视图项的符号名称。</param>
    <param name="oItem">要获取其上一个兄弟项的树形视图项的 TreeViewItem 对象。</param>
    <returns>
      指定项的上一个兄弟树形视图项。
    </returns>
  </TreeView.GetPreviousSiblingItem>

  <TreeView.GetPreviousVisibleItem>
    <summary>
      返回树形视图项的上一个可见项。
    </summary>
    <param name="symItem">要获取其上一个可见项的树形视图项的符号名称。</param>
    <param name="oItem">要获取其上一个可见项的树形视图项的 TreeViewItem 对象。</param>
    <returns>
      指定项的上一个可见树形视图项。
    </returns>
  </TreeView.GetPreviousVisibleItem>

  <TreeView.GetRootItem>
    <summary>
      返回树形视图的根项。
    </summary>
    <returns>
      树形视图的根项。
    </returns>
  </TreeView.GetRootItem>

  <TreeView.GetSelectedItem>
    <summary>
      返回当前选定的树形视图项。
    </summary>
    <returns>
      当前选定的树形视图项。
    </returns>
  </TreeView.GetSelectedItem>

  <TreeView.ImageList>
    <summary>
      一个图像列表，其中包含树形视图中每个项要显示的图像。
    </summary>
    <value>一个图像列表，其中包含树形视图中每个项要显示的图像。</value>
  </TreeView.ImageList>

  <TreeView.Indent>
    <summary>
      一个数字值，表示子项从父项缩进的像素数。
    </summary>
    <value>一个数字值，表示子项从父项缩进的像素数。</value>
  </TreeView.Indent>

  <TreeView.InsertItem>
    <summary>
      将一个新的树形视图项作为指定项的子项插入到树形视图中的特定位置。
    </summary>
    <param name="symParentName">
      新项的父树形视图项的符号名称。这可以是任何树形视图项的符号名称，或以下项之一：#Root，#First，#Last，如果树形视图样式是排序的，则还有#Sort。</param>
    <param name="symInsertAfter">
      新项应在其后插入的树形视图项的符号名称。这可以是任何树形视图项的符号名称，或以下项之一：#Root，#First，#Last，如果树形视图样式是排序的，则还有#Sort。</param>
    <param name="oTreeViewItem">要插入的树形视图项。</param>
    <returns>
      如果成功插入项，则为 TRUE；否则为 FALSE。
    </returns>
  </TreeView.InsertItem>

  <TreeView.ItemCount>
    <summary>
      一个数字值，表示树形视图中的项的数量。
    </summary>
    <value>一个数字值，表示树形视图中的项的数量。</value>
  </TreeView.ItemCount>

  <TreeView.SearchString>
    <summary>
      与树形视图关联的增量搜索字符串。
    </summary>
    <value>与树形视图关联的增量搜索字符串。</value>
    <remarks>
      与树形视图关联的增量搜索字符串。增量搜索字符串是用户在树形视图具有输入焦点时键入的字符序列。当用户键入一个字符时，该字符将附加到搜索字符串，并寻找匹配的项。如果系统找到匹配项，它将选择该项。搜索字符串有一个与之关联的超时期；如果用户在超时期过去之前键入另一个字符，字符串将被重置。
    </remarks>
  </TreeView.SearchString>

  <TreeView.SelectItem>
    <summary>
      使树形视图选择树形视图项，将该项滚动到视图中，或将其重新绘制为拖放操作的目标。
    </summary>
    <param name="symItem">要选择的树形视图项的符号名称。</param>
    <param name="oItem">表示要选择的树形视图项的 TreeViewItem 对象。</param>
    <param name="symCode">
      选择类型的符号名称。可以是以下值之一：#FirstVisible(将项滚动到视图中)或#DropHighlight(重新绘制项)。如果省略，将简单选择该项。</param>
    <param name="lSelect">可选的逻辑值，用于确定是否选择(TRUE)或取消选择(FALSE)指定的树形视图项。如果省略，默认为 TRUE。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeView.SelectItem>

  <TreeView.SetItemAttributes>
    <summary>
      更新树形视图中的树形视图项。
    </summary>
    <param name="oTreeViewItem">要更新的树形视图项。</param>
  </TreeView.SetItemAttributes>

  <TreeView.SortChildren>
    <summary>
      使用 EnableSort() 指定的用户定义排序方法对项目的子树形视图项进行排序。
    </summary>
    <param name="symParentName">要对其子树形视图项进行排序的树形视图项的符号名称。</param>
    <param name="oParentItem">表示要对其子树形视图项进行排序的树形视图项的 TreeViewItem 对象。</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeView.SortChildren>

  <TreeView.StateImageList>
    <summary>
      包含要在树形视图中的每个项上显示的状态图像的图像列表。
    </summary>
    <value>包含要在树形视图中的每个项上显示的状态图像的图像列表。</value>
  </TreeView.StateImageList>

  <TreeView.Toggle>
    <summary>
      切换树形视图项的展开或折叠状态，适当地显示或隐藏其子项。
    </summary>
    <param name="symName">要切换或折叠的树形视图项的符号名称，或表示要切换或折叠的树形视图项的 TreeViewItem 对象。</param>
    <param name="lAll">如果lAll为TRUE(默认为FALSE)，则对指定项的整个子树形视图项执行操作。</param>
    <param name="lForceNotify">
      如果 lForceNotify 为TRUE(默认为FALSE)，则会为每个更改了其展开状态的项发送一个通知消息 Window:TreeViewItemExpanding() 和 Window:TreeViewItemExpanded()。
      通常，窗口只会在首次展开项时发送这些消息。这取决于 TVIS_EXPANDEDONCE 状态。(有关更多详细信息，请参见 Platform SDK 中的 TVM_EXPAND 消息。)
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeView.Toggle>

  <TreeView.VisibleCount>
    <summary>
      一个数字值，表示在树形视图中完全可见的树形视图项的数量。
    </summary>
    <value>一个数字值，表示在树形视图中完全可见的树形视图项的数量。</value>
  </TreeView.VisibleCount>

  <TreeView_CompareDelegate.ctor>
    <exclude />
  </TreeView_CompareDelegate.ctor>

  <TreeView_CompareDelegate.BeginInvoke>
    <exclude />
  </TreeView_CompareDelegate.BeginInvoke>

  <TreeView_CompareDelegate.EndInvoke>
    <exclude />
  </TreeView_CompareDelegate.EndInvoke>

  <TreeView_CompareDelegate.Invoke>
    <exclude />
  </TreeView_CompareDelegate.Invoke>

  <TreeViewDeleteEvent>
    <summary>
      提供有关树形视图删除事件的信息，该事件在删除树形视图控件中的项时生成。
    </summary>
    <remarks>
      树形视图控件在删除其项之一时生成此事件。与此事件对象打包的信息包括删除的是哪个项，以便应用程序可以处理存储在 TreeViewItem 对象中的任何信息。
    </remarks>
  </TreeViewDeleteEvent>

  <TreeViewDeleteEvent.ctor>
    <inheritdoc />
  </TreeViewDeleteEvent.ctor>

  <TreeViewDeleteEvent.TreeViewItem>
    <summary>
      被删除的 TreeViewItem 对象。
    </summary>
    <value>被删除的 TreeViewItem 对象。</value>
  </TreeViewDeleteEvent.TreeViewItem>

  <TreeViewDragEvent>
    <summary>
      提供有关树形视图拖动事件的信息，该事件在拖动树形视图控件中的项时生成。
    </summary>
    <remarks>
      树形视图控件在拖动其项之一时生成此事件。用户可以使用右键或左键生成事件，并根据当前使用的鼠标按钮采取不同的行动。
    </remarks>
  </TreeViewDragEvent>

  <TreeViewDragEvent.ctor>
    <inheritdoc />
  </TreeViewDragEvent.ctor>

  <TreeViewDragEvent.IsLeftButton>
    <summary>
      一个逻辑值，如果这是左键拖动，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果这是左键拖动，则为 TRUE。</value>
  </TreeViewDragEvent.IsLeftButton>

  <TreeViewDragEvent.IsRightButton>
    <summary>
      一个逻辑值，如果这是右键拖动，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果这是右键拖动，则为 TRUE。</value>
  </TreeViewDragEvent.IsRightButton>

  <TreeViewDragEvent.ListViewItem>
    <summary>
      正在拖动的 TreeViewItem 对象。
    </summary>
    <value>正在拖动的 TreeViewItem 对象。</value>
  </TreeViewDragEvent.ListViewItem>

  <TreeViewDragEvent.Position>
    <summary>
      一个 Point 对象，描述树形视图控件中拖动的初始位置。
    </summary>
    <value>一个 Point 对象，描述树形视图控件中拖动的初始位置。</value>
  </TreeViewDragEvent.Position>

  <TreeViewDragEvent.TreeViewItem>
    <summary>
      被拖动的 TreeViewItem 对象。
    </summary>
    <value>被拖动的 TreeViewItem 对象。</value>
  </TreeViewDragEvent.TreeViewItem>

  <TreeViewEditEvent>
    <summary>
      提供有关树形视图编辑事件的信息，该事件在编辑树形视图控件中的项的标签时生成。
    </summary>
    <remarks>
      树形视图控件在编辑其项之一的标签时生成此事件。对于任何编辑操作，实际上会生成两次此事件：一次在编辑开始时，一次在编辑结束时。此对象的属性可以确定编辑是开始还是结束。
    </remarks>
  </TreeViewEditEvent>

  <TreeViewEditEvent.ctor>
    <inheritdoc />
  </TreeViewEditEvent.ctor>

  <TreeViewEditEvent.EditBeginning>
    <summary>
      一个逻辑值，如果编辑开始，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果编辑开始，则为 TRUE。</value>
  </TreeViewEditEvent.EditBeginning>
  
  <TreeViewEditEvent.EditEnding>
    <summary>
      一个逻辑值，如果编辑结束，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果编辑结束，则为 TRUE。</value>
  </TreeViewEditEvent.EditEnding>

  <TreeViewEditEvent.EditText>
    <summary>
      TreeViewItem 对象的已更改标签。
    </summary>
    <value>TreeViewItem 对象的已更改标签。</value>
  </TreeViewEditEvent.EditText>

  <TreeViewEditEvent.TreeViewItem>
    <summary>
      正在编辑的 TreeViewItem 对象。
    </summary>
    <value>正在编辑的 TreeViewItem 对象。</value>
  </TreeViewEditEvent.TreeViewItem>

  <TreeViewExpandedEvent>
    <summary>
      提供有关树形视图展开事件的信息，该事件在展开或折叠树形视图中的项时生成，显示或隐藏其子项。
    </summary>
    <remarks>
      树形视图控件在展开或折叠其项之一时生成此事件。事件对象中打包的信息包括哪个项受到影响以及该项是折叠还是展开。
    </remarks>
  </TreeViewExpandedEvent>

  <TreeViewExpandedEvent.ctor>
    <inheritdoc />
  </TreeViewExpandedEvent.ctor>

  <TreeViewExpandedEvent.Collapsed>
    <summary>
      一个逻辑值，如果项被折叠，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果项被折叠，则为 TRUE。</value>
  </TreeViewExpandedEvent.Collapsed>

  <TreeViewExpandedEvent.Expanded>
    <summary>
      一个逻辑值，如果项被展开，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果项被展开，则为 TRUE。</value>
  </TreeViewExpandedEvent.Expanded>

  <TreeViewExpandedEvent.TreeViewItem>
    <summary>
      正在修改的 TreeViewItem 对象。
    </summary>
    <value>正在修改的 TreeViewItem 对象。</value>
  </TreeViewExpandedEvent.TreeViewItem>

  <TreeViewExpandingEvent>
    <summary>
      提供有关树形视图展开事件的信息，该事件在即将展开或折叠树形视图中的项时生成，显示或隐藏其子项。
    </summary>
    <remarks>
      树形视图控件在即将展开或折叠其项之一时生成此事件。事件对象中打包的信息包括哪个项受到影响。此对象与 TreeViewExpandedEvent 的主要区别在于，此事件在展开/折叠操作发生之前生成。
    </remarks>
  </TreeViewExpandingEvent>

  <TreeViewExpandingEvent.ctor>
    <inheritdoc />
  </TreeViewExpandingEvent.ctor>

  <TreeViewExpandingEvent.TreeViewItem>
    <summary>
      正在修改的 TreeViewItem 对象。
    </summary>
    <value>正在修改的 TreeViewItem 对象。</value>
  </TreeViewExpandingEvent.TreeViewItem>

  <TreeViewItem>
    <summary>
      创建一个树形视图项。
    </summary>
    <remarks>
      树形视图项描述树形视图控件中的一个项。
    </remarks>
  </TreeViewItem>

  <TreeViewItem.ctor>
    <summary>
      构造一个树形视图项。
    </summary>
    <param name="sName">树形视图项的符号名称。</param>
    <param name="cTextVal">树形视图项的文本值。</param>
    <param name="uVal">与树形视图项关联的通常值。</param>
    <param name="iImage">一个数字值，表示树形视图项在图像列表中的图像的索引。</param>
    <param name="iSelImage">一个数字值，表示树形视图项在图像列表中的选定图像的索引。</param>
  </TreeViewItem.ctor>

  <TreeViewItem.Bold>
    <summary>
      一个逻辑值，如果树形视图项的文本是粗体，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果树形视图项的文本是粗体，则为 TRUE。</value>
  </TreeViewItem.Bold>

  <TreeViewItem.Delete>
    <summary>
      删除树形视图项。
    </summary>
    <param name="lChildrenOnly">
      新的逻辑参数，默认为 FALSE。
      如果 lChildrenOnly 为 TRUE，只删除子项
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeViewItem.Delete>

  <TreeViewItem.Disabled>
    <summary>
      一个逻辑值，如果树形视图项的图像被禁用，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果树形视图项的图像被禁用，则为 TRUE。</value>
  </TreeViewItem.Disabled>

  <TreeViewItem.DropTarget>
    <summary>
      一个逻辑值，如果树形视图项被突出显示为拖放操作的目标，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果树形视图项被突出显示为拖放操作的目标，则为 TRUE。</value>
  </TreeViewItem.DropTarget>

  <TreeViewItem.Expanded>
    <summary>
      一个逻辑值，确定树形视图项是展开还是折叠。
    </summary>
    <value>一个逻辑值，确定树形视图项是展开还是折叠。</value>
  </TreeViewItem.Expanded>

  <TreeViewItem.FirstChild>
    <summary>
      树形视图项的第一个子项。
    </summary>
    <value>树形视图项的第一个子项。</value>
  </TreeViewItem.FirstChild>

  <TreeViewItem.Focused>
    <summary>
      一个逻辑值，如果树形视图项被聚焦，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果树形视图项被聚焦，则为 TRUE。</value>
  </TreeViewItem.Focused>

  <TreeViewItem.ImageIndex>
    <summary>
      一个数字值，表示树形视图项在图像列表中的图像的索引。
    </summary>
    <value>一个数字值，表示树形视图项在图像列表中的图像的索引。</value>
  </TreeViewItem.ImageIndex>

  <TreeViewItem.NameSym>
    <summary>
      树形视图项的符号名称。
    </summary>
    <value>树形视图项的符号名称。</value>
  </TreeViewItem.NameSym>

  <TreeViewItem.NextSibling>
    <summary>
      树形视图项的下一个兄弟项。
    </summary>
    <value>树形视图项的下一个兄弟项。</value>
  </TreeViewItem.NextSibling>

  <TreeViewItem.OverlayImageIndex>
    <summary>
      一个数字值，表示树形视图项在图像列表中的覆盖图像的索引。覆盖图像是绘制在项的主图像上的图像。树形视图最多可以有四个覆盖图像，因此这个值可以在1到4的范围内。
    </summary>
    <value>一个数字值，表示树形视图项在图像列表中的覆盖图像的索引。覆盖图像是绘制在项的主图像上的图像。树形视图最多可以有四个覆盖图像，因此这个值可以在1到4的范围内。</value>
  </TreeViewItem.OverlayImageIndex>

  <TreeViewItem.Parent>
    <summary>
      树形视图项的父 TreeView 对象。
    </summary>
    <value>树形视图项的父 TreeView 对象。</value>
  </TreeViewItem.Parent>

  <TreeViewItem.PreviousSibling>
    <summary>
      树形视图项的前一个兄弟项。
    </summary>
    <value>树形视图项的前一个兄弟项。</value>
  </TreeViewItem.PreviousSibling>

  <TreeViewItem.Selected>
    <summary>
      一个逻辑值，如果树形视图项被选中，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果树形视图项被选中，则为 TRUE。</value>
  </TreeViewItem.Selected>

  <TreeViewItem.SelectedImageIndex>
    <summary>
      一个数字值，表示树形视图项在图像列表中的选中图像的索引。选中图像是在项被选中时显示的，代替项的正常图像。
    </summary>
    <value>一个数字值，表示树形视图项在图像列表中的选中图像的索引。选中图像是在项被选中时显示的，代替项的正常图像。</value>
  </TreeViewItem.SelectedImageIndex>

  <TreeViewItem.StateImageIndex>
    <summary>
      一个数字值，表示树形视图项在状态图像列表中的状态图像的索引。状态图像是在项的主图像旁边绘制的图像。
    </summary>
    <value>一个数字值，表示树形视图项在状态图像列表中的状态图像的索引。状态图像是在项的主图像旁边绘制的图像。</value>
  </TreeViewItem.StateImageIndex>

  <TreeViewItem.TextValue>
    <summary>
      树形视图项的文本值。
    </summary>
    <value>树形视图项的文本值。</value>
  </TreeViewItem.TextValue>

  <TreeViewItem.TreeViewControl>
    <summary>
      标识当前树形视图项链接的 TreeView 控件的 TreeView 对象。
    </summary>
    <value>标识当前树形视图项链接的 TreeView 控件的 TreeView 对象。</value>
  </TreeViewItem.TreeViewControl>

  <TreeViewItem.Value>
    <summary>
      与树形视图项关联的通常值。
    </summary>
    <value>与树形视图项关联的通常值。</value>
  </TreeViewItem.Value>

  <TreeViewKeyEvent>
    <summary>
      提供关于树形视图键事件的信息，当树形视图控件具有输入焦点时按键时生成。
    </summary>
    <remarks>
      当树形视图控件具有输入焦点时按键时，树形视图控件会生成此事件。此事件打包的信息包括按下的键的虚拟键码。
    </remarks>
  </TreeViewKeyEvent>

  <TreeViewKeyEvent.ctor>
    <inheritdoc />
  </TreeViewKeyEvent.ctor>

  <TreeViewKeyEvent.KeyCode>
    <summary>
      被按下的键的虚拟键码。
    </summary>
    <value>被按下的键的虚拟键码。</value>
  </TreeViewKeyEvent.KeyCode>

  <TreeViewMouseEvent>
    <summary>
      提供关于树形视图鼠标事件的信息，当在树形视图控件中单击或双击鼠标按钮时生成。
    </summary>
    <remarks>
      当在树形视图控件中发生鼠标单击或双击时，会生成此事件。事件的属性不仅确定事件在物理上发生的位置，还确定事件与控件中的项的关系。
    </remarks>
  </TreeViewMouseEvent>

  <TreeViewMouseEvent.ctor>
    <summary>构造一个 TreeViewMouseEvent 对象。</summary>
    <param name="oControlNotifyEvent">事件发生时的 ControlNotifyEvent。</param>
  </TreeViewMouseEvent.ctor>

  <TreeViewMouseEvent.ButtonID>
    <summary>
      代表哪个鼠标按钮被单击的常量。该值可以是 BUTTONLEFT 或 BUTTONRIGHT。
    </summary>
    <value>代表哪个鼠标按钮被单击的常量。该值可以是 BUTTONLEFT 或 BUTTONRIGHT。</value>
  </TreeViewMouseEvent.ButtonID>

  <TreeViewMouseEvent.IsLeftButton>
    <summary>
      一个逻辑值，如果这是一个左键事件，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果这是一个左键事件，则为 TRUE。</value>
  </TreeViewMouseEvent.IsLeftButton>

  <TreeViewMouseEvent.IsRightButton>
    <summary>
      一个逻辑值，如果这是一个右键事件，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果这是一个右键事件，则为 TRUE。</value>
  </TreeViewMouseEvent.IsRightButton>

  <TreeViewMouseEvent.PointAboveClientArea>
    <summary>
      一个逻辑值，如果单击发生在树形视图控件的客户区域上方，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在树形视图控件的客户区域上方，则为 TRUE。</value>
  </TreeViewMouseEvent.PointAboveClientArea>

  <TreeViewMouseEvent.PointBelowClientArea>
    <summary>
      一个逻辑值，如果单击发生在树形视图控件的客户区域下方，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在树形视图控件的客户区域下方，则为 TRUE。</value>
  </TreeViewMouseEvent.PointBelowClientArea>

  <TreeViewMouseEvent.PointLeftOfClientArea>
    <summary>
      一个逻辑值，如果单击发生在树形视图控件的客户区域左侧，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在树形视图控件的客户区域左侧，则为 TRUE。</value>
  </TreeViewMouseEvent.PointLeftOfClientArea>

  <TreeViewMouseEvent.PointNowhere>
    <summary>
      一个逻辑值，如果单击发生在树形视图控件内部但不在任何项上，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在树形视图控件内部但不在任何项上，则为 TRUE。</value>
  </TreeViewMouseEvent.PointNowhere>

  <TreeViewMouseEvent.PointOnItem>
    <summary>
      一个逻辑值，如果单击发生在树形视图控件中的一个树形视图项上，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在树形视图控件中的一个树形视图项上，则为 TRUE。</value>
  </TreeViewMouseEvent.PointOnItem>

  <TreeViewMouseEvent.PointOnItemButton>
    <summary>
      一个逻辑值，如果单击发生在树形视图控件中的一个树形视图项的按钮上，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在树形视图控件中的一个树形视图项的按钮上，则为 TRUE。</value>
  </TreeViewMouseEvent.PointOnItemButton>

  <TreeViewMouseEvent.PointOnItemImage>
    <summary>
      一个逻辑值，如果单击发生在树形视图控件中的一个树形视图项的图像上，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在树形视图控件中的一个树形视图项的图像上，则为 TRUE。</value>
  </TreeViewMouseEvent.PointOnItemImage>

  <TreeViewMouseEvent.PointOnItemIndent>
    <summary>
      一个逻辑值，如果单击发生在树形视图控件中的一个树形视图项的缩进区域上，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在树形视图控件中的一个树形视图项的缩进区域上，则为 TRUE。</value>
  </TreeViewMouseEvent.PointOnItemIndent>

  <TreeViewMouseEvent.PointOnItemLabel>
    <summary>
      一个逻辑值，如果单击发生在树形视图控件中的一个树形视图项的标签上，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在树形视图控件中的一个树形视图项的标签上，则为 TRUE。</value>
  </TreeViewMouseEvent.PointOnItemLabel>

  <TreeViewMouseEvent.PointOnItemRight>
    <summary>
      一个逻辑值，如果单击发生在树形视图控件中的一个树形视图项的右侧，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在树形视图控件中的一个树形视图项的右侧，则为 TRUE。</value>
  </TreeViewMouseEvent.PointOnItemRight>

  <TreeViewMouseEvent.PointOnItemStateImage>
    <summary>
      一个逻辑值，如果单击发生在树形视图控件中的一个树形视图项的状态图像上，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在树形视图控件中的一个树形视图项的状态图像上，则为 TRUE。</value>
  </TreeViewMouseEvent.PointOnItemStateImage>

  <TreeViewMouseEvent.PointRightOfClientArea>
    <summary>
      一个逻辑值，如果单击发生在树形视图控件的客户区域右侧，则为 TRUE。
    </summary>
    <value>一个逻辑值，如果单击发生在树形视图控件的客户区域右侧，则为 TRUE。</value>
  </TreeViewMouseEvent.PointRightOfClientArea>

  <TreeViewMouseEvent.Position>
    <summary>
      一个描述单击发生位置的 Point 对象，以树形视图控件坐标表示。
    </summary>
    <value>一个描述单击发生位置的 Point 对象，以树形视图控件坐标表示。</value>
  </TreeViewMouseEvent.Position>

  <TreeViewMouseEvent.TreeViewItem>
    <summary>
      如果鼠标单击发生在项上，则为鼠标单击的 TreeViewItem 对象；否则，为 null 对象。
    </summary>
    <value>如果鼠标单击发生在项上，则为鼠标单击的 TreeViewItem 对象；否则，为 null 对象。</value>
  </TreeViewMouseEvent.TreeViewItem>

  <TreeViewSelectionEvent>
    <summary>
      提供关于树形视图选择事件的信息，当树形视图控件中的当前选择已更改或即将更改时生成。
    </summary>
    <remarks>
      当树形视图控件中的当前选择已更改或即将更改时，树形视图控件会生成此事件。事件中打包的信息包括导致选择更改的原因，以及哪个项获得了选择焦点，哪个项失去了选择焦点。
    </remarks>
  </TreeViewSelectionEvent>

  <TreeViewSelectionEvent.ctor>
    <inheritdoc />
  </TreeViewSelectionEvent.ctor>

  <TreeViewSelectionEvent.KeyBoardAction>
    <summary>
      一个逻辑值，指示选择更改是否是由键盘按键引起的。
    </summary>
    <value>一个逻辑值，指示选择更改是否是由键盘按键引起的。</value>
  </TreeViewSelectionEvent.KeyBoardAction>

  <TreeViewSelectionEvent.MouseAction>
    <summary>
      一个逻辑值，指示选择更改是否是由鼠标点击引起的。
    </summary>
    <value>一个逻辑值，指示选择更改是否是由鼠标点击引起的。</value>
  </TreeViewSelectionEvent.MouseAction>

  <TreeViewSelectionEvent.NewTreeViewItem>
    <summary>
      作为此事件结果而选择的 TreeViewItem 对象。
    </summary>
    <value>作为此事件结果而选择的 TreeViewItem 对象。</value>
  </TreeViewSelectionEvent.NewTreeViewItem>

  <TreeViewSelectionEvent.OldTreeViewItem>
    <summary>
      此事件发生之前被选择的 TreeViewItem 对象。
    </summary>
    <value>此事件发生之前被选择的 TreeViewItem 对象。</value>
  </TreeViewSelectionEvent.OldTreeViewItem>

  <TreeViewSelectionEvent.SelectionChanged>
    <summary>
      一个逻辑值，指示选择是否已更改。
    </summary>
    <value>一个逻辑值，指示选择是否已更改。</value>
  </TreeViewSelectionEvent.SelectionChanged>

  <TreeViewSelectionEvent.SelectionChanging>
    <summary>
      一个逻辑值，指示选择是否即将更改。
    </summary>
    <value>一个逻辑值，指示选择是否即将更改。</value>
  </TreeViewSelectionEvent.SelectionChanging>

  <TreeViewSelectionEvent.UnknownAction>
    <summary>
      一个逻辑值，指示选择更改是否是由未知来源引起的。
    </summary>
    <value>一个逻辑值，指示选择更改是否是由未知来源引起的。</value>
  </TreeViewSelectionEvent.UnknownAction>

  <VerticalScrollBar>
    <summary>
      创建一个垂直滚动条。
    </summary>
    <remarks> 
      在X#中有两种类型的垂直滚动条：常规的(使用 CLASS VerticalScrollBar 创建)和窗口的(使用 AppWindow:EnableVerticalScroll() 方法创建)。<br />
      这两种类型都有一个所有者窗口，并且可以使用 Window:VerticalScroll() 方法进行操作。
      但是，窗口的垂直滚动条不同之处在于，它会自动出现在其所有者窗口的画布区域右侧，并且根据其所有者窗口的大小自动调整大小。<br />
      垂直滚动条允许用户通过移动滑块位置，单击滚动条两端的按钮以按指定的 ScrollBar:UnitSize 更改数字，
      或者在滚动条的内部单击以按指定的 ScrollBar:BlockSize 更改数字。<br />
      允许的最小和最大数字值由与滚动条关联的 Range 对象的 Min 和 Max 值指示。ScrollBar:Value 访问表示当前选择的数字值。
      滚动条可以绑定到服务器中的数字字段。
      <note type="tip">默认情况下，Window:VerticalScroll() 会更新滚动条中的滑块位置；如果需要，可以通过使用自己的实现来更改这一点。</note>
        在 Windows 中，垂直滚动条等同于具有 SBS_VERT 样式的滚动条。这些通常在资源实体中指定如下： 
        <code language="X#">
          RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 120
          STYLE WS_POPUP | WS_DLGFRAME
          BEGIN
              CONTROL "", IDS_RED, "scrollbar", SBS_VERT, 10, 16, 24, 100
          END
        </code>
    </remarks>
  </VerticalScrollBar>

  <VerticalScrollBar.ctor>
    <summary>
      构造一个垂直滚动条。
    </summary>
    <param name="oOwner">拥有垂直滚动条的窗口。</param>
    <param name="xID">垂直滚动条的唯一ID，介于1和8000之间。</param>
    <param name="oPoint">垂直滚动条在画布坐标中的原点。</param>
    <param name="oDimension">垂直滚动条在画布坐标中的尺寸。</param>
    <param name="oResourceID">垂直滚动条的资源ID。</param>
  </VerticalScrollBar.ctor>

  <VerticalScrollBar.Destroy>
    <summary>
      提供一种方法来取消实例化 VerticalScrollBar 对象。
    </summary>
    <remarks>
      当不再需要 VerticalScrollBar 对象时，可以使用此方法。VerticalScrollBar:Destroy() 取消实例化 VerticalScrollBar 对象，并允许您关闭和释放对象打开或创建的任何资源，而不必等待垃圾收集器。
    </remarks>
  </VerticalScrollBar.Destroy>

  <VerticalSelectionSlider>
    <summary>
      创建一个垂直选择滑块控件。
    </summary>
    <remarks>
      一个垂直选择滑块是一个包含滑块、可选的刻度线和选择条的控件。用户可以使用鼠标或方向键移动垂直选择滑块的滑块。
    </remarks>
  </VerticalSelectionSlider>

  <VerticalSelectionSlider.ctor>
    <summary>
      构造一个垂直选择滑块。
    </summary>
    <param name="oOwner">拥有垂直选择滑块的窗口。</param>
    <param name="xID">垂直选择滑块的唯一ID，介于1和8000之间。</param>
    <param name="nResourceID">垂直选择滑块的资源ID。</param>
    <param name="oPoint">垂直选择滑块在画布坐标中的原点。</param>
    <param name="oDimension">垂直选择滑块在画布坐标中的尺寸。</param>
  </VerticalSelectionSlider.ctor>

  <VerticalSlider>
    <summary>
      创建一个垂直滑块控件。
    </summary>
    <remarks>
      一个垂直滑块是一个包含滑块和可选的刻度线的控件。用户可以使用鼠标或方向键移动垂直滑块的滑块。
    </remarks>
  </VerticalSlider>

  <VerticalSlider.ctor>
    <summary>
      构造一个垂直滑块。
    </summary>
    <param name="oOwner">拥有垂直滑块的窗口。</param>
    <param name="xID">垂直滑块的唯一ID，介于1和8000之间。</param>
    <param name="nResourceID">垂直滑块的资源ID。</param>
    <param name="oPoint">垂直滑块在画布坐标中的原点。</param>
    <param name="oDimension">垂直滑块在画布坐标中的尺寸。</param>
  </VerticalSlider.ctor>

  <VerticalSpinner>
    <summary>
      创建一个带有垂直箭头按钮的微调器。
    </summary>
    <remarks>
      一个垂直微调器是一对上下指向的箭头按钮，可以单击以更改一个值，例如在另一个控件中显示的数字。垂直微调器可以独立存在，但通常与另一个控件一起使用，称为客户端。
    </remarks>
  </VerticalSpinner>

  <VerticalSpinner.ctor>
    <summary>
      构造一个垂直微调器。
    </summary>
    <param name="oOwner">拥有垂直微调器的窗口。</param>
    <param name="xID">垂直微调器的唯一ID，介于1和8000之间。</param>
    <param name="nResourceID">垂直微调器的资源ID。</param>
    <param name="oPoint">垂直微调器在画布坐标中的原点。</param>
    <param name="oDimension">垂直微调器在画布坐标中的尺寸。</param>
    <param name="kStyle">垂直微调器的样式。</param>
  </VerticalSpinner.ctor>

  <VObject>
    <summary>
      定义所有其他 GUI 类都基于的类。
    </summary>
    <example> 
      当您为这个类定义一个方法(如下面的示例)或属性，它就会对所有其他 GUI 类可用： 
      <code language="X#">
        METHOD Save() CLASS VObject
            ...
            RETURN lSuccess
      </code>
    </example>
  </VObject>

  <VObject.ctor>
    <summary>
      构造一个 VObject 对象。
    </summary>
  </VObject.ctor>

  <VObject.Destroy>
    <summary>
      释放为对象及其派生对象分配的内存资源。
    </summary>
  </VObject.Destroy>

  <WarningBox>
    <summary>
      创建一个警告消息框。
    </summary>
    <remarks>
      一个警告消息框是一个窗口，它在标题栏中显示用户定义的标题，警告的文本和一个警告图标。这些框通常用于警告用户可能的错误或不良情况。例如，您可能会显示一个警告框来确认对特定文件的删除请求(如“您确定要删除COMMAND.COM吗？”)。
      <note
        type="tip">警告消息框是应用程序模态的；因此，用户必须在继续应用程序之前确认它。当警告消息框关闭时，焦点返回到其所有者窗口。</note>
    </remarks>
  </WarningBox>

  <WarningBox.ctor>
    <summary>
      创建一个警告消息框。
    </summary>
    <param name="uParent">拥有警告消息框的窗口。如果省略，所有者是桌面，警告消息框是应用程序模态的(即，应用程序被挂起，直到用户确认警告消息框)。</param>
    <param name="uCaption">
      要在警告消息框的标题栏中显示的文本或
      包含警告消息框的标题和描述的超链接。如果省略，默认标题为'警告'，默认描述为'警告...'。
    </param>
    <param name="uText">当显示警告消息框时要打印的信息。如果省略，默认为 NULL_STRING。</param>
  </WarningBox.ctor>

  <WCError>
    <exclude />
  </WCError>

  <WCError.ctor>
    <exclude />
  </WCError.ctor>

  <Win32.ClosePrinter>
    <exclude />
  </Win32.ClosePrinter>

  <Win32.DeviceCapabilities>
    <exclude />
  </Win32.DeviceCapabilities>

  <Win32.DocumentProperties>
    <exclude />
  </Win32.DocumentProperties>

  <Win32.OpenPrinter>
    <exclude />
  </Win32.OpenPrinter>

  <WinDLLVersion>
    <summary>
      从 DLL 中获取版本信息。
    </summary>
    <remarks>
      这将从 DLL 中获取版本信息。DLL 必须包含一个名为 DllGetVersion 的函数，该函数填充一个 _WINDLLVERSIONINFO结构。
      这种确定 DLL 版本的约定被 Windows DLL(如Shell32.DLL)遵循。
    </remarks>
  </WinDLLVersion>

  <WinDLLVersion.ctor>
    <summary>
      构造一个 WinDLLVersion 对象。
    </summary>
    <param name="cDLLName">DLL 的名称，作为字符串。</param>
    <remarks>
      这将在传递的 DLL 周围创建一个 WinDLLVersion 对象。
      DLL 必须包含一个名为 DllGetVersion 的函数，该函数填充一个 _WINDLLVERSIONINFO 结构。
      这种确定 DLL 版本的约定被 Windows DLL(如Shell32.DLL)遵循。
    </remarks>
  </WinDLLVersion.ctor>

  <WinDLLVersion.DLL>
    <summary>
      表示 DLL 的名称的字符串。
    </summary>
    <value>表示 DLL 的名称的字符串。</value>
  </WinDLLVersion.DLL>

  <WinDLLVersion.IsWinNT>
    <summary>
      一个逻辑值，关于 DLL 是为哪个平台开发的。
    </summary>
    <value>一个逻辑值，关于 DLL 是为哪个平台开发的。</value>
  </WinDLLVersion.IsWinNT>

  <Window>
    <summary>
      提供所有 X# 窗口都是基于的基类。
    </summary>
    <remarks>
      窗口是每个 GUI 的中心。GUI 窗口可以以两种方式来思考：
      作为在屏幕上的视觉表示的呈现对象
      作为处理用户交互的事件处理程序
      每种类型的事件都会发送到 Window 类的适当事件处理程序。Window 类的事件处理程序方法是系统的默认事件处理程序。通过在子类中重写这些方法，您可以改变从 Window 类提供的默认行为到您的派生窗口的行为。
    </remarks>
  </Window>

  <Window.ctor>
    <summary>
      构造一个 Window 对象。
    </summary>
    <param name="oOwner">拥有这个窗口的窗口。</param>
    <remarks>
      Window Editor 生成的窗口初始化代码在 Init() 方法的开始和结束时调用 PreInit() 和 PostInit()。默认实现返回 NIL。PreInit()/PostInit() 的实现会导致定制的初始化代码，
      这些代码不会被 Window Editor 的代码生成覆盖。
    </remarks>
  </Window.ctor>

  <Window.Accelerator>
    <summary>
      与这个窗口关联的加速键表。
    </summary>
    <value>与这个窗口关联的加速键表。</value>
  </Window.Accelerator>

  <Window.Activate>
    <summary>
      提供一个在这个窗口被激活时调用的方法。
    </summary>
    <param name="oEvent">描述哪个窗口被激活的事件。</param>
    <seealso cref="T:VO.Event" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      Activate()事件发生在窗口的生命周期开始或在窗口被停用后重新激活(例如，通过鼠标点击)。新激活的窗口接收输入焦点。
      您应该在这个事件处理程序方法中创建和显示光标(如果需要)。任何具有自己的 Activate() 和 Deactivate() 事件处理程序的子类应该始终调用其所有者的处理程序。这确保了标题栏根据需要高亮或变暗。
      </remarks>
    <seealso cref="T:VO.Event" />
  </Window.Activate>

  <Window.AddTrayIcon>
    <summary>
      添加与窗口关联的托盘图标。
    </summary>
    <param name="oTrayIcon">要添加到托盘的图标对象。</param>
    <param name="dwID">图标的唯一ID(介于1和8000之间)。</param>
    <param name="sToolTip">要为这个图标显示的工具提示字符串。</param>
    <remarks>
      <note type="tip">
        如果加载了 Shell 版本5或更高，工具提示将支持使用 CRLF 进行换行。
        在旧版本的 Shell 上，CRLF 会自动替换为一个空格。
      </note>
    </remarks>
  </Window.AddTrayIcon>

  <Window.Animate>
    <exclude />
  </Window.Animate>

  <Window.AnimationStart>
    <summary>
      提供一个在动画控件开始播放时调用的方法。
    </summary>
    <param name="oControlEvent">描述哪个动画控件开始播放的 ControlEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <seealso cref="T:VO.ControlEvent" />
  </Window.AnimationStart>

  <Window.AnimationStop>
    <summary>
      提供一个在动画控件结束播放时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oControlEvent">描述哪个动画控件结束播放的 ControlEvent 对象。</param>
    <seealso cref="T:VO.ControlEvent" />
  </Window.AnimationStop>

  <Window.AppCommand>
    <summary>
      提供一个在 AppCommand 事件发生时调用的方法。
    </summary>
    <param name="oACEvent">描述发起的事件的 AppCommandEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 这个事件必须在应用程序中被重写，并且必须返回 TRUE 以完成处理。 </remarks>
    <seealso cref="T:VO.AppCommandEvent" />
  </Window.AppCommand>

  <Window.Automated>
    <summary>
      一个逻辑值，确定是否要将窗口对象公开为 OLE 自动化服务器。这是 RegisterOLEAutomationObject() 函数的一个方便的快捷方式。当窗口被销毁时，UnRegisterOLEAutomationObject() 会自动调用。
    </summary>
    <value>
      一个逻辑值，确定是否要将窗口对象公开为 OLE 自动化服务器。这是 RegisterOLEAutomationObject() 函数的一个方便的快捷方式。当窗口被销毁时，UnRegisterOLEAutomationObject() 会自动调用。</value>
  </Window.Automated>

  <Window.Background>
    <summary>
      当前由这个窗口使用的背景画刷。
    </summary>
    <remarks> 
      当前由这个窗口使用的背景画刷。
      一个窗口的背景画刷被 CanvasErase() 使用，并在处理 Expose 事件时使用。分配一个新的背景画刷直到窗口(或窗口的一部分)被重绘之前没有效果。如果一个窗口部分被覆盖，然后完全暴露，只有窗口的覆盖部分被重绘，只有那部分得到新的背景。
      这个相关的示例将改变一个应用程序的主窗口的背景颜色，通常会在主 Initialize() 方法中发生： 
      <code language="X#">
        oWin:oColour := Color{164,255,164}
        // app background set to light green
        oWin:ShellWithColourOnly()
      </code>
    </remarks>
    <value>
      当前由这个窗口使用的背景画刷。
    </value>
  </Window.Background>

  <Window.ButtonClick>
    <summary>
      提供一个在鼠标点击了复选框、按钮或单选按钮时调用的方法。
    </summary>
    <param name="oControlEvent">描述哪个按钮被点击的 ControlEvent 对象。</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      按钮点击事件(单选、复选和按钮)被传播到窗口的所有者，方式与 MenuEvents 相同。有关命令事件传播的深入讨论，请参阅程序员指南。
      当用户点击单选按钮时，您必须提供代码来打开(并关闭所有其他单选按钮)一个单选按钮。类似地，当单击复选框时，您必须确保反转复选框的状态。 
    </remarks>
    <example> 
      这是对各种按钮点击做出响应的典型示例： 
      <code language="X#">
        METHOD ButtonClick(oControlEvent) CLASS TeamInfo
            LOCAL oControl AS Control
            LOCAL sSym AS SYMBOL

            oControl := IIf(oControlEvent == NULL_OBJECT, NULL_OBJECT, oControlEvent:Control)
            SUPER:ButtonClick(oControlEvent)
            //Put your changes here
            sSym := oControl:nameSym

            DO CASE
                CASE sSym == #cbHasSponsor // a checkbox
                    IF SELF:oDCcbHasSponsor:checked
                        SELF:oDCsleSponsorName:enable()
                    ELSE
                        SELF:oDCsleSponsorName:TextValue := SPACE(25)
                        SELF:oDCsleSponsorName:disable()
                    ENDIF
                CASE sSym == #rbRecreational .or. sSym == #rbCompetition
                    // radio buttons
                    // Do something in here
            ENDCASE
      </code>
    </example>
  </Window.ButtonClick>

  <Window.ButtonDoubleClick>
    <summary>
      提供一个在双击复选框、按钮或单选按钮时调用的方法。
    </summary>
    <param name="oControlEvent"> 描述哪个按钮被双击的 <seealso cref="T:VO.ControlEvent">ControlEvent</seealso>
      对象。
    </param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <seealso cref="T:VO.ControlEvent" />
  </Window.ButtonDoubleClick>

  <Window.CanvasArea>
    <summary>
      表示当前窗口画布区域的边界框。
    </summary>
    <value>表示当前窗口画布区域的边界框。</value>
  </Window.CanvasArea>

  <Window.CanvasErase>
    <summary>
      擦除当前窗口的画布区域，并使用背景画刷或系统的默认背景颜色重新绘制它。
    </summary>
  </Window.CanvasErase>

  <Window.Caption>
    <summary>
      表示标题(窗口标题栏中的文本)的字符串。这个方法也可以用来改变窗口的标题。
    </summary>
    <value>表示标题(窗口标题栏中的文本)的字符串。这个方法也可以用来改变窗口的标题。</value>
  </Window.Caption>

  <Window.Center>
    <summary>将窗口居中于其所有者，如果所有者是桌面，则将窗口居中于桌面。</summary>
    <returns>NIL</returns>
  </Window.Center>

  <Window.Close>
    <summary>
      当窗口即将关闭时调用的方法。
    </summary>
    <param name="oEvent">一个空事件，用于维护所有事件处理程序的协议，即每个事件处理程序都有一个事件作为其参数。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 请注意，当调用 EndDialog() 或 EndWindow() 方法时，此方法会自动被调用。 </remarks>
    <seealso cref="T:VO.Event" />
  </Window.Close>

  <Window.ComboBoxExEndEdit>
    <summary>
      当 ComboBoxEx 控件发送'EndEdit'通知消息时调用的回调方法
    </summary>
    <param name="oComboBoxExEndEditEvent">一个包含事件信息的对象</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      当 ComboBoxEx 控件发送 CBEN_ENDEDIT 消息时，提供一个在 ComboBoxEx 控件发送'EndEdit'通知消息时调用的方法。 </remarks>
    <seealso cref="T:VO.ComboBoxExEndEditEvent" />
  </Window.ComboBoxExEndEdit>

  <Window.ComboBoxExNotify>
    <summary>
      当 ComboBoxEx 控件发送通知消息时调用的回调方法
    </summary>
    <param name="oControlNotifyEvent">一个包含事件信息的对象</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      当 ComboBoxEx 控件发送以下通知消息之一时，提供一个在 ComboBoxEx 控件发送通知消息时调用的方法。 CBEN_INSERTITEM, CBEN_DELETEITEM,
      CBEN_DRAGBEGIN, CBEN_BEGINEDIT 和 CBEN_ENDEDIT
      目前，此方法仅包含对 CBEN_ENDEDIT 消息的消息处理程序，该处理程序调用 Window:ComboBoxExEndEdit() 方法。
      如果您重写此方法以处理其他消息，请不要忘记在否则部分调用 SUPER: ComboBoxExNotify(oControlNotifyEvent)。 </remarks>
    <seealso cref="T:VO.ControlNotifyEvent" />
  </Window.ComboBoxExNotify>

  <Window.ContextMenu>
    <summary>
      一个表示窗口或窗口控件的本地弹出菜单的菜单对象。
    </summary>
    <value>一个表示窗口或窗口控件的本地弹出菜单的菜单对象。</value>
  </Window.ContextMenu>

  <Window.ControlNotify>
    <summary>
      当控件向其父窗口发送通知时调用的方法。
    </summary>
    <param name="oControlNotifyEvent">描述哪个控件发送了通知的 ControlNotifyEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 这是一个通用方法，当一个常见控件向其父窗口发送通知时，就会调用它。
      在许多情况下，除了在响应通知时调用此方法外，还会调用一个更具体的方法。 如果此方法未处理的通知代码，则在此方法可用时，将这些通知代码发送到 Control:ParentNotify() 方法。 </remarks>
    <seealso cref="T:VO.ControlNotifyEvent" />
  </Window.ControlNotify>

  <Window.DateTimeSelectionChanged>
    <summary>
      当 DateTimePicker 选择发生变化时调用的方法。
    </summary>
    <param name="oDateTimeSelectionEvent">描述哪个控件发送了通知的 DateTimeSelectionEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <seealso cref="T:VO.DateTimeSelectionEvent" />
  </Window.DateTimeSelectionChanged>

  <Window.DeActivate>
    <summary>
      当此窗口被停用时调用的方法。
    </summary>
    <param name="oEvent">一个空事件，用于维护所有事件处理程序的协议，即每个事件处理程序都有一个事件作为其参数。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      通常，当另一个应用程序或窗口被激活时，会调用此事件处理程序。如果 Window:MouseTrapOn() 保持打开状态，那么 MouseEvent 事件将无法传递给其他应用程序或窗口。 </remarks>
    <seealso cref="T:VO.Event" />
  </Window.DeActivate>

  <Window.DeactivateAllOLEObjects>
    <exclude />
  </Window.DeactivateAllOLEObjects>

  <Window.Default>
    <summary>调用窗口的默认窗口过程，并为对象设置 EventReturnValue。</summary>
    <param name="oEvent">为控件发生的事件。</param>
    <returns>NIL</returns>
    <seealso cref="T:VO.Event" />
  </Window.Default>

  <Window.DeleteTrayIcon>
    <exclude />
  </Window.DeleteTrayIcon>

  <Window.Destroy>
    <summary>
      释放为窗口及其派生对象分配的内存资源。
    </summary>
    <remarks>
      这个方法立即释放为应用程序显式创建的 Window 对象分配的资源。Window:Destroy() 也会处理为派生类分配的资源，并按照必要的顺序(例如，子窗口在父窗口之前被销毁，
      对话框窗口和 MDI shell窗口也会被处理)进行释放。
    </remarks>
    <returns>NIL</returns>
  </Window.Destroy>

  <Window.Disable>
    <summary>
      禁用此窗口(直到随后调用Enable())。
    </summary>
    <remarks>
      禁用的窗口将不再接收鼠标和键盘事件。
    </remarks>
    <returns>NIL</returns>
  </Window.Disable>

  <Window.Dispatch>
    <summary>
      当窗口具有焦点时，为系统内部事件提供分发器；将各种事件路由到它们适当的事件处理程序。
    </summary>
    <param name="oEvent">要处理的事件。</param>
    <seealso cref="T:VO.Event" />
    <returns>
      一个表示事件处理程序的数字值，用于处理事件。这通常是 EventReturnValue 字段的值。
    </returns>
    <remarks> 
      窗口会不断地接收来自用户和系统的事件。每个窗口只会接收与其相关的事件。<br />
      对于每个生成的事件，会发生两件事： <br />
      1.事件根据触发事件的操作转换为特定的 Event 对象(例如，ExposeEvent 或 MouseEvent)。 <br />
      2. 调用适当的事件处理程序，并将这个类型化的Event对象传递给它。 
      <note type="tip"> 
        如果您想为底层窗口过程设置特定的返回值，您必须更改窗口对象的 EventReturnValue 变量。<br />
        如果您想处理其他事件(例如，定时器事件)，您需要编写自己的 Dispatch() 方法。 在编写自定义的 Dispatch() 方法时，应遵循以下准则： 
        1. 对于正在使用的操作类型，应该对事件类型进行子类化。 <br />
        2. 在派生对象中添加一个事件处理程序函数。(当接收到事件时，应该调用此事件处理程序。) <br />
        3. 通常，此事件处理程序的实现应该调用 Default()。这保持了与基类相同的行为，但也允许其他类为您的新事件类型提供有用的事件处理程序，从而允许您为其他类提供一个框架。
        在这些情况下，应该在否则部分调用基类的 Dispatch()方法，以处理未被自定义分发器处理的接收到的事件。 <br />
        例如： 
        <code language="X#">
          RETURN SUPER:Dispatch(&lt;oEvent&gt;)
        </code>
      </note> 
        现在，您可以在自己的窗口类上编写一个 DispatchUnknown( oEvent )方法，以处理窗口未处理的消息。 
        当存在此消息时，它将在 Window 类中的 Dispatch() 方法内部自动调用。 
      <example>
        <code language="X#">
          METHOD DispatchUnknown(oEvent) CLASS MyCustomWindow
              // Your code
              // If you need the default window
              // procedure call SELF:Default(oEvent)
              // Assign the event return value to SELF:EventReturnValue,
              // the default value is 0l.
              SELF:EventReturnValue := 1l
        </code>
      </example>
    </remarks>
  </Window.Dispatch>

  <Window.DragDropClient>
    <summary>
      当调用 Window:EnableDragDropClient(TRUE) 时创建的 DragDropClient 对象。
    </summary>
    <value>当调用 Window:EnableDragDropClient(TRUE) 时创建的 DragDropClient 对象。</value>
  </Window.DragDropClient>

  <Window.DragDropServer>
    <summary>
      当调用 Window:EnableDragDropServer(TRUE) 时创建的 DragDropServer 对象。
    </summary>
    <value>当调用 Window:EnableDragDropServer(TRUE) 时创建的 DragDropServer 对象。</value>
  </Window.DragDropServer>

  <Window.DragImageList>
    <summary>
      用于拖放操作的 ImageList 对象。
    </summary>
    <value>用于拖放操作的 ImageList 对象。</value>
  </Window.DragImageList>

  <Window.Draw>
    <summary>
      在这个窗口上显示一个 Draw 对象。
    </summary>
    <param name="oDrawObject">要绘制的对象，或要绘制的对象数组。</param>
    <remarks>
      通过将设备上下文或演示空间放入 Draw 对象，然后调用 Draw 对象的 Draw() 方法，可以在窗口上绘制 Draw 对象。这是在窗口上绘制 Draw 对象的唯一有效方式。
    </remarks>
    <seealso cref="T:VO.DrawObject" />
  </Window.Draw>

  <Window.DrawBackground>
    <summary>
      绘制窗口的背景。
    </summary>
    <param name="hdc">设备上下文的句柄。</param>
    <param name="oWindow">
      要绘制的窗口。
      oWindow 对象通常与 SELF 相同，除非 SELF 是 DataWindow。在这种情况下，oWindow 应该是 oSurface(__FormDialogWindow)对象。
      在 DataWindow 中，只有在 oWindow == oSurface 时，才应该绘制背景，否则是多余的。
    </param>
    <remarks>
      如果您自己绘制背景，应该返回 TRUE，否则返回 FALSE。
    </remarks>
  </Window.DrawBackground>

  <Window.Drop>
    <summary>
      从拖动事件中检索有关加载的信息，并对选择中的每个文件进行操作。
    </summary>
    <param name="oDragEvent">确定鼠标位置(在画布坐标中)，以及拖放加载中的文件的数量和名称的 DragEvent。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      当用户在客户区域放开鼠标按钮以放下加载时，系统会分派此方法。这个方法是必需的，以正确处理拖放。它从拖动事件中检索有关加载的信息，并对选择中的每个文件进行操作。 </remarks>
    <seealso cref="T:VO.DragEvent" />
  </Window.Drop>

  <Window.EditChange>
    <summary>
      当编辑控件中的文本发生变化时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oControlEvent">描述哪个编辑控件发生了变化的 ControlEvent 对象。</param>
    <seealso cref="T:VO.ControlEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.EditChange>

  <Window.EditFocusChange>
    <summary>
      当输入焦点从编辑控件转移到其他控件，或者从其他控件转移到编辑控件时调用的方法。
    </summary>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
    <param name="oEditFocusChangeEvent">
      标识生成 EditFocusChangeEvent 对象的编辑控件，以及它是否刚刚获得或失去了键盘焦点的 EditFocusChangeEvent 对象。</param>
    <seealso cref="T:VO.EditFocusChangeEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      如果Window:EditFocusChange() 用于验证编辑控件(并在无效时返回焦点到它)，则不应该在其他控件获得焦点之前调用 Control:SetFocus()。
      在包含许多编辑控件的复杂对话框窗口中，当焦点正在改变时，抓取编辑控件的文本是有意义的，这样，如果需要，其他控件就可以使用它来更新。
      请参阅 ButtonClick() 方法，了解在这个方法中使用类似语法的示例。请注意，这个方法不会传递任何按钮控件，只有 SingleLineEdit 和 MultiLineEdit 控件。如果要控制 Combobox 的选择，那么请使用 ListBoxSelect() 回调方法。
    </remarks>
  </Window.EditFocusChange>

  <Window.EditScroll>
    <summary>
      当编辑控件滚动时调用的方法。
    </summary>
    <param name="oControlEvent">标识调用事件处理程序的编辑控件的 ControlEvent 对象。</param>
    <seealso cref="T:VO.ControlEvent" />
    <returns>此方法调用Window.Default()，并返回 Window.Default() 的结果</returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 这种类型的事件通常发生在用户在编辑控件中输入的字符数超过它可以显示的字符数时。
      在Windows中，您必须在编辑控件的资源实体描述中设置标志，以允许滚动： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>ES_AUTOHSCROLL</term>
          <description>水平自动滚动文本</description>
        </item>
        <item>
          <term>ES_AUTOVSCROLL</term>
          <description>垂直自动滚动文本</description>
        </item>
        <item>
          <term>WS_HSCROLL</term>
          <description>在编辑控件上显示水平滚动条</description>
        </item>
        <item>
          <term>WS_VSCROLL</term>
          <description>在编辑控件上显示垂直滚动条</description>
        </item>
      </list>
    </remarks>
  </Window.EditScroll>

  <Window.Enable>
    <summary>
      启用先前禁用的窗口。
    </summary>
    <remarks>
      启用窗口允许它接收鼠标和键盘事件。默认情况下，窗口在禁用之前都是启用的，因此除非之前调用了 Window:Disable() 方法，否则不需要调用 Window:Enable() 方法。
    </remarks>
    <returns>NIL</returns>
  </Window.Enable>

  <Window.EnableCloseBox>
    <summary>
      启用或禁用窗口的关闭按钮(X)。
    </summary>
    <param name="uValue">一个逻辑值，指示关闭框是否应该启用(TRUE)或禁用(FALSE)。</param>
    <returns>NIL</returns>
  </Window.EnableCloseBox>

  <Window.EnableDragDropClient>
    <summary>
      允许“可拖动”窗口被拖放到这个窗口上。
    </summary>
    <param name="lEnable">TRUE 启用窗口作为拖放客户端。FALSE 不允许这种行为。如果省略，缺省值为 TRUE。</param>
    <returns>NIL</returns>
  </Window.EnableDragDropClient>

  <Window.EnableDragDropClient>
    <inheritdoc />
    <param name="lSurfaceOnly">当传递逻辑值 TRUE 时，只有 DataWindow 的表面被激活。</param>
  </Window.EnableDragDropClient>

  <Window.EnableDragDropServer>
    <summary>
      允许这个窗口被拖放到具有拖放功能的窗口上。
    </summary>
    <param name="lEnable">TRUE 启用窗口作为拖放服务器。FALSE 不允许这种行为。如果省略，缺省值为 TRUE。</param>
    <returns>NIL</returns>
  </Window.EnableDragDropServer>

  <Window.EnableHelp>
    <summary>
      启用或禁用窗口及其子窗口的帮助。
    </summary>
    <param name="lEnable">TRUE 启用帮助；FALSE 禁用帮助。如果未指定，缺省值为 TRUE。</param>
    <param name="oHelpDisplay">一个指定要使用的帮助文件的 HelpDisplay 对象。</param>
    <remarks>
      此方法由 Window:HelpDisplay() 调用。
    </remarks>
    <returns>NIL</returns>
  </Window.EnableHelp>

  <Window.EnableHelpButton>
    <summary>
      在窗口标题栏中启用帮助按钮。
    </summary>
    <remarks>
      在窗口标题栏中启用帮助按钮。只有在标题栏上没有最大化或最小化按钮时，这才有效。这在 DialogWindow 中是推荐的。
      只有在你用 lWin32Processing 为 TRUE 创建了 HelpDisplay{} 对象时，才推荐使用这个。
    </remarks>
    <returns>NIL</returns>
  </Window.EnableHelpButton>

  <Window.EnableHelpCursor>
    <summary>
      将鼠标光标更改为带有指针的问号。
    </summary>
    <remarks>
      将鼠标光标更改为带有指针的问号。如果用户然后点击一个控件，控件将接收到一个帮助请求消息。
      只有在你用 lWin32Processing 为 TRUE 创建了 HelpDisplay{} 对象时，才推荐使用这个。
    </remarks>
    <returns>NIL</returns>
  </Window.EnableHelpCursor>

  <Window.EnableThemeDialogTexture>
    <summary>
      启用或禁用对话框窗口的背景的视觉样式。
    </summary>
    <param name="dwStyle"> 
      要设置的样式。 
      <list type="table">
        <listheader>
          <term>样式</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>
            ETDT_ENABLE
          </term>
          <description>启用对话框窗口背景纹理。纹理由视觉样式定义。</description>
        </item>
        <item>
          <term>
            ETDT_ENABLETAB
          </term>
          <description>
            启用对话框窗口背景纹理。纹理是由视觉样式定义的Tab控件纹理。此标志等同于(ETDT_ENABLE | ETDT_USETABTEXTURE)。
          </description>
        </item>
        <item>
          <term>
            ETDT_DISABLE
          </term>
          <description>禁用背景纹理。</description>
        </item>
        <item>
          <term>
            ETDT_USETABTEXTURE
          </term>
          <description>使用Tab控件纹理作为对话框窗口的背景纹理。</description>
        </item>
      </list>
    </param>
    <remarks>
      此方法允许在 WinXP 及更高版本中启用和禁用背景主题。
    </remarks>
  </Window.EnableThemeDialogTexture>

  <Window.EnableToolTips>
    <summary>
      启用或禁用窗口的工具提示。请注意，为 Control:ToolTipText 分配一个值会自动启用父窗口上的工具提示显示。
    </summary>
    <param name="lEnable">逻辑值，指示工具提示是否应该启用(TRUE)或禁用(FALSE)。如果省略，缺省值为 TRUE。</param>
    <returns>
      TRUE，如果工具提示已启用；FALSE，如果工具提示已禁用。
    </returns>
  </Window.EnableToolTips>

  <Window.EventReturnValue>
    <summary>此字段存储对窗口的 Windows Procedure 调用的结果。</summary>
  </Window.EventReturnValue>

  <Window.Expose>
    <summary>
      提供一个在窗口的一部分需要重新绘制时调用的方法。
    </summary>
    <param name="oExposeEvent">描述窗口的哪个区域需要重新绘制的 ExposeEvent 对象。</param>
    <seealso cref="T:VO.ExposeEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      这是最重要的事件处理程序之一。 当窗口： 
      <list type="bullet">
        <item>被另一个窗口部分遮盖</item>
        <item>首次显示</item>
        <item>增大尺寸</item>
        <item>从最小化状态恢复</item>
        <item>窗口应该保留足够的信息，以便重新绘制屏幕，就像它是(或应该是)的那样。</item>
      </list>
      通过调用 Repaint() 或 Update() 也会触发 ExposeEvent；在 Expose() 中不应该调用 Repaint() 或 Update()。 
    </remarks>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.Expose>

  <Window.FocusChange>
    <summary>
      提供一个在输入焦点从当前窗口转移到另一个窗口(或反之)时调用的方法。
    </summary>
    <param name="oFocusChangeEvent">标识焦点是获得还是失去的 FocusChangeEvent 对象。</param>
    <seealso cref="T:VO.FocusChangeEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      如果你的窗口使用光标，当焦点从当前窗口转移到另一个窗口时，你应该隐藏窗口的光标，然后当窗口再次获得焦点时，显示光标。
      这应该与 Window:Activate() 和 Window:Deactivate() 事件处理程序一起使用。
    </remarks>
    <example> 
      这个示例演示了 Window:FocusChange() 在获得焦点时在指定的光标位置显示光标。如果失去焦点，光标将被隐藏： 
      <code language="X#">
        METHOD FocusChange(oFocusChangeEvt) CLASS MyTopAppWindow
            IF oFocusChangeEvt:GotFocus // Gaining focus
                oMyCursor:Show()
                oMyCursor:Position := oMyCursorPos
            ELSE // Losing focus
                oMyCursorPos := oMyCursor:Position
                oMyCursor:Hide()
            ENDIF
      </code>
    </example>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.FocusChange>

  <Window.Font>
    <summary>
      当前由这个窗口使用的字体。这个字体由 TextObject:TextPrint() 方法使用。
    </summary>
    <value>当前由这个窗口使用的字体。这个字体由 TextObject:TextPrint() 方法使用。</value>
  </Window.Font>

  <Window.Foreground>
    <summary>
      当前由这个窗口使用的前景画刷。
    </summary>
    <value>当前由这个窗口使用的前景画刷。</value>
  </Window.Foreground>

  <Window.GetAllChildren>
    <summary>
      获取窗口的所有X#子对象的数组。
    </summary>
    <returns>
      窗口的所有X#子对象的数组。这个数组可能包含窗口对象和控件对象。请注意，没有对应的X#对象的控件(例如，
      GeneratedCode属性设置为“No”的ListBox控件)不包含在返回的数组中。
    </returns>
  </Window.GetAllChildren>

  <Window.GetExStyle>
    <summary>
      获取窗口的 Ex 样式。
    </summary>
    <returns>
      一个数字值，表示为窗口启用的 X# 样式常量或 Windows API 样式常量。
    </returns>
  </Window.GetExStyle>

  <Window.GetStyle>
    <summary>
      获取窗口的样式。
    </summary>
    <returns>
      一个数字值，表示为窗口启用的 X# 样式常量或 Windows API 样式常量。
    </returns>
  </Window.GetStyle>

  <Window.Handle>
    <summary>
      返回窗口的句柄。
    </summary>
    <param name="nHandleType"> 所需的句柄类型。0是唯一支持的选项，如果省略 <paramref name="nHandle" />，则默认为0。 </param>
    <returns>
      一个句柄，描述底层系统对象的窗口。
    </returns>
    <remarks>
      此方法提供窗口的句柄，然后可以通过 Windows API 调用使用。
    </remarks>
  </Window.Handle>

  <Window.HasExStyle>
    <summary>检查窗口是否已设置 Ex 样式值</summary>
    <param name="kStyle">要检查的样式</param>
    <returns>当 Ex 样式已设置时为 TRUE。否则为 FALSE。</returns>
  </Window.HasExStyle>

  <Window.HasStyle>
    <summary>检查窗口是否已设置样式值</summary>
    <param name="kStyle">要检查的样式</param>
    <returns>当样式已设置时为 TRUE。否则为 FALSE。</returns>
  </Window.HasStyle>

  <Window.HelpDisplay>
    <summary>
      当前由这个窗口使用的帮助显示对象。这个帮助显示对象提供了要显示的帮助文件和这个窗口之间的连接。
    </summary>
    <value>当前由这个窗口使用的帮助显示对象。这个帮助显示对象提供了要显示的帮助文件和这个窗口之间的连接。</value>
    <example> 
      下面的示例处理默认的帮助菜单命令： 
      <code language="X#">
        CLASS MyWindow INHERIT TopAppWindow
            METHOD Init() CLASS MyWindow
                SUPER:Init()
                SELF:HelpDisplay := HelpDisplay{"mywind.hlp"}

            METHOD MenuCommand(oMCE) CLASS MyWindow
                LOCAL nItemID := oMCE:ItemID

                DO CASE
                    CASE nItemID = IDM_MENU_HELP_INDEX_ID
                        SELF:HelpDisplay:Show("HelpIndex")
                    CASE nItemID = IDM_MENU_HELP_USINGHELP_ID
                        SELF:HelpDisplay:Show("HelpOnHelp")
                    OTHERWISE
                        SUPER:MenuCommand(oMCE)
                ENDCASE
      </code>
    </example>
  </Window.HelpDisplay>

  <Window.HelpRequest>
    <summary>
      当用户使用可用的上下文敏感帮助机制之一从应用程序请求帮助时，提供一个被调用的方法。
    </summary>
    <param name="oHelpRequestEvent">描述正在请求帮助的项目的 HelpRequestEvent 对象。</param>
    <seealso cref="T:VO.HelpRequestEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      只有在当前窗口(或其所有者之一)的帮助机制已启用时，才会调用此事件处理程序。通过将 HelpDisplay 对象分配给窗口的 HelpDisplay 属性来启用帮助机制。
      此事件处理程序的默认实现是在生成 HelpRequestEvent 时显示与控件、菜单命令或具有焦点的窗口区域相关联的帮助主题。这是通过使用 HelpDisplay:Show(&lt;cKeyword&gt;) 来实现的，其中 &lt;cKeyword&gt; 是 HyperLabel:HelpContext 属性或在没有超级标签可用的情况下由此事件处理程序生成的默认关键字。
      如果没有为项目生成超级标签，生成的关键字如下：
      HELPCONTROL 请求生成的关键字是 Control_xxxx，其中 xxxx 是控件的数字ID，以十进制表示。例如，OK 按钮可能会生成 Control_101 的关键字。
      HELPMENU 请求生成的关键字是 Menu_xxxx，其中 xxxx 是菜单命令的“清理”文本。清理文本已删除所有前导和尾随空格以及和字符(&amp;)。此外，所有空格序列都被替换为一个下划线，并且字符串在第一个制表符处被截断。
      例如，对于菜单命令： Save &amp;As\tF3 生成的关键字是 Menu_Save_As HELPWINDOW请求根据具有焦点的窗口区域生成下表中列出的关键字之一： 
      <list type="table">
        <listheader>
          <term>关键字</term>
          <description>窗口区域</description>
        </listheader>
        <item>
          <term>
            Window_Border
          </term>
          <description>边框</description>
        </item>
        <item>
          <term>
            Window_Caption
          </term>
          <description>标题栏</description>
        </item>
        <item>
          <term>
            Window_MaxBox
          </term>
          <description>最大化按钮</description>
        </item>
        <item>
          <term>
            Window_MinBox
          </term>
          <description>最小化按钮</description>
        </item>
        <item>
          <term>
            Window_SysMenuBox
          </term>
          <description>系统菜单按钮</description>
        </item>
        <item>
          <term>
            Window_Unknown
          </term>
          <description>在此表中未明确标识的窗口区域的任何区域</description>
        </item>
        <item>
          <term>
            Window_WindowCanvas
          </term>
          <description>画布区域</description>
        </item>
      </list>
      <note type="tip">
        如果生成的关键字是 Window_Unknown，HelpRequest() 的默认行为是显示 HelpDisplay 中定义的 Contents 主题(即，HelpDisplay:Show("HelpIndex"))。
      </note>
      如果收到 HELPWINDOW 请求，同时 Window:HelpContext 已定义，Window:HelpRequest() 将使用 HelpContext 属性，而不管具有焦点的窗口区域是什么。
      有关如何为应用程序的在线帮助系统编程的更多信息，请参阅程序员指南中的“GUI类”章节。 
    </remarks>
  </Window.HelpRequest>

  <Window.Hide>
    <summary>
      隐藏此窗口，使其不可见。
    </summary>
    <remarks>
      窗口保持隐藏，直到调用 Window:Show() 方法。此方法不用于关闭窗口。使用 Window:Hide() 使窗口从视图中消失，但仍可重新打开。
    </remarks>
  </Window.Hide>

  <Window.HorizontalScroll>
    <summary>
      当水平滚动条滚动时，提供一个被调用的方法。
    </summary>
    <param name="oScrollEvent">描述滚动类型和新位置的 ScrollEvent 对象。</param>
    <seealso cref="T:VO.ScrollEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      此事件处理程序的默认行为是更新滚动条的滑块位置；可以通过自己的事件处理程序实现来更改这一点。此事件处理程序仅适用于 HorizontalScrollBar 和 WindowHorizontalScrollBar 对象。如果应用程序有垂直滚动条，请使用 WindowVerticalScrollBar 事件处理程序。
      </remarks>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.HorizontalScroll>

  <Window.HorizontalSlide>
    <summary>
      当水平滑坆被鼠标或键盘拖动时，提供一个被调用的方法。
    </summary>
    <param name="oSliderEvent">描述哪个水平滑坆的滑块被拖动的 SliderEvent 对象。</param>
    <seealso cref="T:VO.SliderEvent" />
    <returns>此方法调用Window.Default()，并返回 Window.Default() 的结果</returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </Window.HorizontalSlide>

  <Window.HorizontalSpin>
    <summary>
      当水平微调器被旋转时，提供一个被调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      此事件处理程序的默认行为是更新微调器的位置；可以通过自己的事件处理程序实现来更改这一点。此事件处理程序仅适用于 HorizontalScrollBar 和 WindowHorizontalScrollBar 对象。如果应用程序有垂直滚动条，请使用 WindowVerticalScrollBar 事件处理程序。
      </remarks>
    <param name="oSpinnerEvent">描述哪个水平微调器被旋转的 SpinnerEvent 对象。</param>
    <seealso cref="T:VO.SpinnerEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.HorizontalSpin>

  <Window.HyperLabel>
    <summary>
      连接到此窗口的超级标签。
    </summary>
    <value>连接到此窗口的超级标签。</value>
    <remarks> 
      从超级标签，您可以检索有关窗口的其他信息，例如： 
      <code language="X#">
        cCaption      := oWindow:HyperLabel:Caption
        cDescription  := oWindow:HyperLabel:Description
        cHelpContext  := oWindow:HyperLabel:HelpContext
      </code>
      超级标签也可以用于将超级标签对象分配给窗口，尽管这通常在实例化期间完成。 
    </remarks>
  </Window.HyperLabel>

  <Window.Icon>
    <summary>
      用于此窗口的大图标对象。
    </summary>
    <value>用于此窗口的大图标对象。</value>
  </Window.Icon>

  <Window.IconSm>
    <summary>
      用于此窗口的小图标对象。
    </summary>
    <value>用于此窗口的小图标对象。</value>
  </Window.IconSm>

  <Window.IsEnabled>
    <summary>
      报告此窗口当前是否已启用。
    </summary>
    <returns>
      如果窗口已启用，则为 TRUE；否则为 FALSE。
    </returns>
  </Window.IsEnabled>

  <Window.IsIconic>
    <summary>
      报告此窗口当前是否已最小化。
    </summary>
    <returns>
      如果窗口已最小化，则为 TRUE；否则为 FALSE。
    </returns>
  </Window.IsIconic>

  <Window.IsVisible>
    <summary>
      报告此窗口当前是否可见(完全或部分)或隐藏。
    </summary>
    <returns>
      如果窗口可见，则为 TRUE；否则为 FALSE。
    </returns>
  </Window.IsVisible>

  <Window.IsZoomed>
    <summary>
      报告此窗口当前是否已最大化(填满整个屏幕)。
    </summary>
    <returns>
      如果窗口已最大化，则为 TRUE；否则为 FALSE。
    </returns>
  </Window.IsZoomed>

  <Window.KeyDown>
    <summary>
      当键盘上的键被按下时，提供一个被调用的方法。
    </summary>
    <param name="oKeyEvent">描述按下了哪个键的 KeyEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      只有当窗口具有输入焦点时，才会调用此事件处理程序。此外，由于存在编辑控件，它很少被覆盖。如果为对话框窗口覆盖，应调用所有者处理程序(这确保在 Windows 中仍然可以在控件之间切换)。 </remarks>
  </Window.KeyDown>

  <Window.KeyUp>
    <summary>
      当键盘上的键被释放时，提供一个被调用的方法。
    </summary>
    <param name="oKeyEvent">描述释放了哪个键的 KeyEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 只有当窗口具有输入焦点时，才会调用此事件处理程序。 </remarks>
  </Window.KeyUp>

  <Window.LineTo>
    <summary>
      在此窗口上绘制一条线(使用当前笔)从当前笔位置到指定点。
    </summary>
    <param name="oPoint">
      线应该结束的位置，以画布坐标表示。或者是一个点数组，以画布坐标表示，线应该结束在这种情况下，Window:LineTo() 就像一个折线方法。
    </param>
    <seealso cref="T:VO.Point" />
    <remarks>
      当前笔位置更新为线的结束位置(由&lt;oPoint&gt;或&lt;aoPoint&gt;指定)。
    </remarks>
  </Window.LineTo>

  <Window.ListBoxClick>
    <summary>
      当此窗口拥有的列表框中的项目被双击时，提供一个被调用的方法。
    </summary>
    <param name="oControlEvent">描述双击的哪个列表框中包含了项目的 ControlEvent 对象。</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.ListBoxClick>

  <Window.ListBoxSelect>
    <summary>
      当此窗口拥有的列表框中的项目被单击时，提供一个被调用的方法。
    </summary>
    <param name="oControlEvent">描述哪个列表框中包含了项目的 ControlEvent 对象。</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <example> 
      下面是使用此方法的典型示例： 
      <code language="X#">
        METHOD ListBoxSelect(oControlEvent) CLASS TeamInfo
            LOCAL oControl AS Control
            LOCAL sSym AS SYMBOL

            oControl := IIf(oControlEvent == NULL_OBJECT, NULL_OBJECT, ;
            oControlEvent:Control)
            SUPER:ListBoxSelect(oControlEvent)
            //Put your changes here
            sSym := oControl:nameSym

            IF sSym == #cbxTeamNumbers
                IF SELF:cLastTeamNr != SELF:oDCcbxTeamNumbers:Value
                    SELF:cLastTeamNr := SELF:oDCcbxTeamNumbers:Value
                    SELF:BreakDownTeamNumber( SELF:oDCcbxTeamNumbers:Value )
                ENDIF
            ENDIF
      </code>
    </example>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.ListBoxSelect>

  <Window.ListViewColumnClick>
    <summary>
      当在列表视图控件中单击列表视图列标题时，提供一个被调用的方法。
    </summary>
    <param name="oListViewColumnClickEvent">描述单击哪个列表视图列标题的哪个列表视图控件的 ListViewColumnClickEvent 对象。</param>
    <seealso cref="T:VO.ListViewColumnClickEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.ListViewColumnClick>

  <Window.ListViewItemChanged>
    <summary>
      当列表视图项目发生变化时，提供一个被调用的方法。
    </summary>
    <param name="oListViewItemEvent">描述哪个列表视图项目发生了变化的 ListViewItemEvent 对象。</param>
    <seealso cref="T:VO.ListViewItemEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 
      ListViewItemChanged 事件处理程序通知列表视图控件的父窗口，项目已更改。 
    </remarks>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.ListViewItemChanged>

  <Window.ListViewItemChanging>
    <summary>
      当列表视图项目的状态即将更改时，提供一个被调用的方法。
    </summary>
    <param name="oListViewItemEvent">描述哪个列表视图项目即将更改的 ListViewItemEvent 对象。</param>
    <seealso cref="T:VO.ListViewItemEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      ListViewItemChanging 事件处理程序通知列表视图控件的父窗口，项目即将更改。 
    </remarks>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.ListViewItemChanging>

  <Window.ListViewItemDelete>
    <summary>
      当在列表视图控件中删除列表视图项目时，提供一个被调用的方法。
    </summary>
    <param name="oListViewDeleteEvent">描述哪个列表视图控件中删除了哪个列表视图项目的 ListViewDeleteEvent 对象。</param>
    <seealso cref="T:VO.ListViewDeleteEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.ListViewItemDelete>

  <Window.ListViewItemDrag>
    <summary>
      当在列表视图控件中拖动列表视图项目时，提供一个被调用的方法。
    </summary>
    <param name="oListViewDragEvent">描述哪个列表视图控件中拖动了哪个列表视图项目的 ListViewDragEvent 对象。</param>
    <seealso cref="T:VO.ListViewDragEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      此方法的默认实现是检查列表视图控件是否已启用拖放，构建和定位拖动图像，并在图像上调用 DragEnter() 方法。 
    </remarks>
  </Window.ListViewItemDrag>

  <Window.ListViewItemEdit>
    <summary>
      当在列表视图控件中编辑列表视图项目时，提供一个被调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oListViewEditEvent">描述哪个列表视图控件中的哪个列表视图项目被编辑的 ListViewEditEvent 对象。</param>
    <seealso cref="T:VO.ListViewEditEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.ListViewItemEdit>

  <Window.ListViewKeyDown>
    <summary>
      当在列表视图控件中按键时，提供一个被调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oListViewKeyEvent">描述哪个列表视图控件接收到按键的 ListViewKeyEvent 对象。</param>
    <seealso cref="T:VO.ListViewKeyEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.ListViewKeyDown>

  <Window.ListViewMouseButtonDoubleClick>
    <summary>
      当在列表视图控件中双击鼠标按钮时，提供一个被调用的方法。这可以用于调用所选项目的“编辑屏幕”，打印报告等。请参阅 ListViewMouseButtonDown() 方法的示例语法。
    </summary>
    <param name="oListViewMouseEvent">描述哪个列表视图控件接收到鼠标按钮双击的 ListViewMouseEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <seealso cref="T:VO.ListViewMouseEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.ListViewMouseButtonDoubleClick>

  <Window.ListViewMouseButtonDown>
    <summary>
      当在列表视图控件中单击鼠标按钮时，提供一个被调用的方法。
    </summary>
    <param name="oListViewMouseEvent">描述哪个列表视图控件接收到鼠标按钮单击的 ListViewMouseEvent 对象。</param>
    <seealso cref="T:VO.ListViewMouseEvent" />
    <returns>此方法调用Window.Default()，并返回 Window.Default() 的结果</returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <example>
      ListViewMouseButtonDown 用法的典型示例。请注意，在示例中，项目的记录号存储在 LVI 的“value”中，而项目的文本存储在“text”实体中。显然，这只有在 ListView 中使用字符串类型列存储记录号时才有效。
      <code language="X#">
        METHOD ListViewMouseButtonDown(oListViewMouseEvent) CLASS CoachesBrowse
            LOCAL sSym AS SYMBOL
            LOCAL oLVI AS ListViewItem

            SUPER:ListViewMouseButtonDown(oListViewMouseEvent)
            //Put your changes here
            oLVI := oListViewMouseEvent:ListViewItem
            sSym := oListViewMouseEvent:NameSym

            DO CASE
                CASE sSym == #lvCoaches
                    IF oLVI != NULL_OBJECT
                        IF oListViewMouseEvent:PointOnItem
                            SELF:iCoachRec := oLVI:GetValue( #cCoachName )
                            SELF:cSelCoach := oLVI:GetText( #cCoachName )
                            SELF:oDbCoaches:GoTo( SELF:iCoachRec )
                        ENDIF
                    ENDIF
            ENDCASE
      </code>
    </example>
  </Window.ListViewMouseButtonDown>

  <Window.Menu>
    <summary>
      当前由这个窗口使用的菜单。
    </summary>
    <value>当前由这个窗口使用的菜单。</value>
  </Window.Menu>

  <Window.MenuCommand>
    <summary>
      当在这个窗口拥有的菜单上选择一个项目时，提供一个被调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oMenuCommandEvent">描述哪个菜单和菜单命令(通过项目的ID)生成了事件的 MenuCommandEvent 对象。</param>
    <seealso cref="T:VO.MenuCommandEvent" />
  </Window.MenuCommand>

  <Window.MenuInit>
    <summary>
      当由这个窗口拥有的弹出菜单即将“弹出”时，提供一个被调用的方法。
    </summary>
    <param name="oMenuInitEvent">描述即将弹出的菜单的 MenuInitEvent 对象。</param>
    <seealso cref="T:VO.MenuInitEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 这个事件处理程序可以用来初始化菜单命令，检查项目等。 
    </remarks>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.MenuInit>

  <Window.MenuSelect>
    <summary>
      当在这个窗口拥有的菜单上选择一个项目时，提供一个被调用的方法。
    </summary>
    <param name="oMenuSelectEvent">描述哪个菜单和菜单命令(通过项目的ID)生成了事件的 MenuSelectEvent 对象。</param>
    <seealso cref="T:VO.MenuSelectEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      这个事件处理程序的一个用途是为用户当前的选择提供更广泛的帮助。选择菜单命令并不一定意味着它被调用，只是意味着菜单高亮条当前在这个项目上。 
    </remarks>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.MenuSelect>

  <Window.MinMaxInfo>
    <summary>
      当窗口的大小或位置即将改变(cf WM_GETMINMAXINFO in Win API)时，提供一个被调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      这个方法的默认实现设置 MinMaxInfoEvent 事件的 MinTrackSize 属性为窗口的最小大小。 </remarks>
    <param name="oMinMaxInfoEvent">描述最大化窗口的宽度、高度和位置以及窗口的最小和最大高度和宽度的 MinMaxInfoEvent 对象。</param>
    <seealso cref="T:VO.MinMaxInfoEvent" />
  </Window.MinMaxInfo>

  <Window.MinSize>
    <summary>窗口的最小大小</summary>
    <value>窗口的最小大小</value>
  </Window.MinSize>

  <Window.ModifyTrayIcon>
    <summary>
      修改与窗口关联的托盘图标。
    </summary>
    <param name="oTrayIcon">要添加到托盘的图标对象。</param>
    <param name="dwID">图标的唯一ID(介于1和8000之间)。</param>
    <param name="sToolTip">要为这个图标显示的工具提示字符串。</param>
    <remarks>
      <note type="tip">
        如果是现代版本的窗口，工具提示将支持使用CRLF进行换行。
        在旧版本中，CRLF会自动替换为一个空格。
      </note>
    </remarks>
  </Window.ModifyTrayIcon>

  <Window.MonthCalSelectionChanged>
    <summary>
      当月历控件的选择更改时，提供一个被调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="_oMonthCalSelectionEvent">描述选择的改变的 MonthCalSelectionEvent 对象。</param>
    <param name="oMonthCalSelectionEvent">描述选择的改变的 MonthCalSelectionEvent 对象。</param>
    <seealso cref="T:VO.MonthCalSelectionEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.MonthCalSelectionChanged>

  <Window.MouseButtonDoubleClick>
    <summary>
      当鼠标指针位于窗口上并且双击鼠标按钮时，提供一个被调用的方法。
    </summary>
    <param name="oMouseEvent">包含鼠标在按钮被双击时的状态信息的 MouseEvent 对象。</param>
    <seealso cref="T:VO.MouseEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      MouseButtonDoubleClick() 经常在 MouseButtonDown() 和 MouseButtonUp() 事件处理程序之间发生。 
    </remarks>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.MouseButtonDoubleClick>

  <Window.MouseButtonDown>
    <summary>
      当鼠标指针位于窗口上并且单击鼠标按钮时，提供一个被调用的方法。
    </summary>
    <param name="oMouseEvent">包含鼠标在按钮被单击时的状态信息的 MouseEvent 对象。</param>
    <seealso cref="T:VO.MouseEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      使用 Window:MouseTrapOn() 方法强制将在画布区域外生成的 MouseEvents 定向到这个窗口。 
    </remarks>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.MouseButtonDown>

  <Window.MouseButtonUp>
    <summary>
      当鼠标指针位于窗口上并且释放鼠标按钮时，提供一个被调用的方法。
    </summary>
    <param name="oMouseEvent">包含鼠标在按钮被释放时的状态信息的 MouseEvent 对象。</param>
    <seealso cref="T:VO.MouseEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      不要假设 Window:MouseButtonUp() 会立即在 Window:MouseButtonDown() 之后被调用。在这段时间内可能会生成其他 MouseEvents。
      在某些情况下，可能没有 Window:MouseButtonUp() 事件被定向到窗口对应的 Window:MouseButtonDown()。
      如果鼠标按钮在窗口上单击，但在鼠标移出窗口后释放，就可能发生这种情况。 使用 Window:MouseTrapOn() 将所有 MouseEvents 定向到这个窗口。<br />
      这个事件还会检测是否有 MouseDrag 正在活动，并结束拖动。 
    </remarks>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.MouseButtonUp>

  <Window.MouseDrag>
    <summary>
      当鼠标点击一个或多个按钮的鼠标移动时，提供一个被调用的方法。
    </summary>
    <param name="oMouseEvent">包含鼠标在拖动时的状态信息的 MouseEvent 对象。</param>
    <seealso cref="T:VO.MouseEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 这个方法将拖动图像移动到新位置。 
    </remarks>
  </Window.MouseDrag>

  <Window.MouseMove>
    <summary>
      当鼠标在窗口中移动时，提供一个被调用的方法。
    </summary>
    <param name="oMouseEvent">包含鼠标在移动时的状态信息的 MouseEvent 对象。</param>
    <seealso cref="T:VO.MouseEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" /> 这个事件在鼠标没有点击任何按钮时移动。 
    </remarks>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.MouseMove>

  <Window.MouseTrapOff>
    <summary>
      禁用窗口捕获在自身外部生成的 MouseEvents。
    </summary>
    <returns>NIL</returns>
  </Window.MouseTrapOff>

  <Window.MouseTrapOn>
    <summary>
      启用这个窗口捕获在自身外部生成的 MouseEvents。
    </summary>
    <remarks>
      在禁用或停用这个窗口之前，关闭鼠标捕获；否则，其他窗口无法接收 MouseEvents。
    </remarks>
    <returns>NIL</returns>
  </Window.MouseTrapOn>

  <Window.Move>
    <summary>
      当窗口移动(无论是由用户还是应用程序)时，提供一个被调用的方法。
    </summary>
    <param name="oMoveEvent">描述窗口移动的 MoveEvent 对象。</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <seealso cref="T:VO.MoveEvent" />
  </Window.Move>

  <Window.MoveTo>
    <summary>
      将当前笔移动到窗口的画布区域上的一个点。
    </summary>
    <param name="oPoint">笔的位置，以画布坐标表示。</param>
    <returns>
      一个点，表示笔的以前位置，以画布坐标表示。
    </returns>
    <remarks>
      在事件处理程序之间可能不会记住笔的位置。
    </remarks>
  </Window.MoveTo>

  <Window.Origin>
    <summary>
      表示这个窗口的新位置的点，以其所有者的画布坐标表示。
    </summary>
    <value>表示这个窗口的新位置的点，以其所有者的画布坐标表示。</value>
    <example> 
      下面的示例设置了一个窗口对象的原点： 
      <code language="X#">
        oWin:Origin := Point{nLeft,nBottom}
      </code>
    </example>
  </Window.Origin>

  <Window.Owner>
    <summary>
      窗口的所有者，可以是 Window 或 App 对象。
    </summary>
    <value>窗口的所有者，可以是 Window 或 App 对象。</value>
  </Window.Owner>

  <Window.OwnerAlignment>
    <summary>窗口的所有者对齐值，当窗口是另一个窗口上的子窗口时使用。</summary>
    <value>窗口的所有者对齐值</value>
  </Window.OwnerAlignment>

  <Window.PaintBackground>
    <summary>
      使用用户指定的画刷或背景对象为窗口绘制背景。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="hDC">必须绘制背景的窗口的设备上下文。</param>
    <returns>NIL</returns>
  </Window.PaintBackground>

  <Window.PaintBoundingBox>
    <summary>
      使用指定的绘制方法在窗口中绘制一个矩形区域。
    </summary>
    <param name="oBoundingBox">表示要绘制的窗口区域的边界框(组或字符框)，以画布坐标表示。</param>
    <param name="kPaintMode"> 表示如何绘制窗口区域的常量： <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>
            PAINTFILL
          </term>
          <description>使用当前选择的画刷填充整个矩形。这是默认值。</description>
        </item>
        <item>
          <term>
            PAINTFRAME
          </term>
          <description>使用当前选择的笔框架化整个矩形。</description>
        </item>
        <item>
          <term>PAINTINVERT </term>
          <description>反转整个矩形。</description>
        </item>
      </list>
    </param>
    <returns>NIL</returns>
  </Window.PaintBoundingBox>

  <Window.Pen>
    <summary>
      分配给窗口的笔，用于后续的线条和矩形绘制操作；在它是当前选择时，不应删除。
    </summary>
    <value>分配给窗口的笔，用于后续的线条和矩形绘制操作；在它是当前选择时，不应删除。</value>
  </Window.Pen>

  <Window.Pointer>
    <summary>
      窗口使用的指针，当鼠标进入窗口时用于表示鼠标。
    </summary>
    <value>窗口使用的指针，当鼠标进入窗口时用于表示鼠标。</value>
  </Window.Pointer>

  <Window.PostInit>
    <summary>
      为窗口实现自定义的初始化代码。
    </summary>
    <remarks> 
      此方法用于自定义窗口的初始化代码。 窗口编辑器的默认初始化代码不会覆盖自定义的初始化代码。 在 Init() 方法的末尾会自动生成对 PostInit() 的调用。
      您可以通过更改 CAVOWED.TPL 文件中的 [PostInitCall] 和 [PostInit] 部分来自定义代码生成。请注意，PreInit() 总是在 PostInit() 之前调用。<br />
      此类中 PostInit() 的默认实现为空。 
    </remarks>
  </Window.PostInit>

  <Window.PreInit>
    <summary>
      为窗口实现自定义的初始化代码。
    </summary>
    <remarks> 
      此方法用于自定义窗口的初始化代码。 窗口编辑器的默认初始化代码不会覆盖自定义的初始化代码。 在 Init() 方法的开始会自动生成对 PreInit() 的调用。
      您可以通过更改 CAVOWED.TPL 文件中的 [PreInitCall] 和 [PreInit] 部分来自定义代码生成。请注意，只有类变量可以在 PreInit() 方法中访问，直到 PostInit() 方法本身被调用。<br />
      此类中 PostInit() 的默认实现为空。 
      <note type="tip">
        在.NET中，通常不允许或建议在父构造函数调用之前运行类中的代码。
        窗口编辑器生成的代码在这样做(在 SUPER() 调用之前调用 PreInit())。
        我们建议您非常小心，不要触摸从父类继承的受保护实例变量，因为这些变量可能未初始化和/或您为它们分配的值可能在父类的构造函数中被覆盖。
      </note>
    </remarks>
  </Window.PreInit>

  <Window.PreMenuCommand>
    <summary>
      在正常 MenuCommand 方法被调用之前，处理菜单事件。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      此方法可以在窗口级别编写，以处理菜单命令。如果存在 window:PreMenuCommand( ) 方法，将调用该方法来处理菜单事件，而不是直接调用 MenuCommand( ) 方法。
      该方法必须返回一个逻辑值 – TRUE – 如果您已处理了MenuCommand。 FALSE – 如果您希望正常的 MenuCommand 也运行。 
    </remarks>
  </Window.PreMenuCommand>

  <Window.Print>
    <summary>
      打印窗口的内容。
    </summary>
    <param name="oDevice">将接收输出的 PrintingDevice 对象。如果省略，将使用默认打印机驱动程序。</param>
    <seealso cref="T:VO.PrintingDevice" />
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>此方法的默认实现创建窗口表面的位图，并将其发送到默认打印机。</remarks>
  </Window.Print>

  <Window.QueryClose>
    <summary>
      在窗口关闭之前，提供一个被调用的方法，以确认应用程序是否真的想要关闭窗口。
    </summary>
    <param name="oEvent">一个空事件，用于维护所有事件处理程序都有一个事件作为参数的协议。</param>
    <seealso cref="T:VO.Event" />
    <returns>
      窗口类中的此方法总是返回 TRUE。
      如果您在子类中重写此方法，那么如果要关闭窗口，必须返回 TRUE；否则，返回 FALSE。
    </returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      当用户尝试通过从系统菜单选择 Close 菜单命令(或使用其他方法结束会话)来关闭应用程序时，系统会调用每个窗口的 QueryClose() 事件处理程序。 
      <note type="tip">
        如果在子类中重新实现此方法，建议您首先在方法中调用 SUPER:QueryClose()，以获取其默认行为。
      </note>
    </remarks>
    <example> 
      此示例显示一个消息框，以确认用户是否要退出应用程序。如果用户选择 YES，返回 TRUE(否则，返回 FALSE)。 
      <code language="X#">
        METHOD QueryClose(oEvent) CLASS TopAppWindow
            oTB := TextBox{SELF, "Quit", "Do you really want to quit?"}
            oTB:TYPE := BOXICONQUESTIONMARK + BUTTONYESNO

            IF (oTB:Show() = BOXREPLYYES)
                RETURN TRUE // Quit application.
            ELSE
                RETURN FALSE
                // Don't quit the application.
            END
      </code>
    </example>
  </Window.QueryClose>

  <Window.RegisterTimer>
    <summary>
      注册一个定时器方法，以在窗口上调用。
    </summary>
    <param name="nInterval">调用窗口的 Timer() 方法之间的时间间隔，以秒为单位。</param>
    <param name="lOneTime">逻辑值，指示定时器是只调用一次(TRUE)，还是多次(FALSE)。如果省略，将默认为 FALSE。</param>
  </Window.RegisterTimer>

  <Window.RePaint>
    <summary>
      发送一个 ExposeEvent 来重新绘制窗口的画布区域。
    </summary>
    <returns>NIL</returns>
  </Window.RePaint>

  <Window.RepaintBoundingBox>
    <summary>
      重新绘制窗口中的一个矩形区域。
    </summary>
    <param name="oBoundingBox">表示要重新绘制的窗口区域的边界框(组或字符框)，以画布坐标表示。</param>
    <remarks>
      在 Expose() 事件处理程序中应避免使用此方法。如果使用，确保应用程序不会陷入无限循环。
    </remarks>
    <returns>NIL</returns>
  </Window.RepaintBoundingBox>

  <Window.Resize>
    <summary>
      当窗口大小发生变化时，提供一个被调用的方法。
    </summary>
    <param name="oResizeEvent">描述窗口画布区域新尺寸的 ResizeEvent 对象。</param>
    <seealso cref="T:VO.ResizeEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      在 Window:Resize() 事件处理程序中，应谨慎使用 Window:Size，以避免进入无限循环。<br /> 
      如果窗口有一个工具栏，那么这个方法还会确保工具栏也被调整大小。 
    </remarks>
  </Window.Resize>

  <Window.RichEditProtected>
    <summary>
      当尝试在富文本编辑控件中修改受保护的文本时，提供一个被调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oRichEditProtectEvent">描述哪个富文本编辑控件接收到保护事件的 RichEditProtectEvent 对象。</param>
    <seealso cref="T:VO.RichEditProtectEvent" />
    <returns>此方法总是将 EventReturnValue 设置为1，并返回0</returns>
  </Window.RichEditProtected>

  <Window.RichEditSelectionChange>
    <summary>
      当富文本编辑控件中的当前选择发生变化时，提供一个被调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oRichEditSelectionEvent">描述哪个富文本编辑控件的当前选择发生了变化的 RichEditSelectionEvent 对象。</param>
    <seealso cref="T:VO.RichEditSelectionEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.RichEditSelectionChange>

  <Window.RichEditUndoLost>
    <summary>
      当富文本编辑控件的撤销状态无法维护时，提供一个被调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oControlNotifyEvent">描述哪个富文本编辑控件丢失了其撤销状态的 ControlNotifyEvent 对象。</param>
    <seealso cref="T:VO.ControlNotifyEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.RichEditUndoLost>

  <Window.Scroll>
    <summary>
      滚动窗口中的一个矩形区域，指定的方向和指定的数量，可选地在滚动时剪裁区域。
    </summary>
    <param name="oDimension">表示矩形滚动区域(相对于其原点)移动的量的维度。正宽度值向右滚动，负宽度值向左滚动。此外，正高度值向上滚动，负高度值向下滚动。</param>
    <param name="oBoundingBox">表示矩形窗口区域的边界框，以画布坐标表示。如果省略，将默认为屏幕的画布区域。</param>
    <param name="lClip">指示在滚动时是否剪裁矩形区域。TRUE 剪裁区域；FALSE 不剪裁。如果省略，将默认为 TRUE。</param>
    <remarks>
      剪裁区域是一个可以接收系统输出的区域。
    </remarks>
  </Window.Scroll>

  <Window.SetAlignStartSize>
    <summary>此方法用于注册窗口的开始大小，稍后用于调整具有 OwnerAlignment 属性设置的控件的大小。</summary>
    <param name="oSize">包含应存储的大小的维度对象。如果未传递此对象，方法将计算窗口的大小并将其存储以供将来参考。</param>
    <returns>NIL</returns>
  </Window.SetAlignStartSize>

  <Window.SetBackgroundBrush>
    <summary>
      设置用于绘制窗口的背景的背景画刷。
    </summary>
    <param name="dwNew">要使用的新画刷。默认值为 COLOR_3DSHADOW。</param>
    <returns>NIL</returns>
  </Window.SetBackgroundBrush>

  <Window.SetExStyle>
    <summary>
      设置窗口的扩展样式。
    </summary>
    <param name="dwSetStyle">要设置的扩展样式。</param>
    <param name="lEnable">逻辑值。TRUE 打开样式，FALSE 关闭样式。</param>
    <returns>窗口的新 ExStyle(通过获取现有样式并启用或禁用传递的样式值计算得到)。</returns>
  </Window.SetExStyle>

  <Window.SetFocus>
    <summary>
      将键盘焦点设置为此窗口。
    </summary>
  </Window.SetFocus>

  <Window.SetHandle>
    <summary>此方法允许设置或更改窗口的句柄。通常在创建窗口后立即执行此操作。</summary>
    <param name="hNewWnd">窗口的新句柄。</param>
    <returns>窗口的句柄。</returns>
    <remarks>如果不知道自己在做什么，请不要更改窗口句柄！</remarks>
  </Window.SetHandle>

  <Window.SetStyle>
    <summary>
      设置窗口的样式。
    </summary>
    <param name="dwSetStyle">要设置的 X# 样式常量或 Windows API 样式常量。</param>
    <param name="lEnable">逻辑值，指示样式是否应启用(TRUE)或禁用(FALSE)。如果省略，将默认为 TRUE。</param>
    <returns>
      <returns>窗口的新 Style(通过获取现有样式并启用或禁用传递的样式值计算得到)。</returns>
    </returns>
  </Window.SetStyle>

  <Window.Show>
    <summary>
      显示此窗口。
    </summary>
    <param name="kShowState">表示窗口如何显示的常量。有效值为：</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>
            SHOWCENTERED
          </term>
          <description>在其所有者窗口中居中显示窗口。如果所有者是桌面，窗口将在屏幕上居中显示。</description>
        </item>
        <item>
          <term>
            SHOWICONIZED
          </term>
          <description>最初将窗口显示为图标</description>
        </item>
        <item>
          <term>
            SHOWNORMAL
          </term>
          <description>
            在其所有者窗口中以所有者选择的大小显示窗口。如果所有者是桌面，窗口看起来可能很大，但可能不会填满整个桌面。如果需要，您可以使用 Window:Size 和 Window:Origin 精确控制窗口的大小。这是默认值。
          </description>
        </item>
        <item>
          <term>SHOWZOOMED</term>
          <description>
            在其所有者窗口中以其所有者允许的最大尺寸显示窗口。如果所有者是桌面，窗口将占据整个桌面。
          </description>
        </item>
      </list>
    </remarks>
    <returns>NIL</returns>
  </Window.Show>

  <Window.ShowBalloonTrayTip>
    <summary>
      在与此窗口关联的托盘图标上显示气泡提示。
    </summary>
    <param name="oTrayIcon">要在托盘中显示的图标。</param>
    <param name="dwID">图标的唯一ID(介于1和8000之间)。</param>
    <param name="sHeading">在气泡中显示的标题。此标题以粗体显示在文本上方。最多可以有63个字符。</param>
    <param name="sToolTip">在气泡中显示的文本。在 Shell 版本5及以上，最大大小为128个字符。在 Shell 版本5以下，最大为64个字符。</param>
    <param name="dwTimeOut">
      在用户未关闭气泡提示的情况下，显示气泡提示的时间长度。
      系统会强制执行最小和最大超时值。超时值太大的 dwTimeout 将被设置为最大值，太小的值将默认为最小值。
      这是以毫秒为单位的。
    </param>
    <param name="dwInfo"> 
      可以设置的标志，以在气泡提示中添加图标。 有效值为： 
      <list type="table">
        <listheader>
          <term>常量</term>
          <description>描述</description>
        </listheader>
        <item>
          <term>
            NIIF_ERROR
          </term>
          <description>错误图标。</description>
        </item>
        <item>
          <term>
            NIIF_INFO
          </term>
          <description>信息图标。</description>
        </item>
        <item>
          <term>
            NIIF_NONE
          </term>
          <description>无图标。</description>
        </item>
        <item>
          <term>
            NIIF_WARNING
          </term>
          <description>警告图标。</description>
        </item>
        <item>
          <term>
            NIIF_NOSOUND
          </term>
          <description>不播放关联的声音。</description>
        </item>
      </list>
    </param>
    <returns>调用 Shell_NotifyIcon() 的结果(参见 WIN32 API)</returns>
  </Window.ShowBalloonTrayTip>

  <Window.Size>
    <summary>
      表示此窗口大小的维度。
    </summary>
    <value>表示此窗口大小的维度。</value>
    <example> 以下示例设置窗口对象的大小： 
      <code language="X#">
        oWin:Size := Dimension{nWidth,nHeight}
      </code>
    </example>
  </Window.Size>

  <Window.SizeText>
    <summary>
      确定在当前字体上打印在窗口上所需的空间。
    </summary>
    <param name="cTextToSize">要打印的字符串。</param>
    <returns>
      表示使用当前字体在此窗口上打印字符串所需的空间的维度。
    </returns>
  </Window.SizeText>

  <Window.StatusMessage>
    <summary>
      这是一个空的方法，因为 Window 类没有状态栏。
    </summary>
    <param name="oHL">包含状态消息的超级标签(HyperLabel:Description)或状态消息的字符串。</param>
    <param name="ntype">
      表示在状态栏上显示的消息的类型和优先级的常量值。
      最高优先级的消息(MESSAGEMENU)始终优先于并替换低优先级的消息。有关更多信息，请参见备注部分的表格。
    </param>
    <returns>NIL</returns>
  </Window.StatusMessage>

  <Window.SysLinkSelect>
    <summary>
      当用户点击 SysLink 控件时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
    <param name="oSysLinkSelectEvent">描述用户点击的控件的 SysLinkSelectEvent 对象。</param>
    <seealso cref="T:VO.SysLinkSelectEvent" />
  </Window.SysLinkSelect>

  <Window.TabKeyDown>
    <summary>
      当在选项卡控件中按键时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oControlNotifyEvent">描述哪个选项卡控件接收到按键的 ControlNotifyEvent 对象。</param>
    <seealso cref="T:VO.ControlNotifyEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.TabKeyDown>

  <Window.TabSelect>
    <summary>
      当在选项卡控件中选择选项卡时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oControlNotifyEvent">描述哪个选项卡控件的选项卡被选择的 ControlNotifyEvent 对象。</param>
    <seealso cref="T:VO.ControlNotifyEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.TabSelect>

  <Window.TabSelectionChanging>
    <summary>
      当在选项卡控件中更改选项卡选择时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oControlNotifyEvent">描述哪个选项卡控件的选中选项卡正在更改的 ControlNotifyEvent 对象。</param>
    <seealso cref="T:VO.ControlNotifyEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.TabSelectionChanging>

  <Window.TextColor>
    <summary>
      使用笔对象并在此窗口中构建一个笔。
    </summary>
    <value>使用笔对象并在此窗口中构建一个笔。</value>
  </Window.TextColor>

  <Window.TextPrint>
    <summary>
      使用当前字体和当前笔颜色在窗口的指定位置显示给定的字符串。
    </summary>
    <param name="cText">要显示的字符串。</param>
    <param name="oPoint">字符串原点的位置，以画布坐标表示。</param>
  </Window.TextPrint>

  <Window.Timer>
    <summary>
      在注册定时器时定义的特定间隔时间调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </Window.Timer>

  <Window.ToolBar>
    <summary>
      窗口使用的工具栏。
    </summary>
    <value>窗口使用的工具栏。</value>
  </Window.ToolBar>

  <Window.ToolBarHeightChanged>
    <summary>
      当窗口的工具栏高度发生变化时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oControlNotifyEvent">描述工具栏高度变化的 ControlNotifyEvent 对象。</param>
    <seealso cref="T:VO.ControlNotifyEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.ToolBarHeightChanged>

  <Window.ToTop>
    <summary>
      将此窗口移动到桌面上的窗口“前面”，使其获得输入焦点。
    </summary>
    <remarks>
      这将使窗口完全可见。
    </remarks>
    <returns>NIL</returns>
  </Window.ToTop>

  <Window.TrayIconBalloonClicked>
    <summary>
      当托盘图标气泡被点击时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="dwID">与托盘图标气泡关联的ID。</param>
    <returns>NIL</returns>
  </Window.TrayIconBalloonClicked>

  <Window.TrayIconBalloonShown>
    <summary>
      当托盘图标气泡显示时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="dwID">与托盘图标气泡关联的ID。</param>
    <returns>NIL</returns>
  </Window.TrayIconBalloonShown>

  <Window.TrayIconBalloonTimeOut>
    <summary>
      当托盘图标气泡超时时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="dwID">与托盘图标气泡关联的ID。</param>
    <returns>NIL</returns>
  </Window.TrayIconBalloonTimeOut>

  <Window.TrayIconClicked>
    <summary>
      当用户点击托盘图标时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="dwID">与托盘图标关联的ID。</param>
    <param name="lRightButton">当用户使用鼠标右键点击时为 TRUE</param>
    <param name="lDoubleClick">当用户双击时为 TRUE</param>
    <returns>NIL</returns>
  </Window.TrayIconClicked>

  <Window.TreeViewItemDelete>
    <summary>
      当在树视图控件中删除树视图项时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewDeleteEvent">描述哪个树视图控件的哪个树视图项被删除的 TreeViewDeleteEvent 对象。</param>
    <seealso cref="T:VO.TreeViewDeleteEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.TreeViewItemDelete>

  <Window.TreeViewItemDrag>
    <summary>
      当在树视图控件中拖动树视图项时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewDragEvent">描述哪个树视图控件的哪个树视图项被拖动的 TreeViewDragEvent 对象。</param>
    <seealso cref="T:VO.TreeViewDragEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.TreeViewItemDrag>

  <Window.TreeViewItemEdit>
    <summary>
      当在树视图控件中编辑树视图项时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewEditEvent">描述哪个树视图控件的哪个树视图项被编辑的 TreeViewEditEvent 对象。</param>
    <seealso cref="T:VO.TreeViewEditEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.TreeViewItemEdit>

  <Window.TreeViewItemExpanded>
    <summary>
      当在树视图控件中展开树视图项时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewExpandedEvent">描述哪个树视图控件的哪个树视图项被展开的 TreeViewExpandedEvent 对象。</param>
    <seealso cref="T:VO.TreeViewExpandedEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.TreeViewItemExpanded>

  <Window.TreeViewItemExpanding>
    <summary>
      当在树视图控件中展开树视图项时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewExpandingEvent">描述哪个树视图控件的哪个树视图项正在展开的 TreeViewExpandingEvent 对象。</param>
    <seealso cref="T:VO.TreeViewExpandingEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.TreeViewItemExpanding>

  <Window.TreeViewKeyDown>
    <summary>
      当在树视图控件中按键时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewKeyEvent">描述哪个树视图控件接收到按键的 TreeViewKeyEvent 对象。</param>
    <seealso cref="T:VO.TreeViewKeyEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.TreeViewKeyDown>

  <Window.TreeViewMouseButtonDoubleClick>
    <summary>
      当在树视图控件中双击鼠标按钮时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewMouseEvent">描述哪个树视图控件接收到鼠标按钮双击的 TreeViewMouseEvent 对象。</param>
    <seealso cref="T:VO.TreeViewMouseEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.TreeViewMouseButtonDoubleClick>

  <Window.TreeViewMouseButtonDown>
    <summary>
      在树视图控件中单击鼠标按钮时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewMouseEvent">描述哪个树视图控件接收到鼠标按钮单击的 TreeViewMouseEvent 对象。</param>
    <seealso cref="T:VO.TreeViewMouseEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.TreeViewMouseButtonDown>

  <Window.TreeViewSelectionChanged>
    <summary>
      在树视图控件中选择项目更改时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewSelectionEvent">描述哪个树视图控件的选择项目更改的 TreeViewSelectionEvent 对象。</param>
    <seealso cref="T:VO.TreeViewSelectionEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.TreeViewSelectionChanged>

  <Window.TreeViewSelectionChanging>
    <summary>
      在树视图控件中选择项目正在更改时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewSelectionEvent">描述哪个树视图控件的选择项目正在更改的 TreeViewSelectionEvent 对象。</param>
    <seealso cref="T:VO.TreeViewSelectionEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.TreeViewSelectionChanging>

  <Window.Update>
    <summary>
      更新窗口的客户区。
    </summary>
    <remarks> 
      此方法利用 Windows API UpdateWindow() 函数来更新窗口的客户区，通过将 WM_PAINT 消息发送到窗口过程中来实现。该消息将直接发送到窗口过程中，从而绕过了应用程序队列。
      Window:Update() 方法将在 Expose() 事件处理程序结束时自动调用。 
      <note type="tip">请勿在 Expose() 事件处理程序中使用此方法。</note>
    </remarks>
    <returns>NIL</returns>
  </Window.Update>

  <Window.VerticalScroll>
    <summary>
      在垂直滚动条滚动时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oScrollEvent">描述滚动类型和新位置的 ScrollEvent 对象。</param>
    <seealso cref="T:VO.ScrollEvent" />
    <remarks>
      该事件处理程序的默认行为是更新滚动条的 thumb 位置；如果需要，可以使用自己的事件处理程序来更改该行为。该事件处理程序仅适用于 HorizontalScrollBar 和 WindowHorizontalScrollBar 对象。如果应用程序具有水平滚动条，请使用 HorizontalScrollBar 事件处理程序。
    </remarks>
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.VerticalScroll>

  <Window.VerticalSlide>
    <summary>
      在垂直滑块的 thumb 被拖曳时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oSliderEvent">描述哪个垂直滑块的 thumb 被拖曳的 SliderEvent 对象。</param>
    <seealso cref="T:VO.SliderEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.VerticalSlide>

  <Window.VerticalSpin>
    <summary>
      在垂直 spinner 被旋转时调用的方法。
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      该事件处理程序的默认行为是更新 spinner 的位置；如果需要，可以使用自己的事件处理程序来更改该行为。该事件处理程序仅适用于 HorizontalScrollBar 和 WindowHorizontalScrollBar 对象。如果应用程序具有水平滚动条，请使用 HorizontalScrollBar 事件处理程序。
      </remarks>
    <param name="oSpinnerEvent">描述哪个垂直 spinner 被旋转的 SpinnerEvent 对象。</param>
    <seealso cref="T:VO.SpinnerEvent" />
    <returns>此方法调用 Window.Default()，并返回 Window.Default() 的结果</returns>
  </Window.VerticalSpin>

  <Window.WindowArea>
    <summary>
      窗口的边界框，包括 canvas area 和 non-canvas area，单位为 canvas 坐标。
    </summary>
    <value>窗口的边界框，包括 canvas area 和 non-canvas area，单位为 canvas 坐标。</value>
  </Window.WindowArea>

  <WindowHorizontalScrollBar>
    <summary>
      创建一个窗口水平滚动条。
    </summary>
    <remarks> 
      在X#中有两种水平滚动条：常规滚动条(使用 CLASS HorizontalScrollBar 创建)和窗口水平滚动条(使用 AppWindow:EnableHorizontalScroll() 方法创建)。
      这两种滚动条都有一个所有者窗口，并且可以使用 Window:HorizontalScroll() 方法来操作它们。
      然而，窗口水平滚动条自动出现在所有者窗口的 canvas area 的底部，并且根据所有者窗口的大小来调整自身的大小。 
      <note type="tip">
        Window:HorizontalScroll() 方法的默认行为是更新滚动条的 thumb 位置；如果需要，可以使用自己的事件处理程序来更改该行为。
      </note>
    </remarks>
  </WindowHorizontalScrollBar>

  <WindowHorizontalScrollBar.ctor>
    <summary>
      构造一个窗口水平滚动条。
    </summary>
    <param name="oOwner">所有者窗口</param>
  </WindowHorizontalScrollBar.ctor>

  <WindowHorizontalScrollBar.Background>
    <summary>
      该属性是为了override Control 类中的 Background 属性，因为它不适用于 WindowHorizontalScrollBar。
    </summary>
    <value>该属性是为了override Control 类中的 Background 属性，因为它不适用于 WindowHorizontalScrollBar。</value>
  </WindowHorizontalScrollBar.Background>

  <WindowHorizontalScrollBar.ControlID>
    <summary>
      该属性是为了override Control 类中的 ControlID 属性，因为它不适用于 WindowHorizontalScrollBar。
    </summary>
    <value>该属性是为了override Control 类中的 ControlID 属性，因为它不适用于 WindowHorizontalScrollBar。</value>
  </WindowHorizontalScrollBar.ControlID>

  <WindowHorizontalScrollBar.Destroy>
    <summary>
      释放 WindowHorizontalScrollBar 对象占用的资源。
    </summary>
    <remarks>
      该方法可以在 WindowHorizontalScrollBar 对象不再需要时使用。WindowHorizontalScrollBar:Destroy() 释放 WindowHorizontalScrollBar 对象占用的资源，允许您在不等待垃圾收集器的情况下关闭和释放对象占用的资源。
    </remarks>
  </WindowHorizontalScrollBar.Destroy>

  <WindowHorizontalScrollBar.Origin>
    <summary>
      该属性是为了override Control 类中的 Origin 属性，因为它不适用于 WindowHorizontalScrollBar。
    </summary>
    <value>该属性是为了override Control 类中的 Origin 属性，因为它不适用于 WindowHorizontalScrollBar。</value>
  </WindowHorizontalScrollBar.Origin>

  <WindowHorizontalScrollBar.SetFocus>
    <summary>
      该方法是为了override Control 类中的 SetFocus() 方法，因为它不适用于 WindowHorizontalScrollBar。
    </summary>
  </WindowHorizontalScrollBar.SetFocus>
 
  <WindowHorizontalScrollBar.Size>
  <summary>
    在指定的窗口中显示 DIB。
  </summary>
  <value>
    提供此属性是为了覆盖从 Control 类继承的功能，因为它不适用于 WindowHorizontalScrollBar。
  </value>
  </WindowHorizontalScrollBar.Size>
  
  <WindowScrollBar>
    <summary>
      Windows Scrollbars 的 Abstract class
    </summary>
    <remarks> 
      X# 中有两种水平滚动条：常规滚动条(使用 CLASS HorizontalScrollBar 创建)和窗口水平滚动条(使用 AppWindow:EnableHorizontalScroll() 方法创建)。
      两种类型都有一个所有者窗口，并且可以使用 Window:HorizontalScroll() 方法来操作它们。
      然而，窗口水平滚动条自动出现在所有者窗口的 canvas area 的底部，并且根据所有者窗口的大小来调整自身的大小。
      <note type="tip">
        默认情况下，Window:HorizontalScroll() 更新滚动条的拇指位置；如果需要，可以使用自己的事件处理程序来更改该行为。
      </note>
    </remarks>
  </WindowScrollBar>

  <WindowScrollBar.ctor>
    <inheritdoc />
  </WindowScrollBar.ctor>

  <WindowStyle.ctor>
    <exclude />
  </WindowStyle.ctor>

  <WindowStyle.ClassName>
    <exclude />
  </WindowStyle.ClassName>

  <WindowStyle.SetExStyle>
    <exclude />
  </WindowStyle.SetExStyle>

  <WindowStyle.SetStyle>
    <exclude />
  </WindowStyle.SetStyle>

  <WindowVerticalScrollBar>
    <summary>
      创建一个窗口垂直滚动条.
    </summary>
    <remarks> 
      在 X# 中有两种垂直滚动条：常规滚动条(使用 CLASS VerticalScrollBar 创建)和窗口滚动条(使用 AppWindow:EnableVerticalScroll() 方法创建)。
      这两种滚动条都有一个拥有者窗口，并且可以使用 Window:VerticalScroll() 方法来操作它们。
      然而，窗口垂直滚动条不同于它自动出现在拥有者窗口的 canvas area 的右侧，并且根据拥有者窗口的大小来调整自身的大小。 
      <note type="tip">
        Window:VerticalScroll() 方法的默认行为是更新滚动条的 thumb 位置；如果需要，可以使用自己的事件处理程序来更改该行为。
      </note>
    </remarks>
  </WindowVerticalScrollBar>

  <WindowVerticalScrollBar.ctor>
    <summary>
      构造一个窗口垂直滚动条.
    </summary>
    <param name="oOwner">拥有者窗口.</param>
  </WindowVerticalScrollBar.ctor>

  <WindowVerticalScrollBar.Background>
    <summary>
      该属性是为了override Control 类中的 Background 属性，因为它不适用于 WindowVerticalScrollBar.
    </summary>
    <value>该属性是为了override Control 类中的 Background 属性，因为它不适用于 WindowVerticalScrollBar.</value>
  </WindowVerticalScrollBar.Background>

  <WindowVerticalScrollBar.ControlID>
    <summary>
      该属性是为了override Control 类中的 ControlID 属性，因为它不适用于 WindowVerticalScrollBar.
    </summary>
    <value>该属性是为了override Control 类中的 ControlID 属性，因为它不适用于 WindowVerticalScrollBar.</value>
  </WindowVerticalScrollBar.ControlID>

  <WindowVerticalScrollBar.Destroy>
    <summary>
      释放 WindowVerticalScrollBar 对象占用的资源.
    </summary>
    <remarks>
      该方法可以在 WindowVerticalScrollBar 对象不再需要时使用。WindowVerticalScrollBar:Destroy() 释放 WindowVerticalScrollBar 对象占用的资源，允许您在不等待垃圾收集器的情况下关闭和释放对象占用的资源.
    </remarks>
  </WindowVerticalScrollBar.Destroy>

  <WindowVerticalScrollBar.Origin>
    <summary>
      该属性是为了override Control 类中的 Origin 属性，因为它不适用于 WindowVerticalScrollBar.
    </summary>
    <value>该属性是为了override Control 类中的 Origin属性，因为它不适用于 WindowVerticalScrollBar.</value>
  </WindowVerticalScrollBar.Origin>

  <WindowVerticalScrollBar.SetFocus>
    <summary>
      该方法是为了 override Control 类中的 SetFocus() 方法，因为它不适用于 WindowVerticalScrollBar.
    </summary>
  </WindowVerticalScrollBar.SetFocus>

  <WindowVerticalScrollBar.Size>
    <summary>
      该属性是为了 override Control 类中的 Size 属性，因为它不适用于 WindowVerticalScrollBar.
    </summary>
    <value>该属性是为了 override Control 类中的 Size 属性，因为它不适用于 WindowVerticalScrollBar.</value>
  </WindowVerticalScrollBar.Size>

  <VOGUIClasses.Functions>
    <summary>
      该编译器生成的类包含了 VOGUIClasses 程序集中的所有函数、全局变量和常量.
    </summary>
  </VOGUIClasses.Functions>

  <ApplicationExec>
    <exclude />
  </ApplicationExec>

  <DIBCreateFromFile>
    <summary>
      从图像文件创建一个设备无关位图 (DIB)。
    </summary>
    <param name="pszFName">新 DIB 文件的名称。</param>
    <returns>
      指向 DIB 数据的指针，否则 NULL_PTR。
    </returns>
    <remarks>
      DIBCreateFromFile() 从图像文件 (JPG, TIF, BMP, TGA, PNG, PCX, PCT) 创建一个设备无关位图 (DIB)。
    </remarks>
    <example></example>
    <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromPTR">DIBCreateFromPTR</seealso>
    <seealso cref="O:VOGUIClasses.Functions.DIBDelete">DIBDelete</seealso>
  </DIBCreateFromFile>

  <DIBCreateFromPTR>
    <summary>
      将图像文件转换为设备无关位图 (DIB)。
    </summary>
    <param name="pbImage">指向图像数据的第一个字节的指针。</param>
    <param name="nSize">图像数据的大小 (字节数)。</param>
    <returns>
      指向 DIB 数据的指针，否则 NULL_PTR。
    </returns>
    <remarks>
      DIBCreateFromPtr() 将图像文件 (JPG, TIF, BMP, TGA, PNG, PCX, PCT) 转换为设备无关位图 (DIB)。
    </remarks>
    <example> 
      以下示例将文件 test.jpg 转换并显示在一个 TopAppWindow 中: 
      <code language="X#">
        METHOD Start() CLASS App
        LOCAL oWin AS MyWindow
        LOCAL hf AS PTR
        LOCAL nSize AS INT
        LOCAL pDib AS PTR

        WCSetCoordinateSystem(WCWindowsCoordinates)
        InitializeCAPaint()

        hf := FOpen("test.jpg")

        IF hf != F_ERROR
            nSize := FSeek(hf, 0, FS_END)
            FSeek(hf, 0, FS_SET)
            pDib := MemAlloc(nSize)

            IF FRead3(hf, pDib, nSize) == nSize
                oWin := MyWindow{ SELF, pDib, nSize }
                oWin:Show(SHOWCENTERED)
            ENDIF

            FClose(hf)
            SELF:Exec()
            oWin:Axit()
            MemFree(pDib)
        ENDIF
        
        CLASS MyWindow INHERIT TopAppWindow
            PROTECT pBitMap AS PTR
            PROTECT lBitMap AS LOGIC

            CONSTRUCTOR(oParent, xFile, nSize)
                LOCAL pBmiH AS _WINBITMAPINFO
                LOCAL nHeight AS INT
                LOCAL nWidth AS INT
                LOCAL oPOint AS POINT
                LOCAL hWnd AS PTR
                LOCAL cx AS INT
                LOCAL cy AS INT
                LOCAL cr IS _WINRECT
                LOCAL wr IS _WINRECT

                SUPER:Init(oParent)
                SELF:QuitOnClose := TRUE

                IF IsPtr(xFile) .AND. IsNumeric(nSize)
                    SELF:pBitMap := DIBCreateFromPtr(xFile, nSize)
                ENDIF

                IF pBitMap = NULL_PTR
                    MessageBox(0, "Error reading image", "ERROR ", MB_ICONSTOP)
                ELSE
                    SELF:lBitmap := .T.
                    oPoint      := SELF:Origin
                    pBmiH       := DIBGetInfo(pBitMap)
                    nHeight     := pBmiH.bmiHeader.biHeight
                    nWidth      := pBmiH.bmiHeader.biWidth
                    hWnd        := SELF:Handle()
                    GetWindowRect(hWnd, @wr)
                    GetClientRect(hWnd, @cr)
                    cx          := wr.right - wr.left - cr.right
                    cy          := wr.bottom - wr.top - cr.bottom
                    SELF:Size   := DIMension{nWidth + cx, nHeight + cy}
                    SELF:Origin := oPoint
                ENDIF

                RETURN SELF

            METHOD Expose(oExposeEvent)
                SUPER:Expose(oExposeEvent)

                IF SELF:lBitMap
                    DIBShow( SELF:pBitMap, NULL_PTR )
                ENDIF

            DESTRUCTOR() CLASS MyWindow
                DIBDelete(SELF:pBitmap)
        END CLASS
      </code>
    </example>
    <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromFile">DIBCreateFromFile</seealso>
    <seealso cref="O:VOGUIClasses.Functions.DIBDelete">DIBDelete</seealso>
  </DIBCreateFromPTR>

  <DIBDelete>
    <summary>
      销毁 DIBCreateFromFile() 或 DIBCreateFromPtr() 创建的 DIB。
    </summary>
    <param name="pWinBmp">指向 DIB 数据的指针。</param>
    <returns></returns>
    <remarks>
      DIBDelete() 销毁 DIBCreateFromFile() 或 DIBCreateFromPtr() 创建的 DIB。
    </remarks>
    <example> 
      以下示例销毁一个 DIB: 
      <code language="X#">
        FUNC Start()
            LOCAL pDib AS PTR
            pDib := DIBCreateFromFile("c:\test.jpg")

            IF pDib = NULL_PTR
               DIBDelete(pDib)
            ENDIF

            WAIT
      </code>
    </example>
    <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromFile">DIBCreateFromFile</seealso>
    <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromPTR">DIBCreateFromPtr</seealso>
  </DIBDelete>

  <DIBGetInfo>
    <summary>
      返回 DIB 的 BITMAPINFO 结构的指针。
    </summary>
    <param name="pWinBmp">指向 DIB 数据的指针。</param>
    <returns>
      指向 BITMAPINFO 结构的指针，否则 NULL_PTR。
    </returns>
    <remarks>
      DIBGetInfo() 返回 DIB 的 BITMAPINFO 结构的指针。
    </remarks>
    <example>
      参考 DIBCreateFromPtr() 示例。
    </example>
    <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromPTR">DIBCreateFromPtr</seealso>
  </DIBGetInfo>

  <DIBSaveAs>
    <summary>
      将 DIB 保存到文件中。
    </summary>
    <param name="pWinBmp">指向 DIB 数据的指针。</param>
    <param name="pszFName">新 DIB 文件的名称。</param>
    <returns></returns>
    <remarks>
      DIBSaveAs() 将 DIB 保存到文件中。
    </remarks>
    <example> 
      以下示例将 DIB 保存到文件 test.dib 中: 
      <code language="X#">
        FUNC Start()
            LOCAL pDib AS PTR
            pDib := DIBCreateFromFile("c:\test.jpg")

            IF pDib = NULL_PTR
                DIBSaveAs(pDib, "c:\test.dib")
                DIBDelete(pDib)
            ENDIF

            WAIT

            RETURN 
      </code>
    </example>
    <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromFile">DIBCreateFromFile</seealso>
  </DIBSaveAs>

  <DIBShow>
    <summary>
      在指定的窗口中显示 DIB.
    </summary>
    <param name="pWinBmp">指向 DIB 数据的指针.</param>
    <param name="hWnd">窗口句柄.</param>
    <returns></returns>
    <remarks>
      DIBShow() 在指定的窗口 &lt;hWnd&gt; 中显示 DIB.
    </remarks>
    <example>
      请参阅 DIBCreateFromPtr() 示例.
    </example>
    <seealso cref="O:VOGUIClasses.Functions.DIBStretch">DIBStretch</seealso>
  </DIBShow>

  <DIBStretch>
    <summary>
      在指定的窗口中显示 DIB.
    </summary>
    <param name="pWinBmp">指向 DIB 数据的指针.</param>
    <param name="hWnd">窗口句柄.</param>
    <param name="nCx">显示 DIB 的宽度.</param>
    <param name="nCy">显示 DIB 的高度.</param>
    <param name="r8Factor">
      DIB 的缩放因子.
      值为 1.0 将显示 DIB 的正常大小.
    </param>
    <returns></returns>
    <remarks>
      DIBStretch() 将 DIB 复制到一个目标矩形中，&lt;nWidth&gt; by &lt;nHeight&gt;，缩放或压缩 DIB，以适合窗口 &lt;hWnd&gt;
      的大小.&lt;r8Zoom&gt; 可以用来计算 DIB 的缩放因子.&lt;r8Zoom&gt; 可以用来计算 DIB 的缩放因子.
      例如，值为 2.0 将 DIB 的大小加倍，而值为 0.5 将 DIB 缩放到其正常大小的一半.
    </remarks>
    <example></example>
    <seealso cref="O:VOGUIClasses.Functions.DIBShow">DIBShow</seealso>
  </DIBStretch>

  <Enable3dControls>
    <summary>确定是否使用三维外观来显示 windows 创建的控件.</summary>
    <remarks>注意 - 该函数仅在 16 位应用程序中有用.</remarks>
  </Enable3dControls>

  <EnableAppVisualTheme>
    <summary>
      启用或禁用应用程序对视觉主题的支持.
    </summary>
    <param name="lEnable">
      可选的逻辑值。TRUE启用视觉主题，FALSE禁用它们。<br />
      默认值为 TRUE.
    </param>
    <returns>
      如果启用了视觉主题，则返回 TRUE；否则返回 FALSE。
    </returns>
    <remarks>
      如果使用应用程序清单加载公共控件的版本 6，则将自动启用视觉主题。
    </remarks>
    <seealso cref="O:VOGUIClasses.Functions.IsThemeEnabled">IsThemeEnabled</seealso>
  </EnableAppVisualTheme>

  <EnableThemeDialogTexture>
    <exclude />
  </EnableThemeDialogTexture>

  <GetAppObject>
    <summary>
      返回当前应用程序的全局 App 对象.
    </summary>
    <returns></returns>
    <remarks></remarks>
    <example> 
      以下示例终止了一个基于对话框的应用程序: 
      <code language="X#">
        METHOD CancelButton() CLASS OrderDialog
            SELF:EndDialog()
            GetAppObject():Quit()
      </code>
    </example>
    <seealso cref="T:VO.App">App Class</seealso>
    <seealso cref="O:VOGUIClasses.Functions.GetObjectByHandle">GetObjectByHandle</seealso>
  </GetAppObject>

  <GetFocusedObject>
    <summary>
      返回当前拥有焦点的对象.
    </summary>
    <returns>
      当前拥有焦点的对象.
    </returns>
    <remarks></remarks>
    <example> 
      以下示例在当前拥有焦点的对象是一个 MultiLineEdit 控件时发出提示音: 
      <code language="X#">
        oObj := GetFocusedObject()

        IF oObj != NULL_OBJECT .AND. IsInstanceOf(oControl, #MultiLineEdit)
            MessageBeep(MB_ICONASTERISK)
        ENDIF
      </code>
    </example>
    <seealso cref="T:VO.Control">CLASS Control</seealso>
    <seealso cref="T:VO.Window">Class Window</seealso>
    <seealso cref="O:VOGUIClasses.Functions.GetAppObject">GetAppObject</seealso>
    <seealso cref="O:VOGUIClasses.Functions.GetObjectByHandle">GetObjectByHandle</seealso>
  </GetFocusedObject>

  <GetFrameWidth>
    <exclude />
  </GetFrameWidth>

  <GetObjectByHandle>
    <summary>
      返回与指定窗口句柄关联的对象.
    </summary>
    <param name="hwnd">窗口句柄.</param>
    <returns>
      与指定窗口句柄关联的对象.
    </returns>
    <remarks></remarks>
    <example> 
      以下示例获取当前拥有焦点的对象: 
      <code language="X#">
        FUNCTION GetFocusedObject() AS OBJECT
            LOCAL oCtrl AS OBJECT
            oCtrl := GetObjectByHandle(GetFocus())

            IF IsInstanceOf(oCtrl, #Control)
                RETURN oCtrl
            ELSE
                RETURN NULL_OBJECT
            ENDIF
      </code>
    </example>
    <seealso cref="T:VO.Control">CLASS Control</seealso>
    <seealso cref="T:VO.Window">Class Window</seealso>
    <seealso cref="O:VOGUIClasses.Functions.GetAppObject">GetAppObject</seealso>
    <seealso cref="O:VOGUIClasses.Functions.GetFocusedObject">GetAppObject</seealso>
  </GetObjectByHandle>

  <GetThemeAppProperties>
    <summary>
      获取当前应用程序中控制视觉样式应用于哪些部分的标志
    </summary>
    <returns>
      <list>
        <item>
          <term>STAP_ALLOW_NONCLIENT</term>
          <description>指定应用程序窗口的非客户区应用视觉样式</description>
        </item>
        <item>
          <term>STAP_ALLOW_CONTROLS</term>
          <description>指定应用程序窗口中的控件应用视觉样式</description>
        </item>
        <item>
          <term>STAP_ALLOW_WEBCONTENT</term>
          <description>指定应用程序中显示的所有 web 内容使用视觉样式渲染</description>
        </item>
      </list>
    </returns>
    <remarks></remarks>
    <example></example>
  </GetThemeAppProperties>

  <IsAltPressed>
    <summary>获取 Alt 键的当前状态</summary>
  </IsAltPressed>

  <IsAppThemed>
    <summary>返回当前应用程序的主题设置</summary>
  </IsAppThemed>

  <IsControlPressed>
    <summary>获取 Ctrl 键的当前状态</summary>
  </IsControlPressed>

  <IsCtl3dEnabled>
    <exclude />
  </IsCtl3dEnabled>

  <IsShiftPressed>
    <summary>获取 Shift 键的当前状态</summary>
  </IsShiftPressed>

  <IsThemeEnabled>
    <summary>
      确定是否启用了视觉主题支持
    </summary>
    <returns>
      如果启用了视觉主题支持，返回 TRUE；否则返回 FALSE
    </returns>
    <seealso cref="O:VOGUIClasses.Functions.EnableAppVisualTheme">EnableAppVisualTheme</seealso>
  </IsThemeEnabled>

  <VerifyThemeState>
    <summary>验证当前的主题状态，并设置 ThemeEnabled 标志</summary>
    <returns>该函数返回 IsThemeEnabled() 函数的当前值</returns>
  </VerifyThemeState>

  <VOInternetClasses.Functions>
    <summary>
      该编译器生成的类包含 VOInternetClasses 程序集中的所有函数、全局变量和定义
    </summary>
  </VOInternetClasses.Functions>

  <VORDDClasses.Functions>
    <summary>
      该编译器生成的类包含 VORDDClasses 程序集中的所有函数、全局变量和定义
    </summary>
  </VORDDClasses.Functions>

  <VORDDClasses.Functions.DBFDebug>
    <exclude />
  </VORDDClasses.Functions.DBFDebug>

  <VORDDClasses.Functions.DbGetDefaultLockMode>
    <summary>Get/Set DbServer 类的默认锁定模式</summary>
    <param name="dwLockMode">新的锁定模式。默认值 = ccOptimistic</param>
    <returns>之前的锁定模式</returns>
  </VORDDClasses.Functions.DbGetDefaultLockMode>

  <VORDDClasses.Functions.DbSetDefaultLockMode>
    <summary>Get DbServer 类的默认锁定模式</summary>
    <returns>当前的锁定模式</returns>
  </VORDDClasses.Functions.DbSetDefaultLockMode>

  <VORDDClasses.Functions.DbSetRestoreWorkarea>
    <summary>Get/Set DbServer 操作是否还原当前工作区的标志 </summary>
  </VORDDClasses.Functions.DbSetRestoreWorkarea>

  <VOSystemClasses.Functions>
    <summary>
      该编译器生成的类包含 VOSystemClasses 程序集中的所有函数、全局变量和定义
    </summary>
  </VOSystemClasses.Functions>

  <XSharp.ChildWinForm.ctor>
    <exclude />
  </XSharp.ChildWinForm.ctor>

  <XSharp.ChildWinForm.Activate>
    <exclude />
  </XSharp.ChildWinForm.Activate>

  <XSharp.ChildWinForm.Close>
    <exclude />
  </XSharp.ChildWinForm.Close>

  <XSharp.ChildWinForm.DeActivate>
    <exclude />
  </XSharp.ChildWinForm.DeActivate>

  <XSharp.ChildWinForm.Resize>
    <exclude />
  </XSharp.ChildWinForm.Resize>

  <XSharp.ChildWinForm.WinForm>
    <exclude />
  </XSharp.ChildWinForm.WinForm>

  <XSharp.VOWinFormApp.ctor>
    <exclude />
  </XSharp.VOWinFormApp.ctor>

  <XSharp.VOWinFormApp.BeforeDispatch>
    <exclude />
  </XSharp.VOWinFormApp.BeforeDispatch>

  <XSharp.VOWinFormApp.RegisterWinForm>
    <exclude />
  </XSharp.VOWinFormApp.RegisterWinForm>

  <XSharp.VOWinFormApp.UnRegisterWinForm>
    <exclude />
  </XSharp.VOWinFormApp.UnRegisterWinForm>

  <XSharp.WinFormVOWindow.ctor>
    <exclude />
  </XSharp.WinFormVOWindow.ctor>

  <XSharp.WinFormVOWindow.CloseHostForm>
    <exclude />
  </XSharp.WinFormVOWindow.CloseHostForm>

  <XSharp.WinFormVOWindow.Initialize>
    <exclude />
  </XSharp.WinFormVOWindow.Initialize>

  <XSharp.WinFormVOWindow.VOWindowHost>
    <exclude />
  </XSharp.WinFormVOWindow.VOWindowHost>

  <XSharp.WinFormVOWindowHost.ctor>
    <exclude />
  </XSharp.WinFormVOWindowHost.ctor>

  <XSharp.WinFormVOWindowHost.ctor>
    <exclude />
  </XSharp.WinFormVOWindowHost.ctor>

  <XSharp.WinFormVOWindowHost.ctor>
    <exclude />
  </XSharp.WinFormVOWindowHost.ctor>

  <XSharp.WinFormVOWindowHost.AdjustVOWindow>
    <exclude />
  </XSharp.WinFormVOWindowHost.AdjustVOWindow>

  <XSharp.WinFormVOWindowHost.ClassesNeedingTranslateTabToArrow>
    <exclude />
  </XSharp.WinFormVOWindowHost.ClassesNeedingTranslateTabToArrow>

  <XSharp.WinFormVOWindowHost.Close>
    <exclude />
  </XSharp.WinFormVOWindowHost.Close>

  <XSharp.WinFormVOWindowHost.Focus>
    <exclude />
  </XSharp.WinFormVOWindowHost.Focus>

  <XSharp.WinFormVOWindowHost.HostingControl>
    <exclude />
  </XSharp.WinFormVOWindowHost.HostingControl>

  <XSharp.WinFormVOWindowHost.IsHostingDataWindow>
    <exclude />
  </XSharp.WinFormVOWindowHost.IsHostingDataWindow>

  <XSharp.WinFormVOWindowHost.ProcessDialogKey>
    <exclude />
  </XSharp.WinFormVOWindowHost.ProcessDialogKey>

  <XSharp.WinFormVOWindowHost.VOWindow>
    <exclude />
  </XSharp.WinFormVOWindowHost.VOWindow>

  <XSharp.WinFormVOWindowHost.VOWindowClassName>
    <exclude />
  </XSharp.WinFormVOWindowHost.VOWindowClassName>
</doc>