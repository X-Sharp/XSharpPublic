<?xml version="1.0" encoding="utf-8" ?>
<Comments>
  <StaticMemory>
    <remarks>
      <note type="tip">
        The Static Memory Functions (MemAlloc, MemSet etc) are included for compatibility only.
        In most cases the static memory blocks can (and should) be replaced with arrays of bytes.<br/>
        Many of the functions in the runtime that take memory blocks as parameter, 
        such as the low level IO functions, now have overloads that take arrays of bytes as parameter.<br/>
        We recommend that you use these overloads, because their performance is somewhat better.
      </note>
    </remarks>
  </StaticMemory>
  <PSZ>
    <remarks>
      <note type="tip">
        The PSZ type is included in the X# language and runtime for compatibility only.
        In most cases the type can and should be replaced with normal strings. <br/>
        If you need to interface with Win32 API functions that expect an ansi string, there is often also
        an alternative with a unicode string. We recommend to use that alternative when possible.
      </note>
    </remarks>
  </PSZ>
  <Symbol>
    <remarks>
      <note type="tip">
        The SYMBOL type is included in the X# language and runtime for compatibility only.
        In most cases the type can and should be replaced with normal strings.
      </note>
    </remarks>
  </Symbol>
  <Memvar>
    <remarks>
      <note type="tip">
        Dynamic memory variables (PUBLIC, PRIVATE, PARAMETERS) are supported in the X# language and runtime for compatibility only.<br/>
        In most cases the type can and should be replaced with lexically scoped variables, such as LOCALs and GLOBALs.
      </note>
    </remarks>
  </Memvar>
  <Operator>
    <summary>This operator is used in code generated by the compiler when needed.</summary>
  </Operator>
  <UsualCompare>
      <param name="lhs">Left side of the comparison</param>
      <param name="rhs">Right side of the comparison</param>
      <remarks>When comparing 2 usuals from different types, then the type of the Left Hand Side is taken as 'leading'.
      For example when comparing a usual of a LHS of type DATE with a RHS of type DateTime
      then the DateTime from the RHS is converted to a DATE first (the time is stripped off) becore comparing. <br/>
      Comparison with .NULL.  (DBNull.Value) always returns FALSE. In FoxPro this returns .NULL. but that is not supported by .Net.

      </remarks>
      <returns>A Logicical value</returns>
  </UsualCompare>
    <UsualBinary>
        <param name="lhs">Left side of the binary operation</param>
        <param name="rhs">Right side of the binary operation</param>
        <returns>A usual value of a type that matches the binary operator. For example when the operation involves an integer and a float then the result will be a float</returns>
        <remarks>
            When performing binary operations on usual types where the Left and Right types are different then the runtime follows "special"
            rules to handle these. <br/>
            For example when adding an integral number to a fractional number(float, decimal or currency), then the result is always a 
            fractional number of the fractional type.<br/>
            Binary operations where one or both sides are .NULL. (DBNull.Value) always returns .NULL. 

        </remarks>
    </UsualBinary>
    <Converter>
    <summary>This converter is used in code generated by the compiler when needed.</summary>
  </Converter>
  <Constructor>
    <summary>This constructor is used in code generated by the compiler when needed.</summary>
  </Constructor>
  <FileCompat>
    <remarks>
      <note type="tip">
        This function is included for compatibility. We do not recomment using static memory for file i/o operations.
        We recommend that you use the function overload that takes a byte array parameter in stead.
      </note>
    </remarks>
  </FileCompat>
  <ZeroBasedIndex>
    <remarks>
      The indexer in this type is <em>ZERO</em> based, however in your PRG code you can use <em>ONE</em> based array indices.
      When the compiler detects an index operation to a class that implements this interface then the compiler will automatically
      adjust the indices (by subtracting one) unless the /az compiler option is enabled.
    </remarks>
  </ZeroBasedIndex>
  <ZeroBasedIndexParam>
    <span>
      This indexer is <em>ZERO</em> based, however in your PRG code you can use <em>ONE</em> based array indices.
      The compiler will recognize that this property is part of a type that implements a special interface
      and will subtract one from the indexes, unless the /az compiler option is enabled.
    </span>
  </ZeroBasedIndexParam>
  <NameBasedIndexParam>
    <span>
      Name of the property from the element stored in the location index. If the element implements IIndexedProperties,
      then the indexer with a string parameter on this element will be called. Otherwise the runtime will use reflection to find
      the field or property on the element and return its value
    </span>
  </NameBasedIndexParam>
  <ZeroBasedIndexProperty>
    <summary>
      Get/Set array elements with a <em>ZERO</em> based array index.
    </summary>
    <remarks>
      In your PRG code you can assess the elements with a <em>ONE</em> based index.
      The compiler will recognize that this property is part of a type that implements a special interface
      and will subtract one from the indexes, unless the /az compiler option is enabled.
    </remarks>
  </ZeroBasedIndexProperty>
  <ScopeParams>
    <span>
      <list type="table">
        <listheader>
          <term>DEFINE</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>SCOPE_TOP</term>
          <description>The top scope.</description>
        </item>
        <item>
          <term>SCOPE_BOTTOM</term>
          <description>The bottom scope.</description>
        </item>
        <item>
          <term>SCOPE_BOTH</term>
          <description>The top and also the bottom scope. This is the <em>default</em>.</description>
        </item>
      </list>
    </span>
  </ScopeParams>
  <ScopeReturn>
    <span>
      The return value depends on the parameter that is passed in:<br/>
      <list type="table">
        <listheader>
          <term>Parameter</term>
          <description>Return value</description>
        </listheader>
        <item>
          <term>no parameter</term>
          <description>Returns .T. (true) if a scope is defined, and .F. when no scope is defined.</description>
        </item>
        <item>
          <term>SCOPE_TOP</term>
          <description>Returns the top scope value, or NIL if no top scope is set.</description>
        </item>
        <item>
          <term>SCOPE_BOTTOM</term>
          <description>Returns the bottom scope value, or NIL if no bottom scope is set.</description>
        </item>
        <item>
          <term>SCOPE_BOTH</term>
          <description>Returns an array with 2 elements with the Top scope in element 1 and the Bottom scope in element 2. 
          When a scope is not set then the value NIL is stored in the array</description>
        </item>

      </list>
    </span>
  </ScopeReturn>
    <SerializeConstructor>
        <summary>Construct a value from serialized data</summary>
        <param name="info">A SerializationInfo object containing information required to construct value.</param>
        <param name="context">A StreamingContext object containing the source and destination of the serialized stream associated with the value.</param>
    </SerializeConstructor>
    <RddInfoParam>
        <span>
            The constants are described in the Constants section below. <br />
            The initial default of a setting depends on the RDD.<br/>
            The constants are described in the Constants section below.  Note, however, that not all constants are supported for all RDDs.<br/>
            Important!  _SET_USER is a constant that returns the minimum value that third-party RDD developers 
            can use for defining new parameters.
            Values less than _SET_USER are reserved for X# development.
        </span>
    </RddInfoParam>
    
    <RddInfoRemarks>
        <list type="table">
            <listheader>
                <term>Constant</term>
                <description>Description</description>
            </listheader>
            <item>
                <term>_SET_AUTOOPEN</term>
                <description>Returns and optionally changes the logical flag that determines whether the RDD will open production indexes automatically when a database file is opened. A TRUE setting indicates that the production index is opened automatically.</description>
            </item>
            <item>
                <term>_SET_AUTOORDER</term>
                <description>Returns and optionally changes the numeric setting that determines whether the production index will set a controlling order. A setting of 1 indicates that the first order in the production index will be the controlling order. A setting of 0 indicates that database files will be processed in natural order when the production index is initially opened.</description>
            </item>
            <item>
                <term>_SET_AUTOSHARE</term>
                <description>
                    Returns and optionally changes the numeric setting that determines the automatic sharing mode. <br/>
                    A setting of 0 completely disables automatic sharing control. This is primarily useful when developing network applications in a stand-alone environment. <br/>
                    A setting of 1 causes the RDD to determine at runtime whether the application is running in a network environment. If not, the RDD automatically opens all files in exclusive mode. This allows you to write code that is network-aware, while still getting optimal performance when you application is running in single-user mode. <br/>
                    A setting of 2 opens all files in exclusive mode, regardless of the current environment. Using this mode, you can easily convert an application designed for a network environment to work as a single-user application. This is useful if you prefer to deliver separate stand-alone and LAN versions of the application.
                </description>
            </item>
            <item>
                <term>_SET_BLOB_CIRCULAR_ARRAY_REF</term>
                <description>
                    Returns and optionally sets the logical flag indicating whether to check for circular array references when storing and retrieving arrays to and from BLOB fields. A FALSE setting indicates that the RDD will not check for circular references. <br/>
                    The algorithm for storing/retrieving arrays uses a recursive process which will call itself indefinitely if the array has a circular reference, quickly exhausting the program's stack. You can set DBServer:RDDInfo(_SET_BLOB_CIRCULAR_ARRAY_REF, TRUE) to cause the algorithm to check for and correctly process circular references. Note, however, that the checking takes extra time and is unnecessary unless there are circular references.
                </description>
            </item>
            <item>
                <term>_SET_DEFAULTRDD</term>
                <description>Returns the name of the default RDD, specified as a string.</description>
            </item>
            <item>
                <term>_SET_HPLOCKING</term>
                <description>Returns and optionally changes the logical flag that determines whether to use the High Performance (HP) locking schema for newly created index files. A FALSE setting indicates that the HP locking schema is not used.</description>
            </item>
            <item>
                <term>_SET_MEMOBLOCKSIZE</term>
                <description>Returns and optionally changes the numeric value specifying block size (in bytes) for memo files.</description>
            </item>
            <item>
                <term>_SET_MEMOEXT</term>
                <description>Returns and optionally changes the string value indicating the default memo file extension.</description>
            </item>
            <item>
                <term>_SET_NEWINDEXLOCK</term>
                <description>Returns and optionally changes the logical flag that determines the locking offset flag for newly created index files. A FALSE setting indicates a locking offset that is compatible with Xbase applications but more restrictive than the offset that will be used if this flag is set to TRUE.</description>
            </item>
            <item>
                <term>_SET_OPTIMIZE</term>
                <description>Returns and optionally changes the logical flag that determines whether optimization will be used when filtering records in the database files. A TRUE setting indicates that the RDD will use the available orders to make processing a filtered database as efficient as possible.</description>
            </item>
            <item>
                <term>_SET_STRICTREAD</term>
                <description>
                    Returns and optionally changes the logical flag that determines whether the RDD will read records directly from disk when creating orders. <br/>
                    A FALSE setting indicates that the RDD will read records directly from disk when creating orders, which is the most efficient setting. <br/>
                    However, if you are using a DBF RDD layer that encrypts the database file, this setting will give incorrect results because the RDD will see the encrypted value rather than the actual value of the records. <br/>
                    In order to use the RDD with encryption packages, use DBServer:RDDInfo(_SET_STRICTREAD, TRUE). <br/>
                    This setting lets the DBF RDD layer read the records when creating an order.
                </description>
            </item>
        </list>
    </RddInfoRemarks>
</Comments>