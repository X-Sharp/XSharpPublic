<?xml version="1.0" encoding="utf-8"?>
<Runtimefunctions>
    <aclass>
        <summary>
            Places an object's class name and its ancestor class names into a variable array.
        </summary>
        <param name="ArrayName">
            Specifies the name of the array into which the class names are placed.
        </param>
        <param name="oExpression">
            Specifies an object whose class name and ancestor class names are placed into the array.
            oExpression can be any object expression, such as an object reference, an object variable, or an object array element.
        </param>
        <returns>Numeric</returns>
        <remarks>
            If you specify the name of an array that doesn't exist, X# automatically creates the array.
            If you specify the name of an existing array that isn't large enough to hold all the parent names, X# automatically increases the size of the array.
            If the array is larger than necessary, the array size is truncated. If you specify the name of an existing two-dimensional array,
            the array is redimensioned to a one-dimensional array. <br/> <br/>
            AClass( ) creates a one-dimensional array containing the class name of the specified object and its ancestor class names.
            The first array element contains the class name of the object, the second element contains the name of the object's parent class,
            the third element contains the name of the object's grandparent class, and so on. <br/>
            AClass( ) returns the number of class names in the array. AClass( ) returns 0 if the array cannot be created.<br/>
        </remarks>
        <example>
             <code language="X#">
                Clear
                frmMyForm = CreateObject("FormGrandChild")
                For nCount = 1 TO AClass(gaNewarray, frmMyForm)    &amp;&amp; Creates an array
                ? gaNewarray(nCount)  &amp;&amp; Displays the names of the classes
                ENDFor
                RELEASE frmMyForm
                DEFINE CLASS FormChild AS ForM
                ENDDEFINE
                DEFINE CLASS FormGrandChild AS FormChild
                ENDDEFINE
            </code>
        </example>
    </aclass>
    <adatabases>
        <summary>
            Places the names of all open databases and their paths into a variable array.
        </summary>
        <param name="ArrayName">
            Specifies the name of the array.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            The names of all open databases are placed into a variable array.<br/> <br/>
            If the array you specify doesn't exist, X# automatically creates the array.
            If the array exists and isn't large enough to contain all the database information,
            X# automatically increases the size of the array to accommodate the information. If the array is larger than necessary, X# truncates the array.
            If the array exists and ADatabases( ) returns 0 because no databases are open, an existing array remains unchanged.
            If the array doesn't exist, and ADatabases( ) returns 0, the array is not created.<br/><br/>
            ADatabases( ) creates a two-dimensional array. The first column of the array contains the names of the open databases,
            and the second column contains the paths to the databases.<br/>
            ADatabases( ) returns the number of database names (rows) in the array. If no databases are open, ADatabases( ) returns 0 and the array isn't created.<br/>
        </remarks>
        <example>
             <code language="X#">
                Set PATH TO (HOME(2) + 'data\')     &amp;&amp; Sets path to database
                Open Database testdata &amp;&amp; Opens the database
                Clear
                ? ADatabases(gaDatabase)     &amp;&amp; Creates an array of open databases
                Display MEMORY LIKE gadatabase  &amp;&amp; Displays the contents of the array
                Close Databases
            </code>
        </example>
    </adatabases>
    <adbobjects>
        <summary>
            Places the names of named connections, relations, tables, or SQL views in the current database into a variable array.
        </summary>
        <param name="ArrayName">
            Specifies the name of the array in which the names are placed.
        </param>
        <param name="cSetting">
            Specifies the names to place in the variable array. The table in the remarks section lists the values for cSetting and the corresponding names placed in the array:
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            A database must be open and current when ADBObjects( ) is issued; otherwise X# generates an error message.
            <list type="table">
                <listheader>
                    <term>Value</term>
                    <description>Name placed in array</description>
                </listheader>
                <item>
                    <term>Connection</term>
                    <description>Connection names</description>
                </item>
                <item>
                    <term>RELATION</term>
                    <description>Table relationships</description>
                </item>
                <item>
                    <term>Table</term>
                    <description>Table names</description>
                </item>
                <item>
                    <term>View</term>
                    <description>View names</description>
                </item>
            </list>
            The Connection, Relation, Table, and View settings cannot be abbreviated. <br/> <br/>
            ArrayName:  If the array you specify doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain all the names,
            X# automatically increases the size of the array to accommodate the names. If the array is larger than necessary, X# truncates the array.
            If the array exists and ADBObjects( ) returns 0 because no names are found, the array remains unchanged.
            If the array doesn't exist, and ADBObjects( ) returns 0, the array is not created. <br/><br/>
            A one-dimensional array is created when you specify Connection, Table, or View for cSetting.
            Each row in the one-dimensional array contains the name of a connection, table, or view in the database.<br/>
            A two-dimensional array is created when you specify Relation for cSetting.
            Each row in the two-dimensional array corresponds to a relationship in the database.
            The first column in an array row contains the name of the child table and the second column in an array row contains the name of the parent table.
            The third column contains the name of the index tag for the child table and the fourth column contains the name of the index tag for the parent table.<br/>
            The fifth column in an array row contains referential integrity information. This column is empty if the relation has no referential integrity rules.
            If the relationship does have referential integrity rules,
            the column contains characters corresponding to the type of referential integrity rules for updates, deletions, and insertions.<br/>
            The first character indicates the type of update rule, the second character indicates the type of deletion rule,
            and the third character indicates the type of insertion rule.<br/>
            Possible values for updates and deletions are "C" for cascade,
            "R" for restrict, and "I" for ignore. Possible values for insertions are "R" for restrict, and "I" for ignore.
            For example, if a relation has cascaded updates, restricted deletions, and ignores insertion referential integrity rules, the column contains "CRI".<br/>
        </remarks>
        <example>
             <code language="X#">
                * Close any open databases
                Close Databases
                * Clear desktop to prepare for displaying the array
                Clear
                * Open sample testdata database
                Open Database (HOME(2) + 'Data\testdata')
                * Function call with cSetting for table names
                =ADBObjects(gaTables, "Table")
                * Displays array gaTables created by ADBObjects( ) function
                Display MEMORY LIKE gaTables
            </code>
        </example>
    </adbobjects>

    <aelement>
        <summary>
            Returns the number of an array element from the element's subscripts.
        </summary>
        <param name="ArrayName">
            Specifies the name of the array whose element number you want to return.
        </param>
        <param name="nRowSubscript">
            Specifies the row subscript. If the array is one-dimensional, AElement( ) identically returns nRowSubscript.<br/>
            If you include just nRowSubscript and it is greater than the number of rows in the array, X# generates an error message.
        </param>
        <param name="nColumnSubscript">
            Specifies the column subscript. If the array is two-dimensional, include both nRowSubscript and nColumnSubscript.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            You can refer to an element in a two-dimensional array in one of two ways. The first method uses two subscripts to specify the row and column position
            of the element in the array, and the second method uses a single-element number.
            AElement( ) returns the element number when supplied with an element's row and column subscripts.<br/>
            The X# functions ADel( ), ADir( ), AFields( ), AIns( ), ALen( ), AScan( ), ASort( ), and ASubscript( ) can manipulate two-dimensional arrays
            and require that elements be referred to by their element number. AElement( ) facilitates conversion from subscripts to an element number
            for use by these functions. The corresponding row and column subscripts can be returned from an element number with ASubscript( ).<br/>
            The following example illustrates the creation of an array with two rows and three columns. Display MEMORY shows the contents
            of the elements of the array listed in element number order.
             <code language="X#">
                DIMENSION gaMyArray(2,3)
                Display MEMORY LIKE gaMyArray
                gaMyArray   Pub  A
                ( 1, 1)   L  .F. (element number 1)
                ( 1, 2)   L  .F. (element number 2)
                ( 1, 3)   L  .F. (element number 3)
                ( 2, 1)   L  .F. (element number 4)
                ( 2, 2)   L  .F. (element number 5)
                ( 2, 3)   L  .F. (element number 6)
            </code>
            An element can be referred to by its subscripts or its element number. The commands <c>STORE 'INVOICE' TO gaMyArray(2, 1)</c> and
            <c>STORE 'INVOICE' TO gaMyArray(4)</c> both store the character string INVOICE to the same array element.<br/>
            In one-dimensional arrays, an element number is identical to its single-row subscript. It isn't necessary to use AElement( ) with one-dimensional arrays.
        </remarks>
    </aelement>
    <agetfileversion>
        <summary>
            Creates an array containing information about files with Windows version resources such as .exe, .dll, and .fll files, or automation servers created in X#.
            For a X# automation server to have Windows version resources, you must specify a value for at least one item in the EXE Version dialog box.
            For more information, see EXE Version Dialog Box.
        </summary>
        <param name="ArrayName">
            Specifies the name of the array in which the file information is placed. If the array you specify doesn't exist, X# automatically creates the array.
            If the array exists and isn't large enough to contain the file information, X# automatically increases the size of the array.
            If the array is larger than necessary, X# truncates the array.
        </param>
        <param name="cFileName">
            Specifies the name, and optionally the path, of the target file.
        </param>
        <returns>
            Numeric. <b>AGetfileversion( )</b> returns the number of elements in the array.
            If the file you specify does not exist or does not contain Windows version resources,
            <b>AGetfileversion( )</b> returns zero, and the array, if already created, remains unchanged.
        </returns>
        <remarks>
            The table below lists the contents of each element of the array.
            For example, you can use the following code to determine the Locale ID for the X# executable file:
             <code language="X#">
                DIMENSION aFiles[1]
                AGetfileversion(aFiles,"VFP9.EXE")
                ? EVAL("0x"+LEFT(aFiles[15],4))
                ** Returns 1033 for US version
            </code>
            <list type="table">
                <listheader>
                    <term>element of the array</term>
                    <description>contents</description>
                </listheader>
                <item>
                    <term>1</term>
                    <descripton>Comments</descripton>
                </item>
                <item>
                    <term>2</term>
                    <descripton>Company Name</descripton>
                </item>
                <item>
                    <term>3</term>
                    <descripton>File Description</descripton>
                </item>
                <item>
                    <term>4</term>
                    <descripton>File Version</descripton>
                </item>
                <item>
                    <term>5</term>
                    <descripton>Internal Name</descripton>
                </item>
                <item>
                    <term>6</term>
                    <descripton>Legal Copyright</descripton>
                </item>
                <item>
                    <term>7</term>
                    <descripton>Legal Trademarks</descripton>
                </item>
                <item>
                    <term>8</term>
                    <descripton>Original File Name</descripton>
                </item>
                <item>
                    <term>9</term>
                    <descripton>Private Build</descripton>
                </item>
                <item>
                    <term>10</term>
                    <descripton>Product Name</descripton>
                </item>
                <item>
                    <term>11</term>
                    <descripton>
                        Product Version
                        The format of this value is dependent on the version of X#. For details, see VERSION( ) Function.
                    </descripton>
                </item>
                <item>
                    <term>12</term>
                    <descripton>Special Build</descripton>
                </item>
                <item>
                    <term>13</term>
                    <descripton>OLE Self Registration (contains "OLESelfRegister" if the file supports self-registration; otherwise contains the empty string)</descripton>
                </item>
                <item>
                    <term>14</term>
                    <descripton>Language (derived from the Translation Code)</descripton>
                </item>
            </list>
            <b>AGetfileversion( )</b> can be abbreviated to a minimum number of 5 characters.
        </remarks>
    </agetfileversion>
    <alines>
        <summary>
            Copies each line in a character expression or memo field to a corresponding row in an array.
        </summary>
        <param name="ArrayName">
            Specifies the name of the array to store the copied lines in the character expression or memo field.
        </param>
        <param name="cExpression">
            Specifies the character expression or memo field containing the lines to copy to the array. All character expressions are case-sensitive.
            If cExpression is the empty string or the null value, an array with a single row is created and the row contains the empty string.
            You can use double-byte expressions.
        </param>
        <param name="nFlags">
            In previous versions of X#, nFlags was the lTrim option. The lTrim option corresponds to a value of 1 for nFlag. Previous code will run identically in X# 9.0.
            The table below describes the values for nFlags.
        </param>
        <param name="cParseChar">
            Specifies one or more character strings that terminate the elements in cExpression.
        </param>
        <param name="cParseChar2">
            Specifies one or more character strings that terminate the elements in cExpression.
        </param>
        <returns>
            Numeric. <b>ALines( )</b> returns the number of rows in the array, or, identically, the number of lines in the character expression or memo field.
        </returns>
        <remarks>
            If the array you specify does not exist, X# automatically creates the array.
            If the array exists but is not large enough to contain all the lines in the memo field, X# automatically increases the size of the array.
            If the array is larger than necessary, X# truncates the array.<br/><br/>
            <list type="table">
                <listheader>
                    <term>Bit</term>
                    <description>Value</description>
                    <description>Descripton</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>1</description>
                    <description>(Default) Removes leading and trailing spaces from lines, or for Varbinary and Blob values, removes trailing zeroes (0) instead of spaces.</description>
                </item>
                <item>
                    <term>1</term>
                    <description>2</description>
                    <description>Include the last element in the array even if the element is empty.</description>
                </item>
                <item>
                    <term>2</term>
                    <description>4</description>
                    <description>Do not include empty elements in the array.</description>
                </item>
                <item>
                    <term>3</term>
                    <description>8</description>
                    <description>Specifies case-insensitive parsing.</description>
                </item>
                <item>
                    <term>4</term>
                    <description>16</description>
                    <description>Include the parsing characters in the array.</description>
                </item>
            </list>
            When used with binary values, such as <b>Varbinary</b> and <b>Blob</b>, <b>ALines( )</b> creates an array with elements that have <b>Varbinary</b> type.<br/><br/>
            When cParseChar is specified, the line breaks when cParseChar is found, and the next line continues with the character following cParseChar.<br/>
            The maximum number of strings permitted in cParseChar is 23.<br/>
            You can use a line feed (CHR(10)) or carriage return (CHR(13)) character to denote the end of a line.
            You can also denote the end of the line with either combination of these two characters, for example, (CHR(10) + CHR(13) or CHR(13) + CHR(10)).
            The default behavior for <b>ALines( )</b> is to ignore CHR(13) and CHR(10) when you specify one or more values for cParseChar,
            unless you also specify the end of line characters.<br/>
            When cParseChar is omitted for <b>Varbinary</b> or <b>Blob</b> input, <b>ALines( )</b> treats the hexadecimal value 0hA (10) as a carriage return
            and discontinues the line at that location. The value, 0hA, is not saved in the resulting array element and might result in an incorrect binary value.
            For example, given the binary value, 0hFE0AF2, <b>ALines( )</b> creates a two-element array with the values, 0hFE and 0hF2.<br/>
            <b>ALines( )</b> provides an easy way to parse lines in a character expression or memo field.
            While you can also use <b>MLINES( )</b> to parse a character expression or memo field, <b>ALines( )</b> is faster and requires less programming.
            Also, <b>ALines( )</b> is not affected by the value of <b>Set MEMOWIDTH</b>.<br/>
            The first line of the character expression or memo field is copied to the first row of the array,
            the second line of the character expression or memo field is copied to the second row of the array, and so on.<br/>
            You must have sufficient memory to copy the lines in a large memo field to an array. X# generates an error message if you lack sufficient memory.<br/>
            If you want to perform a case-insensitive parse, you can follow one of the following examples:
             <code language="X#">? ALines(aMyArray, UPPER(employee.notes), "R.") </code>
            - OR -
             <code language="X#">? ALines(aMyArray, employee.notes, "R.", "r.")</code>
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Clear
                Open Database (HOME(2) + "data\testdata")
                Use employee  &amp;&amp; Open Employee table
                ? ALines(aMyArray, employee.notes)            &amp;&amp; Displays 1
                ? ALines(aMyArray, employee.notes, CHR(13))   &amp;&amp; Displays 1
                ? ALines(aMyArray, employee.notes, " ")       &amp;&amp; Displays 75
                ? ALines(aMyArray, employee.notes, ".")       &amp;&amp; Displays 7
                ? ALines(aMyArray, employee.notes, ",")       &amp;&amp; Displays 4
                ? ALines(aMyArray, employee.notes, ".", ",")  &amp;&amp; Displays 10
                ? ALines(aMyArray, employee.notes, 8, "m")    &amp;&amp; Displays 14
                ? ALines(aMyArray, employee.notes, "m")       &amp;&amp; Displays 11
                ? ALines(aMyArray, employee.notes, "M")       &amp;&amp; Displays 4
            </code>
        </example>
    </alines>
    <amembers>
        <summary>
            Places the names of properties, procedures, and member objects for an object into a variable array.
        </summary>
        <param name="ArrayName">
            Specifies the array into which the names of the member properties for oObjectName are placed.
            If you specify the name of an array that doesn't exist, the array is automatically created.
            If the array isn't large enough to contain all the names, X# automatically increases the size of the array.
        </param>
        <param name="oObjectNameOrClassName">
            Specifies the object or X# class whose member properties are placed in the variable array specified with ArrayName.
            This can be any expression that evaluates to an object, such as an object reference, an object variable, or an object array element.<br/>
        </param>
        <param name="nArrayContentsID">
            Specifies the contents of an array.
        </param>
        <param name="cFlags">
            Specify the filtering applied to the array returned by the AMembers( ) function.
            cFlags will not function when AMembers( ) is passed a COM object (the value of ArrayContentsID is 3).
            Some flags are mutually exclusive so that if you use more than one cFlag, use them in the following groupings:
            <code>[P | H | G] [N | U] [C] [I | B] [R]</code>
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            <list type="table">
                <listheader>
                    <term> </term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>
                        Specifies that the array contains a single column of property names. Omitting the nArrayContentsID parameter is the same as passing a 0.
                    </description>
                </item>
                <item>
                    <term>1</term>
                    <description>
                        Specifies that the array contains the names of the properties of the object or class, as well as the methods and member objects.
                        The resulting array is two-dimensional with the second column specifying what type of member is listed in the first column.
                        The possible values for the second column are Property, Event, Method, or Object.
                    </description>
                </item>
                <item>
                    <term>2</term>
                    <description>
                        Specifies that the array contains the names of objects that are members of a native X# object specified with oObjectName. The resulting array is one-dimensional.
                        This option provides a method to determine the names of child objects in a container such as all Form objects in a form set or controls in a form.
                    </description>
                </item>
                <item>
                    <term>3</term>
                    <description>
                        Specifies that the array contains information about one or more objects. You can pass an object reference to either a native X# object or to a COM object.
                        <note>A value of 3 for this parameter is not supported in .app or .exe applications.</note>
                    </description>
                </item>
            </list>
            The array returned when you specify this parameter consists of four columns as described in the table in the remarks section:
            <list type="table">
                <listheader>
                    <term>Column</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>Name of the event or method</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Property type (for example, PROPERTYPUT, PROPERTYGET, PROPERTYPUTREF, METHOD)</description>
                </item>
                <item>
                    <term>3</term>
                    <description>
                        Function signature (parameters and their types, and the function return type).
                        This information is similar to the Quick Info text provided in IntelliSense expansion of a method.
                    </description>
                </item>
                <item>
                    <term>4</term>
                    <description>Help string</description>
                </item>
            </list>
            If you omit nArrayContentsID, AMembers( ) returns a one column array of properties.<br/><br/>
            The tables below describe the valid values for cFlags.
            <list type="table">
                <listheader>
                    <term>Value</term>
                    <description>Filter Flags</description>
                </listheader>
                <item>
                    <term>P</term>
                    <description>Protected properties, methods, or events</description>
                </item>
                <item>
                    <term>H</term>
                    <description>Hidden properties, methods, or events</description>
                </item>
                <item>
                    <term>G</term>
                    <description>Public properties, methods, or events</description>
                </item>
                <item>
                    <term>N</term>
                    <description>Native (Intrinsic) properties, methods, or events</description>
                </item>
                <item>
                    <term>U</term>
                    <description>User-Defined (Extrinsic) properties, methods, or events</description>
                </item>
                <item>
                    <term>C</term>
                    <description>Changed properties (but not changed array properties)</description>
                </item>
                <item>
                    <term>I</term>
                    <description>Inherited properties, methods, or events</description>
                </item>
                <item>
                    <term>B</term>
                    <description>Base properties, methods, or events (using the AddProperty method)</description>
                </item>
                <item>
                    <term>R</term>
                    <description>Read-Only Properties</description>
                </item>
            </list>
            The default configuration for the filtering specified by cFlags is logical OR between flags. You can change this by using the special "+" cFlags.
            <list type="table">
                <listheader>
                    <term>Value</term>
                    <description>Special Flags</description>
                </listheader>
                <item>
                    <term>#</term>
                    <description>Adds a new column to the output array with the corresponding cFlags value.</description>
                </item>
                <item>
                    <term>+</term>
                    <description>Performs logical AND between filter flags.</description>
                </item>
            </list>
            AMembers( ) returns the number of objects, properties, and procedures for the object, or 0 if the array cannot be created.
            If you omit the optional 1, 2, or 3 flag parameters, a one-dimensional array is created containing the properties of oObjectName.
            You can pass COM object references to the AMembers( ) function, but when you do so, you must also pass a value of 3 in the third (flag) parameter,
            as in the following example.
             <code language="X#">
                oExcel = CreateObject("excel.application")
                = AMembers(gaPropArray, oExcel, 3)
            </code>
        </remarks>
        <example>
             <code language="X#">
                Clear
                goForm1 = CreateObject("Form")  &amp;&amp; Creates a Form
                = AMembers(gaPropArray, goForm1, 1)  &amp;&amp; Array containing Form properties
                Display MEMORY LIKE gaPropArray  &amp;&amp; Display the Form properties
            </code>
        </example>
    </amembers>
    <anetresources>
        <summary>
            Places the names of network shares or printers into an array and then returns the number of resources.
        </summary>
        <param name="ArrayName">
            Specifies the name of the array containing the network share or printer information.
        </param>
        <param name="cNetworkName">
            Specifies the name of the network or domain for which share or printer information is returned.
        </param>
        <param name="nResourceType">
            Specifies the type of network resource for which information is returned.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            If the array you specify doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain all the information,
            X# automatically increases the size of the array to accommodate the information. If the array is larger than necessary, X# truncates the array.<br/>
            If the array exists and ANetResources( ) returns 0 because no network shares or printers are found, the array remains unchanged.
            If the array doesn't exist and ANetResources( ) returns 0, the array isn't created.<br/>
            The network name should be in the format "\\NetworkName." You do not have to be connected to the network you specify,
            and specifying a network doesn't connect you to the network.
            If you specify a domain name, ANetResources( ) returns an array of members or resources from that domain.<br/>
            The names of shares on the network are returned if nResourceType evaluates to 1.
            The names of printers on the network are returned if nResourceType evaluates to 2. A value of 0 returns the name of any resource.<br/>
            ANetResources( ) returns the number of network shares or printers found (identical to the number of rows in the array).
            ANetResources( ) returns zero if there are no shares or printers for the network of the type you specify, or the network you specify doesn't exist.<br/>
            Before Windows 2000, share names were limited to twelve characters in length.
            If you run ANetResources() on a computer that uses an operating system earlier than Windows 2000,
            ANetResources() will not return any shares that are on computers running Windows 2000 or later that have share names longer than twelve characters.<br/>
            Refer to the WNetOpenEnum and WNetEnumResource Win32 API functions for more details.
        </remarks>
    </anetresources>
    <aprinters>
        <summary>
            Stores information about currently-available printers into an array.<br/>
            The behavior of this function is OS (operating system) - specific.
            X# may or may not check to see if the printers are actually connected to your computer when it prepares this list,
            and the list may include all printers installed as printer setups, or only those available on the current network.
        </summary>
        <param name="ArrayName">
            Specifies the name of the array containing information about printers.
        </param>
        <param name="nValue">
            Specifies a value that creates a two-column array or five-column array. Each row in the array contains information about a printer.<br/>
            The table in the remarks section describes the possible values of nValue.
        </param>
        <remarks>
            If the array you include does not exist, X# automatically creates the array. If the array exists but is not large enough to contain all the information,
            X# increases the size of the array to accommodate the information. If the array is larger than necessary, X# truncates the array.
            If the array exists but <b>APRINTERS( )</b> returns 0 because no printers are available, the array remains unchanged.
            If the array does not exist, and <b>APRINTERS( )</b> returns 0, the array is not created.<br/><br/>
            <list type="table">
                <listheader>
                    <term>nValue</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>0 or omitted</term>
                    <description>
                        Return a two-column array containing the following items beginning with the first column:
                        <list type="bullet">
                            <item>
                                <description>Printer name.</description>
                            </item>
                            <item>
                                <description>Name of the port to which the printer is connected.</description>
                            </item>
                        </list>
                    </description>
                </item>
                <item>
                    <term>1</term>
                    <description>
                        Return a five-column array containing the following items beginning with the first column:
                        <list type="bullet">
                            <item>
                                <description>Printer name.</description>
                            </item>
                            <item>
                                <description>Name of the port to which the printer is connected.</description>
                            </item>
                            <item>
                                <description>Name of the printer driver.</description>
                            </item>
                            <item>
                                <description>Printer comment.</description>
                            </item>
                            <item>
                                <description>Printer location.</description>
                            </item>
                        </list>
                    </description>
                </item>
            </list>
        </remarks>
        <returns>
            Numeric. <b>APRINTERS( )</b> returns the number of rows in the array or 0 when no printers are available.
        </returns>
        <example>
             <code language="X#">
                IF APRINTERS(gaPrinters) &gt; 0
                Clear  &amp;&amp; clear the current output window
                Display MEMORY LIKE gaPrinters &amp;&amp; show the contents of the array
                ELSE
                WAIT 'No printers found.'
                ENDIF
            </code>
        </example>
    </aprinters>
    <asessions>
        <summary>
            Creates an array of existing data session IDs.
        </summary>
        <param name="ArrayName">
            Specifies the array that contains the data session IDs.
        </param>
        <returns>
            Numeric. Returns the number of data sessions.
        </returns>
        <remarks>
            If the array does not exist, X# automatically creates and populates it. X# automatically resizes the array to accommodate current data sessions.
        </remarks>
    </asessions>

    <astackinfo>
        <summary>
            Creates an array and populates it with information about the current state of the call stack.
        </summary>
        <param name="ArrayName">
            Specifies the name of the array to store information about the call stack.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            The following table describes the information returned by the AStackInfo( ) function:
            <list type="table">
                <listheaders>
                    <term>Array Element</term>
                    <description>Description</description>
                </listheaders>
                <item>
                    <term>1</term>
                    <description>Call Stack Level</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Current program filename</description>
                </item>
                <item>
                    <term>3</term>
                    <description>Module or Object name</description>
                </item>
                <item>
                    <term>4</term>
                    <description>Module or Object Source filename</description>
                </item>
                <item>
                    <term>5</term>
                    <description>Line number in the object source file</description>
                </item>
                <item>
                    <term>6</term>
                    <description>Source line contents</description>
                </item>
            </list>
            <br/>
            AStackInfo( ) populates an array with information about the entire calling stack.
            It combines functionality of SYS(16) and Program( ) functions while adding new support for line numbers at each call stack level.
            The value returned is the number of program levels or rows of the returned array.<br/>
            AStackInfo( ) only populates the 6th array element if source line contents are available, otherwise it will be left empty.<br/>
            AStackInfo( ) provides, in the 2nd and 4th elements respectively, the name of the current file and,
            if the file is bound in an APP or other separate file, a full path name to the binding program.<br/>
            The 4th element contains the original source file information.
            For objects, this is same information returned by SYS(16), even when bound inside of applications.<br/>
            AStackInfo() might not be able to retrieve information about program (.prg) files.
            In this case, X# displays the 2nd element similar to the SYS(16) function. For more information, see SYS(16) - Executing Program File Name.
        </remarks>
        <example>
             <code language="X#">
                AStackInfo(myarray)
                Display MEMO LIKE myarray
                myArray
                (1,1)   1                                    &amp;&amp; Stack level = 1
                (1,2)   c:\vfp\myAppl.app                        &amp;&amp; Current program
                (1,3) frmRerport.PrintReport.Click         &amp;&amp; Object
                (1,4) c:\vfp\myclasses\buttons.vct         &amp;&amp; Object source file name
                (1,5) 42                              &amp;&amp; Line number in the source
                (1,6) THISForM.DoReport()                  &amp;&amp; in the source
                (2,1)   2                                    &amp;&amp; Stack level = 2
                (2,2) c:\vfp\myAppl.app
                (2,3) frmRerport.DoReport
                (2,4) c:\vfp\forms\frmRerport.sct         &amp;&amp; Module source file name
                (2,5) 31
                (2,6) DO RunListReport                     &amp;&amp; in the source
                (3,1)   3                                    &amp;&amp; Stack level = 3
                (3,2) c:\vfp\myAppl.app
                (3,3)
                (3,4) c:\vfp\programs\runlisterport.prg   &amp;&amp; Module source file name
                (3,5) 12
                (3,6) REPORT ForM myreport1.frx            &amp;&amp; in the source
                (4,1)   4                                    &amp;&amp; Stack level = 4
                (4,2) c:\vfp\reports\myreport1.frt
                (4,3) myreport1.DataEnvironment.BeforeOpenTables
                (4,4) c:\vfp\reports\myreport1.frt          &amp;&amp; Module source file name
                (4,5) 31
                (4,6) DO ForM getcusts                     &amp;&amp; in the source
                (5,1)   5                                    &amp;&amp; Stack level = 5
                (5,2) c:\vfp\myAppl.app
                (5,3) getcusts.init
                (5,4) c:\vfp\forms\getcusts.sct            &amp;&amp; Module source file name
                (5,5) 2
                (5,6) AStackInfo(myarray)                  &amp;&amp; in the source
            </code>
        </example>
    </astackinfo>
    
    <at>
        <summary>
            Searches a character expression for the occurrence of another character expression.
            The search performed by <b>AT( )</b> is case-sensitive. To perform a search that is not case-sensitive, use <b>ATC( )</b>.
            For more information, see ATC( ) Function.
        </summary>
        <param name="cSearchExpression">
            Specifies the character expression to search for in cExpressionSearched.
        </param>
        <param name="cExpressionSearched">
            Specifies the character expression to search for cSearchExpression.
            Both cSearchExpression and cExpressionSearched can be memo fields of any size.
        </param>
        <param name="nOccurrence">
            Specifies which occurrence, first, second, third, and so on, of cSearchExpression to search for in cExpressionSearched.
            By default, <b>AT( )</b> searches for the first occurrence of cSearchExpression (nOccurrence = 1).
        </param>
        <returns>
            Numeric. <b>AT( )</b> returns an integer indicating the position of the first character for a character expression or memo field within another
            character expression or memo field, beginning from the leftmost character. If the expression or field is not found,
            or if nOccurrence is greater than the number of times cSearchExpression occurs in cExpressionSearched, <b>AT( )</b> returns 0.
        </returns>
        <example>
             <code language="X#">
                STORE 'Now is the time for all good men' TO gcString
                STORE 'is the' TO gcFindString
                Clear
                ? AT(gcFindString,gcString)  &amp;&amp; Displays 5
                STORE 'IS' TO gcFindString
                ? AT(gcFindString,gcString)  &amp;&amp; Displays 0, case-sensitive
            </code>
        </example>
    </at>
    <ataginfo>
        <summary>
            Creates an array that contains information about index files for the selected table.
        </summary>
        <param name="ArrayName">
            Specifies the name of the array to create. X# creates the array if it does not already exist.
        </param>
        <param name="cCDXName">
            Specifies the name of the compound index (.cdx) file to return information for.
            Specifying an empty string ("") returns the number of tags in all open .cdx files and all open standalone index (.idx) files for the selected table.
        </param>
        <param name="uArea">
            Specifies the work area number or workarea alias that contains the table to returns information for. <br/>
            Omitting this uses the table in the current work area.
        </param>
        <returns>
            Numeric. <b>ATagInfo( )</b> returns the number of index tags in compound index (.cdx) files
            or open single-key standalone index (.idx) files for the current table.
        </returns>
        <remarks>
            The following table describes the information stored in the array that <b>ATagInfo( )</b> creates.
            <list type="table">
                <listheader>
                    <term>Column</term>
                    <description>Description</description>
                    <description>Data type</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>Index tag name in a .cdx file or index file name for .idx files</description>
                    <description>Character</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Index tag type</description>
                    <description>Character</description>
                </item>
                <item>
                    <term>3</term>
                    <description>Index key expression</description>
                    <description>Character</description>
                </item>
                <item>
                    <term>4</term>
                    <description>Filter expression</description>
                    <description>Character</description>
                </item>
                <item>
                    <term>5</term>
                    <description>Index order as created (Ascending or Descending)</description>
                    <description>Character</description>
                </item>
                <item>
                    <term>6</term>
                    <description>Collate sequence</description>
                    <description>Character</description>
                </item>
            </list>
        </remarks>
    </ataginfo>
    <atc>
        <summary>
            Returns the beginning numeric position of the first occurrence of a character expression or memo field within another character expression or memo field,
            without regard for the case of these two expressions.
        </summary>
        <param name="cSearchExpression">
            Specifies the character expression that ATC( ) searches for in <paramref name='cExpressionSearched' />.
        </param>
        <param name="cExpressionSearched">
            Specifies the character expression <paramref name='cSearchExpression' /> searches for.
            Both <paramref name='cSearchExpression' /> and <paramref name='cExpressionSearched' /> can be memo fields of any size.
        </param>
        <param name="nOccurrence">
            Specifies which occurrence (first, second, third, and so on) of <paramref name='cSearchExpression' /> is searched for in <paramref name='cExpressionSearched' />.
            By default, ATC( ) searches for the first occurrence of <paramref name='cSearchExpression' /> (nOccurrence = 1).
            Including nOccurrence lets you search for additional occurrences of <paramref name='cSearchExpression' /> in <paramref name='cExpressionSearched' />.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            ATC( ) searches the second character expression for the occurrence of the first character expression,
            without concern for the case (upper or lower) of the characters in either expression. Use AT( ) to perform a case-sensitive search.
            ATC( ) returns an integer corresponding to the position where the first character of the character expression is found.
            If the character expression isn't found, ATC( ) returns 0.
        </remarks>
        <example>
             <code language="X#">
                STORE 'Now is the time for all good men ... ' TO gcString
                STORE 'IS THE' TO gcFindString
                Clear
                ? ATC(gcFindString, gcString)  &amp;&amp; Displays 5
                STORE 'is' TO gcFindString
                ? ATC(gcFindString, gcString)  &amp;&amp; Displays 5
                ? ATC('now',gcString)  &amp;&amp; Displays 1
            </code>
        </example>
    </atc>
    <aused>
        <summary>
            Places table aliases and work areas for a data session into a variable array.
        </summary>
        <param name="ArrayName">
            Specifies the name of the array containing the table aliases and work areas for a data session.
        </param>
        <param name="nDataSessionNumber">
            Specifies the data session number for which <b>AUsed( )</b> returns the table aliases and work areas.
            If you omit nDataSessionNumber, <b>AUsed( )</b> returns information about the current data session.
            Use <b>Set DATASESSION</b> to specify the current data session.
        </param>
        <param name="cTableName">
            The array will only contain aliases of the table specified with cTableName.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            If the array you specify does not exist, X# automatically creates the array.
            If the array exists and is not large enough to contain all the table aliases and work areas, X# automatically increases the size of the array.
            If the array is larger than necessary, X# truncates the array. If the array exists,
            and <b>AUsed( )</b> returns 0 because no tables are open in the data session, the array remains unchanged. If the array does not exist,
            and <b>AUsed( )</b> returns 0, the array is not created.<br/><br/>
            The current data session is used if you set nDataSessionNumber to the null value (.NULL.).<br/>
            cTableName can be in the following formats, listed in the order in which X# searches for tables.<br/>
            <list type="bullet">
                <term>DatabaseName!TableName or DatabaseName!ViewName.</term>
                <term>Path\DatabaseName!TableName or Path\DatabaseName!ViewName.</term>
                <term>Database container (DBC) defined table name or view in the current DBC in the data session.</term>
                <term>Simple or full table name.</term>
            </list>
            <br/>
            <b>AUsed( )</b> returns the number of rows in the array, which is identical to the number of tables open in the data session.<br/><br/>
            <b>AUsed( )</b> creates a two-dimensional array and places the aliases of tables open for the data session in the first column of the array.
            The second column of the array contains the tables' corresponding work area numbers.<br/>
            The table aliases are placed into the array in reverse order that they were opened in. For example, the first array element contains the alias
            of the last table opened, and the last array element contains the alias of the first table opened.
            This ordering is useful when using <b>TableUpdate( )</b> on views that contain views. For example:<br/>
             <code language="X#">
                For x = 1 TO AUsed(aTableAliases,1)
                IF CursorGetProp( "Buffering", aTableAliases(x) ) &gt; 1 &amp;&amp; Buffered
                ? TableUpdate( 0, .T., aTableAliases(x) )
                ENDIF
                Next
            </code>
        </remarks>
        <example>
             <code language="X#">
                Open Database (HOME(2) + 'Data\testdata') EXCLUSIVE
                Use Customer IN 0
                Clear
                ? AUsed(gaInuse)
                Display MEMORY LIKE gaInuse
                Close Databases
            </code>
        </example>
    </aused>
    <bintoc>
        <summary>
            Converts a numeric value to a binary character representation.
        </summary>
        <param name="nExpression">
            Specifies the value to convert. For eFlags settings 1, 2 or 4, this value is an integer. Otherwise, the expression data type is based on the eFlags setting.
        </param>
        <param name="eFlags">
            Specifies the length in characters of the returned character string.
        </param>
        <returns>
            Character. BinToc( ) returns a binary character expression.
        </returns>
        <remarks>
            eFlags determines the value you can specify for nExpression. eFlags can either be numeric or character.
            The following table lists the permissible values for eFlags and the corresponding range of values for nExpression:<br/>
            <list type="table">
                <listheader>
                    <term>eFlags</term>
                    <description>nExpression Range</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>128 to 127</description>
                </item>
                <item>
                    <term>2</term>
                    <description>32,768 to 32,767</description>
                </item>
                <item>
                    <term>4</term>
                    <description>
                        2,147,483,648 to 2,147,483,647 <br/>
                        This is default setting.
                    </description>
                </item>
                <item>
                    <term>8</term>
                    <description>
                        The range of nExpression depends on its type. Only numeric, float, double, and currency data types are supported with this option.
                        See X# Data and Field Types for the ranges of the numeric, float, double, and currency data types.<br/>
                        BinToc( ) returns 8 bytes for this setting.
                    </description>
                </item>
                <item>
                    <term>F</term>
                    <description>nExpression is interpreted as a Float Field Type and BinToc( ) returns 4 bytes.</description>
                </item>
                <item>
                    <term>B</term>
                    <description>nExpression is interpreted as a Double Field Type and BinToc( ) returns 8 bytes.</description>
                </item>
                <item>
                    <term>R</term>
                    <description>Reverses the resulting binary expression.</description>
                </item>
                <item>
                    <term>S</term>
                    <description>Prevents the sign bit of number from being toggled (BitXOR).</description>
                </item>
            </list>
            If this parameter is omitted, BinToc( ) returns a character string composed of four characters.<br/>
            <br/>
            The eFlags parameter can either be numeric or character. The 'R' and 'S' settings are additive while the others are mutually exclusive.
            Character settings can be passed in either upper or lower case (e.g., 'R' or 'r'). The following examples show various uses of the eFlags parameter.
             <code language="X#">
                ? BinToc(1,1)
                ? BinToc(1000,"2")&amp;&amp; same as BinToc(1000,2)
                ? BinToc($12.34,8)
                ? BinToc(1, "4RS")&amp;&amp; same as BinToc(1,"RS")
                ? BinToc(-100, "Fr")
            </code>
            You can use BinToc( ) to reduce the size of indexes for numeric fields containing integer data by passing a numeric eFlags parameter.
            For example, a numeric field named <c>nPartCode</c> might contain an integer value from 1 to 32,767, which corresponds to a parts classification code.
            BinToc( ) lets you convert the value in the numeric field to a smaller character representation. For example,
            the following command creates an index with a two-character index key:
             <code language="X#">Index ON BinToc(nPartCode,2) TAG PartCode</code>
            When using BinToc( ) for an 8 byte index creation, you should use 8 and not "B". For 4 byte results, you should use 4 if nExpression is an integer type.
            Otherwise, you should use 'F' for floating point type.
            BinToc( ) can also be used when working with Win32 API routines where you might need to convert to or from a Win32 struct member. When used for indexing,
            BinToc( ) needs to properly handle negative numbers for the resulting binary expression. This is done by using a BitXOR operation on the high bit.
            This also means that the most significant byte is first. For Win32 API routines on an Intel platform,
            the architecture follows the little-endian rule where the least significant byte is stored first (memory location with lowest address).
            The 'R' and 'S' settings allow you to use BinToc( ) to work more efficiently with routines that use structs.
        </remarks>
    </bintoc>
    <bitand>
        <summary>
            Performs a bitwise AND operation on two or more values of <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> type and returns the result.
            There is a numeric and a binary version of the syntax.
        </summary>
        <param name="Arg1">
            Specifies Varbinary or Blob values to perform the bitwise AND operation.
        </param>
        <param name="Arg2">
            Specifies Varbinary or Blob values to perform the bitwise AND operation.
        </param>
        <returns>
            <b>Numeric</b> or <b>Varbinary</b>. <b>BitAnd( )</b> returns the result of the bitwise AND operation performed on the specified expressions.
            For <b>Varbinary</b> or <b>Blob</b> values, the return value is calculated as if all values are padded with 0h00 on the right of the value
            up to the length of the longest value. The appropriate operation is then performed between those values.
        </returns>
        <remarks>
            <note>
                You can specify a maximum of 26 values. The specified values must have the same type. If the specified expressions are not integers,
                they are converted to integers before performing the operation.
            </note><br/>
            <b>BitAnd( )</b> compares each bit in eExpressionN to the corresponding bit in eExpressionN+1. If the bits in eExpressionN and eExpressionN+1 are both 1,
            the corresponding result bit is set to 1; otherwise, the corresponding result bit is set to 0.<br/>
            The following table shows the result of a bitwise AND operation on corresponding eExpressionN and eExpressionN+1 bits:
            <list type="table">
                <listheader>
                    <term>eExpressionN bit</term>
                    <description>eExpressionN+1 bit</description>
                    <description>Resulting bit</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>0</description>
                    <description>0</description>
                </item>
                <item>
                    <term>0</term>
                    <description>1</description>
                    <description>0</description>
                </item>
                <item>
                    <term>1</term>
                    <description>1</description>
                    <description>1</description>
                </item>
                <item>
                    <term>1</term>
                    <description>0</description>
                    <description>0</description>
                </item>
            </list>
        </remarks>
        <example>
             <code language="X#">
                x = 3  &amp;&amp; 0011 binary
                y = 6  &amp;&amp; 0110 binary
                ? BitAnd(x,y) &amp;&amp; Returns 2, 0010 binary
            </code>
        </example>
    </bitand>
    <bitclear>
        <summary>
            Clears the specified bit in a <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> value by setting it to 0 and returns the resulting value.
            There is a numeric and a binary version of the syntax.
            If the specified expression is not an integer, it is converted to an integer before performing the operation.
        </summary>
        <param name="Arg1">
            Specifies the <b>Numeric</b> value or <b>Varbinary</b> or <b>Blob</b> expression to clear the bit in. If the expression is not an integer, it is converted to an integer before setting the bit.
        </param>
        <param name="Num">
            Specifies the <b>Numeric</b> value to clear the bit in. If the expression is not an integer, it is converted to an integer before setting the bit.
        </param>
        <param name="Bit">
            Specifies the bit position in nExpression1 to clear. nExpression2 can range from 0 to 31 with 0 located as the bit to the farthest right.
        </param>
        <param name="BinString">
            Specifies a <b>Varbinary</b> or <b>Blob</b> expression.
        </param>
        <param name="StartBit">
            Specifies a starting zero-based number of the first bit to perform the operation as nStartBit and the number of bits to perform the operation as nBitCount.<br/>
            If you do not specify nStartBit and nBitCount, the operation applies to all bits in the expression.
            If you specify nStartBit only, the operation applies to nStartBit only.
        </param>
        <param name="BitCount">
            Specifies a starting zero-based number of the first bit to perform the operation as nStartBit and the number of bits to perform the operation as nBitCount.<br/>
            If you do not specify nStartBit and nBitCount, the operation applies to all bits in the expression.
            If you specify nStartBit only, the operation applies to nStartBit only.
        </param>
        <returns>
            <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b>. <b>BitClear( )</b> returns the specified expression without specified bit.
        </returns>
        <example>
             <code language="X#">
                x = 7  &amp;&amp; 0111 binary
                y = 1  &amp;&amp; 2nd bit position (0 = 1st bit position)
                ? BitClear(x,y) &amp;&amp; Returns 5, 0101 binary
            </code>
        </example>
    </bitclear>
    <bitlshift>
        <summary>
            Moves bits in a numeric value to the left by the specified number of positions and returns the resulting value.
            If the specified expressions are not integers, they are converted to integers before performing the operation.
        </summary>
        <param name="Arg">
            Specifies the numeric value in which to move bits to the left.
        </param>
        <param name="Bit">
            Specifies the number of bit positions to move to the left.
        </param>
        <returns>
            Numeric. <b>BitLShift( )</b> returns the specified expression with bits moved by the specified number of positions.
        </returns>
        <remarks>
            <b>BitLShift( )</b> does not support <b>Varbinary</b> values.
        </remarks>
        <example>
             <code language="X#">
                x = 5  &amp;&amp; 0101 binary
                y = 1  &amp;&amp; Shift bits 1 position left
                ? BitLShift(x,y) &amp;&amp; Returns 10, 1010 binary
            </code>
        </example>
    </bitlshift>
    <bitnot>
        <summary>
            Performs a bitwise NOT operation on a value of <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> type and returns the bitwise complement on the specified value.
            There is a numeric and a binary version of the syntax.
            If the specified expression is not an integer, it is converted to an integer before performing the operation.
        </summary>
        <param name="Arg1">
            Specifies a <b>Numeric</b> or a <b>Varbinary</b> or <b>Blob</b> value to perform the bitwise NOT operation.
        </param>
        <param name="nNumericExpression">
            Specifies a <b>Numeric</b> value to perform the bitwise NOT operation.
        </param>
        <param name="BinString">
            Specifies a <b>Varbinary</b> or <b>Blob</b> value to perform the bitwise NOT operation.
        </param>
        <param name="StartBit">
            Specifies nStartBit as the starting zero-based number of the first bit to perform the operation
            and nBitCount as the number of bits to perform the operation.<br/>
            If you do not specify nStartBit and nBitCount, the operation applies to all bits in the expression.
            If you specify nStartBit only, the operation applies to nStartBit only.
        </param>
        <param name="BitCount">
            Specifies nStartBit as the starting zero-based number of the first bit to perform the operation and nBitCount as the number of bits to perform the operation.<br/>
            If you do not specify nStartBit and nBitCount, the operation applies to all bits in the expression. If you specify nStartBit only,
            the operation applies to nStartBit only.
        </param>
        <returns>
            <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b>. <b>BitNot( )</b> returns the bitwise complement of the specified expression.
            In other words, the return value represents the specified expression with each 0 bit changed to 1 and each 1 bit changed to 0.
        </returns>
        <example>
             <code language="X#">
                x = 5  &amp;&amp; 0101 binary
                ? BitNot(x) &amp;&amp; Returns -6
            </code>
        </example>
    </bitnot>
    <bitor>
        <summary>
            Perform a bitwise inclusive OR operation on two or more values of <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> type and returns the result.
            There is a numeric and a binary version of the syntax.
        </summary>
        <param name="Arg1">
            Specifies Varbinary or Blob value to perform the bitwise AND operation.
        </param>
        <param name="Arg2">
            Specifies Varbinary or Blob values to perform the bitwise AND operation.
        </param>
        <returns>
            <b>Numeric</b> or <b>Varbinary</b>. <b>BitOr( )</b> returns the result of a bitwise inclusive OR operation on the specified expressions.<br/>
            For <b>Varbinary</b> or <b>Blob</b> values, the return value is calculated as if all values are padded with 0h00 on the right of the value
            up to the length of the longest value. The appropriate operation is then performed between those values.
        </returns>
        <remarks>
            <b>BitOr( )</b> compares each bit in eExpressionN to the corresponding bit in eExpressionN+1. If either of the bits in eExpressionN and eExpressionN+1 is 1,
            the corresponding result bit is set to 1; otherwise, the corresponding result bit is set to 0.<br/>
            The following table shows the result of an inclusive OR operation on corresponding eExpressionN and nExpressionN+1 bits:
            <list type="table">
                <listheader>
                    <term>eExpressionN bit</term>
                    <description>eExpressionN+1 bit</description>
                    <description>Resulting bit</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>0</description>
                    <description>0</description>
                </item>
                <item>
                    <term>0</term>
                    <description>1</description>
                    <description>1</description>
                </item>
                <item>
                    <term>1</term>
                    <description>0</description>
                    <description>1</description>
                </item>
                <item>
                    <term>1</term>
                    <description>1</description>
                    <description>1</description>
                </item>
            </list>
        </remarks>
        <example>
             <code language="X#">
                x = 5  &amp;&amp; 0101 binary
                y = 6  &amp;&amp; 0110 binary
                ? BitOr(x,y) &amp;&amp; Returns 7, 0111 binary
            </code>
        </example>
    </bitor>
    <bitrshift>
        <summary>
            Moves bits in a numeric value to the right by the specified number of positions and returns the resulting value.
            If the specified expressions are not integers, they are converted to integers before performing the operation.
        </summary>
        <param name="Arg">
            Specifies the numeric value in which to move bits to the right.
        </param>
        <param name="Bits">
            Specifies the number of bit positions to move to the right.
        </param>
        <returns>
            Numeric. <b>BitRShift( )</b> returns the specified expression with bits moved by the specified number of positions.
        </returns>
        <remarks>
            <b>BitRShift( ) </b> does not support <b>Varbinary</b> values.
        </remarks>
        <example>
             <code language="X#">
                x = 5  &amp;&amp; 0101 binary
                y = 1  &amp;&amp; Shift bits 1 position right
                ? BitRShift(x,y) &amp;&amp; Returns 2, 0010 binary
            </code>
        </example>
    </bitrshift>
    <bitset>
        <summary>
            Sets a bit to 1 in a value of <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> type and returns the resulting value.
            There is a numeric and a binary version of the syntax.<br/>
            If the specified expression is not an integer, it is converted to an integer before setting the bit.
        </summary>
        <param name="Arg1">
            Specifies a <b>Numeric</b> or a <b>Varbinary</b> value to set the bit.
        </param>
        <param name="Num">
            Specifies a <b>Numeric</b> value to set the bit.
        </param>
        <param name="Bit">
            Specifies the position of the bit in nExpression1 to set to 1. nExpression2 can range from 0 to 31 with 0 as the bit farthest to the right.
        </param>
        <param name="BinString">
            Specifies a <b>Varbinary</b> or <b>Blob</b> expression.
        </param>
        <param name="StartBit">
            Specifies a starting zero-based number of the first bit to perform the operation as nStartBit and the number of bits to perform the operation as nBitCount.<br/>
            If you do not specify nStartBit and nBitCount, the operation applies to all bits in the expression.
            If you specify nStartBit only, the operation applies to nStartBit only.
        </param>
        <param name="BitCount">
            Specifies a starting zero-based number of the first bit to perform the operation as nStartBit and the number of bits to perform the operation as nBitCount.<br/>
            If you do not specify nStartBit and nBitCount, the operation applies to all bits in the expression.
            If you specify nStartBit only, the operation applies to nStartBit only.
        </param>
        <returns>
            <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b>. <b>BitSet( )</b> returns the specified expression with the specified bit set to 1.
        </returns>
        <example>
             <code language="X#">
                x = 5  &amp;&amp; 0101 binary
                y = 1  &amp;&amp; 2nd bit position (0 = 1st bit position)
                ? BitSet(x,y) &amp;&amp; Returns 7, 0111 binary
            </code>
        </example>
    </bitset>
    <bittest>
        <summary>
            Determines whether a specific bit in a <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> value is set to 1.
            There is a numeric and a binary version of the syntax.
            If the specified expression is not an integer, it is converted to an integer before performing the operation.
        </summary>
        <param name="Arg">
            Specifies the <b>Numeric</b> value to check for the specified bit.
        </param>
        <param name="Bit">
            Specifies the bit position in nExpression1 to check. nExpression2 can range from 0 to 31 with 0 as the bit farthest to the right.
        </param>
        <param name="BinString">
            Specifies a <b>Varbinary</b> or <b>Blob</b> expression to check for the specified bit.
        </param>
        <param name="BitNumber">
            Specifies a zero-based bit in BinString.
            If nBitNumber is out of range of BinString, X# generates an error.
        </param>
        <returns>
            Logical. <b>BitTest( ) </b>returns True (.T.) if the specified bit is set to 1; otherwise, it returns False (.F.).
        </returns>
        <example>
             <code language="X#">
                Clear
                ? '2 even? '
                ?? IsEven(2)  &amp;&amp; Even, .T. returned
                ? '3 even? '
                ?? IsEven(3)  &amp;&amp; Not even, .F. returned
                ? '0 even? '
                ?? IsEven(0)  &amp;&amp; Even, .T. returned
                ? '-13 even? '
                ?? IsEven(-13)  &amp;&amp; Not even, .F. returned
                Function IsEven
                PARAMETER nInteger
                RETURN NOT BitTest(nInteger, 0)
            </code>
        </example>
    </bittest>
    <bitxor>
        <summary>
            Perform a bitwise exclusive OR operation on two or more values of <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> type and returns the result.
            There is a numeric and a binary version of the syntax.
        </summary>
        <param name="Arg1">
            Specifies Varbinary or Blob values to perform the bitwise AND operation.
        </param>
        <param name="Arg2">
            Specifies Varbinary or Blob values to perform the bitwise AND operation.
        </param>
        <returns>
            <b>Numeric</b> or <b>Varbinary</b>. <b>BitXOR( )</b> returns the result of the bitwise exclusive OR operation performed on the specified expressions.<br/>
            For <b>Varbinary</b> or <b>Blob</b> values, the return value is calculated as if all values are padded with 0h00 on the right of the value
            up to the length of the longest value. The appropriate operation is then performed between those values.
        </returns>
        <remarks>
            <b>BitXOR( )</b> compares each bit in eExpressionN to the corresponding bit in eExpressionN+1. If the bits in eExpressionN and eExpressionN+1 are the same,
            the corresponding result bit is set to 0; otherwise, the corresponding result bit is set to 1.<br/>
            The following table shows the result of an exclusive OR operation on corresponding eExpressionN and eExpressionN+1 bits:
            <list type="table">
                <listheader>
                    <term>eExpressionN bit</term>
                    <description>eExpressionN+1 bit</description>
                    <description>Result bit</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>0</description>
                    <description>0</description>
                </item>
                <item>
                    <term>0</term>
                    <description>1</description>
                    <description>1</description>
                </item>
                <item>
                    <term>1</term>
                    <description>0</description>
                    <description>1</description>
                </item>
                <item>
                    <term>1</term>
                    <description>1</description>
                    <description>0</description>
                </item>
            </list>
        </remarks>
        <example>
             <code language="X#">
                Var1 = 5  &amp;&amp; 0101 binary value
                Var2 = 6  &amp;&amp; 0110 binary value
                ? BitXOR(Var1,Var2) &amp;&amp; returns 3 (0011 binary value)
            </code>
        </example>
    </bitxor>
    <candidate>
        <summary>
            Returns true (.T.) if an index tag is a candidate index tag; otherwise, returns false (.F.).
        </summary>
        <param name="nIndexNumber">
            Specifies the number of the index tag for which Candidate( ) returns the candidate status.
        </param>
        <param name="uArea">
            Specifies the work area number or workarea alias of the index tag specified with nIndexNumber. <br/>
            If you omit this, Candidate( ) checks the index tag in the currently selected work area to see if it is a candidate index tag.
        </param>
        <returns>
            Logical
        </returns>
        <remarks>
            Candidate( ) returns the candidate status in the following order as nIndexNumber increases
            from 1 to the total number of structural compound and independent compound index tags:<br/>
            Candidate status for each tag in the structural compound index (if one is present) is returned first.
            The candidate status is returned for the tags in the order in which the tags are created in the structural index.<br/>
            Candidate status for each tag in any open independent compound indexes is returned last.
            The candidate status is returned for the tags in the order in which the tags are created in the independent compound indexes.<br/>
            If you omit nIndexNumber, Candidate( ) checks the master controlling index tag to see if it is a candidate index tag.
            If there is no master controlling index tag, Candidate( ) returns false (.F.).<br/><br/>
            A candidate index tag is an index tag that can become the primary index tag because it does not contain null or duplicate values.
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Open Database (HOME(2) + 'data\testdata')
                Use customer     &amp;&amp; Open customer table
                For nCount = 1 TO TAGCOUNT( )
                IF !EMPTY(TAG(nCount))  &amp;&amp; Checks for tags in the index
                ? TAG(nCount)  &amp;&amp; Display tag name
                ? Candidate(nCount)  &amp;&amp; Display candidate status
                ELSE
                EXIT  &amp;&amp; Exit the loop when no more tags are found
                ENDIF
                ENDFor
            </code>
        </example>
    </candidate>
    <capslock>
        <summary>
            Returns the current mode of the CAPS Lock key or sets the CAPS Lock key mode on or off.
        </summary>
        <param name="lSetOn">
            Include to turn the CAPS Lock key on or off. Capslock(.T.) turns CAPS Lock on and Capslock(.F.) turns CAPS Lock off.
        </param>
        <returns>
            A logical value is returned corresponding to the CAPS Lock setting before Capslock(.T.) or Capslock(.F.) is issued.
        </returns>
        <remarks>
            Issuing Capslock( ) with no argument returns true (.T.) if CAPS Lock is on, or false (.F.) if CAPS Lock is off.
        </remarks>
        <example>
             <code language="X#">
                glOldLock = Capslock( )     &amp;&amp; Save original setting
                Capslock(.T.)     &amp;&amp; Turn CAPS Lock on
                *** Perform any number of statements ***
                Capslock(glOldLock)  &amp;&amp; Return to original setting
                *** or, toggle CapsLock to the opposite value and back ***
                Capslock(!Capslock( ))
                WAIT
                Capslock(!Capslock( ))
                WAIT
                Capslock(glOldLock)  &amp;&amp; Return to original setting
            </code>
        </example>
    </capslock>
    <ceiling>
        <summary>
            Returns the next highest integer that is greater than or equal to the specified numeric expression.
        </summary>
        <param name="nExpression">
            Specifies the number whose next highest integer <b>Ceiling( )</b> returns.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            <b>Ceiling</b> rounds a number with a fractional portion to the next highest integer.
        </remarks>
        <example>
             <code language="X#">
                STORE 10.1 TO num1
                STORE -10.9 TO num2
                ? Ceiling(num1)  &amp;&amp; Displays 11
                ? Ceiling(num2)  &amp;&amp; Displays -10
                ? Ceiling(10.0)  &amp;&amp; Displays 10
                ? Ceiling(-10.0) &amp;&amp; Displays -10
            </code>
        </example>
    </ceiling>

    <compobj>
        <summary>
            Compares the properties of two objects and returns True (.T.) if their properties and property values are identical.
        </summary>
        <param name="oExpression1">
            Specifies the objects to compare. oExpression1 and oExpression2 can be any expressions that evaluate to objects,
            such as object references, object variables, or object array elements.
        </param>
        <param name="oExpression2">
            Specifies the objects to compare. oExpression1 and oExpression2 can be any expressions that evaluate to objects,
            such as object references, object variables, or object array elements.
        </param>
        <returns>
            Logical
        </returns>
        <remarks>
            CompObj( ) returns False (.F.) if an object has a property that the other object doesn't have,
            or if the objects have identical properties but the values of one or more properties differ.
        </remarks>
        <example>
             <code language="X#">
                lstMyList1 = CreateOBJ('ListBox')  &amp;&amp; Creates a ListBox
                lstMyList2 = CreateOBJ('ListBox')  &amp;&amp; Creates a second ListBox
                cmbMyCombo = CreateOBJ('ComboBox')  &amp;&amp; Creates a ComboBox
                lstMyList1.Name = 'list1'
                lstMyList2.Name = 'list2'
                Clear
                ? lstMyList1.Name  &amp;&amp; Displays List1 Name property
                ? lstMyList2.Name  &amp;&amp; Displays List2 Name property
                ? CompObj(lstMyList1, cmbMyCombo)     &amp;&amp; Displays .F.
                ? CompObj(lstMyList1, lstMyList2)     &amp;&amp; Displays .F., different Names
                lstMyList2.Name = lstMyList1.Name
                ? CompObj(lstMyList1, lstMyList2)     &amp;&amp; Displays .T., same properties
            </code>
        </example>
    </compobj>
    <cpconvert>
        <summary>
            Converts character or memo fields or character expressions to another code page.
        </summary>
        <param name="nCurrentCodePage">
            Specifies the code page that cExpression is being converted from.
        </param>
        <param name="nNewCodePage">
            Specifies the code page to which cExpression is converted.
        </param>
        <param name="cExpression">
            Specifies the character expression that's converted.
        </param>
        <remarks>
            Note that CPConvert( ) isn't required for normal cross-platform functioning of the product.
            It is used strictly to access the underlying translation facilities of X#.
            For example, if the variable <c>gcCharExpr</c> contains a character that looks like on the Macintosh (in code page 10000)
            then CPConvert( ) will return a character that looks like  in Microsoft Windows (code page 1252):
             <code language="X#">CPConvert(10000, 1252, gcCharExpr)</code>
            For additional information on code pages and X#'s international support, see Code Pages Supported by X# and Developing International Applications.
        </remarks>
    </cpconvert>
    <cpcurrent>
        <summary>
            Returns the code page setting (if any) in your X# configuration file, or returns the current operating system code page.
        </summary>
        <remarks>
            CPCurrent([1 | 2])Remarks
            CPCurrent( ) returns one of the following:
            In X#, the current operating system code page if the CODEPAGE configuration item isn't included in your configuration file.
            In previous versions of FoxPro, 0 is returned if the CODEPAGE configuration item isn't included in your configuration file.
            The code page number specified in the CODEPAGE configuration item.
            For example, CPCurrent( ) returns 852 if the following line is included in your configuration file:
             <code language="X#">CODEPAGE = 852</code>
            The current operating system code page if you have included the following line in your configuration file:
             <code language="X#">CODEPAGE = AUTO</code>
            In X#, CPCurrent(1) returns the current operating system code page, regardless of your configuration CODEPAGE setting.
            CPCurrent(2) always returns the underlying operating system code page, regardless of your configuration CODEPAGE setting.
            For example, if you're running Windows, CPCurrent(2) returns the MS-DOS code page.
            For additional information on code pages and X#'s international support, see Code Pages Supported by X# and Developing International Applications.
        </remarks>
    </cpcurrent>

    <createobject>
        <summary>
            Creates an object from a class definition or an Automation-enabled application.
        </summary>
        <param name="cClassName">
            Specifies the class or OLE object from which the new object is created. X# searches for the class or OLE object in the following order:<br/>
            X# base classes<br/>
            Classes in the current program<br/>
            Classes in .vcx class libraries opened with Set CLASSLIB<br/>
            Classes in procedure files opened with Set PROCEDURE<br/>
            Classes in the X# program execution chain<br/>
            The OLE registry if Set OLEOBJECT is ON<br/>
            OLE objects are created using the following syntax for ClassName:<br/>
             <code language="X#">ApplicationName.Class</code>
            For example, to create a Microsoft Excel worksheet (which supports Automation), you can use the following syntax:<br/>
             <code language="X#">x = CreateObject('Excel.Sheet')</code>
            When this code is run, Microsoft Excel is started (if not already running), and a new worksheet is created.<br/>
            A class library can have an alias. To specify an object in a class library with an alias,
            include the class library alias followed by a period and the object name.
            Note that ClassName cannot be the X# OLE Container control base class.
        </param>
        <returns>
            Object
        </returns>
        <remarks>
            eParameter1, eParameter2, ...<br/>
            These optional parameters are used to pass values to the Init event procedure for the class.<br/>
            The Init event is executed when you issue CreateObject( ) and allows you to initialize the object.<br/>
            Use CreateObject( ) to create an object from a class definition or an application that supports Automation,
            and assign a reference to the object to a system variable or array element.<br/>
            Before you can create an object from a user-defined class, the user-defined class must first be created with DEFINE CLASS,
            or it must be available in a .vcx visual class library opened with Set CLASSLIB.<br/>
            Use = or STORE to assign a reference to the object to a system variable or array element.
            If an object assigned to a system variable or array element is released, the system variable or array element contains the null value.
            Use RELEASE to remove the system variable or array element from memory.<br/>
        </remarks>
        <example>
             <code language="X#">
                Clear
                * Verify current class library setting
                cCurClassLib=Set("CLASSLIB")
                IF LEN(ALLTRIM(cCurClassLib))=0
                cCurClassLib="None"
                ENDIF
                WAIT "Current class library is: " + cCurClassLib + CHR(13);
                + "Press any key to continue..."
                frmMyForm = CreateObject("FormGrandChild")
                * Create an array
                For nCount = 1 TO AClass(gaNewarray, frmMyForm)
                ? gaNewarray(nCount)  &amp;&amp; Display the names of the classes
                ENDFor
                RELEASE frmMyForm
                * Create FormChild from ForM baseclass
                DEFINE CLASS FormChild AS ForM
                ENDDEFINE
                * Create FormGrandChild from user-defined FormChild class
                DEFINE CLASS FormGrandChild AS FormChild
                ENDDEFINE
            </code>
        </example>
    </createobject>

    <createoffline>
        <summary>
            Takes an existing view offline.
        </summary>
        <param name="ViewName">
            Specifies the name of the existing view to take offline. The database containing the existing view must be open before you can take the existing view offline.
        </param>
        <param name="cPath">
            Specifies the directory in which the offline view is placed and the name of the offline view.
        </param>
        <returns>
            Logical
        </returns>
        <remarks>
            CreateOffline( ) returns a logical true (.T.) if the existing view is successfully taken offline; otherwise false (.F.) is returned.<br/>
            An offline view is opened with Use. When an offline view is open, you can append records or make changes to records in the offline view.
            However, you cannot use the Create Trigger, Insert, Pack or Zap commands in an offline view. After making changes to the offline view,
            you can update the data on the server with your changes by opening the offline view with Use and including the Online clause.<br/>
            You cannot refresh the contents of an offline view with data from the server until the offline view has been opened with Use and the Online clause.<br/>
            Use DropOffline( ) to take the offline view back online.
        </remarks>
    </createoffline>
    <ctobin>
        <summary>
            Converts a binary character representation to a numeric value.
        </summary>
        <param name="cExpression">
            Specifies the binary character representation to convert.
        </param>
        <param name="cFlags">
            If the binary character representation specified with cExpression was generated using an 8 byte data type (currency or double, for example),
            include cFlags to control the type of value returned by CToBin( ).
        </param>
        <returns>
            Numeric. <b>CToBin( )</b> returns a numeric value from a binary character expression.
        </returns>
        <remarks>
            <list type="table">
                <listheader>
                    <term>cFlags</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>cExpression is an expression that is 1 byte long.</description>
                </item>
                <item>
                    <term>2</term>
                    <description>cExpression is an expression that is 2 bytes long.</description>
                </item>
                <item>
                    <term>4</term>
                    <description>cExpression is an expression that is 4 bytes long.</description>
                </item>
                <item>
                    <term>8</term>
                    <description>cExpression is an expression that is 8 bytes long.</description>
                </item>
                <item>
                    <term>B</term>
                    <description>
                        cExpression is a double data type, and must be 8 bytes long.<br/>
                        CToBin( ) returns a double data type value. This is the default for an expression that is 8 bytes long.
                    </description>
                </item>
                <item>
                    <term>N</term>
                    <description>
                        cExpression is a numeric data type, and must be 4 or 8 bytes long.<br/>
                        CToBin( ) returns a numeric type value.
                    </description>
                </item>
                <item>
                    <term>Y</term>
                    <description>
                        cExpression is a currency data type, and must be 8 bytes long.<br/>
                        CToBin( ) returns a currency type value.
                    </description>
                </item>
                <item>
                    <term>R</term>
                    <description>Reverses the binary expression.</description>
                </item>
                <item>
                    <term>S</term>
                    <description>Prevents the sign bit of number from being toggled (BitXOR).</description>
                </item>
            </list>
            The cFlags parameter is a character expression. The 'R' and 'S' settings are additive while the others are mutually exclusive.
            Character settings can be passed in either upper or lower case (e.g., 'R' or 'r'). Specifying a value of '1', '2' or '4' is not required,
            but is available as a convenience to provide feedback for the length of cExpression.<br/>
            The following examples show various uses of the cFlags parameter.
             <code language="X#">
                ? CToBin("A")&amp;&amp; same as CToBin("A","1")
                ? CToBin(BinToc($12.34,"8"),"Y")
                ? CToBin(BinToc(12.34,"8"),"B")
                ? CToBin(BinToc(PI(),"BR"),"NRS")
            </code>
            You can use CToBin( ) to convert a binary character representation created with BinToc( ) to its integer value.
            CToBin( ) can also be used when working with Win32 API routines where you might need to convert to or from a Win32 struct member.
            The 'R' and 'S' settings allow you to use CToBin ( ) to work more efficiently with these scenarios.
        </remarks>
    </ctobin>
    <ctot>
        <summary>
            Returns a DateTime value from a character expression.
        </summary>
        <param name="cCharacterExpression">
            Specifies the character expression from which a DateTime value is returned.
        </param>
        <returns>
            DateTime data type. CToT( ) returns a DateTime value from a character expression.
        </returns>
        <remarks>
            <note>
                CToT() can create ambiguous DateTime values and generates a compilation error when Set STRICTDATE is set to 2.
                To create nonambiguous Date values, use the DATETIME( ) function instead.
            </note>
            X# supports the native SQL Datatypes Datetime and Smalldatetime, which are returned in 24 hour format in SQL XML.
            <note>The CToT() function does not address the 19 different ways that T-SQL Convert() function returns datetime and smalldatetime values.</note>
            To convert date formats from Access, SQL Server, Visual Studio, and XML, you must call the appropriate Set DATE setting to interpret DateTime strings properly.
            However, if an uppercase T is in the XML date string, X# overrides the current date setting by internally calling Set DATE YMD
            and restores the current date setting when exiting CToT( ).
            <note>
                CToT( ) resolves these dates to the limits of precision of the X# DateTime data type.
                Therefore, precision can be lost when using CToT( ) with certain formats. The X# DateTime data type does not support milliseconds or time zones.
            </note>
            CToT( ) respects the setting of the Set CENTURY command. For more information, see Set CENTURY Command.<br/><br/>
            The following examples show how CToT( ) handles DateTime values from different sources.
            In all examples, CToT( ) converts the DateTime values correctly without needing to call Set DATE YMD.
            Access 2000 XML date format
             <code language="X#">
                * 2000-10-24T13:30:00 (24-hour format is exported from Access,
                * whether original was in 12- or 24-hour format)
                ? CToT("2000-10-24T13:30:00")
            </code>
            SQL Server 2000 XML date format
             <code language="X#">
                ? CToT("2000-10-24T20:47:58.170")   &amp;&amp; datetime (24-hour format)
                ? CToT("2000-10-24T21:11:00")         &amp;&amp; Small DT (24-hour format)
                ? CToT("2000-10-03T02:02:02")
            </code>
            Visual Studio XML
             <code language="X#">? CToT("2002-10-05T04:04:04.0000000-07:00")</code>
            Simple Object Access Protocol (SOAP)
             <code language="X#">? CToT("2001-09-14T07:00:00Z")</code>
        </remarks>
    </ctot>
    <cursorgetprop>
        <summary>
            Retrieves the current property settings for a X# table or a cursor.
            <note name="tip">
                To set a specific property for a X# table or a cursor, use <b>CursorGetProp( )</b>.
                For additional information about each of the properties and their settings, see CursorGetProp( ) Function.
            </note>
        </summary>
        <param name="cProperty">
            Specifies the property setting to retrieve. See the table in the remarks section for possible properties.
        </param>
        <param name="uArea">
            Specifies the work area number or the alias of the table or cursor from which the property setting is returned.
            If you specify 0 for uArea, <b>CursorGetProp( )</b> returns the environment setting.
        </param>
        <returns>
            Character, Numeric, or Logical data type
        </returns>
        <remarks>
            The current property settings are returned for the table or cursor open in the currently selected work area if <b>CursorSetProp( )</b>
            is issued without the optional uArea argument. If you use CursorGetProp( ) without a table selected, a cursor open,
            or an alias specified, you get Error 52 (No table is open in current work area.) unless a work area is specified as in this example,
            CursorSetProp("Refresh",-2,0).<br/><br/>
            The following table includes a list of properties whose settings can be returned, the data type of the return value,
            and a description of the return value.
            <list type="table">
                <listheader>
                    <term>cProperty</term>
                    <description>Type</description>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>ADOBookmark</term>
                    <description>Variant</description>
                    <description>Contains a value that corresponds to an ADO Bookmark for the current record in an ADO-based cursor.</description>
                </item>
                <item>
                    <term>ADOCodePage</term>
                    <description>N</description>
                    <description>Returns the code page bound to an ADO-based cursor as specified by the ADOCodePage Property. Read-only.</description>
                </item>
                <item>
                    <term>ADORecordset</term>
                    <description>O</description>
                    <description>
                        Contains an object reference to the ActiveX Data Object (ADO) Recordset associated with the cursor.
                        Not valid for cursors that are not based on ADO Recordsets. Read-only.
                    </description>
                </item>
                <item>
                    <term>AllowSimultaneousFetch</term>
                    <description>L</description>
                    <description>
                        Applies when using remote views, a shared connection, and to cursors created using ODBC.<br/>
                        AllowSimultaneousFetch contains True (.T.) when similarly configured cursors sharing the connection
                        are permitted to fetch rows simultaneously.<br/>
                        Otherwise, AllowSimultaneousFetch contains False (.F.) when fetching rows simultaneously is not permitted.
                    </description>
                </item>
                <item>
                    <term>AutoIncError</term>
                    <description>L</description>
                    <description>
                        Contains True (.T.) when attempts to insert or update a value in a field that uses automatically
                        incrementing field values generate an error message.<br/>
                        Contains False (.F.) when attempts to insert or update a value in a field that uses automatically
                        incrementing field values does not generate an error message and the specified value to be inserted or updated is disregarded.<br/>
                        Applies to cursors and sessions.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>BatchUpdateCount</term>
                    <description>N</description>
                    <description>
                        Contains the number of update statements sent to the remote data source for buffered tables. The default value is 1.
                        Adjusting this value can greatly increase update performance.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>Buffering</term>
                    <description>N</description>
                    <description>
                        1  Row and table buffering is off. (Default)<br/>
                        2  Pessimistic row buffering is on.<br/>
                        3  Optimistic row buffering is on.<br/>
                        4  Pessimistic table buffering is on.<br/>
                        5  Optimistic table buffering is on.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>CompareMemo</term>
                    <description>L</description>
                    <description>
                        Contains True (.T.) if Where clause for updates includes memo fields of type Memo, General, or Picture. (Default).<br/>
                        Otherwise, contains False (.F.).<br/>
                        For views only.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>ConnectHandle</term>
                    <description>N</description>
                    <description>
                        The connection handle. This property is valid only when the data source contains a remote table.
                        The connection handle obtained for a view might close when the view closes.<br/>
                        Read-only.
                    </description>
                </item>
                <item>
                    <term>ConnectName</term>
                    <description>C</description>
                    <description>
                        The connection name used when the cursor is created. This property is valid only when the data source contains a remote table.<br/>
                        Read-only.
                    </description>
                </item>
                <item>
                    <term>Database</term>
                    <description>C</description>
                    <description>
                        The name of the database that contains the table or view. If a table is a free table, Database contains an empty string.<br/>
                        Read-only.
                    </description>
                </item>
                <item>
                    <term>FetchAsNeeded</term>
                    <description>L</description>
                    <description>
                        If True (.T.), data is fetched only when needed, such as when record pointer moves to a row that has not been fetched.<br/>
                        If False (.F.), additional data is fetched during idle time. (Default)
                        <note>FetchAsNeeded does not apply when progressive fetching is disabled (FetchSize is -1).</note>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>FetchIsComplete</term>
                    <description>L</description>
                    <description>
                        If True (.T.), the fetch process is complete for an ODBC or ADO-based cursor.<br/>
                        If False (.F.), the fetch process has not been completed.<br/>
                        This option is not supported for tables and local views or on the environment level (work area 0).
                    </description>
                </item>
                <item>
                    <term>FetchMemo*</term>
                    <description>L</description>
                    <description>
                        Contains True (.T.) if memo fields are fetched with the view results. Otherwise, contains False (.F.). (Default).<br/>
                        Use the ISMEMOFETCHED( ) Function to determine if the memo field has been fetched.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>FetchSize*</term>
                    <description>N</description>
                    <description>
                        Contains the number of rows fetched at a time from the remote tables.
                        The default is 100 rows. Setting FetchSize to 1 retrieves the complete result set, limited by the MaxRecords setting.
                        <note>
                            Progressive fetching holds the connection until all rows are retrieved.
                            Use caution coding with FetchSize if ShareConnection is True (.T.).
                        </note>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>KeyFieldList</term>
                    <description>C</description>
                    <description>
                        A comma delimited list of primary fields for the cursor.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>MapBinary</term>
                    <description>L</description>
                    <description>
                        Contains True (.T.) if Varbinary mapping is turned on. Otherwise, contains (.F.).<br/>
                        Read/write for uArea set to 0 only. Read-only for SQL Pass-Through cursors. Invalid for table cursors (uArea equal to or greater than 1).
                    </description>
                </item>
                <item>
                    <term>MapVarchar</term>
                    <description>L</description>
                    <description>
                        Contains True (.T.) if Varchar mapping is turned on. Otherwise, contains False (.F.).<br/>
                        Read/write for uArea set to 0 only. Read-only for SQL Pass-Through cursors. Invalid for table cursors (uArea equal to or greater than 1).
                    </description>
                </item>
                <item>
                    <term>MaxRecords*</term>
                    <description>N</description>
                    <description>
                        The maximum number of rows fetched when result sets are returned. The default value is  1 (all rows are returned).
                        A value of 0 specifies that the view is executed but no results are fetched.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>ParameterList</term>
                    <description>C</description>
                    <description>
                        A semi-colon delimited list of view parameters and parameter types. For views only.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>Prepared</term>
                    <description>L</description>
                    <description>
                        Contains True (.T.) if SQL statements are prepared for subsequent Requery( ) function calls. Otherwise, contains False (.F.). (Default).<br/>
                        Requery( ) is used to retrieve data again for a SQL view. See SqlPrepare( ) for additional information about preparing SQL statements. For views only.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>RecordsFetched</term>
                    <description>N</description>
                    <description>
                        Contains a numeric value that indicates the number of records fetched from the data source for an ODBC or ADO-based cursor.<br/>
                        This numeric value may not reflect the current record count for the cursor if records were locally deleted or appended.<br/>
                        This option is not supported for tables and local views or on the environment level (work area 0).<br/>
                        <note>Any filter conditions are ignored in the record count.</note>
                        Read-only.
                    </description>
                </item>
                <item>
                    <term>Refresh</term>
                    <description>N</description>
                    <description>
                        Contains a numeric value that indicates the refresh setting for an individual cursor
                        in the current data session or an initial refresh value for newly opened cursors in the current data session.
                    </description>
                </item>
                <item>
                    <term>SendUpdates</term>
                    <description>L</description>
                    <description>
                        Contains True (.T.) if a SQL update query is sent to update tables when an update is made using the view; otherwise, contains false (.F.) (default).<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>SourceName</term>
                    <description>N</description>
                    <description>
                        1  The data source is a local SQL view.<br/>
                        101 (1 + 100) - Cursor is created by the CursorFill method.<br/>
                        201 (1 + 200) - Cursor is attached to a CursorAdapter object using the CursorAttach method.<br/>
                        2  The data source is a remote SQL view.<br/>
                        102 (2 + 100) - Cursor is created by CursorFill.<br/>
                        202 (2 + 200) - Cursor is attached to a CursorAdapter object using CursorAttach.<br/>
                        3  The data source is a table.<br/>
                        103 (3 + 100) - Cursor is created by CursorFill.<br/>
                        203 (3 + 200) - Cursor is attached to a CursorAdapter object using CursorAttach.<br/>
                        4 - The cursor is based on ADO Recordset and attached to a CursorAdapter object.<br/>
                        104 (4 + 100) - Cursor is created by CursorFill.<br/>
                        204 (4 + 200) - Cursor is attached to a CursorAdapter object using CursorAttach.<br/>
                        Read-only.
                    </description>
                </item>
                <item>
                    <term>SQL</term>
                    <description>C</description>
                    <description>
                        The SQL statement executed when the cursor is created.<br/>
                        Read-only.
                    </description>
                </item>
                <item>
                    <term>Tables</term>
                    <description>C</description>
                    <description>
                        A comma delimited list of the names of tables.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>UpdatableFieldList</term>
                    <description>C</description>
                    <description>
                        A comma delimited list of fields in the view. This list can include fields from local and remote tables.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>UpdateNameList</term>
                    <description>C</description>
                    <description>
                        A comma delimited list of remote field names and the local field names assigned to the cursor.
                        Use this option to specify valid Visual FoxPro names for fields in the cursor that have invalid Visual FoxPro field names.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>UpdateType</term>
                    <description>N</description>
                    <description>
                        1  Specifies that old data is updated with the new data. (Default).<br/>
                        2  Specifies that updates occur by deleting the old data and inserting the new data.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>UseMemoSize*</term>
                    <description>N</description>
                    <description>
                        The minimum size, in bytes, for result columns to return in memo fields.
                        For example, if the width of a column result is greater than the value of UseMemoSize, the column result is stored in a memo field.
                        UseMemoSize may vary from 1 to 255; the default value is 255.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>WhereType</term>
                    <description>N</description>
                    <description>
                        The Where clause for updates to tables. WhereType can specify the following values:<br/>
                        1 or DB_KEY (from Foxpro.H). The Where clause used to update tables consists of only the primary fields specified with the KeyFieldList property.<br/>
                        2 or DB_KEYANDUPDATable (from Foxpro.H). The Where clause used to update tables
                        consists of the primary fields specified with the KeyFieldList property and any updatable fields.<br/>
                        3 or DB_KEYANDMODIFIED (from Foxpro.H) (default). The Where clause used to update tables
                        consists of the primary fields specified with the KeyFieldList property and any other fields that are modified.<br/>
                        4 or DB_KEYANDTIMESTAMP (from Foxpro.H). The Where clause used to update tables
                        consists of the primary fields specified with the KeyFieldList property and a comparison of the time stamps.<br/>
                        Read/write.
                    </description>
                </item>
            </list>
            * The value returned by this property is significant only for remote views;
            if you get this property for local views, the <b>CursorGetProp( )</b> function returns the default value.
        </remarks>
        <example>
            When a cursor is opened, the default value for the AutoIncError property is read from the session default value,
            which is the current default data session setting.
            The following example shows how you can retrieve the default AutoIncError value for each session by specifying 0 (default session) as the last parameter:
             <code language="X#">CursorGetProp("AutoIncError", 0) </code>
            The default session is used when opening a new private data session or cursor.
            The following example shows how you can retrieve the cursor or table AutoIncError setting for each table
            by using the uArea parameter as the last parameter:
             <code language="X#">CursorGetProp("AutoIncError", uArea)</code>
            The following example opens a "Customer" table in the "Testdata" database and uses <b>CursorGetProp( )</b> to display the buffering mode for the table
            and the name of the database in which the table is contained:
             <code language="X#">
                Close Databases
                Clear
                Open Database (HOME(2) + 'data\testdata')
                Use customer     &amp;&amp; Open customer table
                ? CursorGetProp("Buffering") &amp;&amp; Displays buffering mode
                ? CursorGetProp("Database")  &amp;&amp; Displays database name
            </code>
        </example>
    </cursorgetprop>
    <cursorsetprop>
        <summary>
            Specifies property settings for a X# table or a cursor.
        </summary>
        <param name="cProperty">
            Specifies the table or cursor property to set. Buffering is the only property you can specify for a X# table.
        </param>
        <param name="eExpression">
            Specifies the value for the property you specify with cProperty. If you omit eExpression, the property is set to its default value.<br/>
            The table in the remarks section lists the properties you can specify for cProperty and a description of the values eExpression can assume.
        </param>
        <param name="uArea">
            Specifies the alias of the table or cursor for which the property is set or specifies the work area of the table or cursor for which the property is set. <br/>
            If you specify 0 for uArea, <b>CursorSetProp( )</b> sets the environment setting used for all subsequent tables or cursors.<br/>
            Buffering is not applied to tables that are opened implicitly, for example, using SQL Insert/Update/Delete commands.
        </param>
        <returns>
            Logical data type. <b>CursorSetProp( )</b> returns True (.T.) if X# successfully sets the property you specify.
            X# generates an error if the property you specify cannot be set.
        </returns>
        <remarks>
            The setting of the Buffering property for <b>CursorSetProp( )</b> determines how X# performs record locking and update buffering.
            For additional information about record locking and update buffering, see How to: Buffer Data.<br/>
            The setting of the WhereType property for <b>CursorSetProp( )</b> determines how updates are performed on remote tables.
            For additional information about remote table updates, see Developing Databases.<br/>
            You can use <b>CursorSetProp( )</b> to override the FetchSize property in the <b>SqlSetProp( )</b> function for a cursor.
            This property is inherited from the cursor's connection handle by default.<br/>
            Use <b>CursorGetProp( )</b> to return the current property settings for a X# table or a cursor created for a table.<br/>
            If <b>CursorSetProp( )</b> is issued without the optional uArea arguments,
            the property setting is specified for the open table or cursor in the currently selected work area.
            <list type="table">
                <listheader>
                    <term>Property</term>
                    <desdription>eExpression values</desdription>
                </listheader>
                <item>
                    <term>AllowSimultaneousFetch</term>
                    <description>
                        Applies when using remote views, a shared connection, and to cursors created using ODBC.<br/>
                        .T. - Permit similarly configured cursors sharing the connection to fetch rows simultaneously.<br/>
                        .F. - Do not permit similarly configured cursors sharing the connection to fetch rows simultaneously.
                    </description>
                </item>
                <item>
                    <term>AutoIncError</term>
                    <description>
                        .T. - Generate an error message when attempting to insert or update values in a field that uses automatically incrementing field values.<br/>
                        .F. - Does not generate an error message but does not use the value specified when attempting to insert or update the value in a field
                        that uses automatically incrementing field values, which uses the appropriate incremented value.<br/>
                        Applies to cursors and sessions.
                    </description>
                </item>
                <item>
                    <term>BatchUpdateCount*</term>
                    <description>
                        Specifies the number of update statements to send to the remote data source for buffered tables.
                        The default value is 1. Adjusting this value can greatly increase update performance when using automatic updating.
                    </description>
                </item>
                <item>
                    <term>Buffering</term>
                    <description>
                        1  Sets row and table buffering off. Record locking and data writing are identical to earlier FoxPro versions. (Default)<br/>
                        2  Sets pessimistic row buffering on.<br/>
                        3  Sets optimistic row buffering on.<br/>
                        4  Sets pessimistic table buffering on.<br/>
                        5  Sets optimistic table buffering on. <b>Set multilocs</b> must be <b>on</b> for all Buffering modes except 1 (off).
                    </description>
                </item>
                <item>
                    <term>CompareMemo</term>
                    <description>
                        .T. - Include memo fields of type Memo, General, or Picture in the <b>Where</b> clause for updates.<br/>
                        .F.  Do not include memo fields in the Where clause for updates.<br/>
                        Applies when automatic updating is used.
                    </description>
                </item>
                <item>
                    <term>FetchAsNeeded</term>
                    <description>
                        .T.  Fetch records only when needed, such as when record pointer moves to a row that has not been fetched.<br/>
                        .F.  Fetch additional data during idle time.<br/>
                        <note name="Note">FetchAsNeeded does not apply when progressive fetching is disabled (FetchSize is -1).</note>
                    </description>
                </item>
                <item>
                    <term>FetchMemo*</term>
                    <description>
                        .T.  Fetch memo fields with the view results.<br/>
                        .F.  Do not fetch memo fields with the view results.
                    </description>
                </item>
                <item>
                    <term>FetchSize*</term>
                    <description>
                        Specifies the number of rows progressively fetched from the remote table result set. The default value is 100 rows.
                        Setting FetchSize to 1 retrieves the complete result set, limited by the MaxRecords setting.<br/>
                        <note name="Note">
                            Progressive fetching holds the connection until all rows are retrieved.
                            Use caution coding with FetchSize if ShareConnection is True (.T.).
                        </note>
                    </description>
                </item>
                <item>
                    <term>KeyFieldList</term>
                    <description>
                        Specifies a comma-delimited list of primary fields for the cursor. No default.
                        You must include a list of field names for updates to work when using automatic updating.
                    </description>
                </item>
                <item>
                    <term>KeyFieldList</term>
                    <description>
                        Specifies a comma-delimited list of primary fields for the cursor. No default.
                        You must include a list of field names for updates to work when using automatic updating.
                    </description>
                </item>
                <item>
                    <term>MapBinary</term>
                    <description>
                        .T. - At the session level, SQL Pass-Through maps SQL_BINARY, SQL_VARBINARY,
                        and SQL_LONGVARBINARY ODBC types to <b>Varbinary</b> or <b>Blob</b> data type.<br/>
                        For remote views, the <b>Create SQL View</b> command maps the SQL_LONGVARBINARY ODBC data source type to <b>Blob</b> type,
                        and it maps SQL_BINARY and SQL_VARBINARY ODBC data source types to <b>Varbinary</b> type when the precision of the corresponding column
                        in the data source is less than or equal to 254 bytes. When precision is greater than 254 bytes, these types map to <b>Blob</b> type.<br/>
                        .F. - SQL Pass-Through maps SQL_BINARY and SQL_VARBINARY ODBC types to <b>Character</b> type. (Default)<br/>
                        For remote views, the <b>Create SQL View</b> command maps SQL_BINARY and SQL_VARBINARY ODBC data source types to <b>Memo</b> type.<br/>
                        <note name="Note">
                            <b>MapBinary</b> is read/write for uArea set to 0, read-only for SQL Pass-Through cursors, and invalid for table cursors
                            (uArea equal to or greater than 1).
                        </note>
                    </description>
                </item>
                <item>
                    <term>MapVarchar</term>
                    <description>
                        .T. - At the session level, SQL Pass-Through maps SQL_WVARCHAR and SQL_VARCHAR ODBC types to <b>Varchar</b> type.<br/>
                        For remote views, <b>Create SQL View</b> command maps SQL_WVARCHAR and SQL_VARCHAR ODBC data source types to <b>Varchar</b> type.<br/>
                        .F. - SQL Pass-Through maps SQL_WVARCHAR and SQL_VARCHAR ODBC types to Character type. (Default)<br/>
                        For remote views, <b>Create SQL View</b> command maps SQL_WVARCHAR and SQL_VARCHAR ODBC data source types to <b>Character</b> type.<br/>
                        <note name="Note">
                            <b>MapVarchar</b> is read/write for uArea set to 0, read-only for SQL Pass-Through cursors, and invalid for table cursors (uArea equal to or greater than 1).
                        </note>
                    </description>
                </item>
                <item>
                    <term>MaxRecords*</term>
                    <description>
                        Specifies the maximum number of rows fetched when returning result sets. The default value is  1, and all rows are returned.
                        A value of 0 specifies that the view is executed but no results are fetched.
                    </description>
                </item>
                <item>
                    <term>ParameterList</term>
                    <description>Specifies a semi-colon delimited list of view parameters and parameter types. For views only.</description>
                </item>
                <item>
                    <term>Prepared</term>
                    <description>
                        .T. - Prepare SQL statements for subsequent <b>Requery( )</b> function calls.<br/>
                        .F. - Do not prepare SQL statements for subsequent <b>Requery( )</b> calls. (Default).<br/>
                        <b>Requery( )</b> is used to retrieve data again for a SQL view.
                        For additional information about preparing SQL statements, see SqlPrepare( ) Function.
                    </description>
                </item>
                <item>
                    <term>Refresh</term>
                    <description>
                        Specifies a numeric refresh value for an individual cursor in the current data session or an initial refresh value for newly opened cursors
                        in the current data session.<br/>
                        Use the Set DATASESSION Command to select a specific data session, and use the uWorkArea parameter to specify a specific cursor.
                        Use uArea = 0 to change the initial refresh value for all newly opened cursors.
                        Any cursors that are already open will not be affected by the new refresh setting.<br/>
                        Set Refresh Command allows you to specify a global refresh value. By default, the CursorSetProp( ) Refresh setting is -2,
                        which indicates that the current global Set Refresh value is used. The global Set Refresh value is specified with its second parameter, nSeconds2.<br/>
                        You can set the CursorSetProp( ) Refresh setting to the same values as the nSeconds2 parameter in Set Refresh.<br/>
                        <note name="Note">The CursorSetProp( ) Refresh setting will be ignored if the nSeconds2 parameter is currently set to zero in the Set Refresh command.</note>
                    </description>
                </item>
                <item>
                    <term>SendUpdates</term>
                    <description>
                        .T.  Specifies that a SQL update query is sent to update tables when an update is made using the view.<br/>
                        .F.  Specifies that a SQL update query is not sent to update tables.
                    </description>
                </item>
                <item>
                    <term>Tables</term>
                    <description>
                        Specifies a comma-delimited list of the names of remote tables. No default.
                        You must include a list of table names for updates to work when using automatic updating.
                    </description>
                </item>
                <item>
                    <term>UpdateableFieldList</term>
                    <description>
                        Specifies a comma-delimited list of fields in the view. This list can include fields from local and remote tables.
                        You must include a list of fields for updates to work when using automatic updating.
                    </description>
                </item>
                <item>
                    <term>UpdateNameList</term>
                    <description>
                        Specifies a comma-delimited list of remote field names and the local field names assigned to the cursor.
                        Use this option to specify valid Visual FoxPro names for fields in the cursor that have invalid Visual FoxPro field names.
                    </description>
                </item>
                <item>
                    <term>UpdateType</term>
                    <description>
                        1  Update old data with new data. (Default)<br/>
                        2  Update by deleting old data and inserting new data.
                    </description>
                </item>
                <item>
                    <term>UseMemoSize*</term>
                    <description>
                        Specifies the minimum size in bytes for result columns to return in memo fields.
                        For example, if the width of a column result is greater than the value of UseMemoSize, the column result is stored in a memo field.
                        UseMemoSize can vary from 1 to 255 bytes.<br/>
                        The default value is 255 bytes.
                    </description>
                </item>
                <item>
                    <term>WhereType</term>
                    <description>
                        The <b>Where</b> clause for updates to remote tables. WhereType can assume the following values:<br/>
                        1 or <b>DB_KEY</b> (from Foxpro.H). The <b>Where</b> clause used to update remote tables consists of
                        only the primary fields specified with the KeyFieldList property.<br/>
                        2 or <b>DB_KEYANDUPDATable</b> (from Foxpro.H). The <b>Where</b> clause used to update remote tables
                        consists of the primary fields specified with the KeyFieldList property and any updatable fields.<br/>
                        3 or <b>DB_KEYANDMODIFIED</b> (from Foxpro.H). The <b>Where</b> clause used to update remote tables
                        consists of the primary fields specified with the KeyFieldList property and any other fields that are modified. (Default)<br/>
                        4 or <b>DB_KEYANDTIMESTAMP</b> (from Foxpro.H). The <b>Where</b> clause used to update remote tables
                        consists of the primary fields specified with the KeyFieldList property and a comparison of the time stamps.
                    </description>
                </item>
            </list>
            * This property is primarily used for remote views; setting it has no effect on local views. However, you can preset this property for
            local views that will be upsized.
        </remarks>
        <example>
            When a cursor is opened, the default value for the AutoIncError property is read from the session default value,
            which is the current default data session setting. The following example shows how you can set the default AutoIncError
            value for each session by specifying 0 (default session) as the last parameter:
             <code language="X#">CursorSetProp("AutoIncError", .T., 0) </code>
            The default session is used when opening a new private data session or cursor. The following example shows how you can set the cursor or
            table AutoIncError setting for each table by using the uArea parameter as the last parameter:
             <code language="X#">CursorSetProp("AutoIncError", .F. , uArea )</code>
            The following example demonstrates how you can enable optimistic table buffering with <b>CursorSetProp( )</b>. <b>MultiLocks</b> is set to
            <b>ON</b>, a requirement for table buffering. The "Customer" table in the "testdata" database is opened, and <b>CursorSetProp( )</b> is used
            to set the buffering mode to optimistic table buffering (5). A message box is displayed showing the result of the operation.
             <code language="X#">
                Close Databases
                Clear
                Set MultiLocks ON
                Open Database (HOME(2) + 'data\testdata')
                Use Customer     &amp;&amp; Open Customer table.
                * Set buffering mode and store logical result
                lSuccess=CursorSetProp("Buffering", 5, "Customer")
                IF lSuccess = .T.
                =MessageBox("Operation successful!",0,"Operation Status")
                ELSE
                =MessageBox("Operation NOT successful!",0,"Operation Status")
                ENDIF
            </code>
        </example>
    </cursorsetprop>
    <cursortoxml>
        <summary>
            Converts a X# cursor to XML.
        </summary>
        <param name="uArea">
            Specifies the work area number or alias of the table from which to create the XML string.
            If you specify 0 or no value, X# uses the current work area.
        </param>
        <param name="cOutput">
            Specifies the path and file name or memory variable name to which results are sent.
            If nFlags is set to 0 (default) for memory variable output, XML is returned to the memory variable.
            If the memory variable does not exist, it is created.
            If nFlags is set to 512 for file output, and the file does not exist, it is created.
            If the file already exists, it is overwritten. The setting for <b>Set SAFETY</b> is observed.
        </param>
        <param name="nOutputFormat">
            Specifies the output format of the XML string. The table in the remarks section lists the values for nOutputFormat.
        </param>
        <param name="nFlags">
            Specifies the formatting of the XML that is produced and its destination. The table in the remarks section lists the values for nFlags.
        </param>
        <param name="nRecords">
            Specifies the number of records to output to XML and has a default value is 0.<br/>
            If nRecords is 0, all records are output. If nRecords is greater than the number of records remaining in the table,
            all remaining records are output.
        </param>
        <param name="cSchemaName">
            Specifies the name and location to contain schema information for the data in cOutput, for example "MySchema.xsd".
            If no extension is provided, the schema file is created with an .xsd extension.<br/>
            The table in the remarks section lists the values for cSchemaName.
        </param>
        <param name="cSchemaLocation">
            Specifies an optional location where the application reading the XML data should look for the schema file.
            <note name="Note">Use this parameter only when you are deploying your schema to a location other than the location of the XML data.</note>
            The contents of cSchemaLocation xsi:schemaLocation or xsi:noNamespaceSchemaLocation attribute of the XML data produced. <br/>
            The cschemaLocation parameter can be an HTTP address or other URI. You need to copy the schema file to the location you have specified in
            cSchemaLocation.
            The following example produces XML data:
             <code language="X#">
                CURSORTOXML("LABELS", "myXMLFile.xml", 1, 512, 0, ;
                "mySchema.xsd", "http://www.microsoft.com/mySchema.xsd")
            </code>
            containing the following attribute:
             <code language="X#">   xsi:noNamespaceSchemaLocation=" http://www.microsoft.com/mySchema.xsd"</code>
            Specifying cSchemaLocation when cSchemaName is blank causes the same attributes to be written to the XML data.
            This makes it possible for you to point to an existing schema without recreating the schema each time <b>CURSORTOXML( )</b> is called.
        </param>
        <param name="cNamespace">
            Specifies the namespace of the XML or schema to be produced and has an empty string ("") as the default value.<br/>
            Specifying a value for cNameSpace sets the targetNamespace attribute to the same value and adds the elementFormDefault="qualified"
            attribute to the schema.<br/>
            If you do not specify a cNamespace value, and the schema is external, no namespace declaration is written to the schema.
            If you do not specify a cNamespace value and the schema is inline, the targetNamespace in the schema is set to an empty string ("").
        </param>
        <returns>
            Numeric data type. <b>CURSORTOXML( )</b> returns the number of bytes written to the file or a memory variable.
        </returns>
        <remarks>
            You can use <b>CURSORTOXML( )</b> with the OLE DB Provider for X#. However, the <b>_VFP</b> <b>VFPXMLProgID</b> property is not
            supported because the <b>_VFP</b> system variable is not supported in the OLE DB Provider.<br/>
            To use the X# OLE DB Provider with <b>CURSORTOXML( )</b>, you must install MSXML 3.0 on the computer with the OLE DB Provider.
            <note name="Note">
                <b>CURSORTOXML( )</b> output adheres to the cursor index order, <b>Set Fields TO</b>, and current filter settings.
            </note>
            However, it does not preserve the cursor location. After the calling <b>CURSORTOXML( )</b>, if all records are output,
            the cursor record pointer reports <b>EOF</b>. If not all records are output, it points to the last record output to XML.<br/>
            The resulting XML from <b>CURSORTOXML( )</b> contains the same scale as the exported table if the table contains <b>Double</b> data type values.
            For example, if a <b>Double</b> column is created with a scale of 6 using the following codem the resulting XML contains six digits
            to the right of the decimal point:
             <code language="X#">Create Table test (col1 b(6))</code>
            When you use the <b>CURSORTOXML( )</b> function to export a table or cursor to XML, the root node is always called "VFPData",
            regardless of the output format.
            For <b>Date</b> types only, you can export "Empty" <b>Date</b> and <b>DateTime</b> types using <b>CURSORTOXML( )</b>.
            However, the XML schema validation might fail because "Empty" is not valid for these types in an XML schema definition (XSD) schema.
            This is an issue only if a schema is required, and the resulting XML is validated against an XML parser that can interpret XSD schemas.
            To work around this issue, you might need to change the data to a nonempty representation by calling the appropriate <b>Select</b> statement
            and use <b>CURSORTOXML( )</b> on the created cursor. For example, you can change the empty <b>Date</b> or <b>DateTime</b> values to .<b>NULL.</b>:
             <code language="X#">Select orderid, EVL(shippeddate,.NULL.) as ShippedDate From orders</code>
            You can also change the empty <b>Date</b> or <b>DateTime</b> to an appropriate representation for "empty":
             <code language="X#">
                Select orderid, IIF(EMPTY(shippeddate),{^1899-12-30 00:00:00},tc11);
            </code>
            When using flag 32768, the flags 16 and 32 settings can affect which code page is applied depending on the type of data you are writing to XML.
            The following tables show the possible combinations of settings and the code page each combination applies.
            For XML documents written with the 32768 flag set, the following code pages are applied.
            <list type="table">
                <item>
                    <term>Flag 16</term>
                    <description>Flag 32</description>
                    <description>Flag 32768 is Set</description>
                </item>
                <item>
                    <term>Not set</term>
                    <description>Not set</description>
                    <description>
                        XML documents: Window-1252.<br/>
                        Unicode data: code page 1252.<br/>
                        Character data: default code page, unless a field is marked as <b>NOCPTRANS</b>.
                    </description>
                </item>
                <item>
                    <term>True (.T)</term>
                    <description>Not set</description>
                    <description>
                        XML documents: Plus-<b>CodePage</b> property of the cursor.<br/>
                        If XMLField <b>CodePage</b> property is greater than zero (0) and it doesnt match the cursors code page, an error is reported.<br/>
                        Unicode data: the <b>Code page</b> property of the cursor object.<br/>
                        Character data: none. Raw data from the X# tables (.dbf) are used instead.
                    </description>
                </item>
                <item>
                    <term>Not set</term>
                    <description>Set</description>
                    <description>
                        XML documents: UTF-8 code page.<br/>
                        Unicode data: UTF-8 code page.<br/>
                        Character data: Default code page unless field is marked as <b>NOCPTRANS</b>,
                        in which case no additional character translation to UTF-8 occurs.
                    </description>
                </item>
                <item>
                    <term>Set</term>
                    <description>Set</description>
                    <description>
                        XML documents: UTF-8 code page.<br/>
                        Unicode data: UTF-8 code page.<br/>
                        Character data: default code page unless a field is marked as <b>NOCPTRANS</b>, in which case the data are translated to UTF-8 using the
                        <b>SYS(3005)</b> setting.
                    </description>
                </item>
            </list>
            For XML documents written without setting the 32768 flag, the following code pages are applied.

            <list type="table">
                <item>
                    <term>Flag 16</term>
                    <description>Flag 32</description>
                    <description>Without the 32768 flag</description>
                </item>
                <item>
                    <term>Not set</term>
                    <description>Not set</description>
                    <description>
                        XML documents: Window-1252.<br/>
                        Unicode data: code page 1252.<br/>
                        Character data: default code page unless a field is marked as <b>NOCPTRANS</b>.
                    </description>
                </item>
                <item>
                    <term>True (.T)</term>
                    <description>Not set</description>
                    <description>
                        XML documents: <b>CodePage</b> property of the cursor.<br/>
                        Character data: none. Raw data from the X# tables (.dbf) are used instead.<br/>
                        Unicode data: code page property of the cursor object.
                    </description>
                </item>
                <item>
                    <term>Not set</term>
                    <description>Set</description>
                    <description>
                        XML documents: UTF-8 code page.<br/>
                        Unicode data: UTF-8 code page.<br/>
                        Character data: default code page unless field is marked as <b>NOCPTRANS</b>,
                        in which case no additional character translation to UTF-8 occurs.
                    </description>
                </item>
                <item>
                    <term>Set</term>
                    <description>Set</description>
                    <description>
                        XML documents: UTF-8 code page.<br/>
                        Unicode data: UTF-8 code page.<br/>
                        Character data: default code page unless field is marked as <b>NOCPTRANS</b>, in which case,
                        they are translated to UTF-8 using code page for the current <b>SYS(3005)</b> setting.
                    </description>
                </item>
            </list>
            <list type="table">
                <listheader>
                    <term>nOutputFormat</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>1  ELEMENTS</term>
                    <description>(Default) Element-centric XML</description>
                </item>
                <item>
                    <term>2  ATTRIBUTES</term>
                    <description>Attribute-centric XML</description>
                </item>
                <item>
                    <term>3  RAW</term>
                    <description>Generic, attribute-centric XML</description>
                </item>
            </list>

            <list type="table">
                <listheader>
                    <term>nFlags</term>
                    <description>Bit</description>
                    <description>Output description</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>0000</description>
                    <description>
                        (Default) Produce XML in UTF-8 format.<br/>
                        This setting creates a memory variable if one does not exist when specified by cOutput and returns XML to the memory variable.<br/>
                        The XML declaration does not contain an Encoding= attribute; that is, no encoding attribute is set to UTF-8.
                    </description>
                </item>
                <item>
                    <term>1</term>
                    <description>0001</description>
                    <description>Produce unformatted XML as a continuous string.</description>
                </item>
                <item>
                    <term>2</term>
                    <description>0010</description>
                    <description>Enclose empty elements with open and closing elements, for example, &lt;cc04&gt;&lt;cc04/&gt;.</description>
                </item>
                <item>
                    <term>4</term>
                    <description>0100</description>
                    <description>Preserve white space in fields.</description>
                </item>
                <item>
                    <term>8</term>
                    <description>1000</description>
                    <description>Wrap Memo fields in CDATA sections.</description>
                </item>
                <item>
                    <term>16</term>
                    <description>10000</description>
                    <description>
                        Output encoding. Output is set to the cursor code page.<br/>
                        To ensure accurate character translation, the X# default code page must match the code page of the cursor.<br/>
                        You can accomplish this by setting character and memo fields in the cursor to <b>NOCPTRAN</b> (character binary/memo binary).<br/>
                        When setting this value with tables using any of the code pages, the encoding attribute in the XML is set to an empty string
                        (""). To change to the correct encoding attribute, use the STRTRAN( ) function.<br/>
                        For example, for code page 936, provide the following to the resulting XML string:
                         <code language="X#">strxml=STRTRAN(strxml, 'encoding=""', 'encoding="gb2312"'</code>
                    </description>
                </item>
                <item>
                    <term>32</term>
                    <description>100000</description>
                    <description>Output encoding.</description>
                </item>
                <item>
                    <term>512</term>
                    <description>1000000000</description>
                    <description>
                        Output to the file specified by cOutput.
                        If a file does not exist, it is created. If the file already exists, it is overwritten. The setting for <b>Set SAFETY</b> is observed.
                    </description>
                </item>
                <item>
                    <term>4096</term>
                    <description>1000000000000</description>
                    <description>
                        Disables base64 encoding.<br/>
                        <b>CURSORTOXML( )</b> exports Memo (Binary) fields as xsd:base64binary unless you use nFlags set to 4096.<br/>
                        In X#, base64 encoding is meant for encoding only binary data.
                    </description>
                </item>
                <item>
                    <term>32768</term>
                    <description>none</description>
                    <description>Indicates that a code page should be used.</description>
                </item>
            </list>
            The following table describes how the encoding attribute is written when output encoding defaults to the cursor or table code page.
            <note name="Note">Encoding flags are set by combining bits 4 and 5 (0010000).</note>
            <list type="table">
                <listheader>
                    <term>Encoding flag</term>
                    <description>Bits 4 and 5</description>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>+0</term>
                    <description>00</description>
                    <description>(Default) Windows-1252</description>
                </item>
                <item>
                    <term>+16</term>
                    <description>01</description>
                    <description>Set output encoding attribute to the cursor code page.</description>
                </item>
                <item>
                    <term>+32</term>
                    <description>10</description>
                    <description>Set output encoding attribute to UTF-8 with no character translation.</description>
                </item>
                <item>
                    <term>+48</term>
                    <description>11</description>
                    <description>Set output encoding attribute to UTF-8 and translate character data to UTF-8.</description>
                </item>
            </list>
            The following table lists common Windows-compatible code pages.
            <list type="table">
                <listheader>
                    <term>Code page</term>
                    <description>Platform</description>
                    <description>Encoding attribute in XML Declaration </description>
                    <description>Comments</description>
                </listheader>
                <item>
                    <term>437</term>
                    <description>MS-DOS, US</description>
                    <description>ibm437</description>
                    <description></description>
                </item>
                <item>
                    <term>850</term>
                    <description>MS-DOS, International</description>
                    <description>ibm850</description>
                </item>
                <item>
                    <term>865</term>
                    <description>MS-DOS, Nordic</description>
                    <description>Empty string ("")</description>
                </item>
                <item>
                    <term>866</term>
                    <description>MS-DOS, Russian</description>
                    <description>cp866</description>
                </item>
                <item>
                    <term>932</term>
                    <description>Windows, Japanese</description>
                    <description>shift-jis</description>
                </item>
                <item>
                    <term>936</term>
                    <description>Simplified Chinese</description>
                    <description>gb2312</description>
                </item>
                <item>
                    <term>949</term>
                    <description>Windows, Korean</description>
                    <description>iso-2022-kr</description>
                    <description>
                        or:<br/> ks_c_5601-1987
                    </description>
                </item>
                <item>
                    <term>950</term>
                    <description>Windows, Traditional Chinese (Taiwan)</description>
                    <description>big5</description>
                </item>
                <item>
                    <term>1250</term>
                    <description>Windows, East European</description>
                    <description>Windows-1250</description>
                    <description>Note case.</description>
                </item>
                <item>
                    <term>1251</term>
                    <description>Windows, Russian</description>
                    <description>Windows-1251</description>
                </item>
                <item>
                    <term>1252</term>
                    <description>Windows, U.S., West European</description>
                    <description>Windows-1252</description>
                </item>
                <item>
                    <term>1253</term>
                    <description>Windows, Greek</description>
                    <description>Windows-1253</description>
                </item>
                <item>
                    <term>1254</term>
                    <description>Windows, Turkish</description>
                    <description>Windows-1254</description>
                </item>
                <item>
                    <term>1255</term>
                    <description>Windows, Hebrew</description>
                    <description>Windows-1255</description>
                </item>
                <item>
                    <term>1256</term>
                    <description>Windows, Arabic</description>
                    <description>Windows-1256</description>
                </item>
            </list>
            <note name="Note">
                X# uses Windows-1252 as the default encoding. You can specify that the encoding attribute be set to match the code page, such as Big5
                (code page 950), when using double-byte character sets (DBCS) for DBCS languages for which X# supports code pages.
            </note>
            When using Windows-1252 and DBCS, no additional character translation is required to display correctly in Internet Explorer.<br/>
            However, to make XML more compliant for Web browsers that can interpret UTF-8, you can optionally set the encoding attribute to
            UTF-8 instead of Windows-1252. The result set undergoes translation to UTF-8 characters only when you set nFlags to 48
            (specify the encoding attribute as UTF-8 and translate character data to UTF-8 format). This is required only when the data actually
            contains double-byte characters. You do not have to use character translation, <b>STRCONV ( )</b>, for example,
            if you are outputting only Latin (single byte) characters.
            <list type="table">
                <listheader>
                    <term>cSchemaName</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>cSchemaName</term>
                    <description>
                        Specifies the name and path of the external file for the schema (scoped to the root element of the XML).
                        <note name="Note">
                            If cSchemaName contains a file name and cSchemaLocation is not provided or is blank, the contents of cSchemaName xsi:schemaLocation or
                            xsi:noNamespaceSchemaLocation attribute in the XML.
                        </note>
                        In the following example, X# generates a generic XML file named MyXMLFile.xml from the Labels.dbf file in the "Labels" alias and the schema file named
                        MySchema in the same folder.
                         <code language="X#">CURSORTOXML("LABELS", "myXMLFile.xml", 1, 512, 0, "mySchema.xsd")</code>
                        If cSchemaName includes a URI, the schema is written to the current directory and must be uploaded to the server to be accessed by the browser or parser.
                        External schemas always are written to the same location as the XML file.
                    </description>
                </item>
                <item>
                    <term>"1"</term>
                    <description>
                        Specifies an inline schema is produced. For example, the following code produces an inline schema:
                         <code language="X#">CURSORTOXML("LABELS", "myXMLFile.xml", 1, 512, 0, "1")</code>
                    </description>
                </item>
                <item>
                    <term>""</term>
                    <description>Specifies that no schema is produced.</description>
                </item>
            </list>
        </remarks>
    </cursortoxml>
    <curval>
        <summary>
            Returns field values directly from disk for a table or a remote data source.
        </summary>
        <param name="cExpression">
            Specifies an expression whose value CurVal( ) returns from a table or a remote data source.
            cExpression is typically a field or an expression consisting of a set of fields from the table or remote data source.
        </param>
        <param name="uArea">
            Specifies the alias or workarea number of the table from which the field values are returned from disk for a table or a remote data source.
        </param>
        <returns>
            Character, Currency, Date, DateTime, Double, Float, Logical, Numeric, or Memo
        </returns>
        <remarks>
            The field values returned by CurVal( ) and OldVal( ) can be compared to determine if another user on a network changed the field values
            while the fields were being edited. CurVal( ) and OldVal( ) can only return different values when optimistic row or table buffering is enabled.
            Optimistic row or table buffering is enabled with CursorSetProp( ).<br/>
            If you are working with a view in a multiuser environment, the values returned by CurVal() might not be up to date unless you call the Refresh() function first.
            Data returned by a view is buffered, and the CurVal() function reads values from the buffer.
            However, if other users have changed data in the underlying tables for the view, the buffered data is not updated until the Refresh() function is called.<br/>
            CurVal( ) returns field values for the current record, and the return value data type is determined by the expression you specify with cExpression.<br/>
            The value is returned for the table or cursor open in the currently selected work area if CurVal( ) is issued without the optional uArea arguments.
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Clear
                Create Table mytable FREE (cDigit C(10))
                * Store original value
                Insert Into mytable (cDigit) VALUES ("One")
                Set MultiLocks ON        &amp;&amp; Allow optimistic table buffering
                = CursorSetProp("Buffering",5)   &amp;&amp; Optimistic table buffering on
                Replace cDigit WITH "Two"    &amp;&amp; New value
                ? "Current value: " + CurVal("cDigit", "mytable")
                ? "Old value: " + OldVal("cDigit", "mytable")
                = TableUpdate(.T.)       &amp;&amp; Commit changes made to table
                ? "Table changes committed"
                ? "New current value: " + CurVal("cDigit", "mytable")
                ? "New old value: " + OldVal("cDigit", "mytable")
            </code>
        </example>
    </curval>
    <dbalias>
        <summary>
            Returns database alias of currently set database.
        </summary>
        <returns>
            Character.
        </returns>
        <remarks>
            <b>DBAlias( )</b> returns the empty string if there is no current database.
        </remarks>
        <example>
            <code language="X#">
                Open Database HOME(2)+"northwind\northwind" SHARED
                Open Database HOME(2)+"tastrade\data\tastrade" SHARED
                Set Database TO NORTHWIND
                ? DBAlias()
                Set Database TO TASTRADE
                ? DBAlias()
                ? JUSTSTEM(DBC())
            </code>
        </example>
    </dbalias>
    <dbc>
        <summary>
            Returns the name and path of the current database.
        </summary>
        <returns>
            Character
        </returns>
        <remarks>
            <b>DBC( )</b> returns the empty string if there is no current database.
            Use Set Database to specify the current database.
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Open Database (HOME(2) + 'data\testdata')  &amp;&amp; Opens the DBC.
                Clear
                ? DBC( )  &amp;&amp; Displays the path and name of the database
            </code>
        </example>
    </dbc>
    <dbgetprop>
        <summary>
            Retrieves the value of a property for the current database or for fields, named connections, tables, or views in the current database.<br/>
            <note name="Note">
                You must open the database before you can retrieve its properties or those of its connections, tables, views, or fields.
                However, you do not need to open a table or view before retrieving its properties.
            </note>
        </summary>
        <param name="cName">
            Specifies the name of the current open database or the field, named connection, table,
            or view in the current open database for which <b>DbGetProp( )</b> returns information.<br/>
            To return information about a field in a table or a view, preface the name of the field with the name of the table or view containing the field.
            For example, to return information about the <c>custid</c> field in the <c>customer</c> table, specify the following for cName:
             <code language="X#">customer.custid</code>
        </param>
        <param name="cType">
            Specifies whether cName is the current database, or a field, named connection, table, or view in the current database.
            The table in the remarks section lists the values for cType.
        </param>
        <param name="cProperty">
            Specifies the name of the property for which <b>DbGetProp( )</b> returns information.<br/>
            The tables in the remarks section list the values you can specify for cProperty, the return value types, and descriptions of each property.
            Each description includes the read and write privileges for each property. If a property is read-only, its value cannot be changed with <b>DbSetProp( )</b>.
        </param>
        <returns>
            Character, Numeric, or Logical data type. <b>DbGetProp( )</b> returns the value for the specified property.
        </returns>
        <remarks>
            For more information about setting property values, see DbSetProp( ) Function.
            <list type="table">
                <listheader>
                    <term>cType</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>Connection</term>
                    <description>cName is a named connection in the current database.</description>
                </item>
                <item>
                    <term>Database</term>
                    <description>Name is the current database.</description>
                </item>
                <item>
                    <term>Field</term>
                    <description>cName is a field in the current database.</description>
                </item>
                <item>
                    <term>Table</term>
                    <description>cName is a table in the current database.</description>
                </item>
                <item>
                    <term>View</term>
                    <description>
                        cName is a view in the current database.
                    </description>
                </item>
            </list>


            <b>Connection properties</b>
            <list type="table">
                <listheader>
                    <term>cProperty</term>
                    <description>Type</description>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>Asynchronous</term>
                    <description>L</description>
                    <description>
                        The connection mode. (Default) False (.F.) specifies a synchronous connection. True (.T.) specifies an asynchronous connection.<br/>
                    </description>
                </item>
                <item>
                    <term>BatchMode</term>
                    <description>L</description>
                    <description>
                        The batch-processing mode. (Default) True (.T.) specifies the connection that operates in batch mode.
                    </description>
                </item>
                <item>
                    <term>Comment</term>
                    <description>C</description>
                    <description>The text of the connection comment.</description>
                </item>
                <item>
                    <term>ConnectString</term>
                    <description>C</description>
                    <description>The login connection string.</description>
                </item>
                <item>
                    <term>ConnectTimeout</term>
                    <description>N</description>
                    <description>The connection timeout interval in seconds. The default is 0 (wait indefinitely).</description>
                </item>
                <item>
                    <term>Database</term>
                    <description>C</description>
                    <description>The name of the server database specified with the Database clause in the Create Connection command or in the Connection Designer.</description>
                </item>
                <item>
                    <term>DataSource</term>
                    <description>C</description>
                    <description>The name of the data source as defined in the Odbc.ini file.</description>
                </item>
                <item>
                    <term>DisconnectRollback</term>
                    <description>L</description>
                    <description>
                        Specifies if a pending transaction is committed or rolled back when SqlDisconnect( ) is called for the last connection handle.<br/>
                        The default is false (.F.), indicating that a pending transaction is committed when SqlDisconnect( ) is called for the last connection handle.<br/>
                        Specify true (.T.) to roll back a pending transaction when SqlDisconnect( ) is called for the last connection handle.<br/>
                        Connections with automatic transaction processing are not affected by this setting.
                    </description>
                </item>
                <item>
                    <term>DispLogin</term>
                    <description>N</description>
                    <description>
                        Contains a numeric value that determines when the ODBC Login dialog box is displayed. DispLogin may assume the following values:<br/>
                        1 or DB_PROMPTCOMPLETE (from Foxpro.h). 1 is the default.<br/>
                        2 or DB_PROMPTALWAYS (from Foxpro.h).<br/>
                        3 or DB_PROMPTNEVER (from Foxpro.h).<br/>
                        If 1 or DB_PROMPTCOMPLETE is specified, X# displays the ODBC Login dialog box only if any required information is missing.<br/>
                        If 2 or DB_PROMPTALWAYS is specified, the ODBC Login dialog box is always displayed, allowing you to change settings before connecting.<br/>
                        If 3 or DB_PROMPTNEVER is specified, the ODBC Login dialog box is not displayed and
                        X# generates an error if the required login information is not available.
                    </description>
                </item>
                <item>
                    <term>DispWarnings</term>
                    <description>L</description>
                    <description>
                        Contains a logical value that determines if non-trappable warnings from the remote table,
                        ODBC, or X# are displayed. (Default) True (.T.) specifies that non-trappable errors are displayed.
                    </description>
                </item>
                <item>
                    <term>IdleTimeout </term>
                    <description>N</description>
                    <description>
                        The idle timeout interval in minutes. Timeout is checked no more than once per minute,
                        therefore it is possible that active connections might deactivate one or two minutes later after the specified time interval has elapsed.
                        The default value is 0 (wait indefinitely).
                    </description>
                </item>
                <item>
                    <term>PacketSize</term>
                    <description>N</description>
                    <description>
                        The size of the network packet used by the connection.
                        Adjusting this value can improve performance. The default value is 4096 bytes (4K).
                    </description>
                </item>
                <item>
                    <term>PassWord</term>
                    <description>C</description>
                    <description>The connection password.</description>
                </item>
                <item>
                    <term>QueryTimeout</term>
                    <description>N</description>
                    <description>The query timeout interval in seconds. The default value is 0 (wait indefinitely).</description>
                </item>
                <item>
                    <term>Transactions</term>
                    <description>N</description>
                    <description>
                        Contains a numeric value that determines how the connection manages transactions on the remote table. Transactions may assume the following values:<br/>
                        1 or DB_TRANSAUTO (from Foxpro.h). 1 is the default. Transaction processing for the remote table is handled automatically.<br/>
                        2 or DB_TRANSMANUAL (from Foxpro.h). Transaction processing is handled manually through SqlCommit( ) and SqlRollBack( ).
                    </description>
                </item>
                <item>
                    <term>UserId</term>
                    <description>C</description>
                    <description>The user identification.</description>
                </item>
                <item>
                    <term>WaitTime</term>
                    <description>N</description>
                    <description>
                        The amount of time in milliseconds that elapses before X# checks whether the SQL statement has completed executing.
                        The default is 100 milliseconds.
                    </description>
                </item>
            </list>
            <note name="Note">All of these are read/write</note><br/><br/>

            <b>Database properties</b>
            <list type="table">
                <listheader>
                    <term>cProperty</term>
                    <description>Type</description>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>Comment</term>
                    <description>C</description>
                    <description>
                        The text of the database comment.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>DBCEventFileName</term>
                    <description>C</description>
                    <description>Relative path and filename of external program file containing DBC Events code.</description>
                </item>
                <item>
                    <term>DBCEvents</term>
                    <description>L</description>
                    <description>Enabled state of DBC Events. Set to True (.T.) to enable.</description>
                </item>
                <item>
                    <term>Version</term>
                    <description>N</description>
                    <description>
                        The database version number.<br/>
                        Read-only.
                    </description>
                </item>
            </list>
            <br/><br/>
            <b>Field properties for tables</b>
            <list type="table">
                <listheader>
                    <term>cProperty</term>
                    <description>Type</description>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>Caption</term>
                    <description>C</description>
                    <description>
                        The field caption. If an equal sign (=) precedes the value of this property, X# evaluates the value as an expression.
                        Otherwise, it is treated as a string literal.
                    </description>
                </item>
                <item>
                    <term>Comment</term>
                    <description>C</description>
                    <description>
                        The text of the field comment.
                    </description>
                </item>
                <item>
                    <term>DefaultValue</term>
                    <description>C</description>
                    <description>The field default value.</description>
                </item>
                <item>
                    <term>DisplayClass</term>
                    <description>C</description>
                    <description>Name of the class used for field mapping.</description>
                </item>
                <item>
                    <term>DisplayClassLibrary</term>
                    <description>C</description>
                    <description>
                        Path to the class library specified with the <b>DisplayClass</b> property.
                    </description>
                </item>
                <item>
                    <term>Format</term>
                    <description>C</description>
                    <description>The field display format. See the Format Property for a list of format settings.</description>
                </item>
                <item>
                    <term>InputMask</term>
                    <description>C</description>
                    <description>The field input format. See the InputMask Property for a list of input mask settings.</description>
                </item>
                <item>
                    <term>RuleExpression</term>
                    <description>C</description>
                    <description>The field rule expression.</description>
                </item>
                <item>
                    <term>RuleText</term>
                    <description>C</description>
                    <description>The field rule error text.</description>
                </item>
            </list>
            <note name="Note">All of these are read/write</note><br/><br/>

            <b>Field properties for views</b>
            <list type="table">
                <listheader>
                    <term>cProperty</term>
                    <description>Type</description>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>Caption</term>
                    <description>C</description>
                    <description>
                        The field caption. If an equal sign (=) precedes the value of this property,
                        Visual FoxPro evaluates the value as an expression. Otherwise, it is treated as a string literal.
                    </description>
                </item>
                <item>
                    <term>Comment</term>
                    <description>C</description>
                    <description>The text of the field comment.</description>
                </item>
                <item>
                    <term>DataType</term>
                    <description>C</description>
                    <description>
                        The data type for a field in a view. Initially set to the data type for the field in the data source.<br/>
                        To specify a different data type for a field with <b>DbSetProp( )</b>, use the syntax for creating fields in Create Table  SQL.<br/>
                        For example, to change the data type of an integer field named iCost in a table named Mytable to numeric type with width 4 and 2 decimal places,
                        use DbSetProp('mytable.icost', 'field', ; 'DataType', 'N(4,2)')<br/>
                        You can also include the NOCPTRANS clause to prevent translation of character and memo fields to a different code page.<br/>
                        Read/write for remote views.
                    </description>
                </item>
                <item>
                    <term>DisplayClass</term>
                    <description>C</description>
                    <description>Name of the class used for field mapping.</description>
                </item>
                <item>
                    <term>DisplayClassLibrary</term>
                    <description>C</description>
                    <description>
                        Path to the class library specified with the <b>DisplayClass</b> property.
                    </description>
                </item>
                <item>
                    <term>DefaultValue</term>
                    <description>C</description>
                    <description>The field default value</description>
                </item>
                <item>
                    <term>KeyField</term>
                    <description>L</description>
                    <description>Contains True (.T.) if the field is specified in an index key expression; otherwise, contains False (.F.).</description>
                </item>
                <item>
                    <term>RuleExpression</term>
                    <description>C</description>
                    <description>The field rule expression.</description>
                </item>
                <item>
                    <term>RuleText</term>
                    <description>C</description>
                    <description>The field rule error text.</description>
                </item>
                <item>
                    <term>Updatable</term>
                    <description>L</description>
                    <description>Contains True (.T.) if the field can be updated; otherwise, contains False (.F.).</description>
                </item>
                <item>
                    <term>UpdateName</term>
                    <description>C</description>
                    <description>The name of the field used when data in the field is updated to the remote table. By default, the remote table field name.</description>
                </item>
            </list>
            <note name="Note">All of these are read/write</note><br/><br/>

            <b>Table properties</b>
            <list type="table">
                <listheader>
                    <term>cProperty</term>
                    <description>Type</description>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>Comment</term>
                    <description>C</description>
                    <description>
                        The text of the table comment.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>DeleteTrigger</term>
                    <description>C</description>
                    <description>
                        The Delete trigger expression.<br/>
                        Read-only.
                    </description>
                </item>
                <item>
                    <term>InsertTrigger</term>
                    <description>C</description>
                    <description>
                        The Insert trigger expression.<br/>
                        Read-only.
                    </description>
                </item>
                <item>
                    <term>Path</term>
                    <description>C</description>
                    <description>
                        The relative path with respect to the DBC to the table including the name of the file.<br/>
                        Read-only.
                    </description>
                </item>
                <item>
                    <term>PrimaryKey</term>
                    <description>C</description>
                    <description>
                        The tag name of the primary key.<br/>
                        Read-only.
                    </description>
                </item>
                <item>
                    <term>RuleExpression</term>
                    <description>C</description>
                    <description>
                        The row rule expression.<br/>
                        Read-only.
                    </description>
                </item>
                <item>
                    <term>RuleText</term>
                    <description>C</description>
                    <description>
                        The row rule error text.<br/>
                        Read-only.
                    </description>
                </item>
                <item>
                    <term>UpdateTrigger</term>
                    <description>C</description>
                    <description>
                        The Update trigger expression.<br/>
                        Read-only.
                    </description>
                </item>
            </list><br/><br/>

            <b>View properties</b>
            <list type="table">
                <listheader>
                    <term>cProperty</term>
                    <description>Type</description>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>AllowSimultaneousFetch</term>
                    <description>L</description>
                    <description>
                        Applies when using remote views, a shared connection, and to cursors created using ODBC.<br/>
                        AllowSimultaneousFetch contains True (.T.) when similarly configured cursors sharing the connection are permitted to fetch rows simultaneously.<br/>
                        Otherwise, AllowSimultaneousFetch contains False (.F.) when fetching rows simultaneously is not permitted.
                        <note name="Note">
                            This property is available in X# 8.0 and later. Views created in X# 8.0 and later are not compatible with earlier versions.
                            Calling the <b>VALIDATE Database</b> command in a version prior to X# 8.0 on a database container with remote views created or modified in X# 8.0
                            and later generate an error. Calling the <c>VALIDATE Database RECOVER</c> in a version prior to X# 8.0 removes the <b>AllowSimultaneousFetch</b>
                            property from any such views.
                        </note>
                    </description>
                </item>
                <item>
                    <term>BatchUpdateCount</term>
                    <description>N</description>
                    <description>
                        The number of update statements sent to the back end for views. 1 is the default.
                        Adjusting this value can greatly increase update performance.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>Comment</term>
                    <description>C</description>
                    <description>
                        The text of the view comment.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>CompareMemo</term>
                    <description>L</description>
                    <description>
                        Contains true (.T.) (default) if memo fields (of type Memo, General, or Picture, or, for remote views, type Timestamp)
                        are included in the Where clause for updates; otherwise, contains false (.F.).<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>ConnectName</term>
                    <description>C</description>
                    <description>
                        The named connection used when the view is opened.<br/>
                        Read-only.
                    </description>
                </item>
                <item>
                    <term>FetchAsNeeded</term>
                    <description>L</description>
                    <description>
                        If True (.T.), data is fetched only when needed, such as when record pointer moves to a row that has not been fetched.<br/>
                        If False (.F.), additional data is fetched during idle time. (Default)<br/>
                        <note name="note">FetchAsNeeded does not apply when progressive fetching is disabled (FetchSize is -1).</note><br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>FetchMemo</term>
                    <description>L</description>
                    <description>
                        Contains true (.T.) (default) if memo and general fields are fetched with the view results; otherwise, contains false (.F.).<br/>
                        Use the ISMEMOFETCHED( ) Function to determine if the memo field has been fetched.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>FetchSize</term>
                    <description>N</description>
                    <description>
                        Contains the number of records fetched at a time from the remote tables. The default is 100 records.
                        Setting FetchSize to 1 retrieves the complete result set, limited by the MaxRecords setting.<br/>
                        <note name="Note">
                            Progressive fetching holds the connection until all rows are retrieved.
                            Use caution coding with FetchSize if ShareConnection is True (.T.).
                        </note><br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>MaxRecords</term>
                    <description>N</description>
                    <description>
                        The maximum number of records fetched when result sets are returned. The default is  1 (all rows are returned).<br/>
                        A value of 0 specifies that the view is executed but no results are fetched.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>Offline</term>
                    <description>L</description>
                    <description>
                        Contains true (.T.) if the view is an offline view.<br/>
                        Read-only.
                    </description>
                </item>
                <item>
                    <term>ParameterList</term>
                    <description>C</description>
                    <description>
                        The Where clause parameters. The format for the parameters is ''ParameterName1, 'Type1'; ParameterName2, 'Type2'; ...'' where Type
                        is a one of the following characters specifying the parameter type:<br/>
                        C  Character  D  Date  T  DateTime  N  Numeric  F  Floating  B  Double  I  Integer  Y  Currency  L - Logical<br/>
                        For example, ''MyParam1, 'C' '' specifies a single character type parameter named MyParam1.<br/>
                        For more information about creating parameterized views, see How to: Create Parameterized Views.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>Prepared</term>
                    <description>L</description>
                    <description>
                        Contains True (.T.) if SQL statements are prepared for subsequent <b>Requery( )</b> function calls.
                        <b>Requery( )</b> is used to retrieve data again for a SQL view. See SqlPrepare( ) for additional information about preparing SQL statements.
                        The default is false (.F.).<br/>
                        The rule text expression displayed when an error occurs when data is edited in a Browse or Edit window.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>RuleExpression</term>
                    <description>C</description>
                    <description>
                        The row rule expression.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>RuleText</term>
                    <description>C</description>
                    <description>
                        The rule text expression displayed when an error occurs when data is edited in a Browse or Edit window.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>SendUpdates</term>
                    <description>L</description>
                    <description>
                        Contains true (.T.) if a SQL update query is sent to update remote tables; otherwise, contains false (.F.) (default).<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>ShareConnection</term>
                    <description>L</description>
                    <description>
                        Contains true (.T.) if a SQL update query is sent to update remote tables; otherwise, contains false (.F.) (default).<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>ShareType</term>
                    <description>L</description>
                    <description>
                        Contains true (.T.) if the view can share its connection handle with other connections; otherwise, contains false (.F.).<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>SourceType</term>
                    <description>N</description>
                    <description>
                        The view source. SourceType may assume the following values:<br/>
                        1 - The view uses local tables.<br/>
                        2 - The view uses remote tables.<br/>
                        Read-only.
                    </description>
                </item>
                <item>
                    <term>SQL</term>
                    <description>C</description>
                    <description>
                        The SQL statement executed when the view is opened.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>Tables</term>
                    <description>C</description>
                    <description>
                        A comma-delimited list of the names of the tables.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>UpdateType</term>
                    <description>N</description>
                    <description>
                        The update type. Valid values are:<br/>
                        1 or DB_Update (from Foxpro.h). The old data is updated with the new data (default).<br/>
                        2 or DB_DeleteInsert (from Foxpro.h). The old data is deleted and the new data is inserted.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>UseMemoSize</term>
                    <description>N</description>
                    <description>
                        The minimum size (in bytes) for which result columns are returned in memo fields.
                        For example, if the width of a column result is greater than the value of UseMemoSize, the column result is stored in a memo field.
                        UseMemoSize may vary from 1 to 255; the default value is 255.<br/>
                        Read/write.
                    </description>
                </item>
                <item>
                    <term>WhereType</term>
                    <description>N</description>
                    <description>
                        The Where clause for updates to remote tables. WhereType may assume the following values:<br/>
                        1 or DB_KEY (from Foxpro.h). The Where clause used to update remote tables consists of
                        only the primary fields specified with the <b>KeyFieldList</b> property.<br/>
                        2 or DB_KEYANDUPDATable (from Foxpro.h). The Where clause used to update remote tables consists of the primary fields specified
                        with the <b>KeyFieldList</b> property and any updatable fields.<br/>
                        3 or DB_KEYANDMODIFIED (from Foxpro.h) (default). The Where clause used to update remote tables consists of the primary fields specified
                        with the <b>KeyFieldList</b> property and any other fields that are modified.<br/>
                        4 or DB_KEYANDTIMESTAMP (from Foxpro.h). The Where clause used to update remote tables consists of the primary fields specified
                        with the <b>KeyFieldList</b> property and a comparison of the time stamps.<br/>
                        For more information about the <b>WhereType</b> property, see Managing Updates by Using Views.<br/>
                        Read/write.
                    </description>
                </item>
            </list>
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Clear
                Open Database (HOME(2) + 'Data\testdata')
                * Displays the primary key field
                cResults = DbGetProp("customer", "Table", "PrimaryKey")
                =MessageBox(cResults)   &amp;&amp; Displays    'cust_id'
                * Displays comments for the field 'cust_id'
                cResults = DbGetProp("customer.cust_id", "Field", "Comment")
                IF LEN(ALLTRIM(cResults)) = 0
                =MessageBox("No Comment for this field." + CHR(13) + ;
                CHR (13) + "Use DbSetProp( ) to add comments.")
                ELSE
                =MessageBox("Cust_id field comments: " + cRESULTS)
                ENDIF
            </code>
        </example>
    </dbgetprop>
    <dbsetprop>
        <summary>
            Sets a property for the current database or for fields, named connections, tables, or views in the current database.
        </summary>
        <param name="cName">
            Specifies the name of the current open database or the field, named connection, table,
            or view in the current open database for which <b>DbGetProp( )</b> returns information.<br/>
            To set a property for a field in a table or a view, preface the name of the field with the name of the table or view containing the field.
            For example, to set a property for the <c>custid</c> field in the <c>customer</c> table, specify the following for cName:
             <code language="X#">customer.custid</code>
        </param>
        <param name="cType">
            Specifies whether cName is the current database or for a field, named connection, table, or view in the current database.
            The table in the remarks section lists the values you can specify for cType.
        </param>
        <param name="cProperty">
            Specifies the name of the property to set. If a property is read-only, its value cannot be changed with <b>DbSetProp( )</b>.
            If you attempt to set a property that is read-only, X# generates an error message.<br/>
            For more information on properties you can specify with cProperty, including their data types, see DbGetProp( ).
        </param>
        <param name="ePropertyValue">
            Specifies the value to which cProperty is set. ePropertyValue must be the same data type as the property's data type.<br/>
            <note name="Caution">
                X# does not verify that the value you specify is valid for the property. Thus, it is possible to set a property to an invalid value with <b>DbSetProp( )</b>.
                For example, <b>DbSetProp( )</b> can be used to set a field rule expression to an expression that is not valid for the field,
                and X# will not generate an error. To avoid an error when setting the Tables property of a view,
                precede ePropertyValue with the database designation in the following syntax:
                 <code language="X#">         &lt;databaseName&gt;!ePropertyValue</code>
            </note>
        </param>
        <returns>
            Logical data type. <b>DbSetProp( )</b> returns True (.T.) if X# successfully sets the property you specify. X# generates an error if the property you specify cannot be set.
        </returns>
        <remarks>
            <list type="table">
                <listheader>
                    <term>cType</term>
                    <description>description</description>
                </listheader>
                <item>
                    <term>Connection</term>
                    <description>cName is a named connection in the current database.</description>
                </item>
                <item>
                    <term>Database</term>
                    <description>cName is the current database</description>
                </item>
                <item>
                    <term>Field</term>
                    <description>cName is a field in the current database</description>
                </item>
                <item>
                    <term>Table</term>
                    <description>cName is a table in the current database</description>
                </item>
                <item>
                    <term>View</term>
                    <description>cName is a view in the current database</description>
                </item>
            </list><br/>
            For more information about retrieving current property values, see DbGetProp( ) Function.
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Clear
                Open Database (HOME(2) + 'data\testdata')
                Use customer     &amp;&amp; Open customer table
                = DbSetProp("customer.cust_id", "Field", "Comment", ;
                "Property has been set by DbSetProp.")  &amp;&amp; New field comments
                cRESULTS = DbGetProp("customer.cust_id", "Field", "Comment")
                WAIT "Cust_id field comments: "+ cRESULTS  &amp;&amp; Display comments
            </code>
        </example>
    </dbsetprop>
    <dbused>
        <summary>
            Returns true (.T.) if the specified database is open.
        </summary>
        <param name="cDatabaseName">
            Specifies the name of the database for which <b>DbUsed( )</b> returns a logical value indicating whether or not the database is open.
        </param>
        <returns>
            Logical
        </returns>
        <remarks>
            <b>DbUsed( ) </b>returns true (.T.) if the specified database is open; otherwise, it returns false (.F.).
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Open Database (HOME(2) + 'Data\testdata')
                Clear
                ? 'Testdata database open? '
                ?? DbUsed('testdata')     &amp;&amp; Displays .T.
                ? 'Test database open? '
                ?? DbUsed('test')     &amp;&amp; Displays .F.
            </code>
        </example>
    </dbused>
    <defaultext>
        <summary>
            Returns a file name with a new extension if one does not already exist.
        </summary>
        <param name="cFileName">
            Specifies the filename (with or without a path or extension) to be returned.
        </param>
        <param name="cDefault">
            Specifies the default extension without a period.
        </param>
        <returns>
            Character
        </returns>
    </defaultext>
    <difference>
        <summary>
            Returns an integer, 0 through 4, which represents the relative phonetic difference between two character expressions.
        </summary>
        <param name="cExpression1">Specifies the character expressions that DIFFERENCE( ) compares.</param>
        <param name="cExpression2">Specifies the character expressions that DIFFERENCE( ) compares.</param>
        <returns>
            Numeric
        </returns>
        <remarks>
            Difference( ) is useful for searching tables when the exact spelling of an entry isn't known.<br/>
            The more alike the two expressions are spelled, the higher the number Difference( ) returns.
            If the character expressions are spelled very similarly, Difference( ) returns 4. For two character expressions with little in common phonetically,
            Difference( ) returns 0.
        </remarks>
        <example>
             <code language="X#">
                STORE 'Smith' TO gcName1
                STORE 'Smythe'  TO gcName2
                STORE 'Smittie' TO gcName3
                STORE '' TO gcName4
                Clear
                ? Difference(gcName1, gcName2)  &amp;&amp; Displays 4
                ? Difference(gcName1, gcName3)  &amp;&amp; Displays 4
                ? Difference(gcName1, gcName4)  &amp;&amp; Displays 1
            </code>
        </example>
    </difference>
    <displaypath>
        <summary>
            Truncates long path expressions to a specified length for display.
        </summary>
        <param name="cFilename">
            Specifies the name of the file at the end of the target path. If you specify a string containing only spaces as cFileName, X# returns the current directory.
            If you specify an empty string as cFileName, DisplayPath( ) returns an empty string. You can obtain the path of the current directory by using the CurDir( ).<br/>
            This function does not check the validity of cFileName and will report the truncated path expression even if no such file exists.
        </param>
        <param name="nMaxLength">
            Specifies the maximum length of the truncated result. nMaxLength must be greater than or equal to 10 and less than or equal to 260
            Character data type. DisplayPath( ) returns a string and displays the path in lower case.
        </param>
        <remarks>
            DisplayPath( ) returns a string suitable only for display purposes, so you cannot use the result to reference a file.
            The length of the resulting string is equal to or less than nMaxLength. However, the result does not break directory names.
            If inclusion of a directory name would exceed nMaxLength, the result is an ellipsis (...).
            If the filename exceeds nMaxLength, the result is the filename plus extension.
        </remarks>
    </displaypath>
    <drivetype>
        <summary>
            Returns the type of the specified drive.
        </summary>
        <param name="cDrive">
            The drive designator. The colon in drive names (for example, "C:") is optional.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            The following table explains the number DriveType( ) returns and the corresponding drive type description:
            <list type ="table">
                <listheader>
                    <term>Number</term>
                    <description>Drive Type</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>No type</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Floppy disk</description>
                </item>
                <item>
                    <term>3</term>
                    <description>Hard disk</description>
                </item>
                <item>
                    <term>4</term>
                    <description>Removable drive or network drive</description>
                </item>
                <item>
                    <term>5</term>
                    <description>CD-ROM</description>
                </item>
                <item>
                    <term>6</term>
                    <description>RAM disk1</description>
                </item>
            </list>
            <note name="Note">Because there are many different types of RAM disks, you might get inconsistent return results.</note>
        </remarks>
    </drivetype>
    <dropoffline>
        <summary>
            Discards all changes made to an offline view and takes the offline view back online.
        </summary>
        <param name="cViewName">
            Specifies the name of the offline view to take back online.
        </param>
        <returns>
            Logical
        </returns>
        <remarks>
            DropOffline( ) returns a logical true (.T.) if the offline view is successfully taken back online; otherwise it returns false (.F.).
        </remarks>
    </dropoffline>
    <evl>
        <param name="eExpression1">
            Specifies an expression. eExpression1 can be any data type.
        </param>
        <param name="eExpression2">
            Specifies an expression. eExpression1 can be any data type.
        </param>
        <summary>
            Returns a non-empty value from two expressions.<br/>
            You can use the <b>EVL( )</b> function to return an appropriate substitute value instead of an empty value, such as False (.F.) or 0, from two expressions.
            You can also use this functionality to remove empty values from calculations or operations where empty values are not supported or relevant.<br/>
            The X# <b>Logical</b> value, False (.F.), and the <b>Numeric</b> value of 0 also evaluate to empty.
        </summary>
        <returns>
            Character, Date, DateTime, Numeric, Currency, Logical, Object.
            <b>EVL( )</b> returns eExpression1 if it does not evaluate to an empty value,
            otherwise, it returns eExpresssion2.
        </returns>
        <example>
            The following examples create the memory variables, <code>glEmptyDate</code>,
            which contains an empty <b>Date</b> value, and <code>glEmptyNum</code>,
            which contains an empty <b>Numeric</b> value, 0.<br/>
            When performing <b>EVL( )</b> with <code>glEmptyNum</code>, <b>EVL( )</b> returns an empty string ("")
            when evaluating <code>glEmptyNum</code> and an empty string,
            and code"None"/code when evaluating <code>glEmptyNum</code> and <code>"None"</code>.
             <code language="X#">
                STORE {  /  /  } TO glEmptyDate
                ? EVL(glEmptyDate,"")
                ? EVL(glEmptyDate, "None")
            </code>
            When performing EVL( ) with glEmptyNum, EVL( ) returns an empty string when evaluating glEmptyNum and an empty string,
            and "Empty" when evaluating glEmptyNum and "Empty".
             <code language="X#">
                STORE 0 TO glEmptyNum
                ? EVL(glEmptyNum,"")
                ? EVL(glEmptyNum, "Empty")
            </code>
        </example>
    </evl>

    <fldlist>
        <summary>
            Included for compatibility with dBASE.
        </summary>
    </fldlist>
    <fontmetric>
        <summary>
            Returns font attributes for the current installed operating system fonts.
        </summary>
        <param name="nAttribute">
            Determines the font attribute FontMetric( ) returns. If you omit cFontName, nFontSize, and cFontStyle,
            FontMetric( ) returns the attribute for the current font in the active output window.<br/>
            The table in the remarks section lists values for nAttribute and the corresponding font attributes returned.
        </param>
        <param name="cFontName">
            Specifies the name of an installed font.
        </param>
        <param name="nFontSize">
            Specifies the point size of the font specified with cFontName.
        </param>
        <param name="cFontStyle">
            Specifies a font style code for the font specified with cFontName. If you omit cFontStyle, FontMetric( ) returns the attribute for the Normal font style.<br/>
            cFontStyle can be a character or a combination of characters listed in the following font style table.
            For example, the combination BI specifies the Bold Italic font style.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            FontMetric( ) returns font attributes for the current font for the active output window. WFONT( ) can be used to determine the current window font.
            <list type="table">
                <listheader>
                    <term>nAttribute</term>
                    <description>Attribute</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>Character height in pixels</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Character ascent (units above baseline) in pixels</description>
                </item>
                <item>
                    <term>3</term>
                    <description>Character descent (units below baseline) in pixels</description>
                </item>
                <item>
                    <term>4</term>
                    <description>Leading (space between lines) in pixels</description>
                </item>
                <item>
                    <term>5</term>
                    <description>Extra leading in pixels</description>
                </item>
                <item>
                    <term>6</term>
                    <description>Average character width in pixels</description>
                </item>
                <item>
                    <term>7</term>
                    <description>Maximum character width in pixels</description>
                </item>
                <item>
                    <term>8</term>
                    <description>Font weight</description>
                </item>
                <item>
                    <term>9</term>
                    <description>Italic (0 = no, nonzero = yes)</description>
                </item>
                <item>
                    <term>10</term>
                    <description>Underlined (0 = no, nonzero = yes)</description>
                </item>
                <item>
                    <term>11</term>
                    <description>Strikeout (0 = no, nonzero = yes)</description>
                </item>
                <item>
                    <term>12</term>
                    <description>First character defined in font</description>
                </item>
                <item>
                    <term>13</term>
                    <description>Last character defined in font</description>
                </item>
                <item>
                    <term>14</term>
                    <description>Default character (substituted for characters not in font)</description>
                </item>
                <item>
                    <term>15</term>
                    <description>Word-break character</description>
                </item>
                <item>
                    <term>16</term>
                    <description>Pitch and family</description>
                </item>
                <item>
                    <term>17</term>
                    <description>Character set</description>
                </item>
                <item>
                    <term>18</term>
                    <description>Overhang (extra added width)</description>
                </item>
                <item>
                    <term>19</term>
                    <description>Horizontal aspect for font device</description>
                </item>
                <item>
                    <term>20</term>
                    <description>Vertical aspect for font device</description>
                </item>
            </list>
            <list type="table">
                <listheader>
                    <term>Character</term>
                    <description>Font style</description>
                </listheader>
                <item>
                    <term>B</term>
                    <description>Bold</description>
                </item>
                <item>
                    <term>I</term>
                    <description>Italic</description>
                </item>
                <item>
                    <term>N</term>
                    <description>Normal</description>
                </item>
                <item>
                    <term>O</term>
                    <description>Outline</description>
                </item>
                <item>
                    <term>Q</term>
                    <description>Extra leading in pixels</description>
                </item>
                <item>
                    <term>S</term>
                    <description>Shadow</description>
                </item>
                <item>
                    <term>-</term>
                    <description>Strikeout</description>
                </item>
                <item>
                    <term>T</term>
                    <description>Transparent</description>
                </item>
                <item>
                    <term>U</term>
                    <description>Underline</description>
                </item>
            </list>
            <br/><br/>
            For more information about the numeric values returned by FontMetric( ), see the TEXTMETRIC function in the Microsoft Windows Programmer's Reference.
        </remarks>
    </fontmetric>
    <fullpath>
        <summary>
            Returns the path to a specified file or the path relative to another file.
        </summary>
        <param name="cFileName1">
            Specifies the file for which X# searches.
            <note name="Note">Be sure to include the file name extension.</note>
            If the file is located in the X# path, the path is returned with the file name. You can specify the X# path using the Set PATH command.
            If the file cannot be located in the X# path, FullPath( ) returns the current directory the path and
            file name as if the file was located in the current default directory.
        </param>
        <param name="uPath">
            Specifies to search the MS-DOS path instead of the X# path. nMSDOSPath can have any numeric value.
            If the file cannot be located in the MS-DOS path, FullPath( ) returns the path and the file name as if the file was located in the current default directory.
        </param>
        <returns>
            Character. FullPath( ) returns a file path.
        </returns>
        <remarks>
            Use the <b>FILE( )</b> function to verify that the file actually exists; otherwise, if the file does not exist,
            the function returns the file name with the current directory.
        </remarks>
    </fullpath>
    <fv>
        <summary>
            Returns the future value of a financial investment.
        </summary>
        <param name="nPayment">
            Specifies the constant periodic payment (which can be negative or positive).
        </param>
        <param name="nInterestRate">
            Specifies the periodic interest rate. If the interest rate is annual but the payments are made monthly, divide the annual interest rate by 12.
        </param>
        <param name="nPeriods">
            Specifies the number of periods over which payments are made. FV( ) assumes that the periodic payments are made at the end of each period.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            FV( ) computes the future value of a series of constant periodic payments earning fixed compound interest.
            The future value is the total of all payments and the interest.
        </remarks>
        <example>
             <code language="X#">
                STORE 500 TO gnPayment  &amp;&amp; Monthly payment
                STORE .075/12 TO gnInterest     &amp;&amp; 7.5% annual interest rate
                STORE 48 TO gnPeriods  &amp;&amp; Four years (48 months)
                Clear
                ? FV(gnPayment, gnInterest, gnPeriods)    &amp;&amp; Displays 27887.93
            </code>
        </example>
    </fv>
    <getautoincvalue>
        <summary>
            Returns the last value generated for an autoincremented field within a data session.
        </summary>
        <param name="nDataSessionNumber">
            Specifies the data session number of the data session for which the autoincremented field value is returned.
            The autoincremented field value is returned for the current data session if you omit the nDataSessionNumber and 0 parameters.
            Use Set DATASESSION to activate a specific data session.
        </param>
        <param name="0">
            Specifies that the last autoincremented field value returned is derived from the current scope (function, method, procedure).
            Use this to prevent events outside of that current code block, such as ON KEY LABEL, from executing code that could alter the value unexpectedly.
        </param>
        <returns>
            Numeric data type. The value returned by GetAutoIncValue( ) is the last autoincrement value generated, even if a field was not successfully updated with
            the autoincrement value. .NULL. is returned if an autoincrement value hasn't yet been generated for a data session. For example, .NULL. is returned
            if a data session is opened and no updates have occurred.
        </returns>
        <remarks>
            The autoincremented field value is updated for table operations such as Append Command, Insert Command, Append From Command,
            and Blank Command when the AutoInc option is included. See Autoincrementing Field Values in Tables for more information about autoincrementing fields.
        </remarks>
    </getautoincvalue>
    <getcolor>
        <summary>
            Displays the Windows Color dialog box and returns the color number of the chosen color.
        </summary>
        <param name="nDefaultColorNumber">
            Specifies the color that is initially selected when the Color dialog box is displayed. If nDefaultColorNumber doesn't correspond to a color in the
            Color dialog box, the first color in the Color dialog box is selected. If you omit nDefaultColorNumber, black is selected.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            GetColor( ) returns  1 if you exit the Color dialog box by pressing Esc, choosing the Cancel button, or choosing Close from the Control menu.
        </remarks>
        <example>
             <code language="X#">
                Clear
                ? GetColor(255)
            </code>
        </example>
    </getcolor>
    <getcp>
        <summary>
            Prompts for a code page by displaying the Code Page dialog box, and then returns the number of the code page chosen.
        </summary>
        <param name="nCodePage">
            Specifies the number of the code page that is initially selected when the Code Page dialog box is displayed.
            If nCodePage is 0 or if you omit nCodePage, a code page isn't selected when the Code Page dialog box is displayed.
        </param>
        <param name="cText">
            Specifies the text displayed in the Code Page dialog box. If you omit cText, X# displays the following text:
            "Please select a code page for cross-platform data sharing."
        </param>
        <param name="cDialogTitle">
            Specifies the title that appears in the Code Page dialog box title bar. If you omit cDialogTitle, the title "Code Page" is displayed.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            GetCp( ) returns 0 if you exit the Code Page dialog box by pressing Esc, choosing the Cancel button, or choosing Close from the Control menu.<br/>
            The code pages listed in the Code Page dialog box are determined by Foxpro.INT, the X# International code page support file.<br/>
            You can include GetCp( ) in commands such as MODIFY COMMAND, Append From, and COPY TO that support the AS nCodePage clause. <br/>
            The Code Page dialog box is displayed, making it possible for you to specify the code page of the file opened, appended, or created.<br/>
            Because no code page 0 exists, you must trap for 0 in case the user chooses Esc, the Cancel button, or Close from the Control menu.
        </remarks>
        <example>
             <code language="X#">? GetCp(1252, "Select a Code Page", "Code Page Selection")</code>
        </example>
    </getcp>
    <getcursoradapter>
        <summary>
            Returns an object reference to a <b>CursorAdapter</b> object at run time by referencing the cursor name.
        </summary>
        <param name="cAlias">
            Specifies the alias of the cursor. If you do not supply an alias, X# uses the alias for the cursor in the current work area.
        </param>
        <returns>
            An object reference to a <b>CursorAdapter</b> object.
        </returns>
        <remarks>
            Applies To: CursorAdapter Class
        </remarks>
    </getcursoradapter>
    <getdir>
        <summary>
            Displays the Select Directory dialog box from which you can choose a directory.
        </summary>
        <param name="cDirectory">
            Specifies the directory that is initially displayed in the dialog box. When cDirectory is not specified,
            the dialog box opens with the X# default directory displayed.
        </param>
        <param name="cText">
            Specifies the text for the directory list in the dialog box.
        </param>
        <param name="cCaption">
            Specifies the caption to display in the dialog title bar. The Windows default is "Select Directory".
        </param>
        <param name="nFlags">
            Specify the options for the dialog box. nFlags can include zero or an additive combination of the values.<br/>
            The table in the remarks section includes some of more common flags. For more information, see SHBrowseForFolder in MSDN.
        </param>
        <param name="lRootOnly">
            Specifies that only cDirectory and its subfolders display. This parameter prevents navigation above the root folder.
            If you do not specify cDirectory, the default directory (Set DEFAULT value) is used.
        </param>
        <returns>
            Character
        </returns>
        <remarks>
            GetDir( ) returns as a character string the name of the directory you choose.<br/>
            If you do not choose a directory (you click Cancel, press Esc, or choose Close from the window menu), GetDir( ) returns the empty string.<br/>
            Beginning with X# 7, GetDir( ) supports two different dialog boxes. If you provide fewer than three parameters,
            GetDir( ) returns the dialog box from earlier versions. If you provide more than two parameters,
            X# uses the <b>SHBrowseForFolder </b>routine from the Win32 API to provide the dialog.<br/>

            <list type="table">
                <listheader>
                    <term>nFlag</term>
                    <description>Value</description>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>BIF_RETURNONLYFSDIRS</description>
                    <description>
                        Return only file system directories (physical locations). If a user selects folders that are not part of the file system, the OK button is grayed.
                    </description>
                </item>
                <item>
                    <term>2</term>
                    <description>
                        BIF_DONTGOBELOWDOMAIN
                    </description>
                    <description>
                        Do not include network folders below the domain level in the tree view control (For example, My Computer and My Networks).
                    </description>
                </item>
                <item>
                    <term>8</term>
                    <description>
                        BIF_RETURNFSANCESTORS
                    </description>
                    <description>
                        Return only file system ancestors. If a user selects anything other than a file system ancestor, the OK button is grayed.
                    </description>
                </item>
                <item>
                    <term>16</term>
                    <description>
                        BIF_EDITBOX
                    </description>
                    <description>
                        The browse dialog includes an edit control in which the user can type the name of an item. Available on Windows 98 and above,
                        or with Internet Explorer 4.0 or higher (assuming shell integration option selected). Requires version 4.71 of shell32.dll.
                    </description>
                </item>
                <item>
                    <term>32</term>
                    <description>BIF_VALIDATE</description>
                    <description>
                        Validates the editbox contents. If the editbox is used, it is necessary to validate the user-specified content.
                        If the user types an invalid name into the edit box, the Cancel button becomes the only selection available.
                        This flag is ignored if BIF_EDITBOX is not specified.
                    </description>
                </item>
                <item>
                    <term>64</term>
                    <description>
                        BIF_NEWDIALOGSTYLE
                    </description>
                    <description>
                        Use the new user-interface. Setting this flag provides the user with a larger, resizable dialog box. Additional functionality includes:
                        drag and drop capability within the dialog box, reordering, context menus, new folders, delete, and other context menu commands.
                        Support in Windows 2000 and above. Requires version 5.00 of shell32.dll.
                    </description>
                </item>
                <item>
                    <term>16384</term>
                    <description>
                        BIF_BROWSEINCLUDEFILES
                    </description>
                    <description>
                        The browse dialog will display files as well as folders. Available on Windows 98 and above, or with Internet Explorer 4.0 or higher
                        (assuming shell integration option selected). Requires version 4.71 of shell32.dll.
                    </description>
                </item>
            </list>
        </remarks>
    </getdir>
    <getfile>
        <summary>
            Displays the Open dialog box.
        </summary>
        <param name="cFileExtensions">
            Specifies the file name extensions for the files to display in the Open dialog box when the All Files type is not chosen.<br/>
            For more information on this, see the remarks section
        </param>
        <param name="cText">
            Specifies text to display for the File Name label in the Open dialog box.
        </param>
        <param name="cOpenButtonCaption">
            Specifies a caption for the OK button in the Open dialog box.
        </param>
        <param name="nButtonType">
            Specifies the number and type of buttons that appear in the Open dialog box. The table in the remarks section lists the values for nButtonType.
        </param>
        <param name="cTitleBarCaption">
            Specifies the caption for the title bar of the Open dialog box.
        </param>
        <remarks>
            When passing a value as a literal, enclose it with quotation marks (""). Do not include a period (.) in front of file name extensions.<br/>
            <note name="Note">The cFileExtensions parameter cannot exceed 254 characters in length.</note>
            cFileExtensions can take a variety of forms:<br/>
            <list type="bullet">
                <term>If cFileExtensions contains a single extension, for example, "prg", the Open dialog box displays only those file names with that extension.</term>
                <term>If cFileExtensions is the empty string, the Open dialog box displays all files in the current directory.</term>
                <term>
                    cFileExtensions can contain wildcard characters such as * and ?. The Open dialog box displays all file names with extensions that meet the wildcard criteria.
                    For example, if cFileExtensions is "?X?", the Open dialog box displays all file names with the extension .fxp, .exe, and .txt.
                </term>
                <term>
                    cFileExtensions can contain a file description followed by a file extension or a list of file extensions separated with commas.
                    The file description appears in the Open dialog box in the Files of Type list.
                    Separate the file description from the file extension or list of file extensions with a colon (:).
                    Separate multiple file descriptions and their file extensions with a semicolon (;).
                </term>
                <term>
                    For example, if cFileExtensions is "Text:TXT", the Open dialog box displays the file description "Text" in the Files
                    of Type list and displays all files with a .txt extension.
                </term>
                <term>
                    If cFileExtensions is "Tables:DBF; Files:TXT,BAK" the file descriptions "Tables" and "Files" appear in the Files of Type list.
                    When "Tables" is chosen from the Files of Type list, all files with a .dbf extension are displayed. When "Files" is chosen from the Files of Type list,
                    all files with .txt and .bak extensions are displayed.
                </term>
                <term>If cFileExtensions contains just a semicolon (";"), the Open dialog box displays all files without extensions.</term>
            </list>
            <list type="table">
                <listheader>
                    <term>nButtonType</term>
                    <description>Buttons isplayed</description>
                </listheader>
                <item>
                    <term>0 (or omitted)</term>
                    <description>OK, Cancel</description>
                </item>
                <item>
                    <term>1</term>
                    <description>OK, New, Cancel</description>
                </item>
                <item>
                    <term>2</term>
                    <description>OK, None, Cancel</description>
                </item>
            </list><br/>

            <note name="Note">
                GetFile( ) returns the string "Untitled" with the path specified in the Open dialog box when nButtonType is set to 1 and the user
                clicks New, or when nButtonType is set to 2 and the user clicks None.
            </note>
        </remarks>
        <returns>
            Character. GetFile( ) returns the name of the file chosen in the Open dialog box or the empty string if the user closes the Open dialog box by pressing Esc,
            clicking Cancel or the Close button on the Open dialog box.
        </returns>
        <example>
             <code language="X#">
                Close Databases
                Select 0
                gcTable=GetFile('DBF', 'Browse or Create a .DBF:',
                'Browse', 1, 'Browse or Create')
                DO CASE
                CASE 'Untitled' $ gcTable
                Create (gcTable)
                CASE EMPTY(gcTable)
                RETURN
                OTHERWISE
                Use (gcTable)
                BROWSE
                ENDCASE
            </code>
        </example>
    </getfile>
    <getfldstate>
        <summary>
            Returns a numeric value indicating if a field in a table or cursor has been modified or had a record appended,
            or if the deleted status of the current record has been changed.
        </summary>
        <param name="uField">
            Specifies the name of the field or the number of the field for which the modification status is returned.
            The field number nFieldNumber corresponds to the position of the field in the table or cursor structure.
            Display Structure or Field( ) can be used to determine a field's number.<br/>
            You can specify 1 for nFieldNumber to return a character string consisting of deletion and modification status values for all fields in the table or cursor.
            For example, if a table has five fields and only the first field has been changed, GetFldState( ) returns 121111.<br/>
            The 1 in the first position indicates the deletion status has not been changed.<br/>
            You can also include 0 for nFieldNumber to determine if the deletion status of the current record has changed since the table or cursor was opened.

            <note name="Note">
                Using GetFldState() only determines if the deletion status of the current record has changed.
                For example, if you mark a record for deletion and then recall it, GetFldState() indicates the deletion status has changed even though the record's deletion
                status has returned to its original state. Use Deleted() to determine the current deletion status of a record.
            </note>
        </param>
        <param name="uArea">
            Specifies the alias of the table or cursor for which the field modification or record deletion status is returned.<br/>
            Or<br/>
            Specifies the work area of the table or cursor for which the field modification or record deletion status is returned.<br/>
            If you do not specify an alias or work area, GetFldState( ) returns a value for a field in the currently selected table or cursor.
        </param>
        <returns>
            Numeric, Character, or .NULL.
        </returns>
        <remarks>
            The following table lists the character return values and the corresponding modification or deletion status.
            <list type="table">
                <listheader>
                    <term>Return value</term>
                    <description>Modification or deletion status</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>Field has not been modified or deletion status has not changed.</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Field has been modified or deletion status has changed.</description>
                </item>
                <item>
                    <term>3</term>
                    <description>Field in an appended record has not been modified or deletion status has not changed for the appended record.</description>
                </item>
                <item>
                    <term>4</term>
                    <description>Field in an appended record has been modified or deletion status has changed for the appended record.</description>
                </item>
                <item>
                    <term>.NULL.</term>
                    <description>At EOF( )</description>
                </item>
            </list>
            Row or table buffering must first be enabled with CursorSetProp( ) for GetFldState( ) to operate on local tables.<br/>
            The modification or deletion status is returned for the table or cursor open in the currently selected work area if GetFldState( ) is issued
            without the optional uArea arguments.<br/>
            Any change in a field will cause GetFldState() to return a value showing that the field has been modified, whether the change is explicit or implicit.
            An example of an explicit modification would be including the field in a Replace or Insert Into command. An implicit modification occurs in a field that
            has a default value when any command is issued that adds a new record.
        </remarks>
        <examples>
            The following example demonstrates how you can use GetFldState( ) to determine if the contents of a field have changed. MultiLocks is set to ON,
            a requirement for table buffering. The <c>customer</c> table in the <c>testdata</c> database is opened,
            and CursorSetProp( ) is then used to set the buffering mode to optimistic table buffering (5).
            GetFldState( ) is issued to display a value (1) corresponding to the unmodified state of the <c>cust_id</c> field before it is modified.
            The <c>cust_id</c> field is modified with Replace, and GetFldState( ) is issued again to display a value (2)
            corresponding to the modified state of the <c>cust_id</c> field. TableRevert( ) is used to return the table to its original state,
            and GetFldState( ) is issued again to display a value (1) corresponding to the original state of the <c>cust_id</c> field.
             <code language="X#">
                Close Databases
                Clear
                Set MultiLocks ON         &amp;&amp; Allow table buffering
                Open Database (HOME(2) + 'data\testdata')
                Use Customer             &amp;&amp; Open customer table
                =CursorSetProp("Buffering",5,"customer")  &amp;&amp; Enable table buffering
                * Get field state on original cust_id field and display state
                nState=<b>GetFldState(</b>"cust_id"<b>)</b>
                DO DisplayState WITH nState, "Original"
                * Change field contents and display state
                Replace cust_id    WITH "***"
                nState=<b>GetFldState(</b>"cust_id"<b>)</b>
                DO DisplayState WITH nState, "After Replace"
                * Discard table changes and display state
                = TableRevert(.T.)        &amp;&amp; Discard all table changes
                nState=<b>GetFldState(</b>"cust_id"<b>)</b>
                DO DisplayState WITH nState, "After Revert"
                PROCEDURE DisplayState
                PARAMETER nState,cOperation
                DO CASE
                CASE nState=1
                =MessageBox("Field has not been modified",0,cOperation)
                OTHERWISE
                =MessageBox("Field has been modified",0,cOperation)
                ENDCASE
            </code>
            The following example shows the difference in behavior between fields with and without default values.
             <code language="X#">
                Set MultiLocks ON
                Create Database example
                Create Table customer (cust_id C(6),state C(2) DEFAULT "FL")
                Close TableS
                Use customer
                =CursorSetProp("Buffering",5,"customer")
                Append Blank
                ?GetFldState("cust_id")     &amp;&amp; Returns 3, field in an appended record has
                &amp;&amp; not been modified.
                ?GetFldState("state")    &amp;&amp; Returns 4, field in an appended record has
                &amp;&amp; been modified.
            </code>
        </examples>
    </getfldstate>
    <getfont>
        <summary>
            Displays the Font dialog box and returns information about the font you choose.
        </summary>
        <param name="cFontName">
            Specifies the name of the font initially selected in the Font dialog box. If the font you specify is not installed, the default font is selected initially.
        </param>
        <param name="nFontSize">
            Specifies the font size selected initially in the Font dialog box. If the font size you specify is not supported, the default font size is selected initially.
            If you omit nFontSize or if nFontSize is less than or equal to zero, the font size selected defaults to 10 point.<br/>
            <note name="Note">
                The dialog box permits you to select sizes between <code>4</code> and <code>127</code>, inclusive. You can specify other values for nFontSize when calling the
                <b>GetFont</b> function; no error occurs. If you do so, however, the user must select a size within the designated range of values before clicking <b>OK</b>
                in the dialog box. Otherwise, the dialog box displays an alert and does not accept the value.
            </note>
        </param>
        <param name="cFontStyle">
            Specifies the font style selected initially in the Font dialog box or to display only those fonts available on the selected printer.
            If the font style you specify is not supported, the default font style is selected initially.<br/>
            The table in the remarks section lists the values available for cFontStyle.
        </param>
        <param name="nFontCharSet">
            Specifies a value for the language script. The values you can specify differ depending on your version of Windows.
            <note name="Note">Omitting this value disables the script drop-down list in the dialog box.</note>
            The table in the remarks section describes some example values for nFontCharSet.
            <note name="Note">
                If you specify 1 for nFontCharSet, the dialog box that <b>GetFont( )</b> opened displays the default language script on the operating system.
                <b>GetFont( )</b> never returns 1 because it returns the value for the language script selected in the <b>GetFont( )</b> dialog box.<br/>
                For more information, see FontCharSet Property.
            </note>
        </param>
        <returns>
            Character. <b>GetFont( )</b> returns one of the following, depending on certain conditions:
            <list type="bullet">
                <term>
                    A character string containing three types of font information with commas separating the items returned: font name, size and style.
                    This behavior occurs when you choose one in the Font dialog box and you have not included
                    the fourth optional argument when calling the <b>GetFont( )</b> function.
                </term>
                <term>
                    A character string containing four types of font information with commas separating the items returned: font name, size, style and language script.
                    This behavior occurs if you include a value for the nFontCharSet parameter.
                </term>
                <note name="Note">
                    In versions of X# previous to X# 9.0, if you included a value of 0 as the fourth argument to <b>GetFont()</b>,
                    you received the same return information as if you did not include the fourth argument at all.  The script drop-down list was not enabled,
                    and the return value contained only three types of font information. In X# 9.0, a value of 0 explicitly indicates the numeric value
                    corresponding to Western script.  The script drop-down list might also initially display Western if you specify 1 for this value,
                    but only if Western is the default script for your regional settings.
                </note>
                <term>
                    An empty string if you exit the Font dialog box by clicking <b>Cancel</b>, <b>Close</b> on the Control menu, or pressing the <b>Esc</b> key.
                </term>
            </list>
        </returns>
        <remarks>
            <list type="table">
                <listheader>
                    <term>cFontStyle</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>B</term>
                    <description>Select Bold font style initially.</description>
                </item>
                <item>
                    <term>I</term>
                    <description>Select Italic font style initially.</description>
                </item>
                <item>
                    <term>BI</term>
                    <description>Select Bold Italic font style initially.</description>
                </item>
                <item>
                    <term>P</term>
                    <description>Display only those fonts available on the current default printer.</description>
                </item>
            </list>
            <br/>
            <list type="table">
                <listheader>
                    <term>nFontCharSet</term>
                    <description>Language script</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>Western</description>
                </item>
                <item>
                    <term>1</term>
                    <description>Default</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Symbol</description>
                </item>
                <item>
                    <term>128</term>
                    <description>Japanese</description>
                </item>
                <item>
                    <term>161</term>
                    <description>Greek</description>
                </item>
                <item>
                    <term>162</term>
                    <description>Turkish</description>
                </item>
                <item>
                    <term>163</term>
                    <description>Vietnamese</description>
                </item>
                <item>
                    <term>177</term>
                    <description>Hebrew</description>
                </item>
                <item>
                    <term>178</term>
                    <description>Arabic</description>
                </item>
                <item>
                    <term>186</term>
                    <description>Baltic</description>
                </item>
                <item>
                    <term>204</term>
                    <description>Cyrillic</description>
                </item>
                <item>
                    <term>238</term>
                    <description>Central European</description>
                </item>
            </list>
        </remarks>
        <example>
             <code language="X#">
                * Invoke the dialog with script drop-down list disabled:
                ? GetFont("Arial",12,"B") &amp;&amp; press OK in the dialog box
                * return value is the string:
                * "Arial,12,B"
                * Enable the script drop-down list, Western script selected:
                ? GetFont("Arial",12,"B",0) &amp;&amp; press OK after selections
                * sample return value is the string:
                * "Verdana,16,N,161"
                * Return from the dialog box without making a selection:
                ? GetFont("Arial",12,"B") &amp;&amp; press Cancel in the dialog box
                * return value is an empty string
                ? GetFont("Arial",12,"B",0) &amp;&amp; press Cancel in the dialog box
                * return value is still an empty string
            </code>
        </example>
    </getfont>
    <getnextmodified>
        <summary>
            Returns the record number for the next modified record in a buffered table or cursor.
        </summary>
        <param name="nRecordNumber">
            Specifies the record number after which <b>GetNextModified( )</b> searches for the next modified record. Specify 0 for nRecordNumber to determine the first record in the table or cursor that has been modified.
        </param>
        <param name="uArea">
            Specifies the alias of the table or cursor for which <b>GetNextModified( )</b> returns the number of the next modified record.<br/>
            Or<br/>
            Specifies the work area of the table or cursor for which <b>GetNextModified( )</b> returns the number of the next modified record.
            If you do not specify an alias or work area, <b>GetNextModified( )</b> returns the record number for the next modified record in the currently selected table or cursor.
        </param>
        <param name="lNoFire">
            Specifies that all firing of rules are suppressed.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            <b>GetNextModified( )</b> returns 0 if there are no modified records after the record you specify. Because of this, if you modify only one record,
            to verify its modification you must first use the <b>GO TOP</b> command to position the cursor before the changed record.
            A record is considered modified if the contents of any of its fields are changed in any way (even if the original field contents are restored)
            or the record's deletion status is changed.<br/>
            <b>GetNextModified( )</b> can operate only on tables and cursors for which table buffering is enabled.
            Table buffering is enabled with <b>CursorSetProp( )</b>.<br/>
            Since triggers are unaffected by <b>GetNextModified( )</b>, lNoFire suppresses only field and record rules, and the "Uniqueness of index ID is violated" error.
            lNoFire prevents the flushing of temporary data, such as data stored in controls or updates made to the current record, to the underlying cursor.
        </remarks>
        <example>
             <code language="X#">
                LOCAL lnCurRec
                Clear
                Close Databases
                Open Database (HOME(2) + 'data\testdata')
                Use Customer
                * Enable table buffering.
                Set MultiLocks ON
                =CursorSetProp("Buffering", 5, "customer")
                * Increase MAXORDAMT by 10% for customers in Mexico.
                Update Customer Set MaxOrdAmt=MaxOrdAmt * 1.1 Where Country = "Mexico"
                * Start with the first modified record.
                lnCurRec = <b>GetNextModified</b>(0)
                * DO until all modified records are processed.
                DO WHILE .T.
                * Move to the current modified record.
                GOTO (m.lnCurRec)
                * Process modified row here.
                ? Customer.Company, Customer.MaxOrdAmt
                IF Customer.MaxOrdAmt &gt; 8500
                =TableRevert(.F.)
                ENDIF
                ?? Customer.MaxOrdAmt
                * Get the next modified record from here.
                lnCurRec = <b>GetNextModified</b>(m.lnCurRec)
                IF m.lnCurRec = 0 &amp;&amp; No more modified records.
                EXIT
                ENDIF
                ENDDO
                =TableRevert(.T.)  &amp;&amp; Restore sample data and discard all changes.
            </code>
        </example>
    </getnextmodified>
    <getobject>
        <summary>
            Activates an Automation object and creates a reference to the object.
        </summary>
        <param name="cFileName">
            Specifies the full path and name of the file to activate. The application does not need to be specified,
            because the OLE dynamic link libraries determine the application to start based on the file name you provide.<br/>
            For example, the following code launches Microsoft Excel, opens a file named BUDGET.XLS, and creates a reference through an object
            variable named MBUDVAR:
             <code language="X#">MBUDVAR = GetObject('C:\EXCEL\WORK\BUDGET.XLS')</code>
        </param>
        <param name="Moniker">
            The identifier of a COM object that implements the IMoniker interface. A moniker can be any of the following types: file, item,
            generic composite,
            anti-, pointer, and URL. For details about COM monikers, search for "IMoniker" on the Microsoft Developer Network.
        </param>
        <param name="cClassName">
            Specifies the class name of the object to retrieve. Some applications can store more than one object type in the same file,
            making it possible for you to use the class name to specify the object to activate. For example, if a word processing application
            stores its documents, macro definitions, and ToolBar objects in the same file, you can create a reference to the document file with the
            following command:
             <code language="X#">MDOCFILE = GetObject('C:\WRDPROC\MYDOC.DOC','WrdProc.Document')</code>
            With some server applications, each time you issue <b>GetObject( )</b>, an additional instance of the application is started,
            using additional memory. If the application is already running, you can prevent additional instances of the application from starting by
            omitting FileName and including ClassName, as in this example:
             <code language="X#">oleApp = GetObject(, "Excel.Application")</code>
        </param>
        <returns>
            Object reference
        </returns>
        <remarks>
            Use <b>GetObject( )</b> to activate an Automation object from a file and to assign a reference to the object through a memory variable or array element.
            If you specify an invalid file or class name, an OLE error is displayed, and the <b>GetObject( )</b> function returns an empty string.
        </remarks>
        <example>
             <code language="X#">
                *  Replace "DomainName" with the domain name, and "UserLoginID"
                *  with the login ID of the user you are looking up.
                oUser = GetObject("WinNT://DomainName/UserLoginID,user")
                ? oUser.FullName
            </code>
        </example>
    </getobject>
    <getpict>
        <summary>
            Displays the Open Picture dialog box and returns the name of the picture file you chose.<br/>
            You can preview images in Windows 2000 and later by clicking the View Menu icon and then Thumbnails.
            X# uses the Thumbnails view as the default setting to provide mini-previews of images. Therefore, the Open Picture dialog box no longer includes a frame
            for displaying an image. The Preview check box appears in the Open Picture dialog box only when running X# on operating systems earlier than Windows 2000.
        </summary>
        <param name="cFileExtensions">
            Specifies the file extensions of the picture files displayed in the scrollable list when the All Files menu item isn't chosen.<br/>
        </param>
        <param name="cFileNameCaption">
            Specifies the caption displayed to the left of the File Name text box. cFileNameCaption replaces "File Name" that appears when cFileNameCaption is omitted.
        </param>
        <param name="cOpenButtonCaption">
            Specifies a caption for the OK button.
        </param>
        <returns>
            Character data type. Returns the name of the picture file you chose.
        </returns>
        <remarks>
            The GetPict( ) function returns the empty string if you exit the Open Picture dialog box by pressing Esc, choosing the Cancel button,
            or clicking the Close button. The Open Picture dialog box displayed by typing <b>GetPict( )</b> in the Command window makes it possible for you
            to quickly locate all the graphic files supported in X#. In versions earlier than X# 8.0, check the Preview check box in the Picture Open dialog box
            to display the currently selected graphics file.<br/>
            The following table lists the graphic file formats that X# supports.
            <list type="table">
                <listheader>
                    <term>Graphic format</term>
                    <description>File extention</description>
                </listheader>
                <item>
                    <term>Animated Cursor</term>
                    <description>.ani</description>
                </item>
                <item>
                    <term>Bitmap</term>
                    <description>.bmp</description>
                </item>
                <item>
                    <term>Cursor</term>
                    <description>.cur</description>
                </item>
                <item>
                    <term>Device Independent Bitmap</term>
                    <description>.dib</description>
                </item>
                <item>
                    <term>Exchangeable Image File</term>
                    <description>.exif</description>
                </item>
                <item>
                    <term>Graphics Interchange Format</term>
                    <description>.gif, .gfa</description>
                </item>
                <item>
                    <term>Joint Photographic Electronic Group, JPEG File Interchange Format</term>
                    <description>.jpg, .jpeg, .jpe, .jfif</description>
                </item>
                <item>
                    <term>Icon</term>
                    <description>.ico</description>
                </item>
                <item>
                    <term>Portable Networks Graphics</term>
                    <description>.png</description>
                </item>
                <item>
                    <term>Tag Image File Format</term>
                    <description>.tif, .tiff</description>
                </item>
                <item>
                    <term>Windows Enhanced Metafile</term>
                    <description>.emf</description>
                </item>
            </list>
            <note name="Note">
                In X#, cursor, animated cursor, and icon files can be used as graphics files. For example, you can specify an animated cursor file for the
                Picture property for the Image control (however, the Image control displays the static representation of the cursor).>
            </note>
            Use the Clear RESOURCES command to clear all cached graphic files, including .gif and .jpg files.<br/>

            cFileExtensions can take the following forms:
            <list type="bullet">
                <term>If cFileExtensions contains a single extension (for example, .bmp), only files with that extension are displayed.</term>
                <term>
                    cFileExtensions can also contain wildcards (* and ?). All files with extensions that meet the wildcard criteria are displayed.
                    For example, if cFileExtensions is ?X?, all files with the extension .fxp, .exe, and .txt are displayed.
                </term>
                <term>If cFileExtensions contains an empty string (""), all available graphics files (for example, files with the extensions .bmp and .dib ) are displayed.</term>
            </list>
        </remarks>
    </getpict>
    <getprinter>
        <summary>
            Displays the Printer dialog box and returns the name of the selected printer.
        </summary>
        <returns>
            GETPRINTER( )Return Value
            Character. <b>GetPrinter( )</b> returns the name of the selected printer. If you exit the Printer dialog box by pressing
            Esc or by clicking Cancel or Close, <b>GetPrinter( )</b> returns an empty string.
        </returns>
        <remarks>
            The contents of the Printer dialog box can differ between versions of Windows.
            For example, the Printer dialog box might contain only the printer name or include a network path.
        </remarks>
        <example>
             <code language="X#">
                Clear
                cPrinter = GETPRINTER( )
                WAIT IIF(EMPTY(cPrinter), 'No printer chosen', cPrinter)
            </code>
        </example>
    </getprinter>
    <getresultset>
        <summary>
            Retrieves the work area number of a cursor marked by <b>SetResultSet( )</b> in the current data session.
        </summary>
        <returns>
            GetResultSet( )Return Value<br/>
            Numeric. <b>GetResultSet( )</b> returns the work area number of the marked cursor in the current data session or zero
            (0) if no cursor is marked in the current data session.
        </returns>
        <remarks>
            <b>GetResultSet( )</b> is supported in X# and the X# OLE DB Provider.
            You can use <b>GetResultSet( )</b> in a database container (DBC) stored procedure or send it to the X# OLE DB Provider,
            assuming that the cursor has been previously opened by the OLE DB Provider.
        </remarks>
    </getresultset>
    <imestatus>
        <summary>
            Turns the IME (Input Method Editor) window on or off or returns the current IME status.
        </summary>
        <param name="nExpression">
            Turns the IME window on or off. The table in the remarks section lists the values for
            nExpression and the corresponding state of the IME window.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            For more information, see Developing International Applications.<br/>
            This function is useful for manipulating double-byte character sets for languages such as Hiragana and Katakana.
            <list type="table">
                <listheader>
                    <term>nExpression</term>
                    <description>IME window action</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>Turns the IME window off.</description>
                </item>
                <item>
                    <term>1</term>
                    <description>Turns the IME window on.</description>
                </item>
            </list>
            If nExpression is omitted, <b>ImeStatus( )</b> returns the current IME status.
            The following table lists the values returned for the IME status. Use VERSION(3) to determine the current locale.<br/>
            The following table lists the values returned for the IME status in the Japanese locale.
            <list type="table">
                <listheader>
                    <term>Return value</term>
                    <description>IME status</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>No IME installed</description>
                </item>
                <item>
                    <term>1</term>
                    <description>IME on</description>
                </item>
                <item>
                    <term>2</term>
                    <description>IME off</description>
                </item>
                <item>
                    <term>3</term>
                    <description>IME disabled</description>
                </item>
                <item>
                    <term>4</term>
                    <description>Hiragana mode (double-byte)</description>
                </item>
                <item>
                    <term>5</term>
                    <description>Katakana mode (double-byte)</description>
                </item>
                <item>
                    <term>6</term>
                    <description>Katakana mode (single-byte)</description>
                </item>
                <item>
                    <term>7</term>
                    <description>Alphanumeric mode (double-byte)</description>
                </item>
                <item>
                    <term>8</term>
                    <description>Alphanumeric mode (single-byte)</description>
                </item>
            </list><br/>
            The following table lists the values returned for the IME status in the Korean locale.
            <list type="table">
                <listheader>
                    <term>Return value</term>
                    <description>IME status</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>No IME installed</description>
                </item>
                <item>
                    <term>1</term>
                    <description>Hangul mode (single-byte)</description>
                </item>
                <item>
                    <term>2</term>
                    <description>English mode (single-byte)</description>
                </item>
                <item>
                    <term>11</term>
                    <description>English mode (double-byte)</description>
                </item>
                <item>
                    <term>15</term>
                    <description>Hangul mode (double-byte)</description>
                </item>
                <item>
                    <term>23</term>
                    <description>Hanja conversion mode (Hangul + single-byte mode)</description>
                </item>
                <item>
                    <term>31</term>
                    <description>Hanja conversion mode (Hangul + double-byte mode)</description>
                </item>
            </list>
        </remarks>
    </imestatus>
    <indbc>
        <summary>
            Returns true (.T.) if the specified database object is in the current database; otherwise returns false (.F.).
        </summary>
        <param name="cDatabaseObjectName">
            Specifies the name of a named connection, field, index, table, or SQL view for which InDbc( ) returns a logical value
            indicating whether or not the object is in the current database.
        </param>
        <param name="cType">
            Specifies the database object type of cDatabaseObjectName.
            The table in the remarks section lists the values for cType and the corresponding database object type.<br/>
            The Connection, Field, Index, Table, and View settings cannot be abbreviated.
        </param>
        <returns>
            Logical
        </returns>
        <remarks>
            A database must be open and current when <b>InDbc( )</b> is issued; otherwise X# generates an error message.
            <list type="table">
                <listheader>
                    <term>cType</term>
                    <description>Database object type</description>
                </listheader>
                <item>
                    <term>Connection</term>
                    <description>Named connection</description>
                </item>
                <item>
                    <term>Field</term>
                    <description>Field</description>
                </item>
                <item>
                    <term>Index</term>
                    <description>Index</description>
                </item>
                <item>
                    <term>Table</term>
                    <description>Table</description>
                </item>
                <item>
                    <term>View</term>
                    <description>SQL View</description>
                </item>
            </list>
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Create Database mydbc  &amp;&amp; Creates a new database
                Create Table mytable (field1 C(10)) &amp;&amp; Automatically added to database
                ? 'MyTable in the database? '
                ?? InDbc('mytable', 'Table')  &amp;&amp; Returns .T.
                Close Databases
                Delete Database mydbc DeleteTables
            </code>
        </example>
    </indbc>
    <indexseek>
        <summary>
            Without moving the record pointer, searches an indexed table for the first occurrence of a record whose index key matches a specified expression.
        </summary>
        <param name="eExpression">
            Specifies the index key expression for which you want IndexSeek( ) to search.
        </param>
        <param name="lMovePointer">
            Specifies if the record pointer is moved to the matching record. If lMovePointer is true (.T.) and a matching record exists,
            the record pointer is moved to the matching record. If lMovePointer is true (.T.) and a matching record doesn't exist,
            the record pointer isn't moved. If lMovePointer is false (.F.) or is omitted, the record pointer isn't moved even if a matching record exists.
        </param>
        <param name="uArea">
            Specifies the work area number of the table that is searched for the index key.<br/>
            Or<br/>
            Specifies the alias of the table that is searched. If you omit uArea, the table in the currently selected work area is searched.
        </param>
        <param name="nIndexNumber">
            Specifies the number of the index file or tag that is used to search for the index key. nIndexNumber refers to the index files as they are
            listed in Use or Set Index. Open .IDX files are numbered first in the order in which they appear in Use or Set Index.
            Tags in the structural .cdx file (if one exists) are then numbered in the order in which they were created.
            Finally, tags in any open independent .cdx files are numbered in the order in which they were created. For more information about index
            numbering, see Set Order.
        </param>
        <param name="cIDXIndexFileName">
            Specifies an .idx file that is used to search for the index key.
        </param>
        <param name="cTagName">
            Specifies a tag of a .cdx file that is used to search for the index key. The tag name can be from a structural .cdx file or any open
            independent .cdx file.<br/>
            The .idx file takes precedence if duplicate .idx file and tag names exist.
        </param>
        <returns>
            Logical
        </returns>
        <remarks>
            <b>IndexSeek( )</b> returns true (.T.) if a match is found; otherwise false (.F.) is returned.
            You can use <b>IndexSeek( )</b> only with a table with an index order set, and you can search only for an index key.
            The match must be exact unless <b>Set EXACT</b> is set to OFF.<br/>
            <b>IndexSeek( )</b> provides a fast way to search for records without moving the record pointer.
            Because the record pointer isn't moved, rules and triggers aren't executed. If <b>IndexSeek( )</b> returns true
            (.T.) indicating that a matching record is found, you can execute <b>IndexSeek( )</b> again with the second parameter lMovePointer set to true
            (.T.) to move to the matching record.<br/>
            <b>IndexSeek( )</b> returns false (.F.) when you are attempting to find a value in the most recently created record
            (created with <b>Insert Into</b> or <b>Append Blank</b>) until the record pointer is moved. You can execute a <b>GO BOTTOM</b> command to
            cause <b>IndexSeek( )</b> to find the most recently created record.<br/>
        </remarks>
    </indexseek>
    <inputbox>
        <summary>
            Displays a modal dialog used by a parameterized view for input of a single string.
        </summary>
        <param name="cInputPrompt">
            Specifies the Prompt displayed above the text entry box.
        </param>
        <param name="cDialogCaption">
            Specifies the text to display in the title bar of the dialog box.
        </param>
        <param name="cDefaultValue">
            Specifies a default value to display in the text entry box.
        </param>
        <param name="nTimeout">
            Specifies a timeout value in 1/1000 seconds.
            Specify zero in nTimeout to prevent the dialog from timing out. This is identical to omitting nTimeout.
        </param>
        <param name="cTimeoutValue">
            Specifies value to return if a timeout occurs. cTimeoutValue isn't returned if nTimeout is set to zero or is omitted.
        </param>
        <param name="cCancelValue">
            Specifies a character value to return if the user exits the dialog box by choosing
            the <b>Cancel</b> button or pressing the Esc key.
        </param>
        <remarks>
            The dialog box displays an edit box and <b>OK</b> and <b>Cancel</b> buttons.
            The <b>OK</b> button returns the contents of the edit box.
            A timeout returns the text specified in cTimeoutValue or an empty string if cTimeoutValue is unspecified.
            The Cancel button or the Esc key returns the text specified in cCancelValue or an empty string if cCancelValue is unspecified.
             <code language="X#">
                Y = "Nothing at all"
                Y = InputBox("TypeHere","Input ",Y,5000)
                &amp;&amp; Displays dialog box for 5 seconds,
            </code>
            The following example displays a dialog box for five seconds and displays the return value in the main X# window.
            If the user clicks OK, the edit box returns the text which is either the default value, "Nothing at all," or user-specified text.
            If the user clicks Cancel or hits the Esc key, the edit box returns "Canceled." If the user waits the timeout period,
            the edit box closes and returns "Timed Out."
             <code language="X#">
                Clear
                Y = InputBox("Type Here:", "Input Title",  ;
                "Nothing at all", 5000, 'Timed Out', 'Canceled')
                ? Y
            </code>
        </remarks>
    </inputbox>
    <insmode>
        <summary>
            Returns the current insert mode, or sets the insert mode on or off.
        </summary>
        <param name="lSetOn">
            Turns the insert mode on or off. InsMode(.T.) turns the insert mode on and InsMode(.F.) turns it off.
        </param>
        <returns>
            A logical value corresponding to the insert mode setting before InsMode(.T.) or InsMode(.F.) was issued is returned.
        </returns>
        <remarks>
            If you omit the optional argument and the insert mode is on (characters are inserted before the cursor),
            InsMode( ) returns true (.T.). If the insert mode is off (characters are overwritten at the insertion point),
            InsMode( ) returns false (.F.).
        </remarks>
        <example>
             <code language="X#">
                =InsMode(.T.)  &amp;&amp; Set insert mode on
                ? InsMode( )
                = InsMode(!InsMode( ))  &amp;&amp; Toggle insert mode to opposite state
                ? InsMode( )
            </code>
        </example>
    </insmode>
    <isblank>
        <summary>
            Determines whether an expression is blank.
        </summary>
        <param name="eExpression">
            Specifies the expression for <b>IsBlank( )</b> to evaluate.
            eExpression can be a field in a table, a variable or array element, or an expression.
        </param>
        <returns>
            Logical. <b>IsBlank( )</b> returns True (.T.) if the expression eExpression is blank; otherwise,
            <b>IsBlank( )</b> returns False (.F.).<br/>
            <b>IsBlank( )</b> returns True (.T.) for fields when those fields contain certain values.
            The table below lists the values that field types contain for <b>IsBlank( )</b> to return True.
            <list type="table">
                <listheader>
                    <term>Data type</term>
                    <description>Values the field contains</description>
                </listheader>
                <item>
                    <term>
                        <b>Blob</b>
                    </term>
                    <description>Empty (0h) or contains only zero bytes, for example, 0h00, 0h000000, and so on</description>
                </item>
                <item>
                    <term>
                        <b>Character</b>
                    </term>
                    <description>
                        Empty string, spaces, or no value, such as a newly appended blank record or cleared with <b>Blank</b>
                    </description>
                </item>
                <item>
                    <term>
                        <b>Date</b>
                    </term>
                    <description>
                        Blank date ({ / / }) or no value, such as a newly appended blank record or cleared with <b>Blank</b>
                    </description>
                </item>
                <item>
                    <term>
                        <b>DateTime</b>
                    </term>
                    <description>
                        Blank datetime ({ / / : : }) or no value, such as a newly appended blank record or cleared with <b>Blank</b>
                    </description>
                </item>
                <item>
                    <term>
                        <b>Float</b>
                    </term>
                    <description>
                        No value, such as a newly appended blank record or cleared with <b>Blank</b>
                    </description>
                </item>
                <item>
                    <term>
                        <b>General</b>
                    </term>
                    <description>Empty, for example, no OLE object</description>
                </item>
                <item>
                    <term>
                        <b>Logical</b>
                    </term>
                    <description>
                        No value, such as a newly appended blank record or cleared with <b>Blank</b>
                    </description>
                </item>
                <item>
                    <term>
                        <b>Memo</b>
                    </term>
                    <description>Empty, for example, no memo contents</description>
                </item>
                <item>
                    <term>
                        <b>Numeric</b>
                    </term>
                    <description>
                        No value, such as a newly appended blank record or cleared with <b>Blank</b>
                    </description>
                </item>
                <item>
                    <term>
                        <b>Varbinary</b>
                    </term>
                    <description>Empty (0h) or contains only zero bytes, for example, 0h00, 0h000000, and so on</description>
                </item>
            </list>
            <note name="Note">
                Expressions with <b>Currency</b>, <b>Integer</b>, or <b>Double</b> type are never blank;
                therefore, <b>IsBlank( )</b> always returns False (.F.) for these expression types.
            </note>
        </returns>
        <remarks>
            To create a blank record, use the <b>Append Blank</b> and <b>Blank</b> commands.
            You can also use <b>Blank</b> to clear data from fields in a record.<br/>
            <b>IsBlank( ) </b>differs from <b>Empty( )</b> and <b>IsNull( )</b>.
            For example, <b>Empty( )</b> returns True (.T.) if a character expression evaluates to empty, for example,
            it contains spaces, tabs, carriage returns, or line feeds.
            <b>IsBlank( )</b> returns True (.T.) if the character expression contains only the empty string ("") or spaces.
        </remarks>
        <example>
             <code language="X#">
                Create Table mytable FREE (myfield C(20))
                Append Blank  &amp;&amp; Add new blank record
                Clear
                ? ISBlank(myfield)  &amp;&amp; Displays .T.
                Replace myfield WITH 'John Smith'  &amp;&amp; Insert a value in the field
                ? ISBlank(myfield)  &amp;&amp; Displays .F.
            </code>
        </example>
    </isblank>
    <isexclusive>
        <summary>
            Returns true (.T.) if a table or database is opened for exclusive use; otherwise, returns false (.F.).
        </summary>
        <param name="uArea">
            Specifies the alias of the table for which the exclusive use status is returned.
            X# generates an error message if you specify a table alias that doesn't exist.<br/>
            Or<br/>
            Specifies the work area of the table for which the exclusive use status is returned.
            IsExclusive( ) returns false (.F.) if a table isn't open in the work area you specify.<br/>
            Or<br/>
            Specifies the name of the database for which the exclusive use status is returned.
        </param>
        <param name="nType">
            Specifies whether the exclusive status is returned for a table or a database.
            The table in the remarks section lists the values for nType and the corresponding status returned.<br/>
            To determine the exclusive status for a database, you must include nType with a value of 2.
        </param>
        <returns>
            Logical
        </returns>
        <remarks>
            IsExclusive( ) returns a value for the table open in the currently selected work area if you omit the optional
            uArea, or cDatabaseName arguments.<br/>
            A table is opened for exclusive use by including the Exclusive keyword in Use, or by setting Set Exclusive to
            On before the table is opened.<br/>
            A database is opened for exclusive use by including the Exclusive keyword in Open Database.
            <list type="table">
                <listheader>
                    <term>nType</term>
                    <description>Exclusive status returned</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>Table</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Database</description>
                </item>
            </list>
        </remarks>
        <example>
             <code language="X#">
                cExclusive = Set('Exclusive')
                Set Exclusive Off
                Set Path To (Home(2) + 'data\')
                Open Data testdata  &amp;&amp; Opens the test databsase
                Use customer     &amp;&amp; Not opened exclusively
                Use employee IN 0 Exclusive    &amp;&amp; Opened exclusively in another work area
                IF IsExclusive( )
                REIndex  &amp;&amp; Can only be done if table opened exclusively
                ELSE
                WAIT 'The table has to be exclusively opened'
                ENDIF
                Set Exclusive &amp;cExclusive
            </code>
        </example>
    </isexclusive>
    <ismemofetched>
        <summary>
            Determines if a memo field has been fetched during a delayed memo fetch.
        </summary>
        <param name="uField">
            Specifies the name of the memo field for which the fetch status is returned.<br/>
            Or<br/>
            Specifies the field number (based on the physical structure of the table or cursor)
            of the memo field for which the fetch status is returned.
        </param>
        <param name="uArea">
            Specifies the work area of the table or cursor containing the memo field for which the fetch status is returned.<br/>
            Or<br/>
            Specifies the alias of the table or cursor containing the memo field for which the fetch status is returned.
        </param>
        <returns>
            Logical. A logical true (.T.) is returned if the specified memo field has been fetched, otherwise a logical false (.F.)
            is returned. True (.T.) is always returned for local data. The null value (.NULL.) is returned for a cursor if
            the record pointer is positioned at the beginning or end of the cursor. Use the BOF( ) Function and the EOF( ) Function
            to determine if the record pointer is positioned at the beginning or end of the cursor.
        </returns>
        <remarks>
            It can often take a while for a memo field fetch to occur with remote data,
            so you may choose to not download a memo field until it is absolutely needed.
            The FetchMemo setting in the DbGetProp( ) Function and CursorGetProp( )
            Function functions determine if a memo field is retrieved with View results or on demand.
            IsMemoFetched( ) return true (.T.) when the memo field is fetched for delayed Memo data (FetchMemo=.F.).<br/>
            IsMemoFetched( ) works with both memo and general fields.
        </remarks>
    </ismemofetched>
    <isnull>
        <summary>
            Returns true (.T.) if an expression evaluates to a null value; otherwise, IsNull( ) returns false (.F.).
        </summary>
        <param name="eExpression">
            Specifies the expression to evaluate.
        </param>
        <returns>Logical</returns>
        <remarks>
            Use IsNull( ) to determine if the contents of a field, memory variable, or array element contains a null value,
            or if an expression evaluates to a null value.
        </remarks>
        <example>
             <code language="X#">
                Store .NULL. To mNullvalue  &amp;&amp; Store a null value to a memory variable
                Clear
                ? mNullvalue  &amp;&amp; Display the value of the memory variable
                ? IsNull(mNullvalue)  &amp;&amp; Returns .T., indicating a null value
                ? TYPE('mNullvalue')     &amp;&amp; Returns L, indicating a logical value
                ? (mNullvalue = .NULL.)  &amp;&amp; Returns .NULL., bad test for null values
            </code>
        </example>
    </isnull>
    <ispen>
        <summary>
            Determines if the last Tablet PC mouse event was a pen tap.
        </summary>
        <remarks>
            The IsPen( ) function returns a logical true (.T.) if the last Tablet PC mouse event was a pen tap.
            A logical false (.F.) is returned if the last mouse event wasn't a pen tap.
        </remarks>
    </ispen>
    <istransactable>
        <summary>
            Returns a logical value indicating if a free table or free cursor supports transactions.
        </summary>
        <param name="uArea">
            Specifies the work area of the free table or free cursor for which IsTrancsactable( ) determines if transactions are supported.<br/>
            Or<br/>
            Specifies the alias of the table or cursor for which IsTrancsactable( ) determines if transactions are supported.
        </param>
        <returns>
            Logical. Returns a logical true (.T.) if a free table or free cursor supports transactions,
            otherwise a logical false (.F.) is returned.
        </returns>
        <remarks>
            Use the MakeTrancsactable( ) Function to allow a free table or free cursor to support transactions.
        </remarks>
    </istransactable>
    <isupper>
        <summary>
            Determines whether the first character in a character expression is an uppercase alphabetic character.
        </summary>
        <param name="cExpression">
            Specifies the character expression that IsUpper( ) evaluates.
            Any characters after the first character in icExpression/i are ignored.
        </param>
        <returns>
            Logical
        </returns>
        <remarks>
            IsUpper( ) returns true (.T.) if the first character in a character expression is an uppercase alphabetic character;
            otherwise, IsUpper( ) returns false (.F.).
        </remarks>
        <example>
             <code language="X#">
                ? IsUpper('Redmond')  &amp;&amp; Displays .T.
                ? IsUpper('redmond')  &amp;&amp; Displays .F.
            </code>
        </example>
    </isupper>
    <keymatch>
        <summary>
            Searches an index tag or index file for an index key.
        </summary>
        <param name="eIndexKey">
            Specifies the index key that KeyMatch( ) searches for. The index keys in an index file or index tag are determined
            by the index expression. An index expression is specified when an index file or index tag is created with Index.
            KEY( ) and SYS(14) can be used to return the index expressions for index files and index tags.
            For more information on creating index files, index expressions, and index keys, see Index.<br/>
            If you don't include any of the optional parameters, KeyMatch( ) searches the master index file or master index tag
            for the index key you specify. If a master index file or index tag isn't in effect (for example,
            you've issued Set Order To without any parameters to place the table in physical record order), X# generates an error message.<br/>
        </param>
        <param name="nIndexNumber">
            Specifies which index file or index tag is searched.
            nIndexNumber is typically an integer that starts at 1 and is increased by 1 to search additional index tags.<br/>
            If nIndexNumber is 1, the master single-entry .idx index file or master index tag (if one is present) is searched.<br/>
            As nIndexNumber increases, subsequent tags in the structural compound index (if one is present) are searched.
            The tags are searched in the order in which the tags were created in the structural compound index.<br/>
            As nIndexNumber continues to increase and all the tags in the structural compound index have been searched,
            tags in any open independent compound indexes are then searched.
            The tags are searched in the order in which the tags were created in the independent compound indexes.<br/>
            An error message is generated if nIndexNumber is greater than the total number of open single-entry .idx files
            and structural compound and independent compound index tags.
        </param>
        <param name="uArea">
            Searches index files or tags open in another work area.
            uArea specefies the work area number or the table alias.
            If you omit the work area and alias, KeyMatch( ) searches index files or tags open for the table in the current work area.<br/>
            If no table has the alias you specify, X# generates an error message.
        </param>
        <returns>
            Logical
        </returns>
        <remarks>
            KeyMatch( ) searches an index tag or index file for a specific index key and returns true (.T.) if the index key is found;
            otherwise, KeyMatch( ) returns false (.F.). KeyMatch( ) can be used to prevent duplicate index keys.<br/>
            KeyMatch( ) returns the record pointer to the record on which it was originally positioned before KeyMatch( ) was issued.
        </remarks>
    </keymatch>
    <lineno>
        <summary>
            Returns the line number of a line being executed in a program relative to the first line of the main program.
        </summary>
        <param name="nPos">
            Returns the line number relative to the first line of the current program or procedure. If you omit the 1 argument,
            the line number is returned relative to the first line of the main program.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            Program lines are counted starting from the top of the program. Comment lines, continuation lines,
            and blank lines are included in the line number count. If a program is suspended during execution,
            LineNo( ) returns the number of the program line at which program execution was suspended.
            LineNo( ) returns 0 if a program is canceled.<br/>
            By default, line numbers are returned relative to the beginning of the main program. If a procedure is called,
            line numbering continues from the top of the calling program.<br/>
            LineNo( ) is useful for debugging programs. You can set a breakpoint to stop program execution at a specific line number
            by opening the Breakpoints window, setting the Type to 'Break when expression is true'
            and adding codeLineNo( ) = nExpression/code in the Expression textbox.
        </remarks>
        <example>
             <code language="X#">
                On ERROR DO bug_proc WITH LineNo( )
                BRWS  &amp;&amp; Causes an error
                On ERROR
                *** Bug_Proc error handler ***
                PROCEDURE bug_proc
                PARAMETERS gnBadLine
                WAIT 'Error occurred at line: ' + ALLTRIM(STR(gnBadLine))
                RETURN
            </code>
        </example>
    </lineno>
    <loadpicture>
        <summary>
            Creates an object reference for a bitmap, icon, or Windows meta file.
        </summary>
        <param name="cFileName">
            Specifies the image file on disk for which an object is created.<br/>
            The supported images are listed in the remarks section
        </param>
        <returns>
            Object
            <b>LoadPicture() function</b> returns a <b>Picture type COM object reference</b> that can be assigned to ActiveX controls and VFPs Image objects <b>PictureVal property</b>.
            However, the real primary interface <b>iPicture</b> only can be retrieved using code like this:br
            &amp;nbsp;
            <code language="X#">oIPicture = GETINTERFACE(LoadPicture(GetPict()), "iPicture")</code>
        </returns>
        <remarks>
            <b>Supported Image Types</b>
            <list type="table">
                <listheader>
                    <term>Image Type Groups</term>
                    <description>Filename Extensions</description>
                </listheader>
                <item>
                    <term> bitmaps</term>
                    <description>.bmp, .jpg, .jpeg, .jpe, .jfif, .gif, .giff, .gfa</description>
                </item>
                <item>
                    <term>icons</term>
                    <description>.ico</description>
                </item>
                <item>
                    <term>windows metafiles</term>
                    <description>.wmf</description>
                </item>
                <item>
                    <term>windows enhanced metafiles</term>
                    <description>.emf</description>
                </item>
                <item>
                    <term>cursor</term>
                    <description>.cur</description>
                </item>
            </list>
            The following restrictions (tested with VFP 9 SP2 and OlePro32.dll Version 6.0.6002.18005) exist:<br/>
            <b>Known Limitations</b>
            <list type="table">
                <listheader>
                    <term>Image Type Groups</term>
                    <description>Restrictions &amp; Issues</description>
                </listheader>
                <item>
                    <term>bitmaps</term>
                    <description>
                        Loading these <b>.tif</b> and <b>.png</b> formats will cause an OLE error.
                    </description>
                </item>
                <item>
                    <term>icons</term>
                    <description>
                        Icons are allowed with sizes up to 128x128 and must not have more than 256 colors. Even if there is more than one icon stored in the icon file,
                        always only the smallest icon gets displayed. The icon file may contain much more icons - even with more colors and larger sizes - as long as there is at least
                        one that complies with the rules above, then no exception is thrown.
                    </description>
                </item>
                <item>
                    <term>cursor</term>
                    <description>
                        Cursor files must not have more than 1K of file size, otherwise an OLE error is generated. Cursor files containing 16 color cursors can be loaded
                        flawlessly, but only monochrome output is supported. Loading an animated cursor (.ani) causes an OLE error to be raised.
                    </description>
                </item>
            </list>
            <b>Null Picture Support</b>
            If cFileName is omitted, the "null picture" is returned.
            You can include GetPict( ) as cFileName to display the Open dialog from which you can choose a bitmap file.<br/><br/>
            Picture objects provide a language-neutral abstraction for bitmaps, icons, and metafiles.
            As with the standard font object, the system provides a standard implementation of the picture object.
            Its primary interfaces are <b>iPicture</b> and <b>iPictureDisp</b>.
            A picture object is created with <b>OleCreatePictureIndirect</b> and supports both the <b>iPicture</b> and the <b>iPictureDisp</b> interfaces.
            The OLE-provided picture object implements the complete semantics of the <b>iPicture</b> and <b>iPictureDisp</b> interfaces.
            In other words, theres no need to use another interface than <b>iPicture</b>!<br/>
            <b>LoadPicture( ) Function</b> internally wraps the <b>OleCreatePictureIndirect() function</b> implemented in <b>OleAut32.dll</b>.
            Thus, all you can read about that function (above and online) is also true for VFPs <b>LoadPicture() function</b>.
            <b>LoadPicture( ) Function</b> was added to VFPs vocabulary to make it easier to load images with COM interfaces
            that many presentation properties of ActiveX controls require for their settings.<br/>
            For example, the ActiveX Outline control has a <b>PictureOpen property</b> that requires a COM object image reference for its setting.
            The COM object returned by <b>LoadPicture( ) Function</b> hides its primary interface <b>iPicture</b>.
            In contrast to the reference returnd by <b>LoadPicture( ) Function</b>, the OLE-images primary <b>iPicture</b> interface is the only fully functional one.
            In other words, only <b>iPitcure</b> can be used in VFP programms without generating any OLE errors.
            Because <b>iPicture</b> is a superset of Picture it may be, better, it should be used everywhere instead of the one returnd by <b>LoadPicture( ) Function</b>!<br/>
            Example #1 in the examples section below proves that it makes no difference which OLE image interface gets assigned to a <b>oIMAGE.PICTUREVAL property.</b>
            The IID of the <b>iPicture</b> interface is defined as {7BF80980-BF32-101A-8BBB-00AA00300CAB}. <br/>
            <br/>
            The following two lines of code both create a null picture OLE image object:
            <code language="X#">
                oIPicture1 = GETINTERFACE(LoadPicture(), "iPicture")
                oIPicture2 = CreateObjectEx("StdPicture","","{7BF80980-BF32-101A-8BBB-00AA00300CAB}")
            </code>
            <b>Interfacemembers</b>
            The following table summarizes the PEMs <b>iPicture</b> interface.<br/>
            <b>iPicture Interface Members</b>
            <list type="table">
                <listheader>
                    <term>PEM</term>
                    <description>Name</description>
                    <description>Used for</description>
                    <description>ValueType</description>
                    <description>Read/Writable</description>
                </listheader>
                <item>
                    <term>property</term>
                    <description>Attributes</description>
                    <description>The current set of the picture's bit attributes.</description>
                    <description>DWORD (int)</description>
                    <description>readonly</description>
                </item>
                <item>
                    <term>property</term>
                    <description>CurDC</description>
                    <description>The current device context into which this picture is selected.</description>
                    <description>HDC (long)</description>
                    <description>readonly</description>
                </item>
                <item>
                    <term>property</term>
                    <description>Handle</description>
                    <description>Handle to the picture managed within this picture object.</description>
                    <description>OLE_Handle (int)</description>
                    <description>readonly</description>
                </item>
                <item>
                    <term>property</term>
                    <description>Height</description>
                    <description>The current height of the picture in the picture object.</description>
                    <description>OLE_XSIZE_HIMETRIC (long)</description>
                    <description>readonly</description>
                </item>
                <item>
                    <term>property</term>
                    <description>hPal</description>
                    <description>The current palette of the picture (if any).</description>
                    <description>OLE_Handle (int)</description>
                    <description>read/writable</description>
                </item>
                <item>
                    <term>property</term>
                    <description>KeepOriginalFormat</description>
                    <description>The current value of the picture object's KeepOriginalFormat property.</description>
                    <description>Bool</description>
                    <description>read/writable</description>
                </item>
                <item>
                    <term>property</term>
                    <description>Type</description>
                    <description>The current type of the picture.</description>
                    <description>Short (int)</description>
                    <description>readonly</description>
                </item>
                <item>
                    <term>property</term>
                    <description>Width</description>
                    <description>The current width of the picture in the picture object.</description>
                    <description>OLE_XSIZE_HIMETRIC (long)</description>
                    <description>readonly</description>
                </item>
                <item>
                    <term>method</term>
                    <description>PictureChanged()</description>
                    <description>Notifies the picture object that its picture resource changed.</description>
                </item>
                <item>
                    <term>method</term>
                    <description>Render()</description>
                    <description>Draws the specified portion of the picture onto the specified device context, positioned at the specified location.</description>
                </item>
                <item>
                    <term>method</term>
                    <description>SaveAsFile()</description>
                    <description>Saves the picture's data into a stream in the same format that it would save itself into a file.</description>
                </item>
                <item>
                    <term>method</term>
                    <description>SelectPicture()</description>
                    <description>
                        Selects a bitmap picture into a given device context, returning the device context in which the picture was previously selected
                        as well as the picture's handle.
                    </description>
                </item>
            </list>
            The <b>Attributes property</b> is said to hold the pictures bit attributes. Actually, there are only two, which can be set alone, or additive.
            The following table lists both possible values:<br/>
            <b>iPicture.Attributes Enumeration</b>
            <list type="table">
                <listheader>
                    <term>Constant</term>
                    <descripiton>Description</descripiton>
                    <description>Value</description>
                </listheader>
                <item>
                    <term>PICTURE_SCALABLE</term>
                    <description>
                        The picture object is scalable, such that it can be redrawn with a different size than was used to create the picture originally.
                        Metafile-based pictures are considered scalable; icon and bitmap pictures, while they can be scaled, do not express this attribute because both involve bitmap
                        stretching instead of true scaling.
                    </description>
                    <description>1</description>
                </item>
                <item>
                    <term>PICTURE_TRANSPARENT</term>
                    <description>
                        The picture object contains an image that has transparent areas, such that drawing the picture will not necessarily fill in all the spaces in the rectangle
                        it occupies. Metafile and icon pictures have this attribute; bitmap pictures do not.
                    </description>
                    <description>2</description>
                </item>
            </list>
            The following table lists all possible values of the <b>iPicture.Type property</b>:
            <list type="table">
                <listheader>
                    <term>Constant</term>
                    <descripiton>Description</descripiton>
                    <description>Value</description>
                </listheader>
                <item>
                    <term>PICTYPE_UNINITIALIZED</term>
                    <description>The picture object is currently uninitialized. This value is never be returned within VFP.</description>
                    <description>-1</description>
                </item>
                <item>
                    <term>PICTYPE_NONE</term>
                    <description>A new picture object is to be created without an initialized state. This value is returned from VFP if LoadPicture() is used without a parameter.</description>
                    <description>0</description>
                </item>
                <item>
                    <term>PICTYPE_BITMAP</term>
                    <description>The picture type is a bitmap.</description>
                    <description>1</description>
                </item>
                <item>
                    <term>PICTYPE_METAFILE</term>
                    <description>The picture type is a metafile.</description>
                    <description>2</description>
                </item>
                <item>
                    <term>PICTYPE_ICON</term>
                    <description>The picture type is an icon.</description>
                    <description>3</description>
                </item>
                <item>
                    <term>PICTYPE_ENHMETAFILE</term>
                    <description>The picture type is an enhanced metafile.</description>
                    <description>4</description>
                </item>
            </list>
            The most interesting method of the COM image objects <b>iPicture interface</b> is <b>render()</b> which also works flawlessly only when called on the <b>iPicture interface</b>.
            The following table summarises the parameters of the <b>render() method</b>:
            <list type="table">
                <listheader>
                    <term>Parameter</term>
                    <descripiton>Used for</descripiton>
                    <description>Scale unit</description>
                </listheader>
                <item>
                    <term>hdc</term>
                    <description>A handle of the device context on which to render the image.</description>
                </item>
                <item>
                    <term>x</term>
                    <description>The horizontal coordinate in hdc at which to place the rendered image (X-position of upper left corner of output rectangle).</description>
                    <description>pixel</description>
                </item>
                <item>
                    <term>y</term>
                    <description>The vertical coordinate in hdc at which to place the rendered image (X-position of upper left corner of output rectangle).</description>
                    <description>pixel</description>
                </item>
                <item>
                    <term>cx</term>
                    <description>The horizontal dimension (width) of the destination rectangle (with of output rectangle).</description>
                    <description>pixel</description>
                </item>
                <item>
                    <term>cy</term>
                    <description>The vertical dimension (height) of the destination rectangle (height of output rectangle).</description>
                    <description>pixel</description>
                </item>
                <item>
                    <term>xSrc</term>
                    <description>The horizontal offset in the source picture from which to start copying.</description>
                    <description>HiMetric</description>
                </item>
                <item>
                    <term>ySrc</term>
                    <description>The vertical offset in the source picture from which to start copying.</description>
                    <description>HiMetric</description>
                </item>
                <item>
                    <term>cxSrc</term>
                    <description>The horizontal extent to copy from the source picture (width of image sources clipping region AND direction of readout).</description>
                    <description>HiMetric</description>
                </item>
                <item>
                    <term>cySrc</term>
                    <description>The vertical extent to copy from the source picture (height of image sources clipping region AND direction of readout).</description>
                    <description>HiMetric</description>
                </item>
                <item>
                    <term>lprcWBounds</term>
                    <description>
                        If hdc is a metafile device context, the lprcWBounds parameter points to a RECTL structure specifying the bounding rectangle in the underlying metafile.
                        The rectangle structure contains the window extent and window origin. These values are useful for drawing metafiles.
                        The rectangle indicated by lprcBounds is nested inside this lprcWBounds rectangle; they are in the same coordinate space.
                        If hdcDraw is not a metafile device context, lprcWBounds will be NULL. If hdcDraw is a metafile device context, lprcWBounds cannot be NULL!
                    </description>
                </item>
            </list>
            The method returns standard values like E_FAIL, E_INVALIDARG and E_OUToFMEMORY, as well as S_OK, E_POINTER and CTL_E_INVALIDPROPERTYVALUE.
            These values are described on MSDN.
            <b>applications</b>
            The render function has plenty of parameters. Some of them passing in pixel values, others HiMetric values.<br/>
            <b>Example #3</b> has some useful conversions as well as other supporting functions and definitions.<br/>
            To figure out how <b>render()</b> works try the VFP code below; type it in line by line into VFPs command window:<br/>
            Direct input into VFPs command window
            <code language="X#">
                * locate an image with round about 100 x 100 pixels
                goPic = LoadPicture(GetPict())
                gIP = GETINTERFACE(m.goPic, "iPicture")
                goForm = CreateObject("Form")
                goForm.Show()
                * declare access to the _client_area_ of a window
                DECLARE Integer GetDC IN User32 integer HWnd
                * hDC should be  0 (otherwise that's an error)!
                hDC = GetDC(goForm.HWnd)
                * render your image directly onto form's client area
                gIP.Render(m.hDC,0,0,100,100,0,gIP.Height,gIP.Width,- gIP.Height,NULL)
                * declare release function
                DECLARE Integer ReleaseDC IN User32 integer HWnd, integer hDC
                * next line should print 1 on the form's background >> "Okay"
                ? ReleaseDC(m.goForm.HWnd, m.hDC)
                * declare access to the _whole_ window
                DECLARE Integer GetWindowDC IN User32 integer HWnd
                * hDC now references form's caption an border areas as well!
                hDC = GetWindowDC(goForm.HWnd)
                * render out partially overwriting form's border and caption
                gIP.Render(m.hDC,0,0,100,100,0,gIP.Height,gIP.Width,- gIP.Height,NULL)
                * never forget to free an allocated device context
                ? ReleaseDC(m.goForm.HWnd, m.hDC)
            </code>
            <b>iPicture.Render()</b> qualifies for painting on otherwise unreachable form regions, like the TitleBar or WindowBorders.
            Another interesting application for direct rendering stems from the fact that no VFP object reference is necessary for painting.
            The <b>render() method</b> solely uses a common windows handle. Thus, one can render on any known device context.br
            If one encounters the so-called hourglass problem, working with a COM-based image can be the preferred workaround.
            The hourglass mouse cursor gets displayed by the operation system during lengthy disk accesses.
            Sometimes VFP does not reset the hourglass mouse cursor correctly.
            Thus, the user still sees the busy working icon although VFP already is idle, as long she doesnt touch the mouse.
            Most often these disk accesses stem from refreshing pictures loaded into native Image-Objects using the <b>Image.Picture property</b>.
            Storing a COM memory-based object to the Image-Objects <b>.PictureVal property</b> instead, never causes any disk access.
            Thus, no more hourglass mouse cursor will appear after a refresh!
            <b>Drawback</b>
            <b>iPicture.Render()</b> does its work outside of - and unnoticed by  the VFP engine itself.
            Thats why VFP has no idea of what was painted between the lines.
            Each time VFP refreshes the forms area (weve just rendered our picture onto), will clear out our image.
            To make rendered output persistent measures have to be taken against VFP wiping it out!
            There is another BUG one has to be aware of, when employing the hourglass workaround described above!br
            To see what happens, try the following code:

            <code language="X#">
                LOCAL lnLoop, oComPic1, oComPic2
                oComPic1 = LoadPicture(GetFile())
                oComPic2 = LoadPicture(GetFile())
                TRY
                _Screen.Addobject("oImage","IMAGE")
                CATCH
                FINALLY
                _Screen.oImage.Visible = .T.
                ENDTRY
                For lnLoop = 1 to 100
                _Screen.oImage.PictureVal = m.oComPic1
                _Screen.oImage.PictureVal = m.oComPic2
                Next
                *//
                *\\ whereas the next loop will break somewhere down the road:
                For lnLoop = 1 to 100
                _Screen.oImage.PictureVal = m.oComPic1
                _Screen.oImage.PictureVal = m.oComPic1
                _Screen.oImage.PictureVal = m.oComPic1
                _Screen.oImage.PictureVal = m.oComPic2
                Next
            </code>
            One can see, that the first loop executes flawlessly, the second one breaks after only a few loops with a Property value is invalid error message!
            This bug is hard to track and occurs only in cases when someone tries to assign the same COM-reference more than once in a row!
            The workaround for this is to keep track which COM-reference is actually assigned to the Images PictureVal property.
            Never ever then reassign the same reference a second time (overwriting the first one with a copy of itself)!
            BTW: It doesnt matter what interface you are using.
            The error seems to stem from VFPs Image class instance.
        </remarks>
        <example>
            The following example shows that both interfaces (<b>Picture</b> and <b>IPicture</b>) of a COM image
            instance can be assigned to VFPs <b>Image.PictureVal property</b>:
            <code language="X#">
                PUBLIC goPic AS Object, goIPic AS Object
                goPic = LoadPicture(GetPict())
                goIPic = GETINTERFACE(m.goPic, "iPicture")
                _SCREEN.AddObject("oPic1","IMAGE")
                _SCREEN.AddObject("oPic2","IMAGE")
                WITH _SCREEN.oPic1
                .VISIBLE = .T.
                .PICTUREVAL = m.goPic &amp;&amp; "Picture"-Interface
                ENDWITH
                WITH _SCREEN.oPic2
                .LEFT = 110
                .VISIBLE = .T.
                .PICTUREVAL = m.goIPic &amp;&amp; "IPicture"-Interface
                ENDWITH
                HIDE WINDOWS ALL
                WAIT "Press any key..."
                _SCREEN.RemoveObject("oPic1")
                _SCREEN.RemoveObject("oPic2")
                STORE NULL TO goPic, goIPic
                Clear
                SHOW WINDOWS ALL
            </code>
            The following example shows how to query the <b>iPicture interface</b> of a COM image instance.
            Intentionally, there are no TryCatchEndtry sections in this demo code, so that OLE errors may occur.
            You have to run the code snippet multiple times with different image types to see them.
            <code language="X#">
                goPic = LoadPicture(GetPict())
                IF VARTYPE(m.goPic) == "O"
                goIPic = GETINTERFACE(m.goPic, "iPicture")
                IF VARTYPE(m.goIPic) == "O"
                Clear &amp;&amp; just some informal output:
                WITH m.goIPic
                ?
                ? "Properties of 'IPicture'-Interface:"
                ? "Attributes"		,.Attributes
                *\\ next line will fail if an ICOn loaded
                ? "CurDC"	,.CurDC
                ? "Handle"	,.Handle
                ? "Height"	,.Height
                *\\ next line will fail if an ICOn loaded
                ? "hPal"	,.hPal
                ? "KeepOriginalFormat",.KeepOriginalFormat
                ? "Type"	,.Type
                ? "Width"	,.Width
                ?
                ENDWITH
                ENDIF
                ENDIF
            </code>
            The following code is a collection of supporting functions and declarations that come in handy while programming OLE image objects.
            <code language="X#">
                * Supporting Functions &amp; DEFINEs
                #DEFINE INCH2MILLIMETER 25.4 &amp;&amp; 1 Inch = 25.4 millimeters
                #DEFINE INCH2HIMETRICS (INCH2MILLIMETER * 100) &amp;&amp; 1 HIMETRIC = 0.01
                FUNCTION PXL2HIME(tnPixel AS Integer) AS Integer
                * Pixel to HiMetric conversion
                LOCAL lnPixelsOnOneHiMetricUnit AS Integer
                lnPixelsOnOneHiMetricUnit = INCH2HIMETRICS / GetDPI()
                RETURN ROUND(lnPixelsOnOneHiMetricUnit * m.tnPixel, 0)
                ENDFUNC
                FUNCTION HIME2PXL(tnHimetric AS Integer) AS Integer
                * HiMetric to Pixel conversion
                LOCAL lnPixelsOnOneHiMetricUnit AS Integer
                lnPixelsOnOneHiMetricUnit = INCH2HIMETRICS / GetDPI()
                RETURN ROUND(m.tnHimetric / m.lnPixelsOnOneHiMetricUnit, 0)
                ENDFUNC
                FUNCTION GetDPI(tnHDC AS Integer) AS Integer
                * retrieve dots per inch resolution
                * for VFP's _SCREEN device context
                DECLARE Integer GetDeviceCaps IN GDI32 integer hdc, integer nIndex
                DECLARE Integer GetWindowDC IN User32 integer HWnd
                DECLARE Integer ReleaseDC IN User32 integer HWnd, integer hDC
                * For simplicity, we assume X- and Y- dimensions
                * using the same DPI resolution.
                #DEFINE LOGPIXELSX 88 &amp;&amp; Logical pixels/inch in X
                #DEFINE LOGPIXELSY 90 &amp;&amp; Logical pixels/inch in Y
                * Get VFP's _Screen-hDC to calculate resolution:
                LOCAL lhDC AS Integer, lnDPI AS Integer
                STORE 0 TO lhDC, lnDPI
                lhDC = GetWindowDC(_Screen.HWnd)
                IF NOT m.lhDC = 0
                lnDPI = GetDeviceCaps(m.lhDC, LOGPIXELSX)
                ELSE
                lnDPI = 96 &amp;&amp; default to 96 DPI
                ENDIF
                * Free device context
                = ReleaseDC(_Screen.HWnd, m.lhDC)
                RETURN m.lnDPI
                ENDFUNC
                FUNCTION GetCanvas(tnHWND AS Integer, tlChild AS Boolean) AS Integer
                * Retrieve hDC (handle DeviceContext) of window handle
                * tlChild = TRUE  := Use GetDC()
                * tlChild = FALSE := Use GetWindowDC()
                DECLARE Integer GetDC IN User32 integer HWnd
                DECLARE Integer GetWindowDC IN User32 integer HWnd
                LOCAL lnHDC AS Integer
                IF m.tlChild
                lnHDC = GetDC(m.tnHWND)
                ELSE
                lnHDC = GetWindowDC(m.tnHWND)
                ENDIF
                RETURN m.lnHDC
                ENDFUNC
                FUNCTION ReleaseCanvas(tnHWND AS Integer, tnHDC AS Integer) AS Integer
                * Releases a borrowed hDC
                DECLARE Integer ReleaseDC IN User32 integer HWnd, integer hDC
                RETURN ReleaseDC(m.tnHWND, m.tnHDC)
                ENDFUNC
                * The following function is not bullert-proof, as it fails on forms with scrollbars (oForm.Scrollbars > 0)
                FUNCTION GetChildAreaCanvas(tnhWnd AS Integer) AS Integer
                * VFP TopLevelForms (oForm.ShowWindow = 2) have
                * a secondary window inside the outer one.
                * This is also true for forms showing scrollbars!
                LOCAL lnVfpHANDLE AS Integer, lnClienthWnd AS Integer, lnHDC AS Integer
                * Convert the given Windows hWnd to an internal VFP WHANDLE
                lnVfpHANDLE = SYS(2326, m.tnhWnd)
                * Retrieve the Windows hWnd for a client window
                * (WCLIENTWINDOW) of a specified X# parent window
                lnClienthWnd = SYS(2325, m.lnVfpHANDLE)
                * Check if there is a WCLIENTWINDOW
                IF lnClienthWnd = lnVfpHANDLE
                * No such WCLIENTWINDOW, return childs client area
                lnHDC = GetCanvas(m.tnhWnd, .T.)
                ELSE
                * There IS a WCLIENTWINDOW!
                * Get the device context handle for the
                * whole client area of that window:
                lnHDC = GetCanvas(lnClienthWnd)
                ENDIF
                RETURN m.lnHDC
                ENDFUNC
            </code>
        </example>
    </loadpicture>
    <locfile>
        <summary>
            Locates a file on disk and returns the file name with its path.
        </summary>
        <param name="cFileName">
            Specifies the name of the file to locate. If cFileName includes only a file name, LocFile( ) searches the X# default directory or folder first.
            If the file is not found in the default directory or folder, the X# path is then searched. Use Set PATH to specify the X# path.<br/>
            If cFileName includes a path and a file name, the specified location is searched. If the file cannot be found in the specified location,
            LocFile( ) searches the X# default directory or folder and then the X# path.<br/>
            If the file is located, LocFile( ) returns the file name and path.
        </param>
        <param name="cFileExtensions">
            Specifies file extensions for the file to locate. If the file name you specify with cFileName does not include an extension,
            X# applies the file extensions listed in cFileExtensions to the file name and searches for the file again.<br/>
            cFileExtensions also specifies the file name extensions of the files displayed in the Open dialog box
            when the file you specified cannot be located.<br/>
            cFileExtensions can take a variety of forms:
            <list type="bullet">
                <item>If cFileExtensions contains a single extension (for example, PRG), only files with that extension are displayed.</item>
                <item>
                    cFileExtensions can also contain wildcards (* and ?). All files with extensions that meet the wildcard criteria are displayed.
                    For example, if cFileExtensions is ?X?, all files with the extension .fxp, .exe, or .txt are displayed.
                </item>
                <item>
                    In X# for Windows, cFileExtensions can contain a file description followed by a
                    file extension or a list of file extensions separated with commas.
                    The file description appears in the Files of Type list box. Separate the file description from the file extension or list of
                    file extensions with a colon (:). Separate multiple file descriptions and their file extensions with a semicolon (;).
                </item>
            </list>
            For example, if cFileExtensions is "Text:TXT" the file description "Text" appears in
            the Files of Type list box and all files with a .txt extension are displayed.<br/>
            If cFileExtensions is "Tables:DBF; Files:TXT,BAK" the file descriptions "Tables" and "Files" appear in the Files of Type list box.
            When "Tables" is chosen from the Files of Type list box, all files with a .dbf extension are displayed.
            When "Files" is chosen from the Files of Type list
            box, all files with .txt and .bak extensions are displayed.
        </param>
        <param name="cFileNameCaption">
            Specifies the text you want to use to prompt the user. The text appears to the left of the textbox in which you enter the file name.
            If omitted, "File name:" is displayed.<br/>
            For a list of X# file extensions and corresponding creator types, see the File Extensions and File Types online topic.
        </param>
        <returns>
            Character
        </returns>
        <remarks>
            The Open dialog box is displayed if the file cannot be located in the default directory or folder, the X# path, or a specified location.
            The Open dialog box can be used to locate the file. When a file is chosen from the Open dialog box,
            the file name is returned with the file's path.<br/>
            If you exit the Open dialog box by choosing Cancel, pressing Esc, or choosing Close from the Control menu,
            X# generates an error message and LocFile( ) does not return a value.
        </remarks>
    </locfile>
    <lock>
        <summary>
            Attempts to lock one or more records in a table.
        </summary>
        <param name="cRecordNumberList">
            Specifies a list of one or more record numbers which you must include to attempt to lock multiple records.
            Set MultiLocks must be ON and you must include the work area or alias of the table for which you are attempting to place multiple record locks.
            Lock( ) attempts to lock all of the records you specify. The record numbers specified with cRecordNumberList are separated by commas.
            For example, to attempt record locks on the first four records in a table, cRecordNumberList must contain 1,2,3,4.<br/>
            You can also lock multiple records by moving the record pointer to the record you would like to lock,
            issuing Lock( ) or RLock( ) and then repeating these steps for each additional record.<br/>
            In X#, you can specify 0 as a record number. Specifying 0 makes it possible for you to attempt to lock the table header.<br/>
            <note name="Note">
                Keep the table header locked for as short a time as possible because other users cannot add records
                to the table when the table header is locked.
            </note>
            Release the table header lock with UNLock RECORD 0, UNLock or UNLock ALL.
            If all the records specified in cRecordNumbers are successfully locked, Lock( ) returns true (.T.).
            If even one of the records specified with cRecordNumbers cannot be locked, Lock( ) returns false (.F.) and none of the records are locked.
            However, any existing record locks remain in place. Multiple record locking is an additive process. <br/>
            Placing additional record locks does not release locks on other records.
            The maximum number of records that can be locked in each work area is approximately 8,000.
            It is always faster to lock the entire table rather than even a small number of records.
        </param>
        <param name="uArea">
            Attempts a lock on the current record in a table open in a specific work area.
            uArea specifies the work area number and the table alias.
            If you do not specify a work area or table alias, Lock( ) attempts to lock the current record in the table in the current work area.
        </param>
        <returns>
            Logical
        </returns>
        <remarks>
            Lock( ) is identical to RLock( ).<br/>
            Changes to explicitly locked records aren't saved until the record is unlocked or the record pointer is moved.<br/>
            If the lock or locks are successfully placed, Lock( ) returns true (.T.). Locked records are available for both read and write access
            to the user who placed the locks; they are available for read-only access to all other users on the network.
            Executing Lock( ) does not guarantee that the record lock or locks will be successfully placed.
            A record lock cannot be placed on a record already locked by another user or in a table locked by another user.
            If the record lock or locks cannot be placed for any reason, Lock( ) returns false (.F.).<br/>
            By default, Lock( ) makes one attempt to lock a record. Use Set REPROCESS to automatically retry a record lock when the first attempt fails.
            Set REPROCESS determines the number of lock attempts or the length of time during which lock attempts are made when the initial lock attempt
            is unsuccessful. For more information, see Set REPROCESS.<br/>
            Set MultiLocks determines whether you can lock multiple records in a table. If Set MultiLocks is OFF (the default),
            you can lock only a single record in a table. When Set MultiLocks is ON, you can lock multiple records in a table.
            For more information, see Set MultiLocks.<br/><br/>
            <b>Unlocking Records</b>   A table record can be unlocked only by the user who placed the lock.
            You can release record locks by issuing UNLock, closing the table, or exiting X#.
            UNLock can be used to release record locks in the current work area, a specific work area, or in all work areas.
            For more information, see UNLock.<br/>
            Switching Set MultiLocks from ON to OFF or from OFF to ON implicitly performs UNLock ALL  all record locks in all work areas are released.<br/>
            Tables can be closed with Use, Clear ALL, or Close Databases.<br/>
            For more information about record and file locking and sharing tables on a network, see Programming for Shared Access.<br/>
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Open Database (HOME(2) + 'data\testdata')
                Set REPROCESS TO 3 AUTOMATIC
                STORE '1,2,3,4' TO gcRecList
                gcOldExc = Set('EXCLUSIVE')
                Set EXCLUSIVE OFF
                Select 0
                Use employee  &amp;&amp; Open Employee table
                Select 0
                Use customer  &amp;&amp; Open Customer table
                ? Lock('1,2,3,4', 'customer')  &amp;&amp; Lock 1st 4 records in customer
                ? RLock(gcRecList, 'employee')  &amp;&amp; Lock 1st 4 records in employee
                UNLock IN customer
                UNLock IN employee
                Set EXCLUSIVE &amp;gcOldExc
            </code>
        </example>
    </lock>
    <lookup>
        <summary>
            Searches a table for the first record with a field matching the specified expression.
        </summary>
        <returns>
            Character, Numeric, Currency, Float, Integer, Double, Date, DateTime, or Logical.
        </returns>
        <remarks>
            If the search is successful, LOOKUP( ) moves the record pointer to the matching record and
            returns the contents of a specified field in the record.<br/>
            If LOOKUP( ) does not find the search expression, it returns a blank value the same length and data type as ReturnField.
            The record pointer is positioned at the end of the file.<br/>
            If you use LOOKUP( ) to search a parent table, record pointers in all related child tables are moved to the related records.<br/>
            This function cannot be optimized with Rushmore Query Optimization.
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Open Database (HOME(2) + 'data\testdata')
                Use customer Order company  &amp;&amp; Open Customer table
                Clear
                @ 2,2 SAY LOOKUP(contact, 'Ernst Handel', company, 'company')
            </code>
        </example>
    </lookup>
    <maketransactable>
        <summary>
            Allows a free table or free cursor to support transactions.
        </summary>
        <param name="uArea">
            Specifies the work area of the table or cursor for which transactions will be supported.<br/>
            Or<br/>
            Specifies the alias of the table or cursor for which transactions will be supported.
        </param>
        <returns>
            Logical. Returns a logical true (.T.) if MakeTrancsactable( ) was able to make the free table or cursor support transactions,
            otherwise a logical false (.F.) is returned.
        </returns>
        <remarks>
            A free table is a table that has not been added to a database with the ADD Table Command. A free cursor is a cursor that is created from a
            free table or with the Create CURSOR - SQL Command.<br/>
            When MakeTrancsactable( ) is used to make a free table or free cursor support transactions, you can use the BEGIN TRANSACTIOn,
            END TRANSACTIOn, and ROLLBACK commands for the free table or free cursor. Use the IsTrancsactable( ) function to determine if a free
            table or free cursor supports transactions.
            <note name="Note">
                When MakeTrancsactable( ) is used to make a free table or free cursor support transactions, the free table or free cursor supports
                transactions in all work areas and data sessions in which it is opened. MakeTrancsactable( ) makes all open instances of a free table
                or free cursor support transactions, including those in other data sessions within a single instance of X#.
            </note>
            If a free table that does not support transactions is open in more than one data session, the free table cannot be made to support transactions.
            However, you can open a free table that already supports transactions in additional data sessions.<br/>
            If row buffering is enabled, then a table update is performed if the free table or free cursor has pending changes before the free table
            or free cursor is made to support transactions.
            You cannot use MakeTrancsactable( ) to enable transactions for a free table that has table buffering enabled.<br/>
            To disable transactions for a free table, you must close the free table in all data sessions.
        </remarks>
    </maketransactable>
    <newobject>
        <summary>
            Creates a new class or object directly from a visual class library (.vcx) file or program (.prg) file without opening the file.
        </summary>
        <param name="cClassName">
            Specifies the class or object from which the new class or object is created.
        </param>
        <param name="cModule">
            Specifies a .vcx file or X# program (.prg, .fxp, .mpr, .app, .exe, and so on) containing the class or object specified with cClassName.
            The default is a .vcx file. If you specify a program file, you must include an extension.
            <note name="Note">
                A class library can have an alias. To specify a class or object from a class library with an alias,
                include the class library alias followed by a period and the object name.<br/>
                When possible, specify the compiled program name (.fxp) when a class is stored in a program file (.prg).
                This ensures that the class is loaded from the proper class definition file.
            </note>
            If cModule is omitted, or is the empty string or the null value, X# searches for the class or object in the following order:
            <list type="bullet">
                <item>X# base classes.</item>
                <item>Classes in the current program.</item>
                <item>Class libraries opened with Set CLASSLIB.</item>
                <item>Classes in procedure files opened with Set PROCEDURE.</item>
                <item>Classes in the X# program execution chain.</item>
                <item>The OLE registry if Set OLEOBJECT is ON.</item>
            </list>
        </param>
        <param name="cInApplication">
            Specifies the X# application (.exe or .app) containing the .vcx file you specify with cModule.
            You must include an extension for the application. CInApplication is ignored if cModule is omitted,
            or if cInApplication is the empty string or the null value.<br/>
            If you want to use the cInApplication parameter, you must specify the name of .vcx file for cModule.
            You cannot pass the name of a .prg file or compiled program (.fxp).
        </param>
        <param name="0">
            Specifies that the class or object is instantiated without executing any of the event or method code in the class or object.
            This feature is not supported in runtime applications.<br/>
            All child classes or objects of the parent class are also instantiated. The event or method code in the child class or object isn't executed.<br/>
            This option is provides the ability to view the structure of a class or object (with the AMembers( ) Function,
            for example) without opening the class or object in the Class or Form Designer.<br/>
            Note that code in the class or object should never be executed - code execution is not supported and can make X# unstable.
            You should never explicitly call an event or method, or set properties. Setting properties can call Access and Assign methods.
        </param>
        <param name="eParameter1">
            Specifies optional parameters that are passed to the Init event procedure for the class or object.
        </param>
        <param name="eParameter2">
            Specifies optional parameters that are passed to the Init event procedure for the class or object.
        </param>
        <returns>
            Object
        </returns>
        <remarks>
            To assign the object reference returned by NEWOBJECT( ) to a variable or array element, use the equal sign (=) or STORE command.
            If an object assigned to a variable or array element is released, the variable or array element contains the null value.
            To remove the variable or array element from memory, use the RELEASE command.<br/>
            For NEWOBJECT( ), X# performs an internal Set CLASSLIB or Set PROCEDURE for the second or third parameters using the ADDITIVE clause
            where the parameters are first used to determine the search order. If these parameters already exist in the Set CLASSLIB or Set PROCEDURE list,
            X# rearranges the order in the list so they come first. X# then locates all the classes, creates the object, and calls the Init events.
            Finally, X# restores the original Set CLASSLIB or Set PROCEDURE list if the installation did not change list.<br/>
            OLE objects are created with the following syntax for cClassName:
             <code language="X#">ApplicationName.Class</code>
            For example, to create a Microsoft Excel worksheet, which supports Automation, use the following syntax:
             <code language="X#">oExcelSheet = NEWOBJECT('Excel.Sheet')</code>
        </remarks>
    </newobject>
    <normalize>
        <summary>
            Converts an expression, supplied by a user, into the same form of the expression used internally by X#.
            You can use the normalized form of an expression to make more accurate comparisons with the expressions returned from X# commands or functions.
        </summary>
        <param name="cExpression">
            Specifies the character expression to normalize.
        </param>
        <returns>
            Character
        </returns>
        <remarks>
            <b>Normalize( )</b> returns a character string from the character expression cExpression with the following changes. <b>Normalize( )</b>:
            <list type="bullet">
                <item>
                    Converts the character expression to uppercase. However, it does not change embedded strings.
                    An example of an embedded string is "Hello" in the character expression "LEFT('Hello',1)".
                </item>
                <item>Expands any abbreviated X# keywords in the character expression to their full length.</item>
                <item>Converts to periods any -&gt; operators that separate aliases from field names.</item>
                <item>Surrounds by periods the logical operators AND, OR and NOT: .AND. .OR. .NOT.</item>
                <item>In filter expressions, removes any blank spaces between terms.</item>
                <item>
                    Checks the syntax of any X# commands or functions within the character expression, however, it does not evaluate the expression.
                    If the syntax is incorrect, X# generates a syntax error. <b>Normalize( )</b> does not look for any fields, tables, memory variables,
                    user-defined functions, or other references in the character expression.
                </item>
            </list>
            For example, a user may enter an index expression such as the following in the Expression Builder:
             <code language="X#">UPPE(cust-&gt;lname) + UPPE(cust-&gt;fname)</code>
            While this is a valid X# index key expression, it is difficult to compare this to the return values from a X# function like <b>KEY( )</b>.
            <b>Normalize( )</b> returns the following character string for the expression above:
             <code language="X#">UPPER(CUST.LNAME) + UPPER(CUST.FNAME)</code>
            You can easily compare this to the value returned by a function like <b>KEY( )</b>.
            This enables you to verify the existence of an index or index tag with the user-supplied index expression.
            Also, you can use Normalize to compare the results of <b>Set("Filter")</b> or <b>Filter( )</b>.
            For example, you could create the following filter expression:
             <code language="X#">
                STORE '"VIRGINIA" $ UPPER(state) AND NOT "MAINE" $ UPPER(state)' TO
                MyFilter
                Use Addresses
                LINK Word.Document.8 "C:\\Documents and Settings\\v-rodhil\\My Documents\\DocStudio\\Projects\\dv_foxhelp91\\cc1ce3c4-1dc6-4d8f-9406-c8bab4d6a40a.xml"
                "OLE_LINK1" \a \r  \* MERGEForMAT STORE '"VIRGINIA" $ UPPER(state) AND NOT "MAINE" $ UPPER(state)' TO
                MyFilter
                Set Filter TO &amp;MyFilter
            </code>
            However, the value returned by <b>Set("Filter")</b> or <b>Filter( ) </b>will not exactly match the original filter.
             <code language="X#">? Set("Filter") == MyFilter  &amp;&amp; .F.</code>
            <b>Set("Filter")</b> or <b>Filter( )</b> return the following:
             <code language="X#">"VIRGINIA"$UPPER(STATE).AND..NOT."MAINE"$UPPER(STATE)</code>
            To ensure a correct comparison, use:
             <code language="X#">? Normalize(MyFilter) == Set("Filter")  &amp;&amp; .T."</code>
        </remarks>
    </normalize>
    <numlock>
        <summary>
            Returns the current mode of the Num Lock key or sets the mode of the Num Lock key on or off.
        </summary>
        <param name="lSetOn">
            Turns the Num Lock key on or off. If lSetOn is true (.T.), the Num Lock key is turned on; if lSetOn is false (.F.),
            the Num Lock key is turned off.
        </param>
        <returns>
            NumLock( ) returns a logical value corresponding to the Num Lock key setting before NumLock(.T.)
            or NumLock(.F.) is issued.
        </returns>
        <remarks>
            NumLock( ) returns true (.T.) if the Num Lock key is on (pressing a key on the numeric keypad returns a number), or false (.F.)
            if Num Lock is off (pressing a key on the numeric keypad moves the cursor).
        </remarks>
        <example>
             <code language="X#">
                gcOldLock = NumLock( )  &amp;&amp; Save original setting
                WAIT 'Press a key to turn Num Lock on'
                = NumLock(.T.)  &amp;&amp; Turn Num Lock on
                WAIT 'Press a key to turn Num Lock off'
                = NumLock(!NumLock( ))  &amp;&amp; Toggle Num Lock to the opposite value
                WAIT 'Press a key to restore original Num Lock setting'
                = NumLock(gcOldLock)     &amp;&amp; Return to original setting
            </code>
        </example>
    </numlock>
    <nvl>
        <summary>
            Returns a non-null value from two expressions.
        </summary>
        <returns>
            Character, Date, DateTime, Numeric, Currency, Logical, or the null value
        </returns>
        <remarks>
            Use NVL( ) to remove null values from calculations or operations where null values are not supported or are not relevant.
        </remarks>
        <example>
             <code language="X#">
                STORE .NULL. TO glMyNull  &amp;&amp; A memory variable containing the null value
                Clear
                ? NVL(.T., glMyNull)  &amp;&amp; Displays .T.
                ? NVL(glMyNull, glMyNull)  &amp;&amp; Displays .NULL.
            </code>
        </example>
    </nvl>
    <oldval>
        <summary>
            Returns original field values for fields that have been modified but not updated.
        </summary>
        <param name="cExpression">
            Specifies an expression whose original value <b>OldVal( )</b> returns from a table or a remote data source.
            cExpression is typically a field or an expression consisting of a set of fields from the table or remote data source.
        </param>
        <param name="uArea">
            Specifies the alias of the table or cursor from which the original field values are returned.<br/>
            Or<br/>
            Specifies the work area of the table or cursor from which the original field values are returned.
        </param>
        <returns>
            Character, Currency, Date, DateTime, Double, Float, Integer, Logical, Numeric, or Memo
        </returns>
        <remarks>
            <b>OldVal( )</b> returns original field values for records in a X# table or cursor that has
            row or table buffering enabled with <b>CursorSetProp( )</b>.<br/>
            If a table in a database or a cursor has validation rules, <b>OldVal( )</b> does not require that row or table buffering be enabled in
            order to return original field values.<br/>
            If the record pointer is moved to a different record when row buffering is enabled, or if <b>TableUpdate( )</b> is issued to \
            commit changes to the record, or there is some other action that causes an update, such as ending a transaction,
            the fields are updated and the original field values are no longer available.<br/>
            The data type of the value <b>OldVal( )</b> returns is determined by the expression you specify with cExpression.<br/>
            <b>OldVal( )</b> can return .NULL., even for a field declared as NOT NULL and with Set NULL OFF.<br/>
            The original field values are returned for the table or cursor open in the currently selected work area if <b>OldVal( )</b> is issued
            without the optional uArea arguments.
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Clear
                * Create new table and add blank record
                Create Table employee (cLastName C(10))
                Append Blank
                * Insert initial value
                Insert Into employee (cLastName) VALUES ("Smith")
                * Enable and set table buffering
                Set MultiLocks ON  &amp;&amp; Allow table buffering
                =CursorSetProp("Buffering", 5, "employee" )  &amp;&amp; Enable table buffering
                * Display initial value
                =MessageBox("Original cLastName value: "+ cLastName, 0, "Results")
                * Change record value and display results
                Replace cLastName WITH "Jones"
                =MessageBox("Modified cLastName value: "+ cLastName, 0, "Results")
                * Store the old value of the field to cTemp variable and display results
                cTemp=OldVal("cLastName", "employee")
                =MessageBox("Original cLastName value: "+ cTemp, 0, "Results")
                * Update table and display final value
                =TableUpdate(.T.)
                =MessageBox("Final cLastName value: "+ cLastName, 0, "Results")
                * Close and delete example table file
                Use
                Delete FILE employee.dbf
            </code>
        </example>
    </oldval>
    <payment>
        <summary>
            Returns the amount of each periodic payment on a fixed-interest loan.
        </summary>
        <param name="nPrincipal">
            Specifies the beginning principal of the loan.
        </param>
        <param name="nInterestRate">
            Specifies the fixed interest rate per period. If monthly payments are made on the loan but the interest rate is annual,
            divide the annual interest rate by 12.
        </param>
        <param name="nPayments">
            Specifies the total number of payments to be made on the loan.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            Payment( ) assumes a constant periodic interest rate and assumes that payments are made at the end of each period.
        </remarks>
        <example>
             <code language="X#">
                STORE 100000 to gnPrincipal     &amp;&amp; $100,000 beginning principal
                STORE .105/12 TO gnInterest  &amp;&amp; 10.5% annual interest rate
                STORE (20*12) TO gnPayments     &amp;&amp; 20 years of monthly payments
                Clear
                ? Payment(gnPrincipal, gnInterest, gnPayments)  &amp;&amp; Displays 998.38
            </code>
        </example>
    </payment>
    <pcol>
        <summary>
            Returns the current column position of the printer's print head.
        </summary>
        <returns>
            PCol( )Return Value
            Numeric
        </returns>
        <remarks>
            The value <b>PCol( )</b> returns is relative to the current setting of the left printer margin.
            You can set the left margin with Set MARGIN or by storing a value to the system memory variable _PLOFFSet.<br/>
            <b>PCol( )</b> is especially useful for relative addressing of printed text.<br/>
            You can use the $ operator in place of <b>PCol( )</b>.
        </remarks>
        <example>
             <code language="X#">
                Clear
                @ PROW( ), PCol( )+12 SAY 'Contact person'
                @ PROW( ), $+12 SAY 'Contact person'
            </code>
        </example>
    </pcol>
    <primary>
        <summary>
            Returns true (.T.) if an index tag is a primary index tag; otherwise, returns false (.F.).
        </summary>
        <param name="nIndexNumber">
            Specifies the number of the index tag for which Primary( ) returns the primary status. Primary( ) returns the primary status in
            the following order as nIndexNumber increases from 1 to the total number of structural compound and independent compound index tags.<br/>
            Primary status for each tag in the structural compound index (if one is present) are returned first.
            The primary status is returned for the tags in the order the tags are created in the structural index.<br/>
            Primary status for each tag in any open, independent compound indexes are returned next.
            The primary status is returned for the tags in the order in which the tags are created in the independent compound indexes.<br/>
            If you omit nIndexNumber, Primary( ) checks the master controlling index tag to see if it's a primary index tag.
            If there is no master controlling index tag, Primary( ) returns false (.F.).
        </param>
        <param name="uArea">
            Specifies the work area of the index tag specified with nIndexNumber.<br/>
            Or<br/>
            Specifies the work area of the index tag specified with nIndexNumber.<br/>
            If you omit uArea, Primary( ) checks the index tag in the currently selected work area to see if it's a primary index tag.
        </param>
        <returns>
            Logical
        </returns>
        <example>
             <code language="X#">
                Close Databases
                Set PATH TO (HOME(2) + 'Data\')   &amp;&amp; Sets path to database
                Open Database testdata  &amp;&amp; Open testdata database
                Use Customer     &amp;&amp; Open customer table
                For nCount = 1 TO TAGCOUNT( )
                IF !EMPTY(TAG(nCount))  &amp;&amp; Checks for tags in the index
                ? TAG(nCount)  &amp;&amp; Display tag name
                ? Primary(nCount)     &amp;&amp; Display primary status
                ELSE
                EXIT  &amp;&amp; Exit the loop when no more tags are found
                ENDIF
                ENDFor
            </code>
        </example>
    </primary>
    <program>
        <summary>
            Returns the name of the program at a specified program level, the name of the currently executing program, the current program level,
            or the name of the program executing when an error occurred.
        </summary>
        <param name="nLevel">
            Specifies the number of program levels to search for the program name. The nLevel parameter can range from 0 to the program nesting depth.
            For more information about program nesting levels, see maximum number of DO calls in X# System Capacities.<br/>
            When nLevel is omitted, <b>Program( )</b> returns the name of the currently executing program. If you specify 0 or 1 for nLevel,
            <b>Program( )</b> returns the name of the master program, or the highest-level program.<br/>
            If you specify 1 for nLevel, <b>Program( )</b> returns the current program level as a numeric value.
            However, using codeProgram(1)/code in the Command window always returns zero (0).<br/>
            If nLevel exceeds the program nesting depth, <b>Program( )</b> returns an empty string ("").
        </param>
        <returns>
            Character or Numeric. <b>Program( )</b> returns a program name, the number of the current program level, or an empty string.
        </returns>
        <remarks>
            You can use <b>Program( )</b> to help your program recover from errors.
            The <b>Program( )</b> function is similar to SYS(16) - Executing Program File Name.
        </remarks>
        <example>
             <code language="X#">
                ON ERROR DO errhand WITH Program( )
                *** The next line should generate an error ***
                Use nodatabase
                ON ERROR     &amp;&amp; Returns to system default error-handling routine
                PROCEDURE errhand
                PARAMETERS gcProgram
                WAIT 'An error occurred in the program ' + gcProgram WINDOW
            </code>
        </example>
    </program>
    <prow>
        <summary>
            Returns the current row number of the printer's print head.
        </summary>
        <returns>
            Numeric
        </returns>
        <remarks>
            If you issue <b>EJECT</b>, X# resets <b>PRow( )</b> to 0.<br/>
            <b>PRow( )</b> is especially useful for relative addressing of printed text.
        </remarks>
        <example>
             <code language="X#">
                @ PRow( ), PCol( ) + 12 SAY 'Contact person'
                @ PRow( ), $+12 SAY 'Contact person'
            </code>
        </example>
    </prow>
    <prtinfo>
        <summary>
            Returns the current specified printer setting.
        </summary>
        <param name="nPrinterSetting">
            Specifies which X# printer setting to return. The table in the remarks section lists descriptions of the type of printer settings returned.
        </param>
        <param name="cPrinterName">
            Specifies the name of the printer for which information is returned. If cPrinterName is omitted, information is returned for the default printer.
        </param>
        <returns>
            Numeric data type. The following tables list values returned when specifying particular values for nPrinterSetting.<br/>
            If nPrinterSetting is 1, <b>PrtInfo( )</b> returns the paper orientation as the following:
            <list type="table">
                <listheader>
                    <term>Return values</term>
                    <description>Paper orientation</description>
                </listheader>
                <item>
                    <term>-1</term>
                    <description>Information not available</description>
                </item>
                <item>
                    <term>0</term>
                    <description>Portrait</description>
                </item>
                <item>
                    <term>1</term>
                    <description>Landscape</description>
                </item>
            </list>
            If nPrinterSetting is 2, <b>PrtInfo( )</b> returns the paper size as the following:
            <list type="table">
                <listheader>
                    <term>Return values</term>
                    <description>Paper Size</description>
                </listheader>
                <item>
                    <term>1 or value other than listed</term>
                    <description>Information not available. Use nPrinterSetting = 3 and nPrinterSetting = 4 to return the paper size.</description>
                </item>
                <item>
                    <term>1</term>
                    <description>Letter, 8 1/2 x 11 in</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Letter Small, 8 1/2 x 11 in</description>
                </item>
                <item>
                    <term>3</term>
                    <description>Tabloid, 11 x 17 in</description>
                </item>
                <item>
                    <term>4</term>
                    <description>Ledger, 17 x 11 in</description>
                </item>
                <item>
                    <term>5</term>
                    <description>Legal, 8 1/2 x 14 in</description>
                </item>
                <item>
                    <term>6</term>
                    <description>Statement, 5 1/2 x 8 1/2 in</description>
                </item>
                <item>
                    <term>7</term>
                    <description>Executive, 7 1/4 x 10 1/2 in</description>
                </item>
                <item>
                    <term>8</term>
                    <description>A3, 297 x 420 mm</description>
                </item>
                <item>
                    <term>9</term>
                    <description>A4, 210 x 297 mm</description>
                </item>
                <item>
                    <term>10</term>
                    <description>A4, Small 210 x 297 mm</description>
                </item>
                <item>
                    <term>11</term>
                    <description>A5, 148 x 210 mm</description>
                </item>
                <item>
                    <term>12</term>
                    <description>B4, 250 x 354 mm</description>
                </item>
                <item>
                    <term>13</term>
                    <description>B5, 182 x 257 mm</description>
                </item>
                <item>
                    <term>14</term>
                    <description>Folio, 8 1/2 x 13 in</description>
                </item>
                <item>
                    <term>15</term>
                    <description>Quarto, 215 x 275 mm</description>
                </item>
                <item>
                    <term>16</term>
                    <description>10 x 14 in</description>
                </item>
                <item>
                    <term>17</term>
                    <description>11 x 17 in</description>
                </item>
                <item>
                    <term>18</term>
                    <description>Note, 8 1/2 x 11 in</description>
                </item>
                <item>
                    <term>19</term>
                    <description>Envelope #9, 3 7/8 x 8 7/8 in</description>
                </item>
                <item>
                    <term>20</term>
                    <description>Envelope #10, 4 1/8 x 9 1/2 in</description>
                </item>
                <item>
                    <term>21</term>
                    <description>Envelope #11, 4 1/2 x 10 3/8 in</description>
                </item>
                <item>
                    <term>22</term>
                    <description>Envelope #12, 4 1/2 x 11 in</description>
                </item>
                <item>
                    <term>23</term>
                    <description>Envelope #14, 5 x 11 1/2 in</description>
                </item>
                <item>
                    <term>24</term>
                    <description>C size sheet</description>
                </item>
                <item>
                    <term>25</term>
                    <description>D size sheet</description>
                </item>
                <item>
                    <term>26</term>
                    <description>E size sheet</description>
                </item>
                <item>
                    <term>27</term>
                    <description>Envelope DL, 110 x 220 mm</description>
                </item>
                <item>
                    <term>28</term>
                    <description>Envelope C5, 162 x 229 mm</description>
                </item>
                <item>
                    <term>29</term>
                    <description>Envelope C3, 324 x 458 mm</description>
                </item>
                <item>
                    <term>30</term>
                    <description>Envelope C4, 229 x 324 mm</description>
                </item>
                <item>
                    <term>31</term>
                    <description>Envelope C6, 114 x 162 mm</description>
                </item>
                <item>
                    <term>32</term>
                    <description>Envelope C65, 114 x 229 mm</description>
                </item>
                <item>
                    <term>33</term>
                    <description>Envelope B4, 250 x 353 mm</description>
                </item>
                <item>
                    <term>34</term>
                    <description>Envelope B5, 176 x 250 mm</description>
                </item>
                <item>
                    <term>35</term>
                    <description>Envelope B6, 176 x 125 mm</description>
                </item>
                <item>
                    <term>36</term>
                    <description>Envelope, 110 x 230 mm</description>
                </item>
                <item>
                    <term>37</term>
                    <description>Envelope Monarch, 3 7/8 x 7.5 in</description>
                </item>
                <item>
                    <term>38</term>
                    <description>6 3/4 Envelope, 3 5/8 x 6 1/2 in</description>
                </item>
                <item>
                    <term>39</term>
                    <description>US Std Fanfold, 14 7/8 x 11 in</description>
                </item>
                <item>
                    <term>40</term>
                    <description>German Std Fanfold, 8 1/2 x 12 in</description>
                </item>
                <item>
                    <term>41</term>
                    <description>German Legal Fanfold, 8 1/2 x 13 in</description>
                </item>
            </list>
            If nPrinterSetting is 7, <b>PrtInfo( )</b> returns the default paper source as the following:
            <list type="table">
                <listheader>
                    <term>Return values</term>
                    <description>Default paper source</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>Upper bin</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Lower bin</description>
                </item>
                <item>
                    <term>3</term>
                    <description>Middle bin</description>
                </item>
                <item>
                    <term>4</term>
                    <description>Manual feed</description>
                </item>
                <item>
                    <term>5</term>
                    <description>Envelope bin</description>
                </item>
                <item>
                    <term>6</term>
                    <description>Manual feed envelope</description>
                </item>
                <item>
                    <term>7</term>
                    <description>Automatic feed</description>
                </item>
                <item>
                    <term>8</term>
                    <description>Tractor feed</description>
                </item>
                <item>
                    <term>9</term>
                    <description>Small format</description>
                </item>
                <item>
                    <term>10</term>
                    <description>Large format</description>
                </item>
                <item>
                    <term>11</term>
                    <description>Large capacity</description>
                </item>
                <item>
                    <term>14</term>
                    <description>Cassette</description>
                </item>
                <item>
                    <term>15</term>
                    <description>Default input bin (automatically select)</description>
                </item>
            </list>
            If nPrinterSetting is 8 and <b>PrtInfo( )</b> returns a negative value, the return value indicates the print quality as the following:
            <list type="table">
                <listheader>
                    <term>Return values</term>
                    <description>Print quality</description>
                </listheader>
                <item>
                    <term>-1</term>
                    <description>Draft</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Low</description>
                </item>
                <item>
                    <term>3</term>
                    <description>Medium</description>
                </item>
                <item>
                    <term>4</term>
                    <description>High</description>
                </item>
            </list>
            If nPrinterSetting is 9, <b>PrtInfo( )</b> returns a value indicating if a color printer renders color or monochrome output as the following:
            <list type="table">
                <listheader>
                    <term>Return values</term>
                    <description>Color of output</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>Monochrome</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Color</description>
                </item>
            </list>
            If nPrinterSetting is 10, <b>PrtInfo( )</b> returns the duplex mode as the following:
            <list type="table">
                <listheader>
                    <term>Return values</term>
                    <description>Duplex mode</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>Simplex printing</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Vertical duplex</description>
                </item>
                <item>
                    <term>3</term>
                    <description>Horizontal duplex</description>
                </item>
            </list>
            If nPrinterSetting is 12, <b>PrtInfo( )</b> returns a value that indicates how TrueType fonts are printed as the following:

            <list type="table">
                <listheader>
                    <term>Return values</term>
                    <description>Printing of TrueType fonts</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>Print as bitmapped graphics</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Download as soft fonts</description>
                </item>
                <item>
                    <term>3</term>
                    <description>Substitute device fonts</description>
                </item>
            </list>
            If nPrinterSetting is 13, <b>PrtInfo( )</b> returns a value that indicates if output is collated as the following:
            <list type="table">
                <listheader>
                    <term>Return values</term>
                    <description>Collation</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>No collation</description>
                </item>
                <item>
                    <term>1</term>
                    <description>Collated</description>
                </item>
            </list>
        </returns>
        <remarks>
            You can set X# printer settings in the printer Page Setup dialog box. For more information, see Page Setup Dialog Box.
            <list type="table">
                <listheader>
                    <term>nPrinterSetting</term>
                    <description>XSHARP.H</description>
                    <description>Setting returned</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>PRT_ORIENTATION</description>
                    <description>Paper orientation</description>
                </item>
                <item>
                    <term>2</term>
                    <description>PRT_PAPERSIZE</description>
                    <description>Paper size</description>
                </item>
                <item>
                    <term>3</term>
                    <description>PRT_PAPERLENGTH</description>
                    <description>Paper length in .1 millimeter increments</description>
                </item>
                <item>
                    <term>4</term>
                    <description>PRT_PAPERWIDTH</description>
                    <description>Paper width in .1 millimeter increments</description>
                </item>
                <item>
                    <term>5</term>
                    <description>PRT_SCALE</description>
                    <description>Factor by which printer output is scaled</description>
                </item>
                <item>
                    <term>6</term>
                    <description>PRT_COPIES</description>
                    <description>Number of copies to print</description>
                </item>
                <item>
                    <term>7</term>
                    <description>PRT_DEFASOURCE</description>
                    <description>Default paper source</description>
                </item>
                <item>
                    <term>8</term>
                    <description>PRT_PRINTQUAL</description>
                    <description>A positive value that indicates the horizontal resolution in dots per inch (DPI) or a negative value that indicates the print quality.</description>
                </item>
                <item>
                    <term>9</term>
                    <description>PRT_COLOR</description>
                    <description>A value that indicates if a color printer rends color or monochrome output</description>
                </item>
                <item>
                    <term>10</term>
                    <description>PRT_DUPLEX</description>
                    <description>Duplex mode</description>
                </item>
                <item>
                    <term>11</term>
                    <description>PRT_YRESOLUTION</description>
                    <description>The vertical resolution in dots per inch (DPI). If not available, a value of -1 is returned.</description>
                </item>
                <item>
                    <term>12</term>
                    <description>PRT_TTOPTION</description>
                    <description>A value that indicates how TrueType fonts are printed</description>
                </item>
                <item>
                    <term>13</term>
                    <description>PRT_COLLATE</description>
                    <description>A value that indicates if output is collated</description>
                </item>
            </list>
        </remarks>
    </prtinfo>
    <putfile>
        <summary>
            Invokes the Save As dialog box and returns the file name you specify.
        </summary>
        <param name="cCustomText">
            Specifies custom text to appear in the Save As dialog box.
        </param>
        <param name="cFileName">
            Specifies the default file name displayed in the text box.
        </param>
        <param name="cFileExtensions">
            Specifies file name extensions. Only file names with the specified extension are displayed in the scrollable list of the
            Save As dialog box when the All Files check box is cleared. The first extension in cFileExtensions is automatically appended to
            the file name entered if an extension isn't included with the file name. The cFileExtensions parameter cannot exceed 254 characters in length.
            For a list of X# file extensions and corresponding creator types, see the File Extensions and File Types online topic.<br/>
            The character expression cFileExtensions can take one of the following forms:
            <list type="bullet">
                <term>cFileExtensions can contain a single extension, such as PRG, and only file names with that extension are displayed.</term>
                <term>
                    cFileExtensions can contain a list of file name extensions separated by semicolons. For example, if you include PRG;FXP,
                    X# displays all file names with the extensions .prg and .fxp.
                </term>
                <term>
                    If file names have the same root name but different extensions (for example, Customer.prg and Customer.fxp),
                    X# displays only the file name with the extension that appears first in cFileExtensions.
                </term>
                <term>
                    cFileExtensions can contain a list of file name extensions separated by vertical bars, such as PRG|FXP. In such a case,
                    X# displays all file names with listed extensions, even if the files have the same root name.
                </term>
                <term>If cFileExtensions contains only a semicolon (;), X# displays all file names that don't have an extension.</term>
                <term>If cFileExtensions is an empty string, X# displays the names of all files in the current directory or folder.</term>
                <term>
                    If cFileExtensions contains MS-DOS wildcards, such as the question mark (?) and asterisk (*), X# displays all file names with
                    extensions that meet the wildcard criteria. For example, if cFileExtensions is ?X?, all file names with the extensions .fxp, .exe, .txt,
                    and so on, are displayed.
                </term>
            </list>
        </param>
        <returns>
            Character
        </returns>
        <remarks>
            Use <b>PutFile( ) </b>to choose an existing file name or specify a new file name. <b>PutFile( )</b> returns the file name with its path.
            If you don't enter a file name, <b>PutFile( )</b> returns the default file name (specified with cFileName) and extension
            (specified by cFileExtensions). If you choose Cancel or press Esc, <b>PutFile( )</b> returns an empty string.
            You can use the file name that <b>PutFile( )</b> returns to name a file and save it to disk.
        </remarks>
        <example>
             <code language="X#">
                gcTableName = GetFile('DBF', 'Open Table:')
                Use (gcTableName)
                gcDelimName = Alias( ) + '.DLM'
                gcDelimFile = PutFile('Delimited file:', gcDelimName, 'DLM')
                IF EMPTY(gcDelimFile)  &amp;&amp; Esc pressed
                CANCEL
                ENDIF
                COPY TO (gcDelimFile) DELIMITED   &amp;&amp; Create delimited file
                MODIFY FILE (gcDelimFile) NOEDIT
            </code>
        </example>
    </putfile>
    <pv>
        <summary>
            Returns the present value of an investment.
        </summary>
        <param name="nPayment">
            Specifies the periodic payment amount. nPayment can evaluate to a positive or negative number.
            <b>PV( )</b> assumes that the payments are made at the end of each period.
        </param>
        <param name="nInterestRate">
            Specifies the periodic interest rate. If the interest rate of an investment is annual and the payments are made monthly,
            divide the annual interest rate by 12.
        </param>
        <param name="nTotalPayments">
            Specifies the total number of payments.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            <b>PV( )</b> computes the present value of an investment based on a series of equal periodic payments at a constant periodic interest rate.
        </remarks>
        <example>
             <code language="X#">
                STORE 500 to gnPayment  &amp;&amp; Periodic payments made monthly
                STORE .075/12 TO gnInterest     &amp;&amp; 7.5% annual interest rate
                STORE 48 TO gnPeriods  &amp;&amp; Four years (48 months)
                Clear
                ? PV(gnPayment, gnInterest, gnPeriods)  &amp;&amp; Displays 20679.19
            </code>
        </example>
    </pv>
    <raiseevent>
        <summary>
            You can use <b>RaiseEvent( )</b> to raise, or trigger, an event from a custom method. Though <b>RaiseEvent( )</b> applies primarily to
            custom methods, you can use it for raising native events and methods.
        </summary>
        <param name="oEventSource">
            Specifies the event source, which must be a valid X# object.
        </param>
        <param name="cEvent">
            Specifies the name of the event, method, or property you want to raise.
        </param>
        <param name="eParm1...">
            Specifies one or more parameters to pass if the method has parameters.
        </param>
        <returns>
            Logical data type. <b>RaiseEvent( )</b> always returns True (.T.).
        </returns>
        <remarks>
            X# automatically raises events for custom methods that are bound to objects using <b>BINDEVENT( )</b> if the methods are called directly.
            For example, the following code does not raise an event:
             <code language="X#">oForm.GetMyData(cData)</code>
            Instead, to raise an event for a custom method, you need to make the following call:
             <code language="X#">RaiseEvent( oForm, "GetMyData", cData )</code>
            You can also change this behavior by using <b>BINDEVENT( )</b> with nFlags set to 2 or 3.
            The event you wish to raise must be marked <b>Public</b>, not <b>Hidden</b> or <b>Protected</b>.
            If you use <b>RaiseEvent( )</b> on a property, X# sets the property to itself.
            The following example sets the <b>Caption</b> property for <b>_SCREEN</b> to the current value for <b>Caption</b>:
             <code language="X#">RaiseEvent( _SCREEN, "Caption" )</code>
            Raising an event fails if you bind to an event, for example, using <b>BINDEVENT( )</b>, that has parameters that are passed by reference.
            X# disregards recursive <b>RaiseEvent( )</b><b> </b>calls to an event from within the same raised event.
        </remarks>
        <example>
             <code language="X#">RaiseEvent( Form1, "Activate" )</code>
        </example>
    </raiseevent>
    <refresh>
        <summary>
            Refreshes data in an updatable SQL remote or local view, or <b>CursorAdapter</b> cursor.
        </summary>
        <param name="nRecords">
            Specifies the number of records to refresh. If nRecords is 1 or you omit nRecords, only the current record is refreshed. I
            f nRecords is 0, no records are refreshed.
        </param>
        <param name="nRecordOffset">
            Specifies the number of records before the current record where the refresh begins.
            For example, if the current record is record 10 and nRecordOffset is 4, record refresh begins with record 6.
            If nRecordOffset is 0 or you omit nRecordOffset, the refresh begins with the current record.
        </param>
        <param name="uArea">
            Specifies the alias of the cursor associated with a SQL remote or local view, or a <b>CursorAdapter</b> cursor where records are refreshed.<br/>
            Or<br/>
            Specifies the work area of cursor where records are refreshed. If you omit uArea,
            records are refreshed in the currently selected work area.<br/>
        </param>
        <returns>
            Numeric. <b>Refresh( )</b> returns the number of records refreshed.
        </returns>
        <remarks>
            The records are refreshed with data from the tables that define the SQL view or <b>CursorAdapter</b>. Unless specified,
            records are refreshed in the SQL view or <b>CursorAdapter</b> cursor open in the currently selected work area.<br/>
            <b>Refresh( )</b> does not refresh content for buffered records; however, field values that are accessible for the record
            through the <b>CurVal( )</b> function are refreshed. For more information, see CurVal( ) Function.<br/>
            Records must have unique primary keys. If a key for a record cannot be located in the base table,
            the corresponding record in the SQL view or <b>CursorAdapter</b> is marked for deletion.<br/>
            Calling the <b>Refresh( )</b> function can result in a significant impact on performance because the function re-executes the query on
            which the view is based. Therefore, do not call this function more than necessary.
        </remarks>
    </refresh>
    <requery>
        <summary>
            Retrieves data again for a SQL view.
        </summary>
        <param name="uArea">
            Specifies the work area in which the SQL view is open.<br/>
            Or<br/>
            Specifies the alias of the SQL view. If you omit uArea,
            the data for the SQL view open in the currently selected work area is retrieved.
        </param>
        <returns>
            Numeric. <b>Requery( )</b> returns 1 if the data is successfully retrieved; otherwise, it returns 0.
        </returns>
        <remarks>
            <b>Requery( )</b> is typically used to refresh a SQL view when data has changed on the data source.
        </remarks>
    </requery>
    <rgbscheme>
        <summary>
            Returns an RGB color pair or an RGB color pair list from a specified color scheme.
        </summary>
        <param name="nColorSchemeNumber">
            Specifies the number of the color scheme for which you want a complete RGB color listing. RGBScheme( ) returns 10 RGB color pairs.
        </param>
        <param name="nColorPairPosition">
            Returns a single RGB color pair from a color scheme. nColorPairPosition specifies the position of the RGB color pair in the color scheme.
            For example, if nColorPairPosition is 4, the fourth RGB color pair is returned.
        </param>
        <returns>
            Character
        </returns>
        <remarks>
            Use SCHEME( ) to return a traditional color pair or a color pair list from a color scheme. RGB color pairs use numeric values to specify colors.
            Traditional color pairs use letters to specify colors.
        </remarks>
        <example>
             <code language="X#">
                Clear
                ? RGBScheme(4,3)
            </code>
        </example>
    </rgbscheme>
    <savepicture>
        <summary>
            Creates a bitmap (.bmp) file from a picture object reference.
        </summary>
        <param name="oObjectReference">
            Specifies a picture object reference from which SAVEPICTURE( ) creates a bitmap file.
        </param>
        <param name="cFileName">
            Specifies the name of the bitmap file that SAVEPICTURE( ) creates. If cFileName includes a path, the file is created in the directory specified
            in the path. If a file with the same name already exists, it is overwritten without warning, even if Set SAFETY is ON.
        </param>
        <returns>
            Logical
        </returns>
        <remarks>
            Picture object references are typically created with LoadPicture( ). However, certain properties (such as the PictureOpen property for the OLE
            Outline control) use a default picture object reference, which can be used to create a bitmap file.
        </remarks>
    </savepicture>
    <scheme>
        <summary>
            Returns a color pair list or a single color pair from a specified color scheme.
        </summary>
        <param name="nSchemeNumber">
            Specifies the number of the color scheme for which you want a complete color-pair list. SCHEME( ) returns ten color pairs.
        </param>
        <param name="nColorPairNumber">
            Specifies the position of one color pair in the color scheme, and SCHEME( ) returns only this color pair. For example, if nColorPairNumber is 4,
            SCHEME( ) returns the fourth color pair from the color scheme.
        </param>
        <returns>
            Character
        </returns>
        <example>
             <code language="X#">? SCHEME(4,3)</code>
        </example>
    </scheme>
    <seconds>
        <summary>
            Returns the number of seconds that have elapsed since midnight.
        </summary>
        <returns>
            SECONDS( )Return Value
            Numeric. <b>SECONDS( )</b> returns a numeric value in decimal format with a resolution of 1 millisecond.
            For versions of X# running on Windows NT 4.0 or later, <b>SECONDS( )</b> returns a resolution of 10 milliseconds.
        </returns>
        <example>
             <code language="X#">
                Clear
                ? SECONDS( )
                ? SECONDS( )/(60 * 60)
            </code>
        </example>
    </seconds>
    <seek>
        <summary>
            Searches an indexed table for the first occurrence of a record whose index key matches a specified expression.
            Issuing Seek( ) is equivalent to issuing Seek and FOUND( ) in succession.<br/>
            X# does not support seek operations for binary indexes.
        </summary>
        <param name="eExpression">
            Specifies the index key expression for which you want Seek( ) to search.
        </param>
        <param name="uArea">
            Specifies the work area number of the table that is searched for the index key.<br/>
            Or<br/>
            Specifies the alias of the table that is searched.
            If you omit uArea, the table in the currently selected work area is searched.
        </param>
        <param name="uIndex">
            Specifies the number of the index file or tag that is used to search for the index key.
            nIndexNumber refers to the index files as they are listed in Use or Set Index. Open .idx files are numbered first in the order in
            which they appear in Use or Set Index. Tags in the structural .cdx file (if one exists) are then numbered in the order in which they were
            created. Finally, tags in any open independent .cdx files are numbered in the order in which they were created.
            For more information about index numbering, see Set Order Command.
        </param>
        <param name="cIDXIndexFileName">
            Specifies an .idx file that is used to search for the index key.
        </param>
        <param name="cTagName">
            Specifies a tag of a .cdx file that is used to search for the index key.
            The tag name can be from a structural .cdx file or any open independent .cdx file.
            The .idx file takes precedence if duplicate .idx file and tag names exist.
        </param>
        <returns>
            Logical. Seek( ) returns True (.T.) if a match is found and the record pointer moves to the matching record.
            Otherwise, Seek( ) returns False (.F.) if a match is not found, and the record pointer moves to the end of the file if Set NEAR is OFF
            or to the closest matching record if Set NEAR is ON.
        </returns>
        <remarks>
            You can use Seek( ) on a table with an index order set, or if an index order is not set on the table, set the controlling index with the
            3rd parameter, nIndexNumber, cIDXIndexFileName, or cTagName. The match must be exact unless Set EXACT is set to OFF.<br/>
            If you omit the nIndexNumber, IDXIndexFileName, and cTagName arguments,
            Seek( ) uses the master controlling index or index tag to search for the index key.<br/>
            The Set KEY setting is ignored if Seek( ) uses a non-active index.
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Open Database (HOME(2) + 'Data\testdata')
                Use customer Order cust_id  &amp;&amp; Opens Customer table
                ? Seek('CHOPS')  &amp;&amp; Returns .T., record found
            </code>
        </example>
    </seek>
    <select>
        <summary>
            Returns the number of the currently selected work area or the highest-numbered unused work area.
        </summary>
        <param name="uSelect">
            Specifies the alias of the table for which Select( ) returns the work area.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            Select( ) returns the number of the current work area if Set COMPATIBLE is set to OFF. If Set COMPATIBLE is set to ON,
            Select( ) returns the number of the unused work area with the highest number.
            A work area can be selected (activated) with Select.
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Set COMPATIBLE ON
                Open Database (HOME(2) + 'data\testdata')
                Select 0  &amp;&amp; Unused work area
                Use customer  &amp;&amp; Opens Customer table
                Select 0  &amp;&amp; Unused work area
                Use orders  &amp;&amp; Opens Orders table
                Clear
                ? Select( )  &amp;&amp; Returns 3, lowest available work area
            </code>
        </example>
    </select>
    <setfldstate>
        <summary>
            Assigns a field modification or deletion state value to a field or record in a table or cursor.
        </summary>
        <param name="nFieldstate">
            Specifies a value for the field modification or deletion status.<br/>
            The table in the remarks section lists the field modification or deletion state value and the corresponding modification or deletion status:
        </param>
        <param name="uArea">
            Specifies the alias of the table or cursor in which the modification or deletion status is assigned.<br/>
            Or<br/>
            Specifies the work area of the table or cursor in which the modification or deletion status is assigned.
            The field modification or deletion state value is assigned for the table or cursor open in the currently selected work area if SetFLDState( )
            is issued without the optional uArea arguments.
        </param>
        <returns>
            Logical
        </returns>
        <remarks>
            X# uses field state values to determine which fields in tables or cursors are updated. SetFLDState( ) makes it possible for you to control
            which fields X# attempts to update, regardless of which fields have been modified in the table or cursor.<br/>
            <list type="table">
                <listheader>
                    <term>nFieldstate</term>
                    <description>Modification or deletion status</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>Field has not been modified or deletion status has not changed.</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Field has been modified or deletion status has changed.</description>
                </item>
                <item>
                    <term>3</term>
                    <description>Field in an appended record has not been modified or deletion status has not changed for the appended record.</description>
                </item>
                <item>
                    <term>4</term>
                    <description>Field in an appended record has been modified or deletion status has changed for the appended record..</description>
                </item>
            </list>
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Set MultiLocks ON  &amp;&amp; Must be on for table buffering
                Set PATH TO (HOME(2) + 'Data\')     &amp;&amp; Sets path to database
                Open Database testdata  &amp;&amp; Open testdata database
                Use Customer     &amp;&amp; Open customer table
                = CursorSetProp('Buffering', 5, 'customer')  &amp;&amp; Enable table buffering
                Clear
                ? GetFldState('cust_id')  &amp;&amp; Displays 1, not modified
                Replace cust_id    WITH '***'  &amp;&amp; Changes field contents
                ? GetFldState('cust_id')  &amp;&amp; Returns 2, field modified
                = SetFLDState('cust_id', 1)  &amp;&amp; Change the field status
                ? GetFldState('cust_id')  &amp;&amp; Displays 1, not modified
                = TableRevert(.T.)  &amp;&amp; Discard all table changes
            </code>
        </example>
    </setfldstate>
    <setresultset>
        <summary>
            Marks a cursor as a result set in the current data session.<br/>
            Only one cursor per data session can be marked. When marking a new cursor,
            <b>SetResultSet( )</b> clears the marker from any previously marked cursor.
        </summary>
        <param name="uArea">
            Specifies a work area number.<br/>
            Or<br/>
            Specifies the alias of the cursor you want to mark.
        </param>
        <returns>
            Numeric. <b>SetResultSet( )</b> returns the number of the work area of the previously marked cursor in the current data session or zero (0)
            if no cursor is marked in the current data session.
        </returns>
        <remarks>
            <b>SetResultSet( )</b> is supported in X# and the X# OLE DB Provider. You can use <b>SetResultSet( )</b> in a database container (DBC)
            stored procedure or send it to the X# OLE DB Provider, assuming that the cursor has been previously opened by the OLE DB Provider.
            For example, suppose a previous command opens a cursor named MyCursor in the OLE DB Provider. The following line of code retrieves an
            ADO RecordSet for the cursor, MyCursor:
             <code language="X#">oRecordSet = oConn.Execute("SetResultSet('MyCursor')")</code>
            By using <b>SetResultSet( )</b> to mark a cursor or table opened by the X# OLE DB Provider, you can retrieve a rowset created from the
            table or cursor from a database container (DBC) stored procedure. When the OLE DB Provider completes command execution, it creates a
            rowset from the marked cursor, if it exists, then clears the marker flag from the cursor.
            In this scenario, the OLE DB Provider disregards all other return values. For example, if a stored procedure contains a <b>RETURN</b> 
            Value statement and a marked cursor, the OLE DB Provider does not return the value. Instead, it returns the marked cursor as a rowset
            to the calling application. When the rowset closes, the cursor also closes.
            However, even though the OLE DB Provider disregards all return values when a marked cursor exists, you can use <b>SetResultSet( )</b>
            with the <b>RETURN</b> command. For example:
             <code language="X#">RETURN SetResultSet("MyCursor")</code>
            This statement creates and returns a rowset from the marked cursor, not the return value from <b>SetResultSet( )</b>.
        </remarks>
    </setresultset>
    <strconv>
        <summary>
            Converts character expressions between single-byte, double-byte, UNICODE, and locale-specific representations.
        </summary>
        <param name="cExpression">
            Specifies the character expression that STRCONV( ) converts.
        </param>
        <param name="nConversionSetting">
            Specifies the type of conversion.
            The table in the remarks section lists the values of nConversionSetting and the type of conversion performed.
        </param>
        <param name="nRegionalIdentifier">
            Specifies the Locale ID, code page, or FontCharSet value to use for the conversion. If nRegionalIDType is omitted,
            the Locale ID is used for the conversion. If nRegionalIdentifier is omitted, the system locale ID is used by default.
            If nRegionalIdentifier is invalid or not supported on the machine, the error "Invalid locale ID" is generated.
        </param>
        <param name="nRegionalIDType">
            Specifies if a Locale ID, code page, or FontCharSet is used for the conversion.
            The nRegionalIdentifier parameter, described above, is used to specify the actual Locale ID, code page,or FontCharSet used for the conversion.
        </param>
        <returns>
            Character data type. STRCONV( ) returns the converted character expression.
        </returns>
        <remarks>
            <list type="table">
                <listheader>
                    <term>nRegionalIdentifier </term>
                    <description>Language</description>
                </listheader>
                <item>
                    <term>1029</term>
                    <description>Czech</description>
                </item>
                <item>
                    <term>1031</term>
                    <description>German</description>
                </item>
                <item>
                    <term>1033</term>
                    <description>English (Default)</description>
                </item>
                <item>
                    <term>1034</term>
                    <description>Spanish</description>
                </item>
                <item>
                    <term>1036</term>
                    <description>French</description>
                </item>
                <item>
                    <term>1040</term>
                    <description>Italian</description>
                </item>
                <item>
                    <term>1045</term>
                    <description>Polish</description>
                </item>
                <item>
                    <term>1046</term>
                    <description>Portuguese (Brazil)</description>
                </item>
                <item>
                    <term>2070</term>
                    <description>Portuguese (Portugal)</description>
                </item>
            </list>
            <list type="table">
                <listheader>
                    <term>nRegionalIDType</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>(Default) Specifies that the nRegionalIdentifier parameter is a Locale ID value.</description>
                </item>
                <item>
                    <term>1</term>
                    <description>Specifies that nRegionalIdentifier is a code page value.</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Specifies that nRegionalIdentifier is a FontCharSet value.</description>
                </item>
            </list>
            X# disregards invalid characters or incorrect length in base 64- and hexBinary- encoded strings.<br/>
            This function is useful for manipulating double-byte character sets for languages such as Hiragana and Katakana.
            <list type="table">
                <listheader>
                    <term>nConversionSetting</term>
                    <description>Conversion</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>
                        Converts single-byte characters in cExpression to double-byte characters.<br/>
                        Supported for Locale ID only (specified with the nRegionalIdentifier or nRegionalIDType parameters).
                    </description>
                </item>
                <item>
                    <term>2</term>
                    <description>Converts double-byte characters in cExpression to single-byte characters.</description>
                </item>
                <item>
                    <term>3</term>
                    <description>Converts double-byte Katakana characters in cExpression to double-byte Hiragana characters.</description>
                </item>
                <item>
                    <term>4</term>
                    <description>Converts double-byte Hiragana characters in cExpression to double-byte Katakana characters.</description>
                </item>
                <item>
                    <term>5</term>
                    <description>Converts double-byte characters to UNICODE (wide characters).</description>
                </item>
                <item>
                    <term>6</term>
                    <description>Converts UNICODE (wide characters) to double-byte characters.</description>
                </item>
                <item>
                    <term>7</term>
                    <description>Converts cExpression to locale-specific lowercase.</description>
                </item>
                <item>
                    <term>8</term>
                    <description>Converts cExpression to locale-specific uppercase.</description>
                </item>
                <item>
                    <term>9</term>
                    <description>Converts double-byte characters in cExpression to UTF-8</description>
                </item>
                <item>
                    <term>10</term>
                    <description>Converts Unicode characters in cExpression to UTF-8</description>
                </item>
                <item>
                    <term>11</term>
                    <description>Converts UTF-8 characters in cExpression to double-byte characters.</description>
                </item>
                <item>
                    <term>12</term>
                    <description>Converts UTF-8 characters in cExpression to UNICODE characters.</description>
                </item>
                <item>
                    <term>13</term>
                    <description>Converts single-byte characters in cExpression to encoded base64 binary.</description>
                </item>
                <item>
                    <term>14</term>
                    <description>Converts base64 encoded data in cExpression to original unencoded data.</description>
                </item>
                <item>
                    <term>15</term>
                    <description>Converts single-byte characters in cExpression to encoded hexBinary.</description>
                </item>
                <item>
                    <term>16</term>
                    <description>Converts single-byte characters in cExpression to decoded hexBinary.</description>
                </item>
            </list>
        </remarks>
    </strconv>
    <strextract>
        <summary>
            Retrieves a string between two delimiters.
        </summary>
        <param name="cSearchExpression">
            Specifies the string to search.
        </param>
        <param name="cBeginDelim">
            Specifies the character that delimits the beginning of cSearchExpression.
        </param>
        <param name="cEndDelim">
            Specifies the character that delimits the end of cSearchExpression.
        </param>
        <param name="nOccurrence">
            Specifies at which occurrence of cBeginDelim in cSearchExpression to start the extraction.
        </param>
        <param name="nFlag">
            Specify the type of controls placed on the search.
            The number you specify in nFlag provides a bit-value that determines options according to the following table:
            <list type="table">
                <listheader>
                    <term>Bit</term>
                    <description>Value (additive)</description>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>1</description>
                    <description>Case-insensitive search</description>
                </item>
                <item>
                    <term>1</term>
                    <description>2</description>
                    <description>
                        End delimiter not required. Specifies that a search, which finds no occurrence of cEndDelim,
                        returns the contents of cSearchExpression from the cBeginDelim location.
                    </description>
                </item>
                <item>
                    <term>2</term>
                    <description>4</description>
                    <description>Include the delimiters in the returned expression.</description>
                </item>
            </list>
            <returns>
                Character or Varbinary.br<br/>
                The Result data type is derived by the first parameter data type.
            </returns>
        </param>
        <remarks>
            The default is a case sensitive search in which delimiters must be found (no nFlag value).<br/>
            If cBeginDelim is an empty string, the search is conducted from the beginning of cSearchExpression to the first occurrence of cEndDelim.
            If cEndDelim is an empty string StrExtract( ) returns a string from nOccurrence of cBeginDelim to the end of cSearchExpression.
        </remarks>
        <example>
             <code language="X#">
                Clear
                Set PATH TO (HOME(2) + 'Data\')   &amp;&amp;Set path to the customer table
                Use customer &amp;&amp; any table
                ?cursortoxml(0,"x",1,0,2)   &amp;&amp; Produce variable "x" that has XML of  first 2 records of table
                ?x         &amp;&amp; show the XML
                xmlproc(x,0)      &amp;&amp; Parse the XML
                PROCEDURE xmlproc(x as String, nLev as Integer)   as void
                LOCAL cTagName, cContents, mterm
                DO WHILE .t.
                cTagName = StrExtract(x,"&lt;","&gt;")
                IF LEN(cTagName) = 0   &amp;&amp; no tag found
                ??' ',x   &amp;&amp; print out raw string as contents
                EXIT
                ENDIF
                IF RIGHT(cTagName,1) = '/'   &amp;&amp; like "&lt;region/&gt;"
                cTagName = LEFT(cTagName, LEN(cTagName)-1)
                cContents=""
                mterm = "&lt;"+cTagName+"/&gt;"   &amp;&amp; "&lt;region/&gt;"
                ELSE
                mterm = "&lt;/"+cTagName+"&gt;"   &amp;&amp; "&lt;/region&gt;"
                cContents = StrExtract(x,"&lt;"+cTagName+"&gt;", mterm,1,2)
                ENDIF
                ?REPLICATE("  ",nLev),nLev+1,PADR(cTagName,20)
                xmlproc(cContents, nLev+1)
                x = StrExtract(x, mterm)   &amp;&amp; get the rest of the xml
                ENDDO
            </code>
        </example>
    </strextract>
    <sys>
        <summary>
            Returns system information or sets its behavior.
        </summary>
        <param name="nSetting">Number of setting to query or change</param>
        <param name="uNewValue">Optional new value for setting</param>
    </sys>
    <sysmetric>
        <summary>
            Returns the size of the operating system's screen elements.
        </summary>
        <param name="nScreenElement">
            Specifies a screen element. The table in the remarks section shows values for nScreenElement and the corresponding screen element:
        </param>
        <returns>
            Character
        </returns>
        <remarks>
            SysMetric( ) returns the size of screen elements. Screen elements include menus, windows, window controls, and the insertion point.
            Values are returned in pixels unless otherwise noted and can vary for different displays, display drivers, and video hardware.
            For further information on screen elements, refer to the GetSystemMetrics function in the MSDN Library at <b>http://msdn.microsoft.com/library</b>.<br/>
            SysMetric( ) enables you to determine the size of menus, windows, and window controls you create in X#.
            Windows and menus created with DEFINE WINDOW and DEFINE MENU use the same screen element sizes as the operating system's windows and menus.
            <list type="table">
                <listheader>
                    <term>nScreenElement</term>
                    <description>Screen Element</description>
                </listheader>
                <item>
                    <term>1</term>
                    <description>Screen width</description>
                </item>
                <item>
                    <term>2</term>
                    <description>Screen height</description>
                </item>
                <item>
                    <term>3</term>
                    <description>Width of sizable window frame</description>
                </item>
                <item>
                    <term>4</term>
                    <description>Height of sizable window frame</description>
                </item>
                <item>
                    <term>5</term>
                    <description>>Width of scroll arrows on vertical scroll bar</description>
                </item>
                <item>
                    <term>6</term>
                    <description>Height of scroll arrows on vertical scroll bar</description>
                </item>
                <item>
                    <term>7</term>
                    <description>Width of scroll arrows on horizontal scroll bar</description>
                </item>
                <item>
                    <term>8</term>
                    <description>Height of scroll arrows on horizontal scroll bar</description>
                </item>
                <item>
                    <term>9</term>
                    <description>Height of window title</description>
                </item>
                <item>
                    <term>10</term>
                    <description>Width of non-sizable window frame</description>
                </item>
                <item>
                    <term>11</term>
                    <description>Height of non-sizable window frame</description>
                </item>
                <item>
                    <term>12</term>
                    <description>Width of DOUBLE or PANEL window frame</description>
                </item>
                <item>
                    <term>13</term>
                    <description>Height of DOUBLE or PANEL window frame</description>
                </item>
                <item>
                    <term>14</term>
                    <description>Scroll box width on horizontal scroll bar in text editing windows</description>
                </item>
                <item>
                    <term>15</term>
                    <description>Scroll box height on vertical scroll bar in text editing windows</description>
                </item>
                <item>
                    <term>16</term>
                    <description>Minimized window icon width</description>
                </item>
                <item>
                    <term>17</term>
                    <description>Minimized window icon height</description>
                </item>
                <item>
                    <term>18</term>
                    <description>Maximum insertion point width</description>
                </item>
                <item>
                    <term>19</term>
                    <description>Maximum insertion point height</description>
                </item>
                <item>
                    <term>20</term>
                    <description>Single-line menu bar height</description>
                </item>
                <item>
                    <term>21</term>
                    <description>Maximized window width</description>
                </item>
                <item>
                    <term>22</term>
                    <description>Maximized window height</description>
                </item>
                <item>
                    <term>23</term>
                    <description>Kanji window height</description>
                </item>
                <item>
                    <term>24</term>
                    <description>Minimum sizable window width</description>
                </item>
                <item>
                    <term>25</term>
                    <description>Minimum sizable window height</description>
                </item>
                <item>
                    <term>26</term>
                    <description>Minimum window width</description>
                </item>
                <item>
                    <term>27</term>
                    <description>Minimum window height</description>
                </item>
                <item>
                    <term>28</term>
                    <description>Window controls width</description>
                </item>
                <item>
                    <term>29</term>
                    <description>Window controls height</description>
                </item>
                <item>
                    <term>30</term>
                    <description>1 if mouse hardware present; otherwise 0</description>
                </item>
                <item>
                    <term>31</term>
                    <description>1 for Microsoft Windows debugging version; otherwise 0</description>
                </item>
                <item>
                    <term>32</term>
                    <description>1 if mouse buttons swapped; otherwise 0</description>
                </item>
                <item>
                    <term>33</term>
                    <description>Width of a button in a half-caption window's caption or title bar</description>
                </item>
                <item>
                    <term>34</term>
                    <description>Height of half-caption window caption area</description>
                </item>
            </list>
        </remarks>
    </sysmetric>
    <tablerevert>
        <summary>
            Discards changes made to a buffered row or a buffered table or cursor and restores the OldVal( ) data for remote cursors and the current
            disk values for local tables and cursors.<br/>
            On a network, the data currently on disk might differ from the data on the disk when the table was opened or the cursor was created.
            Other users on the network might have changed the data after the table was opened or the cursor was created.
        </summary>
        <param name="lAllRows">
            Determines whether all changes made to the table or cursor are discarded. The following table describes the values for lAllRows.
            <list type="table">
                <listheader>
                    <term>lAllRows</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>False (.F.)</term>
                    <description>If table buffering is enabled, only changes made to the current record in the table or cursor are discarded. (Default)</description>
                </item>
                <item>
                    <term>True (.T.)</term>
                    <description>If table buffering is enabled, changes made to all records are discarded in the table or cursor.</description>
                </item>
            </list>
            If row buffering is enabled, X# disregards the value of lAllRows, and changes made to the current record in the table or cursor are discarded.
        </param>
        <param name="uArea">
            Specifies the alias of the table or cursor in which the changes are discarded.<br/>
            Or<br/>
            Specifies the work area of the table or cursor in which the changes are discarded.
        </param>
        <returns>
            Numeric data type. TableRevert( ) returns the number of records for which changes were discarded.
        </returns>
        <remarks>
            TableRevert( ) cannot discard changes made to a table or cursor that does not have row or table buffering enabled.
            If you issue TableRevert( ) and row or table buffering is not enabled, X# generates an error message. Use CursorSetProp( ) to enable or
            disable row and table buffering.<br/>
            Changes are discarded in the table or cursor open in the currently selected work area if TableRevert( ) is issued without the optional
            uArea arguments.<br/>
            TableRevert( ) does not return the record pointer to its original position.<br/>
            TableRevert( ) operates on CursorAdapter objects in the same way as other buffered cursors.<br/>
            In X# 9.0, you cannot issue the TableRevert( ) function when a TableUpdate( ) is in operation.
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Set MultiLocks ON  &amp;&amp; Must be on for table buffering
                Set PATH TO (HOME(2) + 'data\')     &amp;&amp; Sets path to database
                Open Database testdata  &amp;&amp; Open testdata database
                Use Customer     &amp;&amp; Open customer table
                = CursorSetProp('Buffering', 5, 'customer')  &amp;&amp; Enable table buffering
                Clear
                ? 'Original cust_id value: '
                ?? cust_id  &amp;&amp; Displays current cust_id value
                Replace cust_id    WITH '***'  &amp;&amp; Changes field contents
                ? 'New cust_id value: '
                ?? cust_id  &amp;&amp; Displays new cust_id value
                = TableRevert(.T.)  &amp;&amp; Discard all table changes
                ? 'Reverted cust_id value: '
                ?? cust_id  &amp;&amp; Displays reverted cust_id value
            </code>
        </example>
    </tablerevert>
    <tableupdate>
        <summary>
            Commits changes made to a buffered row, a buffered table, cursor, or cursor adapter.
        </summary>
        <param name="nRows">
            Specifies which changes made to the table or cursor should be committed.
            <note name="Note">
                X# enables Optimistic Row Buffering by default for those cursors associated with a <b>CursorAdapter</b> object.
            </note>
            The table in the remarks section describes the values for nRows.
        </param>
        <param name="lForce">
            Determines whether X# overwrites changes made to the table or cursor by another user on a network.<br/>
            The table in the remarks section describes the values for lForce.
        </param>
        <param name="uArea">
            Specifies the alias of the table or cursor in which the changes are committed. If you include a table or cursor alias,
            you must include the lForce argument.<br/>
            Or<br/>
            Specifies the work area of the table or cursor in which the changes are committed. If you include a work area,
            you must include the lForce argument.
        </param>
        <param name="cErrorArray">
            Specifies the name of an array created when nRows = 2 and changes to a record cannot be committed.
            The array contains a single column containing the record numbers of the records for which changes could not be committed.
            If you include an array name, you must include either a table or cursor alias uArea or a work area number.<br/>
            <note name="Note">
                If an error other than a simple commit error occurs while updating records, the first element of cErrorArray will contain 1,
                and you can then use <b>AError( )</b> to determine the why the changes could not be committed.
            </note>
            X# passes the value of cErrorArray, when it exists, to the <b>CursorAdapter</b> AfterCursorUpdate event.
        </param>
        <returns>
            Logical data type. <b>TableUpdate( )</b> returns True (.T.) if changes to all records are committed.<br/>
            Otherwise, <b>TableUpdate( )</b> returns False (.F.) indicating a failure. An ON ERROR routine isn't executed.
            The AError( ) function can be used to retrieve information about the cause of the failure.<br/>
            <note name="Note">
                <b>TableUpdate( )</b> always returns True (.T.) when you are updating data, using Table Buffering,
                and updating the table or tables in the data source from multiple clients when setting <b>BatchUpdateCount</b> to a value greater than 1.
            </note>
            Therefore, avoid setting <b>BatchUpdateCount</b> to a value greater than 1 in these scenarios.
        </returns>
        <remarks>
            <b>TableUpdate( )</b> cannot commit changes made to a table or cursor that does not have row or table buffering enabled.
            If you issue <b>TableUpdate( )</b> and row or table buffering is not enabled, X# generates an error message.
            However, <b>TableUpdate( )</b> can still commit changes to a table or cursor that has validation rules.
            To enable or disable row and table buffering, use <b>CursorSetProp( )</b>.<br/>
            Changes are committed to the table or cursor open in the currently selected work area if <b>TableUpdate( )</b>
            is issued without the optional uArea arguments.<br/>
            If table buffering is used and multiple records are updated, <b>TableUpdate( )</b> moves the record pointer to the last record updated.<br/>
            <note name="Note">
                Calling <b>TableUpdate( )</b> for a local table or view that does not use key fields generates a long <b>Where</b> clause to find the update row.
                The default number of fields supported in the <b>Where</b> clause is 40. If you receive the error SQL: Statement too long (Error 1812),
                you should either use a key field for the update or increase the complexity of the <b>Where</b> clause with SYS(3055).
                If you use the <b>SYS(3055)</b> function,
                increase its value to a number that is eight times the number of fields in the table as shown in the following example:
            </note>
             <code language="X#">SYS(3055, 8 * MIN(40, FCOUNT( ))</code>
            When performing a batched <b>TableUpdate( )</b> operation, due to the way that Open Database Connectivity (ODBC) behaves,
            X# is unable to detect conflicts when no error is generated by the server, yet nothing is updated, for example,
            no row matches the <b>Where</b> clause. This can occur when you use WhereType set to DB_KEYANDUPDATable, DB_KEYANDMODIFIED,
            or DB_KEYANDTIMESTAMP, and another user has changed one of the underlying values in the <b>Where</b> clause such that the row is not
            found by the update statement.<br/>
            <b>Interaction with CursorAdapter Objects</b>   The following behaviors apply when working with <b>CursorAdapter</b> objects:
            <list type="bullet">
                <term>
                    <b>TableUpdate( )</b> operates only on the cursor associated with the <b>CursorAdapter</b> object.
                </term>
                <term>
                    <b>TableUpdate( )</b> executes commands according to the data source type and those stored in the <b>CursorAdapter</b> <b>InsertCmd</b>,
                    <b>UpdateCmd</b>, or <b>DeleteCmd</b> properties against the current cursor row or rows as appropriate.
                </term>
                <term>
                    <b>TableUpdate( )</b> passes the value of <c>GetFldState(1)</c> to the following <b>CursorAdapter</b> events of each row affected:
                </term>
                <list type="bullet">
                    <term>BeforeInsert</term>
                    <term>BeforeUpdate</term>
                    <term>BeforeDelete</term>
                </list>
            </list>
            For more information about <b>GetFldState( )</b>, see GetFldState( ) Function.<br/>
            <list type="bullet">
                <term>
                    The successful completion of <b>TableUpdate( )</b> resets the field states according to usual <b>TableUpdate( )</b><b> </b>behavior.
                </term>
                <term>
                    When table buffering is enabled, you can move away from the current record in the following <b>CursorAdapter</b> events:
                    <list type="bullet">
                        <term>BeforeInsert</term>
                        <term>AfterInsert</term>
                        <term>BeforeUpdate</term>
                        <term>AfterUpdate</term>
                        <term>BeforeDelete</term>
                        <term>AfterDelete</term>
                    </list>
                </term>
            </list>
            You can also modify data in the cursor. This functionality supports scenarios such as retrieving the autoincrement value from the base
            table and inserting it into the cursor. When this scenario occurs, the <b>CursorAdapter</b> object should automatically return to the
            record whose changes are about to be committed after the event has occurred and commit the changes.<br/>
            In X# 9.0, you cannot issue the TableRevert( ) Function when a TableUpdate( ) is in operation.<br/>
            Typically, the CursorAdapter object uses the transaction management functionality provided by the ADO or ODBC API's and X# closes
            transactions when the TableUpdate( ) function completes successfully. However, if you want to send transaction management commands directly
            to the backend, you can set the UseTransactions property of the CursorAdaptor object to False (.F.) and the CursorAdapter does not use
            transactions to send Insert, Update, or Delete commands.
            <list type="table">
                <listheader>
                    <term>nRows</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>
                        If row or table buffering is enabled, commit only the changes made to the current row in the cursor. (Default)<br/>
                        When working with <b>CursorAdapter</b> objects, X# executes the appropriate command in the InsertCmd, UpdateCmd, or DeleteCmd property for that row only.
                    </description>
                </item>
                <item>
                    <term>1</term>
                    <description>
                        If table buffering is enabled, commit changes made to all records to the table or cursor.<br/>
                        If row buffering is enabled, commit only changes made to the current record in the table or cursor.<br/>
                        When working with <b>CursorAdapter</b> objects, X# executes the appropriate commands in the <b>InsertCmd</b>,
                        <b>UpdateCmd</b>, and <b>DeleteCmd</b> properties for each affected row.
                    </description>
                </item>
                <item>
                    <term>2</term>
                    <description>
                        Commit changes made to the table or cursor in the same manner as when nRows = 1.
                        However, an error does not occur when a change cannot be committed. X# continues to process any remaining records in the table or cursor.<br/>
                        If cErrorArray is included, an array containing error information is created when an error occurs.
                    </description>
                </item>
            </list>
            For compatibility with previous X# applications, the nRows parameter also accepts False (.F.) and True (.T.) instead of 0 and 1 respectively.<br/>
            When specifying 0 or 1 for nRows, the record pointer remains on the record where changes could not be committed.
            To determine why the changes could not be committed, use the AError( ) function.<br/>
            When working with <b>CursorAdapter</b> objects and specifying 1 or 2 for nRows, all changes made to the cursor in the following<br/>
            <b>CursorAdapter</b> events must be committed during the same call to <b>TableUpdate( )</b> unless an error occurs:
            <list type="bullet">
                <term>
                    <b>BeforeInsert</b>
                </term>
                <term>
                    <b>AfterInsert</b>
                </term>
                <term>
                    <b>BeforeDelete</b>
                </term>
                <term>
                    <b>AfterDelete</b>
                </term>
                <term>
                    <b>BeforeUpdate</b>
                </term>
                <term>
                    <b>AfterUpdate</b>
                </term>
            </list>
            X# passes the values of nRows to the <b>CursorAdapter</b> BeforeCursorUpdate event.<br/><br/>

            <list type="table">
                <listheader>
                    <term>lForce</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>False (.F.)</term>
                    <description>
                        Commits changes to the table or cursor, starting with the first record and continuing towards the end of the table or cursor.
                        (Default)
                    </description>
                </item>
                <item>
                    <term>True (.T.)</term>
                    <description>
                        Overwrites any changes made to the table or cursor by another user on a network. The <b>Where</b> clause uses only key fields.
                    </description>
                </item>
            </list>
            When working with <b>CursorAdapter</b> objects, X# passes the value of lForce to the following <b>CursorAdapter</b> events:
            <list type="bullet">
                <term>BeforeCursorUpdate</term>
                <term>BeforeInsert</term>
                <term>BeforeUpdate</term>
                <term>BeforeDelete</term>
                <term>AfterInsert</term>
                <term>AfterUpdate</term>
                <term>AfterDelete</term>
            </list>
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Create Table employee (cLastName C(10))
                Set MultiLocks ON  &amp;&amp; Must turn on for table buffering.
                = CursorSetProp('Buffering', 5, 'employee' )  &amp;&amp; Enable table buffering.
                Insert Into employee (cLastName) VALUES ('Smith')
                Clear
                ? 'Original cLastName value: '
                ?? cLastName  &amp;&amp; Displays current cLastName value (Smith).
                Replace cLastName WITH 'Jones'
                ? 'New cLastName value: '
                ?? cLastName  &amp;&amp; Displays new cLastName value (Jones).
                = TableUpdate(.T.)  &amp;&amp; Commits changes.
                ? 'Updated cLastName value: '
                ?? cLastName  &amp;&amp; Displays current cLastName value (Jones).
            </code>
        </example>
    </tableupdate>
    <target>
        <summary>
            Returns the alias of a table that is the target for a relation as specified in the Into clause of Set RELATION.
        </summary>
        <param name="nRelationshipNumber">
            Specifies the number of a relationship. Include a number from 1 to the number of relationships out of the specified work area.
            The aliases of the target tables are returned (in no specific order) until nRelationshipNumber is greater than the number of relationships.
            When nRelationshipNumber is greater than the number of relationships, the empty string is returned.<br/>
        </param>
        <param name="uArea">
            Returns the alias of the target table in another work area. uArea specifies a work area number and specifies a table alias.
            By default, the alias of the target table from the current work area is returned if you don't specify the work area or alias.
        </param>
        <returns>
            Character
        </returns>
        <example>
             <code language="X#">
                Close Databases
                Open Database (HOME(2) + 'Data\testdata')
                Use orders IN 0 Order order_id
                Use customer IN 0 Order cust_id
                Select orders
                Set RELATION TO cust_id Into customer
                ? TARGET(1)  &amp;&amp; Displays customer
                ? TARGET(2)  &amp;&amp; Empty string
            </code>
        </example>
    </target>
    <textmerge>
        <summary>
            Provides evaluation of a character expression.
        </summary>
        <param name="cExpression">
            Specifies the string expression to be evaluated.
        </param>
        <param name="lRecursive">
            Specifies whether to repeatedly iterate through all levels of delimiters in cExpression, evaluating until no text merge delimiters remain.
        </param>
        <param name="cLeftDelim">
            Specifies the left delimiter to use for the text merge search. cLeftDelim is limited to two characters.
        </param>
        <param name="cRightDelim">
            Specifies the right delimiter to use for the text merge search. cRightDelim is limited to two characters.
        </param>
        <returns>
            Character string. Represents the value of cExpression, the merged text.
        </returns>
        <remarks>
            The cLeftDelim and cRightDelim parameters temporarily override any Set TEXTMERGE DELIMITERS values.<br/>
            The TEXTMERGE( ) function responds to current settings of Set TEXTMERGE SHOW | NOSHOW.
        </remarks>
        <example>
             <code language="X#">
                Set TEXTMERGE OFF
                TEXT to myvar noshow &amp;&amp;textm
                this is a test   &lt;&lt;datetime()&gt;&gt;
                &lt;&lt;program(-1)&gt;&gt;
                &lt;&lt;myvar&gt;&gt;
                textmerge(myvar) (this line is literal)
                &lt;&lt;doit(myvar)&gt;&gt;   (cause recursion
                END of orig text
                endtext
                ?myvar
                ?"Now starting textmerge"
                ?textmerge(myvar)
                PROCEDURE doit(myvar)
                *  r=i   &amp;&amp; cause an error
                if program(-1) &gt; 3
                return "THEEND*********"
                endif
                return textmerge(myvar)
            </code>
        </example>
    </textmerge>
    <ttoc>
        <summary>
            Converts a <b>DateTime</b> expression to a <b>Character</b> value with the specified format.
        </summary>
        <param name="tExpression">
            Specifies a <b>DateTime</b> expression to convert into a character string.<br/>
            If tExpression contains only a time, X# adds the default date of 12/30/1899 to tExpression. If tExpression contains only a date,
            X# adds a default time of 12:00:00 AM (if Set HOURS is 12) or 00:00:00 (if Set HOURS is 24) to tExpression to produce a valid DateTime value.
        </param>
        <param name="nParam">
            <b>1</b>
            Returns tExpression as a character string in a format suitable for indexing. The character string returned has a 14-character format,
            yyyymmddhhmmss, that is not affected by the <b>Set CENTURY</b>, the <b>Set HOURS</b>, or <b>Set SECONDS</b> commands.
            For more information, see Set CENTURY, Set HOURS, and Set SECONDS.
            <b>2</b>
            Returns tExpression as a character string containing only the time portion of tExpression.<br/>
            To control whether to include the seconds of the time portion in the character string, set the <b>Set SECONDS</b> and <b>Set DATE</b> commands.
            The <b>Set HOURS</b> command determines if AM or PM is appended to the time portion returned.<br/>
            For more information, see Set DATE and Set HOURS.<br/>
            <note name="Note">
                If <b>Set DATE</b> is set to <b>LONG</b> or <b>SHORT</b>, the format of the time setting in the Windows Control Panel determines the
                format of the character string.
            </note>
            <b>3</b>
            Returns tExpression as a character string with the XML DateTime format. The character string returned has a 19-character yyyy-mm-ddThh:mm:ss
            format that is not affected by the settings of the <b>Set CENTURY</b>, <b>Set HOURS</b>, or <b>Set SECONDS</b> commands.
        </param>
        <returns>
            Character. <b>TTOC( )</b> returns a <b>DateTime</b> expression as a character string.
            <note name="Note">
                When passing the value 1 or 3 as the second parameter, the character string returned does not include the AM or PM designations to indicate
                times before or after noon, respectively. Instead, the string uses a 24-hour clock, also known as military time.
                For example, the time 18:30:00 is equivalent to 06:30:00 PM.
            </note>
        </returns>
        <remarks>
            If an invalid value is passed as the second parameter, <b>TTOC( )</b> handles the invalid value as if it was a value of 1.
        </remarks>
        <example>
             <code language="X#">
                STORE DATETIME( ) TO gtDateTime
                ? "gtDateTime has type: "+TYPE('gtDateTime')
                gtDateTime = TTOC(gtDateTime)
                ? "gtDateTime is now type: "+TYPE('gtDateTime')
            </code>
        </example>
    </ttoc>
    <txnlevel>
        <summary>
            Returns a numeric value indicating the current transaction level.
        </summary>
        <returns>
            TXNLEVEL( )Return Value
            Numeric
        </returns>
        <remarks>
            Use BEGIN TRANSACTION to create a transaction. Transactions are nested by issuing BEGIN TRANSACTION when another transaction is in progress.
            Transactions can be nested in this manner to five levels. Use TXNLEVEL( ) to determine the current transaction level.<br/>
            TXNLEVEL( ) returns a value from 0 to 5. TXNLEVEL( ) returns 0 if a transaction is not in progress.
        </remarks>
        <example>
             <code language="X#">
                Close Databases
                Open Database (HOME(2) + 'Data\testdata')
                Use Customer     &amp;&amp; Open customer table
                Clear
                BEGIN TRANSACTION
                tLevel = ALLTRIM(STR(TXNLEVEL()))
                =MessageBox("Current Transaction: " + tLevel, 0, "Transaction Level")
                BEGIN TRANSACTION
                tLevel = ALLTRIM(STR(TXNLEVEL()))
                =MessageBox("Current Transaction: " + tLevel, 0, ;
                "Transaction Level")
                END TRANSACTION
                END TRANSACTION
            </code>
        </example>
    </txnlevel>
    <txtwidth>
        <summary>
            Returns the length of a character expression with respect to the average character width for a font.
        </summary>
        <param name="cExpression">
            Specifies a character expression for which TXTWIDTH( ) returns the length. If you include only cExpression, the length of the character
            expression is returned for the current font for the main X# window or the active output window. A non-proportional font always returns a
            value equal to the number of characters in cExpression.<br/>
            Include the optional arguments cFontName, nFontSize and cFontStyle to determine the length of a character expression with a specific font,
            font point size, or font style.
        </param>
        <param name="cFontName">
            Specifies the name of the font. Include cFontName to return the length of a character expression with a specific font.
        </param>
        <param name="nFontSize">
            Specifies a number that corresponds to the point size of the font. Include nFontSize to return the length of a character
            expression with a specific point size.
        </param>
        <param name="cFontStyle">
            Specifies a special font style for the character expression. cFontStyle is a font style code specified by a character or a set of characters.
            The Normal font style is used if cFontStyle isn't included. The characters for each font style can be found in the remarks section.
        </param>
        <returns>
            Numeric
        </returns>
        <remarks>
            TXTWIDTH( ) returns the number of characters a character expression cExpression occupies, based on the average character width of a specified
            font (the average character width of a font is called a foxel). Use FontMetric(6) to determine the average character width of a font.<br/>
            If you don't include a font in TXTWIDTH( ), the value returned by TXTWIDTH( ) is determined by the current font for the main X# window,
            as long as output is directed to the main X# window when TXTWIDTH( ) is issued. If output is being directed to a user-defined window,
            the value returned is determined by the window's current font.
            <list type="table">
                <listheader>
                    <term>Character</term>
                    <description>Font Style</description>
                </listheader>
                <item>
                    <term>B</term>
                    <description>Bold</description>
                </item>
                <item>
                    <term>I</term>
                    <description>Italic</description>
                </item>
                <item>
                    <term>N</term>
                    <description>Normal</description>
                </item>
                <item>
                    <term>O</term>
                    <description>Outline</description>
                </item>
                <item>
                    <term>Q</term>
                    <description>Opaque</description>
                </item>
                <item>
                    <term>S</term>
                    <description>Shadow</description>
                </item>
                <item>
                    <term>-</term>
                    <description>Strikeout</description>
                </item>
                <item>
                    <term>T</term>
                    <description>Transparent</description>
                </item>
                <item>
                    <term>U</term>
                    <description>Underline</description>
                </item>
            </list>
            You can include more than one character to specify a combination of font styles. For example, BI specifies a Bold Italic font style.<br/>
            The following command displays a message in a Courier normal 24-point font, centered horizontally in the main X# window:
             <code language="X#">
                @ 25,(WCOLS( )-TXTWIDTH('Hello!','Courier ',24)* ;
                FontMetric(6,'Courier ',24)/FontMetric(6))/2  ;
                SAY 'Hello!' FONT 'Courier ',24
            </code>
        </remarks>
    </txtwidth>
    <vartype>
        <summary>
            Returns the data type of an expression.
            <note name="Note">
                <b>VARTYPE( )</b> is similar to the <b>TYPE( )</b> function, but <b>VARTYPE( )</b> is faster and does not require quotation
                marks to enclose the expression for which the data type is returned.
            </note>
        </summary>
        <param name="eExpression">
            Specifies the expression for which the data type is returned. <b>VARTYPE( )</b> returns a single character
            indicating the data type of the expression.<br/>
            The table in the remarks section lists the characters that <b>VARTYPE( )</b> returns for each data type.
        </param>
        <param name="lNullDataType">
            Specifies whether <b>VARTYPE( )</b> returns the data type when eExpression contains the null value.
            The table in the remarks section lists the values of lNullDataType.
        </param>
        <returns>
            Character. <b>VARTYPE( )</b> returns a character representing the data type of the specified expression.
        </returns>
        <remarks>
            <list type="table">
                <listheader>
                    <term>Return value</term>
                    <description>Data type</description>
                </listheader>
                <item>
                    <term>C</term>
                    <description>
                        <b>Character</b>, <b>Memo</b>, <b>Varchar</b>, <b>Varchar</b> (Binary)
                    </description>
                </item>
                <item>
                    <term>D</term>
                    <description>
                        <b>Date</b>
                    </description>
                </item>
                <item>
                    <term>G</term>
                    <description>
                        <b>General</b>
                    </description>
                </item>
                <item>
                    <term>L</term>
                    <description>
                        <b>Logical</b>
                    </description>
                </item>
                <item>
                    <term>N</term>
                    <description>
                        <b>Numeric</b>, <b>Float</b>, <b>Double</b>, or <b>Integer</b>
                    </description>
                </item>
                <item>
                    <term>O</term>
                    <description>Object</description>
                </item>
                <item>
                    <term>Q</term>
                    <description>
                        <b>Blob</b>, <b>Varbinary</b>
                    </description>
                </item>
                <item>
                    <term>T</term>
                    <description>
                        <b>DateTime</b>
                    </description>
                </item>
                <item>
                    <term>U</term>
                    <description>Unknown or variable does not exist</description>
                </item>
                <item>
                    <term>X</term>
                    <description>Null</description>
                </item>
                <item>
                    <term>Y</term>
                    <description>
                        <b>Currency</b>
                    </description>
                </item>
            </list>
            <note name="Note">If eExpression is an array, the first element in the array is evaluated.</note>
            <list>
                <listheader>
                    <term>lNullDataType</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>True (.T.)</term>
                    <description>Return data type for eExpression.</description>
                </item>
                <item>
                    <term>False (.F.) or omitted</term>
                    <description>Return 'X' to indicate eExpression contains a null value.</description>
                </item>
            </list>
        </remarks>
    </vartype>
    <wvisible>
        <summary>
            Determines if the specified window has been activated and isn't hidden.
        </summary>
        <param name="WindowName">
            Specifies the name of the window WVISIBLE( ) evaluates. In X#, you can also specify the name of a toolbar.
            You can also include the empty string in WindowName to specify the main X# window.
        </param>
        <returns>
            Logical
        </returns>
        <remarks>
            WVISIBLE( ) returns true (.T.) if the specified window is shown or activated and isn't hidden.
            Windows are shown and activated with SHOW WINDOW and ACTIVATE WINDOW.<br/>
            WVISIBLE( ) returns false (.F.) if the window has not been activated, has been hidden with HIDE WINDOW,
            has been deactivated with DEACTIVATE WINDOW, or doesn't exist.
        </remarks>
        <example>
             <code language="X#">
                ACTIVATE WINDOW View
                ? WVISIBLE( "View" ) &amp;&amp; return .T.
                DEACTIVATE WINDOW View
                ? WVISIBLE( "View" ) &amp;&amp; return .F.
            </code>
        </example>
    </wvisible>
    <xmltocursor>
        <summary>
            Converts XML text into a X# cursor or table.
        </summary>
        <param name="eExpression">
            Specifies the XML text or an expression that evaluates to valid XML data. The eExpression parameter can be a X# memory variable,
            memo field contents, the return from an HTTP request, the return result from a SOAP method call, XML from the XMLDOM, or an ADO stream.<br/>
            <note name="Note">XMLTOCURSOR( ) generates an error if eExpression is not found or if eExpression does not parse to valid XML.</note>
        </param>
        <param name="cXMLFile">
            Specifies the name, and, optionally, the path of a physical XML file that resides on your local computer or network.<br/>
            If you do not specify a path, X# searches the path along the X# directory for the XML file.
        </param>
        <param name="cCursorName">
            Specifies the name of the cursor to store the result and creates the cursor in the current work area.<br/>
            If the cursor name already exists or is open, X# closes the cursor and creates a new one in an unused work area.
            If you omit or pass an empty string ("") for cCursorName, X# creates a cursor named "XMLRESULT" for returning the result.<br/>
            If cCursorName contains data and nFlags is set to 8192, X# appends the data being imported from the XML file to the existing table or cursor.
            The table or cursor must be open or in use. If cCursorName is an empty string (""), X# imports XML into the table or cursor that is open in
            the current work area.
        </param>
        <param name="nFlags">
            Specifies how XMLSource eExpression is handled in <b>XMLTOCURSOR( )</b>. The table in the remarks section describes the values for nFlags.
        </param>
        <returns>
            Numeric data type. <b>XMLTOCURSOR( )</b> returns the number of records created.
        </returns>
        <remarks>
            You can use <b>XMLTOCURSOR( )</b> with the OLE DB Provider for X#. However, the <b>_VFP</b> <b>VFPXMLProgID</b> property is not
            supported because the <b>_VFP</b> system variable is not supported in the OLE DB Provider.<br/>
            To use the X# OLE DB Provider with <b>XMLTOCURSOR( )</b>, you must install MSXML 3.0 on the computer with the OLE DB Provider.<br/><br/>
            <b>XMLTOCURSOR( )</b> generates a syntax error for record lengths greater than approximately 160 columns. The exact number of columns that
            cause an error depends on the length of the column names.<br/><br/>
            <b>XMLTOCURSOR( ) </b>does not use the <b>Varchar</b> type when creating a cursor from an XML document. However, <b>XMLTOCURSOR( )</b>
            supports appending data into an existing cursor with <b>Varchar</b> fields.<br/>
            When calling <b>XMLTOCURSOR( )</b> in append mode, X# adds an empty row if no XML element name matches any table or cursor column.<br/><br/>
            <b>XMLTOCURSOR( )</b> converts <b>Decimal</b> data type to <b>Numeric</b> 20,19 (width, precision). In versions prior to X# 8.0,
            <b>Decimal</b> mapped to <b>Numeric</b> 8,0.<br/><br/>
            <b>Numeric Overflow Conditions</b>   <b>XMLTOCURSOR( )</b> imports XML data containing X# numeric overflow conditions, for example,
            "*******", in place of a numeric or integer value. If a schema is provided, X# creates the correct data type in the resulting cursor but
            changes the overflow from asterisk (*) characters to 0.0 or 0 values. Therefore, the XML parser used by <b>XMLTOCURSOR( )</b> does not throw
            an error as a result of character values stored in a decimal type element.<br/>
            For more information about converting XML to X# data, see Converting Between XML and X# Data.
            <list type="table">
                <listheader>
                    <term>nFlags</term>
                    <description>Bit</description>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>0000</description>
                    <description>(Default) Treats the first parameter as a string containing XML data.</description>
                </item>
                <item>
                    <term>4</term>
                    <description>0100</description>
                    <description>Preserves white space in data and overrides the xml:space attribute of the XML data.</description>
                </item>
                <item>
                    <term>512</term>
                    <description>01000000000</description>
                    <description>
                        Specifies that the first parameter, either an eExpression or a cXMLFile, is a string containing the name and path of
                        an XML data file.
                    </description>
                </item>
                <item>
                    <term>1024</term>
                    <description>10000000000</description>
                    <description>
                        NOCPTRANS  Creates <b>Character</b> and <b>Memo</b> fields in the resultant cursor with the NOCPTRANS option and inserts the text or
                        XML values in the incoming elements into the <b>Character</b> or <b>Memo</b> field on an untranslated, byte-for-byte basis.<br/>
                        When used with flag 1024, <b>XMLTOCURSOR( )</b> returns a string padded with trailing spaces equal to the actual string, that is,
                        a string twice the length.
                    </description>
                </item>
                <item>
                    <term>2048</term>
                    <description>100000000000</description>
                    <description>
                        Use when the imported schema has an XML schema definition (XSD) schema containing decimal data type with restrictions, or facets,
                        of totalDigits="19" and fractionDigits="4."<br/>
                        XSD data type values are mapped to the X# <b>Currency</b> data type in the resulting cursor.
                    </description>
                </item>
                <item>
                    <term>4096</term>
                    <description>1000000000000</description>
                    <description>
                        Disables <b>base64</b> decoding.<br/>
                        In X#, base64 encoding is intended for encoding only binary data.
                    </description>
                </item>
                <item>
                    <term>8192</term>
                    <description>1100000000</description>
                    <description>
                        Specifies that cCursorName is the name or alias of an existing table or cursor and imports the data from the specified XML file into
                        an existing table or predefined cursor.<br/>
                        If cCursorName contains data, the data imported from the XML file is appended to the existing data.
                        If cCursorName is an empty string (""), the data from the XML file is imported into the table or cursor in the current work area.<br/>
                        Setting nFlags to 8192 can be useful when an XML schema is not available or not practical for use.
                    </description>
                </item>
                <item>
                    <term>32768</term>
                    <description>0x8000</description>
                    <description>Indicates that a code page should be used.</description>
                </item>
                <item>
                    <term>65536</term>
                    <description>0x10000</description>
                    <description>Maps XML Char fields to native Fox Varchar fields. If not specified, XML Char fields are mapped to Fox Character fields.</description>
                </item>
                <item>
                    <term>131072</term>
                    <description>0x20000</description>
                    <description>
                        Maps XML base64Binary fields to native Fox Varbinary fields if less than 255 bytes or Blob fields if greater than this length.
                        If not specified, XML base64Binary fields are mapped to Fox Memo fields.
                    </description>
                </item>
            </list>
            When you use flag 8192, be aware of the following:
            <list type="bullet">
                <term>
                    You must make sure the table schema matches the incoming XML elements in the appropriate manner.
                    X# enforces the data types in cCursorName as described in the Data Type Matching table in this topic but makes no other assumptions about
                    data types. Attempting to import incompatible values generates the appropriate message.
                </term>
                <term>
                    If the XML contains or references a schema, and the data types in the schema conflict with the data types of the cursor or table,
                    the data types in the cursor or table are used.
                </term>
                <term>
                    Element names in the XML file are mapped to the column names in cCursorName. In addition, X# imports only data from the element names
                    in the XML file that match the column names in cCusorName.
                </term>
                <term>
                    The cursor or table can have fewer columns than those in the XML file, but it must have at least one matching column.
                    The cursor or table can have additional columns that do not correspond to an element in the XML file.
                </term>
                <term>
                    If the table contains autoincrementing fields, <b>XMLTOCURSOR( )</b> fails if <b>AutoIncERROR</b> is set to <b>ON</b>.
                    Setting <b>AutoIncERROR</b> to <b>OFF</b> or turning off autoincrementing in the target table by using <b>CursorSetProp( )</b> allows
                    <b>XMLTOCURSOR( )</b> to succeed. The target table's autoincrementing field or fields are incremented according to the values specified,
                    and the values in the source table are not copied.
                </term>
            </list>
            The following table describes data type matching restrictions when setting nFlags to 8192.
            <list type="table">
                <listheader>
                    <term>X# data type</term>
                    <description>Behavior</description>
                </listheader>
                <item>
                    <term>
                        <b>Character</b>, <b>Character</b> (Binary), <b>Memo</b>, <b>Memo</b> (Binary)
                    </term>
                    <description>
                        Accepts any data but truncates any data exceeding the length of a <b>Character</b> column.
                    </description>
                </item>
                <item>
                    <term>
                        <b>Currency</b>
                    </term>
                    <description>
                        Accepts numeric data within accepted range of the <b>Currency</b> type but truncates numbers outside this range.
                    </description>
                </item>
                <item>
                    <term>
                        <b>Date</b>
                    </term>
                    <description>
                        Accepts XML format date and dateTime values.<br/>
                        X# converts the XML date and dateTime formats to the corresponding X# date.
                        X# preserves only the M/D/Y portion of the XML date or dateTime value.
                    </description>
                </item>
                <item>
                    <term>
                        <b>DateTime</b>
                    </term>
                    <description>
                        X# converts the XML date and dateTime formats to the corresponding X# date and discards precision beyond the
                        extent supported by X#.
                    </description>
                </item>
                <item>
                    <term>
                        <b>Double</b>
                    </term>
                    <description>
                        Accepts numeric data within the accepted range of the <b>Double</b> type but truncates numbers outside this range.
                    </description>
                </item>
                <item>
                    <term>
                        <b>Integer</b>
                    </term>
                    <description>
                        Accepts integer data within the accepted range of the <b>Integer</b> type but truncates numbers outside this range.
                    </description>
                </item>
                <item>
                    <term>
                        <b>Logical</b>
                    </term>
                    <description>Accepts the values True, .T., 1, False, .F., and 0.</description>
                </item>
                <item>
                    <term>
                        <b>Numeric</b>, <b>Float</b>
                    </term>
                    <description>
                        Accepts numeric data with or without decimals but truncates numbers outside the accepted range for these types
                        according to X# rules or replaces with the numeric overflow indicator ("*************").
                    </description>
                </item>
            </list>
        </remarks>
    </xmltocursor>
    <xmlupdategram>
        <summary>
            Mirrors changes made in a buffered table or cursor in an XML UpdateGram and returns a character string that contains the UpdateGram.<br/>
            An XML UpdateGram represents the before and after conditions of the changed portion of a X# table or cursor. Through additional processes,
            you can use an UpdateGram to commit these changes to the data represented by the XML UpdateGram document.
            <note name="Note">
                To use <b>XMLUpdateGRAM( )</b>, you must use <b>Set MultiLocks ON</b> and enable table buffering.
            </note>
            <note name="Tip">
                Before calling <b>XMLUpdateGRAM( )</b>, you should specify the key field list by calling <b>CursorSetProp( )</b> with the
                <b>KeyFieldList</b> property against existing cursors and tables. If you do not specify key fields, both the before and after
                representations contains all the fields in the table. If you specify one or more key fields, only those fields appear in the before section.
            </note>
        </summary>
        <param name="cAliasList">
            Specifies a comma-separated list of open tables or cursors, listed either by name or work area numbers in any combination,
            to include in the XML UpdateGram. If you specify no value or an empty string ("") for cAliasList, X# uses all open tables and cursors in the
            current data session that contain buffered changes.
        </param>
        <param name="nFlags">
            Specifies whether to return a formatted file. The table in the remarks section lists the additive flags for nFlags.
        </param>
        <param name="cSchemaLocation">
            Specifies the name and location of the mapping schema, if it exists.
            <note name="Note">You must supply the mapping schema.</note>
            For example, suppose you pass the a schema called <c>mySchema.xsd</c> to cSchemaLocation, the UpdateGram created contains a mapping schema
            attirbute as it appears in the following XML:
             <code language="X#">
                &lt;ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram"&gt;
                &lt;updg:sync mapping-schema="mySchema.xsd" &gt;
                &lt;updg:before&gt;
            </code>
        </param>
        <returns>
            Character data type. <b>XMLUpdateGRAM( )</b> returns a character string that contains the XML UpdateGram.
        </returns>
        <remarks>
            You can use <b>XMLUpdateGRAM( )</b> with the OLE DB Provider for X#. However, the <b>_VFP</b> <b>VFPXMLProgID</b> property is not supported
            because the <b>_VFP</b> system variable is not supported in the OLD EB Provider.
            <note name="Note">
                To use the X# OLE DB Provider with <b>XMLUpdateGRAM( )</b>,
                you must install MSXML 3.0 on the computer with the OLE DB Provider.
            </note>
            SQL Server and Visual Studio support the DiffGram format for updating XML. However, SQL XML requires a mapping schema to support this format.
            Therefore, <b>XMLUpdateGRAM( )</b> does not support this format.<br/>
            To avoid possible errors generated by <b>XMLUpdateGRAM( )</b> on tables containing <b>Memo</b> or <b>General</b> fields,
            use the <b>CursorSetProp( )</b> function. The following example shows how to include memo data in an XML UpdateGram by setting the
            <b>KeyFieldList</b> property using <b>CursorSetProp( )</b>:
             <code language="X#">
                Set MultiLocks ON
                Create CURSOR Test (mField M, cField I AutoInc)
                Insert Into Test (mField) VALUES ("123456789")
                Insert Into Test (mField) VALUES ("23456789")
                Insert Into Test (mField) VALUES ("3456789")
                Insert Into Test (mField) VALUES ("456789")
                CursorSetProp("Buffering",5)
                CursorSetProp("keyfieldlist",'cField')
                Update Test Set mField = "XXXXXXX" Where cField &lt; 3
                StrToFile(XMLUpdateGRAM(),'xmlupdate.txt')
                MODIFY FILE xmlupdate.txt
                RETURN
            </code>
            To write memo data in the XML UpdateGram to SQL Server, you must use an explicit schema on the SQL
            Server and reference the schema in the XML UpdateGram.<br/>
            Unlike the <b>CURSORTOXML( )</b> function, <b>XMLUpdateGRAM( )</b> disregards <b>Set Fields</b> statements and reads from the underlying cursor
            directly. To change the table structure before calling<b> XMLUpdateGRAM( )</b>, you must copy the data into a new cursor. For example,
            to change a <b>Numeric</b> field to a <b>Currency</b> field, the following example uses a SQL <b>Select</b> statement to create a new cursor
            and uses that cursor with <b>XMLUpdateGRAM( )</b>. The example makes the Total_Price field a currency field, enables buffering with
            <b>CursorSetProp( )</b>, adds sales tax with the <b>Replace</b> command, and creates an XML UpdateGram using the
            <b>XMLUpdateGRAM( )</b> function.
             <code language="X#">
                Select OrderID, CustID, NTOM(Total_Price) as Total_Price;
                From Orders Into CURSOR New_Orders READWRITE
                CursorSetProp("Buffering", 5, "New_Orders")
                Replace Total_Price WITH (Total_Price * 1.083)
                cXMLUpdg = XMLUpdateGRAM("New_Orders")
            </code>
            When using flag 32768, the flag's 16 and 32 settings can affect which code page is applied depending on the type of data you are writing to XML.
            The following tables show the possible combinations of settings and the code page each combination applies.<br/>
            For XML documents written with the 32768 flag set, the following code pages are applied.
            <list type="table">
                <item>
                    <term>Flag 16</term>
                    <description>Flag 32</description>
                    <description>Flag 32768 is Set</description>
                </item>
                <item>
                    <term>Not set</term>
                    <description>Not set</description>
                    <description>
                        XML documents: Window-1252.
                        Unicode data: code page 1252.
                        Character data: default code page, unless a field is marked as <b>NOCPTRANS</b>.
                    </description>
                </item>
                <item>
                    <term>True (.T)</term>
                    <description>Not set</description>
                    <description>
                        XML documents: Plus-<b>CodePage</b> property of the cursor. If XMLField <b>CodePage</b> property is greater than zero (0)
                        and it doesnt match the cursors code page, an error is reported.<br/>
                        Unicode data: the <b>Code page</b> property of the cursor object.<br/>
                        Character data: none. Raw data from the X# tables (.dbf) are used instead.
                    </description>
                </item>
                <item>
                    <term>Not set</term>
                    <description>Set</description>
                    <description>
                        XML documents: UTF-8 code page.<br/>
                        Unicode data: UTF-8 code page.<br/>
                        Character data: Default code page unless field is marked as <b>NOCPTRANS</b>,
                        in which case no additional character translation to UTF-8 occurs.
                    </description>
                </item>
                <item>
                    <term>Set</term>
                    <description>Set</description>
                    <description>
                        XML documents: UTF-8 code page.<br/>
                        Unicode data: UTF-8 code page.<br/>
                        Character data: default code page unless a field is marked as <b>NOCPTRANS</b>,
                        in which case the data are translated to UTF-8 using the <b>SYS(3005)</b> setting.
                    </description>
                </item>
            </list>
            For XML documents written without setting the 32768 flag, the following code pages are applied.
            <list type="table">
                <item>
                    <term>Flag 16</term>
                    <description>Flag 32</description>
                    <description>Without the 32768 flag</description>
                </item>
                <item>
                    <term>Not set</term>
                    <description>Not set</description>
                    <description>
                        XML documents: Window-1252.<br/>
                        Unicode data: code page 1252.<br/>
                        Character data: default code page unless a field is marked as <b>NOCPTRANS</b>.
                    </description>
                </item>
                <item>
                    <term>True (.T)</term>
                    <description>Not set</description>
                    <description>
                        XML documents: <b>CodePage</b> property of the cursor.
                        Character data: none. Raw data from the X# tables (.dbf) are used instead.
                        Unicode data: code page property of the cursor object.
                    </description>
                </item>
                <item>
                    <term>Not set</term>
                    <description>Set</description>
                    <description>
                        XML documents: UTF-8 code page.
                        Unicode data: UTF-8 code page.
                        Character data: default code page unless field is marked as <b>NOCPTRANS</b>, in which case no additional character translation to UTF-8 occurs.
                    </description>
                </item>
                <item>
                    <term>Set</term>
                    <description>Set</description>
                    <description>
                        XML documents: UTF-8 code page.<br/>
                        Unicode data: UTF-8 code page.<br/>
                        Character data: default code page unless field is marked as <b>NOCPTRANS</b>, in which case, they are translated to UTF-8 using code
                        page for the current <b>SYS(3005)</b> setting.
                    </description>
                </item>
            </list>
            For more information about converting XML to X# data, see Converting Between XML and X# Data.
            <list type="table">
                <listheader>
                    <term>nFlag</term>
                    <description>Bit</description>
                    <description>Output description</description>
                </listheader>
                <item>
                    <term>0</term>
                    <description>0000</description>
                    <description>(Default) Use UTF-8 formatted XML.</description>
                </item>
                <item>
                    <term>1</term>
                    <description>0001</description>
                    <description>Use unformatted, for example, continuous string XML.</description>
                </item>
                <item>
                    <term>2</term>
                    <description>0010</description>
                    <description>Enclose empty elements with both open and closing elements, for example, &lt;cc04&gt;&lt;cc04/&gt;.</description>
                </item>
                <item>
                    <term>4</term>
                    <description>0100</description>
                    <description>Preserve white space in fields.</description>
                </item>
                <item>
                    <term>8</term>
                    <description>1000</description>
                    <description>Wrap Memo fields in CDATA sections.</description>
                </item>
                <item>
                    <term>16</term>
                    <description>10000</description>
                    <description>Output encoding.</description>
                </item>
                <item>
                    <term>32</term>
                    <description>100000</description>
                    <description>Output encoding.</description>
                </item>
                <item>
                    <term>32768</term>
                    <description>none</description>
                    <description>Indicates that a code page should be used.</description>
                </item>
            </list>
            <note name="Note">
                When output encoding is UTF-8 (default), the XML Declaration does not contain an Encoding= attribute
                (no encoding attribute = UTF-8).
            </note>
            When output encoding is set to default to the code page of the cursor or table, the encoding attribute will be written according to the following table.
            <note name="Note">Encoding flags are set by combining bits 4 and 5 (0010000).</note>
            <list type="table">
                <listheader>
                    <term>Encoding flag</term>
                    <description>Bits 4 and 5</description>
                    <description>Description</description>
                </listheader>
                <item>
                    <term>+0</term>
                    <description>00</description>
                    <description>(Default) Windows 1252</description>
                </item>
                <item>
                    <term>+16</term>
                    <description>01</description>
                    <description>Set output encoding attribute to the code page of the cursor.</description>
                </item>
                <item>
                    <term>+32</term>
                    <description>10</description>
                    <description>Set output encoding attribute to UTF-8 (no character translation).</description>
                </item>
                <item>
                    <term>+48</term>
                    <description>11</description>
                    <description>Set output encoding attribute to UTF-8 and translate double-byte characters to UTF-8.</description>
                </item>
            </list>
        </remarks>
    </xmlupdategram>
    <execscript>
        <summary>
            Enables you to run multiple lines of code from variables, tables, and other text at runtime.
        </summary>
        <param name="cExpression">
            Represents the text, a variable, type string, or memo to be executed as code.
        </param>
        <param name="eParameter1">
            Optional. Specify parameters passed to a script that has a PARAMETERS or LPARAMETERS statement in first line.
        </param>
        <param name="eParameter2">
            Optional. Specify parameters passed to a script that has a PARAMETERS or LPARAMETERS statement in first line.
        </param>
        <param name="eParameterN">
            Optional. Specify parameters passed to a script that has a PARAMETERS or LPARAMETERS statement in first line.
        </param>

        <returns>
            The return value is the value returned by the script in cExpression. If the script returns no value, X# returns NIL.
        </returns>
        <remarks>
            ExecScript(), allows you to execute a block of code without compiling first. <br/>
            You can use all allowed statements inside the script and create objects,
            set their properties, call the methods and call functions.<br/>
        </remarks>
        <example>
            <code language="X#">?ExecScript("? 'Hello world from X# ExecScript'")</code>
        </example>
    </execscript>
</Runtimefunctions>


