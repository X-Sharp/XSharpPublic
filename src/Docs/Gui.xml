<?xml version="1.0" encoding="utf-8"?>
<doc>
  <members>
  </members>
  <EditConstants>
    <span>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Windows API Constan</description>
        </listheader>
        <item>
          <term>
            EDITAUTOHSCROLL
          </term>
          <description>ES_AUTOHSCROLL</description>
        </item>
        <item>
          <term>
            EDITAUTOVSCROLL
          </term>
          <description>ES_AUTOVSCROLL</description>
        </item>
        <item>
          <term>
            EDITBORDERED
          </term>
          <description>WS_BORDER</description>
        </item>
        <item>
          <term>
            EDITCENTER
          </term>
          <description>ES_CENTER</description>
        </item>
        <item>
          <term>
            EDITLEFT
          </term>
          <description>ES_LEFT</description>
        </item>
        <item>
          <term>
            EDITLOWERCASE
          </term>
          <description>ES_LOWERCASE</description>
        </item>
        <item>
          <term>
            EDITMULTILINE
          </term>
          <description>ES_MULTILINE</description>
        </item>
        <item>
          <term>
            EDITNOHIDESEL
          </term>
          <description>ES_NOHIDESEL</description>
        </item>
        <item>
          <term>
            EDITOEMCONVERT
          </term>
          <description>ES_OEMCONVERT</description>
        </item>
        <item>
          <term>
            EDITPASSWORD
          </term>
          <description>ES_PASSWORD</description>
        </item>
        <item>
          <term>
            EDITREADONLY
          </term>
          <description>ES_READONLY</description>
        </item>
        <item>
          <term>
            EDITRIGHT
          </term>
          <description>ES_RIGHT</description>
        </item>
        <item>
          <term>
            EDITUPPERCASE
          </term>
          <description>ES_UPPERCASE</description>
        </item>
        <item>
          <term>
            EDITWANTRETURN
          </term>
          <description>ES_WANTRETURN</description>
        </item>
      </list>
    </span>
  </EditConstants>
  <Alignment>
    <span>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>GBAALIGNCENTER</term>
          <description>Center aligned</description>
        </item>
        <item>
          <term>GBAALIGNLEFT</term>
          <description>
            Left aligned (This is the <b>default</b> for text.)
          </description>
        </item>
        <item>
          <term>GBAALIGNRIGHT</term>
          <description>
            Right aligned  (This is the <b>default</b> for numeric data.)
          </description>
        </item>
      </list>
    </span>
  </Alignment>
  <BrowseStyle>
    <span>

      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>GBSCONTROL2D</term>
          <description>No sculpting, text on a flat rectangle.</description>
        </item>
        <item>
          <term>GBSCONTROL3D</term>
          <description>Sculpted three-dimensional buttons.</description>
        </item>
        <item>
          <term>GBSEDIT</term>
          <description>Make browser "editable" (turn off read-only style).</description>
        </item>
        <item>
          <term>GBSREADONLY</term>
          <description>Make browser read-only (text cannot be changed).</description>
        </item>
      </list>

    </span>
  </BrowseStyle>
  <SplitBar>
    <span>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>GBSSBLEFT</term>
          <description>Places the splitbar at the left-edge of the browser.</description>
        </item>
        <item>
          <term>GBSSBMIDDLE</term>
          <description>Places the splitbar in the middle of the browser.</description>
        </item>
        <item>
          <term>GBSSBRIGHT</term>
          <description>Places the splitbar at the right-edge of the browser.</description>
        </item>
      </list>
    </span>
  </SplitBar>
  <Where>
    <span>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>GBLCOLCAPTION</term>
          <description>The column caption area.</description>
        </item>
        <item>
          <term>GBLHITEXT</term>
          <description>Highlighted (selected) text in the data area.</description>
        </item>
        <item>
          <term>GBLTEXT</term>
          <description>Text in the data display area. This is the default.</description>
        </item>
      </list>
    </span>
  </Where>
  <Colors>
    <span>

      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Color</description>
        </listheader>
        <item>
          <term>COLORBLACK</term>
          <description>Black</description>
        </item>
        <item>
          <term>COLORBLUE</term>
          <description>Blue</description>
        </item>
        <item>
          <term>COLORCYAN</term>
          <description>Cyan</description>
        </item>
        <item>
          <term>COLORGREEN</term>
          <description>Green</description>
        </item>
        <item>
          <term>COLORMAGENTA</term>
          <description>Magenta</description>
        </item>
        <item>
          <term>COLORRED</term>
          <description>Red</description>
        </item>
        <item>
          <term>COLORWHITE</term>
          <description>White</description>
        </item>
        <item>
          <term>COLORYELLOW</term>
          <description>Yellow</description>
        </item>
      </list>
    </span>
  </Colors>
  <LBStyles>
    <span>
      Possible style values are:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Windows API Constant</description>
        </listheader>
        <item>
          <term>LBOXDISABLENOSCROLL</term>
          <description>LBS_DISABLENOSCROLL</description>
        </item>
        <item>
          <term>LBOXEXTENDEDSEL</term>
          <description>LBS_EXTENDEDSEL</description>
        </item>
        <item>
          <term>LBOXHASSTRINGS</term>
          <description>LBS_HASSTRINGS</description>
        </item>
        <item>
          <term>LBOXMULTICOLUMN</term>
          <description>LBS_MULTICOLUMN</description>
        </item>
        <item>
          <term>LBOXMULTIPLESEL</term>
          <description>LBS_MULTIPLESEL</description>
        </item>
        <item>
          <term>LBOXNOINTEGRALHEIGHT</term>
          <description>LBS_NOINTEGRALHEIGHT</description>
        </item>
        <item>
          <term>LBOXNOREDRAW</term>
          <description>LBS_NOREDRAW</description>
        </item>
        <item>
          <term>LBOXNOTIFY</term>
          <description>LBS_NOTIFY</description>
        </item>
        <item>
          <term>LBOXOWNERDRAWFIXED</term>
          <description>LBS_OWNERDRAWFIXED</description>
        </item>
        <item>
          <term>LBOXOWNERDRAWVARIABLE</term>
          <description>LBS_OWNERDRAWVARIABLE</description>
        </item>
        <item>
          <term>LBOXSORT</term>
          <description>LBS_SORT</description>
        </item>
        <item>
          <term>LBOXSTANDARD</term>
          <description>
            LBS_STANDARD
          </description>
        </item>
        <item>
          <term>LBOXUSETABSTOPS</term>
          <description>LBS_USETABSTOPS</description>
        </item>
        <item>
          <term>LBOXWANTKEYBOARDINPUT</term>
          <description>LBS_WANTKEYBOARDINPUT</description>
        </item>
      </list>
    </span>
  </LBStyles>
  <CBStyles>
    <span>
      <list type="table">
        <listheader>
          <term>Constant</term>
        </listheader>
        <item>
          <term>CBS_AUTOHSCROLL</term>
          <description></description>
        </item>
        <item>
          <term>CBS_DISABLENOSCROLL</term>
          <description></description>
        </item>
        <item>
          <term>CBS_DROPDOWN</term>
          <description></description>
        </item>
        <item>
          <term>CBS_DROPDOWNLIST</term>
          <description></description>
        </item>
        <item>
          <term>CBS_HASSTRINGS</term>
          <description></description>
        </item>
        <item>
          <term>CBS_LOWERCASE</term>
          <description></description>
        </item>
        <item>
          <term>CBS_NOINTEGRALHEIGHT</term>
          <description></description>
        </item>
        <item>
          <term>CBS_OEMCONVERT</term>
          <description></description>
        </item>
        <item>
          <term>CBS_OWNERDRAWFIXED</term>
          <description></description>
        </item>
        <item>
          <term>CBS_OWNERDRAWVARIABLE</term>
          <description></description>
        </item>
        <item>
          <term>CBS_SIMPLE</term>
          <description></description>
        </item>
        <item>
          <term>CBS_SORT</term>
          <description></description>
        </item>
        <item>
          <term>CBS_UPPERCASE</term>
          <description></description>
        </item>
      </list>

    </span>
  </CBStyles>
  <Callback>
    <span>
      <note type="tip">
        Important! This is a callback method used by X#.
        Normally, it should not be called in your application code.
      </note>
    </span>
  </Callback>
  <NoIVar>
    <span>
      <note type="tip">
        Important! This message should not be called directly.
        It is called by the system for handling invalid references.
      </note>
    </span>
  </NoIVar>
  <ReturnsLogic>
    <returns>
      TRUE if successful; otherwise, FALSE.
    </returns>
  </ReturnsLogic>
  <Accelerator>
    <summary>
      Create an accelerator table.
    </summary>
    <remarks>
      Many applications use accelerators as keyboard equivalents for menu selections. An accelerator is a keystroke sequence that is associated with a particular menu command—the accelerator is used to execute the menu command without requiring the application user to first display the menu and then choose the command.
      For example, if the File New command had an accelerator of Ctrl+N, you could simply press this key combination to open a new document, rather than having to choose the File menu and then the New command.
      Each window can be given its own accelerator using the Window:Accelerator property. An accelerator generates events as though its associated menu command was actually selected. Note that an accelerator's menu command does not even have to be visible on any menu—thus an accelerator can be seen as a direct keystroke sequence for generating a command event.
    </remarks>
    <example>
      The following example demonstrates the use of the Accelerator class:
      <code language="X#">
        METHOD Init() CLASS MyTopAppWindow
        SUPER:Init()
        SELF:Show()
        SELF:Accelerator := Accelerator{IDA_HOTKEYS}
      </code>

      In Windows, an accelerator object is created using the ACCELERATORS statement in the resource entity. For example, the following defines three accelerator keys: "^X" for the Exit menu command, "Ctrl+Insert" for the Copy menu command, and "Shift+Insert" for the Paste menu command.
      <code language="X#">
        RESOURCE IDA_HOTKEYS ACCELERATORS
        BEGIN
        ^X, IDMI_EXIT
        VK_INSERT, IDMI_COPY, VIRTKEY, CONTROL
        VK_INSERT, IDMI_PASTE, VIRTKEY, SHIFT
        END
      </code>
    </example>
  </Accelerator>
  <Accelerator.ctor>
    <summary>
      Load an accelerator table from a resource entity.
    </summary>
    <param name="xResourceID">The resource ID of the accelerator table, or another accelerator object, whose accelerators are copied.</param>
    <remarks>
      When no parameter is passed, X# will create a dynamic accelerator. If another accelerator is passed in X# will copy its table of accelerator keys.
      The creation of the actual Windows accelerator is delayed until the Accelerator is first used.
    </remarks>
  </Accelerator.ctor>
  <Accelerator.AddAccelerator>
    <summary>
      Adds all accelerator keys of one accelerator object to another
    </summary>
    <param name="oAccelerator">Existing Accelerator objects, whose accelerator keys are copied. </param>
    <returns>
      TRUE when successful, FALSE when not, for example because the object not dynamic anymore
    </returns>
    <remarks>
      This method copies the accelerator keys from one accelerator object to another.
      <note type="tip">
        After the first use of a dynamic accelerator object, no more accelerators can be added.
      </note>
    </remarks>
  </Accelerator.AddAccelerator>
  <Accelerator.AddKey>
    <summary>
      Adds a new accelerator key to the accelerator table
    </summary>
    <param name="nMenuItemId">the accelerator ID which is sent with a MenuComandEvent{} when the accelerator key is pressed.</param>
    <param name="xKeyId">can be a numeric VO key-code, which is identical to the windows virtual-key code, or a string with one character which specifies the character-code.</param>
    <param name="lCtrl">When TRUE, the CTRL key must be held down when the accelerator key is pressed.</param>
    <param name="lAlt">When TRUE, the ALT key must be held down when the accelerator key is pressed.</param>
    <param name="lShift">When TRUE, the SHIFT key must be held down when the accelerator key is pressed.</param>
    <returns>
      TRUE when successful, FALSE when not, for example because the object not dynamic anymore
    </returns>
    <remarks>
      <note type="tip">
        After the first use of a dynamic accelerator object, no more accelerators can be added..
      </note>
    </remarks>
  </Accelerator.AddKey>
  <Accelerator.Create>
    <summary>
      <para>Creates the underlying windows accelerator.</para>
    </summary>
    <returns>
      <para>The handle of the accelerator, if successful. A null handle (NULL_PTR) is returned if the control creation failed.</para>
    </returns>
  </Accelerator.Create>
  <Accelerator.Destroy>
    <summary>
      Provide a method to de-instantiate an Accelerator object.
    </summary>
    <remarks>
      This method can be used when an Accelerator object is no longer needed. Accelerator:Destroy() de-instantiates the Accelerator object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
    <returns>
      NIL
    </returns>
  </Accelerator.Destroy>
  <Accelerator.Empty>
    <summary>
      Returns TRUE when the accelerator table contains no keys.
    </summary>
    <value>TRUE when the accelerator table contains no keys.</value>
  </Accelerator.Empty>
  <Accelerator.Handle>
    <summary>
      Return the handle for an accelerator.
    </summary>
    <returns>
      A handle describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
      When the Accelerator objects is 'dynamic' this will create the actual Windows GDI Object and no more accelerators can be added to the accelerator
    </remarks>
  </Accelerator.Handle>
  <ActiveXControl>
    <summary>
      Base class for ActiveX control objects.
    </summary>
    <remarks>
      The ActiveXControl class serves as the base class for ActiveX controls developed in X#. The main class representing the ActiveX control has to be derived from this class.
      <note type="tip">When creating ActiveX controls in the IDE, the class derived from ActiveXControl has to be specified in the OCX Base edit control on the OLE Server tab page in the Application Options dialog box.</note>
    </remarks>
  </ActiveXControl>
  <ActiveXControl.ctor>
    <summary>
      Instantiate an ActiveXControl object.
      Init()is automatically called by the ActiveX container. Normally, it should not be called from your application code.
    </summary>
    <param name="hObject">A handle (pointer) representing the object.</param>
    <remarks>
      This method instantiates an ActiveXControl object. Unlike other Init() methods, ActiveXControl:Init() should never be called from X#application code directly. Instead, it is called by the ActiveX container, which creates the ActiveX object.
      For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
    </remarks>
  </ActiveXControl.ctor>
  <ActiveXControl.AutoServer>
    <summary>
      The object representing the automation server interface of the ActiveX control.
    </summary>
    <value>The object representing the automation server interface of the ActiveX control.</value>
    <remarks>
      <note type="tip">When creating OLE Automation servers in the IDE, the class of the automation server has to be specified in the Automation edit control on the OLE Server tab page in the Application Options dialog box.</note>
    </remarks>
  </ActiveXControl.AutoServer>
  <ActiveXControl.Create>
    <summary>
      Create an ActiveX control.
      Create()is automatically called by the ActiveX container. Normally, it should not be called from your application code.
    </summary>
    <param name="hParent">The window handle of the parent (container) window.</param>
    <remarks>
      The Create() method is called after the ActiveXControl object is instantiated. Note that the both methods are called from the ActiveX container application: they should never be called directly from your code.
      Inside Create(), you should:
      1.	Instantiate a control or window object representing the user interface of the ActiveX control. This object should be assigned to OCXWindow.
      2.	Instantiate an object representing the automation interface of the ActiveX control and assign it to AutoServer.
      3.	Instantiate an object representing the event interface of the ActiveX control and assign it to Events—this step is optional.
      4.	Perform other initializations tasks.
      For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
    </remarks>
    <example>
      This is the Create() method from the Calendar ActiveX sample that is accessible from the Samples tab page of the Application Gallery:
      <code language="X#">
        METHOD Create(hParent) CLASS CalOCX
        LOCAL oCal AS CalendarControl
      </code><code language="X#">
        SUPER:Create(hParent)
        SELF:Events   := CalendarEvents{}
        oCal := CalendarControl{hParent, 100,;
        Point{0,0}, DIMension{100,100}, ,SELF}
        SELF:OCXWindow := oCal
        SELF:AutoServer := oCal
        oCal:CurrentDate := curDate
        oCal:Show()
        RETURN oCal:Handle()
      </code>
    </example>
  </ActiveXControl.Create>
  <ActiveXControl.DesignMode>
    <summary>
      A logical value returning TRUE if the ActiveX control is in design mode, i.e., used inside a development environment.
    </summary>
    <value>A logical value returning TRUE if the ActiveX control is in design mode, i.e., used inside a development environment.</value>
  </ActiveXControl.DesignMode>
  <ActiveXControl.Destroy>
    <summary>
      Provide a method to de-instantiate an ActiveX object.
    </summary>
    <remarks>
      This method can be used when an ActiveXControl object is no longer needed. ActiveXControl:Destroy() de-instantiates the ActiveXControl object, and allows you to close and free any resources that were opened or created by the object without waiting for the garbage collector.
    </remarks>
    <returns>
      NIL
    </returns>
  </ActiveXControl.Destroy>
  <ActiveXControl.Events>
    <summary>
      The object representing the event interface of the ActiveX control.
    </summary>
    <value>The object representing the event interface of the ActiveX control.</value>
    <remarks>
      <note type="tip">When creating ActiveX controls in the IDE, the class of the event object has to be specified in the Events edit control on the OLE Server tab page in the Application Options dialog box.</note>
      For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.

    </remarks>
  </ActiveXControl.Events>
  <ActiveXControl.OCXWindow>
    <summary>
      The object representing the user interface of the ActiveX control. This can be any X# control or window object.
      For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
    </summary>
    <value>
      The object representing the user interface of the ActiveX control. This can be any X# control or window object.
      For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
    </value>
  </ActiveXControl.OCXWindow>
  <ActiveXControl.SetExtent>
    <summary>
      Called by the container for resizing the ActiveX control.
    </summary>
    <param name="nX">The requested width of the ActiveXControl.</param>
    <param name="nY">The requested height of the ActiveXControl.</param>
    <remarks>
      SetExtend() is a callback method called by the container whenever the ActiveXControl is to be resized. The default behavior is to resize the user interface object. You may override this method in your derived ActiveX class in order to change the default behavior.
      For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
    </remarks>
  </ActiveXControl.SetExtent>
  <ActiveXControl.ShowPropPages>
    <summary>
      Callback method called by the ActiveX container whenever the ActiveX control should display its Property Pages dialog box.
    </summary>
    <remarks>
      ShowPropPages() is a callback method called by the ActiveX container whenever the ActiveX control should display its Property Pages dialog box. The default implementation displays a message box stating that the property pages are not implemented. In derived classes, this callback method should be overridden to display a dialog box that allows the user to change properties of the ActiveX control.
      For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
    </remarks>
  </ActiveXControl.ShowPropPages>
  <ActiveXControl.StreamIn>
    <summary>
      Callback method used to load persistent data.
    </summary>
    <param name="oStream">A Stream object representing the input stream.</param>
    <remarks>
      For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
    </remarks>
    <example>
      This is the StreamIn() method from the Calendar ActiveX sample that is accessible from the Samples tab page of the Application Gallery:
      <code language="X#">
        METHOD StreamIn(oStream) CLASS CalOCX
        LOCAL u AS USUAL
        u := oStream:Read()
        IF IsDate(u)
        curDate := u
        ENDIF
      </code>
    </example>
  </ActiveXControl.StreamIn>
  <ActiveXControl.StreamOut>
    <summary>
      Callback method used to save persistent data.
    </summary>
    <param name="oStream">A Stream object representing the input stream.</param>
    <remarks>
      For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
    </remarks>
    <example>
      This is the StreamOut() method from the Calendar ActiveX sample that is accessible from the Samples tab page of the Application Gallery:
      <code language="X#">
        METHOD StreamOut(oStream) CLASS CalOCX
        oStream:Write(oOCXWindow:CurrentDate)
        RETURN
      </code>
    </example>
  </ActiveXControl.StreamOut>
  <ActiveXEvents>
    <summary>
      Base class for classes implementing the event interface of ActiveX server applications.
    </summary>
    <remarks>
      ActiveXEvents serves as a base class for classes implementing the event interface of ActiveX server applications. The class implementing the application's event interface should be derived from ActiveXEvents, and it has to be specified on the OLE Server tab page in the Application Options dialog box when specifying your application's options.
      The methods of the event class are included in the server's type library and, at the same time, can be used by the server to fire an event by calling the FIREEVENT macro.
    </remarks>
  </ActiveXEvents>
  <ActiveXEvents.FireEvent>
    <summary>
      FireEvent() should never be called directly. Use the FIREEVENT UDC instead.
    </summary>
    <param name="iEventID">The event ID.</param>
    <param name="nPCount">The number of parameters.</param>
    <param name="pStack">A stack pointer.</param>
    <remarks>
      The FireEvent() method should never be called directly. Instead, the FIREEVENT macro (contained in OCX.UDC ) should be used to call this method with the correct parameters.
      Usually the methods of an event class are empty except for a FIREEVENT call. This way, the methods are used both to set up the server's type library and for firing the event in the server code.
    </remarks>
  </ActiveXEvents.FireEvent>
  <AdsSQLServer>
    <summary>Special Dbserver class that passes the string as SQL Query to the Advantage RDD.</summary>
  </AdsSQLServer>
  <AdsSQLServer.ctor>
    <inheritdoc />
    <summary>Construct a AdsSQLServer object.</summary>
    <param name="oFile">The SQL Query that is executed.</param>
  </AdsSQLServer.ctor>
  <AnimationControl>
    <summary>
      Create an animation control.
    </summary>
    <remarks>
      An animation control displays a silent Audio Video Interleaved (AVI) clip.
      A silent AVI clip is a series of bitmap frames like a movie. Although AVI clips can have sound, only silent AVI clips can be used with the animation control.
    </remarks>
  </AnimationControl>
  <AnimationControl.ctor>
    <summary>
      Construct an animation control.
    </summary>
    <param name="oOwner">The window that owns the animation control.</param>
    <param name="xID">The unique ID of the animation control (between 1 and 8000).</param>
    <param name="nResourceID">The resource ID of the animation control.</param>
    <param name="oPoint">The origin of the animation control in canvas coordinates.</param>
    <param name="oDimension">The dimension of the animation control in canvas coordinates.</param>
    <param name="oFileSpec">The FileSpec object that describes the associated AVI file.</param>
    <param name="cFileName">The file name that describes the associated AVI file.</param>
    <param name="kStyle">The style of the animation control.</param>
    <param name="hInst">The instance handle to be passed to the window when creating the control.</param>
  </AnimationControl.ctor>
  <AnimationControl.Create>
    <summary>
      Creates the underlying window control for a X# animation control object.
    </summary>
    <returns>
      The window handle of the control, if successful. A null handle (NULL_PTR) is returned if the control creation failed.
    </returns>
    <remarks>
      The Create() method creates the underlying window control for controls not loaded from a resource (i.e., designed with the Window Editor) but created at runtime. Normally, it is not necessary to call Create() directly—CA-X# will create the object internally as soon as a window handle is needed.
    </remarks>
    <example>
      <code language="X#">
        METHOD CreateAnimationControl() CLASS MyDataWindow
        LOCAL oAC AS AnimationControl
        // Init creates the X# AnimationControl Object
        oAC := AnimationControl{SELF, 100, Point{10,10}, Dimension{100,20}}
        // Calling Create forces the Windows control to be created
        oAC:Create()
      </code>
    </example>
  </AnimationControl.Create>
  <AnimationControl.FileSpec>
    <summary>
      The FileSpec object that describes the associated AVI file.
    </summary>
    <value>The FileSpec object that describes the associated AVI file.</value>
  </AnimationControl.FileSpec>
  <AnimationControl.Open>
    <summary>
      Open the AVI file and display its first frame in the animation control.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </AnimationControl.Open>
  <AnimationControl.OpenResource>
    <summary>
      Open the AVI resource and display its first frame in the animation control.
    </summary>
    <param name="xID">The unique ID for the animation resource (between 1 and 8000), or a ResourceID object identifying the AVI resource.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </AnimationControl.OpenResource>
  <AnimationControl.Play>
    <summary>
      Play the AVI file in the animation control.
    </summary>
    <param name="nFrom">The initial frame number. If omitted, playback begins from the first frame.</param>
    <param name="nTo">The final frame number. If omitted, playback continues to the last frame.</param>
    <param name="nRepeatCount">The number of times to play the AVI file. If omitted, playback is repeated indefinitely.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </AnimationControl.Play>
  <AnimationControl.Seek>
    <summary>
      Direct the animation control to display a particular frame in the AVI file.
    </summary>
    <param name="nFrame">The frame number to display.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </AnimationControl.Seek>
  <AnimationControl.Stop>
    <summary>
      Direct the animation control to stop the display of the AVI file.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </AnimationControl.Stop>
  <App>
    <summary>
      Create an entity that represents the overall application. Please note that you have to create a subclass of App in your code and add a Start() method to this class. You can't add a Start() method to the App() class inside GUI Classes like you can in VO.
    </summary>
    <remarks>
      The App class starts, runs, and stops the application. However, nearly all the code in an application executes in event handlers.
      Once you invoke the method App:Exec(), the system starts sending you events.
      While the term application is consistent in both the windowing and non-windowing worlds, the event-driven nature of a windowing application is designed to handle user-driven events (such as a mouse click or the resizing of a window). As a result, the function of the windowing application is relegated to an event scheduling loop.
      In this class, the Start() method is analogous to the entry point START() function in CA-Clipper. It is where the main elements of your application are constructed. The objects declared within App:Start() should be those which have "application wide" scope.
      Within the App:Start() method you must call App:Exec(). Doing so invokes the message processing loop of your underlying windowing system and begins the system event handling mechanism by activating the system dispatcher.
      The App:Exec() method can be thought of as a layered service with a typical "get-translate-dispatch-message" mechanism driven by your underlying windowing system and a "filter-translate-dispatch-event" mechanism being directed through the system framework by the system dispatcher.
      The App:Quit() method provides a way of breaking out of the application's Exec() loop to terminate the application. It is analogous to the QUIT() function in CA-Clipper.
    </remarks>
    <example>
      The following example demonstrates an entire application, using the various methods of the App class:
      <code language="X#">
        DEFINE IDM_MYMENU := "MyMenu"
        DEFINE IDM_MYMENU_CLOCK_ID := 1000
        DEFINE IDM_MYMENU_GETHANDLE_ID := 1001
        DEFINE IDM_MYMENU_QUIT_ID := 1002
        FUNCTION Start as VOID
        LOCAL oApp as XApp
        oApp := XApp{}
        oApp:Start()
        RETURN

        CLASS XApp INHERIT APP
        METHOD Start()
        LOCAL oWin AS Window
        oWin := MyTopAppWin{SELF}
        oWin:Show()
        SELF:Exec()
        RETURN NIL

        END CLASS

        CLASS MyTopAppWin INHERIT TopAppWindow

        CONSTRUCTOR(oOwnerApp)
        LOCAL lRetVal AS LONG
        SUPER(oOwnerApp)
        SELF:Menu := MyMenu{SELF}
        lRetVal := oOwnerApp:Run("Clock")
        SELF:Caption := "My Top App Window Application"
        SELF:WarningMessage("The return value of running CLOCK is :" +AsString(lRetVal))
        RETURN

        METHOD GetClock()
        SELF:Owner:Run("Clock")
        RETURN NIL

        METHOD GetHandle()
        SELF:WarningMessage("The handle of this app is :"+AsString(SELF:Handle()))
        RETURN NIL

        METHOD GoQuit()
        SELF:Owner:Quit()
        RETURN NIL
        END CLASS

        CLASS MyMenu INHERIT Menu
        CONSTRUCTOR(oOwner)
        SUPER(ResourceID{IDM_MYMENU})
        SELF:RegisterItem(IDM_MYMENU_CLOCK_ID, HyperLabel{#GetClock,,,})
        SELF:RegisterItem(IDM_MYMENU_GETHANDLE_ID, HyperLabel{#GetHandle,,,})
        SELF:RegisterItem(IDM_MYMENU_QUIT_ID, HyperLabel{#GoQuit,,,})
        END CLASS
        RESOURCE IDM_MYMENU MENU
        BEGIN
        POPUP "&amp;Menu1"
        BEGIN
        MENUITEM "&amp;Clock", IDM_MYMENU_CLOCK_ID
        MENUITEM "&amp;Get App Handle", IDM_MYMENU_GETHANDLE_ID
        MENUITEM SEPARATOR
        MENUITEM "&amp;QUIT", IDM_MYMENU_QUIT_ID
        END
        END
      </code>
    </example>
  </App>
  <App.ctor>
    <summary>
      Construct an application.
    </summary>
    <remarks>
      <br/>Important! X# instantiates this object.
    </remarks>
    <param name="oOwner">The window that owns the application.</param>
  </App.ctor>
  <App.AfterDispatch>
    <summary>
      Low-level handler used with App:BeforeDispatch() for intercepting any message posted to an application's message queue.
    </summary>
    <param name="hWnd">The window handle for which the message is meant.</param>
    <param name="uMsg">The message constant.</param>
    <param name="wParam">The DWORD parameter.</param>
    <param name="lParam">The LONG parameter.</param>
    <remarks>
      The BeforeDispatch() and AfterDispatch() methods are low-level handlers that intercept any message posted to the application's message queue. BeforeDispatch() is called before the message is dispatched to the Dispatch() method of the corresponding window, whereas AfterDispatch() is called afterwards.
      <note type="tip">These methods are not implemented as part of the GUI classes. Rather, they should be implemented by the programmer if general, application-wide message intercepting and handling are wanted. BeforeDispatch() and AfterDispatch() are called from within App:Exec() if they exist.</note>
    </remarks>
    <example>
      See the App:BeforeDispatch() example.
    </example>
  </App.AfterDispatch>
  <App.BeforeDispatch>
    <summary>
      Low-level handler used with App:AfterDispatch() for intercepting any message posted to an application's message queue.
    </summary>
    <param name="hWnd">The window handle for which the message is meant.</param>
    <param name="uMsg">The message constant.</param>
    <param name="wParam">The DWORD parameter.</param>
    <param name="lParam">The LONG parameter.</param>
    <returns>
      TRUE if the message should be further processed; otherwise, FALSE.
    </returns>
    <remarks>
      The BeforeDispatch() and AfterDispatch() methods are low-level handlers that intercept any message posted to the
      application's message queue. BeforeDispatch() is called before the message is dispatched to the Dispatch() method
      of the corresponding window, whereas AfterDispatch() is called afterwards.
      <note type="tip">
        These methods are not implemented as part of the GUI classes. Rather, they should be implemented by
        the programmer if general, application-wide message intercepting and handling are wanted. BeforeDispatch() and
        AfterDispatch() are called from within App:Exec() if they exist.
      </note>
    </remarks>
    <example>
      This example disables single left-button clicks application-wide:
      <code language="X#">
        METHOD BeforeDispatch(hWnd, uMsg, wParam, lParam) CLASS App
        IF uMsg == WM_LBUTTONDOWN
        RETURN FALSE
        ENDIF
        RETURN TRUE
      </code>
    </example>
  </App.BeforeDispatch>
  <App.Exec>
    <summary>
      Start the event handling loop for the application.
    </summary>
    <param name="uObject">
      The object (usually a dialogwindow) for which to process the message
    </param>
    <param name="kExecType">
      The type of event handling loop to start, specified as one of the following constants
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>EXECNORMAL</term>
          <description>
            Tells the system to continue to execute the application until either the user closes it
            (by selecting the Close menu command or using the standard Windows accelerator Alt+F4)
            or the application decides to close by deliberately invoking the App:Quit() method.
            When the application terminates, the thread of control exits from App:Exec() to the
            next statement in your code. This is the default.
          </description>
        </item>
        <item>
          <term>EXECWHILEEVENT</term>
          <description>
            Tells the system to continue to execute the application only while there are still events queued.
            Once the system has dispatched the last event in the queue, the thread of control exits from App:Exec().
            This gives you the opportunity to do some processing and then start another event loop by invoking
            App:Exec() again. You should use this mechanism when you want to do some background processing
            while the application is idle.
          </description>
        </item>
      </list>
    </param>
    <param name="oObject">** missing parameter documentation **</param>
    <returns>
      A value of 0 indicates normal termination (no errors). A non-zero value indicates abnormal termination.
    </returns>
    <remarks>
      Normally, the event handling loop for the application continues looping until there are no more EventContext objects. It can also terminate upon calling App:Quit().
      <note type="tip">Make sure that you show at least one window object before calling App:Exec().</note>
    </remarks>
  </App.Exec>
  <App.GetAccel>
    <summary>This method returns the handle for the current active Accelerator Table.</summary>
    <returns>The handle for the current active Accelerator Table.</returns>
    <remarks>This handle gets set in the Activate event of the window class.</remarks>
  </App.GetAccel>
  <App.GetAccelWindow>
    <summary>This method gets the handle to the window for which accelerators must be translated.</summary>
    <returns>The window for which accelerators must be translated.</returns>
    <remarks>This handle gets set in the Activate event of the window class.</remarks>
  </App.GetAccelWindow>
  <App.GetDialogWindow>
    <summary>This method gets the handle active Dialog window for which Dialog keys must be handled</summary>
    <returns>The handle to the active Dialog window.Please note that the surface of a DataWindow is also a DialogWindow.</returns>
    <remarks>This handle gets set in the Activate() method and event handler of the DialogWindow class.</remarks>
  </App.GetDialogWindow>
  <App.GetMdiClientWindow>
    <summary>This method gets the handle to the MDI Clientwindow on the active ShellWindow.</summary>
    <returns>The handle to the MDI Client window.</returns>
    <remarks>This handle gets set in the constructor of the ShellWindow.</remarks>
  </App.GetMdiClientWindow>
  <App.Handle>
    <summary>
      Return the handle for an application.
    </summary>
    <param name="nHandleType">
      The type of handle required. 0 is the only supported option, and it is the default if <paramref name="nHandle" /> is omitted.
    </param>
    <returns>
      A handle describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
    </remarks>
  </App.Handle>
  <App.Quit>
    <summary>
      Terminate the application by instructing the application to close itself.
    </summary>
    <remarks>
      This method is normally invoked when an Exit menu command is selected.
    </remarks>
  </App.Quit>
  <App.Run>
    <summary>
      Invoke and execute a specified command.
    </summary>
    <param name="sCommand">The command to be executed (including any required arguments).</param>
    <returns>
      A long integer value indicating successful completion or an error. The numbers 0-32 correspond to a specific error type in Windows (e.g., 0 means "out of memory," 2 means "file not found," etc.); any other number indicates successful completion.
    </returns>
  </App.Run>
  <App.SetAccel>
    <summary>This method sets the handle for the current active Accelerator Table (belonging to the active menu).</summary>
    <param name="hNewAccel">The handle to the Accelerator table that has to become active</param>
    <returns>NIL</returns>
    <remarks>This handle gets set in the Activate event of the window class.</remarks>
  </App.SetAccel>
  <App.SetAccelWindow>
    <summary>This method sets the window for which accelerators must be translated.</summary>
    <param name="hNewAccelWnd">The handle for the window for which accelerators (labels that start with an ampersand) must be translated.</param>
    <returns>NIL</returns>
    <remarks>This handle gets set in the Activate event of the window class.</remarks>
  </App.SetAccelWindow>
  <App.SetDialogWindow>
    <summary>This method sets the handle active Dialog window for which Dialog keys must be handled</summary>
    <param name="hNewDialogWnd">The handle for active Dialog window. Please note that the surface of a DataWindow is also a DialogWindow.</param>
    <param name="oSurface">The surface object for the active window.</param>
    <returns>NIL</returns>
    <remarks>This handle gets set in the Activate() method and event handler of the DialogWindow class.</remarks>
  </App.SetDialogWindow>
  <App.SetMdiClientWindow>
    <summary>This method sets the handle to the MDI Clientwindow on the active ShellWindow.</summary>
    <param name="hNewMdiClientWnd">The handle for the MDI Clientwindow.</param>
    <returns>NIL</returns>
    <remarks>This handle gets set in the constructor of the ShellWindow.</remarks>
  </App.SetMdiClientWindow>
  <App.Start>
    <summary>
      Provide the entry point for an application.
    </summary>
    <remarks>
      In the App:Start() method, the main elements of your application are constructed. The objects declared within App:Start() should be those which have "application wide" scope. Within the App:Start() method you must call App:Exec(), invoking the message processing loop of your underlying windowing system and beginning the system event handling mechanism by activating the system dispatcher.
    </remarks>
  </App.Start>
  <AppCommandEvent>
    <summary>
      Provide information about an AppCommand event, which is launched by the extra keys on an extended keyboard or mouse.
    </summary>
    <remarks>
      The AppCommandEvent class is created by X# in responce to the activation of a key on an Extended keyboard or mouse.
    </remarks>
  </AppCommandEvent>
  <AppCommandEvent.ctor>
    <inheritdoc />
  </AppCommandEvent.ctor>
  <AppCommandEvent.Command>
    <summary>
      The command associated with this event.
    </summary>
    <value>The command associated with this event.</value>
    <remarks>
      <a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/wm-appcommand">See the Ms docs website for a list of possible commands</a>
    </remarks>
  </AppCommandEvent.Command>
  <AppCommandEvent.IsControl>
    <summary>
      Returns TRUE if the Control Key is down; otherwise, FALSE.
    </summary>
    <value>TRUE if the Control Key is down; otherwise, FALSE.</value>
  </AppCommandEvent.IsControl>
  <AppCommandEvent.IsDeviceKey>
    <summary>
      Returns TRUE if the device that issued the command was a keyboard; otherwise, FALSE.
    </summary>
    <value>TRUE if the device that issued the command was a keyboard; otherwise, FALSE.</value>
  </AppCommandEvent.IsDeviceKey>
  <AppCommandEvent.IsDeviceMouse>
    <summary>
      Returns TRUE if the device that issued the command was a mouse; otherwise, FALSE.
    </summary>
    <value>TRUE if the device that issued the command was a mouse; otherwise, FALSE.</value>
  </AppCommandEvent.IsDeviceMouse>
  <AppCommandEvent.IsDeviceOEM>
    <summary>
      Returns TRUE if the device that issued the command was an OEM device; otherwise, FALSE.
    </summary>
    <value>TRUE if the device that issued the command was an OEM device; otherwise, FALSE.</value>
  </AppCommandEvent.IsDeviceOEM>
  <AppCommandEvent.IsLeftButton>
    <summary>
      Returns TRUE if the Left mouse button is down; otherwise, FALSE.
    </summary>
    <value>TRUE if the Left mouse button is down; otherwise, FALSE.</value>
  </AppCommandEvent.IsLeftButton>
  <AppCommandEvent.IsMiddleButton>
    <summary>
      Returns TRUE if the Middle mouse button is down; otherwise, FALSE.
    </summary>
    <value>TRUE if the Middle mouse button is down; otherwise, FALSE.</value>
  </AppCommandEvent.IsMiddleButton>
  <AppCommandEvent.IsRightButton>
    <summary>
      Returns TRUE if the Right mouse button is down; otherwise, FALSE.
    </summary>
    <value>TRUE if the Right mouse button is down; otherwise, FALSE.</value>
  </AppCommandEvent.IsRightButton>
  <AppCommandEvent.IsShift>
    <summary>
      Returns TRUE if the Shift Key is down; otherwise, FALSE.
    </summary>
    <value>TRUE if the Shift Key is down; otherwise, FALSE.</value>
  </AppCommandEvent.IsShift>
  <AppCommandEvent.IsXButton1>
    <summary>
      Returns TRUE if the first X mouse button is down; otherwise, FALSE.
    </summary>
    <value>TRUE if the first X mouse button is down; otherwise, FALSE.</value>
  </AppCommandEvent.IsXButton1>
  <AppCommandEvent.IsXButton2>
    <summary>
      Returns TRUE if the second X mouse button is down; otherwise, FALSE.
    </summary>
    <value>TRUE if the second X mouse button is down; otherwise, FALSE.</value>
  </AppCommandEvent.IsXButton2>
  <AppCommandEvent.oTarget>
    <summary>
      Returns the target of the command.
      If it is a Key event the target is focused control or window. If it is a Mouse event the target is the control or window that is under the mouse pointer.
    </summary>
    <value>
      the target of the command.
      If it is a Key event the target is focused control or window. If it is a Mouse event the target is the control or window that is under the mouse pointer.
    </value>
  </AppCommandEvent.oTarget>
  <AppWindow>
    <summary>
      Provide the base class from which all X# application windows are subclassed.
    </summary>
    <remarks>
      Use the methods of the AppWindow class to customize the appearance of top, shell, and child application windows (for example, the display of border styles, the system menu, or icons).
    </remarks>
  </AppWindow>
  <AppWindow.ctor>
    <summary>
      Construct an application window.
    </summary>
    <param name="oOwner">The window that owns the application window.</param>
  </AppWindow.ctor>
  <AppWindow.Default>
    <inheritdoc />
  </AppWindow.Default>
  <AppWindow.Destroy>
    <summary>
      Provide a method to free memory resources allocated for an AppWindow object and its derived objects.
    </summary>
    <remarks>
      This method immediately frees resources for AppWindow objects created explicitly in your application. AppWindow:Destroy() also takes care of resources allocated to derived classes and deallocates them in the necessary order (e.g., child windows are destroyed before the parent window; dialog windows and MDI shell windows are also looked after).
    </remarks>
  </AppWindow.Destroy>
  <AppWindow.Dispatch>
    <inheritdoc />
  </AppWindow.Dispatch>
  <AppWindow.EnableBorder>
    <summary>
      Set the border style for an application window.
    </summary>
    <param name="kBorderStyle">The display style of the application window's border, specified as one of the following constantsn</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>WINDOWNOBORDER</term>
          <description>No border.</description>
        </item>
        <item>
          <term>WINDOWNONSIZINGBORDER</term>
          <description>A nonsizable, captioned border.</description>
        </item>
        <item>
          <term>WINDOWSIZINGBORDER</term>
          <description>
            A resizable, captioned border. This is the <b>default</b>.
          </description>
        </item>
      </list>
    </remarks>
  </AppWindow.EnableBorder>
  <AppWindow.EnableHorizontalScroll>
    <summary>
      Enable/disable a window horizontal scroll bar in an application window.
    </summary>
    <param name="lEnable">TRUE enables the horizontal scroll bar; FALSE disables it. The default is TRUE.</param>
    <returns>
      If the scroll bar is enabled, a WindowHorizontalScrollBar object is returned; if disabled, NULL_OBJECT is returned.
    </returns>
    <remarks>
      <note type="tip">This is the only valid way to create a window horizontal scroll bar.</note>
      A WindowHorizontalScrollBar object is a special type of scroll bar that appears aligned along the bottom of a window's canvas area. It resizes itself according to the size of the window that owns it.
      After creating a window horizontal scroll bar, it should then be shown and its range set.
    </remarks>
    <example>
      This example enables a WindowHorizontalScrollBar object and sets its range to 1-80, with a block size of 8:
      <code language="X#">
        METHOD Init() CLASS MyAppWindow
        owhs := SELF:EnableHorizontalScroll(TRUE)
        owhs:Show()
        owhs:Range := Range{1,80}
        owhs:BlockSize := 8
      </code>
    </example>
  </AppWindow.EnableHorizontalScroll>
  <AppWindow.EnableMaxBox>
    <summary>
      Enable/disable a maximize box in an application window.
    </summary>
    <param name="lEnable">TRUE enables the maximize box; FALSE disables it. The default is TRUE.</param>
  </AppWindow.EnableMaxBox>
  <AppWindow.EnableMinBox>
    <summary>
      Enable/disable a minimize box in an application window.
    </summary>
    <param name="lEnable">TRUE enables the minimize box; FALSE disables it. The default is TRUE.</param>
  </AppWindow.EnableMinBox>
  <AppWindow.EnableOleDropTarget>
    <summary>
      Register the window as an OLE drop target.
    </summary>
    <param name="lEnable">A logical value specifying whether to enable (TRUE) or disable (FALSE) the window as a drop target.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      A window that is registered as an OLE drop target using AppWindow:EnableOLEDropTarget() can handle OLE drag and drop events and create new OLE objects in response to such events. In the associated handlers, an OLEDragEvent object is passed as a parameter that can be used to create a new OLE object by calling OLEObject:CreateFromOLEDragEvent().
    </remarks>
    <example>
      The following code enables a data window as a drop target and creates a new OLE object inside its OLEDrop handler. It also checks the name of the OLE object to allow only WordPad documents:
      <code language="X#">
        METHOD EnableOLEDropTarget CLASS DropTargetDataWindow
        SELF:EnableOLEDropTarget(TRUE)
        METHOD OLEDrop(oOLEDragEvent) CLASS MyChild
        LOCAL oOLE AS OLEObject
        LOCAL lRet AS LOGIC
        IF oOLEDragEvent:ObjectName == "WordPad Document"
        oOLE := OLEObject{SELF}
        oOLE:AllowInPlace := TRUE
        oOLE:AllowResize := TRUE
        IF oOLE:CreateFromOLEDragEvent(oOLEDragEvent)
        oOLE:Origin := oOLEDragEvent:Position
        oOLE:Show()
        oOLE:SetFocus()
        ENDIF
        ENDIF
      </code>
    </example>
  </AppWindow.EnableOleDropTarget>
  <AppWindow.EnableStatusBar>
    <summary>
      Enable/disable a status bar in an application window.
    </summary>
    <param name="lEnable">TRUE enables the status bar; FALSE disables it. The default is TRUE.</param>
    <returns>
      The status bar object.
    </returns>
    <remarks>
      Any status information sent to the application appears on its status bar.
    </remarks>
  </AppWindow.EnableStatusBar>
  <AppWindow.EnableSystemMenu>
    <summary>
      Enable/disable a system menu in an application window.
    </summary>
    <param name="lEnable">TRUE enables the system menu; FALSE disables it. The default is TRUE.</param>
    <returns>
      If the system menu is enabled, a system menu is returned; if disabled, NIL is returned.
    </returns>
    <example>
      The following example enables a system menu in an application window:
      <code language="X#">oSysMenu := oAppWindow:EnableSystemMenu(TRUE)</code>
    </example>
  </AppWindow.EnableSystemMenu>
  <AppWindow.EnableToolBar>
    <summary>
      Enable/disable a toolbar in an application window.
    </summary>
    <param name="lEnable">TRUE enables the toolbar; FALSE disables it. The default is TRUE.</param>
    <returns>
      The toolbar object.
    </returns>
  </AppWindow.EnableToolBar>
  <AppWindow.EnableVerticalScroll>
    <summary>
      Enable/disable a window vertical scroll bar in an application window.
    </summary>
    <param name="lEnable">TRUE enables the WindowVerticalScrollBar object; FALSE disables it. The default is TRUE.</param>
    <returns>
      If the scroll bar is enabled, a WindowVerticalScrollBar object is returned; if disabled, NULL_OBJECT is returned.
    </returns>
    <remarks>
      <note type="tip">This is the only valid way to create a window vertical scroll bar.</note>
      A WindowVerticalScrollBar object is a special type of scroll bar that is aligned along the right side of a window's canvas area. It resizes itself according to the size of the window that owns it.
      After creating a WindowVerticalScrollBar object, it should then be shown and its range set.
    </remarks>
    <example>
      This example enables a WindowVerticalScrollBar object and sets its range to be 1-200, with a block size of 25:
      <code language="X#">
        METHOD Init() CLASS TopAppWindow
        pwvs := SELF:EnableVerticalScroll()
        pwvs:Show()
        pwvs:Range := Range{1,200}
        pwvs:BlockSize := 25
      </code>
    </example>
  </AppWindow.EnableVerticalScroll>
  <AppWindow.EndWindow>
    <summary>
      Remove this application window from view (passing control back to the routine which created the application window).
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <param name="lSendMsg">
      A logical value that indicates if the class should use the SendMessage() function to close the window
      (which works immediately) or the PostMessage() function (which adds the message at the message event queue)
    </param>
  </AppWindow.EndWindow>
  <AppWindow.ErrorMessage>
    <summary>
      Display a message in an error box.
    </summary>
    <param name="oHyperLabel">The hyperlabel object containing the description (HyperLabel:Description) to be displayed in the error box.</param>
    <param name="uText">The description to be displayed in the error box.</param>
  </AppWindow.ErrorMessage>
  <AppWindow.OLEDragEnter>
    <summary>
      Called whenever the mouse enters the window's client area during a drag and drop operation.
    </summary>
    <param name="oOleDragEvent">The specified OLEDragEvent object.</param>
    <remarks>
      The OLE runtime engine calls the following event handlers after an AppWindow object has been registered as an OLE drag and drop target: OLEDragEnter(), OLEDragOver(), OLEDragLeave(), and OLEDrop(). By investigating the passed OLEDragEvent object (for example, a specific server), you can allow or disallow a drag and drop action by returning TRUE or FALSE. This also affects the appearance of the drag and drop cursor. By default OLEDragEnter() returns TRUE.
      <note type="tip">In derived classes you can implement your own OLEDragEnter handlers to customize the default behavior.</note><note type="tip">This method is only available when you include the OLE library in the application's search path.</note>
    </remarks>
  </AppWindow.OLEDragEnter>
  <AppWindow.OLEDragLeave>
    <summary>
      Called whenever the mouse leaves the window's client area during a drag and drop operation.
    </summary>
    <param name="oOleDragEvent">The specified OLEDragEvent object.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The OLE runtime engine calls the following event handlers after an AppWindow object has been registered as an OLE drag and drop target: OLEDragEnter(), OLEDragOver(), OLEDragLeave(), and OLEDrop(). By investigating the passed OLEDragEvent object (for example, a specific server), you can allow or disallow a drag and drop action by returning TRUE or FALSE. This also affects the appearance of the drag and drop cursor. By default OLEDragLeave() returns TRUE.
      <note type="tip">In derived classes you can implement your own OLEDragLeave handlers to customize the default behavior.</note><note type="tip">This method is only available when you include the OLE library in the application's search path.</note>
    </remarks>
  </AppWindow.OLEDragLeave>
  <AppWindow.OLEDragOver>
    <summary>
      Called whenever the mouse moves within the window's client area during a drag and drop operation.
    </summary>
    <param name="oOleDragEvent">The specified OLEDragEvent object.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The OLE runtime engine calls the following event handlers after an AppWindow object has been registered as an OLE drag and drop target: OLEDragEnter(), OLEDragOver(), OLEDragLeave(), and OLEDrop(). By investigating the passed OLEDragEvent object (for example, a specific server), you can allow or disallow a drag and drop action by returning TRUE or FALSE. This also affects the appearance of the drag and drop cursor. By default OLEDragOver() returns TRUE.
      <note type="tip">In derived classes you can implement your own OLEDragOver handlers to customize the default behavior.</note><note type="tip">This method is only available when you include the OLE library in the application's search path.</note>
    </remarks>
  </AppWindow.OLEDragOver>
  <AppWindow.OLEDrop>
    <summary>
      Called whenever the mouse is released within the window's client area during a drag and drop operation.
    </summary>
    <param name="oOleDragEvent">The specified OLEDragEvent object.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The OLE runtime engine calls the following event handlers after an AppWindow object has been registered as an OLE drag and drop target: OLEDragEnter(), OLEDragOver(), OLEDragLeave(), and OLEDrop(). By investigating the passed OLEDragEvent object (for example, a specific server), you can allow or disallow a drag and drop action by returning TRUE or FALSE. This also affects the appearance of the drag and drop cursor.
      By default OLEDrop() returns TRUE. The typical response to the OLEDrop() event is to create a new OLE object by using the CreateFromOLEDragEvent() method.
      <note type="tip">In derived classes you can implement your own OLEDrop handlers to customize the default behavior.</note><note type="tip">This method is only available when you include the OLE library in the application's search path.</note>
    </remarks>
    <example>
      The following example is from the OLE Container application in ...\SAMPLES\OLE\CONT:
      <code language="X#">
        METHOD OleDrop(oOleDragEvent) CLASS Container
        LOCAL oOle AS OleObject
        LOCAL p AS point
        LOCAL lRet := FALSE AS LOGIC
        oOle := DraggableOLEObject{SELF}
        oOle:AllowInPlace   := TRUE
        oOle:AllowResize   := TRUE
        oOle:AutoSizeOnCreate := TRUE
        IF (oOle:CreateFromOleDragEvent(oOleDragEvent))
        p := oOleDragEvent:Position
        SELF:SetupOLEObject(oOle, p)
        lRet := TRUE
        ENDIF
      </code><code language="X#">RETURN lRet</code>
    </example>
  </AppWindow.OLEDrop>
  <AppWindow.OLEInPlaceActivate>
    <summary>
      Called whenever a child OLE object is about to be "inplace" activated.
    </summary>
    <example>
      The following example is from the OLE Container application in ...\SAMPLES\OLE\CONT:
      <code language="X#">
        METHOD OLEInPlaceActivate() CLASS Container
        SELF:Owner:ToolBar:Hide()
        //self:Owner:StatusBar:Hide()
        RETURN SUPER:OLEInPlaceActivate()
      </code>
    </example>
  </AppWindow.OLEInPlaceActivate>
  <AppWindow.OLEInPlaceDeactivate>
    <summary>
      Called whenever a child OLE object is about to be "inplace" deactivated.
    </summary>
    <example>
      The following example is from the OLE Container application in ...\SAMPLES\OLE\CONT:
      <code language="X#">
        METHOD OLEInPlaceDeactivate() CLASS Container
        SELF:Owner:ToolBar:Show()
        //self:Owner:StatusBar:Show()
        RETURN SUPER:OLEInPlaceDeactivate()
      </code>
    </example>
  </AppWindow.OLEInPlaceDeactivate>
  <AppWindow.QuitOnClose>
    <summary>
      A logical value. If set to TRUE, quits the application when this (main) window is closed. The default value is FALSE.
    </summary>
    <value>A logical value. If set to TRUE, quits the application when this (main) window is closed. The default value is FALSE.</value>
  </AppWindow.QuitOnClose>
  <AppWindow.ReportException>
    <summary>This is a compatibility method that is no longer used or needed.</summary>
    <param name="oRQ">The ReportQueue object that reports an exception.</param>
  </AppWindow.ReportException>
  <AppWindow.ReportNotification>
    <summary>
      Called by ReportQueue when it has a message for the owner window.
    </summary>
    <param name="oRQ">The ReportQueue object to be checked for pending commands.</param>
    <returns>
      TRUE if there are any pending reporting commands waiting to be executed; otherwise, FALSE.
    </returns>
    <remarks>
      This method provides a mechanism to determine if a report queue that this application window owns has any pending reporting commands. See ReportQueue:EventType access for different event codes.
      To implement different behavior, recode this method for your class that derives ultimately from AppWindow. Polymorphism ensures that the event is dispatched to your ReportNotification() handler, rather than AppWindow's.
    </remarks>
    <example>
      This example optionally reacts to a report server closing event and ignores other events:
      <code language="X#">
        METHOD ReportNotification(oRQ) CLASS AppWindow
        LOCAL oTB
        LOCAL Reply
        IF (oRQ:EventType == REPORTSERVERCLOSEEVENT)
        oTB := TextBox{SELF,"You closed";
        + oRQ:ReportServer,;
        "Should pending reports be attempted?"}
        oTB:TYPE := BUTTONYESNO + ;
        BOXICONQUESTIONMARK
        Reply := oTB:Show()
        oTB:Axit()
        IF (Reply == BOXREPLYNO)
        RETURN FALSE
        ENDIF     // Reply was BOXREPLYYES
        ENDIF
        RETURN TRUE   // De-queue any pending
        // commands which can cause
        // restart prompt
      </code>
    </example>
  </AppWindow.ReportNotification>
  <AppWindow.Show>
    <summary>
      Display a window.
    </summary>
    <returns>NIL</returns>
    <param name="nShowState">The state in which the window area should be displayed.</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>SHOWICONIZED</term>
          <description>Shows the window initially as an icon. The user must click on the icon to begin to operate the window</description>
        </item>
        <item>
          <term>SHOWNORMAL</term>
          <description>
            Shows the window on its owner, in a size chosen by the owner.
            If the owner is the desktop, the window appears quite large, but not filling the whole desktop.
            You can control the window's size precisely, if you wish, by assigning to its Size and Origin variables.
            The user can always re-size the window to their own requirements. This is the <b>default</b>.
          </description>
        </item>
        <item>
          <term>SHOWZOOMED</term>
          <description>Shows the window at the maximum size allowed by its owner. If the owner is the desktop, the window occupies the whole desktop.</description>
        </item>
      </list>
    </remarks>
  </AppWindow.Show>
  <AppWindow.StatusBar>
    <summary>
      The status bar currently associated with an application window.
      If none is associated, the status bar of the owner window is returned. If there is no status bar in the ownership hierarchy, NIL is returned.
    </summary>
    <value>
      The status bar currently associated with an application window.
      If none is associated, the status bar of the owner window is returned. If there is no status bar in the ownership hierarchy, NIL is returned.
    </value>
  </AppWindow.StatusBar>
  <AppWindow.StatusMessage>
    <summary>
      Display a message in an application window's status bar.
    </summary>
    <returns>NIL</returns>
    <param name="oHL">The hyperlabel containing a description (HyperLabel:Description) for the status message or the status message as a string.</param>
    <param name="nType">
      The constant value indicating the type and priority of the message to be displayed on the status bar.
      The highest priority message (MESSAGEMENU) always takes precedence over and replaces lower priority messages. See table in the remarks section for more info.
    </param>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>MESSAGEMENU</term>
          <description>Priority 4 (Highest priority): A message associated with a menu selection.</description>
        </item>
        <item>
          <term>MESSAGEERROR</term>
          <description>Priority 3: An error message.</description>
        </item>
        <item>
          <term>MESSAGECONTROL</term>
          <description>Priority 2: A message associated with a control.</description>
        </item>
        <item>
          <term>MESSAGEPERMANENT</term>
          <description>
            Priority 1 (Lowest priority): The default message displayed on the status bar; stored whenever a higher
            priority message takes precedence and redisplayed when no other messages take priority. This is the <b>default</b>.
          </description>
        </item>
      </list>
    </remarks>
  </AppWindow.StatusMessage>
  <AppWindow.SystemMenu>
    <exclude />
  </AppWindow.SystemMenu>
  <AppWindow.ToolBar>
    <summary>
      The toolbar that corresponds to the application window. (If a value of NIL is returned, there was no previously selected toolbar.)
    </summary>
    <value>The toolbar that corresponds to the application window. (If a value of NIL is returned, there was no previously selected toolbar.)</value>
  </AppWindow.ToolBar>
  <AppWindow.WarningMessage>
    <summary>
      Display a message in an warning box.
    </summary>
    <param name="aPlace1">The hyperlabel containing the caption and description (HyperLabel:Caption and HyperLabel:Description) for the warning box, or the caption to be displayed in the warning box.</param>
    <param name="aPlace2">The description to be displayed in the warning box.</param>
    <returns>The return value of the WarningBox:Show() call</returns>
  </AppWindow.WarningMessage>
  <ASPAppAbstract>
    <summary>
      Define the common protocol for OLE server applications.
      This in an abstract class and should not be used directly—instead, use one of its subclasses.
    </summary>
    <remarks>
      This abstract class defines the common protocol—properties and behavior—used by the various X# HTTP server applications.
    </remarks>
  </ASPAppAbstract>
  <ASPAppAbstract.Exec>
    <summary>
      Start the event handling loop for the non-GUI application.
    </summary>
    <remarks>
      Normally, the event handling loop for the application continues looping until there are no more EventContext objects. It can also terminate upon calling ASPAppAbstract:Quit().
    </remarks>
    <example>
      The following code shows the framework for an out-of-process ASP component application:
      <code language="X#">
        CLASS ASPComponent INHERIT IScriptingContext
        GLOBAL oLogFile AS LogFile
        FUNC Start()
        LOCAL oServer AS ASPComponent
        LOCAL oAspApp AS AspApp
        #IFDEF __DEBUG__
        oLogFile := LogFile{}
        oLogFile:DebugMsg("ASP Component started ...")
        #ENDIF
        oAspApp := ASPApp{}
        oServer := ASPComponent{}
        oServer:ASPApp := oAspApp
        oAspApp:Exec()
      </code>
    </example>
  </ASPAppAbstract.Exec>
  <ASPAppAbstract.Quit>
    <summary>
      Terminate a non-GUI application by instructing the application to close itself.
    </summary>
    <remarks>
      This method is normally invoked when an Exit menu command is selected.
    </remarks>
  </ASPAppAbstract.Quit>
  <AutoServer>
    <summary>
      Base class for implementing an OLE automation server.
    </summary>
    <remarks>
      The AutoServer class can be used as the base class for implementing OLE automation servers. You can use any X# class as the automation interface; however, if you decide to let your automation server inherit from AutoServer, you do not have to perform the registration calls, RegisterOLEAutomationObject() and UnregisterOLEAutomationObject().
      For further details, see Creating OLE Servers in X# in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
    </remarks>
  </AutoServer>
  <AutoServer.ctor>
    <summary>
      Instantiate a new AutoServer object.
    </summary>
    <param name="oOwnerWnd">The owner of the automation server.</param>
    <param name="sProgramID">The program ID of the automation server. The program ID is a string that uniquely identifies the automation server.</param>
    <param name="iResID">The resource ID of the automation server's type library. The default is 1.</param>
    <param name="lASP">
      A flag specifying if the automation server is to be used as an ASP component. The default is TRUE, if <paramref name="oOwnerWnd" /> is a descendant of the ASPAppAbstract class; otherwise, FALSE.
    </param>
    <remarks>
      The Init() method instantiates a new automation Server object.
      <note type="tip">When creating OLE automation server applications in the IDE, you have to set the application properties on the OLE Server tab page in the Application Options dialog box to match the ProgID and class of your automation server.</note>
    </remarks>
  </AutoServer.ctor>
  <AutoServer.CloseServer>
    <summary>
      Close the server application.
    </summary>
    <remarks>
      If a X# class representing an Automation Server implements a CloseServer() method, this method is called whenever the reference count of the server reaches 0, i.e., when the last client closes the connection to the server. The default implementation in the AutoServer class is to terminate the server application.
    </remarks>
  </AutoServer.CloseServer>
  <AutoServer.Destroy>
    <summary>
      Provide a method to de-instantiate an AutoServer object.
    </summary>
    <remarks>
      This method can be used when an AutoServer object is no longer needed.
    </remarks>
  </AutoServer.Destroy>
  <AutoServer.HelpAbout>
    <summary>
      Displays a "help about" message box.
    </summary>
    <remarks>
      An automation server usually offers a HelpAbout() method. In this base class, the HelpAbout() method displays a simple message box. In derived classes, however, you will probably want to override the method for specialized automation servers.
    </remarks>
  </AutoServer.HelpAbout>
  <AutoServer.Owner>
    <summary>
      The owner—window, control, or application—of the automation server.
    </summary>
    <value>The owner—window, control, or application—of the automation server.</value>
  </AutoServer.Owner>
  <BaseListBox>
    <summary>
      Provide the base class from which all X# list boxes are subclassed.
    </summary>
    <remarks>
      List boxes display a list of strings (or items) to the user. You can use the methods of BaseListBox to add, arrange, remove, and interrogate the items in a list box. You can also specify how the items in a list box should be sorted.
      When an item in a list box is single- or double-clicked, the event handlers Window:ListBoxClick() and Window:ListBoxSelect() are triggered in the list box's owner window, respectively.
    </remarks>
  </BaseListBox>
  <BaseListBox.ctor>
    <summary>
      Construct a list box.
    </summary>
    <param name="oOwner">The window that owns the list box.</param>
    <param name="xID">The unique ID of the list box (between 1 and 8000).</param>
    <param name="oPoint">The origin of the list box in canvas coordinates.</param>
    <param name="oDimension">The dimension of the list box in canvas coordinates.</param>
    <param name="kStyle">The style of the list box, specified as one of the following constants:</param>
    <param name="lDataAware">A logical value specifying whether the list box is data aware.</param>
    <param name="nResourceID">The resource ID of the list box.</param>
    <remarks>
      <include file="Gui.xml" path="doc/LBStyles/*" />
    </remarks>
  </BaseListBox.ctor>
  <BaseListBox.AddItem>
    <summary>
      Add a new item to a list box at a specified position.
    </summary>
    <param name="cItem">The item to be inserted.</param>
    <param name="uItem">The item to be inserted.</param>
    <param name="nItemNumber">The position in the list box at which to insert the new item. Specify one of the following values:</param>
    <param name="uIndex">The position in the list box at which to insert the new item. Specify one of the following values:</param>
    <param name="Value">Position</param>
    <param name="uValue">Position</param>
    <param name="0">In an unsorted list box, adds the new item at the end of the list; if sorted, inserts the new item at a position determined by the list box. This is the default.</param>
    <param name="1">The first position in the list box.</param>
    <param name="n">The nth position in the list box.</param>
    <returns>
      If the item was added, its position in the list box is returned (a value of 1 refers to the first position in the list box). If the item could not be added, 0 is returned.
    </returns>
  </BaseListBox.AddItem>
  <BaseListBox.Clear>
    <summary>
      Clear a list box of all items.
    </summary>
  </BaseListBox.Clear>
  <BaseListBox.CurrentItem>
    <inheritdoc />
  </BaseListBox.CurrentItem>
  <BaseListBox.CurrentItemNo>
    <inheritdoc />
  </BaseListBox.CurrentItemNo>
  <BaseListBox.CurrentText>
    <inheritdoc />
  </BaseListBox.CurrentText>
  <BaseListBox.DeleteItem>
    <summary>
      Remove an item from a list box.
    </summary>
    <param name="nItemNumber">The number of the item to be deleted. Specify one of the following values:</param>
    <param name="Value">Position</param>
    <param name="0">The currently selected item. This is the default.</param>
    <param name="1">The first item.</param>
    <param name="n">The nth item.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </BaseListBox.DeleteItem>
  <BaseListBox.Destroy>
    <summary>
      Provide a method to de-instantiate a BaseListBox object.
    </summary>
    <remarks>
      This method can be used when a BaseListBox object is no longer needed. BaseListBox:Destroy() de-instantiates the BaseListBox object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
    <returns>
      NIL
    </returns>
  </BaseListBox.Destroy>
  <BaseListBox.FindItem>
    <summary>
      Search a list box for a specified string, and return the location of the first item in the list box that matches it.
    </summary>
    <param name="cItem">The text to search for.</param>
    <param name="lWholeItem">
      Indicates how the search is to be performed. TRUE matches an exact <paramref name="cItem" /> string to a 'whole' list box item (for example, a 'can' string does not match 'scan'). FALSE finds a match for any list box prefixed by <paramref name="cItem" /> (for example, the string 'cat' would match 'catalog' in the list box). The default is TRUE.
    </param>
    <param name="nStart">Specifies the one-based index of the item before the first item to be searched. When the search reaches the bottom of the list box, it continues searching from the top of the list box back to the item specified by the nStart parameter. If nStart is 0, the entire list box is searched from the beginning. </param>
    <returns>
      The position of the first item that contains the matching text, if a match is found (a value of 1 refers to the first position in the list box); if no match is found, 0 is returned.
      For example, if <paramref name="cItem" /> matched the fifth string in the list box, the return value would be 5. This means that no earlier string in the list box matched it.
    </returns>
  </BaseListBox.FindItem>
  <BaseListBox.GetItem>
    <summary>
      Retrieve the text of a specified list box item.
    </summary>
    <param name="nItemNumber">
      The number of the desired item. Specify one of the following values:
      <list type="table">
        <listheader>
          <term>Value</term>
          <description>Position</description>
        </listheader>
        <item>
          <term>0</term>
          <description>The currently selected item.</description>
        </item>
        <item>
          <term>1</term>
          <description>The first item.</description>
        </item>
        <item>
          <term>n</term>
          <description> The nth item.</description>
        </item>
      </list>
    </param>
    <param name="nLength">Optional numeric value that indicates how long the returned string should be.</param>
    <returns>
      The text of the specified item.
    </returns>
  </BaseListBox.GetItem>
  <BaseListBox.ItemCount>
    <summary>
      A numeric value representing the number of items in the list box.
    </summary>
    <value>A numeric value representing the number of items in the list box.</value>
  </BaseListBox.ItemCount>
  <BaseListBox.SetTop>
    <summary>
      Move a specified item to the top of the list box.
    </summary>
    <param name="nItemNumber">The number of the item to be moved. Specify one of the following values:</param>
    <param name="Value">Position</param>
    <param name="0">The currently selected item.</param>
    <param name="1">The first item.</param>
    <param name="n">The nth item.</param>
  </BaseListBox.SetTop>
  <Bitmap>
    <summary>
      Create a bitmap, which is a bit pattern entity—that is, a two-dimensional array of pixels, each pixel having color attributes (monochrome or color).
    </summary>
    <remarks>
      In X#, bitmaps are created from resource entities, and can be used to create brushes and icons.
    </remarks>
  </Bitmap>
  <Bitmap.ctor>
    <summary>
      Load a bitmap from the resource entity.
    </summary>
    <param name="xResourceID">The ResourceID object of the bitmap or the numeric resource ID of the bitmap.</param>
    <param name="kLoadOption">The optional constant representing the load option. The default is LR_DEFAULTCOLOR.</param>
    <param name="iWidth">The optional width of the bitmap. The default is the width of the bitmap.</param>
    <param name="iHeight">The optional height of the bitmap. The default is the height of the bitmap.</param>
  </Bitmap.ctor>
  <Bitmap.Destroy>
    <summary>
      Provide a method to de-instantiate a Bitmap object.
    </summary>
    <remarks>
      This method can be used when a Bitmap object is no longer needed. Bitmap:Destroy() de-instantiates the Bitmap object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
    <returns>
      NIL
    </returns>
  </Bitmap.Destroy>
  <Bitmap.Handle>
    <summary>
      Return the handle for a bitmap.
    </summary>
    <param name="nHandleType">
      The type of handle required. 0 is the only supported option and is the default if <paramref name="nHandle" /> is omitted.
    </param>
    <returns>
      A handle describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
    </remarks>
  </Bitmap.Handle>
  <Bitmap.Size>
    <summary>
      A Dimension object representing the size of the bitmap.
    </summary>
    <value>A Dimension object representing the size of the bitmap.</value>
  </Bitmap.Size>
  <BitmapObject>
    <summary>
      Create a Bitmap object; this type of entity is part of the DrawObject hierarchy, which provides a means of displaying and manipulating various objects.
    </summary>
  </BitmapObject>
  <BitmapObject.ctor>
    <summary>
      Construct a BitmapObject object.
    </summary>
    <param name="oPoint">The origin of the BitmapObject object, in canvas coordinates.</param>
    <param name="oDimension">The dimension of the BitmapObject object, in canvas coordinates.</param>
    <param name="oBitmap">The bitmap to be used.</param>
  </BitmapObject.ctor>
  <BitmapObject.BoundingBox>
    <summary>
      A bounding box representing the smallest rectangle that completely encloses the BitmapObject object.
    </summary>
    <value>A bounding box representing the smallest rectangle that completely encloses the BitmapObject object.</value>
  </BitmapObject.BoundingBox>
  <BitmapObject.Draw>
    <summary>
      Draw the BitmapObject object on the window.
    </summary>
  </BitmapObject.Draw>
  <BitmapObject.Size>
    <summary>
      A Dimension object representing the size of a BitmapObject object.
    </summary>
    <value>A Dimension object representing the size of a BitmapObject object.</value>
  </BitmapObject.Size>
  <BoundingBox>
    <summary>
      Create a bounding box, which is a set of four numbers that represent the bottom-left and top-right corners of a rectangle.
    </summary>
    <example>
      The following returns the smallest rectangle that encloses an EllipseObject object, in canvas coordinates:
      <code language="X#">LOCAL oBB := oEllipse:BoundingBox()</code>
    </example>
    <remarks>
      Typically, the rectangle is the smallest one that encloses both the overall size and position of another object (for example, a drawing or an area of a window that needs repainting).
      <note type="tip">A bounding box has no graphical representation—it is just four numbers encapsulated in a class.</note>
    </remarks>
  </BoundingBox>
  <BoundingBox.ctor>
    <summary>
      Construct a bounding box.
    </summary>
    <param name="oPoint">The origin of the bounding box, in canvas coordinates.</param>
    <param name="xPoint">
      The dimension of the bounding box. This may be a <see cref="T:VO.Dimension">Dimension object</see>or a <see cref="T:VO.Dimension">Point object</see>.
    </param>
  </BoundingBox.ctor>
  <BoundingBox.Bottom>
    <summary>
      A numeric value representing the Y coordinate of the bottom side of a bounding box, in canvas coordinates.
    </summary>
    <value>A numeric value representing the Y coordinate of the bottom side of a bounding box, in canvas coordinates.</value>
  </BoundingBox.Bottom>
  <BoundingBox.ConvertToScreen>
    <summary>
      Convert a bounding box to screen coordinates for a given window.
    </summary>
    <param name="oWindow">
      The <see cref="T:VO.Window">window object</see>to use for the conversion.
    </param>
    <returns>
      TRUE.
    </returns>
  </BoundingBox.ConvertToScreen>
  <BoundingBox.Extent>
    <exclude />
  </BoundingBox.Extent>
  <BoundingBox.Height>
    <summary>
      A numeric value representing the height of the bounding box, measured in canvas coordinates.
    </summary>
    <value>A numeric value representing the height of the bounding box, measured in canvas coordinates.</value>
  </BoundingBox.Height>
  <BoundingBox.Left>
    <summary>
      A numeric value representing the X coordinate of the left side of a bounding box, in canvas coordinates.
    </summary>
    <value>A numeric value representing the X coordinate of the left side of a bounding box, in canvas coordinates.</value>
  </BoundingBox.Left>
  <BoundingBox.Origin>
    <summary>
      A point representing the location of a bounding box, in canvas coordinates.
    </summary>
    <value>A point representing the location of a bounding box, in canvas coordinates.</value>
  </BoundingBox.Origin>
  <BoundingBox.PointInside>
    <summary>
      Test whether a given point is within the bounds of a bounding box.
    </summary>
    <param name="oPoint">The point to be tested.</param>
    <returns>
      TRUE if the point is in the bounding box; otherwise, FALSE.
    </returns>
  </BoundingBox.PointInside>
  <BoundingBox.Right>
    <summary>
      A numeric value representing the X coordinate of the right side of a bounding box, in canvas coordinates.
    </summary>
    <value>A numeric value representing the X coordinate of the right side of a bounding box, in canvas coordinates.</value>
  </BoundingBox.Right>
  <BoundingBox.Size>
    <exclude />
  </BoundingBox.Size>
  <BoundingBox.Top>
    <summary>
      A numeric value representing the Y coordinate of the top side of a bounding box, in canvas coordinates.
    </summary>
    <value>A numeric value representing the Y coordinate of the top side of a bounding box, in canvas coordinates.</value>
  </BoundingBox.Top>
  <BoundingBox.Union_>
    <summary>
      Return a new bounding box that represents the minimum area required to contain both this bounding box and the bounding box specified by <paramref name="oBoundingBox" />.
    </summary>
    <param name="oBB">The bounding box to be joined with this bounding box.</param>
  </BoundingBox.Union_>
  <BoundingBox.Width>
    <summary>
      A numeric value representing the width of the bounding box, in canvas coordinates.
    </summary>
    <value>A numeric value representing the width of the bounding box, in canvas coordinates.</value>
  </BoundingBox.Width>
  <Brush>
    <summary>
      Create a brush, which can be used by the Window:PaintBoundingBox() method and the DrawObject hierarchy.
    </summary>
    <remarks>
      You can create a brush by specifying a color and pattern combination. (The specified pattern can either be one of the default, predefined patterns or a user-supplied bitmap.)
    </remarks>
    <example>
      This example changes the background of the window to white and paints a yellow, cross-hatched rectangle:
      <code language="X#">
        oWindow:Background := Brush{BRUSHWHITE}
        oBYellow := Brush{Color{COLORYELLOW},HATCHORTHOGONALCROSS}
        oBPrevious := oWindow:Foreground
        oWindow:Foreground := oBYellow
        oWindow:PaintBoundingBox(Point{0,0}, Dimension{100,100})
        oWindow:Foreground := oBPrevious
      </code>
    </example>
  </Brush>
  <Brush.ctor>
    <summary>
      Construct a brush.
    </summary>
    <param name="oParent">** missing parameter documentation **</param>
    <param name="xColor">
      The new brush's color object. (Refer to the Color:Init() method for details on specifying a color object.) or
      the standard brush to create, specified as one of constants below.
    </param>
    <param name="kHatchStyle">The new brush's pattern (also called a hatching style or meshed line pattern). Specify one of the constants below.</param>
    <remarks>
      xColor constants
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>BRUSHBLACK</term>
          <description>Black</description>
        </item>
        <item>
          <term>BRUSHCLEAR</term>
          <description>Clear (transparent)</description>
        </item>
        <item>
          <term>BRUSHDARK</term>
          <description>Dark gray</description>
        </item>
        <item>
          <term>BRUSHHOLLOW</term>
          <description>Clear (transparent)</description>
        </item>
        <item>
          <term>BRUSHLIGHT</term>
          <description>Light gray</description>
        </item>
        <item>
          <term>BRUSHMEDIUM</term>
          <description>Gray</description>
        </item>
        <item>
          <term>BRUSHWHITE</term>
          <description>White</description>
        </item>
      </list>
      kHatchStyle constants:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>0</term>
          <description>Prepares a brush.</description>
        </item>
        <item>
          <term>HATCHDIAGONAL135</term>
          <description>A pattern of 135-degree angle parallel lines.</description>
        </item>
        <item>
          <term>HATCHDIAGONAL45</term>
          <description>A pattern of 45-degree angle parallel lines.</description>
        </item>
        <item>
          <term>HATCHDIAGONALCROSS</term>
          <description>A combination of HATCHDIAGONAL45 and HATCHDIAGONAL135.</description>
        </item>
        <item>
          <term>HATCHHORIZONTAL</term>
          <description>A pattern of horizontal parallel lines.</description>
        </item>
        <item>
          <term>HATCHORTHOGONALCROSS</term>
          <description>A combination of HATCHHORIZONTAL and HATCHVERTICAL.</description>
        </item>
        <item>
          <term>HATCHSOLID</term>
          <description>A solid blocking pattern. This is the default.</description>
        </item>
        <item>
          <term>HATCHVERTICAL</term>
          <description>A pattern of vertical parallel lines.</description>
        </item>
      </list>
    </remarks>
  </Brush.ctor>
  <Brush.CreateNew>
    <exclude />
  </Brush.CreateNew>
  <Brush.Destroy>
    <summary>
      Provide a method to de-instantiate a Brush object.
    </summary>
    <remarks>
      This method can be used when a Brush object is no longer needed. Brush:Destroy() de-instantiates the Brush object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </Brush.Destroy>
  <Brush.Handle>
    <summary>
      Return the handle for a brush.
    </summary>
    <param name="nHandleType">
      The type of handle required. 0 is the only supported option and is the default if <paramref name="nHandle" /> is omitted.
    </param>
    <returns>
      A handle describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
    </remarks>
  </Brush.Handle>
  <Button>
    <summary>
      Provide the base class from which all X# buttons are subclassed.
    </summary>
    <remarks>
      You can also use the ControlWindow class to create buttons with behaviors and/or appearances that differ from standard buttons. Using ControlWindow permits controls to trap events. Typical uses might include customizing the appearance of controls (like changing the background and foreground colors) or modifying the key handling.
    </remarks>
  </Button>
  <Button.ctor>
    <summary>
      Construct a button.
    </summary>
    <param name="oOwner">The window that owns the button.</param>
    <param name="xID">The unique ID of the button (between 1 and 8000).</param>
    <param name="oPoint">The origin of the button in canvas coordinates.</param>
    <param name="oDimension">The dimension of the button in canvas coordinates.</param>
    <param name="cText">The informational text to be printed in the button. By default, it is a NULL_STRING.</param>
    <param name="kStyle">
      The style of the button, specified by a Windows API style constant.
      <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular Windows API style constant.</note>
    </param>
    <param name="lDataAware">A logical value specifying whether the button is data aware. If omitted, defaults to FALSE.</param>
    <param name="nResourceID">The resource ID of the button.</param>
  </Button.ctor>
  <Button.AsString>
    <summary>
      Return an identifying label for the button.
    </summary>
    <remarks>
      Button:AsString() presents the button control as a recognizable string of the form &lt;ClassName&gt; - &lt;Caption&gt;.
    </remarks>
  </Button.AsString>
  <Button.Caption>
    <summary>
      A string representing the text that is displayed adjacent to a check box or radio button, or on top of a push button. The Button:Caption assign also changes Button:CurrentText for the button.
    </summary>
    <value>A string representing the text that is displayed adjacent to a check box or radio button, or on top of a push button. The Button:Caption assign also changes Button:CurrentText for the button.</value>
  </Button.Caption>
  <Button.CurrentText>
    <summary>
      For check boxes, push buttons, and radio buttons, Button:CurrentText contains NULL_STRING.
    </summary>
    <value>For check boxes, push buttons, and radio buttons, Button:CurrentText contains NULL_STRING.</value>
  </Button.CurrentText>
  <Button.Image>
    <summary>
      An image object representing the icon or bitmap image that is displayed on a button.
    </summary>
    <value>An image object representing the icon or bitmap image that is displayed on a button.</value>
  </Button.Image>
  <Button.ImageList>
    <exclude />
  </Button.ImageList>
  <Button.Modified>
    <summary>
      A logical value that is set to TRUE when the user clicks on a button, and reset to FALSE when the mouse button is released.
    </summary>
    <value>A logical value that is set to TRUE when the user clicks on a button, and reset to FALSE when the mouse button is released.</value>
  </Button.Modified>
  <ButtonImageList>
    <summary>
      Create an image list for use with buttons.
    </summary>
    <remarks>
      Images used on buttons are automatically put into a ButtonImageList as part of the WinXP support.
    </remarks>
  </ButtonImageList>
  <ButtonImageList.ctor>
    <summary>
      Constructs an image list object that is used by the button class for WinXP support.
    </summary>
    <param name="oImage">The image object to be put into the image list.</param>
  </ButtonImageList.ctor>
  <ButtonImageList.Image>
    <summary>
      The current image object in the ButtonImageList.
    </summary>
    <value>The current image object in the ButtonImageList.</value>
  </ButtonImageList.Image>
  <CheckBox>
    <summary>
      Create check boxes, which are controls that can be toggled on or off by a user (or for 3-state check boxes, to a third state).
    </summary>
    <remarks>
      A check box allows the user to choose between 2 or 3 states.
      A 2-state check box allows a choice between a checked (ON) and unchecked (OFF) state.
      The choice is reflected in CheckBox:Value access, which may be TRUE or FALSE.
      A 3-state check box adds a third (UNDETERMINED) state, in which the box is dimmed.
      The third state is indicated by CheckBox:Value being TRUE and by CheckBox:ValueChanged (which is normally TRUE) being FALSE.
      A check box may be bound to a logical field in a server.
      Because of this, you can not directly bind a 3-state check box to a server; instead you must create a
      numeric or character field to store the 3-state information, and update it based on the status of
      the CheckBox:Value and CheckBox:ValueChanged accesses.

      The Window:ButtonClick() event handler responds to events in the check box. The default behavior of the event handler is to toggle the state of the check box. Typically, you would implement your own ButtonClick() event handler in which you first call the default handler to set the state of the buttons. For example:
      <code language="X#">
        METHOD ButtonClick(oControlEvent) CLASS MyWind
        SUPER:ButtonClick(oControlEvent)
        // Do something else
      </code>
    </remarks>
    <example>
      This example creates a check box on a dialog window and then checks it:
      <code language="X#">
        CLASS MyDialog INHERIT DialogWindow
        HIDDEN oCBNew AS OBJECT
        METHOD Init(oWindow,nResourceID) CLASS MyDialog
        SUPER:Init(oWindow,nResourceID)
        oCBNew := CheckBox{SELF,IDB_CHECKBOX}
        oCBNew:Checked := TRUE
        SELF:Show()
      </code>

      In Windows, check boxes are equivalent to a button with the BS_CHECKBOX style. The style BS_AUTOCHECKBOX is useful because the button is automatically checked and unchecked without any code being written in the system. They are normally specified in the resource entity like this:
      <code language="X#">
        RESOURCE IDD_ABOUT DIALOG 20,20,160,120
        STYLE WS_POPUP | WS_DLGFRAME
        BEGIN
        CHECKBOX "&amp;Color" IDB_COLOR,10,20,40,12
        CHECKBOX "&amp;Filled" IDB_FILLED,10,35,40,12
        CONTROL "&amp;Auto",IDB_AUTO,"button", BS_AUTOCHECKBOX,10,65,40,12
        DEFPUSHBUTTON "OK" IDB_OK,64,80,32,14, WS_GROUP
        END
      </code>
    </example>
  </CheckBox>
  <CheckBox.ctor>
    <summary>
      Construct a check box.
    </summary>
    <param name="oOwner">The window that owns the check box.</param>
    <param name="xID">The unique ID of the check box (between 1 and 8000).</param>
    <param name="oPoint">The origin of the check box in canvas coordinates.</param>
    <param name="oDimension">The dimension of the check box in canvas coordinates.</param>
    <param name="cText">The text to be associated with the check box. If no text is specified, it is inherited from TextControl:TextValue.</param>
    <param name="kStyle">
      Constant representing the style of the check box, specified by a Windows API style constant. The default is BS_AUTOCHECKBOX.
      Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular Windows API style constant.
    </param>
    <param name="nResourceID">The resource ID of the check box.</param>
  </CheckBox.ctor>
  <CheckBox.Checked>
    <summary>
      A logical value representing the current state of a check box. It is TRUE if the box is checked (or for 3-state check boxes, if it is in the third UNDETERMINED state), otherwise it is FALSE.  The CheckBox:Checked assign also changes CheckBox:Value and CheckBox:TextValue. Also, if the CheckBox:Value is changed, CheckBox:ValueChanged is set to TRUE.
    </summary>
    <value>A logical value representing the current state of a check box. It is TRUE if the box is checked (or for 3-state check boxes, if it is in the third UNDETERMINED state), otherwise it is FALSE.  The CheckBox:Checked assign also changes CheckBox:Value and CheckBox:TextValue. Also, if the CheckBox:Value is changed, CheckBox:ValueChanged is set to TRUE.</value>
  </CheckBox.Checked>
  <CheckBox.Destroy>
    <summary>
      Provide a method to de-instantiate a CheckBox object.
    </summary>
    <remarks>
      This method can be used when a CheckBox object is no longer needed. CheckBox:Destroy() de-instantiates the CheckBox object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </CheckBox.Destroy>
  <CheckBox.Image>
    <exclude />
  </CheckBox.Image>
  <CheckBox.TextValue>
    <summary>
      CheckBox:TextValue is initialized to FALSE on data windows, since the control contains no text.
    </summary>
    <value>CheckBox:TextValue is initialized to FALSE on data windows, since the control contains no text.</value>
  </CheckBox.TextValue>
  <CheckBox.Value>
    <summary>
      CheckBox:Value contains TRUE if the check box is in the checked (ON) state or for 3-state check boxes, in the third UNDETERMINED state. It contains FALSE if it is in the unchecked state (OFF).
    </summary>
    <value>CheckBox:Value contains TRUE if the check box is in the checked (ON) state or for 3-state check boxes, in the third UNDETERMINED state. It contains FALSE if it is in the unchecked state (OFF).</value>
  </CheckBox.Value>
  <CheckBox.ValueChanged>
    <summary>
      CheckBox:ValueChanged contains TRUE or FALSE, depending on the state of the check box. For 2-state check boxes, it is always TRUE. If a 3-state check box is in the third UNDETERMINED state, CheckBox:ValueChanged is FALSE.
    </summary>
    <value>CheckBox:ValueChanged contains TRUE or FALSE, depending on the state of the check box. For 2-state check boxes, it is always TRUE. If a 3-state check box is in the third UNDETERMINED state, CheckBox:ValueChanged is FALSE.</value>
  </CheckBox.ValueChanged>
  <ChildAppWindow>
    <summary>
      Create child application windows.
    </summary>
    <remarks>
      A child application window is an application window that "belongs to" another window (its owner). Because a child application window is not independent of the owner window, it is always destroyed, hidden, or iconized when its owner window is destroyed, hidden, or iconized. Also note that child application windows are clipped against the owner window.
      Child application windows do not have a default size and position on their owner window. They must be given an origin and size before they are shown.

      In Windows, a child application window never displays a menu (except for the system menu). However, it can own a menu. If the child window is used as an MDI child under a shell window, its menu is displayed in the shell.
      This is very useful: when different child windows present different types of data, they often need different menus. The system automatically switches the owner shell window's menu according to which child window has focus.
    </remarks>
    <example>
      The following example displays a child window:
      <code language="X#">
        CLASS MyTopAppWindow INHERIT TopAppWindow
        HIDDEN oCAWNew AS OBJECT
        METHOD Init() CLASS MyTopAppWindow
        SUPER:Init()
        oCAWNew := ChildAppWindow{SELF,FALSE}
        SELF:Caption := "Top App Window"
        oCAWNew:Origin := Point{10,10}
        oCAWNew:Size := Dimension{100,60}
        SELF:Show()
        oCAWNew:Caption := "Child App Window"
        oCAWNew:Show()
      </code>
    </example>
  </ChildAppWindow>
  <ChildAppWindow.ctor>
    <summary>
      Construct a child application window.
    </summary>
    <param name="oOwner">The window that owns the child application window.</param>
    <param name="lManaged">
      Indicates how to manage the child application window. If TRUE, the child window is managed by its owner as an MDI client.
      If FALSE (the default), the child window does not take its default style and menu from the MDI shell. In this case, you must explicitly provide code to control its behavior.
    </param>
    <param name="lImpl">** missing parameter documentation **</param>
  </ChildAppWindow.ctor>
  <ChildAppWindow.ContextMenu>
    <summary>
      A menu object representing the local pop-up menu for a window or window control.
    </summary>
    <value>A menu object representing the local pop-up menu for a window or window control.</value>
  </ChildAppWindow.ContextMenu>
  <ChildAppWindow.Default>
    <inheritdoc />
  </ChildAppWindow.Default>
  <ChildAppWindow.Destroy>
    <summary>
      Provide a method to free memory resources allocated for a ChildAppWindow object and its derived objects.
    </summary>
    <remarks>
      This method immediately frees resources for ChildAppWindow objects created explicitly in your application. ChildAppWindow:Destroy() also takes care of resources allocated to derived classes and deallocates them in the necessary order.
    </remarks>
    <returns>
      NIL
    </returns>
  </ChildAppWindow.Destroy>
  <ChildAppWindow.EnableBorder>
    <inheritdoc />
  </ChildAppWindow.EnableBorder>
  <ChildAppWindow.EnableHorizontalScroll>
    <inheritdoc />
  </ChildAppWindow.EnableHorizontalScroll>
  <ChildAppWindow.EnableOleDropTarget>
    <summary>
      Register the window as an OLE drop target.
    </summary>
    <param name="lEnable">A logical value specifying whether to enable (TRUE) or disable (FALSE) the window as a drop target.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      A window that is registered as an OLE drop target using ChildAppWindow:EnableOLEDropTarget() can handle OLE drag and drop events and create new OLE objects in response to such events. In the associated handlers, an OLEDragEvent object is passed as a parameter that can be used to create a new OLE object by calling OLEObject:CreateFromOLEDragEvent().
    </remarks>
    <example>
      The following code enables a data window as a drop target and creates a new OLE object inside its OLEDrop handler. It also checks the name of the OLE object to allow only WordPad documents:
      <code language="X#">
        METHOD EnableOLEDropTarget CLASS DropTargetDataWindow
        SUPER:EnableOLEDropTarget(TRUE)
        METHOD OLEDrop(oOLEDragEvent) CLASS MyChild
        LOCAL oOLE AS OLEObject
        LOCAL lRet AS LOGIC
        IF oOLEDragEvent:ObjectName == "WordPad Document"
        oOLE := OLEObject{SELF}
        oOLE:AllowInPlace := TRUE
        oOLE:AllowResize := TRUE
        IF oOLE:CreateFromOLEDragEvent(oOLEDragEvent)
        oOLE:Origin := oOLEDragEvent:Position
        oOLE:Show()
        oOLE:SetFocus()
        ENDIF
        ENDIF
      </code>
    </example>
  </ChildAppWindow.EnableOleDropTarget>
  <ChildAppWindow.EnableStatusBar>
    <inheritdoc />
  </ChildAppWindow.EnableStatusBar>
  <ChildAppWindow.EnableVerticalScroll>
    <inheritdoc />
  </ChildAppWindow.EnableVerticalScroll>
  <ChildAppWindow.Show>
    <inheritdoc />
  </ChildAppWindow.Show>
  <ChildAppWindow.StatusBar>
    <inheritdoc />
  </ChildAppWindow.StatusBar>
  <ChildAppWindow.ToolBar>
    <inheritdoc />
  </ChildAppWindow.ToolBar>
  <ClipBoard>
    <summary>
      Create an object to refer to the Windows clipboard, which allows the sharing of text and bitmaps between different applications.
    </summary>
    <remarks>
      Unlike DDE, the data transfer is almost always user-initiated, such as when the user of an application selects the Paste menu command.
    </remarks>
  </ClipBoard>
  <Clipboard.ctor>
    <summary>
      Construct a clipboard.
    </summary>
  </Clipboard.ctor>
  <Clipboard.Clear>
    <summary>
      Clear the contents of the clipboard.
    </summary>
    <returns>SELF</returns>
  </Clipboard.Clear>
  <Clipboard.FileCount>
    <summary>
      Used to determine how many files were dropped.
    </summary>
    <value>Used to determine how many files were dropped.</value>
  </Clipboard.FileCount>
  <Clipboard.GetItemSize>
    <summary>
      Retrieve the size of the item in the clipboard, specifying either a string or a bitmap object.
    </summary>
    <param name="kFormat">
      The type of item to retrieve, specified as one of the following constants:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>BITMAPFORMAT</term>
          <description>The item is a bitmap object.</description>
        </item>
        <item>
          <term>STRINGFORMAT</term>
          <description>The item is a string.</description>
        </item>
      </list>
    </param>
  </Clipboard.GetItemSize>
  <Clipboard.Insert>
    <summary>
      Insert text or a bitmap into the clipboard.
    </summary>
    <param name="xType">The text or bitmap to insert in the clipboard.</param>
    <remarks>
      If you insert text, any text already in the clipboard is overwritten. However, text and bitmaps in the clipboard do not share the same space. If you insert a bitmap, no existing text is deleted; if you insert text, no existing bitmap is deleted.
    </remarks>
    <returns>SELF</returns>
  </Clipboard.Insert>
  <Clipboard.InsertRTF>
    <summary>
      Insert an RTF string into the clipboard.
    </summary>
    <param name="cText">The RTF text to insert in the clipboard.</param>
    <remarks>
      Used to insert RTF text into the clipboard, overwriting any previous RTF text that may have been there.
    </remarks>
    <returns>SELF</returns>
  </Clipboard.InsertRTF>
  <Clipboard.RetrieveBitmap>
    <summary>
      Retrieves a Bitmap object from the clipboard.
    </summary>
    <param name="oBitmap">An empty Bitmap object in which the retrieved bitmap is stored.</param>
    <returns>
      TRUE if a Bitmap object is retrieved; otherwise, FALSE.
    </returns>
    <remarks>
      The Clipboard:RetrieveBitmap() method changes the value of the Bitmap object argument that is passed to it.
    </remarks>
  </Clipboard.RetrieveBitmap>
  <Clipboard.RetrieveFiles>
    <summary>
      Retrieves an array of file names.
    </summary>
    <param name="lMustExist">If this is set to TRUE, the file must actually exist to appear in the array.</param>
    <returns>
      An array of file names.
    </returns>
    <remarks>
      The Clipboard:RetrieveFiles() method is used to retrieve an array of file names.
    </remarks>
  </Clipboard.RetrieveFiles>
  <Clipboard.RetrieveRTF>
    <summary>
      Retrieve an RTF string from the clipboard.
    </summary>
    <param name="nStringLength">The length of the RTF text to retrieve from the clipboard. If it is left empty or set to 0, the full text is retrieved.</param>
    <remarks>
      Used to retrieve the RTF text from the clipboard.
    </remarks>
    <returns>
      The RTF string from the clipboard or NULL_STRING, if there is no string in the clipboard.
    </returns>
  </Clipboard.RetrieveRTF>
  <Clipboard.RetrieveString>
    <summary>
      Retrieves a string from the clipboard.
    </summary>
    <param name="nStringLength">
      The length of the string to be retrieved. If <paramref name="nStringLength" /> is zero or not specified, the complete clipboard contents is assumed.
    </param>
    <returns>
      The string from the clipboard or NULL_STRING, if there is no string in the clipboard.
    </returns>
  </Clipboard.RetrieveString>
  <Color>
    <summary>
      Select or create a color, which can be used by a Brush, Pen, or DrawObject object.
    </summary>
    <remarks>
      X# provides eight predefined colors or you can also create a color by specifying a weighted combination of red, green, and blue (RGB) values. (Values can range from 0 (lowest intensity) to 255 (highest intensity).)
    </remarks>
    <example>
      This example darkens a color:
      <code language="X#">
        METHOD Darken(oColor) CLASS MyWindow
        RETURN Color{oColor:Red - 9, oColor:Green - 9, ;
        oColor:Blue - 9}
      </code>
    </example>
  </Color>
  <Color.ctor>
    <summary>
      Construct a color
    </summary>
    <param name="nColor">
      Construct a color using an single number. When the number &lt;= then it is assumed to be be one of the predefined colors, such as ColorRed, ColorMagenta etc.
      Otherwise the color is the RGB number for the color.
    </param>
    <param name="nRed">
      The amount of red to be used to create the color. This can be a value between 0 (lowest intensity) and 255 (highest intensity). The default value is 0.
    </param>
    <param name="nGreen">
      The amount of green to be used to create the color. This can be a value between 0 (lowest intensity) and 255 (highest intensity). The default value is 0.
    </param>
    <param name="nBlue">
      The amount of blue to be used to create the color. This can be a value between 0 (lowest intensity) and 255 (highest intensity). The default value is 0.
    </param>
    <remarks>
      If the first and second argument are both numeric and the second argument is -1, VO will treat the first number as the colorref of the color object.
      In that case the first number indicates the standard color to create, specified as one of the following constants:
      <include file="Gui.xml" path="doc/Colors/*" />
    </remarks>
    <example>
      The following example defines some colors:
      <code language="X#">
        oRed                 := Color{COLORRED}
        oWhite        := Color{ 255, 255, 255}
        oMediumAquamarine  := Color{ 50, 204, 153}
        oBlack        := Color{  0,  0,  0}
        oBlue        := Color{  0,  0, 255}
        oCadetBlue      := Color{ 95, 159, 159}
        oCornflowerBlue   := Color{ 66, 66, 111}
        oDarkSlateBlue    := Color{ 107, 35, 142}
      </code>
    </example>
  </Color.ctor>
  <Color.Blue>
    <summary>
      A numeric value between 0 (lowest intensity) and 255 (highest intensity) representing the amount of blue in a color.
    </summary>
    <value>A numeric value between 0 (lowest intensity) and 255 (highest intensity) representing the amount of blue in a color.</value>
  </Color.Blue>
  <Color.ColorRef>
    <summary>
      A numeric value between 0 and 0xFFFFFF with the combined colors in RGB format.
    </summary>
    <value>A numeric value between 0 and 0xFFFFFF with the combined colors in RGB format.</value>
  </Color.ColorRef>
  <Color.Destroy>
    <summary>
      Provide a method to de-instantiate a Color object.
    </summary>
    <remarks>
      This method can be used when a Color object is no longer needed. Color:Destroy() de-instantiates the Color object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </Color.Destroy>
  <Color.Green>
    <summary>
      A numeric value between 0 (lowest intensity) and 255 (highest intensity) representing the amount of green in a color.
    </summary>
    <value>A numeric value between 0 (lowest intensity) and 255 (highest intensity) representing the amount of green in a color.</value>
  </Color.Green>
  <Color.Red>
    <summary>
      A numeric value between 0 (lowest intensity) and 255 (highest intensity) representing the amount of red in a color.
    </summary>
    <value>A numeric value between 0 (lowest intensity) and 255 (highest intensity) representing the amount of red in a color.</value>
  </Color.Red>
  <ComboBox>
    <summary>
      Create a combo box, which is used when you need to provide the user with both a list of choices and an edit control (to optionally allow them to type in their own choice).
    </summary>
    <remarks>
      A combo box (also known as a combination box) is a control that combines the abilities of an edit control and a list box. There are three types of combo boxes—simple, drop-down, and drop-down list.
      A combo box displays a list of items or choices to the user, as well as allowing text to be entered directly into an edit area. The combo box methods will allow you to add, arrange, remove, and interrogate the list of items.
      When one of the items is selected, ComboBox:CurrentItem, ComboBox:CurrentItemNo, ComboBox:TextValue, and ComboBox:Value are updated. Either a one-dimensional or two-dimensional array is specified in the FillUsing() method, with a row for each of the items available for selection. With a two-dimensional array, the first element is called the display value, and the second element is called the return value. When an item is selected, the ComboBox:TextValue contains the first element (the display value), and ComboBox:Value contains the second element (the return value). When text is directly entered, ComboBox:CurrentItemNo is set to 0 and the new text is stored in ComboBox:TextValue and ComboBox:Value.
      A combo box may be bound to a field (character, date, logical, numeric, or memo) in a server. The field's data value is stored in ComboBox:Value. The combo box compares the data value to the second element values specified in the FillUsing() array, and if a match is found, the first element (the display value) is stored in ComboBox:TextValue. In a "no-match" situation, the combo box shows no item selected, ComboBox:CurrentItem is NULL_STRING, ComboBox:CurrentItemNo is set to 0, and ComboBox:TextValue and ComboBox:Value reflect the field contents. If an item is selected, ComboBox:CurrentItemNo is set to a number between 1 and ComboBox:ItemCount, and the corresponding second element is stored as ComboBox:Value and as the field's data value. If text is directly entered, it will also be stored as the field's data value.

      Use the Window:ListBoxSelect() event handler to respond to selections, and the Window:ListBoxClick() event handler to respond to choices.
      A combo box is primarily a selection device, so there is no special support for the functionality available in the Edit class. However, the contents of the edit component can be changed or obtained using the inherited CurrentText access/assign methods.
      The combo box also generates EditFocusChangeEvents when its edit control loses or receives the focus.
    </remarks>
    <example>
      This example creates a combo box and fills it with a list of animals:
      <code language="X#">
        CLASS MyWindow INHERIT TopAppWindow
        HIDDEN oCB AS OBJECT
        METHOD Init() CLASS MyWindow
        SUPER:Init()
        oCB := ComboBox{SELF,42,Point{10,10},;
        Dimension{100,40},BOXDROPDOWN}
        oCB:AddItem("Pig")
        oCB:AddItem("Cow")
        oCB:AddItem("Horse")
        oCB:Show()
      </code>
      This example creates a combo box with different currencies, showing an explicit representation to the user but using a different representation internally:
      <code language="X#">
        METHOD Init(...) CLASS OrderWindow
        ...
        oCBCurrency := ComboBox{SELF,CBCURRENCY_ID}
        oCBCurrency:FillUsing({;
        {"U.S. Dollars","USD"},;
        {"Can. Dollars","CDN"},;
        {"Mexican Pesos","MEX"},;
        {"Yen","YEN"},;
        {"British Pounds","UK"},;
        {"German Marks","DM"};
        })
        oCBCurrency:Show()
      </code>
      This example creates a combo box that shows the products available in the product table:
      <code language="X#">
        METHOD Init(...) CLASS OrderWindow
        ...
        oCBProducts := ComboBox{SELF,CBPRODUCTS_ID}
        oCBProducts:FillUsing(oDBProducts,#ProdName,#ProdNo)
        oCBProducts:Show()
      </code>
    </example>
  </ComboBox>
  <ComboBox.ctor>
    <summary>
      Construct a combo box.
    </summary>
    <param name="oOwner">The window that owns the combo box.</param>
    <param name="xID">The unique ID of the combo box (between 1 and 8000).</param>
    <param name="oPoint">The origin of the combo box in canvas coordinates.</param>
    <param name="oDimension">The dimension of the combo box in canvas coordinates.</param>
    <param name="kComboType">
      The type of combo box to create, specified as one of the constants that are listed in the remarks section

    </param>
    <param name="kStyle">The style of the combo box, specified as one of the Windows API constants listed below:</param>
    <param name="nResourceID">The resource ID of the combo box.</param>
    <remarks>
      <list>
        <listheader>
          <term>Constant</term>
          <description>Creates</description>
        </listheader>
        <item>
          <term>BOXDROPDOWN</term>
          <description>
            An extended combo box with both an edit control and a drop-down icon beside it. The user can enter/edit text in the edit control, or choose items from the list box. (The list box appears only if the user selects the drop-down icon; if the user then selects the icon again, the list box is hidden.) This is the default.
          </description>
        </item>
        <item>
          <term>BOXDROPDOWNLIST</term>
          <description>
            Same as BOXDROPDOWN, except that the user can only choose items from the list box. Text cannot be entered or edited in the edit control.
          </description>
        </item>
        <item>
          <term>BOXSIMPLE</term>
          <description>
            A extended combo box with both an edit control and a list box that are visible at all times. The user can enter/edit text in the edit control, or choose items from the list box.
          </description>
        </item>
      </list>
      Possible values for kStyle are:
      <include file="Gui.xml" path="doc/CBStyles/*" />
    </remarks>
  </ComboBox.ctor>
  <ComboBox.CurrentItem>
    <summary>
      A string representing the displayed combo box item selected. The ComboBox:CurrentItem access also changes ComboBox:CurrentItemNo, ComboBox:CurrentText, ComboBox:TextValue, and ComboBox:Value, if there is a match with the available display items.
    </summary>
    <value>A string representing the displayed combo box item selected. The ComboBox:CurrentItem access also changes ComboBox:CurrentItemNo, ComboBox:CurrentText, ComboBox:TextValue, and ComboBox:Value, if there is a match with the available display items.</value>
  </ComboBox.CurrentItem>
  <ComboBox.CurrentItemNo>
    <summary>
      A numeric value, between 1 and the ComboBox:ItemCount, indicating which item has most recently had focus. If no item is selected it is 0. The ComboBox:CurrentItemNo assign also changes ComboBox:CurrentItem, ComboBox:TextValue, and ComboBox:Value. If the ComboBox:CurrentItemNo assign represents a change, then ComboBox:ValueChanged will be set to TRUE.
    </summary>
    <value>A numeric value, between 1 and the ComboBox:ItemCount, indicating which item has most recently had focus. If no item is selected it is 0. The ComboBox:CurrentItemNo assign also changes ComboBox:CurrentItem, ComboBox:TextValue, and ComboBox:Value. If the ComboBox:CurrentItemNo assign represents a change, then ComboBox:ValueChanged will be set to TRUE.</value>
  </ComboBox.CurrentItemNo>
  <ComboBox.CurrentText>
    <summary>
      ComboBox:CurrentText contains the text currently appearing in the edit box area of the combo box. The CurrentText assign also changes TextValue and Value. If the assigned CurrentText does not match one of the displayed items, then CurrentItemNo is set to 0. If the assigned value represents a change, then ValueChanged will be set to TRUE.
    </summary>
    <value>ComboBox:CurrentText contains the text currently appearing in the edit box area of the combo box. The CurrentText assign also changes TextValue and Value. If the assigned CurrentText does not match one of the displayed items, then CurrentItemNo is set to 0. If the assigned value represents a change, then ValueChanged will be set to TRUE.</value>
  </ComboBox.CurrentText>
  <ComboBox.Destroy>
    <summary>
      Provide a method to de-instantiate a ComboBox object.
    </summary>
    <remarks>
      This method can be used when a ComboBox object is no longer needed. ComboBox:Destroy() de-instantiates the ComboBox object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </ComboBox.Destroy>
  <ComboBox.EditHandle>
    <summary>
      The handle to the edit portion of a ComboBox control.
    </summary>
    <value>The handle to the edit portion of a ComboBox control.</value>
  </ComboBox.EditHandle>
  <ComboBox.EditHeight>
    <summary>
      Integer value specifying the height of the embedded edit control.
    </summary>
    <value>Integer value specifying the height of the embedded edit control.</value>
  </ComboBox.EditHeight>
  <ComboBox.EnableAutoComplete>
    <exclude />
  </ComboBox.EnableAutoComplete>
  <ComboBox.Font>
    <exclude />
  </ComboBox.Font>
  <ComboBox.Modified>
    <summary>
      A logical value indicating whether an editable combo box is in the process of being modified. While you are typing in new text, or moving the highlighted selection, it is set to TRUE. When the focus shifts away from the combo box, ComboBox:Modified is reset to FALSE.
    </summary>
    <value>A logical value indicating whether an editable combo box is in the process of being modified. While you are typing in new text, or moving the highlighted selection, it is set to TRUE. When the focus shifts away from the combo box, ComboBox:Modified is reset to FALSE.</value>
  </ComboBox.Modified>
  <ComboBox.ReadOnly>
    <exclude />
  </ComboBox.ReadOnly>
  <ComboBox.RemoveEditBalloonTip>
    <exclude />
  </ComboBox.RemoveEditBalloonTip>
  <ComboBox.SetCueBanner>
    <summary>
      Add a cue banner to the Edit portion of the ComboBox control.
    </summary>
    <param name="cTitle">The text displayed as the cue.</param>
    <remarks>
      A cue banner is text displayed in an edit control, usually indicating the purpose of the control or prompting for the type of input required. When the control gets focus or has text in it the cue is no longer displayed.
    </remarks>
  </ComboBox.SetCueBanner>
  <ComboBox.ShowEditBalloonTip>
    <exclude />
  </ComboBox.ShowEditBalloonTip>
  <ComboBox.TextValue>
    <summary>
      A string representing the display value (first array element) for the currently selected item, if any, or any text which has been directly entered. The string is formatted according to the picture clause of the field specification attached to the list box (or combo box). For example the ComboBoxTextValue can be "Jones", "01/15/95", or "8".
      The ComboBoxTextValue assign also changes ComboBox:CurrentItem, ComboBox:CurrentItemNo, ComboBox:Modified, ComboBox:Value, and ComboBox:ValueChanged. If the assign does not match one of the display items, then ComboBox:TextValue and ComboBox:Value are set to the text that could not be matched, and ComboBox:CurrentItemNo is set to 0. If the control is bound to a field in a server and the field data value does not match one of the array's second elements, ComboBox:TextValue and ComboBox:Value contain the field's data value.
    </summary>
    <value>
      A string representing the display value (first array element) for the currently selected item, if any, or any text which has been directly entered. The string is formatted according to the picture clause of the field specification attached to the list box (or combo box). For example the ComboBoxTextValue can be "Jones", "01/15/95", or "8".
      The ComboBoxTextValue assign also changes ComboBox:CurrentItem, ComboBox:CurrentItemNo, ComboBox:Modified, ComboBox:Value, and ComboBox:ValueChanged. If the assign does not match one of the display items, then ComboBox:TextValue and ComboBox:Value are set to the text that could not be matched, and ComboBox:CurrentItemNo is set to 0. If the control is bound to a field in a server and the field data value does not match one of the array's second elements, ComboBox:TextValue and ComboBox:Value contain the field's data value.
    </value>
  </ComboBox.TextValue>
  <ComboBox.Value>
    <summary>
      A string representing the return value (second element in the FillUsing() array) for the currently selected item, if any, or any text which has been directly entered. The string is formatted according to the picture clause of the field specification attached to the list box (or combo box). For example the ComboBox:TextValue can be "Jones", "01/15/95", or "8".
    </summary>
    <value>A string representing the return value (second element in the FillUsing() array) for the currently selected item, if any, or any text which has been directly entered. The string is formatted according to the picture clause of the field specification attached to the list box (or combo box). For example the ComboBox:TextValue can be "Jones", "01/15/95", or "8".</value>
    <remrks>
      <note type="tip">ComboBox:Value may not always be consistent with what the state of the control, as indicated to the end-user. For example, if the data value for the field is not one of the allowed choices for a list box return value, the control will be in a "no-match" situation. In this case the list box will revert to its initial unselected state with CurrentItemNo set to 0.</note>
      If there is no selected item and the combo box is not bound to a field in a server, the ComboBox:Value is set to NIL. If there is a match, the ComboBox:Value assign also changes ComboBox:CurrentItem, ComboBox:CurrentItemNo, ComboBox:TextValue, and ComboBox:ValueChanged. If the assigned text does not match one of the return value choices, ComboBox:CurrentItemNo is set to 0, and TextValue and Value are set to the assigned text. In a list box, the ComboBox:Value is generally one of the return values, unless the control is bound to a field where the actual contents is not one of the allowable choices; in this case, ComboBox:TextValue and ComboBox:Value contain the field's data value.
      The data type for ComboBox:Value is determined by the field specification of the list box; in turn, controls linked to a data server inherit the field specification—and hence data type—from the field of the server. When the control is made data-aware, by setting its name to the name of a field in the server attached to the data window, ComboBox:Value is able to automatically read from and write to this field.

    </remrks>
  </ComboBox.Value>
  <ComboBox.ValueChanged>
    <summary>
      A logical value representing whether the combo box Value has been changed from the previously selected item during the selection process. TRUE indicates that it has been changed from the prior choice, while FALSE indicates it has been not changed from the prior choice. The combo box Value may be changed by clicking on a different item, via the ComboBox:TextValue or ComboBox:Value assigns, or by directly entering text.
    </summary>
    <value>A logical value representing whether the combo box Value has been changed from the previously selected item during the selection process. TRUE indicates that it has been changed from the prior choice, while FALSE indicates it has been not changed from the prior choice. The combo box Value may be changed by clicking on a different item, via the ComboBox:TextValue or ComboBox:Value assigns, or by directly entering text.</value>
  </ComboBox.ValueChanged>
  <ComboBoxEx>
    <summary>
      Encapsulate a ComboBoxEx control.
    </summary>
    <remarks>
      A ComboBoxEx control is a ComboBox control with two extensions.
      Firstly, each item in the list is able to display an image beside it. This is achieved with the use of an ImageList object that is assigned to the control. It is also able to overlay a second image when the item is selected. Both images are specified when the item is added to the control.
      Secondly, unlike the normal ComboBox control, a ComboBoxEx control is not restricted inside of the frame of its owner but, can pass over the frame and into the surrounding area so as to display its list of entries in the drop-down box.
    </remarks>
  </ComboBoxEx>
  <ComboBoxEx.ctor>
    <summary>
      Instantiate a new ComboBoxEx object.
    </summary>
    <param name="oOwner">The window that owns the extended combo box.</param>
    <param name="xID">The unique ID of the extended combo box (between 1 and 8000).</param>
    <param name="oPoint">The origin of the extended combo box in canvas coordinates.</param>
    <param name="oDimension">The dimension of the extended combo box in canvas coordinates.</param>
    <param name="kComboType">
      The type of extended combo box to create, specified as one of the constants in the table in the remarks section.
    </param>
    <param name="kStyle">The style of the extended combo box, specified as one of the API constants in the remarks section</param>
    <param name="nResourceID">The resource ID of the extended combo box.</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Creates</description>
        </listheader>
        <item>
          <term>BOXDROPDOWN</term>
          <description>
            An extended combo box with both an edit control and a drop-down icon beside it. The user can enter/edit text in the edit control, or choose items from the list box. (The list box appears only if the user selects the drop-down icon; if the user then selects the icon again, the list box is hidden.) This is the default.
          </description>
        </item>
        <item>
          <term>BOXDROPDOWNLIST</term>
          <description>
            Same as BOXDROPDOWN, except that the user can only choose items from the list box. Text cannot be entered or edited in the edit control.
          </description>
        </item>
        <item>
          <term>BOXSIMPLE</term>
          <description>
            A extended combo box with both an edit control and a list box that are visible at all times. The user can enter/edit text in the edit control, or choose items from the list box.
          </description>
        </item>
      </list>
      Possible kStyle values are:
      <include file="Gui.xml" path="doc/CBStyles/*" />
      <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular style constant.</note>
    </remarks>
  </ComboBoxEx.ctor>
  <ComboBoxEx.AddItem>
    <summary>
      Add a new item to the ComboBoxEx object.
    </summary>
    <param name="cItem">The item text as string.</param>
    <param name="nItemNumber">The position where to insert the new item. The default placement is at the end of the list (-1). Note that the index into the combo box is zero-based.</param>
    <param name="uRetValue">
      The value associated with the specified item. The default is <paramref name="cItem" />.
    </param>
    <param name="iImageIdx">The index of the image associated with this item.</param>
    <param name="iSelectedIdx">The image index to display when the item is selected.</param>
    <param name="iOverlayIdx">The image index of on overlay image in the image list.</param>
    <param name="iIndent">The indentation level of the item.</param>
    <returns>
      The position of the newly inserted item.
    </returns>
    <remarks>
      This method inserts a new item into the ComboBoxEx control. In addition to the parameters known from the parent classes, ComboBoxEx also expects indexes into the associated image list that specify the image(s) to be displayed together with the item text.
    </remarks>
  </ComboBoxEx.AddItem>
  <ComboBoxEx.DeleteItem>
    <summary>
      Remove an item from the ComboBox object.
    </summary>
    <param name="nItemNumber">The number of the item to be deleted. If omitted, defaults to the current item.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Overrides the DeleteItem() method of its parent class to implement the same behavior for ComboBoxEx objects.
    </remarks>
  </ComboBoxEx.DeleteItem>
  <ComboBoxEx.Dispatch>
    <inheritdoc />
  </ComboBoxEx.Dispatch>
  <ComboBoxEx.EditHandle>
    <exclude />
  </ComboBoxEx.EditHandle>
  <ComboBoxEx.GetExCBStyle>
    <exclude />
  </ComboBoxEx.GetExCBStyle>
  <ComboBoxEx.GetItemAttributes>
    <exclude />
  </ComboBoxEx.GetItemAttributes>
  <ComboBoxEx.ImageList>
    <summary>
      The ImageList object containing the images for the items in the ComboBoxEx object.
    </summary>
    <value>The ImageList object containing the images for the items in the ComboBoxEx object.</value>
  </ComboBoxEx.ImageList>
  <ComboBoxEx.InsertItem>
    <exclude />
  </ComboBoxEx.InsertItem>
  <ComboBoxEx.Length>
    <summary>
      The length of the current text. Overrides the Length property of its parent class to provide the same functionality in this specialized class.
    </summary>
    <value>The length of the current text. Overrides the Length property of its parent class to provide the same functionality in this specialized class.</value>
  </ComboBoxEx.Length>
  <ComboBoxEx.SetExCBStyle>
    <exclude />
  </ComboBoxEx.SetExCBStyle>
  <ComboBoxEx.SetItemAttributes>
    <exclude />
  </ComboBoxEx.SetItemAttributes>
  <ComboBoxExEndEditEvent>
    <summary>
      Provide information about a ComboBoxEx EndEdit event
    </summary>
    <remarks>
      ComboBoxExEndEditEvent events are generated when the user has concluded an operation within the edit box or has selected an item from the control's drop-down list.

    </remarks>
  </ComboBoxExEndEditEvent>
  <ComboBoxExEndEditEvent.ctor>
    <inheritdoc />
  </ComboBoxExEndEditEvent.ctor>
  <ComboBoxExEndEditEvent.IsChanged>
    <exclude />
  </ComboBoxExEndEditEvent.IsChanged>
  <ComboBoxExEndEditEvent.NewSelection>
    <exclude />
  </ComboBoxExEndEditEvent.NewSelection>
  <ComboBoxExEndEditEvent.TextValue>
    <exclude />
  </ComboBoxExEndEditEvent.TextValue>
  <ComboBoxExEndEditEvent.Why>
    <exclude />
  </ComboBoxExEndEditEvent.Why>
  <ComboBoxExItem>
    <summary>
      This class contains all properties of a ComboBoxEx item.
      It is used with the ComboBoxEx methods
      ComboBoxEx:SetItemAttributes()
      ComboBoxEx:GetItemAttributes()
      ComboBoxEx:InsertItem()
    </summary>
  </ComboBoxExItem>
  <ComboBoxExItem.ctor>
    <summary>
      Instantiate a new ComboBoxExItem object.
    </summary>
    <param name="cItem">The item text as string.</param>
    <param name="nItemNumber">The position where to insert the new item. The default placement is at the end of the list (-1). Note that the index into the combo box is zero-based.</param>
    <param name="uRetValue">
      The value associated with the specified item. The default is <paramref name="cItem" />.
    </param>
    <param name="iImageIdx">The index of the image associated with this item.</param>
    <param name="iSelectedIdx">The image index to display when the item is selected.</param>
    <param name="iOverlayIdx">The image index of on overlay image in the image list.</param>
    <param name="iIndent">The indentation level of the item.</param>
  </ComboBoxExItem.ctor>
  <ComboBoxExItem.ImageIndex>
    <exclude />
  </ComboBoxExItem.ImageIndex>
  <ComboBoxExItem.ImageIndex>
    <summary>The index of the image associated with this item.</summary>
    <value>The index of the image associated with this item.</value>
  </ComboBoxExItem.ImageIndex>
  <ComboBoxExItem.Indent>
    <exclude />
  </ComboBoxExItem.Indent>
  <ComboBoxExItem.Indent>
    <summary>The indentation level of the item.</summary>
    <value>The indentation level of the item.</value>
  </ComboBoxExItem.Indent>
  <ComboBoxExItem.ItemIndex>
    <exclude />
  </ComboBoxExItem.ItemIndex>
  <ComboBoxExItem.ItemIndex>
    <summary>The position of the item in the combobox.</summary>
    <value>The position of the item in the combobox.</value>
  </ComboBoxExItem.ItemIndex>
  <ComboBoxExItem.OverlayImageIndex>
    <exclude />
  </ComboBoxExItem.OverlayImageIndex>
  <ComboBoxExItem.OverlayImageIndex>
    <summary>The image index of on overlay image in the image list.</summary>
    <value>The image index of on overlay image in the image list.</value>
  </ComboBoxExItem.OverlayImageIndex>
  <ComboBoxExItem.SelectedImageIndex>
    <exclude />
  </ComboBoxExItem.SelectedImageIndex>
  <ComboBoxExItem.SelectedImageIndex>
    <summary>The image index to display when the item is selected.</summary>
    <value>The image index to display when the item is selected.</value>
  </ComboBoxExItem.SelectedImageIndex>
  <ComboBoxExItem.TextValue>
    <exclude />
  </ComboBoxExItem.TextValue>
  <ComboBoxExItem.TextValue>
    <summary>The item text as string.</summary>
    <value>The item text as string.</value>
  </ComboBoxExItem.TextValue>
  <ComboBoxExItem.Value>
    <exclude />
  </ComboBoxExItem.Value>
  <ComboBoxExItem.Value>
    <summary>The value associated with the specified item.</summary>
    <value>The value associated with the specified item.</value>
  </ComboBoxExItem.Value>
  <Control>
    <summary>
      Provide the base class from which all X# controls are subclassed.
    </summary>
    <remarks>
      Control is the base class for a major system class hierarchy. Controls provide an easy mechanism for user I/O. They are self-contained and notify their respective owners when the user takes some action (such as pressing a button or entering text).
      Controls on dialog windows created from resource entity templates are shown automatically when the dialog window is shown. However, if the application wishes to manipulate a control, it must register the control by creating a system object of the appropriate type.
      Controls must appear in an owner window. They also need to know where to appear. There are two basic ways you can specify where; one is by placing the control using the Window Editor. In this case, X# generates a resource to represent the control. When you construct the control in your program, you pass to the constructor the ID of the resource as its second argument. The other way is to place the controls dynamically, in which case, you pass the position and size of the control as the third and fourth arguments (the first argument is always the owner and the second argument is always the resource ID). Even when you place the control dynamically, you pass in a unique ID as the second argument.
    </remarks>
  </Control>
  <Control.ctor>
    <summary>
      Construct a control.
    </summary>
    <param name="oOwner">The window that owns the control.</param>
    <param name="xID">The unique ID of the control (between 1 and 8000).</param>
    <param name="oPoint">The origin of the control in canvas coordinates.</param>
    <param name="oDimension">The dimension of the control in canvas coordinates.</param>
    <param name="cRegClass">String representing the control class (for example, 'Edit', 'ListBox', etc.)</param>
    <param name="kStyle">
      Constant representing the style of the control, specified either by a X# style constant or a Windows API style constant.
      Styles can be combined using the _Or() operator.
    </param>
    <param name="lDataAware">Logical value indicating whether the control is data-aware (TRUE) or not (FALSE). The default is FALSE.</param>
    <param name="nResourceID">The resource ID of the control.</param>
    <remarks>
      <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular Windows API constant.</note>
      Controls are created in one of two ways: dynamically or from a compiled dialog resource. Dynamic creation, which requires that size and position be specified as instantiation parameters, can be used on any type of window. A compiled dialog resource (which specifies both size and location of the control) can be used only with data windows and dialog windows.
      Additionally, the default state when a control is created depends on the way you placed the control:
      With dynamic creation, the control remains invisible until you invoke Control:Show().
      This allows the program to set up the control correctly (with the correct size, position, and any other parameters), while avoiding the "visual noise" of changing controls.
      With resource-bound instantiation, the control is automatically shown, without requiring a call to Control:Show().
    </remarks>
  </Control.ctor>
  <Control.Activate>
    <summary>
      Provide a method that is invoked when the control has focus and a window is activated.<br /><br />
    </summary>
    <param name="oEvent">The event that describes which window was activated.</param>
    <seealso cref="T:VO.Event" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The Activate() event occurs at the start of the control's lifetime or when the control is activated after it has been deactivated (for example, by clicking on it with the mouse). The newly active control receives the input focus.

      You should create and show cursors (if needed) in this event handler method.
      Any subclass with its own Activate() and Deactivate() event handlers should always call its owner's handlers. This ensures that the caption bars get highlighted or dimmed accordingly.
    </remarks>
  </Control.Activate>
  <Control.AsString>
    <summary>
      Return the contents of the control (or its identifying label).
    </summary>
    <remarks>
      For controls that have values, such as edit controls and check boxes, this method returns the same as Control:TextValue. For controls that do not have values, such as push buttons, it returns the same as Control:Caption. In either case, Control:AsString() presents the control as a recognizable string.
    </remarks>
  </Control.AsString>
  <Control.Background>
    <summary>
      The brush used for painting the background of the control. For example, in a single line edit control, the background is the color behind the text in the edit control.
    </summary>
    <value>The brush used for painting the background of the control. For example, in a single line edit control, the background is the color behind the text in the edit control.</value>
    <note type="tip">This method has no effect if three-dimensional controls have been enabled (via a call to the Enable3DControls() function).</note>
  </Control.Background>
  <Control.Caption>
    <summary>
      A string representing the caption of the control (i.e., the static text identifying the control)
    </summary>
    <value>A string representing the caption of the control (i.e., the static text identifying the control)</value>
    <remarks>
      A string representing the caption of the control (i.e., the static text identifying the control). Examples include the label on the face of a button, the text written next to a check box or radio button, or the text on the border of a radio button group or group box.
      Note that not all controls have a visible caption. For example, the ordinary edit control (MultiLineEdit class) does not have a visible caption—the text commonly displayed next to the edit is actually a separate control, placed there by the Window Editor. Thus, assigning a new value to the caption of this type of control does not change anything on the screen.
    </remarks>
  </Control.Caption>
  <Control.ContextMenu>
    <summary>
      A menu object representing the local pop-up menu for a control.
    </summary>
    <value>A menu object representing the local pop-up menu for a control.</value>
  </Control.ContextMenu>
  <Control.ControlID>
    <summary>
      A number between 1 and 8000 representing the unique ID of a control
    </summary>
    <value>A number between 1 and 8000 representing the unique ID of a control</value>
    <remarks>
      A number between 1 and 8000 representing the unique ID of a control. Every control has its own unique ID to distinguish it from other controls (enabling the owner window to determine which control generated an event).
    </remarks>
  </Control.ControlID>
  <Control.Create>
    <summary>
      Creates the underlying Win32 control
    </summary>
  </Control.Create>
  <Control.DataField>
    <exclude />
  </Control.DataField>
  <Control.Deactivate>
    <summary>
      Provide a method that is invoked when the control has focus and a window is deactivated.<br /><br />
    </summary>
    <param name="oEvent">An empty event required to maintain the protocol that all event handlers have exactly one event as their argument.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This event handler is normally invoked when another application, window or control becomes activated.
    </remarks>
    <seealso cref="T:VO.Event" />
  </Control.Deactivate>
  <Control.Default>
    <summary>Call the default windows procedure for a control and set the EventReturnValue.</summary>
    <param name="oEvent">The event that occurred for the control.</param>
    <returns>Nothing</returns>
    <seealso cref="T:VO.Event" />
  </Control.Default>
  <Control.Destroy>
    <summary>
      Provide a method to de-instantiate any Control object.
    </summary>
    <remarks>
      This method can be used when a Control object is no longer needed. Control:Destroy() de-instantiates the Control object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </Control.Destroy>
  <Control.Disable>
    <summary>
      Disable a control (until a subsequent call to Control:Enable()).
    </summary>
    <remarks>
      Disabled controls are not active (for example, push buttons cannot be clicked and data controls cannot be modified) and, therefore, they do not send events to their owner windows. Note that under Windows, a disabled control is dimmed.
    </remarks>
  </Control.Disable>
  <Control.DisableTheme>
    <summary>
      Disable the WinXP theme for a control.
    </summary>
  </Control.DisableTheme>
  <Control.Dispatch>
    <summary>
      Provide the prototype dispatcher for events within the system when the control has focus; routing various events to their appropriate event handlers.<br /><br />
    </summary>
    <param name="oEvent">The event to be handled.</param>
    <seealso cref="T:VO.Event" />
    <returns>
      A numeric value representing the event handler to handle the event.
    </returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      Controls receive events from the user and the system all of the time. Each control receives only the events that are relevant to it. For each event that is generated, two things happen:
      1.	The event is converted to a particular Event object (an ExposeEvent or a MouseEvent, for example) according to the action that triggered the event.
      2.	The appropriate event handler is called, and this typed Event object is passed to it.
      <note type="tip">
        If you want to set a specific return value for the underlying window procedure, you have to change the EventReturnValue variable for the control object.
        If you want to handle other events (for example, timer events), you need to write your own Dispatch() method.
        The following guidelines should be followed when writing a customized Dispatch() method:
        1.	Subclass an event type appropriate to the type of operation for which it is being used.
        2.	Add an event handler function to your derived object. (This event handler should be called with the event when the event is received.)
        3.	In general, the implementation of this event handler should call Default(). This keeps the same behavior as the base class, but it also allows other classes to provide useful event handlers for your new type of event, allowing you to provide a framework for other classes to use.
        The base class Dispatch() method should be called in those cases where the received event is not handled by the customized dispatcher. For example:
        <code language="X#">
          RETURN SUPER:Dispatch(<paramref name="oEvent" />)
        </code>
      </note>
    </remarks>
  </Control.Dispatch>
  <Control.Drop>
    <exclude />
  </Control.Drop>
  <Control.Enable>
    <summary>
      Enable a control that was previously disabled.
    </summary>
    <remarks>
      Enabling a control allows it to generate events and to send the events to its owner window when the user manipulates the control. The dimming of disabled controls is removed, and the control is restored to its normal appearance.
      By default, controls are enabled until disabled, so there is no need to call this Enable() method unless Control:Disable() was previously called.
    </remarks>
  </Control.Enable>
  <Control.EventReturnValue>
    <exclude />
  </Control.EventReturnValue>
  <Control.Expose>
    <summary>
      Provide a method that is invoked when the control has focus and whenever part of the window needs repainting.<br /><br />
    </summary>
    <param name="oExposeEvent">The ExposeEvent object that describes which control of the window needs repainting.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This is one of the most important event handlers. A control requires repainting when the control:
      <list type="bullet">
        <item>Is partially uncovered by another window</item>
        <item>Is first shown</item>
        <item>Increases in size</item>
        <item>Is being restored after being iconized</item>
        <item>The control should retain enough information to redraw the screen as it was (or as it should be).</item>
      </list>
      An ExposeEvent is also triggered by calling Repaint() or Update(); you should not call Repaint() or Update() during the Expose().
    </remarks>
  </Control.Expose>
  <Control.FieldSpec>
    <summary>
      The field specification connected to the control.
    </summary>
    <value>The field specification connected to the control.</value>
    <remarks>
      From the field specification, you can retrieve additional information about the control—for example:
      <code language="X#">
        cPicture := oControl:FieldSpec:Picture
        IF !oControl:FieldSpec:Validate(x)
        oHLStatus := oControl:FieldSpec:Status
        ENDIF
      </code>
    </remarks>
  </Control.FieldSpec>
  <Control.FocusChange>
    <summary>
      Provide a method that is invoked when the control has focus and the input focus changes from the current control to another (or vice versa).<br /><br />
    </summary>
    <param name="oFocusChangeEvent">The FocusChangeEvent object that identifies whether the focus is being gained or lost.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>

  </Control.FocusChange>
  <Control.GetExStyle>
    <summary>
      Retrieve the Ex styles for the control.
    </summary>
    <returns>
      Numeric value representing the X# style constants or Windows API style constants enabled for the window.
    </returns>
  </Control.GetExStyle>
  <Control.GetStyle>
    <summary>
      Retrieve the styles for the control.
    </summary>
    <returns>
      Numeric value representing the X# style constants or Windows API style constants enabled for the window.
    </returns>
  </Control.GetStyle>
  <Control.Handle>
    <summary>
      Return the handle for a control.
    </summary>
    <param name="uType">
      The type of handle required. Zero (0) is the only supported option, and it is the default if <paramref name="nHandle" /> is omitted.
    </param>
    <returns>
      A handle to the "window" (control), describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the window, which can then be used by Windows API calls.
    </remarks>
  </Control.Handle>
  <Control.HandleAsDword>
    <exclude />
  </Control.HandleAsDword>
  <Control.HasBorder>
    <summary>Check if a border  has been set for the control</summary>
    <returns>TRUE when the border is set. Otherwise FALSE.</returns>
  </Control.HasBorder>
  <Control.HasStyle>
    <summary>Check if a style value has been set for the control</summary>
    <param name="kStyle">The style to check for</param>
    <returns>TRUE when the style is set. Otherwise FALSE.</returns>
  </Control.HasStyle>
  <Control.Hide>
    <summary>
      Hide a control so it is not visible (until a subsequent call to Control:Show()).
    </summary>
  </Control.Hide>
  <Control.HorizontalScroll>
    <summary>
      Provide a method that is invoked when the control has focus and a horizontal scroll bar is scrolled.<br /><br />
    </summary>
    <param name="oScrollEvent">The ScrollEvent object that describes the scroll type and new position.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The default behavior for this event handler is to update the thumb position; this can be changed using your own implementation of the handler. This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects. If the application has vertical scroll bars, use a WindowVerticalScrollBar event handler.
    </remarks>
  </Control.HorizontalScroll>
  <Control.HyperLabel>
    <summary>
      The hyperlabel connected to the control.
    </summary>
    <value>The hyperlabel connected to the control.</value>
    <remarks>
      From the hyperlabel, you can retrieve additional information about the control—for example:
      <code language="X#">
        cCaption := oControl:HyperLabel:Caption
        cDescription := oControl:HyperLabel:Description
        cHelpContext := oControl:HyperLabel:HelpContext
      </code>
    </remarks>
  </Control.HyperLabel>
  <Control.IsDestroyed>
    <exclude />
  </Control.IsDestroyed>
  <Control.IsDisabled>
    <exclude />
  </Control.IsDisabled>
  <Control.IsEditable>
    <exclude />
  </Control.IsEditable>
  <Control.IsEnabled>
    <summary>
      Report if this control is currently enabled.
    </summary>
    <returns>
      TRUE if the control is enabled; otherwise, FALSE.
    </returns>
  </Control.IsEnabled>
  <Control.IsExStyle>
    <summary>Check if a exstyle value has been set for the control</summary>
    <param name="nStyle">The exstyle to check for</param>
    <returns>TRUE when the exstyle is set. Otherwise FALSE.</returns>
  </Control.IsExStyle>
  <Control.IsReadOnly>
    <summary>
      Report if this control is currently readonly.
    </summary>
    <returns>
      TRUE if the control is readonly; otherwise, FALSE.
    </returns>
  </Control.IsReadOnly>
  <Control.IsStyle>
    <summary>Check if a style value has been set for the control</summary>
    <param name="nStyle">The style to check for</param>
    <returns>TRUE when the style is set. Otherwise FALSE.</returns>
  </Control.IsStyle>
  <Control.IsVisible>
    <summary>
      Report if this control is visible (completely or partially) or hidden.
    </summary>
    <returns>
      TRUE if the control is visible; otherwise, FALSE.
    </returns>
    <remarks>
      This style is set in the Windows Editor.
    </remarks>
  </Control.IsVisible>
  <Control.KeyDown>
    <summary>
      Provide a method that is invoked when the control has focus and a key on the keyboard is pressed.<br /><br />
    </summary>
    <param name="oKeyEvent">The KeyEvent object that describes what key was pressed.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This event handler is called only if the control has the input focus.
    </remarks>
  </Control.KeyDown>
  <Control.KeyUp>
    <summary>
      Provide a method that is invoked when the control has focus and a key on the keyboard is released.<br /><br />
    </summary>
    <param name="oKeyEvent">The KeyEvent object that describes what key was released.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This event handler is called only if the control has the input focus.
    </remarks>
  </Control.KeyUp>
  <Control.LinkDF>
    <summary>
      Connect a control to a data field in a data server.
    </summary>
    <param name="oDS">The server that the field is to be linked to. Ordinarily, this is the common server that the entire window is linked to, but it is possible to link individual fields to other servers. </param>
    <param name="siDF">The number of the data field within the server.</param>
    <remarks>
      Control:LinkDF() should ordinarily not be called directly by the application. It is called by the DataWindow:Use() method; Use() connects an entire client to an entire server. You can use Control:LinkDF() to link a control to a data field explicitly, perhaps if the control's name doesn't match the data field's name so the automatic linkage of the Use() method doesn't work.
      It is even possible to use Control:LinkDF() to link individual controls to different servers; however, this is not recommended, because none of the automatic behavior of the data window and none of its cooperation with the data server applies to more than one server. Notifications are not to be received for servers other than the main server that the window is registered with, and actions such as DataWindow:Delete() and DataWindow:Append() apply to the main server. To link a window to more than one database, use the techniques described in the "GUI Classes" chapter of the Programmer's Guide.
    </remarks>
  </Control.LinkDF>
  <Control.MenuInit>
    <summary>
      Provide a method that is invoked when a pop-up menu owned by the control is about to pop up.
    </summary>
    <param name="oMenuInitEvent">The MenuInitEvent object that describes which menu is about to pop up.</param>
  </Control.MenuInit>
  <Control.MenuSelect>
    <summary>
      Provide a method that is invoked when an item on a menu owned by the control is highlighted.
    </summary>
    <param name="oMenuSelectEvent">The MenuSelectEvent object that describes which menu and menu command (via the item's ID) generated the event.</param>
  </Control.MenuSelect>
  <Control.Modified>
    <summary>
      A logical value that is set to TRUE when a standard edit control or editable combo box is in the process of being modified.
    </summary>
    <value>A logical value that is set to TRUE when a standard edit control or editable combo box is in the process of being modified.</value>
    <remarks>
      A logical value that is set to TRUE when a standard edit control or editable combo box is in the process of being modified. When the editing is completed and focus shifts to another control, Control:Modified is reset to FALSE. Control:Modified is initialized to FALSE when the control is created.
    </remarks>
  </Control.Modified>
  <Control.MouseButtonDoubleClick>
    <summary>
      Provide a method that is invoked when the control has focus, the mouse pointer is positioned over the window, and a mouse button is double-clicked.<br /><br />

    </summary>
    <param name="oMouseEvent">The MouseEvent object that contains information about the state of the mouse when the button was double-clicked.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      MouseButtonDoubleClick() often occurs between MouseButtonDown() and MouseButtonUp() event handlers.
    </remarks>
  </Control.MouseButtonDoubleClick>
  <Control.MouseButtonDown>
    <summary>
      Provide a method that is invoked when the control has focus, the mouse pointer is positioned over the window, and a mouse button is clicked.<br /><br />
    </summary>
    <param name="oMouseEvent">The MouseEvent object that contains information about the state of the mouse when the button was clicked.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </Control.MouseButtonDown>
  <Control.MouseButtonUp>
    <summary>
      Provide a method that is invoked when the control has focus, the mouse pointer is positioned over the window, and a mouse button is released.
    </summary>
    <param name="oMouseEvent">The MouseEvent object that contains information about the state of the mouse when the button was released.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      Do not assume Control:MouseButtonUp() is called immediately after Control:MouseButtonDown(). Other MouseEvents can be generated during this time.
      In some cases, there may be no Control:MouseButtonUp() events directed to the window for a corresponding Control:MouseButtonDown(). This can occur if the mouse button is clicked while over the window, but released after the mouse has moved off the window.
    </remarks>
  </Control.MouseButtonUp>
  <Control.MouseDrag>
    <summary>
      Provide a method that is invoked when the control has focus and a mouse with one or more buttons clicked is moved in the window.
    </summary>
    <param name="oMouseEvent">The MouseEvent object containing information on the location and state of the buttons when the mouse was dragged.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </Control.MouseDrag>
  <Control.MouseMove>
    <summary>
      Provide a method that is invoked when the control has focus and the mouse is moved in the control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oMouseEvent">The MouseEvent object containing information on the location of the mouse when it was moved.</param>
    <remarks>
      This event occurs when the mouse is moved with no mouse buttons clicked.
    </remarks>
  </Control.MouseMove>
  <Control.Move>
    <summary>
      Provide a method that is invoked when the control has focus and the control is moved (either by the user or by the application).
    </summary>
    <param name="oMoveEvent">The MoveEvent object that describes the window movement.</param>
  </Control.Move>
  <Control.Name>
    <summary>
      A string representing the name of the control.
    </summary>
    <value>A string representing the name of the control.</value>
    <remarks>
      A string representing the name of the control. Do not confuse the name with the caption: the name is a programmer's ID and is never seen by the user.
      The name is important in steering the built-in processing of the system. For example, the name of a push button is the name of the method that is invoked when the button is clicked, and the name of a control is the database field to which it is linked when a data window is linked to a data server.
    </remarks>
  </Control.Name>
  <Control.NameSym>
    <summary>
      A symbol representing the name of the control.
    </summary>
    <value>A symbol representing the name of the control.</value>
    <remarks>
      A symbol representing the name of the control. Do not confuse the name with the caption: the name is a programmer's ID and is never seen by the user.
      The name is important in steering the built-in processing of the system. For example, the name of a push button is the name of the method that is invoked when the button is clicked, and the name of a control is the database field to which it is linked when a data window is linked to a data server.
    </remarks>
  </Control.NameSym>
  <Control.Origin>
    <summary>
      A point representing the location of a control on its owner window, in canvas coordinates.
    </summary>
    <value>A point representing the location of a control on its owner window, in canvas coordinates.</value>
  </Control.Origin>
  <Control.OverRide>
    <summary>This is a compatibility method that is no longer used or needed.</summary>
    <param name="lEnable"></param>
  </Control.OverRide>
  <Control.Owner>
    <summary>
      The owner window of a control.
    </summary>
    <value>The owner window of a control.</value>
  </Control.Owner>
  <Control.OwnerAlignment>
    <summary>
      Constant representing how the window will be aligned within its owner window.

    </summary>
    <value>Constant representing how the window will be aligned within its owner window.</value>
    <remarks>
      <para>If a value has been set for this property, any resizing of the owner</para>
      <para>window will cause the window to be automatically realigned, resized, and/or moved accordingly.</para>
      <para>
        <b>Note:</b>By default (or by setting OwnerAlignment to <paramref name="Auto" /> in the Window Editor), a control will appear where it was placed by the programmer and
        will not be realigned, resized, and/or moved when its owner window is resized.
      </para>
      <para>There are two assigns that aid owner alignment:</para>
      <list type="bullet">
        <item>
          Control:OwnerAlignment  for controls
        </item>
        <item>
          Window:OwnerAlignment  for windows
        </item>
      </list>
      <para>
        Whenever one of these assigns is called, the current size and position of the control or window is saved to an internal array. The assign can be called as
        often as is required without any difficulty and it will simply over right the old values.
      </para>
      <para>Starting with build 2824 this property can take two different forms:</para>
      <list type="bullet">
        <item>proportional mode</item>
        <item>linear mode</item>
      </list>
      <h2>Proportional OwnerAlignment</h2>
      <para>
        With <b>proportional mode</b> you use the OA_ defines to specify how the position and size of the controls should change
        when the size of the window changes. For example:
      </para>
      <para>
        With linear mode you do not use predefines OA_ defines but you specify the amount of change for each of the 4 properties of a control in code:
      </para>
      <list type="bullet">
        <item>The X position</item>
        <item>The Y position</item>
        <item>The Width</item>
        <item>The Height</item>
      </list>
    </remarks>
  </Control.OwnerAlignment>
  <Control.PerformValidations>
    <summary>
      Perform all the validations defined to this control's field specification (for example, required, maximum and minimum digits, maximum and minimum value, validation rule) and return the result of the test.
    </summary>
    <returns>
      If any of the validations fail, this method sets the status of the control appropriately and returns FALSE. Otherwise, it returns TRUE.
    </returns>
  </Control.PerformValidations>
  <Control.ReadOnly>
    <summary>
      Is the control readonly ?
    </summary>
  </Control.ReadOnly>
  <Control.RegisterTimer>
    <summary>
      Register a timer method to be invoked for the control.
    </summary>
    <param name="nInterval">Time interval, in seconds, between calls to the Timer() method of the control.</param>
    <param name="lOneTime">
      Logical value indicating if the timer is called just once (TRUE), or multiple times (FALSE).
      If omitted, the default is FALSE.
    </param>
  </Control.RegisterTimer>
  <Control.RePaint>
    <summary>
      Send an ExposeEvent to repaint the control
    </summary>
  </Control.RePaint>
  <Control.Resize>
    <summary>
      Provide a method that is invoked when the control has focus and the control changes size.
    </summary>
    <param name="oResizeEvent">The ResizeEvent object that describes the new dimensions of the control.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      In the Control:Resize() event handler, calling Window:Size should be used with caution to avoid entering an infinite loop.
    </remarks>
  </Control.Resize>
  <Control.RestoreUpdate>
    <summary>
      Resume all drawing updates for a control (after Control:SuspendUpdate() is called).
    </summary>
    <remarks>
      This method resumes all drawing updates for a control (after Control:SuspendUpdate() is called).
    </remarks>
  </Control.RestoreUpdate>
  <Control.Server>
    <summary>
      The server object that currently connected to this control. If no server is connected, the value is NIL.
    </summary>
    <value>The server object that currently connected to this control. If no server is connected, the value is NIL.</value>
  </Control.Server>
  <Control.SetExStyle>
    <summary>
      Set the exstyle for the control.
    </summary>
    <param name="kExStyle">The exstyle of the control, specified by a either a X# style constant or a Windows API style constant.</param>
    <param name="lEnable">TRUE enables the specified style; FALSE disables it. If omitted, the default is TRUE.</param>
    <returns>NIL</returns>
  </Control.SetExStyle>
  <Control.SetFocus>
    <summary>
      Pass input focus to a control, thereby directing all mouse and keyboard input to the control.
    </summary>
  </Control.SetFocus>
  <Control.SetParent>
    <summary>
      Change the parent handle for the control.
    </summary>
    <param name="hWndNewParent">The new parent handle for the control.</param>
  </Control.SetParent>
  <Control.SetStyle>
    <summary>
      Set the style for the control.
    </summary>
    <param name="kStyle">The style of the control, specified by a either a X# style constant or a Windows API style constant.</param>
    <param name="lEnable">TRUE enables the specified style; FALSE disables it. If omitted, the default is TRUE.</param>
    <returns>NIL</returns>
  </Control.SetStyle>
  <Control.Show>
    <summary>
      Display a control so it is visible.
    </summary>
    <remarks>
      The default state when a control is created depends on the way you placed the control:
      With dynamic creation, the control remains invisible until you invoke Control:Show().
      This allows the program to set up the control correctly (with the correct size, position,
      and any other parameters), while avoiding the "visual noise" of changing controls.
      With resource-bound instantiation, the control is automatically shown, without requiring a call to Control:Show().
      Control:Show() is also usually called to redisplay a control that was hidden with the Control:Hide() method.
    </remarks>
  </Control.Show>
  <Control.Size>
    <summary>
      A dimension representing the size of a control.
    </summary>
    <value>A dimension representing the size of a control.</value>
  </Control.Size>
  <Control.Status>
    <summary>
      A hyperlabel indicating the status of the control after a validation attempt or other action.
    </summary>
    <value>A hyperlabel indicating the status of the control after a validation attempt or other action.</value>
    <remarks>
      If the validation passed or the operation was successful, this value is NULL_OBJECT; if not, it contains information about the failure, which can be retrieved and displayed—for example:
      <code language="X#">
        IF !oControl:FieldSpec:Validate(x)
        WarningBox{SELF, oControl:Status:Caption,;
        oControl:Status:Description}:Show()
        ENDIF
      </code>
      Hyperlabels are commonly used in the system, and in this case, the warning box is capable of accepting a hyperlabel and extracting the relevant information from it. Thus, this example can be simplified even further:
      <code language="X#">
        IF !oControl:FieldSpec:Validate(x)
        WarningBox{SELF,oControl:Status}:Show()
        ENDIF
      </code>
    </remarks>
  </Control.Status>
  <Control.Style>
    <exclude />
  </Control.Style>
  <Control.SuspendUpdate>
    <summary>
      Temporarily suspend all drawing updates for a control; drawing resumes with a call to Control:RestoreUpdate().
    </summary>
    <remarks>
      This method suspends all drawing updates for a control. It is especially useful for TreeView and ListView controls, where you typically want to suspend drawing while the ListView or TreeView control is filled.
    </remarks>
  </Control.SuspendUpdate>
  <Control.TextValue>
    <summary>
      A string representing the value held in the control.
    </summary>
    <value>A string representing the value held in the control.</value>
    <remarks>
      For example, in a standard edit control, the value can be "Jones" or "$14,683.00". In a check box, the value can be "TRUE" or "FALSE". For push buttons, Control:TextValue is set to NULL_STRING. In a list box or combo box, Control:TextValue holds the display value text. In a radio button group, Control:TextValue holds the caption text of the radio button that is currently selected.
      Note that the string is formatted according to the picture clause held in the field specification of the control; in turn, controls linked to a data server inherit the field specification - and hence picture clause - from the field of the server.
    </remarks>
    <example>
      The following examples demonstrate the use of the Control:TextValue property:
      <code language="X#">
        // Prints "C" for character string
        ?ValType(oDCAmountControl:TextValue)
        // Access the control (string value)
        cAmount := oDCAmountControl:TextValue
        // Assign "5" to the control
        oDCAmountControl:TextValue := "5"
      </code>
    </example>
  </Control.TextValue>
  <Control.Timer>
    <summary>
      Provide a method to be invoked at specific intervals defined when the timer is registered though the RegisterTimer() method.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>

  </Control.Timer>
  <Control.ToolTipText>
    <summary>
      String value representing the tooltip text used when the user moves the mouse pointer over the control.
    </summary>
    <value>String value representing the tooltip text used when the user moves the mouse pointer over the control.</value>
    <remarks>
      String value representing the tooltip text used when the user moves the mouse pointer over the control.
      <note type="tip">Tooltips are not supported for static controls, such as fixed text, group boxes, etc.</note>
    </remarks>
  </Control.ToolTipText>
  <Control.UseHLForToolTip>
    <summary>
      Logical value determining whether the descriptive text of a control's Hyperlabel should be used as the tooltip text.
    </summary>
    <value>Logical value determining whether the descriptive text of a control's Hyperlabel should be used as the tooltip text.</value>
    <remarks>
      Logical value determining whether the descriptive text of a control's Hyperlabel should be used as the tooltip text.
      <note type="tip">Any ToolTipText setting will override UseHLForToolTip.</note>
    </remarks>
  </Control.UseHLForToolTip>
  <Control.ValidateControl>
    <summary>This method validates if the control has been created and when not then it triggers the control creation</summary>
    <returns>TRUE when the controls was succesfully created. Otherwise FALSE.</returns>
  </Control.ValidateControl>
  <Control.Value>
    <summary>
      The value held in the control, in whatever data type the control holds.
    </summary>
    <value>The value held in the control, in whatever data type the control holds.</value>
    <remarks>
      The value held in the control, in whatever data type the control holds. Control:Value is thus of the usual data type. For example, in a regular edit control, the value can be the string "Jones" or the number 14683. In a check box, Control:Value can be TRUE or FALSE. In a list box or combo box, the Control:Value is generally one of the return values (unless the control is bound to a field where the actual contents is not one of the allowable choices). In a radio button group, Control:Value holds the group value (specified in the Window Editor) of the radio button that is currently selected; if none is selected, Control:Value is set to NIL.
      The data type of the control's Value is determined by its field specification; in turn, controls linked to a data server inherit the field specification—and hence data type—from the field of the server. When the control is made data-aware, by setting its name to the name of a field in the server attached to the data window, Control:Value is able to automatically read from and write to this field.
      <note type="tip">Value may not always be consistent with the state of the control, as indicated to the end-user. For example, if the data value for the field is not one of the allowed choices for a list box or combo box return value, or among the group value settings for the radio buttons in a radio button group, the control will be in a "no-match" situation. In this case the control will revert to its initial unselected state.</note>
    </remarks>
    <example>
      The following examples demonstrate the use of the Control:Value property:
      <code language="X#">
        // Prints "N" for numeric
        ?ValType(oDCAmountControl:Value)
        // Access the control (numeric value)
        nAmount := oDCAmountControl:Value
        // Assign 5 to the control
        oDCAmountControl:Value := 5
      </code>
    </example>
  </Control.Value>
  <Control.ValueChanged>
    <summary>
      A logical value representing whether the control's Value has been changed from its prior setting.
    </summary>
    <value>A logical value representing whether the control's Value has been changed from its prior setting.</value>
    <remarks>
      A logical value representing whether the control's Value has been changed from its prior setting. TRUE indicates that it has been changed from its prior setting, while FALSE indicates it has not. The Control:ValueChanged access is especially useful when the control is bound to a field in a server, since it is reset to FALSE each time you move to a new record. It is set to TRUE if you have changed from the original data value.
    </remarks>
  </Control.ValueChanged>
  <Control.VerticalScroll>
    <summary>
      Provide a method that is invoked when the control has focus and a vertical scroll bar is scrolled.
    </summary>
    <param name="oScrollEvent">The ScrollEvent object that describes the scroll type and new position.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The default behavior for this event handler is to update the thumb position; this can be changed using your own implementation of the handler. This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects. If the application has horizontal scroll bars, use a HorizontalScrollBar event handler.
    </remarks>
  </Control.VerticalScroll>
  <ControlEvent>
    <summary>
      Provide information about a control that generated a control event.
    </summary>
    <remarks>
      ControlEvent events are generated when the user operates the Button, Edit, and ListBox (and their respective subclasses) types of controls.

    </remarks>
  </ControlEvent>
  <ControlEvent.ctor>
    <inheritdoc />
  </ControlEvent.ctor>
  <ControlEvent.Control>
    <summary>
      The control that generated this control event.
    </summary>
    <value>The control that generated this control event.</value>
    <remarks>
      The control that generated this control event.
      <note type="tip">If the control that generated the control event was not created as a system control, this value is NIL. This can happen if a dialog window was specified in the resource entity, but was not registered in the system (that is, the window is not part of the DialogWindow class).</note>
    </remarks>
  </ControlEvent.Control>
  <ControlEvent.ControlID>
    <summary>
      A number between 1 and 8000 representing the unique ID of the control that generated this control event.
    </summary>
    <value>A number between 1 and 8000 representing the unique ID of the control that generated this control event.</value>
    <remarks>
      A number between 1 and 8000 representing the unique ID of the control that generated this control event. Every control has its own unique ID to distinguish it from other controls (enabling the owner window to determine which control generated an event).
    </remarks>
  </ControlEvent.ControlID>
  <ControlEvent.Description>
    <summary>
      A string representing the description of the control that generated this control event.
    </summary>
    <value>A string representing the description of the control that generated this control event.</value>
    <remarks>
      A string representing the description of the control that generated this control event. The description is contained in the control's hyperlabel. This value is a NULL_STRING if the control has no description.
    </remarks>
  </ControlEvent.Description>
  <ControlEvent.HelpContext>
    <summary>
      A string representing the help context ID of the control that generated this control event.
    </summary>
    <value>A string representing the help context ID of the control that generated this control event.</value>
    <remarks>
      A string representing the help context ID of the control that generated this control event. This ID is contained in the control's hyperlabel.
      <note type="tip">A help context ID indicates the place in the hypertext system where the system looks for help concerning this control.</note>
    </remarks>
  </ControlEvent.HelpContext>
  <ControlEvent.HyperLabel>
    <summary>
      The hyperlabel connected to the control event.
    </summary>
    <value>The hyperlabel connected to the control event.</value>
    <remarks>
      The hyperlabel connected to the control event. From the hyperlabel, you can retrieve additional information about the control event—for example:
      <code language="X#">
        cCaption := oControlEvent:HyperLabel:Caption
        cDescription := oControlEvent:HyperLabel:Description
        cHelpContext := oControlEvent:HyperLabel:HelpContext
      </code>
    </remarks>
  </ControlEvent.HyperLabel>
  <ControlEvent.Name>
    <summary>
      A string representing the name of the control that generated the event.
    </summary>
    <value>A string representing the name of the control that generated the event.</value>
    <remarks>
      A string representing the name of the control that generated the event. Do not confuse the name with the caption: the name is a programmer's ID and is never seen by the user.
    </remarks>
  </ControlEvent.Name>
  <ControlEvent.NameSym>
    <summary>
      A symbol representing the name of the control that generated the event.
    </summary>
    <value>A symbol representing the name of the control that generated the event.</value>
    <remarks>
      A symbol representing the name of the control that generated the event. Do not confuse the name with the caption: the name is a programmer's ID and is never seen by the user.
    </remarks>
  </ControlEvent.NameSym>
  <ControlFocusChangeEvent>
    <summary>
      Provide information about an ControlFocusChangeEvent, generated when a control gains or loses the keyboard focus.
    </summary>
  </ControlFocusChangeEvent>
  <ControlFocusChangeEvent.ctor>
    <inheritdoc />
  </ControlFocusChangeEvent.ctor>
  <ControlFocusChangeEvent.Control>
    <summary>
      The control that generated this control event.
    </summary>
    <value>The control that generated this control event.</value>
    <remarks>
      The control that generated this control event.
      <note type="tip">If the control that generated the control event was not created as a system control, this value is NIL. This can happen if a dialog window was specified in the resource entity, but was not registered in the system (that is, the window is not part of the DialogWindow class).</note>
    </remarks>
  </ControlFocusChangeEvent.Control>
  <ControlNotifyEvent>
    <summary>
      Provide information about a control notification event, which is generated when a control is required to notify its parent window of an event.
    </summary>
    <remarks>
      Many controls generate notification events, which are sent to their parent window so that the parent window can take some action. The notification is sent to the parent in the form of the ControlNotify event handler. This event is often subclassed so that a control can send an event object that is specific to the control and the notification. In this case, a more specific event handler in the parent is called as well.

    </remarks>
  </ControlNotifyEvent>
  <ControlNotifyEvent.ctor>
    <inheritdoc />
  </ControlNotifyEvent.ctor>
  <ControlNotifyEvent.Control>
    <summary>
      The Control object that generated this event.
    </summary>
    <value>The Control object that generated this event.</value>
  </ControlNotifyEvent.Control>
  <ControlNotifyEvent.NotifyCode>
    <summary>
      The notification code for this event as defined by the Windows API.
    </summary>
    <value>The notification code for this event as defined by the Windows API.</value>
    <remarks>
      The notification code for this event as defined by the Windows API. The value of the notification code depends on the type of control and the event. Refer to your Microsoft Win32 Software Development Kit documentation for more details.
      <note type="tip">
        The ControlNotifyEvent:NotifyCode access returns a DWORD variable.
        NotifyCode Values in the Windows SDK are usually defines as:
        <code language="X#">
          DEFINE TVN_KEYDOWN       := (TVN_FIRST-12)
          DEFINE TVN_FIRST        := (0U-400U)
        </code>
        In prior versions of X# TVN_KEYDOWN compiled to a LONG with value -412. Most other development environments treat defines like these as DWORD (unsigned) because the TVN_FIRST has one or more unsigned constants in its definition.
        Unfortunately there is a small problem in X#:
        USUAL variables can only contain LONG or FLOAT numerics and not DWORDS.
        This means that if you call ControlNotifyEvent:NotifyCode late bound you will receive a USUAL and therefore a LONG.
        So in case the NotifyCode is TVN_KEYDOWN, then the USUAL will have a LONG value of -412.
        We therefore strongly advise to store Event objects in a type local. This ensures that you will get the correct numeric type:
        <code language="X#">
          METHOD ControlNotify(oControlNotifyEvent) CLASS HelpAbout
          LOCAL oControl AS Control
          LOCAL oCNEvent AS ControlNotifyEvent
          oCNEvent := oControlNotifyEvent
          oControl := IIF(oCNEvent == NULL_OBJECT, NULL_OBJECT, oCNEvent:Control)
          SUPER:ControlNotify(oControlEvent)
          IF oCNEvent:NotifyCode == TVN_KEYDOWN
          // Do what you want to do
          ENDIF
          RETURN NIL
        </code>
      </note>
    </remarks>
  </ControlNotifyEvent.NotifyCode>
  <ControlWindow>
    <summary>
      Create a control as part of the Window hierarchy, thereby allowing the behavior of the control to be customized using event handlers.
    </summary>
    <remarks>
      When a control is created as part of the Window hierarchy, it can trap events. For example, you might want to customize the appearance of controls (like changing the background and foreground colors) or modify their default key handling.
      Manipulating a control via the ControlWindow class requires more overhead than those created by the subclasses of Control. Therefore, it is recommended that control windows be used only where special handling is needed (for example, to override the handling of certain events or call some window method on a control).
    </remarks>
  </ControlWindow>
  <ControlWindow.ctor>
    <summary>
      Construct a control window from an existing control.
    </summary>
    <param name="oControl">The control that should be used to initialize the control window. It should be an instance of any subclass of Control.</param>
    <remarks>
      The control used to initialize the control window is automatically destroyed when the control window is destroyed.
    </remarks>
    <example>
      The following example constructs a control window with the same properties as a push button:
      <code language="X#">
        CLASS PbWindow INHERIT ControlWindow
        METHOD Init(oWOwner,nResourceID) CLASS PbWindow
        LOCAL oPB AS OBJECT
        oPB := PushButton{oOwner,nResourceID}
        SUPER:Init(oPB)
      </code>
    </example>
  </ControlWindow.ctor>
  <ControlWindow.Control>
    <summary>
      The control on which the control window is based.
    </summary>
    <value>The control on which the control window is based.</value>
    <remarks>
      The control on which the control window is based. This information allows you to use the control window's inherited methods, so that you can use its built-in services.
    </remarks>
  </ControlWindow.Control>
  <ControlWindow.ControlID>
    <summary>
      A number between 1 and 8000 representing the unique ID of the control on which the control window is based.
    </summary>
    <value>A number between 1 and 8000 representing the unique ID of the control on which the control window is based.</value>
    <remarks>
      A number between 1 and 8000 representing the unique ID of the control on which the control window is based. Every control has its own unique ID to distinguish it from other controls (enabling the owner window to determine which control generated an event).
    </remarks>
  </ControlWindow.ControlID>
  <ControlWindow.Default>
    <inheritdoc />
  </ControlWindow.Default>
  <ControlWindow.Destroy>
    <summary>
      Free memory resources allocated for a ControlWindow object and its derived objects.
    </summary>
    <remarks>
      This method immediately frees resources for ControlWindow objects created explicitly in your application. ControlWindow:Destroy() also takes care of resources allocated to derived classes and deallocates them in the necessary order.
    </remarks>
  </ControlWindow.Destroy>
  <ControlWindow.Disable>
    <summary>
      Disable a control window, including its associated control (until a subsequent call to ControlWindow:Enable()).
    </summary>
    <remarks>
      Disabled controls are not active (for example, push buttons cannot be clicked and data controls cannot be modified) and, therefore, they do not send events to their owner windows. Note that under Windows, a disabled control is dimmed.
    </remarks>
  </ControlWindow.Disable>
  <ControlWindow.Dispatch>
    <inheritdoc />
  </ControlWindow.Dispatch>
  <ControlWindow.Enable>
    <summary>
      Enable a control window that was previously disabled.
    </summary>
    <remarks>
      Enabling a control window allows it to generate events and to send the events to its owner window when the user manipulates the control window. The dimming of disabled control windows is removed, and the control window is restored to its normal appearance.
      By default, control windows are enabled until disabled, so there is no need to call this Enable() method unless ControlWindow:Disable() was previously called.
    </remarks>
  </ControlWindow.Enable>
  <ControlWindow.Hide>
    <summary>
      Hide a control window and its associated control so it is not visible (until a subsequent call to ControlWindow:Show()).
    </summary>
  </ControlWindow.Hide>
  <ControlWindow.HyperLabel>
    <summary>
      The hyperlabel connected to the control on which the control window is based.
    </summary>
    <value>The hyperlabel connected to the control on which the control window is based.</value>
    <remarks>
      The hyperlabel connected to the control on which the control window is based. From the hyperlabel, you can retrieve additional information about the control:
    </remarks>
    <example>
      <code language="X#">
        cCaption := oControlWindow:HyperLabel:Caption
        cDescription := oControlWindow:HyperLabel:Description
        cHelpContext := oControlWindow:HyperLabel:HelpContext
      </code>
    </example>
  </ControlWindow.HyperLabel>
  <ControlWindow.Modified>
    <summary>
      A logical value indicating whether the control on which the control window is based has been changed by the user since it was last set.
    </summary>
    <value>A logical value indicating whether the control on which the control window is based has been changed by the user since it was last set.</value>
    <remarks>
      A logical value indicating whether the control on which the control window is based has been changed by the user since it was last set. TRUE indicates that the control has changed (even if it has not yet been validated or has failed validation); FALSE indicates that it has not.
    </remarks>
  </ControlWindow.Modified>
  <ControlWindow.Origin>
    <summary>
      A point representing the position of a control window on its owner window, in canvas coordinates.
    </summary>
    <value>A point representing the position of a control window on its owner window, in canvas coordinates.</value>
  </ControlWindow.Origin>
  <ControlWindow.Override>
    <summary>This is a compatibility method that is no longer used or needed.</summary>
  </ControlWindow.Override>
  <ControlWindow.SetFocus>
    <summary>
      Pass input focus to a control window, thereby directing all mouse and keyboard input to its associated control.
    </summary>
  </ControlWindow.SetFocus>
  <ControlWindow.Size>
    <summary>
      A dimension representing the size of a control window.
    </summary>
    <value>A dimension representing the size of a control window.</value>
  </ControlWindow.Size>
  <CurHand>
    <exclude />
  </CurHand>
  <CurHand.ctor>
    <exclude />
  </CurHand.ctor>
  <Cursor>
    <summary>
      Create a text cursor, which is used to visually represent the position in a window where the next piece of text appears.
    </summary>
    <remarks>
      The default cursor is an I-beam, although you can also create cursors using bitmaps.
      Note that a window can have only one cursor at a time. The system automatically manages the cursor between windows.
      <note type="tip">
        Not applicable for DialogWindows or DataWindows.
        Tip: In X#, the Cursor class corresponds to a text cursor; use class Pointer to create mouse cursors.
      </note>
    </remarks>
    <example>
      This example creates a cursor during a focus change:
      <code language="X#">
        METHOD FocusChange(oEvent) CLASS MyWindow
        IF oEvent:GotFocus
        oCursorText := Cursor{SELF,Dimension{20,20}}
        oCursorText:Position := Point{40,40}
        oCursorText:Show()
        ...
        ENDIF
      </code>
    </example>
  </Cursor>
  <Cursor.ctor>
    <summary>
      Construct a cursor.
    </summary>
    <param name="oOwner">The window that owns the cursor.</param>
    <param name="oObject">Either the dimension of the cursor, in canvas coordinates, or the bitmap used to depict the cursor.</param>
    <param name="lDimmed">TRUE creates the cursor as semi-transparent (dim); FALSE creates the cursor as black. The default is TRUE.</param>
  </Cursor.ctor>
  <Cursor.Destroy>
    <summary>
      Provide a method to de-instantiate a Cursor object.
    </summary>
    <remarks>
      This method can be used when a Cursor object is no longer needed. Cursor:Destroy() de-instantiates the Cursor object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </Cursor.Destroy>
  <Cursor.Handle>
    <summary>
      Return the handle for a cursor.
    </summary>
    <param name="nHandleType">
      The type of handle required. 0 is the only supported option and is the default if <paramref name="nHandle" /> is omitted.
    </param>
    <returns>
      A handle describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
    </remarks>
  </Cursor.Handle>
  <Cursor.Hide>
    <summary>
      Hide a cursor so it is not visible (until a subsequent call to Cursor:Show()).
    </summary>
  </Cursor.Hide>
  <Cursor.Position>
    <summary>
      A point—in owner window canvas coordinates—representing the current position of the cursor.
    </summary>
    <value>A point—in owner window canvas coordinates—representing the current position of the cursor.</value>
  </Cursor.Position>
  <Cursor.Show>
    <summary>
      Display a cursor so it is visible.
    </summary>
    <remarks>
      You must always Show() cursors explicitly. Cursor:Show() is also usually called to redisplay a cursor that was hidden with the Cursor:Hide() method.
    </remarks>
  </Cursor.Show>
  <CustomControl>
    <summary>
      Provide a base custom control class from which to derive specialized custom controls.
    </summary>
    <remarks>
      The CustomControl class registers its own Window class and can be used as a base for custom and owner-drawn controls. The CustomControl class is available via the Window Editor's tool palette.
      A custom control is an empty child window that can be used as a control on any window surface. The plain custom control does not have any built-in functionality, so you usually want to derive your own custom control class and implement specific behavior.
      Also, since a custom control only implements an empty child window, you should implement your own Expose() handler to support the owner-drawn surface of the control.
    </remarks>
  </CustomControl>
  <CustomControl.ctor>
    <summary>
      Construct a custom control.
    </summary>
    <param name="oOwner">The window that owns the custom control.</param>
    <param name="xID">The unique ID of the custom control (between 1 and 8000).</param>
    <param name="oPoint">The origin of the custom control in canvas coordinates.</param>
    <param name="oDimension">The dimension of the custom control in canvas coordinates.</param>
    <param name="kStyle">Constant representing the style of the custom control, specified either by a X# style constant or a Windows API style constant. Styles can be combined using the _Or() operator.</param>
    <param name="lDataAware">Logical value indicating whether the custom control is data-aware (TRUE) or not (FALSE). The default is FALSE.</param>
    <param name="nResourceID">The resource ID of the custom control.</param>
    <remarks>
      <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular Windows API constant.</note>
    </remarks>
  </CustomControl.ctor>
  <DataBrowser>
    <summary>
      Create a data browser, which is a spreadsheet-like table for displaying information from a data server.
    </summary>
    <remarks>
      A data browser is a control, like a check box or edit field. However, it should ordinarily not be created as an independent control; the easiest way to use a data browser is to switch a data window to browse view. This creates the DataBrowser object; it may be referenced through the data window's Browser property.
      The data browser is data-aware, like a window, and may be connected to a data server as a client. It exhibits much of the same behavior as a data window: it propagates data down to the server and it responds to all the notification messages that a server sends to its clients.
      The easiest way to place a browser on a window as a control together with other controls is to place another data window as a nested subform; see the DataWindow class for a description. This is easily done in the Window Editor using the Edit Insert menu commands or the Auto Layout feature. See "Using the Window Editor" in your IDE User Guide for details.
      <note type="tip">Static dependencies to the CATO3*.DLL files, which contain the DataBrowser and SplitWindow functionality, have been removed in this version of X#. Applications not using a data browser and/or split window no longer need these .DLLs. This leads to a smaller memory footprint, faster application startup, and smaller installations.</note>

      Data browsers present information in a spreadsheet-like table, with rows and columns.
      The columns are DataColumn objects. Data columns correspond to fields in a data server—each data column is linked to a server field (just like data controls on a data window).
      The rows correspond to records in the server. Unlike a regular data window, which displays only one record—the "current" record—at a time, the browser displays several records as rows in the table. It always maintains one row as the "current" row, which is the record the server is positioned on. References to the data and action methods that manipulate the data always refer to the "current" record, just like in a regular data window. The only difference, therefore, is visual, in that the browser shows records other than the current one.

      The user and the developer have a great deal of flexibility in the visual layout of data browsers. Columns can be resized and rearranged on the fly, by the user with the mouse (unless the developer disables these options) or under program control.
      To retain meaningful control of a column's contents after it has been rearranged, columns are identified by their name. If there is a need to use numbers for reference (as in a generic utility program that knows nothing of the meaning of its data), the columns can be referenced by their original positional number in the browser, which may or may not be the same as their visual position.
    </remarks>
  </DataBrowser>
  <DataBrowser.ctor>
    <summary>
      Construct a data browser.
    </summary>
    <param name="oOwner">The window that owns the data browser.</param>
    <param name="xID">The unique ID of the data browser (between 1 and 8000).</param>
    <param name="oPoint">The origin of the data browser in canvas coordinates. If not specified, (0,0) is used.</param>
    <param name="oDimension">
      The dimension of the data browser in canvas coordinates. If not specified, the size of <paramref name="oOwner" /> is used.
    </param>
    <param name="nResourceID">The resource ID of the data browser.</param>
    <remarks>
      When the owner window is a DataWindow object, the data browser occupies the full size of the data window frame window and changes size as the data window size changes.
    </remarks>
  </DataBrowser.ctor>
  <DataBrowser.AddColumn>
    <summary>
      Add one or more columns to a data browser.
    </summary>
    <param name="oGColumn">The data column to be added or the array of data columns to be added.</param>
    <param name="nIndex">The column after which the new column or columns will be inserted. This value can be a string or symbol representing the name of the column, a number representing its column number, or an oDataColumn object identifying the column. If you specify a number, you should note that column numbering begins at 1 (which refers to the first column in the logical sequence, not necessarily the leftmost column from the visual viewpoint). If omitted, new columns are added after the last column.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      When columns are inserted in the middle of the sequence, the reference numbers for any trailing columns are incremented. This is one reason why columns should be referenced by name, rather than number. Also, note that while columns can be repositioned from a visual viewpoint, they retain their logical position in the browser.
    </remarks>
  </DataBrowser.AddColumn>
  <DataBrowser.AsString>
    <summary>
      Return an identifying label for the data browser.
    </summary>
  </DataBrowser.AsString>
  <DataBrowser.Background>
    <summary>
      The brush used for painting the background of this data browser.
    </summary>
    <value>The brush used for painting the background of this data browser.</value>
  </DataBrowser.Background>
  <DataBrowser.CanUndo>
    <summary>
      Determine if the most recent changes to a data browser column can be undone (using DataBrowser:Undo()).
    </summary>
    <returns>
      TRUE if the operation can be undone; otherwise, FALSE.
    </returns>
  </DataBrowser.CanUndo>
  <DataBrowser.Caption>
    <summary>
      A string representing the caption of the data browser for use in its title bar.
    </summary>
    <value>A string representing the caption of the data browser for use in its title bar.</value>
    <remarks>
      A string representing the caption of the data browser for use in its title bar. By default, the data browser uses the caption defined in its hyperlabel.
      Assigning a blank caption (" ") causes the title bar to be displayed with no text. Assigning a NULL_STRING causes the title bar to be hidden. Note that by embedding newline (Chr(10)) characters in the caption string, the title bar changes height to accommodate multiple lines.
    </remarks>
  </DataBrowser.Caption>
  <DataBrowser.CellDoubleClick>
    <summary>
      Provide an event handler, called when the user double-clicks in a cell in the data browser.
    </summary>
    <remarks>
      As with all event handlers, this method is called automatically by the system. The developer can override this method to customize the response to this event: the standard response is to switch the cell into editing mode with the entire contents selected. In addition, the cells allow editing immediately, accepting the first keystroke as the new cell contents.
    </remarks>
  </DataBrowser.CellDoubleClick>
  <DataBrowser.CellEdit>
    <summary>
      Returns the edit control for the current cell when the DataBrowser is in edit mode. Otherwise a NULL_OBJECT is returned.
    </summary>
    <value>The edit control for the current cell when the DataBrowser is in edit mode. Otherwise a NULL_OBJECT is returned.</value>
  </DataBrowser.CellEdit>
  <DataBrowser.ChangeBackground>
    <summary>
      Set a new background brush for this data browser.
    </summary>
    <param name="oBrush">The new background brush to be used.</param>
    <param name="kWhere">
      Indicates what part of the browser should be repainted, specified as one of the following constants:
    </param>
    <remarks>
      Indicates what part of the browser should be repainted, specified as one of the following constants:
      <include file="Gui.xml" path="doc/Where/*" />
      The background color can be set for different parts of the data browser as a whole, but not for individual columns. To set the background brush for individual columns, use DataColumn:ChangeBackground().
      As a rule, initial settings are picked up from the standard settings of the environment—under Windows, colors are set in the Control Panel. Note that while it is possible to alter the color of the caption and column caption areas, this is not recommended when a 3-dimensional, sculpted, "button look" is used—end users can be confused if buttons don't look like buttons.
    </remarks>
    <example>
      To set the background of the text area to yellow and highlighted text to blue:
      <code language="X#">
        oDataBrowser:ChangeBackground(Brush{Color{COLORYELLOW}},GBLTEXT)
        oDataBrowser:ChangeBackground(Brush{Color{COLORBLUE}},GBLHITEXT)
      </code>
    </example>
  </DataBrowser.ChangeBackground>
  <DataBrowser.ChangeFont>
    <summary>
      Set a new font in a particular area of the data browser.
    </summary>
    <param name="oFont">The new font to be used.</param>
    <param name="kWhere">
      Indicates what part of the browser should be changed, specified as one of the following constants:
      <include file="Gui.xml" path="doc/Where/*" />

    </param>
    <returns>
      The font previously assigned to the changed area.
    </returns>
    <remarks>
      The font can be set for different parts of the data browser as a whole, but not for individual columns. Initially, the default font is extracted from the browser's owner window.
    </remarks>
    <example>
      To use a Helvetica-type font in the text area and a bold version of the same font in the column caption area:
      <code language="X#">
        oDataBrowser:ChangeFont(Font{FONTSWISS8},GBLTEXT)
        oDataBrowser:ChangeFont(Font{FONTROMAN14},GBLCOLCAPTION)
      </code>
    </example>
  </DataBrowser.ChangeFont>
  <DataBrowser.ChangeTextColor>
    <summary>
      Set a new pen in a particular area of the data browser.
    </summary>
    <param name="oColor">The new color to be used.</param>
    <param name="kColor">The standard color to be used, specified as one of the following constants in the table below</param>
    <param name="kWhere">Indicates what part of the browser should be changed, specified as one of constants in the table below</param>
    <returns>
      The pen previously assigned to the changed area.
    </returns>
    <remarks>
      Values for kColor
      <include file="Gui.xml" path="doc/Colors/*" />
      Values for kWhere
      <include file="Gui.xml" path="doc/Where/*" />
      The text color can be set for different parts of the data browser as a whole, but not for individual columns. To set the color for individual columns, use DataColumn:ChangeTextColor().
      As a rule, initial settings are picked up from the standard settings of the environment—under Windows, colors are set in the Control Panel.
    </remarks>
    <example>
      To set the text color in the main area to blue and highlighted text to red:
      <code language="X#">
        oDataBrowser:ChangeTextColor (Color{COLORBLUE},GBLTEXT)
        oDataBrowser:ChangeTextColor (Color{COLORRED},GBLHITEXT)
      </code>
    </example>
  </DataBrowser.ChangeTextColor>
  <DataBrowser.Clear>
    <summary>
      If one or more cells in the data browser are selected, clear their contents; if only some characters in a cell are selected, remove only those characters.
    </summary>
    <remarks>
      The current selection can be a few characters in a cell, an entire cell's contents, several cells, several records, or nothing at all.
      <note type="tip">Clear() is not allowed if more than one record is selected.</note>
      Note that this method changes the fields to which this data browser's cells are linked and, therefore, the changes are subject to validation. The operation leaves the cells blank, but required fields or other validation rules can mark the record as invalid.
      The operation performed by this method is the same action as is normally performed in standard GUI applications by the Edit Clear menu command (note that under Windows, this menu command is typically linked to the Delete key). This standard behavior is automatically provided by X# and, therefore, there is no need to provide a special method for this (in fact, the Delete key works even if there is no menu command). Systems like spreadsheets (which provide both clear and delete operations) link the Delete key to the Edit Clear menu command, not to the Edit Delete menu command.
      <note type="tip">Do not confuse clearing with deleting. Clearing a structure (such as a cell or field) removes its contents. Deleting a structure, on the other hand, removes the actual structure.</note>
    </remarks>
  </DataBrowser.Clear>
  <DataBrowser.ColPos>
    <summary>
      Return the position of the currently focused column.
    </summary>
  </DataBrowser.ColPos>
  <DataBrowser.ColumnCount>
    <summary>
      A numeric value indicating the number of columns in the data browser.
    </summary>
    <value>A numeric value indicating the number of columns in the data browser.</value>
  </DataBrowser.ColumnCount>
  <DataBrowser.ColumnFocusChange>
    <summary>
      Provide a method that is invoked when the column focus is changed.

    </summary>
    <param name="oDataColumn">The column that is gaining or losing focus.</param>
    <param name="lHasFocus">TRUE indicates the column is gaining focus; FALSE indicates the column is losing focus.</param>
    <remarks>
      When column focus is changed (i.e., the user moves from one column to another), typically there will be two events generated, thus ColumnFocusChange() will be called twice. The first event will be for the previous column losing focus and the second event will be for the new column gaining focus. You can trap either event by checking the value of <paramref name="lHasFocus" />.
    </remarks>
    <example>
      The following code demonstrates how the ColumnFocusChange handler can be used:
      <code language="X#">
        CLASS MyDataBrowser INHERIT DATABROWSER
        METHOD ColumnFocusChange(oDataColumn, lHasFocus) CLASS MyDataBrowser
        SUPER:FocusChange(oDataColumn, lHasFocus)
        IF lHasFocus
        TextBox{ SELF, oDataColumn:Name, "Gaining Focus"}:Show()
        ELSE
        TextBox{ SELF, oDataColumn:Name, "Losing Focus"}:Show()
        ENDIF
        RETURN SELF
      </code>
    </example>
  </DataBrowser.ColumnFocusChange>
  <DataBrowser.ColumnMoved>
    <summary>
      Provide a method that is invoked when a column is moved.

    </summary>
    <param name="oColumn">The column which was moved.</param>
  </DataBrowser.ColumnMoved>
  <DataBrowser.ColumnReSize>
    <summary>
      Provide a method that is invoked when a column is resized.

    </summary>
    <param name="oColumn">The column which was resized.</param>
  </DataBrowser.ColumnReSize>
  <DataBrowser.Copy>
    <summary>
      Copy the current selection in the data browser to the clipboard.
    </summary>
    <remarks>
      The current selection can be a few characters in a cell, an entire cell's contents, several cells, several records, or nothing at all. If several cells are selected, they are copied to the clipboard in the standard tab-separated format accepted by spreadsheet and word processor products.
      The operation performed by this method is the same action as is normally performed in standard GUI applications by the Edit Copy menu command (note that under Windows, this menu command is typically linked to the Ctrl+C and/or Ctrl+Insert accelerators). This standard behavior is automatically provided by X# and, therefore, there is no need to provide a special method for this (in fact, the accelerators work even if there is no menu command).
    </remarks>
  </DataBrowser.Copy>
  <DataBrowser.CurrentColumn>
    <summary>
      The current data column in the data browser (i.e., the one that contains the cursor).
    </summary>
    <value>The current data column in the data browser (i.e., the one that contains the cursor).</value>
  </DataBrowser.CurrentColumn>
  <DataBrowser.Cut>
    <summary>
      Cut the current selection in the data browser to the clipboard.
    </summary>
    <remarks>
      The current selection can be a few characters in a cell, an entire cell's contents, several cells, several records, or nothing at all. If several cells are selected, they are cut to the clipboard in the standard tab-separated format accepted by spreadsheet and word processor products.
      <note type="tip">Cut() is not allowed if more than one record is selected.</note>
      Note that this method changes the fields to which this data browser's cells are linked and, therefore, the changes are subject to validation. The operation leaves the cells blank, but required fields or other validation rules can mark the record as invalid.
      The operation performed by this method is the same action as is normally performed in standard GUI applications by the Edit Cut menu command (note that under Windows, this menu command is typically linked to the Ctrl+X and/or Shift+Insert accelerators). This standard behavior is automatically provided by X# and, therefore, there is no need to provide a special method for this (in fact, the accelerators work even if there is no menu command).
    </remarks>
  </DataBrowser.Cut>
  <DataBrowser.Default>
    <inheritdoc />
  </DataBrowser.Default>
  <DataBrowser.Destroy>
    <summary>
      Provide a method to de-instantiate a DataBrowser object.
    </summary>
    <remarks>
      This method can be used when a DataBrowser object is no longer needed. DataBrowser:Destroy() de-instantiates the DataBrowser object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </DataBrowser.Destroy>
  <DataBrowser.Disable>
    <summary>
      Disable a data browser (until a subsequent call to DataBrowser:Enable()).
    </summary>
    <remarks>
      Disabled data browsers are not active and, therefore, they do not send events to their owner windows or receive input focus. Note that a disabled data browser is dimmed.
    </remarks>
  </DataBrowser.Disable>
  <DataBrowser.Dispatch>
    <inheritdoc />
  </DataBrowser.Dispatch>
  <DataBrowser.EditFont>
    <summary>
      Returns the edit font for the DataBrowser. This font can be changed with the ChangeFont() method.
    </summary>
    <value>The edit font for the DataBrowser. This font can be changed with the ChangeFont() method.</value>
  </DataBrowser.EditFont>
  <DataBrowser.Enable>
    <summary>
      Enable a data browser that was previously disabled.
    </summary>
    <remarks>
      Enabling a data browser allows it to generate events and to send the events to its owner window when the user manipulates the data browser. It also allows the data browser to receive input focus. The dimming of disabled data browsers is removed, and the data browser is restored to its normal appearance.
      By default, data browsers are enabled until disabled, so there is no need to call this Enable() method unless DataBrowser:Disable() was previously called.
    </remarks>
  </DataBrowser.Enable>
  <DataBrowser.EnableBorder>
    <summary>
      Specify the border style of the data browser.
    </summary>
    <param name="kBorderType">
      The display style of the data browser window's border, specified as one of the constants in the table below
    </param>
    <remarks>
      <code>
        Values for kBorderType
        Constant	Description
        BTNOBORDER	No border.
        BTNONSIZINGBORDER	A single-line border that does not allow resizing.
        BTSIZINGBORDER	A border that allows resizing. This is the default.
      </code>
      When autosizing is enabled for a data browser acting as a browse view for a data window, the data browser should not have a border because the window provides a sizing border. When a data browser is acting as a regular control, a non-sizing border is most commonly used.
    </remarks>
  </DataBrowser.EnableBorder>
  <DataBrowser.EnableColumnMove>
    <summary>
      Enable/disable whether the user can move (rearrange) columns in the data browser with the mouse. If this method is not called, the ability to move columns is enabled, by default.
    </summary>
    <param name="lAllowMove">TRUE allows column movement; FALSE disables it. The default is TRUE.</param>
    <remarks>
      The user can rearrange the columns by simply dragging a column's caption area with the mouse. For the purpose of reference from the program, the columns retain their original numbering, regardless of the visual position.
      Column movement is enabled/disabled at two levels: the DataBrowser class level and the DataColumn class level. If column movement is set at the browser level, DataBrowser:EnableColumnMove() can be used to enable/disable movement. However, if column movement is enabled at the column level, this method can no longer be used.
      DataColumn:EnableColumnMove() must be used to change the setting.
    </remarks>
  </DataBrowser.EnableColumnMove>
  <DataBrowser.EnableColumnReSize>
    <summary>
      Enable/disable whether the user can resize columns in the data browser with the mouse. If this method is not called, the ability to resize columns is enabled, by default.
    </summary>
    <param name="lAllowResize">TRUE allows column resizing; FALSE disables it. The default is TRUE.</param>
    <remarks>
      The user can resize the columns by dragging on the boundary between the column caption areas with the mouse.
      Column movement is enabled/disabled at two levels: the DataBrowser class level and the DataColumn class level.
      If column resizing is set at the browser level, DataBrowser:EnableColumnResize() can be used to enable/disable resizing. However, if column resizing is enabled at the column level, this method can no longer be used. DataColumn:EnableColumnResize() must be used to change the setting.
    </remarks>
  </DataBrowser.EnableColumnReSize>
  <DataBrowser.EnableColumnTitles>
    <summary>
      Turn column titles on or off for the entire browser.
    </summary>
    <param name="lEnable">TRUE shows column titles; FALSE hides them. The default is TRUE. </param>
    <returns>
      A logical value indicating whether or not the operation was successful.
    </returns>
    <remarks>
      This method has been introduced to replace the functionality of calling DataColumn:SetCaption with a NIL argument, which is documented as removing the caption area from the column. Since column caption areas cannot be removed from single columns, it must be done globally for the entire browser.
    </remarks>
    <example>
      The following example illustrates how DataBrowser:EnableColumnTitles may be used to suppress the display of column titles in a subform browser created via Window Editor-generated source code:
      <code language="X#">
        METHOD Init( oOwner ) CLASS DW_Detail_DataBrowser
        SUPER:Init( oOwner )
        SELF:EnableColumnTitles( FALSE )
        RETURN SELF
      </code>
    </example>
  </DataBrowser.EnableColumnTitles>
  <DataBrowser.EnableGrid>
    <summary>
      Enable/disable the display of a grid. If this method is not called, the grid is enabled, by default.
    </summary>
    <param name="lShowGrid">TRUE shows the grid; FALSE hides it. The default is TRUE.</param>
  </DataBrowser.EnableGrid>
  <DataBrowser.EnableHorizontalScroll>
    <summary>
      Enable/disable horizontal scrolling of a data browser. If this method is not called, horizontal scrolling is enabled, by default.
    </summary>
    <param name="lAllowScroll">TRUE allows scrolling by displaying a horizontal scroll bar along the bottom edge of the data browser; FALSE disables the scroll bar. The default is TRUE.</param>
  </DataBrowser.EnableHorizontalScroll>
  <DataBrowser.EnableHorizontalSplit>
    <summary>
      Enable/disable a horizontal splitbar in the data browser.
    </summary>
    <param name="lShowSplit">
      TRUE enables (and shows) the splitbar; FALSE disables (and hides) it. The default is TRUE.
      If this method is not called for a data browser, FALSE is the default.
    </param>
  </DataBrowser.EnableHorizontalSplit>
  <DataBrowser.EnableVerticalScroll>
    <summary>
      Enable/disable vertical scrolling of a data browser. If this method is not called, vertical scrolling is enabled, by default.
    </summary>
    <param name="lAllowScroll">TRUE allows scrolling by displaying a vertical scroll bar along the right edge of the data browser; FALSE disables the scroll bar. The default is TRUE.</param>
  </DataBrowser.EnableVerticalScroll>
  <DataBrowser.EnableVerticalSplit>
    <summary>
      Enable/disable a vertical splitbar in the data browser.
    </summary>
    <param name="lShowSplit">
      TRUE enables (and shows) the splitbar; FALSE disables (and hides) it. The default is TRUE.
      If this method is not called for a data browser, FALSE is the default.
    </param>
    <param name="nMode">
      Initial splitbar positioning, specified as one of the following constants:
      <include file="Gui.xml" path="doc/SplitBar/*" />
      If not specified, the initial splitbar position defaults to GBSSBMIDDLE.
    </param>
    <remarks>
      <include file="Gui.xml" path="doc/SplitBar/*" />
      A vertical splitbar allows the left and right parts of a window to be independently scrollable sideways. The position of the splitbar in the window is also adjustable with the mouse.
    </remarks>
  </DataBrowser.EnableVerticalSplit>
  <DataBrowser.Error>
    <summary>
      Provide a method for handling error conditions raised during data browser processing.
    </summary>
    <remarks>
      <note type="tip">This is an event handler and is automatically called by other methods; the developer does not normally need to call the DataBrowser:Error() method, but might want to override it.</note>

    </remarks>
    <param name="oErrorObj">An Error object describing the error condition.</param>
  </DataBrowser.Error>
  <DataBrowser.Font>
    <summary>
      The font to be used for the text area of the data browser.
    </summary>
    <value>The font to be used for the text area of the data browser.</value>
  </DataBrowser.Font>
  <DataBrowser.GetColumn>
    <summary>
      Retrieve a specified column in this data browser.
    </summary>
    <param name="xColumnID">The name, number, or symbol of the column to be retrieved.</param>
    <returns>
      The specified data column or NIL if it could not be found.
    </returns>
  </DataBrowser.GetColumn>
  <DataBrowser.Handle>
    <summary>
      Return the handle for a data browser.
    </summary>
    <returns>
      A handle to the data browser, describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the data browser, which can then be used by Windows API calls.
    </remarks>
  </DataBrowser.Handle>
  <DataBrowser.HiBackground>
    <summary>
      Returns the background brush for the Highlighted rows and cells in the Databrowser. This can be changed with the ChangeBackground() method.
    </summary>
    <value>The background brush for the Highlighted rows and cells in the Databrowser. This can be changed with the ChangeBackground() method.</value>
  </DataBrowser.HiBackground>
  <DataBrowser.Hide>
    <summary>
      Hide a data browser so it is not visible.
    </summary>
    <remarks>
      The data browser remains hidden from display until the DataBrowser:Show() method is called.
    </remarks>
  </DataBrowser.Hide>
  <DataBrowser.NewRow>
    <exclude />
  </DataBrowser.NewRow>
  <DataBrowser.Notify>
    <summary>
      An event handler that reflects events that have occurred in the server connected to this data browser.
    </summary>
    <returns>
      NIL except if NOTIFYINTENTTOMOVE is specified for <paramref name="kNotifyName" />.
      In this case, the return value is TRUE if successful; otherwise, FALSE.
    </returns>
    <include file="VOSDK.xml" path="doc/commonblocks/notify/*" />
  </DataBrowser.Notify>
  <DataBrowser.Origin>
    <summary>
      A point representing the location of the data browser on its owner window, in canvas coordinates.
    </summary>
    <value>A point representing the location of the data browser on its owner window, in canvas coordinates.</value>
  </DataBrowser.Origin>
  <DataBrowser.Owner>
    <summary>
      The owner window of the data browser.
    </summary>
    <value>The owner window of the data browser.</value>
  </DataBrowser.Owner>
  <DataBrowser.Paste>
    <summary>
      Paste the current contents of the clipboard into the current data browser cell.
    </summary>
    <remarks>
      How clipboard data is pasted into the data browser depends on the following:
      The current selection

      The current selection can be a few characters in a cell, an entire cell's contents, several cells, several records, or nothing at all.

      If a few characters or an entire cell is selected, the selected characters are overwritten with the pasted data. Note that in this case, the standard tab-separated format accepted by spreadsheet and word processor products is used, as long as the shape of the selection matches.

      If nothing is selected, the clipboard data is inserted into the current cell (i.e., the one containing the cursor). Note that the data is inserted before the cursor.

      <note type="tip">Paste() is not allowed if more than one record is selected.</note>

      The Insert key
      Note that this method changes the fields to which this data browser's cells are linked and, therefore, the changes are subject to validation. The operation leaves the cells blank, but required fields or other validation rules can mark the record as invalid.
      The operation performed by this method is the same action as is normally performed in standard GUI applications by the Edit Paste menu command (note that under Windows, this menu command is typically linked to the Ctrl+V and/or Shift+Insert accelerators). This standard behavior is automatically provided by X# and, therefore, there is no need to provide a special method for this (in fact, the accelerators work even if there is no menu command).
    </remarks>
  </DataBrowser.Paste>
  <DataBrowser.Pointer>
    <summary>
      The Pointer object to be used in the text area of the data browser.
    </summary>
    <value>The Pointer object to be used in the text area of the data browser.</value>
  </DataBrowser.Pointer>
  <DataBrowser.ptrControlDefaultProc>
    <exclude />
  </DataBrowser.ptrControlDefaultProc>
  <DataBrowser.Refresh>
    <summary>
      Forces the contents of the data browser to be updated from the data server.
    </summary>
  </DataBrowser.Refresh>
  <DataBrowser.RemoveColumn>
    <summary>
      Remove a column from this data browser.
    </summary>
    <param name="uColumnOrIndex">The name, number, or symbol representing the column to be removed.</param>
    <returns>
      The removed data column, if successful; otherwise, NULL_OBJECT.
    </returns>
    <remarks>
      When a column is deleted, the reference numbers for any trailing columns are decremented. This is one reason why columns should be referenced by name, rather than number.
    </remarks>
  </DataBrowser.RemoveColumn>
  <DataBrowser.RestoreUpdate>
    <summary>
      Update this data browser visually and restore standard operation (after DataBrowser:SuspendUpdate() is called).
    </summary>
    <remarks>
      DataBrowser:SuspendUpdate() is used to reduce "visual noise" during a multi-record update of the data browser from its data server. When the updating is complete, use the DataBrowser:RestoreUpdate() method to refresh the display and reactivate standard behavior.
      Note that DataBrowser:SuspendUpdate() stacks its invocations. Therefore, for each call to DataBrowser:SuspendUpdate(), there needs to be a corresponding call DataBrowser:RestoreUpdate().
    </remarks>
  </DataBrowser.RestoreUpdate>
  <DataBrowser.RowCount>
    <summary>
      A numeric value indicating the number of rows in the data browser.
    </summary>
    <value>A numeric value indicating the number of rows in the data browser.</value>
  </DataBrowser.RowCount>
  <DataBrowser.SetCaption>
    <summary>
      Set the caption for the data browser title bar.
    </summary>
    <param name="cText">The text to be used as the caption. </param>
    <param name="symText">The symbol to be used as the caption.</param>
    <remarks>
      Setting a blank caption ("") causes the title bar to be displayed with no caption. Setting a null caption causes the title bar to be hidden.
      By embedding newline characters in the caption string, the title bar changes height to accommodate multiple lines.
    </remarks>
  </DataBrowser.SetCaption>
  <DataBrowser.SetColumn>
    <summary>
      Replace an existing column in the data browser with another column.
    </summary>
    <param name="oDataColumn">The new data column.</param>
    <param name="nColumnNumber">The column to be replaced. The number must be within the range of columns in the data browser; this method does not append a column at the end.</param>
    <returns>
      The replaced data column, if successful; otherwise, NULL_OBJECT.
    </returns>
  </DataBrowser.SetColumn>
  <DataBrowser.SetColumnFocus>
    <summary>
      Set the column focus to a specified data column.
    </summary>
    <param name="oColumn">The column that the focus will be set to. If omitted, the default is NULL_OBJECT; the focus will not be changed.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </DataBrowser.SetColumnFocus>
  <DataBrowser.SetPointer>
    <summary>
      Set a new pointer to be used when the mouse moves over a particular area of the data browser.
    </summary>
    <param name="oPointer">The new pointer to be used. If not specified, the default pointer is POINTERARROW.</param>
    <param name="kWhere">Indicates what part of the browser should be changed, specified as one of the following constants</param>
    <param name="Constant">Description</param>
    <param name="GBLCAPTION">The browser caption area. This is only visible if you first set a Browser caption.</param>
    <param name="GBLCOLCAPTION">The column caption area.</param>
    <param name="GBLTEXT">Text in the data display area. This is the default.</param>
  </DataBrowser.SetPointer>
  <DataBrowser.SetStandardStyle>
    <summary>
      Set the appearance of the data browser's caption areas.
    </summary>
    <param name="kStyle">The style to set, specified as one of the following constants:</param>
    <remarks>
      <note type="tip">The DataBrowser:SetStandardStyle() method can be overridden by DataColumn:SetStandardStyle() for individual columns.</note>
      <include file="Gui.xml" path="doc/BrowseStyle/*" />
      If not specified, the default style is sculpted, three-dimensional, and "editable."
      Tip: To specify more than one style parameter, simply make more than one call.
      <note type="tip">The DataBrowserSetStandardStyle() can be overridden by the DataColumn:SetStandardStyle() for individual columns.</note>
    </remarks>
  </DataBrowser.SetStandardStyle>
  <DataBrowser.Show>
    <summary>
      Show this data browser.
    </summary>
    <remarks>
      When a data browser is first shown, its connected data server can be traversed to build up its buffer of records. When the data browser traverses the server, it uses the current server cursor location to get its first record. It is up to the application to position the server prior to using it with a data browser.
    </remarks>
  </DataBrowser.Show>
  <DataBrowser.Size>
    <summary>
      A dimension representing the size of the data browser.
    </summary>
    <value>A dimension representing the size of the data browser.</value>
  </DataBrowser.Size>
  <DataBrowser.SuspendUpdate>
    <summary>
      Temporarily disable repainting of the data browser while data is being altered; painting resumes with a call to DataBrowser:RestoreUpdate().
    </summary>
    <remarks>
      This method is used to reduce "visual noise" during a multi-record update of the data browser from its data server. For example, when reading a full screen of data, the appearance of the window is more pleasing if the screen updates occur all together. When the updating is complete, use the DataBrowser:RestoreUpdate() method to refresh the display and reactivate standard behavior.
      Note that DataBrowser:SuspendUpdate() stacks its invocations. Therefore, for each call to DataBrowser:SuspendUpdate(), there needs to be a corresponding call DataBrowser:RestoreUpdate().
    </remarks>
  </DataBrowser.SuspendUpdate>
  <DataBrowser.TextColor>
    <summary>
      The text color to be used for the text area of the data browser.
    </summary>
    <value>The text color to be used for the text area of the data browser.</value>
  </DataBrowser.TextColor>
  <DataBrowser.Undo>
    <summary>
      Undo recent changes to a row in the data browser.
    </summary>
    <remarks>
      There is normally little need to call this method, since it is automatically called from the data window. The keyboard interface for a regular undo operation is automatically provided, but menu commands and toolbar items should also be provided on the window.
    </remarks>
  </DataBrowser.Undo>
  <DataBrowser.Use>
    <summary>
      Connect the data browser to a data server in a client-server relationship.
    </summary>
    <param name="oServer">The data server to which this data browser should be connected. If the data browser is already connected to a server, it is disconnected first. If omitted, the data browser is disconnected from the data server.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">If the browser is used as a browse view of a data window, there is no reason to use this method; the browser is automatically connected to the server of the window it belongs to.</note>
      The DataBrowser:Use() method connects browser columns with fields of the data server based on matching names. Any column that does not have an explicitly provided field specification and hyperlabel inherits the FieldSpec and HyperLabel objects from its data server field.
      If the data browser does not have any columns, the DataBrowser:Use() method automatically creates a layout with columns for all the fields in the server.
      DataBrowser:Use() also registers the data browser as a client of the server with the DataServer:RegisterClient() method.
    </remarks>
  </DataBrowser.Use>
  <DataBrowser.Validate>
    <summary>
      Determine whether the currently focused record is valid.
    </summary>
    <returns>
      TRUE if the record is valid; otherwise, FALSE.
    </returns>
  </DataBrowser.Validate>
  <DataColumn>
    <summary>
      Create columns for use in a data browser.
    </summary>
    <remarks>
      A data column is not a control; it is a component of a data browser. From a data management viewpoint, however, a data column is analogous to a control on a data window: when the browser is connected to a server, each column is linked to a data field.
    </remarks>
  </DataColumn>
  <DataColumn.ctor>
    <summary>
      Construct a data column.
    </summary>
    <param name="nWidth">The initial width in which to display the column, in characters, or the FieldSpec object from which the width is extracted. If not specified, the default is 16.</param>
    <param name="xColumnID">The name or symbolic name of the column or hyperlabel containing the name of the column and any optional annotation.</param>
  </DataColumn.ctor>
  <DataColumn.Alignment>
    <summary>
      One of the following constants representing the alignment of this data column:
    </summary>
    <value>One of the following constants representing the alignment of this data column:</value>
    <remarks>
      One of the following constants representing the alignment of this data column:
      <include file="Gui.xml" path="doc/Alignment/*" />
    </remarks>
  </DataColumn.Alignment>
  <DataColumn.AsString>
    <summary>
      Return the current value in the current row of this data column as a formatted string.
    </summary>
    <param name="uParam">The value held in the current row of this data column. </param>
    <remarks>
      This method returns the same as DataColumn:TextValue. AsString() is the standard method provided by all objects, for returning some reasonable text when needed.
      Note that this string is formatted according to the picture clause held in the FieldSpec object inherited from the associated server field.
    </remarks>
  </DataColumn.AsString>
  <DataColumn.Background>
    <summary>
      The brush used for painting the background of this data column.
    </summary>
    <value>The brush used for painting the background of this data column.</value>
  </DataColumn.Background>
  <DataColumn.Block>
    <summary>
      A code block associated with the data column. If set, it is used to filter the data in/out of the data column.
    </summary>
    <value>A code block associated with the data column. If set, it is used to filter the data in/out of the data column.</value>
    <example>
      This example sets the code block for a calculated Wages column where HoursWorked and HourlyRate are fields in your database. These lines would appear inside your DataBrowser:Init() method:
      <code language="X#">
        oMyColumn:BlockOwner := SELF:Server	// The server object attached to the browser
        oMyColumn:Block := { | oVar | oVar:HoursWorked * oVar:HourlyRate }
        //where oVar is the BlockOwner
      </code>
    </example>
  </DataColumn.Block>
  <DataColumn.BlockOwner>
    <summary>
      The owner of the code block associated with the data column. If a code block is assigned, this object will be called when the code block is evaluated. For an example, see DataColumn:Block.
    </summary>
    <value>The owner of the code block associated with the data column. If a code block is assigned, this object will be called when the code block is evaluated. For an example, see DataColumn:Block.</value>
  </DataColumn.BlockOwner>
  <DataColumn.Caption>
    <summary>
      A string representing the caption of this data column for use in its caption area.
    </summary>
    <value>A string representing the caption of this data column for use in its caption area.</value>
    <remarks>
      A string representing the caption of this data column for use in its caption area. By default, the data column uses the caption defined in its hyperlabel.
      You can specify a caption in a manner similar to the DataBrowser:Caption property (for example, assigning a blank caption ("") causes the caption area to be displayed with no text). Note that the height of the caption area is automatically made large enough to accommodate the captions of all columns in the owning data browser.
    </remarks>
  </DataColumn.Caption>
  <DataColumn.CellBackground>
    <summary>
      The Brush object used to paint the background of a cell if DataColumn:EnableCellDraw has been called.
    </summary>
    <value>The Brush object used to paint the background of a cell if DataColumn:EnableCellDraw has been called.</value>
    <remarks>
      The Brush object used to paint the background of a cell if DataColumn:EnableCellDraw has been called. This object should not be a local variable of the cell-painting method supplied to DataColumn:EnableCellDraw.
    </remarks>
  </DataColumn.CellBackground>
  <DataColumn.CellTextColor>
    <summary>
      The Color object used to paint the text in a cell if DataColumn:EnableCellDraw has been called.
    </summary>
    <value>The Color object used to paint the text in a cell if DataColumn:EnableCellDraw has been called.</value>
    <remarks>
      The Color object used to paint the text in a cell if DataColumn:EnableCellDraw has been called. This object should not be a local variable of the cell-painting method supplied to DataColumn:EnableCellDraw.
    </remarks>
  </DataColumn.CellTextColor>
  <DataColumn.ChangeBackground>
    <summary>
      Set a new background brush for this data column.
    </summary>
    <param name="oBrush">The new background brush to be used.</param>
    <param name="kWhere">
      Indicates what part of the data column should be repainted, specified as one of the following constants:
      <include file="Gui.xml" path="doc/Where/*" />
    </param>
    <returns>
      The brush previously assigned to the changed area.
    </returns>
    <remarks>
      The setting specified here supersedes, for this data column, the setting set in this data column's owner data browser. Although the button and caption area can be specified, the method refers only to this column.
      As a rule, initial settings are picked up from the standard settings of the environment—under Windows, colors are set in the Control Panel. Note that while it is possible to alter the color of the caption and column caption areas, this is not recommended when a 3-dimensional, sculpted, "button look" is used—end users can be confused if buttons don't look like buttons.
    </remarks>
    <example>
      To set the background of the text area yellow and column caption blue:
      <code language="X#">
        oDataColumn:ChangeBackground(Brush{Color{COLORYELLOW}},	GBLTEXT)
        oDataColumn:ChangeBackground(Brush{Color{COLORBLUE}},GBLCOLCAPTION)
      </code>
    </example>
  </DataColumn.ChangeBackground>
  <DataColumn.ChangeTextColor>
    <summary>
      Set a new pen in a particular area of this data column.
    </summary>
    <param name="oColor">The new color to be used.</param>
    <param name="kColor">
      Indicates the standard color to be used, specified as one of the following constants:
    </param>
    <param name="kWhere">
      Indicates what part of the data column should be changed, specified as one of the following constants.
    </param>
    <returns>
      The pen previously assigned to the changed area.
    </returns>
    <remarks>
      Possible values for kColor
      <include file="Gui.xml" path="doc/Colors/*" />
      Possible values for kWhere
      <include file="Gui.xml" path="doc/Where/*" />
      As a rule, initial settings are picked up from the standard settings of the environment—under Windows, colors are set in the Control Panel.
      The default is picked up from the standard settings of the environment; for example, under Windows the text color of buttons is set with the Control Panel. Although the button and caption area can be specified, the method refers only to this column.
    </remarks>
    <example>
      To set the text color in the main area blue and caption text red:
      <code language="X#">
        oDataColumn:ChangeTextColor(Color{COLORBLUE},GBLTEXT)
        oDataColumn:ChangeTextColor(Color{COLORRED},GBLCOLCAPTION)
      </code>
    </example>
  </DataColumn.ChangeTextColor>
  <DataColumn.ClearStatus>
    <exclude />
  </DataColumn.ClearStatus>
  <DataColumn.DataField>
    <exclude />
  </DataColumn.DataField>
  <DataColumn.Destroy>
    <summary>
      Provide a method to de-instantiate a DataColumn object.
    </summary>
    <remarks>
      This method can be used when a DataColumn object is no longer needed. DataColumn:Destroy() de-instantiates the DataColumn object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </DataColumn.Destroy>
  <DataColumn.DisableCellDraw>
    <exclude />
  </DataColumn.DisableCellDraw>
  <DataColumn.DrawCellData>
    <exclude />
  </DataColumn.DrawCellData>
  <DataColumn.EnableCellDraw>
    <summary>
      Enable the painting of individual cells by registering a cell-painting method.
    </summary>
    <param name="symMethodName">The symbolic name of the method that will be used to paint the cells in this column.</param>
    <remarks>
      Enables the cells in this column to be painted according to a method supplied by the developer. The method provided will be called whenever the cell is about to be painted. The cell's usual value is passed to the method, and can be used to determine what text color and background brush should be used in painting, by assigning new values to DataColumn:CellTextColor and DataColumn:CellBackground, respectively.
    </remarks>
    <example>
      The following example shows how DataColumn:EnableCellDraw may be used to highlight past due accounts in the data browser:
      <code language="X#">
        CLASS ColorColumn INHERIT DataColumn
        PROTECT oValidTextColor	AS Color
        PROTECT oValidBackground	AS Brush
        PROTECT oInvalidTextColor	AS Color
        PROTECT oInvalidBackground AS Brush
        METHOD Init( oFieldSpec ) CLASS ColorColumn
        SUPER:Init( oFieldSpec )
        oValidTextColor := Color{ COLORWHITE }
        oValidBackground := Brush{ Color{ COLORBLUE } }
        oInvalidTextColor := Color{ COLORYELLOW }
        oInvalidBackground := Brush{ Color{ COLORRED } }
        RETURN SELF
        METHOD Init( oWindow, iCtlID, oServer ) CLASS ColorSubForm
        // some initialization code
        SELF:Browser := ColorSubForm_Browser{ SELF }
        oDBDUE_DATE := ColorColumn{ ACCOUNTS_DUE_DATE{} }
        oDBDUE_DATE:Width := 12
        oDBDUE_DATE:HyperLabel := oDCDUE_DATE:HyperLabel
        oDBDUE_DATE:Caption := "DueDate"
        SELF:Browser:AddColumn( oDBDUE_DATE )
        oDBDUE_DATE:EnableCellDraw( #ValidDateDraw )
        // more initialization code
        RETURN SELF
        METHOD ValidDateDraw( uValue ) CLASS ColorColumn
        IF uValue &lt; GetPastDueDate()
        SELF:CellTextColor := oValidTextColor
        SELF:CellBackground := oValidBackground
        ELSE
        SELF:CellTextColor := oInvalidTextColor
        SELF:CellBackground := oInvalidBackground
        ENDIF
        RETURN NIL
      </code>
    </example>
  </DataColumn.EnableCellDraw>
  <DataColumn.EnableColumnMove>
    <summary>
      Enable/disable whether the user can move (rearrange) this data column with the mouse. If the method is not called, the default behavior is determined by the data browser that owns this column.
    </summary>
    <param name="lAllowMove">TRUE allows column movement; FALSE disables it. The default is TRUE.</param>
    <remarks>
      The user can rearrange the columns by simply dragging a column's caption area with the mouse. For the purpose of reference from the program, the columns retain their original numbering, regardless of the visual position.
    </remarks>
  </DataColumn.EnableColumnMove>
  <DataColumn.EnableColumnReSize>
    <summary>
      Enable/disable whether the user can resize this data column with the mouse. If this method is not called, the default behavior is determined by the data browser that owns this column.
    </summary>
    <param name="lAllowResize">TRUE allows column resizing; FALSE disables it. The default is TRUE.</param>
    <remarks>
      The user can resize a column by dragging on the boundary between the column caption areas with the mouse.
    </remarks>
  </DataColumn.EnableColumnReSize>
  <DataColumn.FieldSpec>
    <summary>
      The FieldSpec object connected to this data column.
    </summary>
    <value>The FieldSpec object connected to this data column.</value>
    <remarks>
      The FieldSpec object connected to this data column. This is used for validation purposes, as well as calculating default widths and alignment characteristics.
    </remarks>
  </DataColumn.FieldSpec>
  <DataColumn.GetCaption>
    <exclude />
  </DataColumn.GetCaption>
  <DataColumn.GetEditObject>
    <exclude />
  </DataColumn.GetEditObject>
  <DataColumn.GetModified>
    <summary>
      Determine whether the value in column has been modified.
    </summary>
    <returns>
      TRUE if the value in the column has been modified; otherwise, FALSE.
    </returns>
  </DataColumn.GetModified>
  <DataColumn.GetValue>
    <summary>
      Get the value of the current data column.
    </summary>
  </DataColumn.GetValue>
  <DataColumn.HyperLabel>
    <summary>
      The hyperlabel connected to this data column.
    </summary>
    <value>The hyperlabel connected to this data column.</value>
    <remarks>
      The hyperlabel connected to this data column. From the hyperlabel, you can retrieve additional information about the data column—for example:
      <code language="X#">
        cCaption := oDataColumn:HyperLabel:Caption
        cDescription := oDataColumn:HyperLabel:Description
        cHelpContext := oDataColumn:HyperLabel:HelpContext
      </code>
    </remarks>
  </DataColumn.HyperLabel>
  <DataColumn.LinkDF>
    <summary>
      Connect a column to a field in a data server.
    </summary>
    <param name="oDataServer">The server that the column is to be linked to. Ordinarily, this is the common server that the entire window is linked to, but it is possible to link individual columns to other servers.</param>
    <param name="nFieldData">The number of the field within the server.</param>
    <remarks>
      DataColumn:LinkDF() should ordinarily not be called directly by the application. It is called by DataBrowser:Use(); Use() connects an entire client to an entire server. You can use DataColumn:LinkDF() to link a column to a data field explicitly, perhaps if the column's name doesn't match the data field's name so the automatic linkage of DataBrowser:Use() doesn't work.
      It is even possible to use DataColumn:LinkDF() to link individual columns to different servers; however, this is not recommended, because none of the automatic behavior of the data window and none of its cooperation with the data server applies to more than one server. Notifications will not be received for servers other than the main server that the window is registered with, and actions such as DataWindow:Delete() and DataWindow:Append() apply to the main server. To link a window to more than one database, use the techniques described in the "GUI Classes" chapter of the Programmer's Guide.
    </remarks>
  </DataColumn.LinkDF>
  <DataColumn.Modified>
    <summary>
      A logical value indicating whether the contents of the current row of this data column has been changed by the user since it was last set. TRUE indicates that it has changed (even if it has not yet been validated or has failed validation); FALSE indicates that it has not.
    </summary>
    <value>A logical value indicating whether the contents of the current row of this data column has been changed by the user since it was last set. TRUE indicates that it has changed (even if it has not yet been validated or has failed validation); FALSE indicates that it has not.</value>
  </DataColumn.Modified>
  <DataColumn.Name>
    <summary>
      A string representing the name of this data column.
    </summary>
    <value>A string representing the name of this data column.</value>
  </DataColumn.Name>
  <DataColumn.NameSym>
    <summary>
      A symbol representing the name of this data column.
    </summary>
    <value>A symbol representing the name of this data column.</value>
  </DataColumn.NameSym>
  <DataColumn.Owner>
    <summary>
      The data browser that owns this data column.
    </summary>
    <value>The data browser that owns this data column.</value>
  </DataColumn.Owner>
  <DataColumn.PerformValidations>
    <summary>
      Perform all the validations defined to this data column's field specification (for example, required, maximum and minimum digits, maximum and minimum value, validation rule) and return the result of the test.
    </summary>
    <returns>
      If any of the validations fail, this method sets the status of the data column appropriately and returns FALSE. Otherwise, it returns TRUE.
    </returns>
  </DataColumn.PerformValidations>
  <DataColumn.PixelWidth>
    <exclude />
  </DataColumn.PixelWidth>
  <DataColumn.Server>
    <summary>
      The data server to which this data column is currently connected, if any.
    </summary>
    <value>The data server to which this data column is currently connected, if any.</value>
  </DataColumn.Server>
  <DataColumn.SetCaption>
    <summary>
      Set the caption for the data column.
    </summary>
    <param name="cText">The text to be used as the caption. If omitted, the data browser uses the caption in the hyperlabel.</param>
    <param name="kAlignment">
      One of the following constants representing the alignment of the caption for the data column:
    </param>
    <remarks>
      <include file="Gui.xml" path="doc/Alignment/*" />
      Setting a blank caption ("") causes the caption of the data column to be displayed with no caption. Setting a null caption causes the caption to be hidden.
      By embedding newline characters in the caption string, the caption field changes height to accommodate multiple lines.
    </remarks>
  </DataColumn.SetCaption>
  <DataColumn.SetModified>
    <summary>
      Mark the current data column, signifying that it has been modified.
    </summary>
    <param name="lModified">Specify TRUE to mark the data column as modified; otherwise, FALSE.</param>
  </DataColumn.SetModified>
  <DataColumn.SetStandardStyle>
    <summary>
      Set the appearance of this data column's caption area.
    </summary>
    <param name="kStyle">
      The style to set, specified as one of the constants below
    </param>
    <remarks>
      <include file="Gui.xml" path="doc/BrowseStyle/*" />
      Tip: To specify more than one style parameter, simply make more than one call
      <note type="tip">DataColumn:SetStandardStyle() can override the DataBrowser:SetStandardStyle() method for individual columns.</note>
    </remarks>
  </DataColumn.SetStandardStyle>
  <DataColumn.SetValue>
    <summary>
      Set the value of the current data column.
    </summary>
    <param name="cNewValue">The new value to be assigned to the data column specified as a string.</param>
    <returns>
      A string representing the current value of the data column.
    </returns>
  </DataColumn.SetValue>
  <DataColumn.Status>
    <summary>
      A hyperlabel that indicates the results of validations or recent actions to this data column.
    </summary>
    <value>A hyperlabel that indicates the results of validations or recent actions to this data column.</value>
    <remarks>
      A hyperlabel that indicates the results of validations or recent actions to this data column.
      If the validation passed or the operation was successful, this value is NULL_OBJECT; if not, it contains information about the cause of the error.
    </remarks>
  </DataColumn.Status>
  <DataColumn.TextColor>
    <summary>
      The text color to be used for the text area of this data column.
    </summary>
    <value>The text color to be used for the text area of this data column.</value>
  </DataColumn.TextColor>
  <DataColumn.TextValue>
    <summary>
      A string representing the value held in the current row of this data column. Note that this string is formatted according to the picture clause held in the FieldSpec object inherited from the associated server field.
    </summary>
    <value>A string representing the value held in the current row of this data column. Note that this string is formatted according to the picture clause held in the FieldSpec object inherited from the associated server field.</value>
  </DataColumn.TextValue>
  <DataColumn.Value>
    <summary>
      The value held in the current row of this data column, in whatever data type is held in the FieldSpec object inherited from the associated server field.
    </summary>
    <value>The value held in the current row of this data column, in whatever data type is held in the FieldSpec object inherited from the associated server field.</value>
  </DataColumn.Value>
  <DataColumn.ValueChanged>
    <summary>
      A logical value indicating whether the data column value has been changed to a "valid" value, since it was last set.
    </summary>
    <value>A logical value indicating whether the data column value has been changed to a "valid" value, since it was last set.</value>
    <remarks>
      A logical value indicating whether the data column value has been changed to a "valid" value, since it was last set. TRUE indicates that it has been changed to a valid value; FALSE indicates that it has not.
    </remarks>
  </DataColumn.ValueChanged>
  <DataColumn.VisualPos>
    <summary>
      Returns the number of the data column with respect to its visual position within a data browser from left to right.
    </summary>
    <value>The number of the data column with respect to its visual position within a data browser from left to right.</value>
    <example>
      The following example shows how DataColumn:VisualPos may be used to save the current layout of a browser to an .INI file:
      <code language="X#">
        METHOD SaveLayout() CLASS MySubForm
        LOCAL wCount AS DWORD
        LOCAL aColumnInfo := {} AS ARRAY
        LOCAL oDataColumn AS DataColumn
        FOR wCount := 1 UPTO SELF:Browser:ColumnCount
        oDataColumn := SELF:Browser:GetColumn( wCount )
        AADD( aColumnInfo, {oDataColumn:NameSym, oDataColumn:VisualPos} )
        NEXT wCount
        SaveSettings( aColumnInfo )
        RETURN NIL
      </code>
    </example>
  </DataColumn.VisualPos>
  <DataColumn.Width>
    <summary>
      The width of this data column in canvas coordinates.
    </summary>
    <value>The width of this data column in canvas coordinates.</value>
  </DataColumn.Width>
  <DataDialog>
    <summary>
      Create a data window that behaves like a modal dialog window (also commonly referred to as a dialog box).
    </summary>
    <remarks>
      Whereas a regular data window is an MDI child window, a data dialog window behaves like a modal dialog window. This means that the user must respond to the window and close it before continuing with the application and that the data dialog window is not resizable.
      The main purpose of this class is to provide a way to create a window for small data entry tasks, such as password entry.
      Note that because the DataDialog class uses DialogWindow (rather than a ChildAppWindow) internally, AppWindow:EnableVerticalScroll() and AppWindow:EnableHorizontalScroll() are just stubs—they do not do anything.
    </remarks>
  </DataDialog>
  <DataDialog.ctor>
    <summary>
      Construct a data dialog window.
    </summary>
    <param name="oOwner">The window that owns the data dialog window. The following window types can be owners: App, ShellWindow, TopAppWindow, ChildAppWindow, DialogWindow, or DataWindow.</param>
    <param name="oSource">The ID of the resource that defines the layout of the data dialog window. If not specified, the window automatically lays itself out when attached to a data server.</param>
    <param name="nResourceID">The resource ID that specifies the location and size of the sub-data window. Specifying this argument creates the new data dialog window as a sub-data window on its owner data window (only data window owners can have sub-data windows). It should refer to a control defined in the resource entity of the owner data window.</param>
    <param name="nDialogStyle">The style for the DataDialog border. Defaults to WS_DLGFRAME.</param>
  </DataDialog.ctor>
  <DataListView>
    <summary>
      Create a data list view as a faster, read-only, standalone control and an alternative to a data browser.
    </summary>
    <remarks>
      A data list view is a "data-ware" list view control which serves as a fast, read-only alternative to a data browser. Together with the list view column control, a data list view can be used inside the Window Editor to "paint" the browse view portion of a data window. It can also be used as a standalone control.
      The DataListView control uses internally a virtual list view, which means that its speed is independent of the total number of records in your database. Additionally, the scrollbar size and position always represents the position in the database correctly.
      The DataListView control relies on the OrderKeyCount(), OrderKeyGoto(), and OrderKeyNo() methods of the associated server. If there is no active order, the DataListView control uses RecCount(), GoTo(), and RecNo() instead. Additionally, the DataListView control has some limitations, depending on the currently active RDD:
      SetFilter is supported for NTX and CDX drivers only.
      SetDeleted(TRUE) is not supported for all RDDs.
      If you want to hide all deleted records, you should use SetDeleted(FALSE) and specify a data server filter condition like:
      <code language="X#">	SetFilter({|| !Deleted()}, "!Deleted()")</code>
      OrderScopes are supported for NTX and CDX drivers only.
      If you want to use a DataListView control as a replacement for a DataBrowser control, set the Browser Inherits From property in the Window Editor to DataListView. The generated code will then reference DataListView.
      <note type="tip">Choosing a DataListView control as a replacement for a DataBrowser control has an additional advantage: your applications will not need the CATO3xxx.DLL support DLLs.</note>
      The DataListView control can also be used as a standalone control that can be placed on any window or dialog. In this case, you have to explicitly assign a data server to the DataListView:Server property.
    </remarks>
  </DataListView>
  <DataListView.ctor>
    <summary>
      Construct a data list view.
    </summary>
    <param name="oOwner">The window that owns the data list view.</param>
    <param name="xID">The unique ID for the data list view (between 1 and 8000).</param>
    <param name="nResourceID">The resource ID of the data list view.</param>
    <param name="oPoint">The origin of the data list view in canvas coordinates.</param>
    <param name="oDimension">The dimension of the data list view in canvas coordinates.</param>
    <param name="kStyle">The style of the data list view.</param>
  </DataListView.ctor>
  <DataListView.DeleteAll>
    <summary>
      Delete all items in a data list view.
    </summary>
    <returns>
      TRUE if all items were deleted successfully; otherwise, FALSE.
    </returns>
  </DataListView.DeleteAll>
  <DataListView.Destroy>
    <summary>
      Provide a method to de-instantiate a DataListView object.
    </summary>
    <remarks>
      This method can be used when a DataListView object is no longer needed. DataListView:Destroy() de-instantiates the DataListView object, and allows you to close and free any resources that were opened or created by the object without waiting for the garbage collector.
    </remarks>
  </DataListView.Destroy>
  <DataListView.FieldGet>
    <summary>
      Return the contents of a specified field of the data server associated with the data list view.
    </summary>
    <param name="nFieldPos">The name, number, or symbol representing the desired field.</param>
    <returns>
      The field's contents. The data type of the return value depends on the data type of the field.
    </returns>
    <remarks>
      By default, the FieldGet() method of the associated server is called. By subclassing DataListView, this functionality can be changed or enhanced. This is the recommended way of creating calculated (virtual) columns with a DataListView control
    </remarks>
  </DataListView.FieldGet>
  <DataListView.Notify>
    <summary>
      Provide an event handler that reflects events that have occurred in the server connected to this data list view.
    </summary>
    <returns>
      NIL, except if NOTIFYINTENTTOMOVE is specified for <paramref name="kNotification" />.
      In this case, the return value is TRUE if successful; otherwise, FALSE.
    </returns>
    <include file="VOSDK.xml" path="doc/commonblocks/notify/*" />
  </DataListView.Notify>
  <DataListView.Owner>
    <summary>
      The owner of this DataListView control.
    </summary>
    <value>The owner of this DataListView control.</value>
  </DataListView.Owner>
  <DataListView.Refresh>
    <summary>
      Force the contents of the data list view to be updated from the data server.
    </summary>
  </DataListView.Refresh>
  <DataListView.Server>
    <summary>
      The data server associated with the data list view.
    </summary>
    <value>The data server associated with the data list view.</value>
  </DataListView.Server>
  <DataListView.Use>
    <summary>
      Associate a data server with the data list view.
    </summary>
    <param name="oNewServer">The data server to be associated with the data list view.</param>
    <returns>
      TRUE, if the server could be assigned successfully; otherwise, FALSE.
    </returns>
    <remarks>
      This method is equivalent to the DataListView:Server assign, which associates a data server with the data list view.
    </remarks>
  </DataListView.Use>
  <DataWindow>
    <summary>
      Create a data window which is capable of interacting intelligently with a data server.
    </summary>
    <remarks>
      Data windows combine the properties and behavior of both child windows and dialog windows, and add data-aware behavior that enables them to interact intelligently with data servers. When connected to a data server, a data window forms a view of the server that allows for direct access and manipulation of the server's data.

      Unlike the other types of windows, a data window takes on different behavior depending on how it is used. It adapts itself to the demands placed on it by its owner, behaving differently depending on the circumstances:
      If Owner Is	Data Window Acts Like
      ChildAppWindow	Modal DialogWindow
      DataWindow	Modal DialogWindow (if no placement is specified) or nested sub-data window (if placement is specified)
      DialogWindow	Modal DialogWindow
      ShellWindow	ChildAppWindow
      TopAppWindow	Modal DialogWindow

      A data window can be placed on a data window in an owner-child relationship (similar to other controls like check boxes and radio buttons). When a data window is placed on another data window in this way, it is referred to as a sub-data window. Note that only a data window can own a sub-data window because it is the only window type of window that can deal with data-related events.
      You can create a data window as a sub-data window when the data window is created. You can optionally specify a third parameter (<paramref name="nResourceID" />), indicating that the new data window should be created as a control on a window by giving its location and size. When placed like a control, the data window hides its border decoration and behaves like a sub-data window. (If this parameter is omitted, the data window is created as a modal DialogWindow, not a sub-data window.) See DataWindow:Init() for details.
      Tip: Instead of newly creating a data window, you may prefer to use the Window Editor's Auto Layout feature which—at the touch of a button—automatically creates controls for every available field in a data window's associated data server(s). See "Using the Window Editor" in the IDE User Guide.

      A data window is connected to a server with the Use() method. When this connection is established, each control on the window is connected to a field in the data server based on matching names: a field named CustName is connected to the control named CustName. The control always reflects the current value of the data in the data server, and assigning a value to a control automatically propagates it to the server.
      Data windows can be associated with data servers in two ways: in a single server or dual server (master detail) relationship.

      The Master-Detail option allows you to link a window to two data servers in a master-detail relationship. In this case, a data window is created for the master server with a nested sub-data window for the detail server.
      The field list presented is taken from the Master data server. The field that you choose is used to perform a SetSelectiveRelation() to the detail server based on its controlling order. If you do not choose a field, the detail window is updated relative to the current record position in the master window.

      A data window can take on two different view modes: form view, which contains individual controls for the data fields and browse view, which contains a spreadsheet-like data browser. The data window can be initially displayed in either mode, and can be switched to the other mode at any time (using the DataWindow:ViewAs() method). Any data window supports both appearances, although the developer can, of course, choose not to provide a way to select one mode or the other.
      The two view modes provide the same set of facilities: the same data linkage facilities, the same display options, the same data manipulation methods. From the perspective of the application, a data window has the same behavior and the same data properties regardless of view mode.

      The standard way of using a data window is to paint its layout in the Window Editor. This produces a resource entity that specifies what controls the window has, and their locations, sizes, captions, and accelerators. It also generates a data window subclass and an Init() method that associates names and further annotation with each control. With such a predefined layout, the window is displayed very quickly and the methods of the window have enough information to act intelligently.

      A data window can also be created without a resource entity. In this case, the layout of controls on the window is automatically generated when the window is connected to a data server. After a layout is automatically generated, the window has exactly the same behavior that it has with a resource-based instantiation.
      If a data window is switched over to a new view mode, and the new mode has not been defined through a resource entity or programmatically, the data window automatically creates a layout based on the characteristics of the connected data server. The new layout picks up all information about fields and controls that is known to the other view; thus, if complex validation rules, prompts, and help have been specified for the individual controls in form view, the columns of the browse view inherit the same properties.

      When a control is connected to a field in a data server, a value entered into the control or assigned to the appropriate name from the program is automatically propagated to the server. Thus, after executing this statement:
      <code language="X#">oCustomerWindow:CustName := x</code>
      the CustName field in the server has the correct value.
      Values are propagated up from the data server to the data window when the server repositions itself, or when another window makes a change. This requires no special action: after executing a Skip() method or assigning a value to a field, every window connected to the server is automatically updated to reflect the change.

      Data entered by the user is automatically validated using the rules of the field specification attached to a control or column. (For more detail on the validation rules provided, see the FieldSpec class.) If data fails the validation test, the data window will not propagate invalid information down to the server or to other windows, nor will it take any action that requires writing the invalid value to the server.
      In addition to the field-specific validations, the system allows the specification of a ValidateRecord() method for the window as a whole, for the purpose of cross-field validation. This method, if provided, is called after all the fields have passed their individual validations.
      The data window also provides for registering controls that are subject to the validation status. Such registered controls are disabled whenever the window's validation status is bad.

      The data window class also provides action methods that correspond to the general capabilities of all data servers: GoTop(), GoTo(), GoBottom(), SkipNext(), SkipPrevious(), Append(), Delete(), and so on. The data window versions of these methods verify the validation status of the controls on the window. If everything is valid, the window invokes the corresponding method of the data server.

      The data window provides built-in facilities for concurrency control, automatically taking and releasing record locks as appropriate. Once the appropriate mode has been selected by assigning one of the available modes to DataWindow:ConcurrencyControl, record movements and changes use the concurrency control facilities of the data server to take and release locks. If taking a lock fails because another user controls the record, the data window action fails.
    </remarks>
  </DataWindow>
  <DataWindow.ctor>
    <summary>
      Construct a data window.
    </summary>
    <param name="oOwner">
      The window that owns the data window. The following window types can be owners:
      ShellWindow, TopAppWindow, ChildAppWindow, DialogWindow, DataDialog, or another DataWindow.
      The behavior of the data window is determined by the type of its owner—see the discussion of
      Adaptive Behavior in the description of this class.
    </param>
    <param name="oSource">
      The ID of the resource that defines the layout of the data window.
      If not specified, the data window automatically lays itself out when attached to a data server.
    </param>
    <param name="nResourceID">
      The resource ID that specifies the location and size of the sub-data window.
      Specifying this argument creates the new data window as a sub-data window on its owner data window
      (only data window owners can have sub-data windows). It should refer to a control defined in the
      resource entity of the owner data window.
      If <paramref name="nResourceID" /> is omitted or if <paramref name="oOwner" /> is not a data window,
      the data window is created as a modal DialogWindow.
    </param>
    <param name="nDialogStyle">** missing parameter documentation **</param>
    <example>
      The following creates a data window and a data server, assigns the server to the window, and then displays the window:
      <code language="X#">
        ...
        oDWCust := DataWindow{oShell,"CustomerWindow"}
        oDWCustOrders := DBServer{SELF,"CustOrders",IDW_CUSTORDERS}
        oDWGeneric := DBServer{SELF}
        oDWGeneric:Use(DBServer{cFileName})
        oDWGeneric:Show()
      </code>
    </example>
  </DataWindow.ctor>
  <DataWindow.Activate>
    <inheritdoc />
  </DataWindow.Activate>
  <DataWindow.AllowServerClose>
    <summary>
      A logical value specifying whether the server is automatically closed with the data window. By default, this is set to TRUE in the DataWindow:Init() method.
    </summary>
    <value>A logical value specifying whether the server is automatically closed with the data window. By default, this is set to TRUE in the DataWindow:Init() method.</value>
  </DataWindow.AllowServerClose>
  <DataWindow.Append>
    <summary>
      Append a blank record to the data server connected to this data window and position the window on this new record.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      When executed successfully, the data server to which the new record was appended sends a NotifyAppend
      message to all of its clients, including this data window.
      DataWindow:Append() can fail for many reasons (for example, data entered in the window fails validation,
      record locks failed because another user controls the data server, or access to the database failed for
      technical reasons). Use the DataWindow:Status property to determine the exact cause of the failure.
      You might also want to check the feasibility of the operation beforehand, using methods like DataWindow:StatusOK().
    </remarks>
  </DataWindow.Append>
  <DataWindow.AutoScroll>
    <summary>
      A data window scrolls automatically to any control which gains focus while tabbing, even if the control is not visible (for example, when the window is resized). By setting AutoScroll to FALSE, this automatic scrolling behavior is blocked.
    </summary>
    <value>A data window scrolls automatically to any control which gains focus while tabbing, even if the control is not visible (for example, when the window is resized). By setting AutoScroll to FALSE, this automatic scrolling behavior is blocked.</value>
  </DataWindow.AutoScroll>
  <DataWindow.Background>
    <summary>
      The background brush currently in use by this data window.
    </summary>
    <value>
      The background brush currently in use by this data window.
    </value>
    <remarks>
      A window's background brush is used by CanvasErase() and in handling Expose events. Assigning a new background brush has no effect until the data window (or portion of the data window) is redrawn. If a data window was partially covered and is then fully exposed, only the covered part of the data window is redrawn and only that part gets the new background.
    </remarks>
  </DataWindow.Background>
  <DataWindow.Browser>
    <summary>
      The DataBrowser object to use when this data window is displayed in browse view.
    </summary>
    <value>The DataBrowser object to use when this data window is displayed in browse view.</value>
    <remarks>
      The DataBrowser object to use when this data window is displayed in browse view.
      A data window does not necessarily need to own a particular data browser. If a data window has no browser and the application chooses to view it in browse mode, X# automatically creates a browser for the window, populating it with one column for each field in the server. The column headings are taken from the server, using the hyperlabels of its fields.
    </remarks>
  </DataWindow.Browser>
  <DataWindow.BrowserClass>
    <summary>
      A symbol specifying the class used for the data window's browse mode. Valid values are: #DATABROWSER, #DATALISTVIEW, or any user-defined class.
      The default is #DATABROWSER.
    </summary>
    <value>
      A symbol specifying the class used for the data window's browse mode. Valid values are: #DATABROWSER, #DATALISTVIEW, or any user-defined class.
      The default is #DATABROWSER.
    </value>
  </DataWindow.BrowserClass>
  <DataWindow.ButtonClick>
    <summary>
      Provide a method that is invoked when a check box, push button, or radio button is clicked with the mouse.
    </summary>
    <param name="oControlEvent">The ControlEvent object that describes which button was clicked.</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      Button click events are propagated to the data window's owner the same way as menu events.
      For an in-depth discussion on command event propagation, refer to the Programmer's Guide.
      You must supply the code to turn a radio button on (and all the other radio buttons off)
      when a user clicks on a radio button. Similarly, you must also be sure to invert the state of a check box when it is clicked.
    </remarks>
  </DataWindow.ButtonClick>
  <DataWindow.Cancel>
    <summary>
      Discard all information entered in this data window and close the window.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      The "cancel" operation is very clear and easily understood and might be profitably used on
      data windows when they are created as MDI children (unconventional or not).
      Note that a user might be unclear on exactly what transactions are discarded.
      For example, if several records have been modified, the default implementation
      of DataWindow:Cancel() discards changes only to the current record.
      You might want to label the button or menu command something else or provide a more comprehensive implementation.
      <note type="tip">
        DataWindow:Cancel() disconnects itself from the data server using
        DataServer:UnregisterClient() and tells the server that it can close itself if it has no other registered clients.
        Explicitly forcing the server to close from a window is not recommended, since this can create future problems.
        Modifications to the application can attach other clients to the server, and any one window should not
        disable other windows.
      </note>
    </remarks>
  </DataWindow.Cancel>
  <DataWindow.CanvasErase>
    <summary>
      Erase the current canvas area of this data window and repaint it using either the background brush or the system's default background color.
    </summary>
  </DataWindow.CanvasErase>
  <DataWindow.ChangeFont>
    <summary>
      Change the font used by this datawindow.
    </summary>
    <param name="oFont">The new font to be used.</param>
    <param name="lUpdate">
      Specify TRUE to resize and reposition all controls in this dialog window and change their fonts; otherwise, FALSE.
      If omitted, the default is FALSE.
    </param>
    <returns>
      The font previously assigned to the datawindow.
    </returns>
  </DataWindow.ChangeFont>
  <DataWindow.CheckStatus>
    <summary>
      Test the information currently displayed in the controls in this data window to see if it passes all validation
      rules defined to the connected server.
    </summary>
    <returns>
      TRUE if the window passes all validation checks; otherwise, FALSE.
    </returns>
    <remarks>
      This method invokes DataWindow:StatusOK() which validates the information for each control in the window.
      If a validation check fails, use the DataWindow:Status property to determine the exact cause of the failure.
    </remarks>
  </DataWindow.CheckStatus>
  <DataWindow.Clear>
    <summary>
      Clear the current selection in this data window.
    </summary>
    <remarks>
      If the data window is in form view, the contents of the edit control is cleared; if in browse view, the contents
      of the selected cell(s) or part of a cell in the data browser is cleared.
    </remarks>
  </DataWindow.Clear>
  <DataWindow.ClearRelations>
    <summary>
      Clear all relations defined to this data window's server.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      In data windows, relations are used to manage relationships between windows that are linked to the same data server.
      Clearing a relation removes the link between the windows; in actuality, it clears the relations set for the data server to which this and any other windows are connected. Relations are set using DataWindow:SetRelation() and DataWindow:SetSelectiveRelation().
    </remarks>
  </DataWindow.ClearRelations>
  <DataWindow.ClipperKeys>
    <summary>
      A logical value indicating that the Clipper navigation keys (i.e., the Direction and Return keys) are to be used for this data window (TRUE if yes, FALSE if no).
    </summary>
    <value>A logical value indicating that the Clipper navigation keys (i.e., the Direction and Return keys) are to be used for this data window (TRUE if yes, FALSE if no).</value>
  </DataWindow.ClipperKeys>
  <DataWindow.Close>
    <summary>
      Invoked just as the data window is about to close.
    </summary>
    <param name="oEvent">An event required to maintain the protocol that all event handlers have exactly one event as their argument.</param>
    <seealso cref="T:VO.Event" />
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This method is not used to close a data window. Use DataWindow:Hide() to make a data window disappear from view,
      but remain available for re-opening; use DataWindow:Destroy() to permanently destroy the data window.
    </remarks>
  </DataWindow.Close>
  <DataWindow.Commit>
    <summary>
      Force all pending updates to this data window's server to be permanently written to disk.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method also makes the changes visible to other users on other machines on a network, as well as to other
      applications on the same machine. Prior to DataWindow:Commit(), the changes are guaranteed to be visible
      only to other data windows connected to the same server within the same application.
      DataWindow:Commit() can fail for many reasons, from a lack of capability in the server to lock conflicts to
      technical problems, such as network crashes. Use the DataServer:Status property to determine the exact cause of the failure.
      You should also note that there is no guarantee that changes which have not been committed can be rolled back.
      The rollback capabilities depend on the particular data server implementation (for example, SQLSelect can usually
      do it—depending on the particular SQL database in use—but DBServer cannot).
      For details, please refer to the documentation on the specific server you intend to use.
    </remarks>
  </DataWindow.Commit>
  <DataWindow.ConcurrencyControl>
    <summary>
      A constant, identifying the mode of automatic concurrency control for this data window, determining when and how records are locked and released:
    </summary>
    <value>A constant, identifying the mode of automatic concurrency control for this data window, determining when and how records are locked and released:</value>
    <remarks>
      One of the following constants, identifying the mode of automatic concurrency control for this data window, determining when and how records are locked and released:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>CCNONE</term>
          <description>The data window provides no automatic record locking; the application is required to do all locking explicitly. </description>
        </item>
        <item>
          <term>CCSTABLE</term>
          <description>The record that the window is sitting on is always kept locked. Note that when in browse view, the row that the cursor is on represents the current record.</description>
        </item>
        <item>
          <term>CCOPTIMISTIC</term>
          <description>
            No locks are maintained continuously except when appending—the record just appended is locked, and the lock is only
            released when moving off the record or explicitly calling the DataServer or DBServer Unlock() method.
            For all other records, the record is reread from disk before any update is done. This is the <b>default</b>.
          </description>
        </item>
        <item>
          <term>CCREPEATABLE</term>
          <description>All records that have been read are maintained locked. The user is guaranteed that when moving back among previously viewed data, they are unchanged.</description>
        </item>
        <item>
          <term>CCFILE</term>
          <description>All the records in the entire set provided by the server are locked throughout. This is not very practical for windows associated with all the records of a server, since it would correspond to a file lock. It is intended to be used in conjunction with method DataWindow:SetSelectiveRelation(). </description>
        </item>
      </list>
    </remarks>
  </DataWindow.ConcurrencyControl>
  <DataWindow.ContextMenu>
    <summary>
      The context menu attached to the window
    </summary>
    <value>The context menu attached to the window</value>
    <remarks>
      This can be used in two ways.
      The DataWindow and its Browser usually share the same ContextMenu and in this situation the assign can be used like this –
      <code language="X#">
        <paramref name="oDataWindow" />:ContextMenu := MyContextMenu{}
      </code>
      If you want the context menus to be different you can now use code like this –
      <code language="X#">
        <paramref name="oDataWindow" />:[ContextMenu,#FormView] := MyContextMenu{}
      </code>
      to just set the FormView context menu, and this –
      <code language="X#">
        <paramref name="oDataWindow" />:[ContextMenu,#BrowseView] := MyOtherContextMenu{}
      </code>
      to set the BrowseView context menu.
    </remarks>
  </DataWindow.ContextMenu>
  <DataWindow.ControlFocusChange>
    <summary>Provide a method that is invoked when the input focus changes to or from a control.</summary>
    <param name="oControlFocusChangeEvent" >The ControlFocusChangeEvent object that identifies which control generated the ControlFocusChangeEvent object and whether it has just gained or lost the keyboard focus. </param>
    <remarks>
      If ControlFocusChange() is used to validate a control (and also set the focus to another control),
      Control:SetFocus() should not be called until another control has received the focus.
      In complex dialog windows that contain many edit controls, it makes sense to grab the edit
      control's text when the focus is changing so that other controls can be updated with it if necessary.
      See the ButtonClick() method for an example of similar syntax to be used in this method.
      Note that all controls are passed through this method, not only SingleLineEdit and MultiLineEdit controls.
      If looking to control Combobox selections, then the ListBoxSelect() callback method should be reviewed.
    </remarks>
    <seealso cref="T:VO.ControlFocusChangeEvent" />
  </DataWindow.ControlFocusChange>
  <DataWindow.Controls>
    <exclude />
  </DataWindow.Controls>
  <DataWindow.Copy>
    <summary>
      Copy the current selection in this data window to the clipboard.
    </summary>
    <remarks>
      If the data window is in form view, the contents of the edit control is copied; if in browse view,
      the contents of the selected cell(s) or part of a cell in the data browser is copied.
    </remarks>
  </DataWindow.Copy>
  <DataWindow.CurrentControl>
    <exclude />
  </DataWindow.CurrentControl>
  <DataWindow.CurrentView>
    <summary>
      A symbol representing the view mode of the data window, as #BrowseView or #FormView.
    </summary>
    <value>A symbol representing the view mode of the data window, as #BrowseView or #FormView.</value>
  </DataWindow.CurrentView>
  <DataWindow.Cut>
    <summary>
      Delete the current selection in this data window and copy it to the clipboard.
    </summary>
    <remarks>
      If the data window is in form view, the contents of the edit control is cut; if in browse view, the contents of the selected cell(s) or part of a cell in the data browser is cut.
    </remarks>
  </DataWindow.Cut>
  <DataWindow.DeActivate>
    <inheritdoc />
  </DataWindow.DeActivate>
  <DataWindow.DeactivateAllOLEObjects>
    <inheritdoc />
  </DataWindow.DeactivateAllOLEObjects>
  <DataWindow.DeferUse>
    <summary>
      A logical value specifying whether the Use() operation for connecting the data window to the associated server should be deferred until the data window is first displayed.
    </summary>
    <value>A logical value specifying whether the Use() operation for connecting the data window to the associated server should be deferred until the data window is first displayed.</value>
    <remarks>
      A logical value specifying whether the Use() operation for connecting the data window to the associated server should be deferred until the data window is first displayed. This is useful, for example, in a situation where multiple data windows build up pages for a tab control. The default is FALSE.
    </remarks>
  </DataWindow.DeferUse>
  <DataWindow.Delete>
    <summary>
      Delete the current record in the attached server and update the window based on the change.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      When executed successfully, the data server from which the record was deleted sends a NotifyDelete message to all of its clients, including this data window.
      With some servers (notably DBServer), a deleted record is not removed from the server but is simply marked as deleted. Marked records are removed only when the file is packed, and until such time can be recalled. (With DBServer, the current setting of the SetDeleted() function affects whether deleted records are visible.) Changes that have been made to fields are recorded in the record before it is deleted; if the field is subsequently recalled, it correctly reflects any changes made before the delete operation.
      <note type="tip">DataWindow:Delete() advances to the next record (if SetDeleted() is TRUE) after the deletion takes place, unlike DBServer:Delete() which does not.</note>
      DataWindow:Delete() does not check validation status before allowing a delete operation. If the window contains invalid data, it is discarded and the delete operation is completed. If you would prefer to validate before deletion, use DataWindow:DeleteValidated().
      <note type="tip">Do not confuse clearing with deleting. Clearing a structure (such as a record or field) removes its contents. Deleting a structure, on the other hand, removes the actual structure.</note>
    </remarks>
  </DataWindow.Delete>
  <DataWindow.DeleteValidated>
    <summary>
      Delete the current record in the attached server only if it passes its validation rules and update the window based on the change.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      When executed successfully, the data server from which the record was deleted sends a NotifyDelete message to all of its clients, including this data window.
      This method checks validation status before allowing a delete operation. If the window contains invalid data, the user is asked if the data should be discarded or corrected before the delete operation is continued. If this behavior is not desired (perhaps because the application does not use recall or the window is to be used only with servers that do not support recall of deleted records), use DataWindow:Delete().
      With some servers (notably DBServer), a deleted record is not removed from the server but is simply marked as deleted. Marked records are removed only when the file is packed, and until such time can be recalled. (With DBServer, the current setting of the SetDeleted() function affects whether deleted records are visible.) Changes that have been made to fields are recorded in the record before it is deleted; if the field is subsequently recalled, it correctly reflects any changes made before the delete operation.
      <note type="tip">Do not confuse clearing with deleting. Clearing a structure (such as a record or field) removes its contents. Deleting a structure, on the other hand, removes the actual structure.</note>
    </remarks>
  </DataWindow.DeleteValidated>
  <DataWindow.Destroy>
    <summary>
      Free memory resources allocated for a window and its derived objects.
    </summary>
    <remarks>
      This method immediately frees resources for DataWindow objects created explicitly in your application. DataWindow:Destroy() also takes care of resources allocated to derived classes and deallocates them in the necessary order.
    </remarks>
  </DataWindow.Destroy>
  <DataWindow.DisableConditionalControls>
    <summary>
      Disable those controls in this data window that have been registered with RegisterConditionalControls().
    </summary>
    <remarks>
      This method disables all controls that have been registered with DataWindow:RegisterConditionalControls(), which registers controls as being subject to validation. It is automatically called by DataWindow:Prevalidate() whenever the window fails validation. This way, all registered controls are guaranteed to be unavailable whenever the window is known to be in an invalid state.
    </remarks>
  </DataWindow.DisableConditionalControls>
  <DataWindow.Dispatch>
    <inheritdoc />
  </DataWindow.Dispatch>
  <DataWindow.Draw>
    <summary>
      Display a Draw object on this data window.
    </summary>
    <param name="oDrawObject">The object to be drawn.</param>
    <param name="aoDrawObject">The array of objects to be drawn.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      A Draw object is drawn by placing the device context or presentation space into the Draw object and then calling the Draw object's method Draw(). This is the only valid way of drawing a Draw object on a window.
    </remarks>
  </DataWindow.Draw>
  <DataWindow.EditChange>
    <summary>
      Provide a method that is invoked when the text in an edit control is changed.
    </summary>
    <param name="oControlEvent">The ControlEvent object that describes which edit control was changed.</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This method is called every time the contents of an edit control is changed.
    </remarks>
  </DataWindow.EditChange>
  <DataWindow.EnableConditionalControls>
    <summary>
      Enable those controls that have been registered with RegisterConditionalControls().
    </summary>
    <remarks>
      This method enables all controls that have been registered with DataWindow:RegisterConditionalControls(), which registers controls as being subject to validation. It is automatically called by DataWindow:Prevalidate() whenever the window's validation status is OK. This way, all registered controls are guaranteed to be available whenever the window is known to be in a valid state.
    </remarks>
  </DataWindow.EnableConditionalControls>
  <DataWindow.EnableDragDropClient>
    <inheritdoc />
  </DataWindow.EnableDragDropClient>
  <DataWindow.EnableStatusBar>
    <inheritdoc />
  </DataWindow.EnableStatusBar>
  <DataWindow.EnableToolTips>
    <inheritdoc />
  </DataWindow.EnableToolTips>
  <DataWindow.Error>
    <summary>
      Provide a method for handling error conditions raised during data window processing.
    </summary>
    <param name="oErrorObj">An Error object describing the error condition.</param>
    <remarks>
      <note type="tip">This is an event handler and is automatically called by other methods; the developer does not normally need to call the DataWindow:Error() method, but might want to override it.</note>
    </remarks>
  </DataWindow.Error>
  <DataWindow.Expose>
    <summary>
      Provide a method that is invoked whenever part of the data window needs repainting.
    </summary>
    <param name="oExposeEvent">The ExposeEvent object that describes which area of the data window needs repainting.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This is one of the most important event handlers. A data window requires repainting when the data window:
      <list type="bullet">
        <item>Is partially uncovered by another window</item>
        <item>Is first shown</item>
        <item>Increases in size</item>
        <item>Is being restored after being iconized</item>
        <item>The data window should retain enough information to redraw the screen as it was (or as it should be).</item>
      </list>
      An ExposeEvent is also triggered by calling Repaint() or Update(); you should not call Repaint() or Update() during the Expose().
    </remarks>
  </DataWindow.Expose>
  <DataWindow.FIELDGET>
    <summary>
      Retrieve the current value of the indicated control in this data window (and the data server field associated with this control, if any).
    </summary>
    <param name="uFieldID">The name, number, or symbol representing the desired field.</param>
    <returns>
      The field's contents. The data type of the return value depends on the data type of the field.
    </returns>
    <remarks>
      In data windows, controls (such as edit controls and check boxes) can be linked to the fields in the connected data server. Since the name of the control and the field are the same, FieldGet() can also be used to retrieve a control that is not connected to a server.
    </remarks>
  </DataWindow.FIELDGET>
  <DataWindow.FIELDPUT>
    <summary>
      Set the value of the control in this data window (and the data server field associated with this control, if any).
    </summary>
    <param name="uFieldId">The name, number, or symbol representing the field that is referenced.</param>
    <param name="uNewValue">The value to be assigned to the field. The data type of this value must match the data type of the field.</param>
    <returns>
      The newly assigned value if the operation was successful; otherwise, NIL.
    </returns>
    <remarks>
      When executed successfully, the data server that received the updated value sends a NotifyFieldChange message to all of its clients, including this data window.
      In data windows, controls (such as edit controls and check boxes) can be linked to the fields in the connected data server.
    </remarks>
  </DataWindow.FIELDPUT>
  <DataWindow.FocusChange>
    <summary>
      Provide a method that is invoked when the input focus changes from the current data window to another window (or vice versa).
    </summary>
    <param name="oFocusChangeEvent">The FocusChangeEvent object that identifies whether the focus is being gained or lost.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      If your data window uses cursors, you should hide the data window's cursor when the focus is changed to a different data window, and then show the cursor when the data window receives focus again. This should be used in conjunction with the Activate() and Deactivate() event handlers.
    </remarks>
    <example>
      This example demonstrates how FocusChange() displays the cursor at the specified cursor position when focus is gained. If the focus is lost, the cursor is hidden:
      <code language="X#">
        METHOD FocusChange(oFocusChangeEvt) CLASS MyDataWindow
        IF oFocusChangeEvt:GotFocus    // Gaining focus
        oMyCursor:Show()
        oMyCursor:ChangePos(oMyCursorPos)
        ELSE           // Losing focus
        oMyCursorPos := oMyCursor:GetPos()
        oMyCursor:Hide()
        ENDIF
      </code>
    </example>
  </DataWindow.FocusChange>
  <DataWindow.Foreground>
    <summary>
      The foreground brush currently in use by this data window.
    </summary>
    <value>The foreground brush currently in use by this data window.</value>
  </DataWindow.Foreground>
  <DataWindow.GetAllChildren>
    <inheritdoc />
  </DataWindow.GetAllChildren>
  <DataWindow.GoBottom>
    <summary>
      Position the data server connected to this data window on the last logical record and update the window based on the change.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      When executed successfully, the data server sends a NotifyGoBottom message to all of its clients, including this data window.
      DataWindow:GoBottom() can fail for many reasons, from a lack of capability in the server to lock conflicts to technical problems, such as network crashes. Use the DataServer:Status property to determine the exact cause of the failure.
      Note also that DataWindow:GoBottom(), like all repositioning operations, is subject to validation—if the current data in the window fails validation, it cannot be written out and the move is refused.
    </remarks>
  </DataWindow.GoBottom>
  <DataWindow.GoTo>
    <summary>
      Position the data server connected to this data window on a specified record number and update the window based on the change.
    </summary>
    <param name="nRecNo">The record number to which the data window should be positioned.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      When executed successfully, the data server sends a NotifyRecordChange message to all of its clients, including this data window.
      DataWindow:GoTo() can fail for many reasons, from a lack of capability in the server to lock conflicts to technical problems, such as network crashes. Use the DataServer:Status property to determine the exact cause of the failure.
      Note also that DataWindow:GoTo(), like all repositioning operations, is subject to validation—if the current data in the window fails validation, it cannot be written out and the move is refused.
    </remarks>
  </DataWindow.GoTo>
  <DataWindow.GoTop>
    <summary>
      Position the data server connected to this data window on the first logical record and update the window based on the change.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      When executed successfully, the data server sends a NotifyGoTop message to all of its clients, including this data window.
      DataWindow:GoTop() can fail for many reasons, from a lack of capability in the server to lock conflicts to technical problems, such as network crashes. Use the DataServer:Status property to determine the exact cause of the failure.
      Note also that DataWindow:GoTop(), like all repositioning operations, is subject to validation—if the current data in the window fails validation, it cannot be written out and the move is refused.
    </remarks>
  </DataWindow.GoTop>
  <DataWindow.HelpRequest>
    <summary>
      Provide a method that is invoked when the user requests help from the application using one of the available context-sensitive help mechanisms.
    </summary>
    <param name="oHelpRequestEvent">The HelpRequestEvent object that describes which item help is being requested for.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This event handler is invoked only if the help mechanism has been enabled for the current data window (or one of its owners). The help mechanism is enabled by assigning a HelpDisplay object to the windows HelpDisplay property.
      The default implementation of this event handler is to display the help topic that is associated with the control, menu command, or window region with focus when the HelpRequestEvent was generated. This is accomplished using HelpDisplay:Show(<paramref name="cKeyword" />), where <paramref name="cKeyword" /> is either a HyperLabel:HelpContext property or a default keyword generated by this event handler in cases where a hyperlabel is not available.
      If there is no hyperlabel for an item, the keyword generated is as follows:
      A HELPCONTROL request generates the keyword Control_xxxx, where xxxx is the numeric ID of the control, in decimal. For example, an OK push button might generate the keyword Control_101.
      A HELPMENU request generates the keyword Menu_xxxx, where xxxx is the "cleaned" text of the menu command. The cleaned text has all leading and trailing spaces and the ampersand character (&amp;) removed. In addition, all sequences of spaces are replaced by a single underscore, and the string is truncated at the first tab character.

      For example, the keyword generated for the menu command:
      Save &amp;As\tF3
      is
      Menu_Save_As
      A HELPWINDOW request generates one of the keywords listed in the table below, depending on the window region that has focus.
      Keyword	Window Region
      Window_Border	Border
      Window_Caption	Title bar
      Window_MaxBox	Maximize button
      Window_MinBox	Minimize button
      Window_SysMenuBox	System menu button
      Window_Unknown	Any area of the window not explicitly identified in this table
      Window_WindowCanvas	Canvas area

      <note type="tip">If the Window_Unknown keyword is generated, the default behavior of HelpRequest() is to display the Contents topic as defined in the HelpDisplay (that is, HelpDisplay:Show("HelpIndex")).</note>

      If a HELPWINDOW request is received, while DataWindow:HelpContext is defined, DataWindow:HelpRequest() uses the HelpContext property, regardless of the window region that has focus.
      Refer to the "GUI Classes" chapter in the Programmer's Guide for more information on programming an online help system for your application.
    </remarks>
  </DataWindow.HelpRequest>
  <DataWindow.Hide>
    <summary>
      Hide this data window so it is not visible.
    </summary>
    <remarks>
      The data window remains hidden from display until the Show() method is called.
    </remarks>
  </DataWindow.Hide>
  <DataWindow.HorizontalScroll>
    <summary>
      Provide a method that is invoked when a horizontal scroll bar is scrolled.
    </summary>
    <param name="oScrollEvent">The ScrollEvent object that describes the scroll type and new position.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The default behavior for this event handler is to update the thumb position of the scrollbar; this can be changed using your own implementation of the handler. This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects. If the application has vertical scroll bars, use a WindowVerticalScrollBar event handler.
    </remarks>
  </DataWindow.HorizontalScroll>
  <DataWindow.HorizontalSlide>
    <inheritdoc />
  </DataWindow.HorizontalSlide>
  <DataWindow.HorizontalSpin>
    <inheritdoc />
  </DataWindow.HorizontalSpin>
  <DataWindow.InsertObject>
    <summary>
      Use the standard Insert Object dialog to insert an OLE object into the focused OLEObject of the data window.
    </summary>
    <remarks>
      DataWindow:InsertObject() displays the standard Insert Object dialog and allows the user to insert an OLE object into an OLEObject container, which currently must have the input focus.
    </remarks>
  </DataWindow.InsertObject>
  <DataWindow.IsDialog>
    <exclude />
  </DataWindow.IsDialog>
  <DataWindow.KeyDown>
    <summary>
      This method is inherited from the Window class but does not apply to DataWindow.
    </summary>
  </DataWindow.KeyDown>
  <DataWindow.KeyUp>
    <summary>
      This method is inherited from the Window class but does not apply to DataWindow.
    </summary>
  </DataWindow.KeyUp>
  <DataWindow.LastFocus>
    <exclude />
  </DataWindow.LastFocus>
  <DataWindow.LineTo>
    <summary>
      Draw a line on this data window (using the current pen) from the current pen position to a specified point.
    </summary>
    <param name="uPoint">The position where the line should end, in canvas coordinates, or an array of points, in canvas coordinates, where the line should end, in which case DataWindow:LineTo() acts like a polyline method.</param>
    <param name="oPoint">The position where the line should end, in canvas coordinates, or an array of points, in canvas coordinates, where the line should end, in which case DataWindow:LineTo() acts like a polyline method.</param>
    <remarks>
      The current pen position is updated to the line's ending position (as specified by <paramref name="oPoint" /> or <paramref name="aoPoint" /> ).
    </remarks>
  </DataWindow.LineTo>
  <DataWindow.Links>
    <summary>
      Display the standard Links dialog.
    </summary>
    <remarks>
      DataWindow:Links() displays the standard Links dialog, allowing the user to manage all linked OLE objects.
    </remarks>
  </DataWindow.Links>
  <DataWindow.ListBoxClick>
    <summary>
      Provide a method that is invoked when an item in a list box owned by this data window is double-clicked.
    </summary>
    <param name="oControlEvent">The ControlEvent object that describes which list box contained the item that is double-clicked.</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </DataWindow.ListBoxClick>
  <DataWindow.ListBoxSelect>
    <summary>
      Provide a method that is invoked when an item in a list box owned by this data window is clicked.
    </summary>
    <param name="oControlEvent">The ControlEvent object that describes which list box contained the item that was clicked.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <seealso cref="T:VO.ControlEvent" />
  </DataWindow.ListBoxSelect>
  <DataWindow.MouseButtonDown>
    <inheritdoc />
  </DataWindow.MouseButtonDown>
  <DataWindow.MoveTo>
    <summary>
      Move the current pen to a point on the data window's canvas area.
    </summary>
    <param name="oPoint">The position of the pen, in canvas coordinates.</param>
    <returns>
      A point representing the previous location of the pen, in canvas coordinates.
    </returns>
    <remarks>
      The pen location may not be remembered between event handlers.
    </remarks>
  </DataWindow.MoveTo>
  <DataWindow.Notify>
    <summary>
      An event handler that reflects events that have occurred in the server connected to this data window.
      <br />Important! Notify() is automatically called by the server, and should normally not be called by application code.
    </summary>
    <returns>
      SELF, except if NOTIFYINTENTTOMOVE is specified for <paramref name="kNotifyName" />. In this case, the return value is TRUE if successful; otherwise, FALSE.
    </returns>
    <include file="VOSDK.xml" path="doc/commonblocks/notify/*" />
  </DataWindow.Notify>
  <DataWindow.OK>
    <summary>
      Accept all information entered in this data window and close the window.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method checks the validation status of the window. If the data is valid and is correctly downloaded to the data server, it forces a commitment to the server and then closes the window.
      The "OK" operation is very clear and easily understood and might be profitably used on data windows used as MDI children (unconventional or not).
      Note that a user might be confused about exactly what information is accepted (for example, in a complex data window with nested windows). If there is any uncertainty, you might consider labeling a button or menu command with something more explicit.
      <note type="tip">DataWindow:OK() disconnects itself from the data server using DataServer:UnregisterClient() and tells the server that it can close itself if it has no other registered clients. Explicitly forcing the server to close from a window is not recommended, since this can create future problems. Modifications to the application can attach other clients to the server, and any one window should not disable other windows.</note>
    </remarks>
  </DataWindow.OK>
  <DataWindow.OLEInPlaceActivate>
    <inheritdoc />
  </DataWindow.OLEInPlaceActivate>
  <DataWindow.OLEInPlaceDeactivate>
    <inheritdoc />
  </DataWindow.OLEInPlaceDeactivate>
  <DataWindow.Origin>
    <summary>
      The point representing the new location of this data window, in the canvas coordinates of its owner.
    </summary>
    <value>The point representing the new location of this data window, in the canvas coordinates of its owner.</value>
    <example>
      The following example sets the origin of a data window object:
      <code language="X#">oDW:Origin := Point{nLeft,nBottom}</code>
    </example>
  </DataWindow.Origin>
  <DataWindow.Owner>
    <summary>
      The owner of the data window, which itself will be a Window object.
    </summary>
    <value>The owner of the data window, which itself will be a Window object.</value>
  </DataWindow.Owner>
  <DataWindow.OwnerServer>
    <exclude />
  </DataWindow.OwnerServer>
  <DataWindow.PaintBoundingBox>
    <summary>
      Paint a rectangular area in the data window using a specified painting method.
    </summary>
    <param name="oBB">The bounding box (group or character box) representing the data window area to be painted, in canvas coordinates.</param>
    <param name="kPM">The constant that represents how the data window area is painted:</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>PAINTFILL</term>
          <description>Fills the entire rectangle using the currently selected brush. This is the default.</description>
        </item>
        <item>
          <term>PAINTFRAME</term>
          <description>Frames the entire rectangle using the currently selected pen</description>
        </item>
        <item>
          <term>PAINTINVERT</term>
          <description>Inverts the entire rectangle</description>
        </item>
      </list>
    </remarks>
  </DataWindow.PaintBoundingBox>
  <DataWindow.Paste>
    <summary>
      Replace the current selection in this data window with the contents of the clipboard.
    </summary>
    <remarks>
      If the data window is in "form" view, the contents of the edit control is replaced with the contents of the clipboard; if in "browse" view, the contents of the selected cell(s) or part of a cell is replaced.
    </remarks>
  </DataWindow.Paste>
  <DataWindow.PasteSpecial>
    <summary>
      Use the standard Paste Special dialog to insert an OLE object into the focused OLEObject of the data window.
    </summary>
    <remarks>
      DataWindow:PasteSpecial() displays the standard Paste Special dialog and allows the user to insert an OLE object from the Clipboard into an OLEObject container, which currently must have the input focus.
    </remarks>
  </DataWindow.PasteSpecial>
  <DataWindow.Pointer>
    <summary>
      The pointer used by the data window to represent the mouse when it enters the window.
    </summary>
    <value>The pointer used by the data window to represent the mouse when it enters the window.</value>
  </DataWindow.Pointer>
  <DataWindow.PreValidate>
    <summary>
      Called after any status change in this data window to allow controls and menu commands to be enabled/disabled based on the current validation status.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This method provides some of the functionality of the WHEN clause in classical Xbase @...SAY...GET statements. However, since the GUI approach does not enforce a rigid sequence of data entry but allows the user to move from control to control at random, the logic of enabling and disabling controls must be different.
      Instead of checking a condition when focus switches into the control (this is too late, a user with a mouse is already on the new control), the system must keep checking on every significant event.
      DataWindow:Prevalidate() provides some automatic handling of this type of validation (through DataWindow:RegisterConditionalControls()), but it also allows you to insert custom logic by overriding the method.
      The standard action in DataWindow:Prevalidate() is to call DataWindow:EnableConditionalControls(); if problems exist, it calls DataWindow:DisableConditionalControls(). DataWindow:Prevalidate() is called after the application of the standard validation, allowing the user to replace the default handling, upon success or failure of validation.
    </remarks>
  </DataWindow.PreValidate>
  <DataWindow.PreventAutoLayout>
    <summary>
      A logical value indicating that the AutoLayout behavior of the data window is blocked (TRUE if yes, FALSE if no). An empty data window does not create controls automatically when it first uses a new data server.
    </summary>
    <value>A logical value indicating that the AutoLayout behavior of the data window is blocked (TRUE if yes, FALSE if no). An empty data window does not create controls automatically when it first uses a new data server.</value>
  </DataWindow.PreventAutoLayout>
  <DataWindow.QueryClose>
    <summary>
      Provide a method that is invoked just before the data window closes to confirm if the application really wants to close the window.
    </summary>
    <param name="oQCE">The Event object that describes which data window is about to be closed.</param>
    <seealso cref="T:VO.Event" />
    <returns>
      TRUE if the data window is to be closed; otherwise, FALSE.
    </returns>
    <remarks>
      <br /><include file="Gui.xml" path="doc/Callback/*" />
      <note type="tip">If you reimplement this method in your subclass, it is recommended that you first call SUPER:QueryClose() within the method to obtain its default behavior.</note>
      When a user tries to close an application by selecting the Close menu command from a system menu (or by using another method to end the session), the system calls each data window's QueryClose() event handler.
    </remarks>
  </DataWindow.QueryClose>
  <DataWindow.RadioGroups>
    <exclude />
  </DataWindow.RadioGroups>
  <DataWindow.RegisterConditionalControls>
    <summary>
      Register a control in this data window as being subject to validation status and hence automatically dimmed whenever the window is in an invalid state.
    </summary>
    <param name="oCC">The control to be registered.</param>
    <remarks>
      Conditional controls allow the developer to register several controls as subject to validation. This means that when the window fails validation, these controls are automatically disabled; when the window's status is OK, they are automatically enabled again.
      Controls that have been registered are automatically enabled or disabled—depending on validation status—by DataWindow:Prevalidate(), which is called on any status change in the window.
      In a practical data entry window, all the buttons would be registered and conditionally disabled—SkipNext, SkipPrevious, GoTop, GoBottom, Insert, Delete, OK—except for Cancel, which discards the invalid changes and hence should always be available.
    </remarks>
  </DataWindow.RegisterConditionalControls>
  <DataWindow.RePaint>
    <summary>
      Send an ExposeEvent to repaint the data window's canvas area.
    </summary>
  </DataWindow.RePaint>
  <DataWindow.RepaintBoundingBox>
    <summary>
      Repaint a rectangular area in the data window.
    </summary>
    <param name="oBB">The bounding box (group or character box) representing the data window area to be repainted, in canvas coordinates.</param>
    <remarks>
      This method should be avoided within an Expose() event handler. If it is used, make sure the application does not fall into an infinite loop.
    </remarks>
  </DataWindow.RepaintBoundingBox>
  <DataWindow.Resize>
    <summary>
      Provide a method that is invoked when the data window changes size.
    </summary>
    <param name="oResizeEvent">The ResizeEvent object that describes the new dimensions of the data window canvas area.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      In the Resize() event handler, calling DataWindow:Size should be used with caution to avoid entering an infinite loop.
    </remarks>
  </DataWindow.Resize>
  <DataWindow.Seek>
    <summary>
      Search for a value in the data server connected to this data window based on a controlling search order and update the window based on the change.
    </summary>
    <param name="uValue">The value to search for. Its data type should be compatible with the controlling search order.</param>
    <param name="lSoftSeek">
      Determines how the attached data server is positioned if the specified key value is not found: TRUE performs a soft seek; FALSE does not. If <paramref name="lSoftSeek" /> is omitted, the current SetSoftSeek() setting is used.
    </param>
    <param name="lLast">
      Should the last matching key be selected?
    </param>
    <returns>
      TRUE if successful; otherwise, FALSE. Note that a FALSE value can indicate either that the value was not found or that the server does not support this search operation. Use the DataWindow:Status property to determine the exact cause of a failure.
    </returns>
  </DataWindow.Seek>
  <DataWindow.Server>
    <summary>
      The DataServer object currently connected to this data window. If no server is connected, this value is NIL.
    </summary>
    <value>The DataServer object currently connected to this data window. If no server is connected, this value is NIL.</value>
  </DataWindow.Server>
  <DataWindow.SetAlignStartSize>
    <summary>
      Sets the start size of the form window. In general, this size is set with the first assign to OwnerAlignment but it can be useful when trying to control the sizes for yourself.
    </summary>
    <param name="oDataWindow">The window attached to the child server; which must be a data window linked to a server of compatible type. If omitted, all relations for this server are removed (although the recommended way of doing this is the DataWindow:ClearRelations() method).</param>
    <param name="oSize">The Dimension representing the size of the window.</param>
  </DataWindow.SetAlignStartSize>
  <DataWindow.SetContextMenu>
    <exclude />
  </DataWindow.SetContextMenu>
  <DataWindow.SetDialog>
    <exclude />
  </DataWindow.SetDialog>
  <DataWindow.SetRelation>
    <summary>
      Set a relation from the data server connected to this data window to the data server of another, creating an owner-child relationship between the two servers and the two windows.
    </summary>
    <remarks>
      <note type="tip">This operation may not be supported, depending on whether the servers used supports relations and are of compatible types. The prototypical implementation is the standard Xbase DBServer:SetRelation() method provided.</note>
    </remarks>
    <param name="oDWChild">
      The window attached to the child server; which must be a data window linked to a server
      of compatible type. If omitted, all relations for this server are removed (although the recommended way of
      doing this is the DataWindow:ClearRelations() method).
    </param>
    <param name="uRelation">
      The relation code block for the server, The name or symbol representing the field from
      this server; a code block is constructed and macro-compiled or the array of field names or symbols representing
      the relation for the server. The field names are concatenated with plus signs and formed into a code block which is macro-compiled.
    </param>
    <param name="cRelation">
      When the relation is specified as a code block, a string version of the code block
      can be provided as well; it is returned by the Relation() method.
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <example>
      The API can take these forms:
      <code language="X#">
        oDWCustomer:SetRelation(oDWOrders, {||_FIELD-&gt;CustNo},"CustNo")
        oDWCustomer:SetRelation(oDWOrders, #CustNo)
        oDWCustomer:SetRelation(oDWOrders, {#LastName,#Initial,#FirstName})
      </code>
    </example>
  </DataWindow.SetRelation>
  <DataWindow.SetSelectiveRelation>
    <summary>
      Set a selective relation from this window to the child window, or actually from the server of
      this window to the server of the other window. A selective relation is one that limits operations on the child server to those records that match the relation condition.
    </summary>
    <remarks>
      <note type="tip">
        This operation may not be supported, depending on whether the servers used supports
        relations and are of compatible types.
      </note>
    </remarks>
    <param name="oDWChild">
      The window attached to the child server; which must be a data window linked to a
      server of compatible type. If omitted, all relations for this server are removed (although the recommended
      way of doing this is the DataWindow:ClearRelations() method).
    </param>
    <param name="uRelation">
      The relation code block for the server, The name or symbol representing the
      field from this server; a code block is constructed and macro-compiled or the array of field names or
      symbols representing the relation for the server. The field names are concatenated with plus signs and
      formed into a code block which is macro-compiled.
    </param>
    <param name="cRelation">
      When the relation is specified as a code block, a string version of the code block
      can be provided as well; it is returned by the Relation() method.
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <example>
      The API can take these forms:
      <code language="X#">
        oDWCustomer:SetSelectiveRelation(oDWOrders, {||_FIELD-&gt;CustNo},"CustNo")
        oDWCustomer:SetSelectiveRelation(oDWOrders, #CustNo)
        oDWCustomer:SetSelectiveRelation(oDWOrders, {#LastName,#Initial,#FirstName})
      </code>
    </example>
  </DataWindow.SetSelectiveRelation>
  <DataWindow.Show>
    <inheritdoc />
  </DataWindow.Show>
  <DataWindow.Size>
    <summary>
      The dimension representing the size of this data window in canvas coordinates.
    </summary>
    <value>The dimension representing the size of this data window in canvas coordinates.</value>
    <example>
      The following example sets the size of a data window object:
      <code language="X#">oDW:Size := Dimension{nWidth,nHeight}</code>
    </example>
  </DataWindow.Size>
  <DataWindow.Skip>
    <summary>
      Move forward or backward in the server by a specified number of records.
    </summary>
    <param name="uRelativePosition">The number of records to be moved. Positive numbers more forward, negative numbers move backward. The default is +1.</param>
    <returns>
      TRUE if operation was successful; otherwise, FALSE. Skip() can fail for several different reasons. It can fail validation, there may not be that many records to move, the write that precedes the move can fail because of lock conflicts with other users that control the server, or the server can have become unavailable due to technical problems. Use DataWindow:Status to determine the reason for the failure.
    </returns>
    <remarks>
      This method is subject to validation (i.e., if the data in the window fails validation, the movement is refused).
      The method does not explicitly refresh the contents of the window after the move; this is done automatically by the NotifyRecordChange message that follows.
      Because it takes a numeric argument, the Skip() method is rarely connected directly with a push button or menu command: for simple movements, use the SkipNext() and SkipPrevious() methods. Skip() provides a lot of flexibility but is usually called from code, in methods of the data window.
    </remarks>
  </DataWindow.Skip>
  <DataWindow.SkipNext>
    <summary>
      Move to the next record (identical to Skip(1)).
    </summary>
    <returns>
      TRUE if operation was successful; otherwise, FALSE.
    </returns>
  </DataWindow.SkipNext>
  <DataWindow.SkipPrevious>
    <summary>
      Move to the previous record (identical to Skip(-1)).
    </summary>
    <returns>
      TRUE if operation was successful; otherwise, FALSE.
    </returns>
  </DataWindow.SkipPrevious>
  <DataWindow.Status>
    <summary>
      A hyperlabel identifying the status of this data window after the last operation.
    </summary>
    <value>A hyperlabel identifying the status of this data window after the last operation.</value>
    <remarks>
      A hyperlabel identifying the status of this data window after the last operation. If the last operation was successful, this value is NULL_OBJECT; if something went wrong (whether it raised an error condition or merely returned a failure code), DataWindow:Status returns an informative hyperlabel.
    </remarks>
    <example>
      The following examples invoke several DataWindow:Status properties of the data server:
      <code language="X#">
        oDataWindow:Status:Caption
        oDataWindow:Status:Description
        oDataWindow:Status:HelpContext
      </code>
    </example>
  </DataWindow.Status>
  <DataWindow.StatusBar>
    <exclude />
  </DataWindow.StatusBar>
  <DataWindow.StatusOK>
    <summary>
      Indicate the current validation status of the window through a return code and by setting the DataWindow:Status property.
    </summary>
    <remarks>
      StatusOK() scans all controls on the window for an invalid status. If an invalid control status is found, the method returns TRUE. Use the DataWindow:Status property to determine which control returned an invalid status.
      Otherwise, StatusOK() returns FALSE.
    </remarks>
  </DataWindow.StatusOK>
  <DataWindow.SubForms>
    <exclude />
  </DataWindow.SubForms>
  <DataWindow.Surface>
    <exclude />
  </DataWindow.Surface>
  <DataWindow.symFormDialog>
    <exclude />
  </DataWindow.symFormDialog>
  <DataWindow.TextPrint>
    <summary>
      Display a given string on the data window at a specified location using the current font and the current pen color.
    </summary>
    <param name="cText">The string to be printed.</param>
    <param name="oPoint">The position of the string's origin, in canvas coordinates.</param>
  </DataWindow.TextPrint>
  <DataWindow.ToolBarHeightChanged>
    <inheritdoc />
  </DataWindow.ToolBarHeightChanged>
  <DataWindow.Undo>
    <summary>
      Undo recent changes made in this data window.
    </summary>
    <remarks>
      If the data window is in "form" view, this applies to changes to the contents of the current edit control in the data window; if in "browse" view, this applies to the changes made to a cell in the data browser.
    </remarks>
  </DataWindow.Undo>
  <DataWindow.UndoAll>
    <summary>
      Undo all changes made in this data window since the last record movement or Commit() operation.
    </summary>
    <remarks>
      After a long series of changes to this record, the DataWindow:UndoAll() method restores the record to the values it had when it was originally accessed. However, the method does not provide for restoring changes made to several records; once the server has moved off a record, the changes are permanent as far as DataWindow:UndoAll() is concerned.
      If the data window is in "form" view, this applies to changes to the contents of the edit controls in the data window; if in "browse" view, this applies to the changes made to a row in the data browser.
    </remarks>
  </DataWindow.UndoAll>
  <DataWindow.UpdateActiveObject>
    <summary>
      Update the toolbars of any in-place active OLE objects.
    </summary>
    <remarks>
      OLEDataWindow:UpdateActiveObject() calls the UpdateTools() method of any currently activated OLE object that the OLE data window contains. It first determines which OLE object control is in-place active, and then replaces the X# container application's toolbars with the OLE server's toolbars. In response to a resizing of the container application, this method causes the OLE object server to rearrange its toolbars.
    </remarks>
  </DataWindow.UpdateActiveObject>
  <DataWindow.Use>
    <summary>
      Connect the data window to a data server in a client-server relationship.
    </summary>
    <param name="oDataServer">The DataServer object that the window is to be connected to. If the window is already connected to a server, it is disconnected first. If the server argument is omitted, the server is not connected to any window.</param>
    <returns>
      TRUE if the connection was successful; otherwise, FALSE. The operation fails under the following conditions: if the window has controls and columns but none matches the names of the fields of the server and, of course, if there is a technical problem with the server.
    </returns>
    <remarks>
      The Use() method connects controls and browser columns with fields of the data server based on matching names. Any control that does not have an explicitly provided field specification and hyperlabel inherits the field specification and hyperlabel from its data server field.
      If the window does not have any controls or columns, the Use() method automatically creates a layout with controls or columns for all the fields in the server. A layout is created for each view—data window and browse—only when it is needed.
      Use() also registers the window as a client of the server with the DataServer:RegisterClient() method.
    </remarks>
  </DataWindow.Use>
  <DataWindow.ValidateRecord>
    <summary>
      If provided by the developer, ValidateRecord() is called by X# when you try to change records.
    </summary>
    <returns>
      TRUE if all fields in the current record are valid; otherwise, FALSE.
    </returns>
    <remarks>
      No default version of this method exists in the data window class. If a record-level validation method is provided, it should return a logical value indicating if the window is valid overall. If it returns FALSE, the method should set the window's Status property to a HyperLabel object with at least an appropriate description and possibly a help context tag, as well.
      ValidateRecord() can be used to perform cross-field validations, such as "the bonus can be no greater than half the salary and no greater than 10,000 for grades 6 and lower" and "tax filing information must be filled in if state is NY". While it is certainly possible to specify such validation rules for individual controls, and keep the controls independent of one another. This improves the reusability of code, making a control and its field specification usable regardless of what else is on the window.
    </remarks>
  </DataWindow.ValidateRecord>
  <DataWindow.VerticalScroll>
    <summary>
      Provide a method that is invoked when a vertical scroll bar is scrolled.
    </summary>
    <param name="oScrollEvent">The ScrollEvent object that describes the scroll type and new position.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The default behavior for this event handler is to update the thumb position; this can be changed using your own implementation of the handler. This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects. If the application has horizontal scroll bars, use a HorizontalScrollBar event handler.
    </remarks>
  </DataWindow.VerticalScroll>
  <DataWindow.VerticalSlide>
    <inheritdoc />
  </DataWindow.VerticalSlide>
  <DataWindow.VerticalSpin>
    <inheritdoc />
  </DataWindow.VerticalSpin>
  <DataWindow.ViewAs>
    <summary>
      Specify the view mode of the data window, as browse view or form view.
    </summary>
    <param name="symViewType">
      Specifies which view mode is to be used. Use one of these symbols:
      <list type="table">
        <listheader>
          <term>Symbol</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>#BrowseView </term>
          <description>Several records are displayed at the same time, as rows in a spreadsheet-like table with each field corresponding to a column.</description>
        </item>
        <item>
          <term>#FormView </term>
          <description>A single record is viewed at a time, with its fields displayed in individual controls.</description>
        </item>
      </list>
    </param>
    <remarks>
      When a window is switched to a new view mode, a layout is automatically generated if one had not been defined previously.
      Because it takes an argument, DataWindow:ViewAs() is rarely connected directly with a push button or menu command; instead, the DataWindow:ViewForm() and DataWindow:ViewTable() methods are used.
    </remarks>
  </DataWindow.ViewAs>
  <DataWindow.ViewForm>
    <summary>
      Select form view for the data window.
    </summary>
  </DataWindow.ViewForm>
  <DataWindow.ViewTable>
    <summary>
      Select browse view for the data window.
    </summary>
  </DataWindow.ViewTable>
  <DateFS>
    <summary>
      Create a date field specification which holds date data type information.
    </summary>
  </DateFS>
  <DateFS.ctor>
    <summary>
      Construct a date specification.
    </summary>
    <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new date field specification.</param>
  </DateFS.ctor>
  <DateRange>
    <summary>
      An auxiliary class used by the DateTimePicker and MonthCalendar controls to represent a date range.
    </summary>
    <remarks>
      The DateRange class encapsulates a date range as expected by various methods of the MonthCalendar and DateTimePicker classes.
    </remarks>
  </DateRange>
  <DateRange.ctor>
    <summary>
      Construct a DateRange object.
    </summary>
    <param name="dStart">The start date of the date range. If omitted, defaults to Today().</param>
    <param name="dEnd">The end date of the date range. If omitted, defaults to Today().</param>
  </DateRange.ctor>
  <DateRange.Max>
    <summary>
      The date representing the upper limit of the date range.
    </summary>
    <value>The date representing the upper limit of the date range.</value>
  </DateRange.Max>
  <DateRange.Min>
    <summary>
      The date representing the lower limit of the date range.
    </summary>
    <value>The date representing the lower limit of the date range.</value>
  </DateRange.Min>
  <DateTimePicker>
    <summary>
      Encapsulate a DateTimePicker control.
    </summary>
    <remarks>
      The DateTimePicker control allows the user to select a date or time.
      <note type="tip">Version 4.70 or higher of COMCTL32.DLL is needed to use the DateTimePicker control.</note>
    </remarks>
  </DateTimePicker>
  <DateTimePicker.ctor>
    <summary>
      Construct a DateTimePicker object.
    </summary>
    <param name="oOwner">The window that owns the DateTimePicker object.</param>
    <param name="xID">The unique ID for the DateTimePicker object (between 1 and 8000).</param>
    <param name="oPoint">The origin of the DateTimePicker object in canvas coordinates.</param>
    <param name="oDimension">The dimension of the DateTimePicker object in canvas coordinates.</param>
    <param name="dwStyle">
      Constant representing the style of the DateTimePicker object, specified either by a X# style constant or a Windows API style constant. Styles can be combined using the _Or() operator.
    </param>
    <param name="lDataAware">A logical value that is TRUE if the DateTimePicker object is data-aware; otherwise, FALSE. If omitted, defaults to TRUE.</param>
    <param name="nResourceID">The resource ID of the DateTimePicker object.</param>
    <remarks>
      <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular style constant.</note>
    </remarks>
  </DateTimePicker.ctor>
  <DateTimePicker.DateRange>
    <summary>
      A DateRange object setting the range of allowable dates.
    </summary>
    <value>A DateRange object setting the range of allowable dates.</value>
  </DateTimePicker.DateRange>
  <DateTimePicker.Format>
    <summary>
      Sets the display format of the DateTimePicker control. The assign expects a string containing any of the following fragments:
    </summary>
    <value>Sets the display format of the DateTimePicker control. The assign expects a string containing any of the following fragments:</value>
    <remarks>
      Sets the display format of the DateTimePicker control. The assign expects a string containing any of the following fragments:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>"d"</term>
          <description>The one- or two-digit day.</description>
        </item>
        <item>
          <term>"dd"</term>
          <description>The two-digit day. Single-digit day values are preceded by a zero (0).</description>
        </item>
        <item>
          <term>"ddd"</term>
          <description>The three-character weekday abbreviation.</description>
        </item>
        <item>
          <term>"dddd"</term>
          <description>The full weekday name.</description>
        </item>
        <item>
          <term>"h"</term>
          <description>The one- or two-digit hour in 12-hour format.</description>
        </item>
        <item>
          <term>"hh"</term>
          <description>The two-digit hour in 12-hour format. Single-digit values are preceded by a zero(0).</description>
        </item>
        <item>
          <term>"H"</term>
          <description>The one- or two-digit hour in 24-hour format.</description>
        </item>
        <item>
          <term>"HH"</term>
          <description>The two-digit hour in 24-hour format. Single-digit values are preceded by a zero(0).</description>
        </item>
        <item>
          <term>"m"</term>
          <description>The one- or two-digit minute.</description>
        </item>
        <item>
          <term>"mm"</term>
          <description>The two-digit minute. Single-digit values are preceded by a zero(0).</description>
        </item>
        <item>
          <term>"M"</term>
          <description>The one- or two-digit month number.</description>
        </item>
        <item>
          <term>"MM"</term>
          <description>The two-digit month number. Single-digit values are preceded by a zero(0).</description>
        </item>
        <item>
          <term>"MMM"</term>
          <description>The three-character month abbreviation.</description>
        </item>
        <item>
          <term>"MMMM"</term>
          <description>The full month name.</description>
        </item>
        <item>
          <term>"t"</term>
          <description>The one-letter AM/PM abbreviation (that is, AM is displayed as "A").</description>
        </item>
        <item>
          <term>"tt"</term>
          <description>The two-letter AM/PM abbreviation (that is, AM is displayed as "AM").</description>
        </item>
        <item>
          <term>"y"</term>
          <description>The one-digit year (that is, 1999 would be displayed as "9").</description>
        </item>
        <item>
          <term>"yy"</term>
          <description>The last two digits of the year (that is, 1999 would be displayed as "99").</description>
        </item>
        <item>
          <term>"yyy"</term>
          <description>The full year (that is, 1999 would be displayed as "1999").</description>
        </item>
      </list>
    </remarks>
    <example>
      This example displays the current time only on the date time picker control:
      <code language="X#">oDTPicker:Format := "hh:mm:ss"  // 10:23:14</code>
      This example displays a string along with the date:
      <code language="X#">
        ODTPicker:Format := "'Today is' dddd, MMMM d, yyy"
        // Today is Friday, April 9, 1999
      </code>
    </example>
  </DateTimePicker.Format>
  <DateTimePicker.IsNone>
    <exclude />
  </DateTimePicker.IsNone>
  <DateTimePicker.IsTimePicker>
    <exclude />
  </DateTimePicker.IsTimePicker>
  <DateTimePicker.MCBackgroundColor>
    <summary>
      A Color object describing the background color (between the months) of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.
    </summary>
    <value>A Color object describing the background color (between the months) of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.</value>
  </DateTimePicker.MCBackgroundColor>
  <DateTimePicker.MCFont>
    <summary>
      A Font object specifying the font of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.
    </summary>
    <value>A Font object specifying the font of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.</value>
  </DateTimePicker.MCFont>
  <DateTimePicker.MCMonthBackgroundColor>
    <summary>
      A Color object describing the background color (within the month area) of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.
    </summary>
    <value>A Color object describing the background color (within the month area) of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.</value>
  </DateTimePicker.MCMonthBackgroundColor>
  <DateTimePicker.MCTextColor>
    <summary>
      A Color object describing the text color of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.
    </summary>
    <value>A Color object describing the text color of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.</value>
  </DateTimePicker.MCTextColor>
  <DateTimePicker.MCTitleBackgroundColor>
    <summary>
      A Color object describing the title background color of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.
    </summary>
    <value>A Color object describing the title background color of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.</value>
  </DateTimePicker.MCTitleBackgroundColor>
  <DateTimePicker.MCTitleTextColor>
    <summary>
      A Color object describing the title text color of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.
    </summary>
    <value>A Color object describing the title text color of the MonthCalendar pop-up window, if the DateTimePicker is in date mode.</value>
  </DateTimePicker.MCTitleTextColor>
  <DateTimePicker.MCTrailingTextColor>
    <summary>
      A Color object describing the color of the trailing and leading days, i.e., those not belonging to the current month, that appear on the MonthCalendar pop-up window, if the DateTimePicker is in date mode.
    </summary>
    <value>A Color object describing the color of the trailing and leading days, i.e., those not belonging to the current month, that appear on the MonthCalendar pop-up window, if the DateTimePicker is in date mode.</value>
  </DateTimePicker.MCTrailingTextColor>
  <DateTimePicker.NullFormat>
    <exclude />
  </DateTimePicker.NullFormat>
  <DateTimePicker.ParentNotify>
    <exclude />
  </DateTimePicker.ParentNotify>
  <DateTimePicker.PerformValidations>
    <exclude />
  </DateTimePicker.PerformValidations>
  <DateTimePicker.SelectedDate>
    <summary>
      A date specifying the currently selected date.
    </summary>
    <value>A date specifying the currently selected date.</value>
  </DateTimePicker.SelectedDate>
  <DateTimePicker.SelectedTime>
    <summary>
      A string (format "HH:MM:SS") specifying the currently selected time.
    </summary>
    <value>A string (format "HH:MM:SS") specifying the currently selected time.</value>
  </DateTimePicker.SelectedTime>
  <DateTimePicker.SetDateTime>
    <exclude />
  </DateTimePicker.SetDateTime>
  <DateTimePicker.TextValue>
    <summary>
      The current value in string format. This is needed internally to allow the binding of a DateTimePicker control to a database field.
    </summary>
    <value>The current value in string format. This is needed internally to allow the binding of a DateTimePicker control to a database field.</value>
  </DateTimePicker.TextValue>
  <DateTimePicker.Value>
    <exclude />
  </DateTimePicker.Value>
  <DateTimeSelectionEvent>
    <summary>
      Provide information about a date time selection event, which is generated when a user selected a Date or Time in a DateTimePicker control.
    </summary>
    <remarks>
      This event occurs when a date is selected in a DateTimePicker control

    </remarks>
  </DateTimeSelectionEvent>
  <DateTimeSelectionEvent.ctor>
    <inheritdoc />
  </DateTimeSelectionEvent.ctor>
  <DateTimeSelectionEvent.SelectedDate>
    <summary>
      A date value indicating the date the user selected in the control
    </summary>
    <value>A date value indicating the date the user selected in the control</value>
  </DateTimeSelectionEvent.SelectedDate>
  <DateTimeSelectionEvent.SelectedTime>
    <summary>
      A string value indicating the time the user selected in the control
    </summary>
    <value>A string value indicating the time the user selected in the control</value>
  </DateTimeSelectionEvent.SelectedTime>
  <DDECallbackDelegate.ctor>
    <exclude />
  </DDECallbackDelegate.ctor>
  <DDECallbackDelegate.BeginInvoke>
    <exclude />
  </DDECallbackDelegate.BeginInvoke>
  <DDECallbackDelegate.EndInvoke>
    <exclude />
  </DDECallbackDelegate.EndInvoke>
  <DDECallbackDelegate.Invoke>
    <exclude />
  </DDECallbackDelegate.Invoke>
  <DialogWindow>
    <summary>
      Create a dialog window (also commonly referred to as a dialog box), which allows the application and end user to interact. This type of dialog can be modal or modeless (see the description below).
    </summary>
    <remarks>
      Dialog windows are windows that present a collection of controls for user I/O. They also have a result code that indicates the result of the user-dialog interaction (for example, if the user pressed the OK or Cancel push button in the dialog).
      Most windowing systems distinguish between modal and modeless objects. Modal objects must be acknowledged before the current thread of execution can continue; conversely, modeless objects do not affect the current execution thread.
      When a dialog box is modal, a further distinction must be made between system modal and application modal objects. Objects that are system modal must be acknowledged before any execution in any windows created by any currently running application, including the Windows desktop, can continue. Application modal objects, on the other hand, must be acknowledged before any execution in just the current application can continue (that is, the user can access windows created by other applications).
      By default, a dialog window is application modal. However, it can be made modeless by assigning FALSE to the <paramref name="lModal" /> flag in the DialogWindow:Init() method. You may also just want to create a modeless dialog box.
    </remarks>
  </DialogWindow>
  <DialogWindow.ctor>
    <summary>
      Construct a dialog window.
    </summary>
    <param name="oOwner">The window that owns the dialog window.</param>
    <param name="xResourceID">The resource ID of the desired dialog window.</param>
    <param name="lModal">TRUE creates a modal dialog window; FALSE, a modeless one. The default is TRUE.</param>
    <remarks>
      <note type="tip">
        When creating windows without using the Window Editor there is a difference between the DialogWindow class and all other Window classes.
        With the other window classes it is possible to write code like this -
        <code language="X#">
          LOCAL oDW AS DataWindow
          oDW := DataWindow{ oOwner }
          oDW:Show( )
        </code>
        However, this code will not work -
        <code language="X#">
          LOCAL oDW AS DialogWindow
          oDW := DialogWindow{ oOwner }
          oDW:Show( )
        </code>
        It is possible to use a generated resource for a blank DialogWindow and inherit from this. The alternative is to do something like this -
        <code language="X#">
          oWin := DialogWindow{ oOwner, "IDD_DEFDLG2", TRUE }
          oWin:Size := Dimension{ 100 , 100 }
          oWin:Show( SHOWCENTERED )
        </code>
        Or
        <code language="X#">
          oWin := DialogWindow{ oOwner, "IDD_DEFDLG", FALSE }
          oWin:Size := Dimension{ 100 , 100 }
          oWin:Show( )
        </code>
        The difference between these two pieces of code is -
        <code language="X#">
          - The first uses the "IDD_DEFDLG2" resource ID and sets the modal property to TRUE. This will create a normal style dialog window and is known as a Pop-Up Dialog.
          - The second uses the "IDD_DEFDLG" resource ID and sets the modal property to FALSE. This is the style of dialog window that would be used as a Tab Page and is known as a Child Dialog.
        </code>
      </note>
    </remarks>
  </DialogWindow.ctor>
  <DialogWindow.Activate>
    <inheritdoc />
  </DialogWindow.Activate>
  <DialogWindow.Active>
    <inheritdoc />
  </DialogWindow.Active>
  <DialogWindow.ButtonClick>
    <summary>
      Provide a method that is invoked when a check box, push button, or radio button is clicked with the mouse.
    </summary>
    <param name="oControlEvent">The ControlEvent object that describes which button was clicked.</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      Button click events are propagated to the dialog window's owner the same way as MenuEvents. For an in-depth discussion on command event propagation, refer to the Programmer's Guide .
      You must supply the code to turn a radio button on (and all the other radio buttons off) when a user clicks on a radio button. Similarly, you must also be sure to invert the state of a check box when it is clicked.
    </remarks>
  </DialogWindow.ButtonClick>
  <DialogWindow.ChangeFont>
    <summary>
      Change the font used by this dialog window.
    </summary>
    <param name="oFont">The new font to be used.</param>
    <param name="lRescale">Specify TRUE to resize and reposition all controls in this dialog window and change their fonts; otherwise, FALSE. If omitted, the default is FALSE.</param>
    <returns>
      The font previously assigned to the dialog window.
    </returns>
  </DialogWindow.ChangeFont>
  <DialogWindow.ClipperKeys>
    <exclude />
  </DialogWindow.ClipperKeys>
  <DialogWindow.ControlFocusChange>
    <summary>Provide a method that is invoked when the input focus changes to or from a control.</summary>
    <param name="oControlFocusChangeEvent" >The ControlFocusChangeEvent object that identifies which control generated the ControlFocusChangeEvent object and whether it has just gained or lost the keyboard focus. </param>
    <remarks>
      If ControlFocusChange() is used to validate a control (and also set the focus to another control),
      Control:SetFocus() should not be called until another control has received the focus.
      In complex dialog windows that contain many edit controls, it makes sense to grab the edit
      control's text when the focus is changing so that other controls can be updated with it if necessary.
      See the ButtonClick() method for an example of similar syntax to be used in this method.
      Note that all controls are passed through this method, not only SingleLineEdit and MultiLineEdit controls.
      If looking to control Combobox selections, then the ListBoxSelect() callback method should be reviewed.
    </remarks>
    <seealso cref="T:VO.ControlFocusChangeEvent" />

    <param name="oControlFocusChangeEvent">** missing parameter documentation **</param>
  </DialogWindow.ControlFocusChange>
  <DialogWindow.DeActivate>
    <inheritdoc />
  </DialogWindow.DeActivate>
  <DialogWindow.Default>
    <inheritdoc />
  </DialogWindow.Default>
  <DialogWindow.Destroy>
    <summary>
      Free memory resources allocated for a dialog window and its derived objects.
    </summary>
    <remarks>
      This method immediately frees resources for DialogWindow objects created explicitly in your application. DialogWindow:Destroy() also takes care of resources allocated to derived classes and deallocates them in the necessary order.
    </remarks>
  </DialogWindow.Destroy>
  <DialogWindow.EditChange>
    <summary>
      Provide a method that is invoked when the text in an edit control is changed.
    </summary>
    <param name="oControlEvent">The ControlEvent object that describes which edit control was changed.</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </DialogWindow.EditChange>
  <DialogWindow.EditFocusChange>
    <summary>
      Provide a method that is invoked when the input focus changes to or from an edit control.
    </summary>
    <param name="oEditFocusChangeEvent">The EditFocusChangeEvent object that identifies which edit control generated the EditFocusChangeEvent object and whether it has just gained or lost the keyboard focus.</param>
    <seealso cref="T:VO.EditFocusChangeEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      If DialogWindow:EditFocusChange() is used to validate an edit control (and also return the focus to it if invalid), Control:SetFocus() should not be called until another control has received the focus.
      In complex dialog windows that contain many edit controls, it makes sense to grab the edit control's text when the focus is changing so that other controls can be updated with it if necessary.
    </remarks>
  </DialogWindow.EditFocusChange>
  <DialogWindow.EndDialog>
    <summary>
      Remove this dialog window from view (passing control back to the routine which created the dialog window) and post a result code indicating how it was closed.
    </summary>
    <param name="iResult">The result code that should be posted. The default is 0.</param>
    <example>
      <note type="tip">This result code can then be passed to the routine that called the dialog window if the routine invokes DialogWindow:Result.</note>
      The following example instructs EndDialog() to return 0 if the Cancel push button is pressed and 1 if OK is pressed:
      <code language="X#">
        METHOD ButtonClick(oEvent) CLASS MyDialogWindow
        IF oEvent:nControlID == ID_OK
        SELF:EndDialog(1)
        ENDIF
        IF oEvent:nControlID == ID_CANCEL
        SELF:EndDialog(0)
        ENDIF
      </code>
    </example>
  </DialogWindow.EndDialog>
  <DialogWindow.ExecModal>
    <summary>
      Allows the programmer greater control over Windows message handling in dialog windows.
    </summary>
    <remarks>
      Normally a dialog window will cause program execution to pause when the window is shown and then continue once the window is closed. The default behavior of ExecModal( ) maintains the expected behavior.
      However the programmer can create a new class which inherits from DialogWindow and implement a new ExecModal() method so as to change this behavior.
    </remarks>
    <example>
      As an example the programmer could use the following version which performs no action:
      <code language="X#">
        METHOD ExecModal() CLASS DialogWindow
        RETURN NIL
      </code>
      Now the program control comes back immediately after calling the Show() method. This is very useful for cases where your code wants to control the windows dispatcher loop with the function ApplicationExec(EXECWHILEEVENT):
      <code language="X#">
        METHOD xyz() CLASS xyz
        LOCAL oPDlg AS ProgressDialog // inherit from DialogWindow

        oPDlg := ProgressDialog{SELF, "Processing is going on!"}
        oPDlg:Count := oServer:Reccount
        oPDlg:Show()

        //ProgressDialog is modal, the user can do
        // nothing during the processing other than what
        // your code permits.
        //In this example you can abort the loop.

        oServer:GoTop()

        DO WHILE oServer:EOF
        IF ! oPDlg:STEP() //FALSE if abort button is pressed
        EXIT
        ENDIF
        //do something
        oServer:Skip()
        ENDDO

        oPDlg:EndDialog()
      </code>
    </example>
  </DialogWindow.ExecModal>
  <DialogWindow.Font>
    <summary>
      The font to be used in this dialog window.
    </summary>
    <value>The font to be used in this dialog window.</value>
  </DialogWindow.Font>
  <DialogWindow.Handle>
    <summary>
      Return the handle for a dialog window.
    </summary>
    <param name="nHandleType">The type of handle required. Specify 0 for the window handle and 2 for the window device context. If omitted, 0 is the default.</param>
    <returns>
      A handle to the window, describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the window, which can then be used by Windows API calls.
    </remarks>
  </DialogWindow.Handle>
  <DialogWindow.HelpRequest>
    <exclude />

  </DialogWindow.HelpRequest>
  <DialogWindow.HorizontalScroll>
    <summary>
      Provide a method that is invoked when a horizontal scroll bar is scrolled.
    </summary>
    <param name="oScrollEvent">The ScrollEvent object that describes the scroll type and new position.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The default behavior for this event handler is to update the thumb position; this can be changed using your own implementation of the handler. This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects. If the application has vertical scroll bars, use a WindowVerticalScrollBar event handler.
    </remarks>
  </DialogWindow.HorizontalScroll>
  <DialogWindow.IsModal>
    <exclude />
  </DialogWindow.IsModal>
  <DialogWindow.LastFocus>
    <exclude />
  </DialogWindow.LastFocus>
  <DialogWindow.ListBoxClick>
    <summary>
      Provide a method that is invoked when an item in a list box owned by this dialog window is double-clicked.
    </summary>
    <param name="oControlEvent">The ControlEvent object that describes which list box contained the item that is double-clicked.</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </DialogWindow.ListBoxClick>
  <DialogWindow.ListBoxSelect>
    <summary>
      Provide a method that is invoked when an item in a list box owned by this window is clicked.
    </summary>
    <param name="oControlEvent">The ControlEvent object that describes which list box contained the item that was clicked.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <seealso cref="T:VO.ControlEvent" />
  </DialogWindow.ListBoxSelect>
  <DialogWindow.Owner>
    <exclude />
  </DialogWindow.Owner>
  <DialogWindow.PostShowDialog>
    <exclude />
  </DialogWindow.PostShowDialog>
  <DialogWindow.Result>
    <summary>
      A numeric result code posted by the DialogWindow:EndDialog() method returned to the system when this dialog window was closed.
    </summary>
    <value>A numeric result code posted by the DialogWindow:EndDialog() method returned to the system when this dialog window was closed.</value>
    <remarks>
      A numeric result code posted by the DialogWindow:EndDialog() method returned to the system when this dialog window was closed. (For example, it may have posted a 0 if the Cancel push button was pressed or a 1 if OK was pressed.)
      <note type="tip">DialogWindow:Result should be invoked by the owner's method that showed the dialog window to determine the action that closed the dialog window.</note>
    </remarks>
  </DialogWindow.Result>
  <DialogWindow.Show>
    <inheritdoc />
  </DialogWindow.Show>
  <DialogWindow.ShowModal>
    <summary>This is the worker method that shows the DialogWindow</summary>
    <param name="lActive">** missing parameter documentation **</param>
  </DialogWindow.ShowModal>
  <DialogWindow.StatusMessage>
    <summary>
      Display a message in the status bar of the shell window.
    </summary>
    <param name="oHyperLabel">The hyperlabel containing a description (HyperLabel:Description) for the status message.</param>
    <param name="kMessageType">The constant value indicating the type and priority of the message to be displayed on the status bar. See the remarks section for more information.</param>
    <remarks>
      <list type="table">
        The highest priority message (MESSAGEMENU) always takes precedence over and replaces lower priority messages.
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader><item>
          <term>MESSAGEMENU</term>
          <description>Priority 4 (Highest priority): A message associated with a menu selection.</description>
        </item><item>
          <term>MESSAGEERROR</term>
          <description>Priority 3: An error message.</description>
        </item><item>
          <term>MESSAGECONTROL</term>
          <description>Priority 2: A message associated with a control.</description>
        </item><item>
          <term>MESSAGEPERMANENT</term>
          <description>
            Priority 1 (Lowest priority): The default message displayed on the status bar; stored whenever a higher
            priority message takes precedence and redisplayed when no other messages take priority. This is the <b>default</b>.
          </description>
        </item>
      </list>
    </remarks>
  </DialogWindow.StatusMessage>
  <DialogWindow.VerticalScroll>
    <summary>
      Provide a method that is invoked when a vertical scroll bar is scrolled.
    </summary>
    <param name="oScrollEvent">The ScrollEvent object that describes the scroll type and new position.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The default behavior for this event handler is to update the thumb position;
      this can be changed using your own implementation of the handler. This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects. If the application has horizontal scroll bars, use a HorizontalScrollBar event handler.
    </remarks>
  </DialogWindow.VerticalScroll>
  <Dimension>
    <summary>
      Create a Dimension object, which is used to describe the size of two-dimensional objects using ordered pair coordinates (width, height or x, y).
    </summary>
    <remarks>
      <note type="tip">
        When a dimension is used to describe irregularly-shaped objects,
        it specifies the size of the smallest bounding box that can fully enclose the object.
      </note>
    </remarks>
  </Dimension>
  <Dimension.ctor>
    <summary>
      Construct a dimension.
    </summary>
    <param name="nWidth">The width of the dimension The default is 0, inherited from CLASS Pair.</param>
    <param name="nHeight">The height of the dimension. The default is 0, inherited from CLASS Pair.</param>
  </Dimension.ctor>
  <Dimension.Height>
    <summary>
      A numeric value representing this dimension's height.
    </summary>
    <value>A numeric value representing this dimension's height.</value>
  </Dimension.Height>
  <Dimension.Width>
    <summary>
      A numeric value representing this dimension's width.
    </summary>
    <value>A numeric value representing this dimension's width.</value>
  </Dimension.Width>
  <DragDropClient>
    <summary>
      Create the client for use in a drag-and-drop operation.
    </summary>
    <remarks>
      In Windows, "drag-and-drop" is a technique by which users can move files from one location to another, either visually (using the mouse) or through another system-accepted method. The client in a drag-and-drop operation is a utility object with an associated owner window that accepts dropped files.
      Creating a drag-and-drop client automatically makes its owner window capable of accepting drag-and-drop loads. The event handlers in the drag-and-drop client handle the events relevant to the drag-and-drop operation.
      <br />Important! When you call Window:EnableDragDropClient(TRUE), the window becomes a DragDropClient and inherits all the methods of DragDropClient. The callback methods DragLeave(), DragOver(), and Drop() are called on the Window object when a DragLeave, DragOver, or Drop event occurs (see the example below.)
    </remarks>
    <example>
      The following example demonstrates the use of the DragDropClient class:
      <code language="X#">
        METHOD Init(oOwner) CLASS StandardShellWindow
        SUPER:Init(oOwner)
        SELF:Size := Dimension{300,100}
        SELF:Origin:= Point{0,20}
        SELF:Caption := "Non-MDI ChildWindow"
        SELF:EnableMinBox()
        SELF:EnableMaxBox()
        SELF:EnableSystemMenu
        SELF:EnableBorder()
        SELF:EnableDragDropClient()	// Make the window a DragDropClient
        SELF:Show()
        METHOD DragOver(oDragEvent) CLASS StandardShellWindow
        LOCAL iCount AS INT
        LOCAL iAcceptDrop AS LOGIC
        // Check files that are being dragged over the window
        // Only accept if all files are .DBF
        lAcceptDrop := TRUE
        FOR iCount := 1 TO oDragEvent:FileCount
        IF RAT(".DBF", oDragEvent:FileName(iCount)) == 0
        lAcceptDrop := FALSE
        EXIT
        ENDIF
        NEXT
        RETURN lAcceptDrop
        METHOD DragLeave() CLASS StandardShellWindow
        // Undo any actions taken during drag-drop attempt
        METHOD Drop(oDragEvent) CLASS StandardShellWindow
        LOCAL nNumFiles := oDragEvent:FileCount
        // Number of entries dropped
        LOCAL nFile AS INT
        // For each item that is dropped, if it is a file, open it.
        FOR nFile := 1 TO nNumFiles
        IF File(oDragEvent:FileName(nFile))
        SELF:DoOpenFile(oDragEvent:FileName(nFile))
        ENDIF
        NEXT
      </code>
    </example>
  </DragDropClient>
  <DragDropClient.ctor>
    <summary>
      Construct a drag-and-drop client.
      <br />Important! Normally, this method should not be called in your application code. Instead use Window:EnableDragDropClient(TRUE) to create a drag-and-drop client.
    </summary>
    <param name="oOwner">The window that owns this drag-and-drop client.</param>
  </DragDropClient.ctor>
  <DragDropClient.Destroy>
    <exclude />
  </DragDropClient.Destroy>
  <DragDropClient.Dispatch>
    <inheritdoc />
  </DragDropClient.Dispatch>
  <DragDropClient.DragLeave>
    <summary>
      Notify the application that the mouse has left the client area of the window that owns the drag-and-drop client.
    </summary>
    <param name="oEvent">An empty event maintaining the protocol requirement that an event handler has exactly one event as its argument.</param>
    <seealso cref="T:VO.Event" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The system dispatches this method when, during an apparent drag-and-drop operation (that is, DragDropClient:DragOver() returns TRUE), the mouse leaves the client area of the window that owns the drag-and-drop client. This means that the user has thought better of performing the operation. Your implementation of DragLeave() should undo any actions taken during the drag-and-drop attempt, in case the user was simply en route to some other client.
    </remarks>
  </DragDropClient.DragLeave>
  <DragDropClient.DragOver>
    <summary>
      Notify the application of a DragOver event and accept or reject the drop.
    </summary>
    <param name="oDragEvent">The drag event that determines the position of the mouse (in canvas coordinates), aswell as the number and names of files, in the drag-and-drop load.</param>
    <returns>
      The client can refuse a drag-and-drop operation by returning FALSE from this method (usually because a certain file type is not accepted). Windows then changes the pointer to a no-entry sign. The method returns TRUE if a drop is accepted.
    </returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The system dispatches this method when, during a drag-and-drop operation, the mouse drags inside the client area of the drag-and-drop client. Several drag events can arrive at DragDropClient:DragOver() during the one operation, before the user finally drops the load or leaves the client area. Windows displays a special pointer to give the user visual feedback on the progress of the operation.
    </remarks>
  </DragDropClient.DragOver>
  <DragDropClient.Drop>
    <summary>
      Retrieve information about a load from the drag event and act on each file in the selection.
    </summary>
    <param name="oDragEvent">The drag event that determines the position of the mouse (in canvas coordinates), as well as the number and names of files, in the drag-and-drop load.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The system dispatches this method when the user lets go of the mouse button to drop the load in the client area. This method is required to handle drag-and-drop correctly. It retrieves information about the load from the drag event and acts on each file in the selection. If the drag-and-drop client is a shell window, it might open a data browser for each file in the selection.
    </remarks>
  </DragDropClient.Drop>
  <DragDropClient.Owner>
    <exclude />
  </DragDropClient.Owner>
  <DragDropServer>
    <summary>
      Create the server for use in a drag-and-drop operation.
    </summary>
    <remarks>
      In Windows, "drag-and-drop" is a technique by which users can move files from one location to another, either visually (using the mouse) or through another system-accepted method. The server in a drag-and-drop operation is the source of the drag-and-drop operation.
      The user normally uses the mouse to select a group of files to drag (however, the application can choose any reasonable metaphor for selection). After selection, the application creates a drag-and-drop load by storing the file names in an array; it then calls the DragDropServer:StartDrag() method.
      When you call Window:EnableDragDropServer(TRUE), the window becomes a DragDropServer. The DragDropServer is a property in the Window and is called Window:DragDropServer.
    </remarks>
  </DragDropServer>
  <DragDropServer.ctor>
    <summary>
      Construct a drag-and-drop server.
      <br />Important! Normally, this method should not be called in your application code. Instead use Window:EnableDragDropServer(TRUE) to make the window a drag-and-drop server.
    </summary>
    <param name="oOwner">The window that owns this drag-and-drop server.</param>
    <remarks>
      Once defined as a server, the GUI recognizes it as a possible source of drag-and-drop operations.
    </remarks>
  </DragDropServer.ctor>
  <DragDropServer.Destroy>
    <exclude />
  </DragDropServer.Destroy>
  <DragDropServer.StartDrag>
    <summary>
      Notify the GUI that a drag-and-drop operation has started.
    </summary>
    <param name="acFilesToDrag">An array of file names to drag.</param>
    <returns>
      TRUE if the drop was successful; otherwise, FALSE (for example, if the user dropped the files on a non-drag-and-drop client).
    </returns>
    <remarks>
      This method is called when the user starts the drag operation, usually by dragging the mouse. DragDropServer:StartDrag() is modal; once it is called, control is only returned to the program when the user has dropped the files.
    </remarks>
    <example>
      The following example demonstrates how to use the DragDropServer:StartDrag() method:
      <code language="X#">
        CLASS MyChildWindow INHERIT ChildAppWindow
        HIDDEN aDragList AS ARRAY
        METHOD Init(oOwner) CLASS MyChildAppWindow
        SUPER:Init(oOwner)
        EnableDragDropServer(TRUE)			// Make Window
        // a DragDropServer
        METHOD MouseDrag(oEvent) CLASS MyChildWindow
        LOCAL ListLength AS INT
        LOCAL lResult	 AS LOGIC
        ListLength := ALen(aDragList)
        // aDragList is already filled with list of file names
        IF ListLength &gt; 0 		// if there are files to drag
        lResult := SELF:DragDropServer:StartDrag(aDragList)
        ENDIF
      </code>
    </example>
  </DragDropServer.StartDrag>
  <DragEvent>
    <summary>
      Provide information about a drag event, which enables the drag-and-drop client (the receiving window) to track the progress of the mouse during the drag operation and to identify the files that the user can drop.
    </summary>
    <remarks>
      Drag-and-drop is a GUI convention for moving objects from one place to another. In Windows, the convention only supports files. A drag event occurs when the user drags a group of previously selected files to a new location. Drag events occur in the target window where the selection will be dropped (not in the window where the selection was made).
      <note type="tip">Drag events do not occur in the drag-and-drop server (the source of the files)—only in the drag-and-drop client (the target). When the drag enters the client area, the drag event goes to the DragDropClient:DragOver() method of the client. If the drag leaves the client without dropping its files, and the drag-and-drop client has returned TRUE to the DragOver() method, a generic event goes to DragDropClient:DragLeave(). It is then no longer relevant or correct for the application to query the event if it is leaving the client. If the user drops the files, the drag event goes to DragDropClient:Drop().</note>
    </remarks>
  </DragEvent>
  <DragEvent.ctor>
    <inheritdoc />
  </DragEvent.ctor>
  <DragEvent.Control>
    <summary>
      A control object returning the control whenever a drop-and-drag event has occurred inside a control with WS_EX_ACCEPTFILES set. If WS_EX_ACCEPTFILES is TRUE, the control accepts files and triggers a call to its parent Drop() method.
    </summary>
    <value>A control object returning the control whenever a drop-and-drag event has occurred inside a control with WS_EX_ACCEPTFILES set. If WS_EX_ACCEPTFILES is TRUE, the control accepts files and triggers a call to its parent Drop() method.</value>
  </DragEvent.Control>
  <DragEvent.FileCount>
    <summary>
      A numeric value representing the number of files in the drag-and-drop load that generated this drag event.
    </summary>
    <value>A numeric value representing the number of files in the drag-and-drop load that generated this drag event.</value>
  </DragEvent.FileCount>
  <DragEvent.FileName>
    <summary>
      Return the name of a specified file in the drag-and-drop load that generated this drag event.
    </summary>
    <param name="nfile">The position of the desired file in the drag-and-drop load array; file numbers in this array start at 1 (see DragEvent:FileCount).</param>
  </DragEvent.FileName>
  <DragEvent.Origin>
    <summary>
      A point representing the location of the mouse in canvas coordinates at the time this drag event was generated.
    </summary>
    <value>A point representing the location of the mouse in canvas coordinates at the time this drag event was generated.</value>
  </DragEvent.Origin>
  <DrawObject>
    <summary>
      Provide the base class from which all X# DrawObject objects are subclassed.
    </summary>
    <remarks>
      The DrawObject class provides a protocol for drawable objects (for example, the Window class invokes DrawObject's methods to manage a drawable object). This protocol provides a means to maintain arrays of drawing objects for subsequent display on a window.
      Each object in the DrawObject hierarchy should provide both a BoundingBox property (to identify the smallest area that can enclose the drawing object) and a Draw() method (to specify how the object is to be drawn). When the application is finished with the object, it must be explicitly destroyed using the Destroy() method.
    </remarks>
  </DrawObject>
  <DrawObject.ctor>
    <summary>
      Construct a DrawObject object.
    </summary>
    <param name="oPoint">The origin of the DrawObject object in canvas coordinates.</param>
  </DrawObject.ctor>
  <DrawObject.BoundingBox>
    <summary>
      A bounding box representing the smallest rectangle (in the owner window's canvas coordinates) which encloses this DrawObject object.
    </summary>
    <value>A bounding box representing the smallest rectangle (in the owner window's canvas coordinates) which encloses this DrawObject object.</value>
  </DrawObject.BoundingBox>
  <DrawObject.Destroy>
    <summary>
      Provide a method to de-instantiate a DrawObject object.
    </summary>
    <remarks>
      DrawObject:Destroy() de-instantiates the DrawObject object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector. When the application is finished with the object, it must be explicitly destroyed using this method.
    </remarks>
  </DrawObject.Destroy>
  <DrawObject.Draw>
    <summary>
      Display a DrawObject object.
    </summary>

    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      <note type="tip">The default implementation of the DrawObject:Draw() method has no effect. You should derive your class from DrawObject and overload the Draw() method to contain the code to draw the new object. This method can then be called by Window:Draw().</note>
      To display a DrawObject object, call Window:Draw() with the DrawObject object as its argument. The window does the drawing by asking each object to draw itself—for example:
      <code language="X#">
        METHOD Expose(oEvent) CLASS MyWindow
        LOCAL oEllipse AS ELLIPSEOBJECT
        oEllipse := EllipseObject{Point{10,10},;
        Dimension{50,100}}
        SELF:Draw(oEllipse)
        // Calls the method Draw() on oEllipse
      </code>
    </remarks>
  </DrawObject.Draw>
  <DrawObject.Handle>
    <summary>
      Return the handle for a DrawObject object.
    </summary>
    <param name="nHandleType">
      The type of handle required. 0 is the only supported option and is the default if <paramref name="nHandle" /> is omitted.
    </param>
    <returns>
      A handle to the device context for the window on which the object is to be drawn. X# will release this handle when necessary. You should not save it to a variable.
    </returns>
    <remarks>
      <note type="tip">This method only has an effect in an overridden DrawObject:Draw() method.</note>
    </remarks>
  </DrawObject.Handle>
  <DrawObject.HitTest>
    <summary>
      Determine if a given point lies within the bounding box of a DrawObject object.
    </summary>
    <param name="oPoint">The point to test for inclusion.</param>
    <returns>
      TRUE if the point lies within the bounding box of the DrawObject object; otherwise, FALSE.
    </returns>
    <remarks>
      This method should be provided by objects in classes subclassed from DrawObject, when behavior other than the default behavior is required.
      When HitTest() is invoked, it does the following by default:
      <code language="X#">RETURN(SELF:BoundingBox()):PtInRect(oPoint)</code>
    </remarks>
  </DrawObject.HitTest>
  <DrawObject.Origin>
    <summary>
      A point representing the origin of this DrawObject object in canvas coordinates.
    </summary>
    <value>A point representing the origin of this DrawObject object in canvas coordinates.</value>
  </DrawObject.Origin>
  <DrawObject.RasterOperation>
    <summary>
      A constant, indicating the raster operation in use for this DrawObject object:
    </summary>
    <value>A constant, indicating the raster operation in use for this DrawObject object:</value>
    <remarks>
      One of the following constants, indicating the raster operation in use for this DrawObject object:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>ROPBACKGROUND</term>
          <description>Draw this object using the background color of the window.</description>
        </item>
        <item>
          <term>ROPINVERT</term>
          <description>Invert the object currently displayed. This operation can be used for elastic banding, moving objects, and so forth.</description>
        </item>
        <item>
          <term>ROPOVERWRITE</term>
          <description>
            Overwrite the current display. This is the <b>default</b>.
          </description>
        </item>
        <item>
          <term>ROPXOR</term>
          <description>Exclusive OR with the current window contents.</description>
        </item>
      </list>
      This property allows you to specify how the drawing affects whatever is already on the window. The XOR operation, for example, is useful for temporary drawings you want to be able to remove, restoring the original image.
    </remarks>
  </DrawObject.RasterOperation>
  <DrawObject.Size>
    <summary>
      A dimension representing the size of this DrawObject object.
    </summary>
    <value>A dimension representing the size of this DrawObject object.</value>
  </DrawObject.Size>
  <Edit>
    <summary>
      Provide the base class from which all X# edit controls are subclassed.
    </summary>
    <remarks>
      The Edit class provides simple text editing facilities for entering, deleting, and selecting text. In addition, you can specify if edit controls are to have a border, whether they should be read-only, or perhaps whether they should be password protected.
      Edit controls in this class hierarchy treat the text they contain as a series of numbered characters. In these edit controls, a selection is an ordered pair of character numbers. For example, if an edit control contains the text "samarkand," the selection (3,7) would select the text "mark."
      Also, for each control, the text limit is the maximum number of characters you wish the edit to hold.
      The non-graphic characters for newline (Chr(10)), tab (Chr(9)), and null (Chr(0)) occupy one character position.
    </remarks>
  </Edit>
  <Edit.ctor>
    <summary>
      Construct an edit control.
    </summary>
    <param name="oOwner">The window that owns the edit control.</param>
    <param name="xID">The ID of the edit control.</param>
    <param name="oPoint">The origin of the edit control in canvas coordinates.</param>
    <param name="oDimension">The dimension of the edit control in canvas coordinates.</param>
    <param name="kStyle">The style of the edit control, specified as one of the following constants:</param>
    <param name="nResourceID">The resource ID of the edit control.</param>
    <remarks>
      <include file="Gui.xml" path="doc/EditConstants/*" />
    </remarks>
  </Edit.ctor>
  <Edit.CanUndo>
    <summary>
      Determine if the Edit:Undo() method can be called for this edit control.
    </summary>
    <returns>
      TRUE if Edit:Undo() can be invoked; otherwise, FALSE.
    </returns>
    <remarks>
      This method is often used to modify Undo menu commands to reflect the state of the different possibilities.
    </remarks>
  </Edit.CanUndo>
  <Edit.Caption>
    <summary>
      Caption text is not displayed for single-line or multiline edit controls. It can be used to store general text information.
    </summary>
    <value>Caption text is not displayed for single-line or multiline edit controls. It can be used to store general text information.</value>
  </Edit.Caption>
  <Edit.Clear>
    <summary>
      Delete the current selection in this edit control.
    </summary>
    <remarks>
      If the current selection refers to a cursor position (for example, {5,5}), no text is deleted.
    </remarks>
  </Edit.Clear>
  <Edit.Copy>
    <summary>
      Copy the current selection in this edit control to the clipboard.
    </summary>
    <remarks>
      If the current selection refers to a cursor position (for example, {5,5}), no text is copied.
    </remarks>
  </Edit.Copy>
  <Edit.Cut>
    <summary>
      Delete the current selection in this edit control and copy it to the clipboard.
    </summary>
    <remarks>
      If the current selection refers to a cursor position (for example, {5,5}), no text is deleted.
    </remarks>
  </Edit.Cut>
  <Edit.Font>
    <exclude />

  </Edit.Font>
  <Edit.IsPassword>
    <exclude />
  </Edit.IsPassword>
  <Edit.Margins>
    <summary>
      A Dimension object specifying the left and right margins of the edit control.
    </summary>
    <value>A Dimension object specifying the left and right margins of the edit control.</value>
  </Edit.Margins>
  <Edit.Modified>
    <summary>
      A logical value indicating whether an editable control is in the process of being modified.
    </summary>
    <value>A logical value indicating whether an editable control is in the process of being modified.</value>
    <remarks>
      A logical value indicating whether an editable control is in the process of being modified. While you are editing the text, it is set to TRUE. When the edit is completed and focus shifts to another control, Edit:Modified is reset to FALSE.
    </remarks>
  </Edit.Modified>
  <Edit.Paste>
    <summary>
      Replace the current selection in this edit control with a string, if specified, or the contents of the clipboard.
    </summary>
    <param name="cNewString">The text to be placed in the edit control. If not specified, the contents of the clipboard is used.</param>
    <remarks>
      If the current selection refers to a cursor position (for example, {5,5}), the text is inserted at that point and no text is deleted.
    </remarks>
  </Edit.Paste>
  <Edit.ReadOnly>
    <summary>
      A logical value specifying the read-only state of an edit control.
    </summary>
    <value>A logical value specifying the read-only state of an edit control.</value>
    <remarks>
      A logical value specifying the read-only state of an edit control.
      This property allows you to change the read-only state at runtime.
      Note that changing the ReadOnly style via Edit:SetStyle(ES_READONLY) is not respected by the edit control at runtime.
    </remarks>
  </Edit.ReadOnly>
  <Edit.SelectAll>
    <exclude />
  </Edit.SelectAll>
  <Edit.SelectedText>
    <summary>
      A string representing the text that is currently selected in this edit control.
    </summary>
    <value>A string representing the text that is currently selected in this edit control.</value>
  </Edit.SelectedText>
  <Edit.Selection>
    <summary>
      The position of the cursor in the edit control.
    </summary>
    <value>The position of the cursor in the edit control.</value>
    <remarks>
      The position of the cursor in the edit control. For example, a Selection of {5,10} means the text from position 5 through 9 inclusive is selected, while a Selection of {5,5} means the cursor is positioned in front of the fifth character.
    </remarks>
  </Edit.Selection>
  <Edit.SelectNone>
    <exclude />
  </Edit.SelectNone>
  <Edit.SetSelectionFocus>
    <exclude />
  </Edit.SetSelectionFocus>
  <Edit.TextLimit>
    <summary>
      A numeric value representing the maximum number of characters this edit control can hold.
    </summary>
    <value>A numeric value representing the maximum number of characters this edit control can hold.</value>
    <remarks>
      A numeric value representing the maximum number of characters this edit control can hold. A value of 0 indicates that there is no limit being imposed. If the limit specified is less than the size of the text already in the buffer, the existing text is truncated.
    </remarks>
  </Edit.TextLimit>
  <Edit.TextValue>
    <summary>
      A string representing the value held in the control.
    </summary>
    <value>A string representing the value held in the control.</value>
    <remarks>
      A string representing the value held in the control. For example, in a standard edit control, the value can be "Jones" or "$14,683.00". The Edit:TextValue assign also changes the Edit:CurrentText and Edit:Value.
      Note that the string is formatted according to the picture clause held in the field specification of the edit field; in turn, edit fields linked to a data server inherit the field specification—and hence picture—from the field of the server.
    </remarks>
  </Edit.TextValue>
  <Edit.Undo>
    <summary>
      Undo the last modification to the text in this edit control.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method only undoes the last change—undos are not nested.
    </remarks>
  </Edit.Undo>
  <Edit.Value>
    <summary>
      Edit:Value contains the text after the previous edit operation. The Edit:TextValue assign also changes the Edit:CurrentText and Edit:TextValue. For non-editable controls (fixed icon, fixed text, group box), Edit:Value is set to NULL_STRING.
    </summary>
    <value>Edit:Value contains the text after the previous edit operation. The Edit:TextValue assign also changes the Edit:CurrentText and Edit:TextValue. For non-editable controls (fixed icon, fixed text, group box), Edit:Value is set to NULL_STRING.</value>
  </Edit.Value>
  <EditFocusChangeEvent>
    <summary>
      Provide information about an EditFocusChangeEvent, generated when an edit control (i.e., SingleLineEdit, MultiLineEdit, or EditWindow) gains or loses the keyboard focus.
    </summary>
  </EditFocusChangeEvent>
  <EditFocusChangeEvent.ctor>
    <inheritdoc />
  </EditFocusChangeEvent.ctor>
  <EditFocusChangeEvent.GotFocus>
    <summary>
      A logical value representing whether an edit control has either just gained keyboard focus (TRUE) or has just lost it (FALSE).
    </summary>
    <value>A logical value representing whether an edit control has either just gained keyboard focus (TRUE) or has just lost it (FALSE).</value>
  </EditFocusChangeEvent.GotFocus>
  <EditFocusChangeEvent.HyperLabel>
    <summary>
      The Hyperlabel connected to the edit control focus change event. From the hyperlabel, you can retrieve additional information about the edit control focus change event—for example:
      <code language="X#">
        cCaption := oEditFocusChangeEvent:HyperLabel:Caption
        cDescription := oEditFocusChangeEvent:HyperLabel:Description
        cHelpContext := oEditFocusChangeEvent:HyperLabel:HelpContext
      </code>
    </summary>
    <value>
      The Hyperlabel connected to the edit control focus change event. From the hyperlabel, you can retrieve additional information about the edit control focus change event—for example:

      cCaption := oEditFocusChangeEvent:HyperLabel:Caption
      cDescription := oEditFocusChangeEvent:HyperLabel:Description
      cHelpContext := oEditFocusChangeEvent:HyperLabel:HelpContext
    </value>
  </EditFocusChangeEvent.HyperLabel>
  <EditWindow>
    <summary>
      Create an edit control as part of the Window hierarchy, thereby allowing the behavior of the edit control to be customized using event handlers.
    </summary>
    <remarks>
      When an edit control is created as part of the Window hierarchy, it can trap events. For example, you might want to customize the appearance of edit controls (like changing the background and foreground colors) or modify their default key handling.
      Manipulating a control via the ControlWindow class requires more overhead than those created by the subclasses of Control. Therefore, it is recommended that control windows be used only where special handling is needed (for example, to override the handling of certain events or call some window method on a control).
    </remarks>
  </EditWindow>
  <EditWindow.ctor>
    <summary>
      Create an edit window.
    </summary>
    <param name="oOwner">The window that owns the edit window.</param>
    <param name="xID">The ID of the edit window.</param>
    <param name="oPoint">The origin of the edit window in canvas coordinates.</param>
    <param name="oDimension">The dimension of the edit window in canvas coordinates.</param>
    <param name="nResourceID">The resource ID of the edit window.</param>
  </EditWindow.ctor>
  <EditWindow.AsString>
    <summary>
      Return the contents of the edit window.
    </summary>
    <remarks>
      This method returns the same as EditWindow:TextValue. EditWindow:AsString() presents the edit window as a recognizable string.
    </remarks>
  </EditWindow.AsString>
  <EditWindow.Clear>
    <summary>
      Delete the current selection in this edit window.
    </summary>
    <remarks>
      If the current selection refers to a cursor position (for example, {5,5}), no text is deleted.
    </remarks>
  </EditWindow.Clear>
  <EditWindow.Control>
    <summary>
      This property is inherited from the ControlWindow class but does not apply to EditWindow. It returns NULL_OBJECT.
    </summary>
    <value>This property is inherited from the ControlWindow class but does not apply to EditWindow. It returns NULL_OBJECT.</value>
  </EditWindow.Control>
  <EditWindow.ControlID>
    <summary>
      This property is inherited from the EditControl class but does not apply to EditWindow. Its return value is NIL.
    </summary>
    <value>This property is inherited from the EditControl class but does not apply to EditWindow. Its return value is NIL.</value>
  </EditWindow.ControlID>
  <EditWindow.Copy>
    <summary>
      Copy the text that is currently selected in an edit window to the clipboard.
    </summary>
    <remarks>
      If the current selection refers to a cursor position (for example, {5,5}), no text is copied.
    </remarks>
  </EditWindow.Copy>
  <EditWindow.Cut>
    <summary>
      Delete the text that is currently selected in an edit window and copy it to the clipboard.
    </summary>
    <remarks>
      If the current selection refers to a cursor position (for example, {5,5}), no text is deleted.
    </remarks>
  </EditWindow.Cut>
  <EditWindow.Destroy>
    <summary>
      Free memory resources allocated for a EditWindow object and its derived objects.
    </summary>
    <remarks>
      This method immediately frees resources for EditWindow objects created explicitly in your application.
      EditWindow:Destroy() also takes care of resources allocated to derived classes and deallocates them in the necessary order.
    </remarks>
  </EditWindow.Destroy>
  <EditWindow.GetLine>
    <summary>
      Get a specified line of text in this edit window.
    </summary>
    <param name="nLineNumber">The position of the desired line in the edit window. Specify one of the following values:</param>
    <param name="Value">Position</param>
    <param name="0">The current line in the edit window (that is, the line currently containing the text cursor). This is the default.</param>
    <param name="1">The first line in the edit window.</param>
    <param name="n">The nth line in the edit window.</param>
    <param name="nMaxLength">The maximum length that you expect the string to be in any language. If not specified, the system substitutes 255. If it is set too low, Windows truncates the resource string.</param>
    <returns>
      The text of the specified line.
    </returns>
  </EditWindow.GetLine>
  <EditWindow.Length>
    <summary>
      A numeric value representing the number of characters in this edit window.
    </summary>
    <value>A numeric value representing the number of characters in this edit window.</value>
  </EditWindow.Length>
  <EditWindow.LineCount>
    <summary>
      A numeric value representing the number of text lines in this edit window.
    </summary>
    <value>A numeric value representing the number of text lines in this edit window.</value>
  </EditWindow.LineCount>
  <EditWindow.LineDown>
    <summary>
      Scroll the text in this edit window down by a single line.
    </summary>
  </EditWindow.LineDown>
  <EditWindow.LineUp>
    <summary>
      Scroll the text in this edit window up by a single line.
    </summary>
  </EditWindow.LineUp>
  <EditWindow.PageDown>
    <summary>
      Scroll the text in this edit window down by a single page.
    </summary>
    <remarks>
      A page is the number of lines that fits in the current edit window in the current font.
    </remarks>
  </EditWindow.PageDown>
  <EditWindow.PageUp>
    <summary>
      Scroll the text in this edit window up by a single page.
    </summary>
    <remarks>
      A page is the number of lines that fits in the current edit window in the current font.
    </remarks>
  </EditWindow.PageUp>
  <EditWindow.Paste>
    <summary>
      Replace the text that is currently selected in an edit window with the contents of the clipboard.
    </summary>
    <param name="cNewString">The text to be placed in the edit window. If not specified, the contents of the clipboard is used.</param>
    <remarks>
      If the current selection refers to a cursor position (for example, {5,5}), the text is inserted at that point and no text is deleted.
    </remarks>
  </EditWindow.Paste>
  <EditWindow.ScrollHorizontal>
    <summary>
      Scroll the current line in this edit window a specified number of characters to the right or left.
    </summary>
    <param name="nChars">The number of characters to scroll. Positive values scroll to the right; negative values to the left.</param>
  </EditWindow.ScrollHorizontal>
  <EditWindow.ScrollVertical>
    <summary>
      Scroll the current line in this edit window up or down a specified number of lines.
    </summary>
    <param name="nLines">The number of lines to scroll. Positive values scroll up; negative values down.</param>
  </EditWindow.ScrollVertical>
  <EditWindow.Selection>
    <summary>
      A Selection object, representing the currently selected text in the edit window.
    </summary>
    <value>A Selection object, representing the currently selected text in the edit window.</value>
    <remarks>
      A Selection object, representing the currently selected text in the edit window.
      For example, a Selection value of {5,10} means the text from position 5 through 9 inclusive is selected, while a Selection value of {5,5} means the cursor is positioned in front of the fifth character.
    </remarks>
  </EditWindow.Selection>
  <EditWindow.TextLimit>
    <summary>
      A numeric value representing the maximum number of characters the edit window can hold.
    </summary>
    <value>A numeric value representing the maximum number of characters the edit window can hold.</value>
    <remarks>
      A numeric value representing the maximum number of characters the edit window can hold. A value of 0 indicates that there is no limit being imposed. If the limit specified is less than the size of the text already in the buffer, the existing text is truncated.
    </remarks>
  </EditWindow.TextLimit>
  <EditWindow.TextValue>
    <summary>
      A string representing the value held in the edit window.
    </summary>
    <value>A string representing the value held in the edit window.</value>
    <remarks>
      A string representing the value held in the edit window. For example, the value can be "Jones" or "$14,683.00".
    </remarks>
  </EditWindow.TextValue>
  <EditWindow.Undo>
    <summary>
      Undo the last modification to the text in this edit window.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method only undoes the last change—undos are not nested.
    </remarks>
  </EditWindow.Undo>
  <EditWindow.Value>
    <summary>
      The value held in the edit field in whatever data type the edit window holds.
    </summary>
    <value>The value held in the edit field in whatever data type the edit window holds.</value>
    <remarks>
      The value held in the edit field in whatever data type the edit window holds. For example, the value can be the string "Jones" or the number 14683.
      The data type of the edit window is determined by its field specification; in turn, edit windows linked to a data server inherit the field specification—and hence data type—from the field of the server.
    </remarks>
  </EditWindow.Value>
  <EllipseObject>
    <summary>
      Create an EllipseObject object; this type of entity is part of the DrawObject hierarchy, which provides a means of displaying and manipulating various objects.
    </summary>
    <example>
      To draw an EllipseObject object, call Window:Draw() with the EllipseObject object as its argument. The window does the drawing by asking each object to draw itself—for example:
      <code language="X#">
        METHOD Expose(oEvent) CLASS MyWindow
        LOCAL oEllipse AS OBJECT
        oEllipse := EllipseObject{Point{10,10},;
        Dimension{20,40}}
        SELF:Draw(oEllipse)
      </code>
    </example>
  </EllipseObject>
  <EllipseObject.ctor>
    <summary>
      Construct an EllipseObject object.
    </summary>
    <param name="oPoint">The position of the EllipseObject object in canvas coordinates.</param>
    <param name="oDimension">The dimension of the EllipseObject object in canvas coordinates.</param>
    <param name="oPen">The pen used to draw the EllipseObject object. By default, the current pen is used.</param>
    <param name="oBrush">The brush used to fill the EllipseObject object. By default, the current brush is used.</param>
  </EllipseObject.ctor>
  <EllipseObject.Draw>
    <summary>
      Draw this EllipseObject object.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This method should not be invoked directly in the application code—it is invoked in X# by Window:Draw(). Refer to the EllipseObject class description for an example using the Draw() method.
    </remarks>
  </EllipseObject.Draw>
  <Error>
    <summary>
      Create an Error object, which contains information about runtime errors.
    </summary>
    <remarks>
      An Error object is a simple object that contains information pertaining to a runtime error. Error objects have no methods, only exported instance variables.
      When a runtime error occurs, X# creates a new Error object and passes it as an argument to the error handler block specified with the ErrorBlock() function. Within the error handler, the Error object can then be queried to determine the nature of the error condition.
      Error objects can also be returned to the RECOVER statement of a BEGIN SEQUENCE construct with a BREAK statement. Similarly, Error objects are also be passed to error methods of DataServer or DataWindow objects. Here, the Error object can be queried for local error handling. For more detailed information and examples, see "Error and Exception Handling" in the Programmer's Guide.
    </remarks>
  </Error>
  <ErrorBox>
    <summary>
      Present the user with an error message box.
    </summary>
    <remarks>
      An error message box is a window that contains the text "Error" in the title bar, the text of the message, and a warning icon.
      Error boxes are application modal—the user must acknowledge them before continuing with the application. When the error box closes, focus is returned to its owner window.
    </remarks>
    <example>
      The following example creates and shows an error message box (whose owner is oMyWin) that displays the text "Oops, We have an error!" to the user:
      <code language="X#">
        METHOD Start() CLASS App
        oMyWin := TopAppWindow{}
        oMyWin:Show()
        oErrBox := ErrorBox{oMyWin,;
        "Oops, We have an error!"}
        oErrBox:Show()
        SELF:Exec()
      </code>
    </example>
  </ErrorBox>
  <ErrorBox.ctor>
    <summary>
      Construct an error message box.
    </summary>
    <param name="uParent">The window that owns the error box. If no owner is specified, the error box is application modal (i.e., the application is suspended until the user acknowledges the error box).</param>
    <param name="uText">The description to be displayed in the error box. If no text is specified, the system-defined 'Error!' error message text is used.</param>
    <param name="oHyperLabel">The hyperlabel containing a description (HyperLabel:Description) to be displayed in the error box.</param>
  </ErrorBox.ctor>
  <Event>
    <summary>
      Provide the base class from which all X# events are subclassed.
    </summary>
    <remarks>
      The system dispatcher dispatches events to the event handler in the appropriate window. The Event class always maps onto the GUI's event or message structure.
      Events are transient objects that carry information to windows indicating that a system event has occurred. For example, the information that a window has been uncovered is passed to that window's Expose() event handler as an Event object.
    </remarks>
  </Event>
  <Event.ctor>
    <summary>
      Construct an event.
    </summary>
    <remarks>
      <note type="Warning">X# instantiates events.</note>
    </remarks>
    <param name="_hWnd">The handle of the window for which the event occurred, or an Event Object. The runtime checks to see if _hWnd is a pointer. When not then it assumes it is an event object and it clones the values from this object.</param>
    <param name="_uMsg">The message (WM_..) that occurred</param>
    <param name="_wParam">The WPARAM of the message</param>
    <param name="_lParam">The LPARAM of the message</param>
    <param name="_oWindow">The Window object that was associated with the event.</param>
  </Event.ctor>
  <Event.Handle>
    <summary>
      The pointer to the window where the event occurred
    </summary>
    <value>The pointer to the window where the event occurred</value>
  </Event.Handle>
  <Event.hWnd>
    <summary>
      The pointer to the window where the event occurred
    </summary>
    <value>The pointer to the window where the event occurred</value>
  </Event.hWnd>
  <Event.lParam>
    <summary>
      A long integer representing the LPARAM of the Windows API message associated with the given event.
    </summary>
    <value>A long integer representing the LPARAM of the Windows API message associated with the given event.</value>
    <remarks>
      A long integer representing the LPARAM of the Windows API message associated with the given event.
      This can be used in the Dispatch() method of the EventContext class for processing of custom messages.
    </remarks>
  </Event.lParam>
  <Event.Message>
    <summary>
      A dword representing the Windows API message associated with the given event.
    </summary>
    <value>A dword representing the Windows API message associated with the given event.</value>
    <remarks>
      A dword representing the Windows API message associated with the given event.
      This can be used in the Dispatch() method of EventContext class for processing of custom messages.
    </remarks>
  </Event.Message>
  <Event.oWindow>
    <summary>
      An object indicating the window or control in which the event occurred. This is helpful, for example, for distinguishing between similar menu events coming from the same context menu attached to different controls.
    </summary>
    <value>An object indicating the window or control in which the event occurred. This is helpful, for example, for distinguishing between similar menu events coming from the same context menu attached to different controls.</value>
  </Event.oWindow>
  <Event.uMsg>
    <summary>
      A dword representing the Windows API message associated with the given event.
    </summary>
    <value>A dword representing the Windows API message associated with the given event.</value>
    <remarks>
      A dword representing the Windows API message associated with the given event.
      This can be used in the Dispatch() method of EventContext class for processing of custom messages.
    </remarks>
  </Event.uMsg>
  <Event.Window>
    <summary>
      An object indicating the window or control in which the event occurred. This is helpful, for example, for distinguishing between similar menu events coming from the same context menu attached to different controls.
    </summary>
    <value>An object indicating the window or control in which the event occurred. This is helpful, for example, for distinguishing between similar menu events coming from the same context menu attached to different controls.</value>
  </Event.Window>
  <Event.wParam>
    <summary>
      A dword representing the WPARAM of the Windows API message associated with the given event.
    </summary>
    <value>A dword representing the WPARAM of the Windows API message associated with the given event.</value>
    <remarks>
      A dword representing the WPARAM of the Windows API message associated with the given event.
      This can be used in the Dispatch() method of the EventContext class for processing of custom messages.
    </remarks>
  </Event.wParam>
  <EventContext>
    <summary>
      Provide the base class from which all X# event-handling classes are subclassed, embodying the elements needed by any objects that receive events.
    </summary>
    <remarks>
      The EventContext class provides:
      A dispatcher
      A default event handler
      A method enabling the dispatcher
    </remarks>
  </EventContext>
  <EventContext.ctor>
    <summary>
      Construct an event context.
    </summary>
  </EventContext.ctor>
  <EventContext.Destroy>
    <summary>
      Destroy the event context permanently.
    </summary>
    <remarks>
      This method can be used when an EventContext object is no longer needed. EventContext:Destroy() de-instantiates the Event Context object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </EventContext.Destroy>
  <EventContext.Override>
    <summary>This is a compatibility method that is no longer used or needed.</summary>
  </EventContext.Override>
  <EventContext.SelfPtrStruc>
    <exclude />
  </EventContext.SelfPtrStruc>
  <ExplorerWindow>
    <summary>
      Create an explorer window.
    </summary>
    <remarks>
      An explorer window is a two- or four-pane split window that mimics the functionality of Microsoft Windows application windows, such as File Manager or Explorer. The explorer window contains a list view control and a tree view control, as well as optional fixed text controls. The programming interfaces for these controls can be used directly to manipulate the window.
      A two-pane explorer window contains a list view and a tree view side-by-side, separated by a vertical split bar that can be dragged. A four-pane explorer window contains a list view and a tree view side-by-side, with fixed text that serves as a label above each. The list view and tree view are separated by a vertical split bar that can be dragged. The fixed text labels are separated from the list view and tree view by a horizontal split bar that cannot be dragged. Panes are aligned vertically.
    </remarks>
  </ExplorerWindow>
  <ExplorerWindow.ctor>
    <summary>
      Construct an ExplorerWindow object.
    </summary>
    <param name="oOwner">The window that owns the explorer window.</param>
    <param name="lLabels">A logical value that is TRUE if you want to create a four-pane explorer window (a four-pane explorer window contains 'labels', or fixed text controls) and FALSE if you want to create a two-pane explorer window. If omitted, the default is TRUE.</param>
    <param name="symTreeViewClassName">The symbolic name of the TreeView class.</param>
    <param name="symListViewClassName">The symbolic name of the ListView class.</param>
  </ExplorerWindow.ctor>
  <ExplorerWindow.Destroy>
    <inheritdoc />
  </ExplorerWindow.Destroy>
  <ExplorerWindow.LabelLeft>
    <summary>
      The left fixed text control in a four-pane explorer window. In a two-pane explorer window, this returns NULL_OBJECT.
    </summary>
    <value>The left fixed text control in a four-pane explorer window. In a two-pane explorer window, this returns NULL_OBJECT.</value>
  </ExplorerWindow.LabelLeft>
  <ExplorerWindow.LabelRight>
    <summary>
      The right fixed text control in a four-pane explorer window. In a two-pane explorer window, this returns NULL_OBJECT.
    </summary>
    <value>The right fixed text control in a four-pane explorer window. In a two-pane explorer window, this returns NULL_OBJECT.</value>
  </ExplorerWindow.LabelRight>
  <ExplorerWindow.ListView>
    <summary>
      The list view control in a two- or four-pane explorer window.
    </summary>
    <value>The list view control in a two- or four-pane explorer window.</value>
  </ExplorerWindow.ListView>
  <ExplorerWindow.ListViewColumnClick>
    <inheritdoc />
  </ExplorerWindow.ListViewColumnClick>
  <ExplorerWindow.TreeView>
    <summary>
      The tree view control in a two- or four-pane explorer window.
    </summary>
    <value>The tree view control in a two- or four-pane explorer window.</value>
  </ExplorerWindow.TreeView>
  <ExposeEvent>
    <summary>
      Provide information about an ExposeEvent, used to notify a window that it may need to be repainted.
    </summary>
    <remarks>
      An ExposeEvent occurs when a window is:
      First shown
      Moved or closed
      Moving or closing a window exposes the area underneath the window; if any other windows are in this newly exposed area, they need to be repainted. The system automatically sends these window(s) an ExposeEvent to notify them that they must repaint the area that was uncovered.
      Resized
      The ExposeEvent goes to the Window:Expose() event handler with the responsibility for repainting the exposed area. You should place your own code in this event handler if you want your application to do something when its window is exposed.
    </remarks>
    <example>
      The following example prints different messages, depending on what part of the window has been exposed:
      <code language="X#">
        METHOD Expose(oEE) CLASS MyWindow
        LOCAL oBB AS BOUNDINGBOX
        oBB := oEE:ExposedArea
        IF oBB:Bottom() &lt; 20
        SELF:TextPrint("In the 20's",Point{0,20})
        ENDIF
        IF oBB:Bottom() &gt; 40
        SELF:TextPrint("In the 40's",Point{0,40})
        ENDIF
      </code>
    </example>
  </ExposeEvent>
  <ExposeEvent.ctor>
    <inheritdoc />
  </ExposeEvent.ctor>
  <ExposeEvent.ExposedArea>
    <summary>
      A bounding box—in canvas coordinates—representing the exposed area that caused this expose event.
      Use this method to optimize your repainting routines so that they paint only the area which requires refreshing.
    </summary>
    <value>
      A bounding box—in canvas coordinates—representing the exposed area that caused this expose event.
      Use this method to optimize your repainting routines so that they paint only the area which requires refreshing.
    </value>
  </ExposeEvent.ExposedArea>
  <FixedBitmap>
    <summary>
      Create a FixedBitmap object. Unlike the bitmaps created by the Bitmap class, fixed bitmaps are static—they do not need to be redisplayed every time an ExposeEvent occurs. FixedBitmap objects can be created dynamically or from a resource entity.
    </summary>
    <example>
      This example creates a fixed bitmap from a resource entity and changes its position to the lower-left corner of a dialog window:
      <code language="X#">
        CLASS MyDialogWindow INHERIT DialogWindow
        HIDDEN OMyFBitmap AS OBJECT
        METHOD Init(oWindow) CLASS MyDialogWIndow
        SUPER:Init(oWindow,ID_MYDIALOG)
        OMyFBitmap := FixedBitmap{SELF,MYBITMAP}
        OMyFBitmap:Origin := Point{10,10}
        SELF:Show()
      </code>

      In Windows, a fixed bitmap is equivalent to a static object with the SS_BITMAP style. These are normally specified in the resource entity as follows:
      <code language="X#">
        RESOURCE IDI_FIXEDBITMAP BITMAP fixed.bmp
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 80
        STYLE WS_POPUP | WS_DLGFRAME
        BEGIN
        BITMAP IDI_FIXEDBITMAP -1, 8, 8, 0, 0
        END
      </code>
    </example>
  </FixedBitmap>
  <FixedBitmap.ctor>
    <summary>
      Construct a FixedBitmap object.
    </summary>
    <param name="uOwner">The window that owns the fixed bitmap.</param>
    <param name="uID">The ID of the fixed bitmap.</param>
    <param name="uPoint">The origin of the fixed bitmap in canvas coordinates.</param>
    <param name="uDimension">The dimension of the fixed bitmap in canvas coordinates.</param>
    <param name="uResID">Resource ID object or numeric resource ID for the bitmap image to be associated with this FixedBitmap static control.</param>
    <param name="oResourceID">The ResourceID object of the fixed bitmap or the resource ID of the fixed bitmap.</param>
  </FixedBitmap.ctor>
  <FixedBitmap.AsString>
    <summary>
      Return the identifying label of the fixed bitmap.
    </summary>
  </FixedBitmap.AsString>
  <FixedBitmap.SetBitmap>
    <summary>
      Associate a bitmap image with the FixedBitmap static control.
    </summary>
    <param name="oBitmap">The bitmap object to associate with this static control.</param>
  </FixedBitmap.SetBitmap>
  <FixedIcon>
    <summary>
      Create a FixedIcon object. Unlike the icons created by the Icon class, fixed icons are static—they do not need to be redisplayed every time an ExposeEvent occurs. FixedIcon objects can be created dynamically or from a resource entity.
    </summary>
    <example>
      This example creates a fixed icon from a resource entity and changes its position to the lower-left corner of a dialog window:
      <code language="X#">
        CLASS MyDialogWindow INHERIT DialogWindow
        HIDDEN OMyFIcon AS OBJECT
        METHOD Init(oWindow) CLASS MyDialogWIndow
        SUPER:Init(oWindow,ID_MYDIALOG)
        OMyFIcon := FixedIcon{SELF,MYICON}
        OMyFIcon:Origin := Point{10,10}
        SELF:Show()
      </code>

      In Windows, a fixed icon is equivalent to a static object with the SS_ICON style. These are normally specified in the resource entity as follows:
      <code language="X#">
        RESOURCE IDI_FIXEDICON ICON fixed.ico
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 80
        STYLE WS_POPUP | WS_DLGFRAME
        BEGIN
        ICON IDI_FIXEDICON -1, 8, 8, 0, 0
        END
      </code>
    </example>
  </FixedIcon>
  <FixedIcon.ctor>
    <summary>
      Construct a FixedIcon object.
    </summary>
    <param name="uOwner">The window that owns the fixed icon.</param>
    <param name="uID">The ID of the fixed icon.</param>
    <param name="uPoint">The origin of the fixed icon in canvas coordinates.</param>
    <param name="uResID">The ResourceID object of the fixed icon or the resource ID of the fixed icon.</param>
  </FixedIcon.ctor>
  <FixedIcon.AsString>
    <summary>
      Return the identifying label of the fixed icon.
    </summary>
  </FixedIcon.AsString>
  <FixedIcon.Destroy>
    <summary>
      Provide a method to de-instantiate a FixedIcon object.
    </summary>
    <remarks>
      This method can be used when a FixedIcon object is no longer needed. FixedIcon:Destroy() de-instantiates the FixedIcon object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </FixedIcon.Destroy>
  <FixedIcon.SetIcon>
    <exclude />

  </FixedIcon.SetIcon>
  s<FixedImage>
    <summary>
      Provide the base class from which FixedBitmap and FixedIcon are subclassed.
    </summary>
    <remarks>
      FixedImage is the base class for the FixedBitmap and FixedIcon subclasses.
    </remarks>
  </FixedImage>
  <FixedImage.ctor>
    <summary>
      Construct a FixedImage control.
    </summary>
    <param name="uOwner">The window that owns the control.</param>
    <param name="uID">The unique ID of the control (between 1 and 8000).</param>
    <param name="uPoint">The origin of the control in canvas coordinates.</param>
    <param name="uDimension">The dimension of the control in canvas coordinates.</param>
    <param name="uResID">The resource ID of the control.</param>
  </FixedImage.ctor>
  <FixedImage.Destroy>
    <summary>
      Provide a method to de-instantiate a FixedImage object.
    </summary>
    <remarks>
      This method can be used when a FixedImage object is no longer needed. FixedImage:Destroy() de-instantiates the FixedImage object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </FixedImage.Destroy>
  <FixedText>
    <summary>
      Create a FixedText object.
    </summary>
    <remarks>
      Unlike text displayed with Window:TextPrint(), fixed text from a FixedText object is static—they do not need to be redisplayed every time an ExposeEvent occurs. FixedText objects can be created dynamically or from a resource entity.
      <note type="tip">The text in a FixedText object can be changed by assigning TextControl:TextValue. In such a case, it may be necessary to resize the FixedText object because the size of the control dictates the clipping region for the displayed text.</note><note type="tip">
        As of Visual Obejcts version 2.7 the FixedText control supports the DrawText and Transparent options. These are on by default.
        If the old behaviour is required, set the EXPORTed variable lUseDrawText to FALSE. It is TRUE by default.
        If WinXP Themes are enabled and you want to stop the drawing of the theme behind the FixedText control, set the EXPORTed variable lDrawThemeBackground to FALSE. It is TRUE by default.
      </note>
    </remarks>
    <example>
      This example places some fixed text on a window:
      <code language="X#">
        CLASS MyWindow INHERIT TopAppWindow
        HIDDEN MyFT AS OBJECT
        METHOD Init() CLASS MyWindow
        p := Point{10,10}
        d := Dimension{10,10}
        MyFT:= FixedText{SELF,1,p,d,"The text"}
        SELF:Show()
        MyFT:Show()
      </code>

      In Windows, fixed text is equivalent to a static object with one of the SS_LEFT, SS_CENTER, SS_RIGHT styles.
      These are normally specified in the resource entity as follows:
      <code language="X#">
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 80
        STYLE WS_POPUP | WS_DLGFRAME
        BEGIN
        LTEXT "Left justified" -1, 8, 8, 120, 12
        CTEXT "Centered"    -1, 8, 24, 120, 12
        RTEXT "Right justified" -1, 8, 36, 120, 12
        DEFPUSHBUTTON "OK"   IDB_OK, 64, 60, 32, 14, WS_GROUP
        END
      </code>
    </example>
  </FixedText>
  <FixedText.ctor>
    <summary>
      Construct a FixedText object.
    </summary>
    <param name="oOwner">The window that owns the FixedText object.</param>
    <param name="xID">The unique ID of the FixedText object.</param>
    <param name="oPoint">The origin of the FixedText object in canvas coordinates.</param>
    <param name="oDimension">The dimension of the FixedText object in canvas coordinates.</param>
    <param name="cText">The informational text to be printed in the FixedText object. The default is NULL_STRING.</param>
    <param name="lDataAware">A logical value specifying whether the FixedText object is data aware.</param>
    <param name="nResourceID">The resource ID of the FixedText object.</param>
  </FixedText.ctor>
  <FixedText.Destroy>
    <summary>
      Provide a method to de-instantiate a FixedText object.
    </summary>
    <remarks>
      This method can be used when a FixedText object is no longer needed. FixedText:Destroy() de-instantiates the FixedText object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </FixedText.Destroy>
  <FixedText.Dispatch>
    <inheritdoc />
  </FixedText.Dispatch>
  <FixedText.lDrawThemeBackground>
    <exclude />
  </FixedText.lDrawThemeBackground>
  <FixedText.lUseDrawText>
    <exclude />
  </FixedText.lUseDrawText>
  <FixedText.SetDrawStyle>
    <summary>
      Set the alignment style for the text in a FixedText object.
    </summary>
    <param name="dwDrawStyle">The style to set. See table in the remarks section.</param>
    <param name="lEnable">A logical value to set the style. TRUE sets the style on, FALSE turns it off.</param>
    <remarks>
      <list>
        <listheader>
          <term>Value</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>DT_BOTTOM</term>
          <description>Justifies the text to the bottom of the rectangle. This value must be combined with DT_SINGLELINE.</description>
        </item>
        <item>
          <term>DT_CALCRECT</term>
          <description>
            Determines the width and height of the rectangle. If there are multiple lines of text,
            DrawText uses the width of the rectangle pointed to by the lpRect parameter and extends the base of the
            rectangle to bound the last line of text. If there is only one line of text,
            DrawText modifies the right side of the rectangle so that it bounds the last character in the line.
            In either case, DrawText returns the height of the formatted text but does not draw the text.
          </description>
        </item>
        <item>
          <term>DT_CENTER</term>
          <description>Centers text horizontally in the rectangle.</description>
        </item>
        <item>
          <term>DT_EDITCONTROL</term>
          <description>
            Duplicates the text-displaying characteristics of a multiline edit control.
            Specifically, the average character width is calculated in the same manner as for an edit control,
            and the function does not display a partially visible last line.
            Replaces part of the given string with ellipses, if necessary, so that the result fits in the specified rectangle.
            The given string is not modified unless the DT_MODIFYSTRING flag is specified.You can specify DT_END_ELLIPSIS to
            replace characters at the end of the string, or DT_PATH_ELLIPSIS to replace characters in the middle of the string.
            If the string contains backslash (\) characters, DT_PATH_ELLIPSIS preserves as much as possible of the text after the last backslash.
          </description>
        </item>
        <item>
          <term>DT_EXPANDTABS</term>
          <description>
            Expands tab characters. The default number of characters per tab is eight.
            Includes the font external leading in line height. Normally, external leading is not included in the height of a line of text.
          </description>
        </item>
        <item>
          <term>DT_LEFT</term>
          <description>Aligns text to the left.</description>
        </item>
        <item>
          <term>DT_MODIFYSTRING</term>
          <description>
            Modifies the given string to match the displayed text.
            This flag has no effect unless the DT_END_ELLIPSIS or DT_PATH_ELLIPSIS flag is specified.
          </description>
        </item>
        <item>
          <term>DT_NOCLIP</term>
          <description>Draws without clipping. DrawText is somewhat faster when DT_NOCLIP is used.</description>
        </item>
        <item>
          <term>DT_NOPREFIX</term>
          <description>
            Turns off processing of prefix characters.
            Normally, DrawText interprets the mnemonic-prefix character &amp; as a directive to underscore the character
            that follows, and the mnemonic-prefix characters &amp;&amp; as a directive to print a single &amp;.
            By specifying DT_NOPREFIX, this processing is turned off.
          </description>
        </item>
        <item>
          <term>DT_RIGHT</term>
          <description>Aligns text to the right.</description>
        </item>
        <item>
          <term>DT_RTLREADING</term>
          <description>
            Layout in right to left reading order for bi-directional text when the font selected into the hdc
            is a Hebrew or Arabic font. The default reading order for all text is left to right.
          </description>
        </item>
        <item>
          <term>DT_SINGLELINE</term>
          <description>Displays text on a single line only. Carriage returns and linefeeds do not break the line.</description>
        </item>
        <item>
          <term>DT_TABSTOP</term>
          <description>
            Sets tab stops. Bits 15-8 (high-order byte of the low-order word) of the uFormat
            parameter specify the number of characters for each tab. The default number of characters per tab is eight.
          </description>
        </item>
        <item>
          <term>DT_TOP</term>
          <description>Top-justifies text (single line only).</description>
        </item>
        <item>
          <term>DT_VCENTER</term>
          <description>Centers text vertically (single line only).</description>
        </item>
        <item>
          <term>DT_WORDBREAK</term>
          <description>
            Breaks words. Lines are automatically broken between words if a word would extend past the edge of the rectangle
            specified by the lpRect parameter. A carriage return-linefeed sequence also breaks the line.
          </description>
        </item>
        <item>
          <term></term>
          <description></description>
        </item>
        <item>
          <term></term>
          <description></description>
        </item>
      </list>
    </remarks>
  </FixedText.SetDrawStyle>
  <FixedText.SetStandardStyle>
    <summary>
      Set the alignment style for the text in a FixedText object.
    </summary>
    <param name="kTextStyle">
      The text alignment style, specified as one of the following constants:
      <list type="Table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>FT_CENTERED</term>
          <description>Centered text</description>
        </item>
        <item>
          <term>FT_LEFTALIGN</term>
          <description>Left-aligned text (This is the default.)</description>
        </item>
        <item>
          <term>FT_RIGHTALIGN</term>
          <description>Right-aligned text</description>
        </item>
      </list>
    </param>
  </FixedText.SetStandardStyle>
  <FocusChangeEvent>
    <summary>
      Provide information about a FocusChangeEvent, used to indicate a change in window focus (i.e., gaining or losing focus).
    </summary>
    <remarks>
      When a window comes in or out of focus, the dispatcher generates a FocusChangeEvent and sends it to Window:FocusChange(). When the input focus changes, the window losing the focus gets a FocusChangeEvent (telling it that it is losing the focus) and the window gaining the focus receives a FocusChangeEvent (telling it that it is gaining the focus).
      A window that has focus gets KeyEvents when the user hits the keyboard. This is similar to an active window, but an active window receives MouseEvents instead of KeyEvents.
      Tip: Applications using cursors should use FocusChangeEvent to determine whether to create or destroy the cursor.
    </remarks>
    <example>
      The following example locks the attached data server when the window gets focus:
      <code language="X#">
        METHOD FocusChange(oFCE) CLASS TopAppWindow
        IF(oFCE:GotFocus)
        Server:RLock()
        ELSE
        Server:Unlock()
        ENDIF
      </code>
    </example>
  </FocusChangeEvent>
  <FocusChangeEvent.ctor>
    <inheritdoc />
  </FocusChangeEvent.ctor>
  <FocusChangeEvent.GotFocus>
    <summary>
      A logical value determining whether a window has either gained keyboard focus (TRUE) or is about to lose it (FALSE).
    </summary>
    <value>A logical value determining whether a window has either gained keyboard focus (TRUE) or is about to lose it (FALSE).</value>
  </FocusChangeEvent.GotFocus>
  <Font>
    <summary>
      Create a font, which describes how characters are displayed on a window.
    </summary>
    <remarks>
      X# provides a set of predefined fonts, defined with the Font:Init() method. In addition, if desired, you can also create a font by specifying a particular size and style.)
      Although you supply specifics for a new font, the GUI actually picks an actual font which best fits the description provided.
      Each window has a currently selected font. Window:TextPrint() and Window:SizeText() use this font when they are printing or sizing text.
      <note type="tip">
        Deselecting a Font:	In Windows, the current font should be deselected before destroying the window. To do this, use Window:Font to assign the previous font, for example. However, this is only necessary if there is a font other than the default one currently selected.
        Font Pitch:	A font's pitch can be either variable or fixed. In variable pitch fonts, characters are proportionally spaced (for example, a variable pitch font uses more space to print an "M" than an "i"). In fixed pitch fonts, the same amount of space is used by each character, regardless of the character width. Fixed pitch fonts are most commonly used by terminals and typewriters or to display program text.
        Variable pitched fonts are not always supported. This is dependent on the individual font.
      </note>
    </remarks>
    <example>
      The following text illustrates how to write some text in italics:
      <code language="X#">
        ...
        oMyFont := Font{FONTROMAN10}
        oMyFont:Italic := TRUE
        oOldFont := oMyWindow:Font
        oMyWindow:Font := oMyFont
        oMyWindow:TextPrint("Italic text",Point{10,10})
        oMyWindow:Font := oOldFont
      </code>
    </example>
  </Font>
  <Font.ctor>
    <summary>
      Construct a font.
    </summary>
    <param name="kFont">
      The standard font to be created, specified as one of the constants in the table in the remarks section or the
      constant that indicates the font family. Specify one of the following constants:
    </param>
    <param name="oDimension">The dimension of the font in canvas coordinates or the windows point size for the font.</param>
    <param name="sTypeFace">The specific font name.</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>kStandardFont</term>
          <description>Point Size/Font</description>
        </listheader>
        <item>
          <term>FONTMODERN8</term>
          <description>8 point Courier</description>
        </item>
        <item>
          <term>FONTMODERN10</term>
          <description>10 point Courier</description>
        </item>
        <item>
          <term>FONTMODERN12</term>
          <description>12 point Courier</description>
        </item>
        <item>
          <term>FONTROMAN8</term>
          <description>8 point Times Roman</description>
        </item>
        <item>
          <term>FONTROMAN10</term>
          <description>10 point Times Roman</description>
        </item>
        <item>
          <term>FONTROMAN12</term>
          <description>12 point Times Roman</description>
        </item>
        <item>
          <term>FONTROMAN14</term>
          <description>14 point Times Roman</description>
        </item>
        <item>
          <term>FONTROMAN18</term>
          <description>18 point Times Roman</description>
        </item>
        <item>
          <term>FONTROMAN24</term>
          <description>24 point Times Roman</description>
        </item>
        <item>
          <term>FONTSWISS8</term>
          <description>8 point Helvetica</description>
        </item>
        <item>
          <term>FONTSWISS10</term>
          <description>10 point Helvetica</description>
        </item>
        <item>
          <term>FONTSWISS12</term>
          <description>12 point Helvetica</description>
        </item>
        <item>
          <term>FONTSWISS14</term>
          <description>14 point Helvetica</description>
        </item>
        <item>
          <term>FONTSWISS18</term>
          <description>18 point Helvetica</description>
        </item>
        <item>
          <term>FONTSWISS24</term>
          <description>24 point Helvetica</description>
        </item>
        <item>
          <term>FONTSYSTEM8</term>
          <description>8 point default system font</description>
        </item>
        <item>
          <term></term>
          <description></description>
        </item>
      </list>
      <list type="table">
        <listheader>
          <term>kFamiliy</term>
          <description>Font Family</description>
        </listheader>
        <item>
          <term>FONTANY</term>
          <description>Any displayable font.  This is the default.   </description>
        </item>
        <item>
          <term>FONTDECORATIVE</term>
          <description>A system-dependent decorative font, e.g. FormalScrp421 BT.</description>
        </item>
        <item>
          <term>FONTMODERN</term>
          <description>Similar to Courier. </description>
        </item>
        <item>
          <term>FONTROMAN</term>
          <description>Similar to Times Roman</description>
        </item>
        <item>
          <term>FONTSCRIPT</term>
          <description>Similar to script handwriting,e.g. BrushScript</description>
        </item>
        <item>
          <term>FONTSWISS</term>
          <description>Similar to Helvetica.</description>
        </item>
      </list>

      Defining what font you want is potentially complicated, for two reasons: different computers may have different sets of
      fonts installed and the same font may have different names on different computers. For
      example, the Helvetica font family which looks like this: Helvetica, is known as Helv, Helvetica, Arial, Swiss or MS Sans Serif,
      depending on what system you are using. The standard name for this font here is FontSwiss.
      To ensure that a program will work, regardless of what fonts are available on each computer, the Font class provides automatic methods
      for finding a reasonable match to the font you specify.
      In practice, however, as long as you use the most common names you will not have a problem since all versions of Windows
      contain the standard fonts.
      For example, to create a font of 10 pt Times New Roman and one of 8 pt Helvetica:
      <code language="X#">
        oFontRoman := Font{FONTROMAN10}	//
        oFontSwiss := Font{FONTSWISS8}		//
      </code>
      The system allows you to reference any font installed on the machine. For example, to create a font of 12 pt Palatino,
      <code language="X#">oMyFont := Font{,Dimension{12,12},"Palatino"}	// </code>
      Or a font of 16 pt Arial:
      <code language="X#">oMyFont := Font{, 16, "Arial"}  // </code>
      That approach, of course, is vulnerable to the font not being available. If Palatino is not available, the system would choose a reasonable facsimile, and if it had never heard of Palatino, this might not be a good match. To help the system come up with a reasonable match, you can specify what font family Palatino belongs to:
      <code language="X#">oMyFont := Font{FONTROMAN, Dimension{12,12},"Palatino"}</code>
      In this case, we would get Times Roman if Palatino was not available.
      You can specify the family only. For example, to create a 10 pt font in whatever is available in the script family:
      <code language="X#">oMyFont := Font{FONTSCRIPT,Dimension{10,10}}</code>
    </remarks>
  </Font.ctor>
  <Font.Bold>
    <summary>
      A logical value determining whether a font is displayed in a bold typeface (TRUE if yes; otherwise, FALSE).
    </summary>
    <value>A logical value determining whether a font is displayed in a bold typeface (TRUE if yes; otherwise, FALSE).</value>
    <remarks>
      <note type="tip">Only one of Font:Light, Font:Normal, and Font:Bold properties can be TRUE for any font.</note>
    </remarks>
  </Font.Bold>
  <Font.CharSet>
    <exclude />
  </Font.CharSet>
  <Font.ClipPrecision>
    <exclude />
  </Font.ClipPrecision>
  <Font.ConvPntToDim>
    <summary>
      Convert a specified point size for the font into a Dimension object.
    </summary>
    <param name="nPntSize">Windows font point size.</param>
    <param name="hDCConv">Handle of the device-context for which to convert the point size. If omitted, defaults to the window canvas.</param>
    <returns>
      The Dimension object representing the specified point size.
    </returns>
    <remarks>
      This method converts a Windows font point size to the appropriate X# Dimension object for drawing on a window canvas.
    </remarks>
  </Font.ConvPntToDim>
  <Font.Create>
    <exclude />

  </Font.Create>
  <Font.Destroy>
    <summary>
      Provide a method to de-instantiate a Font object.
    </summary>
    <remarks>
      This method can be used when a Font object is no longer needed. Font:Destroy() de-instantiates the Font object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </Font.Destroy>
  <Font.Escapement>
    <exclude />
  </Font.Escapement>
  <Font.FaceName>
    <exclude />
  </Font.FaceName>
  <Font.Handle>
    <summary>
      Return the handle for a font.
    </summary>
    <param name="nHandleType">
      The type of handle required. 0 is the only supported option and is the default if <paramref name="nHandle" /> is omitted.
    </param>
    <returns>
      A handle describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
    </remarks>
  </Font.Handle>
  <Font.Height>
    <exclude />
  </Font.Height>
  <Font.Italic>
    <summary>
      A logical value determining whether a font is displayed in a italic typeface (TRUE if yes; otherwise, FALSE).
    </summary>
    <value>A logical value determining whether a font is displayed in a italic typeface (TRUE if yes; otherwise, FALSE).</value>
  </Font.Italic>
  <Font.Light>
    <summary>
      A logical value determining whether a font is displayed in a light typeface (TRUE if yes; otherwise, FALSE). Light is the opposite of bold.
    </summary>
    <value>A logical value determining whether a font is displayed in a light typeface (TRUE if yes; otherwise, FALSE). Light is the opposite of bold.</value>
    <remarks>
      <note type="tip">Only one of Font:Light, Font:Normal, and Font:Bold properties can be TRUE for any font.</note>
    </remarks>
  </Font.Light>
  <Font.Normal>
    <summary>
      A logical value determining whether a font is displayed in a normal typeface (TRUE if yes; otherwise, FALSE).
    </summary>
    <value>A logical value determining whether a font is displayed in a normal typeface (TRUE if yes; otherwise, FALSE).</value>
    <remarks>
      <note type="tip">Only one of Font:Light, Font:Normal, and Font:Bold properties can be TRUE for any font.</note>
    </remarks>
  </Font.Normal>
  <Font.Orientation>
    <exclude />
  </Font.Orientation>
  <Font.OutPrecision>
    <exclude />
  </Font.OutPrecision>
  <Font.PitchAndFamily>
    <exclude />
  </Font.PitchAndFamily>
  <Font.PitchFixed>
    <summary>
      A logical value determining whether a font is displayed in a fixed pitch typeface (TRUE if yes; otherwise, FALSE).
    </summary>
    <value>A logical value determining whether a font is displayed in a fixed pitch typeface (TRUE if yes; otherwise, FALSE).</value>
    <remarks>
      <note type="tip">Either the Font:PitchFixed or Font:PitchVariable property can be TRUE for any font, but not both properties.</note>
    </remarks>
  </Font.PitchFixed>
  <Font.PitchVariable>
    <summary>
      A logical value determining whether a font is displayed in a variable pitch typeface (TRUE if yes; otherwise, FALSE).
    </summary>
    <value>A logical value determining whether a font is displayed in a variable pitch typeface (TRUE if yes; otherwise, FALSE).</value>
    <remarks>
      <note type="tip">Either the Font:PitchFixed or Font:PitchVariable property can be TRUE for any font, but not both properties.</note>
    </remarks>
  </Font.PitchVariable>
  <Font.PointSize>
    <exclude />
  </Font.PointSize>
  <Font.Quality>
    <exclude />
  </Font.Quality>
  <Font.Size>
    <exclude />
  </Font.Size>
  <Font.SizeText>
    <exclude />

  </Font.SizeText>
  <Font.Strikethru>
    <summary>
      A logical value determining whether a font is displayed in a strikethrough typeface (TRUE if yes; otherwise, FALSE). A strikethough typeface places a line through every character.
    </summary>
    <value>A logical value determining whether a font is displayed in a strikethrough typeface (TRUE if yes; otherwise, FALSE). A strikethough typeface places a line through every character.</value>
  </Font.Strikethru>
  <Font.Underline>
    <summary>
      A logical value determining whether a font is displayed in an underline typeface (TRUE if yes; otherwise, FALSE).
    </summary>
    <value>A logical value determining whether a font is displayed in an underline typeface (TRUE if yes; otherwise, FALSE).</value>
  </Font.Underline>
  <Font.Weight>
    <exclude />
  </Font.Weight>
  <Font.Width>
    <exclude />
  </Font.Width>
  <FormattedTextObject>
    <summary>
      Provide a way to format a string specifying position (origin), font, and color.
    </summary>
    <remarks>
      A FormattedTextObject object has the same behavior as a TextObject object with the exception that it recognizes characters like tab (Chr(9)), carriage return (Chr(13)), and newline (Chr(10)), and is able to translate them appropriately.
      You can use FormattedTextObject:TabSize to change the default tab of a FormattedTextObject object and the Window:Draw() method to display it.
    </remarks>
    <example>
      This example uses a formatted text object to print "World" underneath "Hello":
      <code language="X#">
        oFT := FormattedTextObject{Point{10,10},"Hello" + Chr(10) + "World"}
        ?oFT
      </code>
    </example>
  </FormattedTextObject>
  <FormattedTextObject.ctor>
    <summary>
      Construct a FormattedTextObject object.
    </summary>
    <param name="oPoint">The origin of the FormattedTextObject object in canvas coordinates. The default is Point{16, 16}.</param>
    <param name="cText">The text to be displayed in the FormattedTextObject object.</param>
    <param name="oFont">The font to be used by the FormattedTextObject object. The default is the system font.</param>
    <param name="oColor">The color to be used by the FormattedTextObject object. The default is the current window's color selection. (Refer to the Color:Init() method for details on specifying a color.)</param>
  </FormattedTextObject.ctor>
  <FormattedTextObject.Draw>
    <summary>
      Draw a FormattedTextObject object on a window.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This method is invoked inside the system by Window:Draw().
    </remarks>
  </FormattedTextObject.Draw>
  <FormattedTextObject.TabSize>
    <summary>
      A numeric value representing the tab size—in characters—for a FormattedTextObject object. The default tab size is 8.
    </summary>
    <value>A numeric value representing the tab size—in characters—for a FormattedTextObject object. The default tab size is 8.</value>
  </FormattedTextObject.TabSize>
  <FSError>
    <exclude />
  </FSError>
  <FSError.ctor>
    <exclude />
  </FSError.ctor>
  <GroupBox>
    <summary>
      Create a group box, which can be used to group related controls together.
    </summary>
    <remarks>
      A group box is a single-line box with an appropriate title to identify the nature of the group. It should be drawn around the related controls on the surface of a window and can contain a single or several sets of choices.
      Use the Init() method from TextControl to create a group box. Also, the title of a group box can be changed using the TextValue assign method of TextControl.
      <note type="tip">
        CUA Style: According to CUA guidelines, you should not use group boxes for a set of one or more push buttons or list boxes. Rather, a group box would be more useful in a "Print File" dialog, for example, where a number of options—like a "Copies" edit control and a "Print Color" check box—can be grouped together.
      </note>
    </remarks>
  </GroupBox>
  <GroupBox.ctor>
    <summary>
      Construct a group box.
    </summary>
    <param name="oOwner">The window that owns the group box.</param>
    <param name="xID">The unique ID of the group box (between 1 and 8000).</param>
    <param name="oPoint">The origin of the group box in canvas coordinates.</param>
    <param name="oDimension">The dimension of the group box in canvas coordinates.</param>
    <param name="cText">The caption of the group box. The default is NULL_STRING.</param>
    <param name="lDataAware">A logical value specifying whether the group box is data aware.</param>
    <param name="nResourceID">The resource ID of the group box.</param>
  </GroupBox.ctor>
  <GroupBox.AsString>
    <summary>
      Return an identifying label for the group box.
    </summary>
    <remarks>
      GroupBox:AsString() presents the group box control as a recognizable string of the form &lt;ClassName&gt; - &lt;Caption&gt;.
    </remarks>
  </GroupBox.AsString>
  <GroupBox.CurrentText>
    <summary>
      This property is provided to override the inherited functionality from the TextControl class, as it does not apply to group boxes.
    </summary>
    <value>This property is provided to override the inherited functionality from the TextControl class, as it does not apply to group boxes.</value>
  </GroupBox.CurrentText>
  <GroupBox.Destroy>
    <summary>
      Provide a method to de-instantiate a GroupBox object.
    </summary>
    <remarks>
      This method can be used when a GroupBox object is no longer needed. GroupBox:Destroy() de-instantiates the GroupBox object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </GroupBox.Destroy>
  <HelpDisplay>
    <summary>
      Create a link to the help system in use.
    </summary>
    <remarks>
      The HelpDisplay class allows you to easily provide online help for your applications. The help system resource provided by the GUI can remain in memory until the HelpDisplay object is deleted. Therefore, before the application terminates, ensure that the HelpDisplay object is either deleted or goes out of scope.

      HelpDisplay provides a way to display help on a given topic. However, the application still needs a means of determining which topic help is required.
      For large applications, most GUI style guides recommend that help commands be made available from the menu bar. These commands can be trapped using the MenuCommandEvent handler, and the appropriate help information displayed in response.
      Another approach is to use push buttons to obtain help on specific topics. Using a push button and the ButtonClick() event handler, you can program the application to display the relevant help information when the Help button is pressed.
      In practice, an application's Help facility should combine menu commands and buttons to provide help.

      Context-sensitive help means the user receives help specific to the current activity when the help key or mouse sequence is chosen. For example, when responding to a dialog window, the user can want help for the control with the focus.
      X# applications can provide context-sensitive help for:
      Particular areas of the screen (such as the caption bar and canvas area)
      Menu commands
      Controls (like push buttons, edit controls, and toolbar buttons)
      To support a portable context-sensitive help system, X# provides the HelpRequestEvent class, the Window:HelpDisplay property, and the Window:HelpRequest() event handler method. (HelpRequest() determines the source of the help trigger—that is, the particular item for which help is requested—and passes this information on to the GUI's help system.)
      Refer to the "GUI Classes" chapter in the Programmer's Guide for more information on programming an online help system for your application.
      <note type="tip">
        The EXPORTed variable DefaultPageOnContents is a LOGIC which defaults to TRUE. It is used to determine whether the default page should be shown when HelpContents is requested. If set to FALSE, 'HelpContents' will display the Contents tab but leave the current topic displayed. For HTML Help only.
      </note>
    </remarks>
    <example>
      The following example handles two common menu commands, Help Index and Help Using Help:
      <code language="X#">
        CLASS MyWindow INHERIT TopAppWindow
        METHOD Init() CLASS MyWindow
        SUPER:Init()
        SELF:HelpDisplay := HelpDisplay{"mywind.hlp"}
        METHOD MenuCommand(oMCE) CLASS MyWindow
        LOCAL nItemID := oMCE:ItemID
        DO CASE
        CASE nItemID = IDM_MENU_HELP_INDEX_ID
        SELF:HelpDisplay:Show("HelpIndex")
        CASE nItemID = IDM_MENU_HELP_USINGHELP_ID
        SELF:HelpDisplay:Show("HelpOnHelp")
        OTHERWISE
        SUPER:MenuCommand(oMCE)
        ENDCASE
      </code>
    </example>
  </HelpDisplay>
  <HelpDisplay.ctor>
    <summary>
      Construct a help display to be used for a specified help database.
    </summary>
    <param name="cFileName">The file name of the help database to which this help display should be connected.</param>
    <param name="oOwnerWindow">The window object which owns this help display, if any.</param>
    <param name="lWin32Processing">When TRUE this will tell X# to use the standard WIN32 help processing </param>
    <remarks>
      X# 2.8 has added support for the use of Standard Win32 help processing which is based on the WM_HELP message since Windows95. The default VO like online help is disabled in this mode. This means, that SHIFT-F1 and mouse help don’t work.
      On the other hand the Windows standard help cursor is full supported and the help button on a caption bar too. See: Window:EnableHelpButton() and Window:EnableHelpCursor()
      Also text popups are supported only in this mode.
    </remarks>
  </HelpDisplay.ctor>
  <HelpDisplay.DefaultPageOnContents>
    <exclude />
  </HelpDisplay.DefaultPageOnContents>
  <HelpDisplay.Destroy>
    <exclude />
  </HelpDisplay.Destroy>
  <HelpDisplay.EnableHTMLHelp>
    <exclude />

  </HelpDisplay.EnableHTMLHelp>
  <HelpDisplay.HelpError>
    <summary>
      Determine if the previous HelpDisplay operation was successful.
    </summary>
    <returns>
      <para>One of the following constants, indicating the success or failure of the previously called HelpDisplay:</para>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>HDCANTOPENFILE</term>
          <description>The help operation could not open the help database.</description>
        </item>
        <item>
          <term>HDINVALIDKEY</term>
          <description>An invalid key was used for HelpDisplay:Show().</description>
        </item>
        <item>
          <term>HDOK</term>
          <description>The operation was successful.</description>
        </item>
        <item>
          <term>HDOUTOFMEMORY</term>
          <description>
            The operation failed due to insufficient memory or other system resources.
          </description>
        </item>
        <item>
          <term>HDUNKNOWN</term>
          <description>It was not possible to determine why the last operation failed.</description>
        </item>
      </list>
    </returns>
  </HelpDisplay.HelpError>
  <HelpDisplay.Show>
    <summary>
      Instruct the help system to provide the help topic associated with a given keyword.
    </summary>
    <param name="cKeyword">
      The keyword to look up in the application help file. See table in the remarks section.
    </param>
    <param name="symLookupType">
      Controls the lookup type. The default is HH_KEYWORD_LOOKUP.
      Is used to call up Associative links in the help file. Associative Links are not displayed in the index, keywords are. For HTML Help only.
      The second parameter symLookupType can also be a PTR to a _winHelpInfo structure, which is sent with a WM_HELP message.
    </param>
    <remarks>

      The following reserved keywords do not correspond to anything coded in your application help file.
      Instead, they are provided by the system to give you access to certain standard help features:


      <list>
        <listheader>
          <term>Reserved Keyword</term>
          <description>Description</description>
        </listheader>
        <term>HelpIndex</term>
        <description>Displays the Contents or Index topic (whichever was displayed last) as defined in the application help file.</description>
        <term>HelpOnHelp</term>
        <description>
          Displays the Contents topic as defined in your Windows help file (normally WINHELP.HLP, in which the Contents topic is How to Use Help).
          This is not available with .CHM help.
        </description>
        <term>HelpSearch</term>
        <description>
          Displays the Search tab in the help navigation pane.For HTML Help only.
        </description>
        <term># followed by a number.</term>
        <description>
          The number represents the ID for a test popup help. For HTML Help only and Win32Processing mode have to enabled.
        </description>
        <term>~ followed by a keyword.</term>
        <description>
          This forces a HH_ALINK_LOOKUP. Is used to call up Associative links in the help file. Associative Links are not displayed in the index, keywords are. For HTML Help only.
        </description>
      </list>
    </remarks>
    <returns>
      TRUE if the lookup action took place correctly; otherwise, FALSE.
      <note type="tip">A TRUE value does not imply the key was found.</note>
    </returns>
    <remarks>
      GUIs behave differently when an invalid or unknown key is looked up. Although most present an alert message to the user (something to the effect that the key could not be found), you should assume this behavior is undefined and ensure that the key being looked up exists in the help database.
    </remarks>
  </HelpDisplay.Show>
  <HelpDisplay.Win32Processing>
    <exclude />
  </HelpDisplay.Win32Processing>
  <HelpRequestEvent>
    <summary>
      Provide information about a HelpRequestEvent, used to describe the context and item combinations for which help is requested. (This can be help for controls, menu commands, and specific areas of a window.)
    </summary>
  </HelpRequestEvent>
  <HelpRequestEvent.ctor>
    <inheritdoc />
  </HelpRequestEvent.ctor>
  <HelpRequestEvent.HelpContext>
    <summary>
      A string representing the help context ID of the control that generated this control event. This
    </summary>
    <value>A string representing the help context ID of the control that generated this control event. This</value>
    <remarks>
      A string representing the help context ID of the control that generated this control event. This ID is contained in the control's hyperlabel.
      <note type="tip">A help context ID indicates the place in the hypertext system where the system looks for help concerning this control.</note>
    </remarks>
  </HelpRequestEvent.HelpContext>
  <HelpRequestEvent.HelpInfo>
    <summary>
      A pointer to a _winHelpInfo structure if the help request is generated from a WM_HELP message otherwise Null_Ptr.
    </summary>
    <value>A pointer to a _winHelpInfo structure if the help request is generated from a WM_HELP message otherwise Null_Ptr.</value>
  </HelpRequestEvent.HelpInfo>
  <HelpRequestEvent.HelpType>
    <summary>
      A constant, indicating the type of item—menu, control, or window area—for which help was requested:
    </summary>
    <value>A constant, indicating the type of item—menu, control, or window area—for which help was requested:</value>
    <remarks>
      One of the following constants, indicating the type of item—menu, control, or window area—for which help was requested:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>HELPCONTROL</term>
          <description>Help is requested for a control.</description>
        </item>
        <item>
          <term>HELPMENU</term>
          <description>Help is requested for a menu command.</description>
        </item>
        <item>
          <term>HELPWINDOW</term>
          <description>Help is requested for a window area or point on the canvas.</description>
        </item>
        <item>
          <term>HELPINFO</term>
          <description>Help request is generated from a WM_HELP message.</description>
        </item>
      </list>
    </remarks>
  </HelpRequestEvent.HelpType>
  <HelpRequestEvent.HyperLabel>
    <summary>
      The hyperlabel connected to the help request event.
    </summary>
    <value>The hyperlabel connected to the help request event.</value>
    <remarks>
      The hyperlabel connected to the help request event. From the hyperlabel, you can retrieve additional information about the help request event—for example:
      <code language="X#">
        cCaption	:= oHelpRequestEvent:HyperLabel:Caption
        cDescription	:= oHelpRequestEvent:HyperLabel:Description
        cHelpContext	:= oHelpRequestEvent:HyperLabel:HelpContext
      </code>
    </remarks>
  </HelpRequestEvent.HyperLabel>
  <HelpRequestEvent.ItemID>
    <summary>
      A numeric value representing the ID of the item that the user has requested help on.
    </summary>
    <value>A numeric value representing the ID of the item that the user has requested help on.</value>
    <remarks>
      A numeric value representing the ID of the item that the user has requested help on.
      The exact meaning of this ID depends on the type of item:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>ID Returned</description>
        </listheader>
        <item>
          <term>HELPCONTROL</term>
          <description>A unique ID for the control.</description>
        </item>
        <item>
          <term>HELPMENU</term>
          <description>A unique ID for the menu command.</description>
        </item>
        <item>
          <term>HELPWINDOW</term>
          <description>
            A unique ID for the window area. The HelpRequestEvent:WindowRegion access determines which area of the window the help pointer was
            located (could be system menu, border, canvas, unknown, etc.).
          </description>
        </item>
      </list>
    </remarks>
  </HelpRequestEvent.ItemID>
  <HelpRequestEvent.Position>
    <summary>
      The location of the mouse pointer in canvas coordinates.
    </summary>
    <value>The location of the mouse pointer in canvas coordinates.</value>
    <remarks>
      The location of the mouse pointer in canvas coordinates.
      This method is provided to support help requests of type HelpWindow (refer to the HelpRequestEvent:HelpType assign) to allow particular areas of the canvas to have distinct displays of help information.
      The HelpRequestEvent:WindowRegion access should be used to determine if the help pointer was on the canvas at the time. The point returned is not relevant in other cases.
    </remarks>
  </HelpRequestEvent.Position>
  <HelpRequestEvent.WindowRegion>
    <summary>
      A constant, indicating in which window area the help pointer was located when this HelpRequestEvent was generated:
    </summary>
    <value>A constant, indicating in which window area the help pointer was located when this HelpRequestEvent was generated:</value>
    <remarks>
      One of the following constants, indicating in which window area the help pointer was located when this HelpRequestEvent was generated:
      <note type="tip">The return value is only defined for HelpRequestEvents of type HelpWindow (refer to HelpRequestEvent:ItemID access).</note><list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>REGIONBORDER</term>
          <description>The window border</description>
        </item>
        <item>
          <term>REGIONCANVAS</term>
          <description>A window area or point on the canvas</description>
        </item>
        <item>
          <term>REGIONCAPTION</term>
          <description>The caption of the window</description>
        </item>
        <item>
          <term>REGIONMAXBOX</term>
          <description>The maximize box</description>
        </item>
        <item>
          <term>REGIONMENUBAR</term>
          <description>A menu command</description>
        </item>
        <item>
          <term>REGIONMINBOX</term>
          <description>The minimize box</description>
        </item>
        <item>
          <term>REGIONSIZEBOX</term>
          <description>The size box</description>
        </item>
        <item>
          <term>REGIONSYSTEMMENUBOX</term>
          <description>The system menu</description>
        </item>
        <item>
          <term>REGIONUNKNOWN</term>
          <description>The help system cannot determine a localized context</description>
        </item>
      </list>
    </remarks>
  </HelpRequestEvent.WindowRegion>
  <HLError>
    <exclude />
  </HLError>
  <HLError.ctor>
    <exclude />
  </HLError.ctor>
  <HorizontalScrollBar>
    <summary>
      Create a horizontal scroll bar that is independent of its owner window.
    </summary>
    <remarks>
      There are two types of horizontal scroll bars in X#: regular (created with CLASS HorizontalScrollBar) and window (created with the AppWindow:EnableHorizontalScroll() method).
      Both types have an owner window and can be manipulated using Window:HorizontalScroll(). However, a window horizontal scroll bar differs in that it automatically appears aligned along the bottom of its owner window's canvas area and also resizes itself according to the size of its owner window.
      A horizontal scroll bar allows the user to update a short integer numeric value by either moving the thumb position, clicking on the button at either end of the scroll bar to change the number by the designated ScrollBar:UnitSize, or by clicking in the interior of the scroll bar to change the number by the designated ScrollBar:BlockSize. The minimum and maximum allowable numeric values are indicated by the Min and Max values for the Range object associated with the scroll bar. The ScrollBar:Value access indicates the currently selected numeric value. A scroll bar may be bound to a numeric field in a server.
      <note type="tip">By default, Window:HorizontalScroll() updates the thumb position (the marker on the scroll bar that can be dragged up or down, left or right) in the scroll bar. If desired, you can change this by using your own implementation of this handler.</note>

      In Windows, horizontal scroll bars are equivalent to a scroll bar with the SBS_HORZ style. They are normally specified in the resource entity as follows:
      <code language="X#">
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 120
        STYLE WS_POPUP | WS_DLGFRAME
        BEGIN
        CONTROL "", IDS_RED,  "scrollbar", SBS_HORZ, 10, 16, 100, 20
        CONTROL "", IDS_BLUE, "scrollbar", SBS_HORZ, 10, 46, 100, 20
        CONTROL "", IDS_GREEN, "scrollbar", SBS_HORZ, 10, 76, 100, 20
        END
      </code>
    </remarks>
  </HorizontalScrollBar>
  <HorizontalScrollBar.ctor>
    <summary>
      Construct a horizontal scroll bar.
    </summary>
    <param name="oOwner">The window that owns the horizontal scroll bar.</param>
    <param name="xID">The unique ID of the horizontal scroll bar (between 1 and 8000).</param>
    <param name="oPoint">The origin of the horizontal scroll bar in canvas coordinates.</param>
    <param name="oDimension">The dimension of the horizontal scroll bar in canvas coordinates.</param>
    <param name="nResourceID">The resource ID of the horizontal scroll bar.</param>
  </HorizontalScrollBar.ctor>
  <HorizontalScrollBar.Destroy>
    <summary>
      Provide a method to de-instantiate a HorizontalScrollBar object.
    </summary>
    <remarks>
      This method can be used when a HorizontalScrollBar object is no longer needed. HorizontalScrollBar:Destroy() de-instantiates the HorizontalScrollBar object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </HorizontalScrollBar.Destroy>
  <HorizontalSelectionSlider>
    <summary>
      Create a horizontal selection slider control.
    </summary>
    <remarks>
      A horizontal selection slider is a control that contains a thumb, optional tick marks, and a selection bar. The user can move the horizontal selection slider's thumb using either the mouse or the Direction keys.
    </remarks>
  </HorizontalSelectionSlider>
  <HorizontalSelectionSlider.ctor>
    <summary>
      Construct a horizontal selection slider.
    </summary>
    <param name="oOwner">The window that owns the horizontal selection slider.</param>
    <param name="xID">The unique ID of the horizontal selection slider (between 1 and 8000).</param>
    <param name="nResourceID">The resource ID of horizontal selection slider.</param>
    <param name="oPoint">The origin of the horizontal selection slider in canvas coordinates.</param>
    <param name="oDimension">The dimension of the horizontal selection slider in canvas coordinates.</param>
  </HorizontalSelectionSlider.ctor>
  <HorizontalSlider>
    <summary>
      Create a horizontal slider control.
    </summary>
    <remarks>
      A horizontal slider is a control that contains a thumb and optional tick marks. The user can move the horizontal slider's thumb using either the mouse or the Direction keys.
    </remarks>
  </HorizontalSlider>
  <HorizontalSlider.ctor>
    <summary>
      Construct a horizontal slider.
    </summary>
    <param name="oOwner">The window that owns the horizontal slider.</param>
    <param name="xID">The unique ID of the horizontal slider (between 1 and 8000).</param>
    <param name="nResourceID">The resource ID of horizontal slider.</param>
    <param name="oPoint">The origin of the horizontal slider in canvas coordinates.</param>
    <param name="oDimension">The dimension of the horizontal slider in canvas coordinates.</param>
  </HorizontalSlider.ctor>
  <HorizontalSpinner>
    <summary>
      Create a spinner with horizontal arrow buttons.
    </summary>
    <remarks>
      A horizontal spinner is a pair of left- and right-pointing arrow buttons that can be clicked to change a value, such as a number displayed in another control. A horizontal spinner can exist independently but is most often used with another control, referred to as the client.
    </remarks>
  </HorizontalSpinner>
  <HorizontalSpinner.ctor>
    <summary>
      Construct a horizontal spinner.
    </summary>
    <param name="oOwner">The window that owns the horizontal spinner.</param>
    <param name="xID">The unique ID of the horizontal spinner (between 1 and 8000).</param>
    <param name="nResourceID">The resource ID of the horizontal spinner.</param>
    <param name="oPoint">The origin of the horizontal spinner in canvas coordinates.</param>
    <param name="oDimension">The dimension of the horizontal spinner in canvas coordinates.</param>
    <param name="kStyle">The style of the horizontal spinner.</param>
  </HorizontalSpinner.ctor>
  <HotKey>
    <summary>
      Create a hot key.
    </summary>
    <remarks>
      A hot key is an object that can be applied to a hot key edit control to set a valid key combination for a window. When the key combination is pressed, the given window is activated by the system.
    </remarks>
  </HotKey>
  <HotKey.ctor>
    <summary>
      Construct a hot key.
    </summary>
    <param name="bKey">The virtual key code for the hot key.</param>
    <param name="lAlt">Specifies that the Alt key is to be used for the hot key.</param>
    <param name="lCtl">Specifies that the Ctl key is to be used for the hot key.</param>
    <param name="lShift">Specifies that the Shift key is to be used for the hot key.</param>
    <param name="lExt">Specifies that the extended key—the keys on the numeric key pad—is to be used for the hot key. </param>
  </HotKey.ctor>
  <HotKey.AltKey>
    <summary>
      A logical value that is TRUE if the Alt key is valid for the hot key.
    </summary>
    <value>A logical value that is TRUE if the Alt key is valid for the hot key.</value>
  </HotKey.AltKey>
  <HotKey.CtrlKey>
    <summary>
      A logical value that is TRUE if the Ctrl key is valid for the hot key.
    </summary>
    <value>A logical value that is TRUE if the Ctrl key is valid for the hot key.</value>
  </HotKey.CtrlKey>
  <HotKey.ExtendedKey>
    <summary>
      A logical value that is TRUE if an extended key is valid for the hot key.
    </summary>
    <value>A logical value that is TRUE if an extended key is valid for the hot key.</value>
  </HotKey.ExtendedKey>
  <HotKey.Key>
    <summary>
      A virtual key code for the hot key.
    </summary>
    <value>A virtual key code for the hot key.</value>
  </HotKey.Key>
  <HotKey.ShiftKey>
    <summary>
      A logical value that is TRUE if the Shift key is valid for the hot key.
    </summary>
    <value>A logical value that is TRUE if the Shift key is valid for the hot key.</value>
  </HotKey.ShiftKey>
  <HotKeyEdit>
    <summary>
      Create a hot key edit.
    </summary>
    <remarks>
      A hot key edit is a control that can be used to apply a key combination to a window such that the window can be activated by the system when the combination is pressed.
    </remarks>
  </HotKeyEdit>
  <HotKeyEdit.ctor>
    <summary>
      Construct a hot key edit.
    </summary>
    <param name="oOwner">The window that owns the hot key edit.</param>
    <param name="xID">The unique ID of the hot key edit (between 1 and 8000).</param>
    <param name="nResourceID">The resource ID of the hot key edit.</param>
    <param name="oPoint">The origin of the hot key edit in canvas coordinates.</param>
    <param name="oDimension">The dimension of the hot key edit in canvas coordinates.</param>
    <param name="kStyle">The style of the hot key edit.</param>
  </HotKeyEdit.ctor>
  <HotKeyEdit.ApplyHotKey>
    <summary>
      Apply the HotKey object associated with this control to a particular window.
    </summary>
    <param name="oWindow">The window to which the HotKey object will be applied.</param>
    <returns>
      A numeric value indicating the result of applying the HotKey object to the window. The result can be one of the following values:
      <list>
        <listheader>
          <term>Value</term>
          <description>Result</description>
        </listheader>
        <item>
          <term>-1</term>
          <description>The operation was unsuccessful because the HotKey object is invalid.</description>
        </item>
        <item>
          <term>0</term>
          <description>The operation was unsuccessful because the window is invalid.</description>
        </item>
        <item>
          <term>1</term>
          <description>The operation was successful, and no other window has the same HotKey object.</description>
        </item>
        <item>
          <term>2</term>
          <description>The operation was successful, but another window already has the same HotKey object.</description>
        </item>
      </list>
    </returns>
  </HotKeyEdit.ApplyHotKey>
  <HotKeyEdit.Create>
    <summary>
      Creates the underlying window control for a X# hot key edit object.
    </summary>
    <returns>
      The window handle of the control, if successful. A null handle (NULL_PTR) is returned if the control creation failed.
    </returns>
    <remarks>
      The Create() method creates the underlying window control for controls not loaded from a resource (i.e., designed with the Window Editor) but created at runtime. Normally, it is not necessary to call Create() directly—CA-X# will create the object internally as soon as a window handle is needed.
    </remarks>
    <example>
      <code language="X#">
        Method CreateHotKeyEdit() class MyDataWindow
        local oHK as HotKeyEdit
        // Init creates the X# HotKeyEdit Object
        oHK := HotKeyEdit{self, 100, Point{10,10}, Dimension{100,20}}
        // Calling Create forces the Windows control to be created
        oHK:Create()
      </code>
    </example>
  </HotKeyEdit.Create>
  <HotKeyEdit.HotKey>
    <summary>
      The HotKey object associated with this hot key edit.
    </summary>
    <value>The HotKey object associated with this hot key edit.</value>
  </HotKeyEdit.HotKey>
  <HotKeyEdit.Rule>
    <summary>
      The HotKeyRule object associated with this hot key edit.
    </summary>
    <value>The HotKeyRule object associated with this hot key edit.</value>
  </HotKeyEdit.Rule>
  <HotKeyRule>
    <summary>
      Create a hot key rule.
    </summary>
    <remarks>
      A hot key rule is an object that can be applied to a hot key edit control to define invalid key combinations for a window. The hot key rule also defines how to modify the key combination when it is invalid.
    </remarks>
  </HotKeyRule>
  <HotKeyRule.ctor>
    <exclude />
  </HotKeyRule.ctor>
  <HotKeyRule.AltKeyInvalid>
    <summary>
      A logical value that is TRUE if the Alt key is invalid for the HotKey object.
    </summary>
    <value>A logical value that is TRUE if the Alt key is invalid for the HotKey object.</value>
  </HotKeyRule.AltKeyInvalid>
  <HotKeyRule.CtrlAltKeysInvalid>
    <summary>
      A logical value that is TRUE if the Ctrl+Alt key combination is invalid for the HotKey object.
    </summary>
    <value>A logical value that is TRUE if the Ctrl+Alt key combination is invalid for the HotKey object.</value>
  </HotKeyRule.CtrlAltKeysInvalid>
  <HotKeyRule.CtrlKeyInvalid>
    <summary>
      A logical value that is TRUE if the Ctrl key is invalid for the HotKey object.
    </summary>
    <value>A logical value that is TRUE if the Ctrl key is invalid for the HotKey object.</value>
  </HotKeyRule.CtrlKeyInvalid>
  <HotKeyRule.ShiftAltKeysInvalid>
    <summary>
      A logical value that is TRUE if the Shift+Alt key combination is invalid for the HotKey object.
    </summary>
    <value>A logical value that is TRUE if the Shift+Alt key combination is invalid for the HotKey object.</value>
  </HotKeyRule.ShiftAltKeysInvalid>
  <HotKeyRule.ShiftCtrlAltKeysInvalid>
    <summary>
      A logical value that is TRUE if the Shift+Alt+Ctrl key combination is invalid for the HotKey object.
    </summary>
    <value>A logical value that is TRUE if the Shift+Alt+Ctrl key combination is invalid for the HotKey object.</value>
  </HotKeyRule.ShiftCtrlAltKeysInvalid>
  <HotKeyRule.ShiftCtrlKeysInvalid>
    <summary>
      A logical value that is TRUE if the Shift+Ctrl key combination is invalid for the HotKey object.
    </summary>
    <value>A logical value that is TRUE if the Shift+Ctrl key combination is invalid for the HotKey object.</value>
  </HotKeyRule.ShiftCtrlKeysInvalid>
  <HotKeyRule.ShiftKeyInvalid>
    <summary>
      A logical value that is TRUE if the Shift key is invalid for the HotKey object.
    </summary>
    <value>A logical value that is TRUE if the Shift key is invalid for the HotKey object.</value>
  </HotKeyRule.ShiftKeyInvalid>
  <HotKeyRule.UnmodifiedKeysInvalid>
    <summary>
      A logical value that is TRUE if unmodified key combinations (no Shift, Alt, or Ctrl keys) are invalid for the HotKey object.
    </summary>
    <value>A logical value that is TRUE if unmodified key combinations (no Shift, Alt, or Ctrl keys) are invalid for the HotKey object.</value>
  </HotKeyRule.UnmodifiedKeysInvalid>
  <HotKeyRule.UseAltKeyOnInvalid>
    <summary>
      A logical value that is TRUE if the Alt key is to be used when an invalid key combination is entered into the hot key edit.
    </summary>
    <value>A logical value that is TRUE if the Alt key is to be used when an invalid key combination is entered into the hot key edit.</value>
  </HotKeyRule.UseAltKeyOnInvalid>
  <HotKeyRule.UseCtrlKeyOnInvalid>
    <summary>
      A logical value that is TRUE if the Ctrl key is to be used when an invalid key combination is entered into the hot key edit.
    </summary>
    <value>A logical value that is TRUE if the Ctrl key is to be used when an invalid key combination is entered into the hot key edit.</value>
  </HotKeyRule.UseCtrlKeyOnInvalid>
  <HotKeyRule.UseExtendedKeyOnInvalid>
    <summary>
      A logical value that is TRUE if an extended key is to be used when an invalid key combination is entered into the hot key edit.
    </summary>
    <value>A logical value that is TRUE if an extended key is to be used when an invalid key combination is entered into the hot key edit.</value>
  </HotKeyRule.UseExtendedKeyOnInvalid>
  <HotKeyRule.UseShiftKeyOnInvalid>
    <summary>
      A logical value that is TRUE if the Shift key is to be used when an invalid key combination is entered into the hot key edit.
    </summary>
    <value>A logical value that is TRUE if the Shift key is to be used when an invalid key combination is entered into the hot key edit.</value>
  </HotKeyRule.UseShiftKeyOnInvalid>
  <HTTPCgiContext>
    <summary>
      Create HTTP server applications that use the Common Gateway Interface (CGI).
    </summary>
  </HTTPCgiContext>
  <HTTPCgiContext.ctor>
    <summary>
      Construct an HTTPCgiContext object.
    </summary>
  </HTTPCgiContext.ctor>
  <HTTPCgiContext.Close>
    <summary>
      Close a CGI session and do all necessary cleanup.
    </summary>
    <remarks>
      This method frees up all file handles and detaches the CGI process from its console.
    </remarks>
    <example>
      See the HTTPCgiContext:Write() example.
    </example>
  </HTTPCgiContext.Close>
  <HTTPCgiContext.ReadClient>
    <summary>
      Read data from the body of a client's HTTP request.
    </summary>
    <param name="pBuffer">Pointer to the buffer area which is to receive the requested information. </param>
    <param name="nSize">Numeric value indicating the number of bytes available in the buffer. </param>
    <returns>
      TRUE, if the read operation was successful; otherwise, FALSE.
    </returns>
    <remarks>
      ReadClient() reads information from the body of the Web client's HTTP request. It can be used to read data from an HTML form that uses the POST method. The Init() method uses ReadClient() internally to read data for a POST request and stores them into the property, aArgs, which can be retrieved by the GetParams() method.
    </remarks>
  </HTTPCgiContext.ReadClient>
  <HTTPCgiContext.Write>
    <summary>
      Send the raw HTTP entity data to the client.
    </summary>
    <param name="cHTTPEntity">String containing data that has to be sent to the client's Internet browser. If omitted, a line break, '&lt;br&gt;', is sent.</param>
    <returns>
      TRUE, if the write operation was successful; otherwise, FALSE.
    </returns>
    <remarks>
      This method sends data present in the given buffer to the client that made the request.
    </remarks>
    <example>
      The following CGI application displays the string, "Hello World", to the client's Internet browser:
      <code language="X#">
        FUNCTION Start
        LOCAL oCGI   AS HTTPCGIContext
        LOCAL cHtml   AS STRING
        LOCAL cValue AS STRING
        oCGI := HTTPCGIContext{}
        cHtml := oCGI:HTTPMsg("Hello World")
        oCGI:Write(cHtml)
        oCGI:Close()
        RETURN
      </code>
    </example>
  </HTTPCgiContext.Write>
  <HTTPCgiContext.WriteClient>
    <summary>
      Send the raw HTTP entity data to the client.
    </summary>
    <param name="cHTTPEntity">String containing data that has to be sent to the client's Internet browser.</param>
    <returns>
      TRUE, if the write operation was successful; otherwise, FALSE.
    </returns>
    <remarks>
      This method sends data present in the given buffer to the client that made the request.
    </remarks>
  </HTTPCgiContext.WriteClient>
  <HTTPCgiContext.WriteContentFile>
    <summary>
      Send the raw HTTP header and data for the specified content type to the client.
    </summary>
    <param name="cFile">File name, including drive letter and path.</param>
    <param name="cType">Content type (e.g., 'image', 'text', or 'application').</param>
    <param name="cSubType">
      Content subtype (e.g., 'jpeg' or 'gif' if <paramref name="cType" /> is 'image', 'zip' if <paramref name="cType" /> is 'application', or 'html' if <paramref name="cType" /> is 'text').
    </param>
    <returns>
      File size in bytes if the file has been found; otherwise, 0.
    </returns>
    <remarks>
      This method sends the specified content file and appropriate reply header to the client that made the request.
    </remarks>
    <example>
      The following CGI application can be used to create a download link for the client's Internet browser. The appropriate HTML file might look like the following:
      <code language="X#">
        &lt;html&gt;
        &lt;body&gt;
        &lt;h1&gt;CGI Download Test&lt;/h1&gt;
        &lt;p&gt;&lt;a href="/voscript/votest.exe"&gt;
        Download file test.zip
        &lt;/a&gt;&lt;/p&gt;
        &lt;/body&gt;
        &lt;/html&gt;
      </code>
      Source code for votest.exe:
      <code language="X#">
        FUNCTION Start
        LOCAL oCGI   AS HTTPCGIContext
        LOCAL cFile   AS STRING
        LOCAL cRet	   AS STRING
        oCGI := HTTPCGIContext{}
        cFile := oCGI:GetServerVariable("PATH_TRANSLATED");
        + "\downloads\test.zip"
        IF File(cFile)
        oCGI:WriteContentFile(cFile, "application", "zip")
        ELSE
        cFile := FPathName()
        cRet := "File " + cFile + "not found"
        oCGI:Write(oCGI:HTTPMsg(cRet))
        ENDIF
        oCGI:Close()
        RETURN
      </code>
      To test this application, simply type the following command line into the browser URL:
      <code language="X#">http://localhost/scripts/votest.exe</code>
    </example>
  </HTTPCgiContext.WriteContentFile>
  <HTTPCgiContext.WriteImage>
    <summary>
      Send the raw HTTP header and data for a specified image file to the client.
    </summary>
    <param name="cFile">Image file name, including drive letter and path.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      WriteImage() sends the specified image file and appropriate reply header to the client that made the request.
    </remarks>
    <example>
      The following CGI application displays the image, "vo.jpg", to the client's Internet browser. It can be tested by typing the following command line into the browser URL:
      <code language="X#">http://localhost/scripts/votest.exe</code>
      To hook the application into an HTML file, you can use following code:
      <code language="X#">
        &lt;html&gt;
        &lt;body&gt;
        &lt;h1&gt;CGI Application Test&lt;/h1&gt;
        &lt;img src="/scripts/votest.exe"&gt;
        &lt;/body&gt;
        &lt;/html&gt;
      </code>
      Source code for votest.exe:
      <code language="X#">
        FUNCTION Start
        LOCAL oCGI   AS HTTPCGIContext
        LOCAL cFile  AS STRING
        LOCAL cRet	   AS STRING
        oCGI := HTTPCGIContext{}
        cFile:=oCGI:GetServerVariable("PATH_TRANSLATED");
        +"\images\vo.jpg"
        IF File(cFile)
        oCGI:WriteImage(cFile)
        ELSE
        cFile := FPathName()
        cRet := "File " + cFile + " not found"
        oCGI:Write(SELF:HTTPMsg(cRet))
        ENDIF
        oCGI:Close()
        RETURN
      </code>
    </example>
  </HTTPCgiContext.WriteImage>
  <HTTPContextAbstract>
    <summary>
      Provide the base class from which Internet server applications can be created, using CGI (Common Gateway Interface) or ISAPI (Internet Server API).
    </summary>
  </HTTPContextAbstract>
  <HTTPContextAbstract.ctor>
    <summary>
      Construct an HTTPContextAbstract object.
    </summary>
  </HTTPContextAbstract.ctor>
  <HTTPContextAbstract.BinRoot>
    <summary>
      The fully qualified directory of the Internet application (DLL or EXE).
    </summary>
    <value>The fully qualified directory of the Internet application (DLL or EXE).</value>
  </HTTPContextAbstract.BinRoot>
  <HTTPContextAbstract.DelParamValue>
    <summary>
      Delete a specified parameter from an argument list passed to that request.
    </summary>
    <param name="cValueName">String containing the name of the parameter that has to be removed.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method removes the specified parameter from the argument list that was created based upon the current query string.
    </remarks>
  </HTTPContextAbstract.DelParamValue>
  <HTTPContextAbstract.Error>
    <summary>
      Number of the last error that occurred in the running application.
    </summary>
    <value>Number of the last error that occurred in the running application.</value>
  </HTTPContextAbstract.Error>
  <HTTPContextAbstract.GetBinRoot>
    <summary>
      Determine the absolute path name for the current CGI application.
    </summary>
    <returns>
      String containing the path name.
    </returns>
    <remarks>
      GetBinRoot() determines the fully specified path name, including drive letter, for the current CGI application.
    </remarks>
    <example>
      The following CGI application can be used as a spy program to retrieve the actual path name of the server:
      <code language="X#">
        FUNCTION Start
        LOCAL oCGI   AS HTTPCGIContext
        LOCAL cHtml   AS STRING
        LOCAL cValue  AS STRING
        oCGI := HTTPCGIContext{}
        cValue := oCGI:GetBinRoot()
        cHtml := oCGI:HTTPMsg("CGI script is started
        from: ";
        + cValue)
        oCGI:Write(cHtml)
        oCGI:Close()
        RETURN
      </code>
    </example>
  </HTTPContextAbstract.GetBinRoot>
  <HTTPContextAbstract.GetParams>
    <summary>
      Return arguments of the HTTP request.
    </summary>
    <returns>
      Array containing values and their names.
    </returns>
    <remarks>
      This method can be used to retrieve all arguments of the HTTP request as a two-dimensional array wherein each element contains a value pair of the following format:
      {<paramref name="cValueName" />, <paramref name="cValue" />}
    </remarks>
  </HTTPContextAbstract.GetParams>
  <HTTPContextAbstract.GetParamValue>
    <summary>
      Retrieve a specified parameter from an argument list passed to that request.
    </summary>
    <param name="cValueName">String containing the name of the sought after parameter.</param>
    <param name="nPosition">
      Integer value determining the occurrence of the parameter within the query string. The default value is 1, if <paramref name="nPosition" /> is not specified.
    </param>
    <returns>
      String containing the specified value, if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      GetParamValue() parses all values of the query string and returns the value of <paramref name="nPosition" />, i.e., the nth occurrence of <paramref name="cValueName" /> within the query string.
    </remarks>
    <example>
      The following CGI application can be used as a script for HTML form processing in order to display the value, "value1", within the Internet browser:
      <code language="X#">
        FUNCTION Start
        LOCAL oCGI   AS HTTPCGIContext
        LOCAL cHtml   AS STRING
        LOCAL cValue  AS STRING
        oCGI := HTTPCGIContext{}
        cValue := oCGI:GetParamValue("value1")
        cHtml := oCGI:HTTPMsg("Value1 is :" + cValue)
        oCGI:Write(cHtml)
        oCGI:Close()
        RETURN
      </code>
    </example>
  </HTTPContextAbstract.GetParamValue>
  <HTTPContextAbstract.GetServerVariable>
    <summary>
      Retrieve a specified environment value of the current Internet server.
    </summary>
    <param name="cValueName">String containing the name of the sought after environment variable.</param>
    <returns>
      String containing the specified value, if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      GetServerVariable() returns the current environment setting specified by <paramref name="cValueName" />.
    </remarks>
    <example>
      The following CGI application can be used to display the environment value, PATH_TRANSLATED:
      <code language="X#">
        FUNCTION Start
        LOCAL oCGI   AS HTTPCGIContext
        LOCAL cHtml   AS STRING
        LOCAL cValue  AS STRING
        oCGI := HTTPCGIContext{}
        cValue := oCGI:GetServerVariable("PATH_TRANSLATED")
        cHtml:=oCGI:HTTPMsg("PATH_TRANSLATED is :" + ;
        Value)
        oCGI:Write(cHtml)
        oCGI:Close()
        RETURN
      </code>
    </example>
  </HTTPContextAbstract.GetServerVariable>
  <HTTPContextAbstract.HTTPErrorMessage>
    <summary>
      Create HTML code to display all values of a  error object.
    </summary>
    <param name="oError">Current error object instance.</param>
    <returns>
      String containing HTML code for displaying the error within an Internet browser.
    </returns>
    <remarks>
      This method creates HTML code based on the values of a X# error object.
    </remarks>
    <example>
      The following example demonstrates how to catch runtime errors and display them within the browser:
      <code language="X#">
        FUNC Start()
        LOCAL oCGI   AS HTTPCGIContext
        LOCAL cHtml   AS STRING
        LOCAL cValue	AS STRING
        LOCAL oOldError AS USUAL
        LOCAL oError  AS USUAL
        LOCAL x
        oCGI := HTTPCgiContext{}
        oOldError := ErrorBlock( {|oErr| ;	__MyError(oErr)} )
        BEGIN SEQUENCE
        x := 0
        cHtml += x // error occurs here
        RECOVER USING oError
        cHtml := oCGI:HTTPErrorMessage(oError)
        END SEQUENCE
        ErrorBlock( oOldError )
        oCGI:Write(cHtml)
        oCGI:Close()
        RETURN
        STATIC FUNC __MyError  (oError)
        LOCAL cRepl AS STRING
        cRepl := "Module " + ProcName(1)
        cRepl += ", line " + NTrim(ProcLine(1))
        IF SLen(oError:Description)&gt; 0
        oError:Description += "(" + cRepl + ")"
        ELSE
        oError:Description := cRepl
        ENDIF
        _Break(oError)
      </code>
    </example>
  </HTTPContextAbstract.HTTPErrorMessage>
  <HTTPContextAbstract.HTTPMsg>
    <summary>
      Create HTML code to display a specified message.
    </summary>
    <param name="cMsg">Message to be displayed.</param>
    <returns>
      String containing HTML code for displaying a message within an Internet browser.
    </returns>
    <remarks>
      HTTPMsg() creates HTML code to display a specified message.
    </remarks>
    <example>
      See the HTTPContextAbstract:GetServerVariable() example.
    </example>
  </HTTPContextAbstract.HTTPMsg>
  <HTTPContextAbstract.HTTPRequestItems>
    <summary>
      Create HTML code to display all items of an query string.
    </summary>
    <returns>
      String containing HTML code for displaying all items of the query string.
    </returns>
    <remarks>
      HTTPRequestItems() creates HTML code to display all items of the query string.
    </remarks>
    <example>
      The following CGI application can be used to debug the items for a form-processing request:
      <code language="X#">
        FUNCTION Start
        LOCAL oCGI   AS HTTPCGIContext
        LOCAL cHtml   AS STRING
        oCGI := HTTPCGIContext{}
        cHtml := oCGI:HTTPRequestItems()
        oCGI:Write(cHtml)
        oCGI:Close()
        RETURN
      </code>
    </example>
  </HTTPContextAbstract.HTTPRequestItems>
  <HTTPContextAbstract.HTTPServerVariables>
    <summary>
      Create HTML code to display all environment variables of the Internet server.
    </summary>
    <returns>
      String containing HTML code to display all environment variables.
    </returns>
    <example>
      The following CGI application can be used to display the server's environment:
      <code language="X#">
        FUNCTION Start
        LOCAL oCGI   AS HTTPCGIContext
        LOCAL cHtml   AS STRING
        oCGI := HTTPCGIContext{}
        cHtml := oCGI:HTTPServerVariables()
        oCGI:Write(cHtml)
        oCGI:Close()
        RETURN
      </code>

      HTTPContextAbstract:HTTPErrorMessage(), HTTPContextAbstract:HTTPMsg(), HTTPContextAbstract:HTTPRequestItems()
    </example>
  </HTTPContextAbstract.HTTPServerVariables>
  <HTTPContextAbstract.QueryString>
    <summary>
      Query string of the HTTP request.
    </summary>
    <value>Query string of the HTTP request.</value>
  </HTTPContextAbstract.QueryString>
  <HTTPContextAbstract.ServerPath>
    <summary>
      The fully qualified directory name of the server's home directory.
    </summary>
    <value>The fully qualified directory name of the server's home directory.</value>
  </HTTPContextAbstract.ServerPath>
  <HTTPContextAbstract.SetParamValue>
    <summary>
      Change or add a specified parameter of the argument list passed to that request.
    </summary>
    <param name="cValueName">String containing the name of the parameter.</param>
    <param name="cValue">New value.</param>
    <param name="nPosition">
      Integer value determining the occurrence of the parameter within the query string. The default value is 1, if <paramref name="nPosition" /> is not specified.
    </param>
    <returns>
      TRUE, if the value has been changed; otherwise, FALSE.
    </returns>
    <remarks>
      This method parses all values of the query string and changes the value of <paramref name="nPosition" />, i.e., the nth occurrence of <paramref name="cValueName" /> within the query string. If the appropriate value name is not found, a new value is added to that list.
    </remarks>
    <example>
      The following CGI application can be used as a script for HTML form processing in order to display the value, "value1", within the Internet browser:
      <code language="X#">
        FUNCTION Start
        LOCAL oCGI   AS HTTPCGIContext
        LOCAL cHtml   AS STRING
        LOCAL cValue  AS STRING
        oCGI := HTTPCGIContext{}
        IF oCGI:SetParamValue("xyz", "123")
        CValue := oCGI:GetParamValue("xyz")
        cHtml:=oCGI:HTTPMsg("Value xyz changed" + ;
        "to :" + cValue)
        ELSE
        CValue := oCGI:GetParamValue("xyz")
        CHtml := oCGI:HTTPMsg("New value is :" ;
        + cValue)
        ENDIF
        oCGI:Write(cHtml)
        oCGI:Close()
        RETURN
      </code>
    </example>
  </HTTPContextAbstract.SetParamValue>
  <HTTPExtensionContext>
    <summary>
      Create HTTP server applications that use Microsoft's Internet Information Server API (ISAPI).
    </summary>
    <remarks>
      This class defines the common protocol--properties and behavior—for the various X# HTTP server applications that use ISAPI (Internet Server API).
    </remarks>
  </HTTPExtensionContext>
  <HTTPExtensionContext.ctor>
    <summary>
      Construct an HTTPExtensionContext object.
    </summary>
    <param name="pExtControlBlock">Pointer to a _WINEXTENSION_CONTROL_BLOCK structure containing all data for the request to an ISAPI DLL.</param>
    <remarks>
      An HTTPExtensionContext object can only be created within the entry point function, HttpExtensionProc(), of an ISAPI extension DLL. The Init() method requires a valid <paramref name="pExtControlBlock" /> pointer, because the HTTPExtensionContext class is a layer for the ISAPI callback functions contained in the _WINEXTENSION_CONTROL_BLOCK structure.
    </remarks>
    <example>
      The following function can be used to create an ISAPI DLL (votest.dll) for displaying the string, "Hello World", to the client's Internet browser:
      <code language="X#">
        FUNC HttpExtensionProc( pECB AS ;
        WINEXTENSION_CONTROL_BLOCK);
        AS DWORD PASCAL
        //
        // Entry point for all ISAPI requests
        //
        LOCAL cHtml   AS STRING
        LOCAL nRet   AS DWORD
        LOCAL oISAPI  AS StdHTTPContext
        oISAPI:= StdHTTPContext{pECB}
        cHtml := oISAPI:HTTPMsg("Hello World")
        IF oISAPI:Write(cHtml)
        nRet := HSE_STATUS_SUCCESS
        ELSE
        nRet := oISAPI:StatusCode
        ENDIF
        RETURN nRet
      </code>
      The appropriate HTML file might look like the following:
      <code language="X#">
        &lt;html&gt;
        &lt;body&gt;
        &lt;h1&gt;ISAPI DLL Test&lt;/h1&gt;
        &lt;p&gt;&lt;a href="/voscript/votest.dll"&gt;
        Click here to start the DLL
        &lt;/a&gt;&lt;/p&gt;
        &lt;/body&gt;
        &lt;/html&gt;
      </code>
    </example>
  </HTTPExtensionContext.ctor>
  <HTTPExtensionContext.ECB>
    <summary>
      Pointer to a _WINEXTENSION_CONTROL_BLOCK structure.
    </summary>
    <value>Pointer to a _WINEXTENSION_CONTROL_BLOCK structure.</value>
  </HTTPExtensionContext.ECB>
  <HTTPExtensionContext.GetServerVariable>
    <summary>
      Retrieve a specified environment value from the current Internet server.
    </summary>
    <param name="cValueName">String containing the name of the sought after environment variable.</param>
    <returns>
      String containing the specified value if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      GetServerVariable() returns the current environment setting specified by <paramref name="cValueName" />.
    </remarks>
    <example>
      See the HTTPContextAbstract:GetServerVariable() example.
    </example>
  </HTTPExtensionContext.GetServerVariable>
  <HTTPExtensionContext.ReadClient>
    <summary>
      Read data from the body of a client's HTTP request.
    </summary>
    <param name="pBuffer">Pointer to the buffer area which is to receive the requested information. </param>
    <param name="nSize">Numeric value indicating the number of bytes available in the buffer. </param>
    <returns>
      TRUE, if the read operation was successful; otherwise, FALSE.
    </returns>
  </HTTPExtensionContext.ReadClient>
  <HTTPExtensionContext.ServerSupportFunction>
    <summary>
      Provide auxiliary functionality to the HTTP response DLL.
    </summary>
    <param name="nRequest">A DWORD value containing the HTTP Server Extension Request (HSER) type, which indicates the requested functions by the ISAPI application. Valid values are:</param>
    <param name="pBuffer">Pointer to the buffer that contains the primary argument required for the requested support function.</param>
    <param name="nSize">
      Numeric value indicating the number of bytes available in the buffer. Defaults to the length of <paramref name="pBuffer" />.
    </param>
    <param name="cData">String containing data for secondary arguments.</param>
    <returns>
      TRUE, if the value has been changed; otherwise, FALSE.
    </returns>
    <remarks>
      This method provides several support functions that are not covered directly by the standard callback functions of the _WINEXTENSION_CONTROL_BLOCK structure.
    </remarks>
    <example>
      The following function can be used to create an ISAPI DLL (votest.dll) for displaying translated path names for different alias names:
      <code language="X#">
        FUNC HttpExtensionProc(pECB AS ;
        WINEXTENSION_CONTROL_BLOCK);
        AS DWORD PASCAL
        //
        // Entry point for all ISAPI requests
        //
        LOCAL cHtml   		AS STRING
        LOCAL nRet   		AS DWORD
        LOCAL oISAPI  		AS StdHTTPContext
        LOCAL DIM abTemp[256] 	AS BYTE
        LOCAL cTemp		AS STRING
        oISAPI:= StdHTTPContext{pECB}
        cTemp := oISAPI:QueryString
        MemCopy(@abTemp[1], PTR(_CAST, cTemp),;
        SLen(cTemp) + 1)
        IF oISAPI:ServerSupportFunction( ;
        HSE_REQ_MAP_URL_TO_PATH, @abTemp[1], 256, "")
        cHtml := "The path for " + cTemp + " is " + ;
        Psz2String(@abTemp[1])
        ELSE
        cHtml:="Error calling ServerSupportFunction()"
        ENDIF
        cHtml := oISAPI:HTTPMsg(cHtml)
        IF oISAPI:Write(cHtml)
        nRet := HSE_STATUS_SUCCESS
        ELSE
        nRet := oISAPI:StatusCode
        ENDIF
        RETURN nRet
      </code>
      The appropriate HTML file might look like the following:
      <code language="X#">
        &lt;html&gt;
        &lt;body&gt;
        &lt;h1&gt;ISAPI DLL Test&lt;/h1&gt;
        &lt;p&gt;&lt;a href="/voscript/votest.dll&amp;/scripts"&gt;
        Display translated name for scripts
        &lt;/a&gt;&lt;/p&gt;
        &lt;/body&gt;
        &lt;/html&gt;
      </code>
    </example>
  </HTTPExtensionContext.ServerSupportFunction>
  <HTTPExtensionContext.StatusCode>
    <summary>
      Numeric value representing the HTTP status code.
    </summary>
    <value>Numeric value representing the HTTP status code.</value>
  </HTTPExtensionContext.StatusCode>
  <HTTPExtensionContext.Write>
    <summary>
      Send the HTTP entity, including the response header, to the client.
    </summary>
    <param name="cHTTPEntity">String containing data that has to be sent to the client's Internet browser.</param>
    <returns>
      TRUE, if the write operation was successful; otherwise, FALSE.
    </returns>
    <remarks>
      This method sends a complete HTTP server response header—including the status, server version, message time, and MIME version—to the client followed by HTTP data specified by <paramref name="cHTTPEntity" />.
    </remarks>
    <example>
      See the HTTPExtensionContext:WriteClient() example.
    </example>
  </HTTPExtensionContext.Write>
  <HTTPExtensionContext.WriteClient>
    <summary>
      Send the raw HTTP entity data to a client.
    </summary>
    <param name="cHTTPEntity">String containing data that has to be sent to the client's Internet browser.</param>
    <param name="nFlag">
      A numeric value indicating how the I/O operation should be handled. The following flags are supported:
      The I/O operation should be done synchronously. This is the default value.
      The I/O operation should be done asynchronously. The ISAPI application should have made a call to the ServerSupportFunction(HSE_REQ_IO_COMPLETION) method, and submitted a callback function and context value for handling completion of asynchronous operations.
    </param>
    <returns>
      TRUE, if the write operation was successful; otherwise, FALSE.
    </returns>
    <remarks>
      This method sends data present in the given buffer to the client that made the request.
    </remarks>
    <example>
      The following function can be used to create an ISAPI DLL (votest.dll) for displaying a specified image file:
      <code language="X#">
        FUNC HttpExtensionProcx( pECB AS ;
        WINEXTENSION_CONTROL_BLOCK) AS DWORD PASCAL
        LOCAL cHtml		AS STRING
        LOCAL nRet			AS DWORD
        LOCAL oISAPI		AS StdHTTPContext
        LOCAL cTemp		AS STRING
        LOCAL cContent		AS STRING
        LOCAL nSize		AS INT
        oISAPI:= StdHTTPContext{pECB}
        cTemp := oISAPI:QueryString
        IF File(cTemp)
        cContent := MemoRead(cTemp)
        nSize  := SLen(cContent)
        cHtml := "Content-type: image/" +;
        Lower(Right(cTemp,3)) + CRLF
        cHtml  += "Content-length: " + NTrim(nSize)
        Html  += CRLF + CRLF
        IF oISAPI:Write(cHtml)
        ISAPI:WriteClient(cContent)
        Ret := HSE_STATUS_SUCCESS
        ELSE
        nRet := oISAPI:StatusCode
        ENDIF
        ELSE
        cTemp := FPathName()
        cHtml := "File " + cTemp + " not found"
        cHtml := oISAPI:HTTPMsg(cHtml)
        IF oISAPI:Write(cHtml)
        nRet := HSE_STATUS_SUCCESS
        ELSE
        nRet := oISAPI:StatusCode
        ENDIF
        ENDIF
        RETURN nRet
      </code>
      The appropriate HTML file might look like the following:
      <code language="X#">
        &lt;html&gt;
        &lt;body&gt;
        &lt;h1&gt;DLL Image Test&lt;/h1&gt;
        ...
        &lt;img src="/scripts/votest.dll?/vosample/vo.jpg"&gt;
        &lt;/body&gt;
        &lt;/html&gt;
      </code>
    </example>
  </HTTPExtensionContext.WriteClient>
  <HTTPExtensionContext.WriteContentFile>
    <summary>
      Send the HTTP header and data for a specified content type to the client.
    </summary>
    <param name="cFile">File name, including drive letter and path.</param>
    <param name="cType">Content type (e.g., 'image', 'text', or 'application').</param>
    <param name="cSubType">
      Content subtype (e.g., 'jpeg' or 'gif' if <paramref name="cType" /> is 'image', 'zip' if <paramref name="cType" /> is 'application', or 'html' if <paramref name="cType" /> is 'text').
    </param>
    <returns>
      File size in bytes if the file has been found; otherwise, 0.
    </returns>
    <remarks>
      This method sends the specified content file and appropriate reply header to the client that made the request.
    </remarks>
    <example>
      See the HTTPCgiContext:WriteContentFile() example.
    </example>
  </HTTPExtensionContext.WriteContentFile>
  <HTTPExtensionContext.WriteImage>
    <summary>
      Send the raw HTTP header and data for a specified image file to the client.
    </summary>
    <param name="cFile">Image file name, including drive letter and path.</param>
    <returns>
      File size in bytes if the file has been found; otherwise, 0.
    </returns>
    <remarks>
      This method sends the specified image file and appropriate reply header to the client that made the request.
    </remarks>
    <example>
      See the HTTPCgiContext:WriteImage() example.
    </example>
  </HTTPExtensionContext.WriteImage>
  <HTTPFilterContext>
    <summary>
      Provide low-level access to the HTTP communication server.
    </summary>
    <remarks>
      The HTTPFilterContext class provides low-level access to the HTTP communication stream. This class can be used, for example, to filter the data sent by a Web server to a client and exchange certain parts of that data in order to implement a page counter.
    </remarks>
  </HTTPFilterContext>
  <HTTPFilterContext.ctor>
    <summary>
      Construct an HTTPFilterContext object.
    </summary>
    <param name="pFilterContext">Pointer to a _WINHTTP_FILTER_CONTEXT structure containing all data for the request to an ISAPI DLL.</param>
    <remarks>
      An HTTPFilterContext object can only be created within the entry point function, HttpFilterProc(), of an ISAPI extension DLL. The Init() method requires a valid <paramref name="pFilterContext" /> pointer, because the HTTPFilterContext class is a layer for ISAPI Filter Callback functions contained in the _WINHTTP_FILTER_CONTEXT structure.
    </remarks>
    <example>
      The following function can be used to create an ISAPI filter DLL:
      <code language="X#">
        CLASS MyFilter INHERIT HTTPFilterContext
        FUNC HttpFilterProc(pFCB AS ;
        WINHTTP_FILTER_CONTEXT,;
        dwNotify AS DWORD,;
        pData AS PTR) AS DWORD PASCAL
        LOCAL nRet   AS DWORD
        LOCAL oFilter  AS MyFilter
        oFilter := MyFilter{pFCB}
        DO CASE
        CASE dwNotify == SF_NOTIFY_URL_MAP
        nRet := oFilter:OnUrlMap(pData)
        CASE dwNotify == SF_NOTIFY_SEND_RAW_DATA
        nRet := oFilter:OnSendRawData(pData)
        CASE dwNotify == SF_NOTIFY_END_OF_NET_SESSION
        nRet := oFilter:OnEndSession(pFCB)
        CASE dwNotify == SF_NOTIFY_READ_RAW_DATA
        nRet := oFilter:OnReadRawData(pData)
        CASE dwNotify == SF_NOTIFY_PREPROC_HEADERS
        nRet :=oFilter:OnPreprocHeaders(pData)
        CASE dwNotify == SF_NOTIFY_LOG
        nRet := oFilter:OnLog(pData)
        CASE dwNotify == SF_NOTIFY_AUTHENTICATION
        nRet := oFilter:OnAuthentication(pData)
        OTHERWISE
        nRet := SF_STATUS_REQ_NEXT_NOTIFICATION
        ENDCASE
        RETURN nRet
      </code>
      The filter will be implemented by overwriting the OnUrlMap() and OnRawSendData() event handlers of the HTTPFilterContext class by the MyFilter class.
    </example>
  </HTTPFilterContext.ctor>
  <HTTPFilterContext.AddResponseHeaders>
    <summary>
      Add a header to an HTTP response.
    </summary>
    <param name="cNewHeader">String containing the headers to be added.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This call method is used to add a header to an HTTP response.
    </remarks>
  </HTTPFilterContext.AddResponseHeaders>
  <HTTPFilterContext.AllocMem>
    <summary>
      Allocate memory that has not been freed when the communication terminates.
    </summary>
    <param name="nBytes">Size of the memory buffer to allocate in bytes.</param>
    <returns>
      Pointer to an allocated buffer, if successful; otherwise, NULL_PTR.
    </returns>
    <remarks>
      This method allocates memory that has not been freed when the communication terminates. The memory buffer will be freed automatically by the Internet Information Server (IIS) when the end-of-net-session occurs.
    </remarks>
  </HTTPFilterContext.AllocMem>
  <HTTPFilterContext.Error>
    <summary>
      Number of the last error that occurred in the running application.
    </summary>
    <value>Number of the last error that occurred in the running application.</value>
  </HTTPFilterContext.Error>
  <HTTPFilterContext.FCB>
    <summary>
      Pointer to the _WINHTTP_FILTER_CONTEXT structure.
    </summary>
    <value>Pointer to the _WINHTTP_FILTER_CONTEXT structure.</value>
  </HTTPFilterContext.FCB>
  <HTTPFilterContext.FilterContext>
    <summary>
      Pointer to the pFilterContext member of the _WINHTTP_FILTER_CONTEXT structure.
    </summary>
    <value>Pointer to the pFilterContext member of the _WINHTTP_FILTER_CONTEXT structure.</value>
  </HTTPFilterContext.FilterContext>
  <HTTPFilterContext.GetServerVariable>
    <summary>
      Retrieve a specified environment value from the current Internet server.
    </summary>
    <param name="cValueName">String containing the name of the sought after environment variable.</param>
    <returns>
      String containing the specified value, if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      This method returns the current environment setting specified by <paramref name="cValueName" />.
    </remarks>
    <example>
      See the HTTPContextAbstract:GetServerVariable() example.
    </example>
  </HTTPFilterContext.GetServerVariable>
  <HTTPFilterContext.OnAuthentication>
    <summary>
      Event handler method called by the filter DLL to authenticate the client.
    </summary>
    <param name="pFCB">Pointer to a _WINHTTP_FILTER_CONTEXT structure.</param>
    <returns>
      One of the following notification types:
      SF_STATUS_REQ_FINISHED
      The filter has handled the HTTP request. The server should disconnect the session.
      SF_STATUS_REQ_FINISHED_KEEP_CONN
      Same as SF_STATUS_REQ_FINISHED, except the server should keep the TCP session open if the option was negotiated.
      SF_STATUS_REQ_NEXT_NOTIFICATION
      The next filter in the notification chain should be called.
      SF_STATUS_REQ_ERROR
      An error occurred. The server should use the Win32 API SetLastError() function to indicate the error to the client.
      SF_STATUS_REQ_READ_NEXT
      The filter is an opaque stream filter; eegotiate the session parameters. Only valid for raw read notification.
    </returns>
    <remarks>
      Override this method to implement your own authentication. The default setting is inactive.
    </remarks>
  </HTTPFilterContext.OnAuthentication>
  <HTTPFilterContext.OnEndSession>
    <summary>
      Event handler method called by the filter DLL to notify the filter that the session is ending.
    </summary>
    <param name="pFilterContext">Pointer to a _WINHTTP_FILTER_CONTEXT structure.</param>
    <returns>
      One of the following notification types:
      SF_STATUS_REQ_FINISHED
      The filter has handled the HTTP request. The server should disconnect the session.
      SF_STATUS_REQ_FINISHED_KEEP_CONN
      Same as SF_STATUS_REQ_FINISHED except the server should keep the TCP session open if the option was negotiated.
      SF_STATUS_REQ_NEXT_NOTIFICATION
      The next filter in the notification chain should be called.
      SF_STATUS_REQ_ERROR
      An error occurred. The server should use the Win32 API SetLastError() function to indicate the error to the client.
      SF_STATUS_REQ_READ_NEXT
      The filter is an opaque stream filter; negotiate the session parameters. Only valid for raw read notification.
      If unsuccessful, the notification type SF_STATUS_REQ_ERROR should be returned. In this case, the server should use the Windows function, SetLastError(), to indicate the error to the client.
    </returns>
    <remarks>
      Override this method to provide your own end-of-session implementation. The default setting is inactive.
    </remarks>
    <example>
      The following event handler writes an output debug string to the Win32 Debug Messages Window when the filter receives an SF_NOTIFY_END_OF_NET_SESSION notification:
      <code language="X#">
        METHOD OnEndSession (pData) CLASS MyFilter
        LOCAL nRet   AS DWORD
        LOCAL pContext AS _WINHTTP_FILTER_CONTEXT
        nRet := SF_STATUS_REQ_NEXT_NOTIFICATION
        IF IsPtr(pData)
        pContext := pData
        ELSE
        RETURN nRet
        ENDIF
        DebOut32("Session ended " + AsString(pContext) )
        RETURN nRet
      </code>
    </example>
  </HTTPFilterContext.OnEndSession>
  <HTTPFilterContext.OnLog>
    <summary>
      Event handler method called by the filter DLL to notify the filter that the server is writing information to the server log.
    </summary>
    <param name="pFilterLog">Pointer to a _WINHTTP_FILTER_LOG structure.</param>
    <returns>
      One of the following notification types:
      SF_STATUS_REQ_FINISHED
      The filter has handled the HTTP request. The server should disconnect the session.
      SF_STATUS_REQ_FINISHED_KEEP_CONN
      Same as SF_STATUS_REQ_FINISHED except the server should keep the TCP session open if the option was negotiated.
      SF_STATUS_REQ_NEXT_NOTIFICATION
      The next filter in the notification chain should be called.
      SF_STATUS_REQ_ERROR
      An error occurred. The server should use the Win32 API SetLastError() function to indicate the error to the client.
      SF_STATUS_REQ_READ_NEXT
      The filter is an opaque stream filter; negotiate the session parameters. Only valid for raw read notification.
      If unsuccessful, the notification type SF_STATUS_REQ_ERROR should be returned. In this case, the server should use the Windows function, SetLastError(), to indicate the error to the client.
    </returns>
    <remarks>
      Override this method to provide your own method for logging information to the server file. The default setting is inactive.
    </remarks>
  </HTTPFilterContext.OnLog>
  <HTTPFilterContext.OnPreprocHeaders>
    <summary>
      Event handler method called by the filter DLL to notify the filter that the server has preprocessed the client headers.
    </summary>
    <param name="pHeaders">Pointer to a _WINHTTP_FILTER_PREPROC_HEADERS structure.</param>
    <returns>
      One of the following notification types:
      SF_STATUS_REQ_FINISHED
      The filter has handled the HTTP request. The server should disconnect the session.
      SF_STATUS_REQ_FINISHED_KEEP_CONN
      Same as SF_STATUS_REQ_FINISHED except the server should keep the TCP session open if the option was negotiated.
      SF_STATUS_REQ_NEXT_NOTIFICATION
      The next filter in the notification chain should be called.
      SF_STATUS_REQ_ERROR
      An error occurred. The server should use the Win32 API SetLastError() function to indicate the error to the client.
      SF_STATUS_REQ_READ_NEXT
      The filter is an opaque stream filter; negotiate the session parameters. Only valid for raw read notification.
      If unsuccessful, the notification type SF_STATUS_REQ_ERROR should be returned. In this case, the server should use the Windows function, SetLastError(), to indicate the error to the client.
    </returns>
    <remarks>
      Override this method to provide your own method for processing client headers. The default setting is inactive.
    </remarks>
  </HTTPFilterContext.OnPreprocHeaders>
  <HTTPFilterContext.OnReadRawData>
    <summary>
      Event handler method called by the filter DLL to allow the filter to see the raw data. The data returned will contain both headers and data.
    </summary>
    <param name="pRawData">Pointer to a _WINHTTP_FILTER_RAW_DATA structure.</param>
    <returns>
      One of the following notification types:
      SF_STATUS_REQ_FINISHED
      The filter has handled the HTTP request. The server should disconnect the session.
      SF_STATUS_REQ_FINISHED_KEEP_CONN
      Same as SF_STATUS_REQ_FINISHED except the server should keep the TCP session open if the option was negotiated.
      SF_STATUS_REQ_NEXT_NOTIFICATION
      The next filter in the notification chain should be called.
      SF_STATUS_REQ_ERROR
      An error occurred. The server should use the Win32 API SetLastError() function to indicate the error to the client.
      SF_STATUS_REQ_READ_NEXT
      The filter is an opaque stream filter; negotiate the session parameters. Only valid for raw read notification.
      If unsuccessful, the notification type SF_STATUS_REQ_ERROR should be returned. In this case, the server should use the Windows function, SetLastError(), to indicate the error to the client.
    </returns>
    <remarks>
      Override this method to process raw data differently.
    </remarks>
  </HTTPFilterContext.OnReadRawData>
  <HTTPFilterContext.OnSendRawData>
    <summary>
      Event handler method called by the filter DLL to allow the filter to send the raw data. The data returned will contain both headers and data.
    </summary>
    <param name="pRawData">Pointer to a _WINHTTP_FILTER_RAW_DATA structure.</param>
    <returns>
      One of the following notification types:
      SF_STATUS_REQ_ERROR
      An error occurred. The server should use the Win32 API SetLastError() function to indicate the error to the client.
      SF_STATUS_REQ_NEXT_NOTIFICATION
      The next filter in the notification chain should be called.
      If unsuccessful, the notification type SF_STATUS_REQ_ERROR should be returned. In this case, the server should use the Windows function, SetLastError(), to indicate the error to the client.
    </returns>
    <remarks>
      Override this method to change the default notification handler and to process raw data differently.
    </remarks>
  </HTTPFilterContext.OnSendRawData>
  <HTTPFilterContext.OnUrlMap>
    <summary>
      Event handler method called by the filter DLL when the server is mapping a logical URL to a physical path.
    </summary>
    <param name="pURLMap">Pointer to a _WINHTTP_FILTER_URL_MAP structure.</param>
    <returns>
      One of the following notification types:
      SF_STATUS_REQ_ERROR
      An error occurred. The server should use the Win32 API SetLastError() function to indicate the error to the client.
      SF_STATUS_REQ_NEXT_NOTIFICATION
      The next filter in the notification chain should be called.
      If unsuccessful, the notification type SF_STATUS_REQ_ERROR should be returned. In this case, the server should use the Windows function, SetLastError(), to indicate the error to the client.
    </returns>
    <remarks>
      Override this method to handle URL mapping differently. The default setting is inactive.
    </remarks>
    <example>
      The following event handler writes the translated URL to the Win32 Debug Messages Window when the filter receives an SF_NOTIFY_END_OF_NET_SESSION notification:
      <code language="X#">
        METHOD OnUrlMap (pData) CLASS MyFilter
        LOCAL nRet  AS DWORD
        LOCAL pFUM  AS _WINHTTP_FILTER_URL_MAP
        nRet := SF_STATUS_REQ_NEXT_NOTIFICATION
        IF IsPtr(pData)
        pFUM := pData
        ELSE
        RETURN nRet
        ENDIF
        DebOut32(pFUM.pszPhysicalPath)
        RETURN nRet
      </code>
    </example>
  </HTTPFilterContext.OnUrlMap>
  <HTTPFilterContext.ServerSupportFunction>
    <summary>
      Method to extend the filter's functionality.
    </summary>
    <param name="nRequest">A DWORD value containing the Filter Request type, which indicates the requested functions. Valid values are:</param>
    <param name="pBuffer">Pointer to the buffer that contains the primary argument required for the requested support function.</param>
    <param name="nSize">
      Numeric value indicating the number of bytes available in the buffer. Defaults to the size of <paramref name="pBuffer" /> + 1.
    </param>
    <param name="cData">String containing data for secondary arguments.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method provides several support functions that are not covered directly by the standard callback functions of the _WINHTTP_FILTER_CONTEXT structure.
    </remarks>
  </HTTPFilterContext.ServerSupportFunction>
  <HTTPFilterContext.WriteClient>
    <summary>
      Send the raw HTTP entity data to the client.
    </summary>
    <param name="cHTTPEntity">String containing data that has to be sent to the client's Internet browser. If not specified, defaults to a line break, '&lt;br&gt;'.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method sends data present in the given buffer to the client that made the request.
    </remarks>
  </HTTPFilterContext.WriteClient>
  <HyperLink>
    <summary>
      Create a HyperLink control.
    </summary>
    <remarks>
      The intention of this class is that the text would appear as a HyperLink to a www address or as an @ email address and therefore the cursor will appear as the normal hand.
      When the control is clicked on, it will attempt to "open" the text of the control using the OpenLink callback method. If the text is a www address it will open the default browser and attempt to navigate to the address. If the text contains an @ it will be taken as an email address and open the default email client.
      <note type="tip">
        The difference between the HyperLink and the SysLink classes is in the way that the text is used.
        In a HyperLink control, ALL of the text is passed as the hyperlink where as in the SysLink control you can mix display text and hyperlink text.
        Also, in the HyperLink control, ALL of the displayed text is passed through to the ShellExecute method and you must make sure that there is nothing in it which could cause this to fail.
      </note>
    </remarks>
    <example>
      <code language="X#">
        oFont1 := Font{,8,"Microsoft Sans Serif"}
        oFont1:Underline := TRUE
        oHL1 := HyperLink{ SELF, -1, Point{190, 25 }, ;
        Dimension{0, 0 }, "http://www.grafxsoft.com" }
        oHL1:font := oFont1
        oHL1:size := Dimension{150,20}
        oHL1:textcolor := Color{ COLORBLUE }
        oHL1:font:underline := TRUE
        oHL1:Show( )
      </code>
    </example>
  </HyperLink>
  <HyperLink.ctor>
    <summary>
      Construct a HyperLink control.
    </summary>
    <param name="oOwner">The window that owns the HyperLink.</param>
    <param name="xID">The unique ID of the HyperLink control (between 1 and 8000).</param>
    <param name="oPoint">The origin of the HyperLink control in canvas coordinates.</param>
    <param name="oDimension">The dimension of the HyperLink control in canvas coordinates.</param>
    <param name="cText">The string that is to be displayed on screen.</param>
  </HyperLink.ctor>
  <HyperLink.Dispatch>
    <inheritdoc />
  </HyperLink.Dispatch>
  <HyperLink.OpenLink>
    <summary>
      Is the method that is invoked whenever the mouse is clicked over the HyperLink control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This method is automatically called whenever the mouse is clicked over the HyperLink control.
    </remarks>
  </HyperLink.OpenLink>
  <IApplicationObject>
    <summary>
      Share information among all users of an ASP application.
    </summary>
    <remarks>
      By using an IApplication object, you are able to share information among all users of a given application. An ASP-based application contains all the .ASP files in a virtual directory and its subdirectories. Because the IApplication object can be shared by more than one user, there are _Lock() and _Unlock() methods to ensure that multiple users accesses.
    </remarks>
  </IApplicationObject>
  <IApplicationObject.ctor>
    <summary>
      Construct an IApplicationObject object instance.
    </summary>
    <param name="oIScrContext">An IScriptingContext object.</param>
    <param name="pIAppObj">Pointer to an IApplication Interface object structure.</param>
    <remarks>
      An IApplicationObject instance is automatically created by the IScriptingContext:OnStartPage() method when the appropriate .ASP file is loaded by the Internet Information Server (IIS). Therefore, you do not have to create this object yourself. Rather, use it for an ASP Component application via the IScriptingContext:Application property.
    </remarks>
  </IApplicationObject.ctor>
  <IApplicationObject._Lock>
    <summary>
      Lock all variables of an IApplicationObject instance.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Prevents other clients from accessing the variables stored in an IApplicationObject object until the _Unlock() method has been called.
    </remarks>
    <example>
      See the IApplicationObject:GetValue() example.
    </example>
  </IApplicationObject._Lock>
  <IApplicationObject._UnLock>
    <summary>
      Release all variables of an IApplicationObject instance.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Releases variables stored in an IApplicationObject object previously locked by the _Lock() method.
    </remarks>
    <example>
      See the IApplicationObject:GetValue() example.
    </example>
  </IApplicationObject._UnLock>
  <IApplicationObject.GetValue>
    <summary>
      Retrieve the value of a variable stored in an IApplication object.
    </summary>
    <param name="cVarName">Name of the wanted variable.</param>
    <returns>
      Value of type USUAL, if successful; otherwise, NIL.
    </returns>
    <remarks>
      This method retrieves the value of a variable stored in the IApplication object.
    </remarks>
    <example>
      The following source code can be used to display the application-wide value, "GlobalVar":
      <code language="X#">
        GLOBAL goASPComponent 	AS ASPComponent
        PROCEDURE InitProc() _INIT 3
        goASPComponent := ASPComponent{}
        CLASS ASPComponent INHERIT IScriptingContext
      </code><code language="X#">
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL cRet	AS STRING
        IF SELF:Application:_Lock()
        cRet := SELF:Application:GetValue("GlobalVar")
        SELF:Application:_UnLock()
        ENDIF
        RETURN SELF:Response:_Write(cRet)
      </code>
      ASP code:
      <code language="X#">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        Application("GlobalVar") = "Hello world"
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IApplicationObject.GetValue>
  <IApplicationObject.PutValue>
    <summary>
      Store the value of a variable into an IApplication object.
    </summary>
    <param name="cVarName">Name of the desired variable.</param>
    <param name="xValue">
      The new value to assign to <paramref name="cVarName" />.
    </param>
    <returns>
      TRUE, if the value has been changed; otherwise, FALSE.
    </returns>
    <remarks>
      This method assigns the value of a variable stored in the IApplication object.
    </remarks>
  </IApplicationObject.PutValue>
  <Icon>
    <summary>
      Create an icon, which is a small bitmap that the system displays for a window when it is iconized in its owner window.
    </summary>
    <remarks>
      X# provides a set of predefined icons, defined in Icon:Init(). Use the AppWindow:Icon property to assign an icon for each application window.
      Visual Object includes an Icon Editor which produces standard system icon files. There is also a large library of system icons. These icon files are compatible with the standard format on the system, so any other icon file or Icon Editor may also be used. To use such an icon file, create an icon resource with the RESOURCE statement and reference it when instantiating an icon. Refer to the IDE User Guide for more information on using and editing the standard icons.
      <note type="tip">An icon's size and color range is system-dependent.</note>
    </remarks>
    <example>
      The following example demonstrates the use of one of the standard icons:
      <code language="X#">
        CLASS MyWindow INHERIT TopAppWindow
        METHOD Init() CLASS MyWindow
        SUPER:Init()
        SELF:Icon := Icon{ICONASTERISK}
      </code>
      This code fragment emphasizes three things:
      Any Init() method of a class that inherits must call SUPER:Init().
      The pseudo-variable Icon is an access/assign pair in class AppWindow.
      ICONASTERISK identifies one of the standard icons.
      The following example provides an application window with a custom icon:
      <code language="X#">
        CLASS MyTopAppWin INHERIT TopAppWindow
        METHOD Init CLASS MyTopAppWin
        SUPER:Init()
        SELF:Icon := Icon{IDI_APPICON}
        RESOURCE IDI_APPICON ICON app.ico
      </code>

      In Windows, icons are defined in a resource entity using the keyword ICON, referencing the name of the file created by the Icon Editor.
    </example>
  </Icon>
  <Icon.ctor>
    <summary>
      Construct an icon.
    </summary>
    <param name="xResourceID">The resource ID of the desired icon, a handle of an existing Icon object or one of the icon constants from the table below</param>
    <param name="kLoadOption">The optional constant representing the load option. The default is LR_DEFAULTCOLOR.</param>
    <param name="iWidth">The optional width of the bitmap. The default is the width of the bitmap.</param>
    <param name="iHeight">The optional height of the bitmap. The default is the height of the bitmap.</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant	Icon</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>ICONASTERISK</term>
          <description>An icon used to indicate "note that."</description>
        </item>
        <item>
          <term>ICONEXCLAMATION</term>
          <description>An icon used to indicate warnings.</description>
        </item>
        <item>
          <term>ICONHAND</term>
          <description>An icon used to indicate error conditions.</description>
        </item>
        <item>
          <term>ICONQUESTIONMARK</term>
          <description>An icon used to indicate that more information is required.</description>
        </item>
        <item>
          <term>ICONSTANDARD</term>
          <description>A blank, square icon. This is the default.</description>
        </item>
      </list>
    </remarks>
  </Icon.ctor>
  <Icon.Destroy>
    <summary>
      Provide a method to de-instantiate an Icon object.
    </summary>
    <remarks>
      This method can be used when an Icon object is no longer needed. Icon:Destroy() de-instantiates the Icon object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </Icon.Destroy>
  <Icon.Handle>
    <summary>
      Return the handle for an icon.
    </summary>
    <param name="nHandleType">
      The type of handle required. Zero (0) is the only supported option and is the default if <paramref name="nHandle" /> is omitted.
    </param>
    <returns>
      A handle describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
    </remarks>
  </Icon.Handle>
  <Icon.Size>
    <exclude />
  </Icon.Size>
  <IDispatch>
    <summary>
      Provide a helper class for turning a returned OLE automation interface into an OLEAutoObject.
    </summary>
    <remarks>
      <br />Important! This class is used for internal implementation only and is not intended to be used directly.
    </remarks>
  </IDispatch>
  <ImageList>
    <summary>
      Create an image list.
    </summary>
    <remarks>
      An image list is an object that is essentially a collection of icons and/or bitmaps of the same size. Image lists provide a way to manage icons and bitmaps in groups rather than as individual objects. They are typically used by tab, list view, and tree view controls, which refer to particular images in the list by their sequential index. Image lists are used by controls for image manipulation; as a result, methods such as BeginDrag(), DragMove(), EndDrag(), and Handle() are used by the system and should generally not be used directly.
    </remarks>
  </ImageList>
  <ImageList.ctor>
    <summary>
      Construct an image list object.
    </summary>
    <param name="nImages">The number of images this image list will contain.</param>
    <param name="oDimension">A Dimension object representing the size of the images in the image list.</param>
    <param name="oImage">Add an Icon or Bitmap object to the ImageList.</param>
    <param name="wColor">The color mask to use. This is a Set of bit flags that specify the type of image list to create. This parameter can be a combination of the following values, but it can include only one of the ILC_COLOR values.</param>
    <param name="nGrow">This is the number of images by which the image list can grow when the system needs to make room for new images.</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>Value</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>ILC_COLOR</term>
          <description>Use the default behavior if none of the other ILC_COLOR* flags is specified. Typically, the default is ILC_COLOR4, but for older display drivers, the default is ILC_COLORDDB.</description>
        </item>
        <item>
          <term>ILC_COLOR4</term>
          <description>Use a 4-bit (16-color) device-independent bitmap (DIB) section as the bitmap for the image list.</description>
        </item>
        <item>
          <term>ILC_COLOR8</term>
          <description>Use an 8-bit DIB section. The colors used for the color table are the same colors as the halftone palette.</description>
        </item>
        <item>
          <term>ILC_COLOR16</term>
          <description>Use a 16-bit (32/64k-color) DIB section.</description>
        </item>
        <item>
          <term>ILC_COLOR24</term>
          <description>Use a 24-bit DIB section.</description>
        </item>
        <item>
          <term>ILC_COLOR32</term>
          <description>Use a 32-bit DIB section.</description>
        </item>
        <item>
          <term>ILC_COLORDDB</term>
          <description>Use a device-dependent bitmap.</description>
        </item>
        <item>
          <term>ILC_MASK</term>
          <description>Use a mask. The image list contains two bitmaps, one of which is a monochrome bitmap used as a mask. If this value is not included, the image list contains only one bitmap.</description>
        </item>
        <item>
          <term>ILC_MIRROR</term>
          <description>Version 6.00. Microsoft Windows can be mirrored to display languages such as Hebrew or Arabic that read right-to-left. If the image list is created on a mirrored version of Windows, then the images in the lists are mirrored, that is, they are flipped so they display from right to left. Use this flag on a mirrored version of Windows to instruct the image list not to automatically mirror images.</description>
        </item>
        <item>
          <term>ILC_PERITEMMIRROR</term>
          <description>Version 6.00. Specify this flag if ILC_MIRROR is used on an image list that contains a strip of images. ILC_MIRROR must be specified for this flag to have any effect.</description>
        </item>
      </list>
      NOTE: If you pass the fourth parameter you should always include ICL_MASK in the value.
    </remarks>
  </ImageList.ctor>
  <ImageList.Add>
    <summary>
      Add an icon or bitmap to the image list.
    </summary>
    <param name="oImage">The icon or bitmap to add to the image list.</param>
    <returns>
      The image list index of the added image.
    </returns>
  </ImageList.Add>
  <ImageList.AddMask>
    <summary>
      Adds an image or images to an image list and generates a mask from the specified bitmap.
    </summary>
    <param name="oBitmap">The bitmap object to use for the ImageList mask.</param>
    <param name="oMaskColor">The color of the mask.</param>
    <returns>
      The index of the first new image, if successful; otherwise, -1.
    </returns>
  </ImageList.AddMask>
  <ImageList.BeginDrag>
    <summary>
      Begin a drag operation on an image list.
    </summary>
    <param name="nIndex">The image list index of the image to be dragged. If omitted, the first image in the image list is used.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ImageList.BeginDrag>
  <ImageList.CreateOverlayImage>
    <summary>
      Create an overlay image from an image in an image list.
    </summary>
    <param name="nListIndex">The image list index of the image from which to create an overlay image.</param>
    <param name="nImageIndex">The index of the new overlay image. This can be a value from 1 to 4. If omitted, the new overlay image will be the first in the list.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      An overlay image is an image drawn over another image. This technique is commonly used in list view and tree view controls. An image list can have up to four overlay images.
    </remarks>
  </ImageList.CreateOverlayImage>
  <ImageList.Destroy>
    <exclude />
  </ImageList.Destroy>
  <ImageList.DragEnter>
    <summary>
      Starts a drag-and-drop operation at the given position in the given window.
    </summary>
    <param name="oPoint">** missing parameter documentation **</param>
    <param name="oWindow">** missing parameter documentation **</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ImageList.DragEnter>
  <ImageList.DragLeave>
    <summary>
      Ends a drag-and-drop operation.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ImageList.DragLeave>
  <ImageList.DragMove>
    <summary>
      Drag an image list to the specified position.
    </summary>
    <param name="oPoint">The point to which to drag the image list.</param>
    <param name="oWindow">The window over which the image list is to be dragged.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ImageList.DragMove>
  <ImageList.EndDrag>
    <summary>
      End a drag operation on an image list.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ImageList.EndDrag>
  <ImageList.Handle>
    <summary>
      Return the Windows handle of the image list, which can be used in Windows.
    </summary>
    <returns>
      The handle (a pointer) of the image list.
    </returns>
  </ImageList.Handle>
  <ImageList.ImageCount>
    <summary>
      The number of images in the ImageList object.
    </summary>
    <value>The number of images in the ImageList object.</value>
  </ImageList.ImageCount>
  <ImageList.ImageSize>
    <exclude />
  </ImageList.ImageSize>
  <InfoBox>
    <summary>
      Present the user with informational message box.
    </summary>
    <remarks>
      An informational message box is a window that displays a user-defined caption in the title bar, the text of the informational message, and an information icon. These boxes are typically used to provide useful information to the user. When the information box disappears, focus is returned to the owner window.
      <note type="tip">An information box is application modal—the user must acknowledge it before continuing with the application.</note>
    </remarks>
    <example>
      The following example displays an information box:
      <code language="X#">
        METHOD Start() CLASS App
        oMyWin := TopAppWindow{}
        oMyWin:Show()
        oSomeInfo := InfoBox{oMyWin, "Info", "Message box"}
        oSomeInfo:Show()
        SELF:Exec()
      </code>
    </example>
  </InfoBox>
  <InfoBox.ctor>
    <summary>
      Construct an information message box.
    </summary>
    <param name="uParent">The window that owns the information box. If omitted, the default owner is the Windows desktop.</param>
    <param name="uCaption">The caption text to be displayed in the title bar of the information box. If omitted, the default is 'Info Box'.</param>
    <param name="uText">
      The informational text to be printed in the information box when it is shown or the hyperlabel containing a caption and description for the information box.
      If omitted, the default is NULL_STRING.
    </param>
  </InfoBox.ctor>
  <IntegerFS>
    <summary>
      Create an integer field specification, which holds integer data type information.
    </summary>
  </IntegerFS>
  <IntegerFS.ctor>
    <summary>
      Construct an integer field specification.
    </summary>
    <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new integer field specification.</param>
    <param name="uLength">The length of the field. If not specified, the default is 10.</param>
  </IntegerFS.ctor>
  <IPAddress>
    <summary>
      Edit control to edit an IP address that consists of 4 numbers
    </summary>
  </IPAddress>
  <IPAddress.ctor>
    <summary>
      Construct an IPAddress object.
    </summary>
    <param name="oOwner">The window that owns the IPAddress object.</param>
    <param name="xID">The unique ID for the IPAddress object (between 1 and 8000).</param>
    <param name="oPoint">The origin of the IPAddress object in canvas coordinates.</param>
    <param name="oDimension">The dimension of the IPAddress object in canvas coordinates.</param>
    <param name="dwStyle">
      Constant representing the style of the IPAddress object, specified either by a X# style constant or a Windows API style constant. Styles can be combined using the _Or() operator.
    </param>
    <param name="lDataAware">A logical value that is TRUE if the IPAddress object is data-aware; otherwise, FALSE. If omitted, defaults to TRUE.</param>
    <param name="nResourceID">The resource ID of the IPAddress object.</param>
    <remarks>
      <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular style constant.</note>
    </remarks>
  </IPAddress.ctor>
  <IPAddress.Address>
    <summary>
      A long value representing the current IP address. This equals the IP address interpreted as a 4-byte integer.
    </summary>
    <value>A long value representing the current IP address. This equals the IP address interpreted as a 4-byte integer.</value>
  </IPAddress.Address>
  <IPAddress.EditHandle>
    <exclude />
  </IPAddress.EditHandle>
  <IPAddress.Field1>
    <summary>
      A numeric value representing the first field of the current IP Address. For the IP Address "130.119.121.147", this access would return 130.
    </summary>
    <value>A numeric value representing the first field of the current IP Address. For the IP Address "130.119.121.147", this access would return 130.</value>
  </IPAddress.Field1>
  <IPAddress.Field2>
    <summary>
      A numeric value representing the second field of the current IP address. For the IP address "130.119.121.147", this access would return 119.
    </summary>
    <value>A numeric value representing the second field of the current IP address. For the IP address "130.119.121.147", this access would return 119.</value>
  </IPAddress.Field2>
  <IPAddress.Field3>
    <summary>
      A numeric value representing the third field of the current IP address. For the IP address "130.119.121.147", this access would return 121.
    </summary>
    <value>A numeric value representing the third field of the current IP address. For the IP address "130.119.121.147", this access would return 121.</value>
  </IPAddress.Field3>
  <IPAddress.Field4>
    <summary>
      A numeric value representing the fourth field of the current IP address. For the IP address "130.119.121.147", this access would return 147.
    </summary>
    <value>A numeric value representing the fourth field of the current IP address. For the IP address "130.119.121.147", this access would return 147.</value>
  </IPAddress.Field4>
  <IPAddress.SetRange>
    <summary>
      Set the allowable entry range per field.
    </summary>
    <param name="iFieldIndex">Index of the field for which the range is being set (between 1 and4).</param>
    <param name="iLower">Lower limit of the range.</param>
    <param name="iUpper">Upper limit of the range.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      SetRange allows you to set the allowed range of the four input fields individually.
    </remarks>
  </IPAddress.SetRange>
  <IPAddress.TextValue>
    <summary>
      String representing the IP address.
    </summary>
    <value>String representing the IP address.</value>
    <example>
      The following example demonstrates the IP address being set and read back:
      <code language="X#">
        oDCIPAddress1:TextValue := '192.168.0.1'
        ? oDCIPAddress1:TextValue //	'192.168.0.1'
      </code>
    </example>
  </IPAddress.TextValue>
  <IPAddress.Value>
    <exclude />
  </IPAddress.Value>
  <IpcClient>
    <summary>
      Register an application as a client able to request and receive data from a designated server application.
    </summary>
    <remarks>
      In X#, the IPC... classes provides a means of implementing DDE conversations between DDE-compatible applications. DDE (Dynamic Data Exchange) is a type of interprocess communication (IPC) that uses shared memory to exchange data between applications. IPC is governed by a DDE management library, an underlying DLL in Windows.
      In such a conversation, there is a client and a server. The client requests data from the server about particular topics and items, and the server supplies the requested data. The applications, after requesting to be a client or server (or both), then exchange updates as soon as new data becomes available. These exchanges are not necessarily initiated by the user.
      Each IPC client must uniquely identify the server with which it wishes to communicate, and then request data updates. After the initial transfer, the client is informed of any changes to the transferred data in the server by means of an IpcDataUpdateEvent.
    </remarks>
  </IpcClient>
  <IpcClient.ctor>
    <summary>
      Construct an IpcClient object.
    </summary>
    <param name="cServerName">The server with which to communicate.</param>
  </IpcClient.ctor>
  <IpcClient.ChangeData>
    <summary>
      Tell the remote server that some data value has changed. This results in the server receiving an IpcDataUpdateEvent. It is then the responsibility of the server to update itself.
    </summary>
    <param name="cTopic">The name of the IPC topic whose data has changed. This method causes the system to notify the IPC server of the change by sending it an IpcDataUpdateEvent. When the server asks that event which topic has changed, the event answers with the value you gave to this argument.</param>
    <param name="cItem">The name of the item to change.</param>
    <param name="cStringData">The data that has changed.</param>
  </IpcClient.ChangeData>
  <IpcClient.ClientError>
    <summary>
      Handle ClientErrorEvent, if one occurs. Provide this event handler in your derived IpcClient class if you require special handling of errors.
    </summary>
    <param name="oIpcClientErrorEvent">The type of error that occurred. Refer to the IpcClientErrorEvent class for a list of error types.</param>
    <returns>
      TRUE if the DDE conversation is to continue; otherwise, FALSE.
    </returns>
    <example>
      The following example demonstrates how a client error event is handled by the ClientError() method:
      <code language="X#">
        METHOD ClientError(oICEE) CLASS MyClient
        LOCAL Err := oICEE:ErrorType
        DO CASE
        CASE Err == IPCSERVERNOTFOUND
        ...
      </code>
    </example>
  </IpcClient.ClientError>
  <IpcClient.DataUpdate>
    <summary>
      Called whenever the requested data changes. It is invoked after the IpcServer calls its UpdateTopic() method.
    </summary>
    <param name="oIpcDataUpdateEvent">Stores the topic name, item name, and the changed data as a string.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </IpcClient.DataUpdate>
  <IpcClient.Destroy>
    <summary>
      Provide a method to de-instantiate an IpcClient object.
    </summary>
    <remarks>
      This method can be used when an IpcClient object is no longer needed. IpcClient:Destroy() de-instantiates the IpcClient object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </IpcClient.Destroy>
  <IpcClient.Dispatch>
    <inheritdoc />
  </IpcClient.Dispatch>
  <IpcClient.Execute>
    <summary>
      Send a message to the server telling it to execute the command string remotely. As a result of this call, the server receives an IpcExecuteRequestEvent.
    </summary>
    <remarks>
      <note type="tip">In Windows, the item is not passed to the server.</note>
    </remarks>
    <param name="cTopic">The name of the IPC topic for which the server executes a command.</param>
    <param name="cItem">The name of the IPC item for which the server executes a command.</param>
    <param name="cCommand">The command to be executed by the server.</param>
  </IpcClient.Execute>
  <IpcClient.IdInst>
    <exclude />
  </IpcClient.IdInst>
  <IpcClient.RequestData>
    <summary>
      Request updates on a particular topic from the server.
    </summary>
    <param name="oIpcTopic">The IPC topic on which data is being requested.</param>
    <param name="continuous">If set to TRUE, the server sends data to the client each time it changes; if FALSE, the server sends only one update.The default is FALSE.</param>
  </IpcClient.RequestData>
  <IpcClientErrorEvent>
    <summary>
      Provide information about an IpcClientErrorEvent, used to indicate what type of error event occurred in an IPC server.
    </summary>
    <remarks>
      IpcClientErrorEvent events are sent to IpcClient:ClientError().
    </remarks>
  </IpcClientErrorEvent>
  <IpcClientErrorEvent.ctor>
    <exclude />
  </IpcClientErrorEvent.ctor>
  <IpcClientErrorEvent.ErrorType>
    <summary>
      The type of error event that occurred, as defined by the one of the constants in the table below:
    </summary>
    <value>The type of error event that occurred, as defined by the one of the constants in the table below:</value>
    <remarks>
      The type of error event that occurred, as defined by the following constants:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>IPCITEMNOTFOUND</term>
          <description>The server does not have an item of that name.</description>
        </item>
        <item>
          <term>IPCOUTOFMEMORY</term>
          <description>The system is out of memory so the action cannot be completed.</description>
        </item>
        <item>
          <term>IPCSERVERNOTFOUND</term>
          <description>The indicated server or topic is not found.</description>
        </item>
      </list>
    </remarks>
  </IpcClientErrorEvent.ErrorType>
  <IpcDataRequestEvent>
    <summary>
      Provide information about an IpcDataRequestEvent, used to store the topic name (and length) and the item name (and length) for which data has been requested.
    </summary>
    <remarks>
      IpcDataRequestEvent events are sent to IpcServer:DataRequest().
    </remarks>
  </IpcDataRequestEvent>
  <IpcDataRequestEvent.ctor>
    <exclude />
  </IpcDataRequestEvent.ctor>
  <IpcDataRequestEvent.Item>
    <summary>
      A string representing the item name for which data has been requested.
    </summary>
    <value>A string representing the item name for which data has been requested.</value>
  </IpcDataRequestEvent.Item>
  <IpcDataRequestEvent.Topic>
    <summary>
      A string representing the topic name for which data has been requested.
    </summary>
    <value>A string representing the topic name for which data has been requested.</value>
  </IpcDataRequestEvent.Topic>
  <IpcDataUpdateEvent>
    <summary>
      Provide information about an IpcDataUpdateEvent, used to store information about the topic name, item name, and the new data.
    </summary>
    <remarks>
      IpcDataUpdateEvent events are sent to IpcServer:DataUpdate() and IpcClient:DataUpdate().
    </remarks>
  </IpcDataUpdateEvent>
  <IpcDataUpdateEvent.ctor>
    <exclude />
  </IpcDataUpdateEvent.ctor>
  <IpcDataUpdateEvent.AsString>
    <summary>
      A string containing the data that has changed.
    </summary>
    <value>A string containing the data that has changed.</value>
  </IpcDataUpdateEvent.AsString>
  <IpcDataUpdateEvent.GetData>
    <summary>
      Enable the program to handle the data that has changed.
    </summary>
    <returns>
      A string containing the data that has changed.
    </returns>
  </IpcDataUpdateEvent.GetData>
  <IpcDataUpdateEvent.Item>
    <summary>
      A string representing the item name for which a data update has been requested.
    </summary>
    <value>A string representing the item name for which a data update has been requested.</value>
  </IpcDataUpdateEvent.Item>
  <IpcDataUpdateEvent.Topic>
    <summary>
      A string representing the topic name for which data update has been requested.
    </summary>
    <value>A string representing the topic name for which data update has been requested.</value>
  </IpcDataUpdateEvent.Topic>
  <IpcEvent>
    <summary>
      Provide the base class from which all Ipc event classes are subclassed.
    </summary>
  </IpcEvent>
  <IpcEvent.ctor>
    <exclude />
  </IpcEvent.ctor>
  <IpcEvent.dwData1>
    <exclude />
  </IpcEvent.dwData1>
  <IpcEvent.dwData2>
    <exclude />
  </IpcEvent.dwData2>
  <IpcEvent.dwFmt>
    <exclude />
  </IpcEvent.dwFmt>
  <IpcEvent.dwType>
    <exclude />
  </IpcEvent.dwType>
  <IpcEvent.hConv>
    <exclude />
  </IpcEvent.hConv>
  <IpcEvent.hData>
    <exclude />
  </IpcEvent.hData>
  <IpcEvent.hsz1>
    <exclude />
  </IpcEvent.hsz1>
  <IpcEvent.hsz2>
    <exclude />
  </IpcEvent.hsz2>
  <IpcEvent.Item>
    <summary>
      A string representing the item name for which the event has been requested.
    </summary>
    <value>A string representing the item name for which the event has been requested.</value>
  </IpcEvent.Item>
  <IpcEvent.oIPCObject>
    <exclude />
  </IpcEvent.oIPCObject>
  <IpcEvent.Topic>
    <summary>
      A string representing the topic name for which the event has been requested.
    </summary>
    <value>A string representing the topic name for which the event has been requested.</value>
  </IpcEvent.Topic>
  <IpcExecuteRequestEvent>
    <summary>
      Provide information about an IpcExecuteRequestEvent, used to store information about the topic, item, and command string.
    </summary>
    <remarks>
      <note type="tip">In Windows, the item string is always empty and should not be used.</note>
      IpcExecuteRequestEvent events are sent to IpcServer:ExecuteRequest().
    </remarks>
  </IpcExecuteRequestEvent>
  <IpcExecuteRequestEvent.ctor>
    <exclude />
  </IpcExecuteRequestEvent.ctor>
  <IpcExecuteRequestEvent.Command>
    <summary>
      A string representing the command name.
    </summary>
    <value>A string representing the command name.</value>
  </IpcExecuteRequestEvent.Command>
  <IpcExecuteRequestEvent.Item>
    <summary>
      A string representing the item name.
      There is no item in Windows. The access is provided for compatibility with other environments.
    </summary>
    <value>
      A string representing the item name.
      There is no item in Windows. The access is provided for compatibility with other environments.
    </value>
  </IpcExecuteRequestEvent.Item>
  <IpcExecuteRequestEvent.Topic>
    <summary>
      A string representing the topic name.
    </summary>
    <value>A string representing the topic name.</value>
  </IpcExecuteRequestEvent.Topic>
  <IpcServer>
    <summary>
      Register an application as a server able to access data on specific topics and update registered topics and update registered client applications.
    </summary>
    <remarks>
      In X#, the IPC... classes provides a means of implementing DDE conversations between DDE-compatible applications. DDE (Dynamic Data Exchange) is a type of interprocess communication (IPC) that uses shared memory to exchange data between applications. IPC is governed by a DDE management library, an underlying DLL in Windows.
      In such a conversation, there is a client and a server. The client requests data from the server about particular topics and items, and the server supplies the requested data. The applications, after requesting to be a client or server (or both), then exchange updates as soon as new data becomes available. These exchanges are not necessarily initiated by the user.
      Each IPC client must uniquely identify the server with which it wishes to communicate, and then request data updates. After the initial transfer, the client is informed of any changes to the transferred data in the server by means of an IpcDataUpdateEvent object.
    </remarks>
  </IpcServer>
  <IpcServer.ctor>
    <summary>
      Construct an IpcServer object.
    </summary>
    <param name="cServName">The name uniquely identifying the server, which the clients use.</param>
  </IpcServer.ctor>
  <IpcServer.AddTopic>
    <summary>
      Add a topic to the list of topics supported by the server.
    </summary>
    <param name="oIpcTopic">The IPC topic to add to the list supported by the server.</param>
    <remarks>
      This should be invoked once for every topic supported.
    </remarks>
  </IpcServer.AddTopic>
  <IpcServer.DataRequest>
    <summary>
      Called whenever a client makes a request for data or when the IpcServer:UpdateTopic() is called.
    </summary>
    <param name="oIpcDataRequestEvent">Stores the topic name and item name.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <returns>
      An object containing a pointer to the data and the length of the data string (it created as a global memory object by Windows DDE management library and it passes a data handle back to the application).
    </returns>
  </IpcServer.DataRequest>
  <IpcServer.DataUpdate>
    <summary>
      Called whenever a client calls IpcClient:ChangeData().
    </summary>
    <param name="oIpcDataUpdateEvent">Stores the topic name, item name, and the changed data as a string.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      When this method is called, the server should update itself. This functionality is provided by the developer in the overridden method, not by X#.
    </remarks>
  </IpcServer.DataUpdate>
  <IpcServer.Destroy>
    <summary>
      Provide a method to de-instantiate an IpcServer object.
    </summary>
    <remarks>
      This method can be used when an IpcServer object is no longer needed. IpcServer:Destroy() de-instantiates the IpcServer object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </IpcServer.Destroy>
  <IpcServer.Dispatch>
    <inheritdoc />
  </IpcServer.Dispatch>
  <IpcServer.ExecuteRequest>
    <summary>
      Called when the client calls IpcClient:Execute(). The server should take the appropriate action to execute the command locally.
    </summary>
    <param name="oIpcExecuteRequestEvent">Stores the topic name, item name, and the command name to be executed.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </IpcServer.ExecuteRequest>
  <IpcServer.idInst>
    <exclude />
  </IpcServer.idInst>
  <IpcServer.UpdateTopic>
    <summary>
      Request that the server update a particular topic and item.
    </summary>
    <param name="cTopic">The IPC topic to be updated.</param>
    <param name="cItem">The IPC item to be updated.</param>
    <remarks>
      This results in the invocation of IpcServer:DataRequest(). Then the clients associated with the topic and item pair are updated with the new value.
    </remarks>
  </IpcServer.UpdateTopic>
  <IpcTopic>
    <summary>
      Create topic (and items) to be supported by an IPC server and which IPC clients can request. These objects are used by IpcServer:AddTopic() and IpcClient:RequestData().
    </summary>
  </IpcTopic>
  <IpcTopic.ctor>
    <summary>
      Construct an IpcTopic object.
    </summary>
    <param name="cTopicString">The IPC topic to be created.</param>
  </IpcTopic.ctor>
  <IpcTopic.AddItem>
    <summary>
      Add an item to the list of items associated with the topic.
    </summary>
    <param name="cItemString">The IPC item to be added to the list of items associated with the topic.</param>
  </IpcTopic.AddItem>
  <IpcTopic.aItemList>
    <exclude />
  </IpcTopic.aItemList>
  <IpcTopic.cTopicName>
    <exclude />
  </IpcTopic.cTopicName>
  <IpcTopic.DeleteItem>
    <summary>
      Delete an item from the list of items associated with the topic.
    </summary>
    <param name="cItemString">The IPC item to be deleted.</param>
  </IpcTopic.DeleteItem>
  <IpcTopic.Destroy>
    <exclude />
  </IpcTopic.Destroy>
  <IpcTopicData>
    <summary>
      Create a global memory object and pass a data handle back to the application.
    </summary>
    <remarks>
      The IpcTopicData object contains a pointer to the data and the length of the data string (it is created as a global memory object by Windows DDE management library and it passes a data handle back to the application).
    </remarks>
  </IpcTopicData>
  <IpcTopicData.ctor>
    <summary>
      Construct an IpcTopicData object.
    </summary>
    <param name="ptrString">A pointer to the data string.</param>
    <param name="nLength">The number of characters to transfer. If not specified, the entire length of the data string is used.</param>
    <remarks>
      An IpcTopicData object is used for transferring data in response to a data request call on an IpcServer object.
    </remarks>
  </IpcTopicData.ctor>
  <IpcTopicData.Data>
    <exclude />
  </IpcTopicData.Data>
  <IpcTopicData.Destroy>
    <exclude />
  </IpcTopicData.Destroy>
  <IpcTopicData.Length>
    <exclude />
  </IpcTopicData.Length>
  <IpcTopicData.liLen>
    <exclude />
  </IpcTopicData.liLen>
  <IpcTopicData.ptrData>
    <exclude />
  </IpcTopicData.ptrData>
  <IReadCookie>
    <summary>
      Provide a class for retrieving the values of the cookies sent in an HTTP request.
    </summary>
    <remarks>
      The IReadCookie class enables you to retrieve the values of the cookies sent in an HTTP request.
    </remarks>
  </IReadCookie>
  <IReadCookie.ctor>
    <summary>
      Construct an IReadCookie object instance.
    </summary>
    <param name="pICookie">Pointer to an IReadCookie Interface object structure.</param>
    <param name="oIServer">The IServer object instance.</param>
    <remarks>
      An IReadCookie object instance can be created by the IRequest:GetCookies() method because it is directly associated with an HTTP request. Therefore, you do not have to create this object yourself. Rather, use it for an ASP Component application via the IScriptingContext:Request:GetCookies() method.
    </remarks>
    <example>
      See the IReadCookie:GetItem() example.
    </example>
  </IReadCookie.ctor>
  <IReadCookie.GetEnum>
    <summary>
      Retrieve the number of items from a cookie object.
    </summary>
    <returns>
      Number of cookie items (type INT), if successful; otherwise, 0.
    </returns>
    <remarks>
      This method retrieves the number of stored items for a cookie object.
    </remarks>
    <example>
      See the IReadCookie:GetItem() example.
    </example>
  </IReadCookie.GetEnum>
  <IReadCookie.GetHasKeys>
    <summary>
      Indicate whether or not a cookie object has keys.
    </summary>
    <returns>
      TRUE, if the current cookie has keys; otherwise, FALSE.
    </returns>
    <remarks>
      This method returns a logical value which indicates whether or not the cookie has keys.
    </remarks>
  </IReadCookie.GetHasKeys>
  <IReadCookie.GetItem>
    <summary>
      Retrieve the specified item from a cookie object.
    </summary>
    <param name="cItemName">The name of the variable (item) to to be retrieved.</param>
    <returns>
      A string value, if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      This method retrieves the specified item, <paramref name="cItemName" />, from the cookie object.
    </remarks>
    <example>
      The following sample displays the cookie collection of an appropriate request:
      <code language="X#">
        GLOBAL goASPComponent 	AS ASPComponent
        PROCEDURE InitProc() _INIT 3
        goASPComponent := ASPComponent{}
        CLASS ASPComponent INHERIT IScriptingContext
      </code><code language="X#">
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL oCookie	AS IReadCookie
        LOCAL aTemp	AS ARRAY
        LOCAL aRet	AS ARRAY
        LOCAL n,i		AS INT
        LOCAL cName	AS STRING
        LOCAL cRet	AS STRING
        oCookie := SELF:Request:GetCookies()
        IF oCookie == NULL_OBJECT
        n   := oCookie:GetEnum()
        aRet := ArrayCreate(n)
        FOR i := 1 TO n
        aTemp := ArrayCreate(2)
        cName := oCookie:GetName(i)
        aTemp[1] := cName
        aTemp[2] := oCookie:GetItem(cName)
        aRet[i] := aTemp
        NEXT
        ENDIF
      </code><code language="X#">
        cRet := GetHTTPValueTable(aTemp)
        RETURN SELF:Response:_Write(cRet)
      </code>
    </example>
  </IReadCookie.GetItem>
  <IReadCookie.GetName>
    <summary>
      Retrieve the name of the specified item from a cookie object.
    </summary>
    <param name="nItem">The number (position) of the item within the cookie item collection.</param>
    <returns>
      Item name (type STRING), if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      This method retrieves the name of the specified item, <paramref name="nItem" />, from the cookie object.
    </remarks>
    <example>
      See the IReadCookie:GetItem() example.
    </example>
  </IReadCookie.GetName>
  <IRequest>
    <summary>
      Class to retrieve the values that the client browser passed to the server during an HTTP request.
    </summary>
    <remarks>
      The IRequest class retrieves the values that the client browser passed to the server during an HTTP request. The variables are internally stored by collections in the following order:
      1.	QueryString
      2.	Form
      3.	Cookies
      4.	ClientCertificate
      5.	ServerVariables
      The IRequest class provides the following kinds of methods:
      Methods to retrieve these collections as arrays containing value {name, value} pairs for each collection (e.g., GetForms()).
      Methods to retrieve a certain value of one of these collections (e.g., GetForm("firstname")).
      Methods to retrieve the value without the knowledge about to what collection it belongs (e.g., GetItem("firstname")).
    </remarks>
  </IRequest>
  <IRequest.ctor>
    <summary>
      Construct an IRequest object instance.
    </summary>
    <param name="oIScrContext">An IScriptingContext object.</param>
    <param name="pIRequest">Pointer to an IRequest Interface object structure.</param>
    <remarks>
      An IRequest object instance is automatically created by the IScriptingContext:OnStartPage() method when the appropriate .ASP file is loaded by the Internet Information Server (IIS). Therefore, you do not have to create this object yourself. Rather, use it for an ASP Component application via the IScriptingContext:Request property.
    </remarks>
  </IRequest.ctor>
  <IRequest.GetClientCertificate>
    <summary>
      Retrieve a value of the client certificate collection of an IRequest object.
    </summary>
    <param name="cVarName">Name of the certificate field.</param>
    <param name="n">
      Position, if more than one variable with the same name, <paramref name="cVarName" />, exists within the collection.
    </param>
    <returns>
      A string value, if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      The GetClientCertificate() method retrieves a certification field (specified in the X.509 standard) from the request issued by the Web browser. If a Web browser uses the SSL3.0/PCT1 protocol (i.e., URL starts with "https://" instead of "http://") to connect to a server and the server requests certification, the browser sends the certification field. If no certificate is sent, the collection array is empty and the return value is NULL_STRING.
    </remarks>
  </IRequest.GetClientCertificate>
  <IRequest.GetClientCertificates>
    <summary>
      Retrieve the certification fields as a two-dimensional array.
    </summary>
    <returns>
      Two-dimensional array with name-value pairs, if successful; otherwise, an empty array.
    </returns>
    <remarks>
      The GetClientCertificates() method retrieves all certification fields (specified in the X.509 standard) as a two-dimensional array. If a Web browser uses the SSL3.0/PCT1 protocol (i.e., URL starts with "https://" instead of "http://") to connect to a server and the server requests certification, the browser sends the certification fields. If no certificate is sent, the collection array is empty.
    </remarks>
  </IRequest.GetClientCertificates>
  <IRequest.GetCookies>
    <summary>
      Retrieve the cookie collection of an IRequest object.
    </summary>
    <returns>
      The IReadCookie object instance.
    </returns>
    <remarks>
      This method retrieves an IReadCookie object instance of the IRequest object.
    </remarks>
    <example>
      The following example demonstrates the use of this method:
      <code language="X#">
        GLOBAL goASPComponent 	AS ASPComponent
        PROCEDURE InitProc() _INIT 3
        goASPComponent := ASPComponent{}
        CLASS ASPComponent INHERIT IScriptingContext
      </code><code language="X#">
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL oCookie	AS IReadCookie
        LOCAL aTemp	AS ARRAY
        LOCAL aRet	AS ARRAY
        LOCAL n,i		AS INT
        LOCAL cName	AS STRING
        LOCAL cRet	AS STRING
        oCookie := SELF:Request:GetCookies()
        IF oCookie == NULL_OBJECT
        ELSE
        n   := oCookie:GetEnum()
        aRet := ArrayCreate(n)
        FOR i := 1 UPTO n
        aTemp := ArrayCreate(2)
        cName := oCookie:GetName(i)
        aTemp[1] := cName
        aTemp[2] := oCookie:GetItem(cName)
        aRet[i] := aTemp
        NEXT
        ENDIF
      </code><code language="X#">
        cRet := GetHTTPValueTable(aTemp)
        RETURN SELF:Response:_Write(cRet)
      </code>
      ASP code:
      <code language="X#">
        &lt;%
        Response.Cookies("mycookie")("value1") = "Hello"
        Response.Cookies("mycookie")("value2") = "World"
        Response.Cookies("value1") = "X#"
        Response.Cookies("value2") = "rules"
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
      The result would be:

    </example>
  </IRequest.GetCookies>
  <IRequest.GetForm>
    <summary>
      Retrieve a form value of an IRequest object.
    </summary>
    <param name="cVarName">Name of the form field.</param>
    <param name="n">
      Position, if more than one variable with the same name, <paramref name="cVarName" />, exists within the collection.
    </param>
    <returns>
      A string value, if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      The GetForm() method retrieves a form value posted to the HTTP request body by a form using the POST method. If no form value is sent, the collection array is empty and the return value is NULL_STRING.
    </remarks>
    <example>
      The following example demonstrates the use of this method:
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent
        PROCEDURE InitProc() _INIT 3
        goASPComponent := ASPComponent{}
        CLASS ASPComponent INHERIT IScriptingContext
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL cRet AS STRING
        cRet := SELF:Request:GetForm("Value1")
        RETURN SELF:Response:_Write("Value1=" + cRet)
      </code>
      HTML code:
      <code language="X#">
        &lt;form action="response.asp?Action=FORM" method="post"&gt;
        &lt;p&gt;Value1: &lt;input type="text" name="Value1" size="4"&gt;&lt;/p&gt;
        &lt;p&gt;&lt;input type="submit" value="Execute POST Request"&gt; &lt;/p&gt;
        &lt;/form&gt;
      </code>
      ASP code (response.asp):
      <code language="X#">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IRequest.GetForm>
  <IRequest.GetForms>
    <summary>
      Retrieve all form values of an IRequest object.
    </summary>
    <returns>
      Two-dimensional array with name-value pairs, if successful; otherwise, an empty array.
    </returns>
    <remarks>
      The GetForms() method retrieves all values posted to the HTTP request body by a form (via POST method) as a two-dimensional array. If no form values are sent, the collection array is empty.
    </remarks>
    <example>
      The following example demonstrates the use of this method:
      <code language="X#">
        GLOBAL goASPComponent 	AS ASPComponent
        PROCEDURE InitProc() _INIT 3
        goASPComponent := ASPComponent{}
        CLASS ASPComponent INHERIT IScriptingContext
      </code><code language="X#">
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL aTemp   AS ARRAY
        LOCAL cRet   AS STRING

        aTemp := SELF:Request:GetForms()
        cRet := GetHTTPValueTable(aTemp)
        RETURN SELF:Response:_Write(cRet)
      </code>
      HTML code:
      <code language="X#">
        &lt;form action="response.asp?Action=FORM" method="post"&gt;
        &lt;p&gt;Value1: &lt;input type="text" name="Value1" size="4"&gt;&lt;/p&gt;
        &lt;p&gt;Value2: &lt;input type="text" name="Value2" size="5"&gt;&lt;/p&gt;
        &lt;p&gt;Value2: &lt;input type="text" name="Value2" size="5"&gt;&lt;/p&gt;
        &lt;p&gt;&lt;input type="submit" value="Execute POST Request"&gt; &lt;/p&gt;
        &lt;/form&gt;
      </code>
      ASP code (response.asp):
      <code language="X#">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IRequest.GetForms>
  <IRequest.GetItem>
    <summary>
      Retrieve any value of the HTTP request body.
    </summary>
    <param name="cVarName">Name of the variable.</param>
    <returns>
      A string value, if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      This method returns a value posted to the HTTP request body. The collections are searched in the following order: QueryString, Form, Cookies, ClientCertificate, ServerVariables.
    </remarks>
    <example>
      The following example demonstrates the use of this method:
      <code language="X#">
        GLOBAL goASPComponent 	AS ASPComponent
        PROCEDURE InitProc() _INIT 3
        goASPComponent := ASPComponent{}
        CLASS ASPComponent INHERIT IScriptingContext
      </code><code language="X#">
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL cRet   AS STRING
        cRet := SELF:Request:GetItem("Value1")
        RETURN SELF:Response:_Write("Value1=" + cRet)
      </code>
      HTML code:
      <code language="X#">
        &lt;form action="response.asp?Action=FORM" method="post"&gt;
        &lt;p&gt;Value1: &lt;input type="text" name="Value1" size="4"&gt;&lt;/p&gt;
        &lt;p&gt;&lt;input type="submit" value="Execute POST Request"&gt; &lt;/p&gt;
        &lt;/form&gt;
      </code>
      ASP code (response.asp):
      <code language="X#">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IRequest.GetItem>
  <IRequest.GetQueryString>
    <summary>
      Retrieve a value of the HTTP request's query string.
    </summary>
    <param name="cVarName">Name of the variable.</param>
    <param name="n">
      Position, if more than one variable with the same name, <paramref name="cVarName" />, exists within the collection.
    </param>
    <returns>
      A string value, if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      The GetQueryString() method retrieves a value of the variables in the HTTP query string (i.e., the values encoded after the question mark (?) in an HTTP request).
    </remarks>
    <example>
      The following example demonstrates the use of this method:
      <code language="X#">
        GLOBAL goASPComponent 	AS ASPComponent
        PROCEDURE InitProc() _INIT 3
        goASPComponent := ASPComponent{}
        CLASS ASPComponent INHERIT IScriptingContext
      </code><code language="X#">
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL cRet   AS STRING
        cRet := SELF:Request:GetQueryString("Action")
        RETURN SELF:Response:_Write("Action=" + cRet)
      </code>
      HTML code:
      <code language="X#">
        &lt;html&gt;
        &lt;p&gt;
        &lt;a href="response.asp?Action=TEST&amp;Display=Yes"&gt;
        Start
        &lt;/a&gt;&lt;/p&gt;
        ...
        &lt;/html&gt;
      </code>
      ASP code (response.asp):
      <code language="X#">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IRequest.GetQueryString>
  <IRequest.GetQueryStrings>
    <summary>
      Retrieve all values of the variables in the HTTP query string.
    </summary>
    <returns>
      Two-dimensional array with name-value pairs, if successful; otherwise, an empty array.
    </returns>
    <remarks>
      The GetQueryStrings() method retrieves all values of the variables in the HTTP query string (i.e., the values encoded after the question mark (?) via GET method) as a two-dimensional array. If no values are sent, the array is empty.
    </remarks>
    <example>
      The following example demonstrates the use of this method:
      <code language="X#">
        GLOBAL goASPComponent 	AS ASPComponent
        PROCEDURE InitProc() _INIT 3
        goASPComponent := ASPComponent{}
        CLASS ASPComponent INHERIT IScriptingContext
      </code><code language="X#">
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL aTemp   AS ARRAY
        LOCAL cRet   AS STRING

        aTemp := SELF:Request:GetQueryStrings()
        cRet := GetHTTPValueTable(aTemp)
        RETURN SELF:Response:_Write(cRet)
      </code>
      HTML code:
      <code language="X#">
        &lt;html&gt;
        &lt;p&gt;
        &lt;a href="response.asp?Action=TEST&amp;Display=Yes"&gt;
        Start
        &lt;/a&gt;&lt;/p&gt;
        ...
        &lt;/html&gt;
      </code>
      ASP code (response.asp):
      <code language="X#">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IRequest.GetQueryStrings>
  <IRequest.GetServerVariable>
    <summary>
      Retrieve a value from the environment variables collection of an IRequest object.
    </summary>
    <param name="cVarName">
      The name of the environment variable.
      Valid names are:
    </param>
    <param name="AUTH_TYPE">REMOTE_HOST</param>
    <param name="CONTENT_LENGTH">REQUEST_METHOD</param>
    <param name="CONTENT_TYPE">SCRIPT_MAP</param>
    <param name="GATEWAY_INTERFACE">SCRIPT_NAME</param>
    <param name="HTTP_HeaderName">SERVER_NAME</param>
    <param name="LOGON_USER">SERVER_PORT</param>
    <param name="PATH_INFO">SERVER_PORT_SECURE</param>
    <param name="PATH_TRANSLATED">SERVER_PROTOCOL</param>
    <param name="QUERY_STRING">SERVER_SOFTWARE</param>
    <param name="REMOTE_ADDR">URL</param>
    <returns>
      Value of type STRING, if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      The GetServerVariable() method retrieves a value from the environment variables collection of the IRequest object.
    </remarks>
    <example>
      The following example demonstrates the use of this method:
      <code language="X#">
        GLOBAL goASPComponent 	AS ASPComponent
        PROCEDURE InitProc() _INIT 3
        goASPComponent := ASPComponent{}
        CLASS ASPComponent INHERIT IScriptingContext
      </code><code language="X#">
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL cRet   AS STRING
        cRet := ;
        SELF:Request:GetServerVariable("PATH_TRANSLATED")
        RETURN SELF:Response:_Write("Path name: " + cRet)
      </code>
      HTML code:
      <code language="X#">
        &lt;html&gt;
        &lt;p&gt;
        &lt;a href="response.asp"&gt;
        Display Path
        &lt;/a&gt;&lt;/p&gt;
        ...
        &lt;/html&gt;
      </code>
      ASP code (response.asp):
      <code language="X#">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IRequest.GetServerVariable>
  <IRequest.GetServerVariables>
    <summary>
      Retrieve all environment variables of an IRequest object.
    </summary>
    <returns>
      Two-dimensional array with name-value pairs, if successful; otherwise, an empty array.
    </returns>
    <remarks>
      The GetServerVariables() method retrieves all values of the server's environment as a two-dimensional array.
    </remarks>
    <example>
      The following example demonstrates the use of this method:
      <code language="X#">
        GLOBAL goASPComponent 	AS ASPComponent
        PROCEDURE InitProc() _INIT 3
        goASPComponent := ASPComponent{}
        CLASS ASPComponent INHERIT IScriptingContext
      </code><code language="X#">
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL aTemp   AS ARRAY
        LOCAL cRet   AS STRING

        aTemp := SELF:Request:GetServerVariables()
        cRet := GetHTTPValueTable(aTemp)
        RETURN SELF:Response:_Write(cRet)
      </code>
      HTML code:
      <code language="X#">
        &lt;html&gt;
        &lt;p&gt;
        &lt;a href="response.asp"&gt;
        Display Server Environment
        &lt;/a&gt;&lt;/p&gt;
        ...
        &lt;/html&gt;
      </code>
      ASP code (response.asp):
      <code language="X#">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IRequest.GetServerVariables>
  <IResponse>
    <summary>
      Send output to the client.
    </summary>
    <remarks>
      The IResponse class is used to send output to the client.
    </remarks>
  </IResponse>
  <IResponse.ctor>
    <summary>
      Construct an IResponse object instance.
    </summary>
    <param name="oIScrContext">An IScriptingContext object.</param>
    <param name="pIRequest">Pointer to an IResponse Interface object structure.</param>
    <remarks>
      An IResponse object instance is automatically created by the IScriptingContext:OnStartPage() method when the appropriate .ASP file is loaded by the Internet Information Server (IIS). Therefore, you do not have to create this object yourself. Rather, use it for an ASP Component application via the IScriptingContext:Request property.
    </remarks>
  </IResponse.ctor>
  <IResponse._AddHeader>
    <summary>
      Add an HTML header to an HTTP response.
    </summary>
    <param name="cHeaderName">String containing the name of the HTTP header.</param>
    <param name="cHeader">String containing the HTTP header.</param>
    <returns>
      TRUE, if the value has been added; otherwise, FALSE.
    </returns>
    <remarks>
      This method adds an HTML header to the HTTP response.
    </remarks>
  </IResponse._AddHeader>
  <IResponse._AppendToLog>
    <summary>
      Add a string to the end of the Web server log entry for the current request.
    </summary>
    <param name="cMessage">String to append to the log entry.</param>
    <returns>
      TRUE, if the value has been appended; otherwise, FALSE.
    </returns>
    <remarks>
      This method appends a string to the end of the Web server log entry for the current request. The log entry can contain a maximum of 80 bytes.
    </remarks>
  </IResponse._AppendToLog>
  <IResponse._Clear>
    <summary>
      Erase any buffered HTML output of the current response.
    </summary>
    <returns>
      TRUE, if the value has been changed; otherwise, FALSE.
    </returns>
    <remarks>
      This method erases any buffered HTML output of the current response.
    </remarks>
  </IResponse._Clear>
  <IResponse._End>
    <summary>
      Cause the server to stop processing the script and to return the current response.
    </summary>
    <returns>
      TRUE, if the value has been changed; otherwise, FALSE.
    </returns>
    <remarks>
      This method causes the server to stop processing the script and to return the current response.
    </remarks>
  </IResponse._End>
  <IResponse._Flush>
    <summary>
      Send buffered output immediately.
    </summary>
    <returns>
      TRUE, if the value has been changed; otherwise, FALSE.
    </returns>
    <remarks>
      This method sends buffered output immediately to the client.
    </remarks>
  </IResponse._Flush>
  <IResponse._Redirect>
    <summary>
      Cause the browser to attempt to connect to a different URL.
    </summary>
    <param name="cNewURL">A new URL value as STRING.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method stops the server from processing the current script and then causes the browser to attempt to connect to <paramref name="cNewURL" />.
    </remarks>
  </IResponse._Redirect>
  <IResponse._Write>
    <summary>
      Write a specified string the HTTP output.
    </summary>
    <param name="cOut">String containing the HTTP output.</param>
    <param name="nSize">
      Number of bytes to write. If omitted, defaults to the length of <paramref name="cOut" />.
    </param>
    <returns>
      TRUE, if the value has been changed; otherwise, FALSE.
    </returns>
    <remarks>
      This method writes data to the HTTP output.
    </remarks>
  </IResponse._Write>
  <IResponse.GetBuffer>
    <summary>
      Retrieve the current value of the Buffer flag property of an IResponse object.
    </summary>
    <returns>
      TRUE, if the value of the current HTTP output is buffered; otherwise, FALSE.
    </returns>
    <remarks>
      This method retrieves the current value of the Buffer flag property of the IResponse object.
    </remarks>
  </IResponse.GetBuffer>
  <IResponse.GetContentType>
    <summary>
      Retrieve the current value of the ContentType property of an IResponse object.
    </summary>
    <returns>
      The content type of the IResponse object as STRING, if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      This method retrieves the current value of the ContentType property of the IResponse object.
    </remarks>
  </IResponse.GetContentType>
  <IResponse.GetCookies>
    <summary>
      Retrieve the cookie collection of an IResponse object.
    </summary>
    <returns>
      An IWriteCookie object instance.
    </returns>
    <remarks>
      This method retrieves the write-only cookie collection as an IWriteCookie object instance of the IResponse object.
    </remarks>
  </IResponse.GetCookies>
  <IResponse.GetExpires>
    <summary>
      Retrieve the current value of the Expires property of an IResponse object.
    </summary>
    <returns>
      The expires value of the IResponse object in minutes (type LONG).
    </returns>
    <remarks>
      This method retrieves the current value of the Expires property of the IResponse object. This property specifies the length of time before a page cached on a browser expires. If the user returns to the same page before it expires, the cached version is displayed.
    </remarks>
  </IResponse.GetExpires>
  <IResponse.GetExpiresAbsolute>
    <summary>
      Retrieve the current value of the ExpiresAbsolute property of an IResponse object.
    </summary>
    <returns>
      The expires value of the IResponse object as a DATE value.
    </returns>
    <remarks>
      This method retrieves the current value of the ExpiresAbsolute property of the IResponse object. This property specifies the date at which a page cached on a browser expires. If the user returns to the same page before that date and time, the cached version is displayed. If a time is not specified, the page expires at midnight of that day. If a date is not specified, the page expires at the given time on the day that the script is run.
    </remarks>
  </IResponse.GetExpiresAbsolute>
  <IResponse.GetStatus>
    <summary>
      Retrieve the current value of the Status property of an IResponse object.
    </summary>
    <returns>
      The current value of the Status property as STRING.
    </returns>
    <remarks>
      This method retrieves the current value of the Status property of the IResponse object. The status specifies the value of the status line returned by the server. Status values are defined in the HTTP specification.
    </remarks>
  </IResponse.GetStatus>
  <IResponse.PutBuffer>
    <summary>
      Set the current value of the Buffer flag property of an IResponse object.
    </summary>
    <param name="lNew">New value of the Buffer flag property.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method sets the value of the Buffer flag property of the IResponse object.
    </remarks>
  </IResponse.PutBuffer>
  <IResponse.PutContentType>
    <summary>
      Set the current value of the ContentType property of an IResponse object.
    </summary>
    <param name="cType">The general content category.</param>
    <param name="cSubType">A specific content type.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method sets the value of the ContentType property of the IResponse object as a string describing the content type. This string is usually formatted, type/subtype where type is the general content category and subtype is the specific content type. For a full list of supported content types, see your Web browser documentation or the current HTTP specification.
    </remarks>
    <example>
      The following example demonstrates the use of this method:
      <code language="X#">
        GLOBAL goASPComponent 	AS ASPComponent
        PROCEDURE InitProc() _INIT 3
        goASPComponent := ASPComponent{}
        CLASS ASPComponent INHERIT IScriptingContext
      </code><code language="X#">
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL aTemp   AS ARRAY
        LOCAL cRet   AS STRING
        ...
        SELF:Response:PutContentType(/gif
        SELF:Response:PutContentType(text/html
      </code><code language="X#">	RETURN SELF:Response:_Write("Hello world")</code>
    </example>
  </IResponse.PutContentType>
  <IResponse.PutExpires>
    <summary>
      Set the current value of the Expires property of an IResponse object.
    </summary>
    <param name="nMinutes">New expires value expressed in minutes.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method sets the current value of the Expires property of the IResponse object. This property specifies the length of time before a page cached on a browser expires. If the user returns to the same page before it expires, the cached version is displayed.
    </remarks>
  </IResponse.PutExpires>
  <IResponse.PutExpiresAbsolute>
    <summary>
      Set the current value of the Expires property of an IResponse object.
    </summary>
    <param name="dNew">New expires value as DATE.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method sets the new value for the ExpiresAbsolute property of the IResponse object. This property specifies the date at which a page cached on a browser expires. If the user returns to the same page before that date, the cached version is displayed. If a time is not specified, the page expires at midnight of that day. If a date is not specified, the page expires at the given time on the day that the script is run.
    </remarks>
  </IResponse.PutExpiresAbsolute>
  <IResponse.PutStatus>
    <summary>
      Set a new value for the Status property of an IResponse object.
    </summary>
    <param name="cNew">New status value as STRING.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method sets a new value to the Status property of the IResponse object. The status specifies the value of the status line returned by the server. Status values are defined in the HTTP specification.
    </remarks>
  </IResponse.PutStatus>
  <IScriptingContext>
    <summary>
      Retrieve the Active Server Pages (ASP) built-in objects.
    </summary>
    <remarks>
      This class exposes methods that your component can use to retrieve the Active Server Pages (ASP) built-in objects.
    </remarks>
  </IScriptingContext>
  <IScriptingContext.ctor>
    <summary>
      Construct an IScriptingContext object instance.
    </summary>
  </IScriptingContext.ctor>
  <IScriptingContext.Application>
    <summary>
      An IApplicationObject object instance.
    </summary>
    <value>An IApplicationObject object instance.</value>
  </IScriptingContext.Application>
  <IScriptingContext.ASPApp>
    <summary>
      An ASPAppAbstract object instance.
    </summary>
    <value>An ASPAppAbstract object instance.</value>
  </IScriptingContext.ASPApp>
  <IScriptingContext.GetApplication>
    <summary>
      Retrieve the build in an IApplicationObject instance.
    </summary>
    <returns>
      An IApplicationObject instance, if successful; otherwise, NULL_OBJECT.
    </returns>
    <remarks>
      The GetApplication() method creates a new IApplicationObject instance based on the build in the IApplicationObject interface pointer. This method is called internally by the OnStartPage() method when the appropriate ASP script file is loaded by the Internet Information Server. You can access the created instance, <paramref name="oIAppObj" />, by means of the Application property.
    </remarks>
  </IScriptingContext.GetApplication>
  <IScriptingContext.GetRequest>
    <summary>
      Retrieve the build in an IRequest instance.
    </summary>
    <returns>
      An IRequest instance, if successful; otherwise, NULL_OBJECT.
    </returns>
    <remarks>
      This method creates a new IRequest instance based on the build in the IRequest interface pointer. The method is called internally by the OnStartPage() method when the appropriate ASP script file is loaded by the Internet Information Server. You can access the created instance, <paramref name="oIRequest" />, by means of the Request property.
    </remarks>
  </IScriptingContext.GetRequest>
  <IScriptingContext.GetResponse>
    <summary>
      Retrieve the build in an IResponse object instance.
    </summary>
    <returns>
      An IResponse instance, if successful; otherwise, NULL_OBJECT.
    </returns>
    <remarks>
      This method creates a new IResponse instance based on the build in the IResponse interface pointer. The method is called internally by the OnStartPage() method when the appropriate ASP script file is loaded by the Internet Information Server. You can access the created instance, <paramref name="oIResponse" />, by means of the Response property.
    </remarks>
  </IScriptingContext.GetResponse>
  <IScriptingContext.GetServer>
    <summary>
      Retrieve the build in an IServer object instance.
    </summary>
    <returns>
      An IServer instance, if successful; otherwise, NULL_OBJECT.
    </returns>
    <remarks>
      This method creates a new IServer instance based on the build in the IServer interface pointer. The method is called internally by the OnStartPage() method when the appropriate ASP script file is loaded by the Internet Information Server. You can access the created instance, <paramref name="oIServer" />, by means of the Server property.
    </remarks>
  </IScriptingContext.GetServer>
  <IScriptingContext.GetSession>
    <summary>
      Retrieve the build in an ISessionObject instance.
    </summary>
    <returns>
      An ISessionObject instance, if successful; otherwise, NULL_OBJECT.
    </returns>
    <remarks>
      This method creates a new ISessionObject instance based on the build in the ISessionObject interface pointer. The method is called internally by the OnStartPage() method when the appropriate ASP script file is loaded by the Internet Information Server. You can access the created instance, <paramref name="oISessionObject" />, by means of the Session property.
    </remarks>
  </IScriptingContext.GetSession>
  <IScriptingContext.GetVariantString>
    <summary>
      Helper method to convert a VARIANT string to a X# string.
    </summary>
    <param name="pString">Pointer to an IDispatch object.</param>
    <returns>
      A converted X# STRING, if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      This method converts a VARIANT to a dynamic X# string value. This method can be used to implement ASSIGN methods with STRING arguments.
    </remarks>
    <example>
      The following sample is a typical implementation of the STRING property, Action, for an ASP Component:
      <code language="X#">
        CLASS ASPComponent INHERIT IScriptingContext
        PROTECT cAction AS STRING
      </code><code language="X#">
        ASSIGN Action(cNew) CLASS ASPComponent
        SELF:cAction := SELF:GetVariantString(cNew)
        RETURN SELF:cAction
        ACCESS Action CLASS ASPComponent
        RETURN SELF:cAction
      </code>
    </example>
  </IScriptingContext.GetVariantString>
  <IScriptingContext.HTTPErrorMessage>
    <summary>
      Create HTML code to display all values of a X# Error object.
    </summary>
    <param name="oError">The current Error object instance.</param>
    <returns>
      String containing HTML code for displaying the error within an Internet browser.
    </returns>
    <remarks>
      This method creates HTML code based on the values of a X# Error object, and will be automatically invoked if a runtime error occurs. If you want to modify the default error message design, just overload this method.
    </remarks>
    <example>
      The following sample demonstrates how to overload the default error handling method to create a customized HTML output:
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent
        PROCEDURE InitProc() _INIT 3
        goASPComponent := ASPComponent{}
        CLASS ASPComponent INHERIT IScriptingContext
        METHOD HTTPErrorMessage(oError) CLASS ASPComponent
        LOCAL cRet AS STRING
        IF IsObject(oError)
        cRet := SUPER:HTTPErrorMessage(oError)
        ENDIF
        RETURN cRet
        METHOD HTTPGoBackLink (cCaption) CLASS ASPComponent
        LOCAL cRef AS STRING
        LOCAL cRet AS STRING
        IF !IsString(cCaption)
        cCaption := "Back"
        ENDIF
        cRef := ;
        SELF:oRequest:GetServerVariable("HTTP_REFERER")
        cRet += '&lt;p&gt;&lt;a href="'
        cRet += cRef + '"&gt;'
        cRet += cCaption
        cRet += '&lt;/a&gt;&lt;/p&gt;'
        RETURN cRet
      </code>
    </example>
  </IScriptingContext.HTTPErrorMessage>
  <IScriptingContext.HTTPQueryString>
    <summary>
      Create HTML code to display all query string items.
    </summary>
    <returns>
      String containing HTML code for displaying all items of the query string.
    </returns>
    <remarks>
      The HTTPRequestItems() method creates HTML code to display all query string items.
    </remarks>
    <example>
      The following source code can be used to create an ASP component for displaying the query string items:
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent
        PROCEDURE InitProc() _INIT 3
        goASPComponent := ASPComponent{}
        CLASS ASPComponent INHERIT IScriptingContext
      </code><code language="X#">
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL cRet	AS STRING
        cRet := SELF:HTTPQueryString()
        RETURN SELF:Response:_Write(cRet)
      </code>
      ASP code:
      <code language="X#">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IScriptingContext.HTTPQueryString>
  <IScriptingContext.HTTPServerVariables>
    <summary>
      Create HTML code to display all environment variables of an Internet server.
    </summary>
    <returns>
      String containing HTML code to display all environment variables.
    </returns>
    <remarks>
      The HTTPServerVariables() method creates HTML code to display all environment variables of the Internet server.
    </remarks>
    <example>
      The following source code can be used to create an ASP component for displaying the server environment:
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent
        PROCEDURE InitProc() _INIT 3
        goASPComponent := ASPComponent{}
        CLASS ASPComponent INHERIT IScriptingContext
      </code><code language="X#">
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL cRet	AS STRING
        cRet := SELF:HTTPServerVariables()
        RETURN SELF:Response:_Write(cRet)
      </code>
      ASP code:
      <code language="X#">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IScriptingContext.HTTPServerVariables>
  <IScriptingContext.OnEndPage>
    <summary>
      Clean up (exit) method for ASP components.
    </summary>
    <remarks>
      When the server finishes processing the script on an ASP page, it calls the OnEndPage() method for all components that have implemented OnEndPage(). The server calls this method after processing the script on that page.
      <note type="tip">If you want to overload this method for your own de-initialization operation, call the SUPER method first.</note>
    </remarks>
  </IScriptingContext.OnEndPage>
  <IScriptingContext.OnStartPage>
    <summary>
      Entry point for ASP components.
    </summary>
    <param name="pDispatch">Pointer to an IDispatch Interface object.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      When a user requests a Web page in an ASP-based application, the server calls the OnStartPage() method for all components on that page (except those with application scope). This method creates object instances for following built-in interfaces:
      ISessionObject
      IApplicationObject
      IRequest
      IResponse
      IServer
      <note type="tip">If you want to overload this method for your own initialization operation, call the SUPER method first.</note>
    </remarks>
    <example>
      The following source code shows how to overload OnStartPage() for your own purposes:
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent
        PROCEDURE InitProc() _INIT 3
        goASPComponent := ASPComponent{}
        CLASS ASPComponent INHERIT IscriptingContext
        LOCAL p AS PTR
      </code><code language="X#">
        METHOD	OnStartPage(pDispatch)	CLASS ASPComponent
        IF SUPER:OnStartPage(pDispatch)
        SELF:p := MemAlloc(100)
        ENDIF
        METHOD	OnEndPage()		CLASS ASPComponent
        SUPER:OnEndPage()
        IF SELF:p != NULL_PTR
        MemFree(SELF:p)
        SELF:p := NULL_PTR
        ENDIF
      </code>
      ASP code:
      <code language="X#">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </IScriptingContext.OnStartPage>
  <IScriptingContext.Request>
    <summary>
      An IRequest object instance.
    </summary>
    <value>An IRequest object instance.</value>
  </IScriptingContext.Request>
  <IScriptingContext.Response>
    <summary>
      An IResponse object instance.
    </summary>
    <value>An IResponse object instance.</value>
  </IScriptingContext.Response>
  <IScriptingContext.Server>
    <summary>
      An IServer object instance.
    </summary>
    <value>An IServer object instance.</value>
  </IScriptingContext.Server>
  <IScriptingContext.Session>
    <summary>
      An ISession object instance.
    </summary>
    <value>An ISession object instance.</value>
  </IScriptingContext.Session>
  <IScriptingContext.WriteImage>
    <summary>
      Create HTML code to display images for ASP components.
    </summary>
    <param name="cFile">Image file name, including drive letter and path.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      WriteImage() creates HTML code for displaying images in ASP components.
    </remarks>
  </IScriptingContext.WriteImage>
  <IServer>
    <summary>
      Provide utility methods on the server.
    </summary>
    <remarks>
      The IServer class provides methods on the server that serve as utility functions.
    </remarks>
  </IServer>
  <IServer.ctor>
    <summary>
      Construct an IServer object instance.
    </summary>
    <param name="oIScrContext">An IScriptingContext object.</param>
    <param name="pIServer">Pointer to an IServer Interface object structure.</param>
    <remarks>
      An IServer object instance is automatically created by the IScriptingContext:OnStartPage() method when the appropriate .ASP file is loaded by an Internet Information Server (IIS). Therefore, you do not have to create this object yourself. Rather, use it for an ASP Component application via the IScriptingContext:Server property.
    </remarks>
  </IServer.ctor>
  <IServer._HTMLEncode>
    <summary>
      Apply HTML encoding to a specified string.
    </summary>
    <param name="cHTML">The HTML string to be encoded.</param>
    <returns>
      An encoded HTML text as STRING, if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      This method applies HTML encoding to the specified string, <paramref name="cHTML" />.
    </remarks>
    <example>
      The following call to method _HTMLEncode()
      <code language="X#">
        CLASS ASPComponent INHERIT IScriptingContext
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL cEncode	AS STRING
        ...
        cEncode := SELF:Server:_HTMLEncode("&lt;/html&gt;")
        ...
      </code>
      produces the output (cEncode):
      <code language="X#">&amp;lt;/html&amp;gt;</code>
    </example>
  </IServer._HTMLEncode>
  <IServer._MapPath>
    <summary>
      Map the specified relative or virtual path to the corresponding physical directory on the server.
    </summary>
    <param name="cPath">The alias name of the path.</param>
    <returns>
      The full specified path including drive letter, if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      The _MapPath() method maps the specified relative or virtual path, <paramref name="cPath" />, to the corresponding physical directory on the server. If <paramref name="cPath" /> starts with either a forward (/) or backward (\) slash, this method returns a path as if <paramref name="cPath" /> is a full virtual path. If <paramref name="cPath" /> does not start with a slash, _MapPath() returns a path relative to the directory of the .ASP file being processed.
    </remarks>
    <example>
      The following call to method _MapPath(),
      <code language="X#">
        CLASS ASPComponent INHERIT IScriptingContext
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL cPath	AS STRING
        ...
        cPath := SELF:Server:_MapPath("/cgi-bin")
        ...
      </code>
      produces the output (cPath):
      <code language="X#">c:\inetsrv\scripts</code>
      However, the call to
      <code language="X#">cPath := SELF:Server:_MapPath("test")</code>
      produces the output (cPath):
      <code language="X#">c:\inetsrv\wwwroot\vosample\test</code>
    </example>
  </IServer._MapPath>
  <IServer._URLEncode>
    <summary>
      Apply URL encoding to a specified string.
    </summary>
    <param name="cURL">The URL string to be encoded.</param>
    <returns>
      The encoded URL text as STRING, if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      This method applies URL encoding to the specified string, <paramref name="cURL" />.
    </remarks>
    <example>
      The following call to method _URLEncode(),
      <code language="X#">
        CLASS ASPComponent INHERIT IScriptingContext
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL cEncode	AS STRING
        ...
        cEncode := SELF:Server:_URLEncode( ;
        "X#")
        ...
      </code>
      produces the output (cEncode):
      <code language="X#">Visual+Objects</code>
    </example>
  </IServer._URLEncode>
  <IServer.GetScriptTimeOut>
    <summary>
      Retrieve the script time-out value of an IServer object.
    </summary>
    <returns>
      Timeout value in minutes (type LONG), if successful; otherwise,0.
    </returns>
    <remarks>
      This method retrieves the script time-out value of the IServer object in seconds.
    </remarks>
  </IServer.GetScriptTimeOut>
  <IServer.PutScriptTimeOut>
    <summary>
      Set the script time-out value of an IServer object.
    </summary>
    <param name="nValue">New time-out value in seconds.</param>
    <returns>
      TRUE, if the value has been changed; otherwise, FALSE.
    </returns>
    <remarks>
      This method sets the script time-out value of the IServer object in seconds.
      <note type="tip">
        This property cannot be set to a value less than that specified in the registry settings. For example, if it is set to 60 and the registry setting contains the default value of 120 seconds, scripts will time out after 120 seconds. However, if <paramref name="nValue" /> were set to 200, the scripts would time out after 200 seconds.
      </note>
    </remarks>
  </IServer.PutScriptTimeOut>
  <ISessionObject>
    <summary>
      Store information needed for a particular user session.
    </summary>
    <remarks>
      An ISessionObject object instance can be used to store information needed for a particular user session. Variables stored in the ISessionObject instance persist for the entire user session. They will not be discarded when the user switches between pages in the application.
    </remarks>
  </ISessionObject>
  <ISessionObject.ctor>
    <summary>
      Construct an ISessionObject object instance.
    </summary>
    <param name="oIScrContext">An IScriptingContext object.</param>
    <param name="pISessObj">Pointer to an ISession Interface object structure.</param>
    <remarks>
      An ISessionObject object instance is automatically created by the IScriptingContext:OnStartPage() method when the appropriate .ASP file is loaded by the Internet Information Server (IIS). Therefore, you do not have to create this object yourself. Rather, use it for an ASP Component application via the IScriptingContext:Session property.
    </remarks>
  </ISessionObject.ctor>
  <ISessionObject.Abandon>
    <summary>
      Destroy all of the objects stored in the current session and release their resources.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method destroys all of the objects stored in the current session and releases their resources.
    </remarks>
  </ISessionObject.Abandon>
  <ISessionObject.GetSessionID>
    <summary>
      Retrieve the session's ID value.
    </summary>
    <returns>
      Value of type STRING, if successful; otherwise, NULL_STRING.
    </returns>
    <remarks>
      The GetSessionID() method retrieves the value of a session's ID as STRING.
    </remarks>
  </ISessionObject.GetSessionID>
  <ISessionObject.GetTimeout>
    <summary>
      Retrieve the time-out value of a user session.
    </summary>
    <returns>
      Timeout value in minutes (type LONG), if successful; otherwise,0.
    </returns>
    <remarks>
      The GetTimeout() method retrieves the time-out value of the ISessionObject object instance.
    </remarks>
  </ISessionObject.GetTimeout>
  <ISessionObject.GetValue>
    <summary>
      Retrieve the value of a variable stored in an ISessionObject object instance.
    </summary>
    <param name="cVarName">Name of the desired variable.</param>
    <returns>
      Value of type USUAL, if successful; otherwise, NIL.
    </returns>
    <remarks>
      This method retrieves the value of a variable stored in the ISessionObject object instance.
    </remarks>
    <example>
      The following source code can be used to display the session value, "SessionVar":
      <code language="X#">
        GLOBAL goASPComponent AS ASPComponent
        PROCEDURE InitProc() _INIT 3
        goASPComponent := ASPComponent{}
        CLASS ASPComponent INHERIT IScriptingContext
      </code><code language="X#">
        METHOD	HTTPResponse 	CLASS ASPComponent
        LOCAL cRet AS STRING
        cRet := SELF:Session:GetValue("SessionVar")
        RETURN SELF:Response:_Write(cRet)
      </code>
      ASP code:
      <code language="X#">
        &lt;%
        Set oComp = Server.CreateObject("VoAsp.Component")
        Session("SessionVar") = 111
        oComp.HTTPResponse()
        %&gt;
      </code>
    </example>
  </ISessionObject.GetValue>
  <ISessionObject.PutTimeout>
    <summary>
      Set the time-out value of a user session.
    </summary>
    <param name="nValue">New time-out value expressed in minutes.</param>
    <returns>
      TRUE, if the value has been changed; otherwise, FALSE.
    </returns>
    <remarks>
      This method sets the time-out value of the ISessionObject object instance.
    </remarks>
  </ISessionObject.PutTimeout>
  <ISessionObject.PutValue>
    <summary>
      Store the value of a variable into an ISessionObject instance.
    </summary>
    <param name="cVarName">Name of the desired variable.</param>
    <param name="xValue">New value.</param>
    <returns>
      TRUE, if the value has been changed; otherwise, FALSE.
    </returns>
    <remarks>
      This method assigns the value of a variable stored in the ISessionObject object instance.
    </remarks>
  </ISessionObject.PutValue>
  <IUnknown>
    <summary>
      Provide a helper class for the internal implementation of OLE automation.
    </summary>
    <remarks>
      <br />Important! This class is used for internal implementation only and is not intended to be used directly.
    </remarks>
  </IUnknown>
  <IUnknown.ctor>
    <summary>
      Provide a helper method for the internal implementation of OLE automation.
      <br />Important! This method is used for internal implementation only and is not intended to be used directly.
    </summary>
  </IUnknown.ctor>
  <IUnknown.AddRef>
    <summary>
      Provide a helper method for the internal implementation of OLE automation.
      <br />Important! This method is used for internal implementation only and is not intended to be used directly.
    </summary>
  </IUnknown.AddRef>
  <IUnknown.Destroy>
    <summary>
      Provide a helper method for the internal implementation of OLE automation.
      <br />Important! This method is used for internal implementation only and is not intended to be used directly.
    </summary>
  </IUnknown.Destroy>
  <IUnknown.Release>
    <summary>
      Provide a helper method for the internal implementation of OLE automation.
      <br />Important! This method is used for internal implementation only and is not intended to be used directly.
    </summary>
  </IUnknown.Release>
  <IWriteCookie>
    <summary>
      Provide a class for altering values and attributes of the cookies stored in the write-only cookie collection of an HTTP response.
    </summary>
    <remarks>
      The IWriteCookie class enables you to alter values and attributes of the cookies stored in the write-only cookie collection of an HTTP response.
    </remarks>
  </IWriteCookie>
  <IWriteCookie.ctor>
    <summary>
      Construct an IWriteCookie object instance.
    </summary>
    <param name="pICookie">Pointer to an IWriteCookie Interface object structure.</param>
    <param name="oIServer">An IServer object instance.</param>
    <remarks>
      An IWriteCookie object instance can be created by the IResponse:GetCookies() method because it is directly associated with an HTTP request. Therefore, you do not have to create this object yourself. Rather, use it for an ASP Component application via the IScriptingContext:Response:GetCookies() method.
    </remarks>
  </IWriteCookie.ctor>
  <IWriteCookie.PutDomain>
    <summary>
      Set the Domain attribute of a cookie object.
    </summary>
    <param name="cDomain">New domain value as STRING.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method sets the new value for the Domain attribute of the IWriteCookie object. This attribute determines whether the cookie is sent only to requests to this domain.
    </remarks>
  </IWriteCookie.PutDomain>
  <IWriteCookie.PutExpires>
    <summary>
      Set the current value of the Expires property of a cookie object.
    </summary>
    <param name="dNew">New expires value as DATE.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method sets the new value for the Expires property of the IWriteCookie object. This property specifies the date at which a cookie expires.
    </remarks>
  </IWriteCookie.PutExpires>
  <IWriteCookie.PutItem>
    <summary>
      Add a specified cookie to a write-only cookie collection.
    </summary>
    <param name="cName">Name of the item to add to the cookie as STRING.</param>
    <param name="cValue">Value of the item to add to the cookie as STRING.</param>
    <param name="aValue">
      Array with item values to add to the cookie. <paramref name="cName" /> is treated as the key name and the cookie as a dictionary cookie.
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method adds a new item to the IWriteCookie object. If the second argument is a STRING, then the cookie is treated as a simple cookie and <paramref name="cValue" /> is the cookie's value. Otherwise, the cookie is treated as a dictionary cookie and <paramref name="aValues" /> contains the values for the cookie's key, <paramref name="cName" />.
    </remarks>
  </IWriteCookie.PutItem>
  <IWriteCookie.PutPath>
    <summary>
      Set the Path attribute of a cookie object.
    </summary>
    <param name="cPath">New Path value as STRING.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method sets the new value for the Path attribute of the IWriteCookie object. This attribute determines whether the cookie is sent only to requests to this path. If this attribute is not set, the application path is used.
    </remarks>
  </IWriteCookie.PutPath>
  <IWriteCookie.PutSecure>
    <summary>
      Set the Secure attribute of a cookie object.
    </summary>
    <param name="lSecure">Logical value with new Secure attribute.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method sets the new value for the Secure attribute of the IWriteCookie object. This attribute specifies whether the cookie is secure.
    </remarks>
  </IWriteCookie.PutSecure>
  <KeyEvent>
    <summary>
      Provide information about a KeyEvent, used to encapsulate information about the key that was pressed.
    </summary>
    <remarks>
      KeyEvent events occur when the keyboard is used and are sent to Window:KeyDown() and Window:KeyUp().
    </remarks>
    <example>
      This example moves the text cursor down one line when the user presses the Enter key. <paramref name="oCursorPoint" /> defines the current location of the text cursor.
      <code language="X#">
        METHOD KeyDown(aKeyEvt) CLASS TopAppWindow
        IF(aKeyEvt:KeyCode() = KeyEnter)
        ts := SELF:TextSize('A'):Height() + 2
        oCursorPoint := Point{10,oCursorPoint:Y() - ts}
        ENDIF
      </code>
    </example>
  </KeyEvent>
  <KeyEvent.ctor>
    <inheritdoc />
  </KeyEvent.ctor>
  <KeyEvent.ASCIIChar>
    <summary>
      A numeric value representing the normal ASCII code for the key that caused this KeyEvent.
    </summary>
    <value>A numeric value representing the normal ASCII code for the key that caused this KeyEvent.</value>
    <remarks>
      A numeric value representing the normal ASCII code for the key that caused this KeyEvent. (This includes all printable characters, as well as the Control key combinations from Ctrl+A to Ctrl+Z).
      This value is NIL if a non-printable and non-Control key was pressed—you should then call KeyEvent:KeyCode() to examine the key. (Keys that generate NIL include function keys, editing keys, and the Direction keys.)
    </remarks>
  </KeyEvent.ASCIIChar>
  <KeyEvent.KeyCode>
    <summary>
      A constant, indicating the code for the key that was pressed:
    </summary>
    <value>A constant, indicating the code for the key that was pressed:</value>
    <remarks>
      One of the following constants, indicating the code for the key that was pressed:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>KEYALT</term>
          <description>Alt key</description>
        </item>
        <item>
          <term>KEYARROWDOWN</term>
          <description>Down arrow key</description>
        </item>
        <item>
          <term>KEYARROWLEFT</term>
          <description>Left arrow key</description>
        </item>
        <item>
          <term>KEYARROWRIGHT</term>
          <description>Right arrow key</description>
        </item>
        <item>
          <term>KEYARROWUP</term>
          <description>Up arrow key</description>
        </item>
        <item>
          <term>KEYBACKSPACE</term>
          <description>Backspace key</description>
        </item>
        <item>
          <term>KEYCANCEL</term>
          <description>Cancel key</description>
        </item>
        <item>
          <term>KEYCAPSLOCK</term>
          <description>Capitals Lock key</description>
        </item>
        <item>
          <term>KEYCONTROL</term>
          <description>Control key</description>
        </item>
        <item>
          <term>KEYDELETE</term>
          <description>Delete key</description>
        </item>
        <item>
          <term>KEYEND</term>
          <description>End key</description>
        </item>
        <item>
          <term>KEYENTER</term>
          <description>Enter key</description>
        </item>
        <item>
          <term>KEYESCAPE</term>
          <description>Escape key</description>
        </item>
        <item>
          <term>KEYF1...KEYF16</term>
          <description>Function keys 1-16</description>
        </item>
        <item>
          <term>KEYHOME</term>
          <description>Home key</description>
        </item>
        <item>
          <term>KEYINSERT</term>
          <description>Insert key</description>
        </item>
        <item>
          <term>KEYNUMLOCK</term>
          <description>Numeric Lock key</description>
        </item>
        <item>
          <term>KEYPAGEDOWN</term>
          <description>PgDn key</description>
        </item>
        <item>
          <term>KEYPAGEUP</term>
          <description>PgUp key</description>
        </item>
        <item>
          <term>KEYPAUSE</term>
          <description>Pause key</description>
        </item>
        <item>
          <term>KEYPRINT</term>
          <description>Print key</description>
        </item>
        <item>
          <term>KEYRETURN</term>
          <description>Return key</description>
        </item>
        <item>
          <term>KEYSHIFT</term>
          <description>Shift key</description>
        </item>
        <item>
          <term>KEYSPACE</term>
          <description>Spacebar</description>
        </item>
        <item>
          <term>KEYTAB</term>
          <description>Tab key</description>
        </item>
      </list><note type="tip">KeyEvent:KeyCode provides access to the underlying keyboard hardware. Use this property if the KeyEvent:ASCIIChar access method returns NIL.</note>
    </remarks>
  </KeyEvent.KeyCode>
  <KeyEvent.RepeatCount>
    <summary>
      A numeric value determining whether a user depressed a key repeatedly or held it down for an extended period of time.
    </summary>
    <value>A numeric value determining whether a user depressed a key repeatedly or held it down for an extended period of time.</value>
    <remarks>
      A numeric value determining whether a user depressed a key repeatedly or held it down for an extended period of time.
      If a key is repeatedly depressed, the number of times the key is depressed is returned; otherwise, a value of 1 is returned.
      When the user holds down a key for a duration, multiple KeyEvents can be translated into a single KeyEvent with a RepeatCount greater than 1.
    </remarks>
  </KeyEvent.RepeatCount>
  <KeyEvent.System>
    <summary>
      A logical value determining whether the Alt key was pressed at the same time as another key (TRUE if yes, FALSE if no).
    </summary>
    <value>A logical value determining whether the Alt key was pressed at the same time as another key (TRUE if yes, FALSE if no).</value>
    <remarks>
      A logical value determining whether the Alt key was pressed at the same time as another key (TRUE if yes, FALSE if no).
    </remarks>
  </KeyEvent.System>
  <LineObject>
    <summary>
      Create a LineObject object; this type of entity is part of the DrawObject hierarchy, which provides a means of displaying and manipulating various objects.
    </summary>
    <example>
      To draw a LineObject object, call Window:Draw() with the LineObject object as its argument. The window does the drawing by asking each object to draw itself—for example:
      <code language="X#">
        METHOD Expose(oEvent) CLASS MyWindow
        LOCAL oLine AS OBJECT
        oLine := LineObject{Point{10,10},Point{20,20}}
        SELF:Draw(oLine)
      </code>
    </example>
  </LineObject>
  <LineObject.ctor>
    <summary>
      Construct a LineObject object.
    </summary>
    <param name="oPoint1">The point representing the start of the line.</param>
    <param name="oPoint2">The point representing the end of the line.</param>
    <param name="oPen">The pen to be used for drawing the LineObject object. If omitted, the current pen is used.</param>
    <remarks>
      The pen specified by <paramref name="oPen" /> should not be deleted while it is selected.
    </remarks>
  </LineObject.ctor>
  <LineObject.BoundingBox>
    <summary>
      A bounding box representing the smallest rectangle that completely encloses this LineObject object.
    </summary>
    <value>A bounding box representing the smallest rectangle that completely encloses this LineObject object.</value>
  </LineObject.BoundingBox>
  <LineObject.Destroy>
    <exclude />
  </LineObject.Destroy>
  <LineObject.Draw>
    <summary>
      Draw the LineObject object on a window.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This method should not be invoked directly in the application code—it is invoked in X# by Window:Draw(). Refer to the class description for an example using the Draw() method.
    </remarks>
  </LineObject.Draw>
  <LineObject.Origin>
    <summary>
      A point, in canvas coordinates, representing the starting coordinate of the LineObject object on its owner window.
    </summary>
    <value>A point, in canvas coordinates, representing the starting coordinate of the LineObject object on its owner window.</value>
  </LineObject.Origin>
  <LineObject.Pen>
    <summary>
      A pen associated with this LineObject object.
    </summary>
    <value>A pen associated with this LineObject object.</value>
    <remarks>
      A pen associated with this LineObject object.
      The most common reason to change the pen is to redraw an existing line temporarily in a different color to highlight the fact that the user has selected that line.
      In Windows, the pen specified by <paramref name="oPen" /> should not be deleted while it is selected.
    </remarks>
  </LineObject.Pen>
  <LineObject.Size>
    <summary>
      A dimension representing the size of this LineObject object.
    </summary>
    <value>A dimension representing the size of this LineObject object.</value>
  </LineObject.Size>
  <ListBox>
    <summary>
      Create a list box.
    </summary>
    <remarks>
      List boxes and combo boxes display a list of items or choices to the user. The list box methods will allow you to add, arrange, remove, and interrogate the list of items. When one of the items is selected, ListBox:CurrentItem, ListBox:CurrentItemNo, ListBox:TextValue, and ListBox:Value are updated. Either a one-dimensional or two-dimensional array is specified in the FillUsing() method, with a row for each of the items available for selection. With a two-dimensional array, the first element is called the display value, and the second element is called the return value. When an item is selected, ListBox:TextValue contains the first element (the display value), and ListBox:Value contains the second element (the return value). If no item is selected, ListBox:TextValue is NULL_STRING and ListBox:Value is NIL.
      A list box may be bound to a field (character, date, logical, numeric, or memo) in a server. The field's data value is stored in ListBox:Value. The list box compares the data value to the second element values specified in the FillUsing() array, and if a match is found, the first element (the display value) is stored in ListBox:TextValue. In a "no-match" situation, the list box shows no item selected, ListBox:CurrentItem is NULL_STRING, ListBox:CurrentItemNo is set to 0, and ListBox:TextValue and ListBox:Value reflect the field contents. If an item is selected, ListBox:CurrentItemNo is set to a number between 1 and ListBox:ItemCount, and the corresponding second element is stored as ListBox:Value and as the field's data value.
      <note type="tip">All array index references start at 1.</note>
      You can also create a multiple selection list box, which allows you to manage multiple items within a list box. Any number of items in a list box can be selected together (referred to as multiple selection). Each item is toggled on/off each time the user clicks on it.
      A multiple selection list box is created by selecting the LBOXMULTIPLESEL style when creating a ListBox object. Certain properties and methods of this class apply specifically to multiple selection list boxes, including SelectedCount access, ChangeSelected(), ClearSelection(), DeselectItem(), FirstSelected(), NextSelected(), and SelectItem().
    </remarks>
    <example>
      This example creates and fills a list box with a list of animals:
      <code language="X#">
        CLASS MyWindow INHERIT TopAppWindow
        HIDDEN oLB AS OBJECT
        METHOD Init() CLASS MyWindow
        SUPER:Init()
        oLB := ListBox{SELF,42,Point{10,10},;
        Dimension{100,40}}
        oLB:AddItem("Pig")
        oLB:AddItem("Cow")
        oLB:AddItem("Horse")
        oLB:Show()
      </code>

      A X# list box is equivalent to a Windows list box with the LBS_NOTIFY and LBS_SORT styles.
      List boxes are normally specified in the resource entity like this:
      <code language="X#">
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 80
        STYLE WS_POPUP | WS_DLGFRAME
        BEGIN
        LISTBOX IDL_ITEMLIST, 10, 10, 90, 40
        END
      </code>
    </example>
  </ListBox>
  <ListBox.ctor>
    <summary>
      Construct a list box.
    </summary>
    <param name="oOwner">The window that owns the list box.</param>
    <param name="xID">The unique ID of the list box (between 1 and 8000).</param>
    <param name="oPoint">The origin of the list box in canvas coordinates.</param>
    <param name="oDimension">The dimension of the list box in canvas coordinates.</param>
    <param name="kStyle">The style of the list box, specified as one of the following constants listed below:</param>
    <param name="nResourceID">The resource ID of the list box.</param>
    <remarks>
      <include file="Gui.xml" path="doc/LBStyles/*" />
    </remarks>
  </ListBox.ctor>
  <ListBox.AddItem>
    <summary>
      Add a new item to a list box at a specified position.
    </summary>
    <param name="cItem">The item to be inserted.</param>
    <param name="nItemNumber">The position in the list box at which to insert the new item. Specify one of the values listed below.</param>
    <param name="uRetValue">
      The value associated with the specified item. The default is <paramref name="cItem" />.
    </param>
    <returns>
      If the item was added, its position in the list box is returned (a value of 1 refers to the first position in the list box). If the item could not be added, 0 is returned.
    </returns>
    <remarks>
      Value	Position
      0	In an unsorted list box, adds the new item at the end of the list; if sorted, inserts the new item at a position determined by the list box. This is the default.
      1	The first position in the list box.
      n	The nth position in the list box.
    </remarks>
  </ListBox.AddItem>
  <ListBox.Caption>
    <summary>
      The string representing the caption of the list box.
    </summary>
    <value>The string representing the caption of the list box.</value>
  </ListBox.Caption>
  <ListBox.ChangeSelected>
    <summary>
      Change a range of items in a multiple selection list box to a specified selection.
    </summary>
    <param name="oRange">The Range object representing the selected items.</param>
    <param name="lEnabled">The state of the selected items. If not specified, the default is TRUE.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method is intended for use with a multiple selection list box (i.e., a list box created using the LBOXMULTIPLESEL style).
    </remarks>
  </ListBox.ChangeSelected>
  <ListBox.ClearSelection>
    <summary>
      Clear a multiple selection list box of all selections.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method is intended for use with a multiple selection list box (i.e., a list box created using the LBOXMULTIPLESEL style).
    </remarks>
  </ListBox.ClearSelection>
  <ListBox.Create>
    <exclude />
  </ListBox.Create>
  <ListBox.CurrentItem>
    <summary>
      A string representing the displayed list box or combo box item selected.
    </summary>
    <value>A string representing the displayed list box or combo box item selected.</value>
    <remarks>
      A string representing the displayed list box or combo box item selected. The ListBox:CurrentItem access also changes ListBox:CurrentItemNo, ListBox:CurrentText, ListBox:TextValue, and ListBox:Value, if there is a match with the available display items.
    </remarks>
  </ListBox.CurrentItem>
  <ListBox.CurrentItemNo>
    <summary>
      A numeric value, between 1 and the ListBox:ItemCount, indicating which item is currently selected.
    </summary>
    <value>A numeric value, between 1 and the ListBox:ItemCount, indicating which item is currently selected.</value>
    <remarks>
      A numeric value, between 1 and the ListBox:ItemCount, indicating which item is currently selected. If no item is selected, it is 0.The ListBox:CurrentItemNo assign also changes ListBox:CurrentItem, ListBox:TextValue, and ListBox:Value.
      If the assigned ListBox:CurrentItemNo is zero (0), or if it exceeds the ListBox:ItemCount, then no item will be selected. If the ListBox:CurrentItemNo assign represents a change, then ListBox:ValueChanged will be set to TRUE.
    </remarks>
  </ListBox.CurrentItemNo>
  <ListBox.CurrentText>
    <summary>
      ListBox:CurrentText is set to the NULL_STRING, since there is no text editing for list boxes.
    </summary>
    <value>ListBox:CurrentText is set to the NULL_STRING, since there is no text editing for list boxes.</value>
  </ListBox.CurrentText>
  <ListBox.DeleteItem>
    <summary>
      Remove an item from a list box.
    </summary>
    <param name="uItemNumber">The number of the item to be deleted. Specify one of values listed below</param>
    <param name="nItem">The number of the item to be deleted. Specify one of values listed below</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Value	Position
      0	The currently selected item. This is the default.
      1	The first item.
      n	The nth item.
    </remarks>
  </ListBox.DeleteItem>
  <ListBox.DeselectItem>
    <summary>
      Turn off the selection of a specified item in a list box.
    </summary>
    <param name="nItem">The item number to be deselected. Zero (0) represents the current item.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Normally, the user turns selections off, but this method enables the program to do so also.
      This method is intended for use with a multiple selection list box (i.e., a list box created using the LBOXMULTIPLESEL style).
    </remarks>
  </ListBox.DeselectItem>
  <ListBox.Destroy>
    <summary>
      Provide a method to de-instantiate a ListBox object.
    </summary>
    <remarks>
      This method can be used when a ListBox object is no longer needed. ListBox:Destroy() de-instantiates the ListBox object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </ListBox.Destroy>
  <ListBox.EnableItemDrag>
    <summary>
      Turn the list box into a drag list box.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ListBox.EnableItemDrag>
  <ListBox.FillUsing>
    <summary>
      Specify the set of values to be displayed in the list box, using an array or a data server. These values act as a constraint on the values that may be entered in the list box, and optionally as a translation between program values and display values.
    </summary>
    <param name="oList">Sorted List of String/Usual pairs </param>
    <param name="aContents">
      An array containing the values to be placed in the list box. A two-dimensional array may be used to define the values to be returned to the program when a list item is selected, separately from the text strings shown in the list; this 'other' value is what is returned in the ListBox:Value property, and what is stored in the database if the control is associated with a database field.
      Thus, the array may be specified in one of two formats:
      <list type="table">
        <item>
          <term>1.</term>
          <description>One-dimensional array containing the list of values.</description>
        </item>
        <item>
          <term>2.</term>
          <description>
            Array of two-element arrays, each containing the string to display in the list and the corresponding value returned to the program.
            Note that the two dimensional array has the same structure as that returned by DBServer:GetLookupTable(), and the
            one-dimensional array matches that returned by DBServer:GetArray(). or The data server that is to be used to provide the set of values.
          </description>
        </item>
      </list>
    </param>
    <param name="symField1">The symbolic name of the field that is to be used for the display values. If not specified, the values of the first field are used.</param>
    <param name="symField2">The symbolic name of the field that is to be used for the values that are returned to the program. If not specified, the values of the first field are used.</param>
    <remarks>
      A list box shows the set of valid values for a field. Depending on what type of list box is used, the set of values may act as a constraint on the values that may be retrieved or only as a suggestion. Two sets of values may be specified, allowing for translation of values between the displayed, "human-readable" representation and the internal, programmatic value.
      The FillUsing() method provides a way of specifying the values to be included in the list all at once, instead of constructing the list item by item with the AddItem() method.
      <note type="tip">The list box control may be associated with a database field, just like any other control. Do not confuse this primary field linkage with the possibility of linking the list box to a secondary server used for populating the list.</note>
    </remarks>
    <example>
      Create a list box with different currencies, showing an explicit representation to the user but using a different representation internally:
      <code language="X#">
        METHOD Init(...) CLASS OrderWindow
        ...
        oLBCurrency := ListBox{SELF,LBCURRENCY_ID}
        oLBCurrency:FillUsing({;
        {"U.S. Dollars","USD"},;
        {"Can. Dollars","CDN"},;
        {"Mexican Pesos","MEX"},;
        {"Yen","YEN"},;
        {"British Pounds","UK"},;
        {"German Marks","DM"};
        })
        oLBCurrency:Show()
      </code>
      Create a list box that shows the products available in the product table:
      <code language="X#">
        METHOD Init(...) CLASS OrderWindow
        ...
        oLBProducts := ListBox{SELF,LBPRODUCTS_ID}
        oLBProducts:FillUsing(oDBProducts,#ProdName,#ProdNo)
        oLBProducts:Show()
      </code>
    </example>
  </ListBox.FillUsing>
  <ListBox.FirstSelected>
    <summary>
      Returns the position of the first item selected in a multiple selection list box, or 0 if no item is selected.
    </summary>
    <remarks>
      ListBox:FirstSelected() positions an imaginary cursor on the first item of the selection.
      This method is intended for use with a multiple selection list box (i.e., a list box created using the LBOXMULTIPLESEL style).
    </remarks>
  </ListBox.FirstSelected>
  <ListBox.GetItemValue>
    <summary>
      Retrieve the value of a specified list box item.
    </summary>
    <param name="nItemNumber">The number of the desired item. Specify one of the values listed below:</param>
    <returns>
      The value associated with the specified item.
    </returns>
    <remarks>
      Value	Position
      0	The currently selected item.
      1	The first item.
      n	The nth item.
    </remarks>
    <example>
      <code language="X#">
        METHOD ListBoxClick(oControlEvent) CLASS EmailWindow
        LOCAL oControl := oControlEvent:Control AS Control
        SUPER:ListBoxClick(oControlEvent)
        IF IsInstanceOf(oControl, #ListBox)
        SELF:DialClient(oControl:GetItemValue(0))
        ENDIF
        RETURN NIL
      </code>
    </example>
  </ListBox.GetItemValue>
  <ListBox.IsSelected>
    <summary>
      Determine if the list box item at the specified index position is selected.
    </summary>
    <param name="iIdx">Index position of the list box item.</param>
    <returns>
      TRUE if selected; otherwise, FALSE.
    </returns>
  </ListBox.IsSelected>
  <ListBox.ItemCount>
    <exclude />
  </ListBox.ItemCount>
  <ListBox.ListFiles>
    <summary>
      Fill a list box with the names of all files that match the specified path or file name.
    </summary>
    <param name="sStartDir">The path or file name of the starting directory.</param>
    <param name="oFixedText">
      Set automatically to the fixed text of the drive/directory of <paramref name="sStartDir" />.
    </param>
    <param name="FileTypes">One of the following constants indicating the attributes of the files to be displayed:</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <list type="table">
        <listheader>
          <term>Windows API Constant </term>
          <description>Description</description>
        </listheader>
        <item>
          <term>DDL_ARCHIVE</term>
          <description>Includes archived files.</description>
        </item>
        <item>
          <term>DDL_DIRECTORY</term>
          <description>Includes subdirectories, enclosed in square brackets ([ ]).</description>
        </item>
        <item>
          <term>DDL_DRIVES</term>
          <description>Includes drives, listed in the form [-x-] where x is the drive letter.</description>
        </item>
        <item>
          <term>DDL_EXCLUSIVE</term>
          <description>Includes only files with the specified attributes. </description>
        </item>
        <item>
          <term></term>
          <description>
            <note type="tip">Read-write files are included by default even if DDL_READWRITE is not specified.</note>
          </description>
        </item>
        <item>
          <term>DDL_HIDDEN</term>
          <description>Includes hidden files.</description>
        </item>
        <item>
          <term>DDL_READONLY</term>
          <description>Includes read-only files.</description>
        </item>
        <item>
          <term>DDL_READWRITE</term>
          <description>Includes read-write files with no additional attributes specified.</description>
        </item>
        <item>
          <term>DDL_SYSTEM</term>
          <description>Includes system files.</description>
        </item>
        <item>
          <term>DDL_POSTMSGS</term>
          <description>Posts messages to the application's message queue. </description>
        </item>
      </list>
    </remarks>
  </ListBox.ListFiles>
  <ListBox.Modified>
    <summary>
      A logical value that is set to FALSE for a list box, since it does not contain text that can be edited.
    </summary>
    <value>A logical value that is set to FALSE for a list box, since it does not contain text that can be edited.</value>
  </ListBox.Modified>
  <ListBox.MultiSelection>
    <summary>
      Used to identify if the ListBox supports multiple selections.
    </summary>
    <value>Used to identify if the ListBox supports multiple selections.</value>
  </ListBox.MultiSelection>
  <ListBox.NextSelected>
    <summary>
      After calling ListBox:FirstSelected(), this method is used to cycle through the remaining items selected in a multiple selection list box.
    </summary>
    <returns>
      Position of the next selected item in the list box, or 0 if no item is selected or if there are no remaining items.
    </returns>
    <remarks>
      This method is intended for use with a multiple selection list box (i.e., a list box created using the LBOXMULTIPLESEL style).
    </remarks>
  </ListBox.NextSelected>
  <ListBox.SelectedCount>
    <summary>
      A numeric value representing the total number of items that are currently selected in a multiple selection list box.
      <note type="tip">This property is intended for use with a multiple selection list box (i.e., a list box created using the LBOXMULTIPLESEL style).</note>
    </summary>
    <value>
      A numeric value representing the total number of items that are currently selected in a multiple selection list box.
      This property is intended for use with a multiple selection list box (i.e., a list box created using the LBOXMULTIPLESEL style).
    </value>
  </ListBox.SelectedCount>
  <ListBox.SelectedFiles>
    <summary>
      The string representing the selected file in a list box previously filled by the ListFiles() method.
    </summary>
    <value>The string representing the selected file in a list box previously filled by the ListFiles() method.</value>
  </ListBox.SelectedFiles>
  <ListBox.SelectItem>
    <summary>
      Turn on the selection of an item in a list box.
    </summary>
    <param name="nItemId">The item number to be selected. Zero (0) represents the current item.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Normally, the user turns selections on and off, but this method enables the program to do so also.
      This method is intended for use with a multiple selection list box (i.e., a list box created using the LBOXMULTIPLESEL style).
    </remarks>
  </ListBox.SelectItem>
  <ListBox.SetTabs>
    <exclude />

  </ListBox.SetTabs>
  <ListBox.TextValue>
    <summary>
      A string representing the display value (first array's element) for the currently selected item.
    </summary>
    <value>A string representing the display value (first array's element) for the currently selected item.</value>
    <remarks>
      A string representing the display value (first array's element) for the currently selected item, formatted according to the picture clause of the field specification attached to the list box (or combo box). For example the ListBox:TextValue can be "Jones", "01/15/95", or "8". The ListBox:TextValue assign also changes ListBox:CurrentItem, ListBox:CurrentItemNo, ListBox:Modified, ListBox:Value, and ListBox:ValueChanged.
      If the assign does not match one of the display items, then ListBox:TextValue and ListBox:Value are set to the text that could not be matched, and ListBox:CurrentItemNo is set to 0. If the control is bound to a field in a server and the field data value does not match one of the array's second elements, ListBox:TextValue and ListBox:Value contain the field's data value.
    </remarks>
  </ListBox.TextValue>
  <ListBox.Value>
    <summary>
      A value (second element in the FillUsing() array) representing the currently selected item, formatted according to the picture clause of the field specification attached to the list box (or combo box). For example the TextValue can be "Jones", "01/15/95", or "8". If there is no selected item and the list box is not bound to a field in a server, the ListBox:Value is set to NIL. The ListBox:Value assign also changes ListBox:CurrentItem, ListBox:CurrentItemNo, ListBox:TextValue, and ListBox:ValueChanged.
      If the assigned text does not match one of the return value choices, ListBox:CurrentItemNo is set to 0, and ListBox:TextValue and ListBox:Value are set to the assigned text. In a list box, the ListBox:Value is generally one of the return values, unless the control is bound to a field where the actual contents is not one of the allowable choices, and there is a no-match situation; in this case ListBox:TextValue and ListBox:Value contain the field's data value.
      The data type for ListBox:Value is determined by the field specification of the list box; in turn, controls linked to a data server inherit the field specification—and hence data type—from the field of the server. When the control is made data-aware, by setting its name to the name of a field in the server attached to the data window, ListBox:Value is able to automatically read from and write to this field.
      <note type="tip">ListBox:Value may not always be consistent with what the state of the control, as indicated to the end user. For example, if the data value for the field is not one of the allowed choices for a list box return value, the control will be in a "no-match" situation. In this case the list box will revert to its initial unselected state with ListBox:CurrentItemNo set to 0.</note>
    </summary>
    <value>
      A value (second element in the FillUsing() array) representing the currently selected item, formatted according to the picture clause of the field specification attached to the list box (or combo box). For example the TextValue can be "Jones", "01/15/95", or "8". If there is no selected item and the list box is not bound to a field in a server, the ListBox:Value is set to NIL. The ListBox:Value assign also changes ListBox:CurrentItem, ListBox:CurrentItemNo, ListBox:TextValue, and ListBox:ValueChanged.
      If the assigned text does not match one of the return value choices, ListBox:CurrentItemNo is set to 0, and ListBox:TextValue and ListBox:Value are set to the assigned text. In a list box, the ListBox:Value is generally one of the return values, unless the control is bound to a field where the actual contents is not one of the allowable choices, and there is a no-match situation; in this case ListBox:TextValue and ListBox:Value contain the field's data value.
      The data type for ListBox:Value is determined by the field specification of the list box; in turn, controls linked to a data server inherit the field specification—and hence data type—from the field of the server. When the control is made data-aware, by setting its name to the name of a field in the server attached to the data window, ListBox:Value is able to automatically read from and write to this field.
      ListBox:Value may not always be consistent with what the state of the control, as indicated to the end user. For example, if the data value for the field is not one of the allowed choices for a list box return value, the control will be in a "no-match" situation. In this case the list box will revert to its initial unselected state with ListBox:CurrentItemNo set to 0.
    </value>
  </ListBox.Value>
  <ListBox.ValueChanged>
    <summary>
      A logical value representing whether the list box Value has been changed from the previously selected item during the selection process. TRUE indicates that it has been changed from the prior choice, while FALSE indicates it has been not changed from the prior choice. The list box Value may be changed by clicking on a different item, or via the ListBox:TextValue or ListBox:Value assigns.
    </summary>
    <value>A logical value representing whether the list box Value has been changed from the previously selected item during the selection process. TRUE indicates that it has been changed from the prior choice, while FALSE indicates it has been not changed from the prior choice. The list box Value may be changed by clicking on a different item, or via the ListBox:TextValue or ListBox:Value assigns.</value>
  </ListBox.ValueChanged>
  <ListView>
    <summary>
      Create a list view control.
      Important - Microsoft Note - Under visual styles GridLines are not always displayed correctly.
    </summary>
    <remarks>
      A list view is a control that displays a collection of list view items, each item consisting of images and a text label. List views provide several ways of arranging items and displaying individual items.
    </remarks>
  </ListView>
  <ListView.ctor>
    <summary>
      Construct a list view.
    </summary>
    <param name="oOwner">The window that owns the list view.</param>
    <param name="xID">The unique ID for the list view (between 1 and 8000).</param>
    <param name="oPoint">The origin of the list view in canvas coordinates.</param>
    <param name="oDimension">The dimension of the list view in canvas coordinates.</param>
    <param name="kStyle">The style of the list view.</param>
    <param name="nResourceID">The resource ID of the list view.</param>
  </ListView.ctor>
  <ListView.AddColumn>
    <summary>
      Add a new ListViewColumn object to the end of the list view's list of columns.
    </summary>
    <param name="oListViewColumn">The ListViewColumn object to add to the list view.</param>
    <returns>
      TRUE if the column was added successfully; otherwise, FALSE.
    </returns>
    <example>
      <code language="X#">SELF:oDClvPlayers:AddColumn( ListViewColumn{15, HyperLabel{ String2Symbol( "cName" ), "Recipient"}})</code>
    </example>
  </ListView.AddColumn>
  <ListView.AddGroup>
    <summary>
      Set an image as the background to the list view.
    </summary>
    <param name="iGroupId">The number of the group.</param>
    <param name="cGroupName">group name</param>
    <param name="dwAlign">
      The group alignment. Available options are -
      <list type="table">
        <item>
          <term>LVGA_HEADER_LEFT</term>
          <description></description>
        </item>
        <item>
          <term>LVGA_HEADER_RIGHT</term>
          <description></description>
        </item>
        <item>
          <term>LVGA_HEADER_CENTER</term>
          <description></description>
        </item>
      </list>
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">
        Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
        If group view is enabled only items belonging to groups are displayed.
      </note>
    </remarks>
  </ListView.AddGroup>
  <ListView.AddItem>
    <summary>
      Add a new ListViewItem object as the last item in the list view.
    </summary>
    <param name="oListViewItem">The ListViewItem object to add to the list view.</param>
    <returns>
      TRUE if the item was added successfully; otherwise, FALSE.
    </returns>
    <example>
      The example below shows how to populate a ListView control. Note that it is also storing the record number with each item also for later retrieval when any given item is selected:
      <code language="X#">
        LOCAL cCoachName	 AS string
        LOCAL oItem 		AS ListViewItem
        DO WHILE !SELF:oCoachesServer:eof
        cCoachName	:= 	Trim( SELF:oCoachesServer:FIELDGET( #LastName ) ) ;
        + ", " + ;
        Trim( SELF:oCoachesServer:FIELDGET( #FirstName ) ) + " " + ;
        SELF:oCoachesServer:FIELDGET( #MiddleInit )
        oItem:SetText( SELF:oCoachesServer:FIELDGET( #Season ), #cSeason )
        oItem:SetValue( SELF:oCoachesServer:RecNo, #cCoachName )
        oItem:SetText( CoachName, #cCoachName )
        oItem:SetText( SELF:oCoachesServer:FIELDGET( #Gender ), #cGender )
        oItem:SetText( SELF:oCoachesServer:FIELDGET( #ClubCode ), #cClubCode )
        oItem:SetText( SELF:oCoachesServer:FIELDGET( #TeamNr ), #cTeamNr )
        oItem:SetText( SELF:oCoachesServer:FIELDGET( #HomePhone ),	#cHomePhone )
        oItem:SetText( SELF:oCoachesServer:FIELDGET( #WorkPhone ),	#cWorkPhone )
      </code><code language="X#">
        SELF:oDClvCoaches:AddItem( oItem )
        SELF:oCoachesServer:skip()
        ENDDO
      </code>
    </example>
  </ListView.AddItem>
  <ListView.Arrange>
    <summary>
      Align list view items while in icon view.
    </summary>
    <param name="kAlignment">One of the following constants describing how to align the list view items:</param>
    <returns>
      TRUE if the item was arranged successfully; otherwise, FALSE.
    </returns>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>LVA_ALIGNLEFT</term>
          <description>Aligns items along the left edge of the window.</description>
        </item>
        <item>
          <term>LVA_ALIGNTOP</term>
          <description>Aligns items along the top edge of the window.</description>
        </item>
        <item>
          <term>LVA_DEFAULT</term>
          <description>Aligns items according to the list view's current alignment styles (the default setting).</description>
        </item>
        <item>
          <term>LVA_SNAPTOGRID</term>
          <description>Items are snapped to the nearest grid position.</description>
        </item>
      </list>
    </remarks>
  </ListView.Arrange>
  <ListView.BackgroundColor>
    <summary>
      A Color object used to paint the background in the list view.
    </summary>
    <value>A Color object used to paint the background in the list view.</value>
  </ListView.BackgroundColor>
  <ListView.CheckBoxes>
    <summary>
      A logical value determining whether check boxes are used in the list view.
    </summary>
    <value>A logical value determining whether check boxes are used in the list view.</value>
  </ListView.CheckBoxes>
  <ListView.ColumnCount>
    <summary>
      A numeric value representing the number of columns in the list view.
    </summary>
    <value>A numeric value representing the number of columns in the list view.</value>
  </ListView.ColumnCount>
  <ListView.ColumnOrderArray>
    <summary>
      An array of ListViewColumn object symbolic names representing the order of the columns in the list view.
    </summary>
    <value>An array of ListViewColumn object symbolic names representing the order of the columns in the list view.</value>
  </ListView.ColumnOrderArray>
  <ListView.CurrentView>
    <summary>
      A symbolic name representing the current view of the list view.
    </summary>
    <value>A symbolic name representing the current view of the list view.</value>
    <remarks>
      A symbolic name representing the current view of the list view. The following are valid views:
      <list type="bullet">
        <item>#IconView</item>
        <item>#SmallIconView</item>
        <item>#ListView</item>
        <item>#ReportView</item>
      </list>
    </remarks>
  </ListView.CurrentView>
  <ListView.DeleteAll>
    <summary>
      Delete all items of the list view.
    </summary>
    <returns>
      TRUE if all items were deleted successfully; otherwise, FALSE.
    </returns>
  </ListView.DeleteAll>
  <ListView.DeleteAllColumns>
    <summary>
      Delete all columns from a list view.
    </summary>
    <returns>
      TRUE if all items were deleted successfully; otherwise, FALSE.
    </returns>
  </ListView.DeleteAllColumns>
  <ListView.DeleteColumn>
    <summary>
      Delete a ListViewColumn object from the list view.
    </summary>
    <param name="oListViewColumn">The ListViewColumn object to delete from the list view.</param>
    <returns>
      TRUE if the column was deleted successfully; otherwise, FALSE.
    </returns>
  </ListView.DeleteColumn>
  <ListView.DeleteItem>
    <summary>
      Delete a ListViewItem object from the list view.
    </summary>
    <param name="nItem">The index of the ListViewItem object to delete from the list view.</param>
    <returns>
      TRUE if the item was deleted successfully; otherwise, FALSE.
    </returns>
  </ListView.DeleteItem>
  <ListView.Destroy>
    <inheritdoc />
  </ListView.Destroy>
  <ListView.DragDropEnabled>
    <summary>
      A logical value that is TRUE if drag and drop is enabled for the list view. If drag and drop is enabled, items can be dragged within, as well as outside, the control.
    </summary>
    <value>A logical value that is TRUE if drag and drop is enabled for the list view. If drag and drop is enabled, items can be dragged within, as well as outside, the control.</value>
  </ListView.DragDropEnabled>
  <ListView.DragImageList>
    <summary>
      An image list containing a single image displayed during a drag and drop operation for the list view.
    </summary>
    <value>An image list containing a single image displayed during a drag and drop operation for the list view.</value>
  </ListView.DragImageList>
  <ListView.EditItemLabel>
    <summary>
      Begins in-place label editing of an item in the list view.
    </summary>
    <param name="nItem">The index of the ListViewItem object whose label you want to edit.</param>
  </ListView.EditItemLabel>
  <ListView.EnableDragDrop>
    <summary>
      Enable or disable drag and drop of items for the list view.
    </summary>
    <param name="lEnable">A value of TRUE indicates that drag and drop is enabled, while FALSE indicates that it is disabled. The default value is TRUE.</param>
    <returns>
      TRUE if drag and drop could be enabled or disabled; otherwise, FALSE.
    </returns>
  </ListView.EnableDragDrop>
  <ListView.EnableGroupView>
    <summary>
      Set Group View on or off in a ListView control.
    </summary>
    <param name="lSetting">A logical value. TRUE turns Group View on, FALSE turns it off. The default is TRUE.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">
        Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
        If group view is enabled only items belonging to groups are displayed.
      </note>
    </remarks>
  </ListView.EnableGroupView>
  <ListView.EnableSort>
    <summary>
      Register a user-defined method to use for sorting items in the list view.
    </summary>
    <param name="symMethodName">The symbolic name of the user-defined method that will be used to sort items in the list view. When called, this method receives two ListViewItem objects as arguments. The method should determine which of the two list view items should come first in the list view. If the first item precedes the second, this method should return -1; if the second item precedes the first, this method should return 1; if the items are equivalent, this method should return 0.</param>
    <returns>
      The symbolic name of the user-defined method to perform the sort.
    </returns>
  </ListView.EnableSort>
  <ListView.EnsureVisible>
    <summary>
      Ensure that an item is visible in the list view, scrolling if necessary.
    </summary>
    <param name="nItem">The index of the list view item to make visible.</param>
    <param name="lPartiallyVisible">A value of TRUE indicates that the specified item can be only partially visible. Specify FALSE if you want the item to be fully visible.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ListView.EnsureVisible>
  <ListView.FullRowSelect>
    <summary>
      A logical value determining whether the entire row is highlighted when a list view item is selected.
    </summary>
    <value>A logical value determining whether the entire row is highlighted when a list view item is selected.</value>
  </ListView.FullRowSelect>
  <ListView.GetAllItems>
    <summary>
      Get an array with all the Listview Items
    </summary>
    <returns>
      An array with all Listview Items
    </returns>
  </ListView.GetAllItems>
  <ListView.GetAllSelectedItems>
    <summary>
      Get an array with all the selected Listview Items
    </summary>
    <returns>
      An array with all selected Listview Items
    </returns>
  </ListView.GetAllSelectedItems>
  <ListView.GetColumn>
    <summary>
      Return a particular ListViewColumn object.
    </summary>
    <param name="xColumnID">
      The numeric position of the list view column in the list view. Columns are numbered from left to right,
      or the symbolic name of the list view column.
    </param>
    <returns>
      The ListViewColumn object.
    </returns>
  </ListView.GetColumn>
  <ListView.GetExLVStyle>
    <exclude />

  </ListView.GetExLVStyle>
  <ListView.GetExStyle>
    <summary>
      A logical value determining whether the specified extended list view style is enabled or disabled.
    </summary>
    <param name="kExStyle">Extended list view style to query. (See the Microsoft Win32 Software Development Kit documentation for a list of valid constants.)</param>
    <returns>
      TRUE, if the extended ListView style is set; otherwise, FALSE.
    </returns>
  </ListView.GetExStyle>
  <ListView.GetGroupTextColor>
    <summary>
      Get the text color used for the headings when displaying a ListView control by group.
    </summary>
    <returns>
      The color object.
    </returns>
    <remarks>
      <note type="tip">
        Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
        If group view is enabled only items belonging to groups are displayed.
      </note>
    </remarks>
  </ListView.GetGroupTextColor>
  <ListView.GetItemAtPosition>
    <summary>
      Return a ListViewItem object at a particular position, if one exists.
    </summary>
    <param name="oPoint">The point at which to find a list view item.</param>
    <returns>
      The ListViewItem object at the specified point.
    </returns>
  </ListView.GetItemAtPosition>
  <ListView.GetItemAttributes>
    <summary>
      Return a ListViewItem object given its item index.
    </summary>
    <param name="nItem">The index of the list view item to be returned.</param>
    <returns>
      The ListViewItem object specified by the item index.
    </returns>
    <example>
      <code language="X#">
        nCount := SELF:oDClvClaims:ItemCount
        FOR x := 1 UPTO nCount
        oLVI := SELF:oDClvClaims:GetItemAttributes(x)
        IF oLVI != NULL_OBJECT
        IF oLVI:Checked	// Using the "checkbox" property of a ListView set to YES
        nValue := oLVI:GetValue( #dSvcDate )
        SELF:oBillingsServer:GoTo( nValue )
        // do some processing here
        DO CASE
        CASE cClaims == "P"
        oLVI:StateImageIndex := 1	// ImageList was predefined in a PostInit() method
        CASE cClaims == "X"
        oLVI:StateImageIndex := 2
        CASE cClaims == "S"
        oLVI:StateImageIndex := 6
        ENDCASE
        SELF:oDClvClaims:SetItemAttributes(oLVI)
        ENDIF
        ENDIF
        NEXT x
      </code>
    </example>
  </ListView.GetItemAttributes>
  <ListView.GetItemBoundingBox>
    <summary>
      Return the bounding box of a ListViewItem object given its item index.
    </summary>
    <param name="nItem">The index of the list view item whose bounding box you want to obtain.</param>
    <returns>
      The bounding box of the ListViewItem object specified by the item index.
    </returns>
  </ListView.GetItemBoundingBox>
  <ListView.GetItemPosition>
    <summary>
      Return the origin of a ListViewItem object given its item index.
    </summary>
    <param name="nItem">The index of the list view item whose origin you want to obtain.</param>
    <returns>
      The origin of the list view item specified by the item index.
    </returns>
  </ListView.GetItemPosition>
  <ListView.GetItemSpacing>
    <summary>
      Return the spacing between list view items in icon view or small icon view.
    </summary>
    <param name="symView">The symbolic name of the view whose spacing you want to obtain. This value can be #IconView or #SmallIconView. If omitted, the spacing of icon view is reported.</param>
    <returns>
      The amount of spacing between items.
    </returns>
  </ListView.GetItemSpacing>
  <ListView.GetNextItem>
    <summary>
      Retrieve the next list view item that possesses all of the specified properties.
    </summary>
    <param name="kRelationship">One of the following constants describing the physical relationship to the specified item. See table below for possible values</param>
    <param name="lDisabled">A value of TRUE indicates that the list view item's image should be disabled. If omitted, the default is FALSE.</param>
    <param name="lDropTarget">A value of TRUE indicates that the list view item should be a drag and drop target. If omitted, the default is FALSE.</param>
    <param name="lFocused">A value of TRUE indicates that the list view item should be focused. If omitted, the default is FALSE.</param>
    <param name="lSelected">A value of TRUE indicates that the list view item should be selected. If omitted, the default is FALSE.</param>
    <param name="nItemStart">Index of the item with which to begin searching. If omitted, searching starts from the beginning.</param>
    <returns>
      The list view item returned as a result of the search.
    </returns>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>LV_GNIABOVE</term>
          <description>Searches for an item that is above the specified item</description>
        </item>
        <item>
          <term>LV_GNIBELOW</term>
          <description>Searches for an item that is below the specified item</description>
        </item>
        <item>
          <term>LV_GNIBYITEM</term>
          <description>Searches for a subsequent item by index (the default value)</description>
        </item>
        <item>
          <term>LV_GNILEFT</term>
          <description>Searches for an item to the left of the specified item</description>
        </item>
        <item>
          <term>LV_GNIRIGHT</term>
          <description>Searches for an item to the right of the specified item</description>
        </item>
      </list>
    </remarks>
    <example>
      The example below shows how to traverse all items in a ListView for further processing. Note that the GetNextItem() method's last parameter is zero-based:
      <code language="X#">
        LOCAL oLVI	AS ListViewItem
        nCount		:= SELF:oDClvPlayers:ItemCount
        FOR x := 1 UPTO nCount
        oLVI		:= SELF:oDClvPlayers:GetNextItem( LV_GNIBYITEM,,,,,x-1 )
        cID		:= AllTrim( oLVI:GetText( #cPlayerID ) )
        nRecNo	:= oLVI:GetValue( #cPlayerID )
        NEXT x
      </code>
    </example>
  </ListView.GetNextItem>
  <ListView.GetSelectedColumn>
    <exclude />
  </ListView.GetSelectedColumn>
  <ListView.GetSelectedItem>
    <summary>
      Retrieve the currently selected ListViewItem object.
    </summary>
    <returns>
      The currently selected ListViewItem object.
    </returns>
  </ListView.GetSelectedItem>
  <ListView.GridLines>
    <summary>
      A logical value determining whether gridlines are shown in the list view.
    </summary>
    <value>A logical value determining whether gridlines are shown in the list view.</value>
    <remarks>
      A logical value determining whether gridlines are shown in the list view.
      Important - Microsoft Note - Under visual styles GridLines are not always displayed correctly.
      See http://support.microsoft.com/default.aspx?scid=kb;en-us;813791 for more info.
    </remarks>
  </ListView.GridLines>
  <ListView.HasGroup>
    <summary>
      A logical value to determine if the group with the specified ID exists in a ListView control.
    </summary>
    <param name="iGroupId">The number of the group.</param>
    <returns>
      TRUE if it exists; otherwise, FALSE.
    </returns>
    <remarks>
      <note type="tip">
        Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
        If group view is enabled only items belonging to groups are displayed.
      </note>
    </remarks>
  </ListView.HasGroup>
  <ListView.HeaderDragDrop>
    <summary>
      A logical value determining whether columns can be rearranged in the list view by dragging and dropping the column headers.
    </summary>
    <value>A logical value determining whether columns can be rearranged in the list view by dragging and dropping the column headers.</value>
  </ListView.HeaderDragDrop>
  <ListView.InsertColumn>
    <summary>
      Insert a new ListViewColumn object after a particular column index in the list view.
    </summary>
    <param name="oListViewColumn">The ListViewColumn object to insert in the list view.</param>
    <param name="nInsertAfter">The position after which to insert the new column. If omitted, the new column is added to the end of the column list.</param>
    <returns>
      TRUE if the column was inserted successfully; otherwise, FALSE.
    </returns>
  </ListView.InsertColumn>
  <ListView.InsertItem>
    <summary>
      Insert a new ListViewItem object after a particular item index in the list view.
    </summary>
    <param name="oListViewItem">The ListViewItem object to insert in the list view.</param>
    <param name="nInsertAfter">The position after which to insert the new item. If omitted, the new item is added as the last item.</param>
    <returns>
      TRUE if the item was inserted successfully; otherwise, FALSE.
    </returns>
  </ListView.InsertItem>
  <ListView.IsGroupViewEnabled>
    <summary>
      A logical value to identify if ListView groups are enabled.
    </summary>
    <value>A logical value to identify if ListView groups are enabled.</value>
    <remarks>
      A logical value to identify if ListView groups are enabled.
      <note type="tip">
        Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
        If group view is enabled only items belonging to groups are displayed.
      </note>
    </remarks>
  </ListView.IsGroupViewEnabled>
  <ListView.ItemCount>
    <summary>
      A numeric value representing the number of items in the list view.
    </summary>
    <value>A numeric value representing the number of items in the list view.</value>
  </ListView.ItemCount>
  <ListView.ItemsPerPage>
    <summary>
      A numeric value representing the number of items that can fit vertically in the visible area of the list view.
    </summary>
    <value>A numeric value representing the number of items that can fit vertically in the visible area of the list view.</value>
  </ListView.ItemsPerPage>
  <ListView.LargeImageList>
    <summary>
      An image list containing large images to display for each item when the list view is displayed in icon view.
    </summary>
    <value>An image list containing large images to display for each item when the list view is displayed in icon view.</value>
    <example>
      This example would typically occur in a PostInit() method of a window. In the example below, when the ListView is populated, each item will be assigned an image index, in this case depending upon whether the player in question is active or not.
      <code language="X#">
        LOCAL oImageList 	AS ImageList
        oImageList := ImageList{2, Dimension{32, 32}}
        oImageList:Add(SmIconCheck{})
        oImageList:Add(SmIconCross{})
        SELF:oDClvPlayers:LargeImageList := oImageList
      </code>
    </example>
  </ListView.LargeImageList>
  <ListView.RedrawRange>
    <summary>
      Redraw a range of list view items.
    </summary>
    <param name="oRange">The range of list view item indexes to redraw.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ListView.RedrawRange>
  <ListView.RemoveAllGroups>
    <summary>
      Remove all groups from a ListView control.
    </summary>
    <remarks>
      <note type="tip">
        Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
        If group view is enabled only items belonging to groups are displayed.
      </note>
    </remarks>
  </ListView.RemoveAllGroups>
  <ListView.RemoveGroup>
    <summary>
      Remove the group with the specified ID from a ListView control.
    </summary>
    <param name="iGroupId">The number of the group.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">
        Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
        If group view is enabled only items belonging to groups are displayed.
      </note>
    </remarks>
  </ListView.RemoveGroup>
  <ListView.Scroll>
    <summary>
      Scroll the contents of a list view.
    </summary>
    <param name="oDimension">The dimension representing the amount to scroll the list view. Positive width values scroll to the right, while negative width values scroll to the left. In addition, positive height values scroll upwards, while negative height values scroll downwards.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ListView.Scroll>
  <ListView.SearchString>
    <summary>
      The incremental search string associated with the list view.
    </summary>
    <value>The incremental search string associated with the list view.</value>
    <remarks>
      The incremental search string associated with the list view. The incremental search string is the character sequence that the user types while the list view has the input focus. When the user types a character, the character is appended to the search string and a matching item is sought. If the system finds a match, it selects the item. A timeout period is associated with the search string; if the timeout period elapses before the user types another character, the string is reset.
    </remarks>
  </ListView.SearchString>
  <ListView.Seek>
    <summary>
      Search the list view for a particular list view item.
    </summary>
    <param name="uValue">
      The value to seek. <paramref name="kSeekType" /> must be LV_SEEKVALUE.
    </param>
    <param name="cText">
      The string to seek. <paramref name="kSeekType" /> must be LV_SEEKTEXT.
    </param>
    <param name="oPoint">
      The point in the client area of the list view at which the seek begins. The nearest list view item to this point in the direction specified by <paramref name="kSeekType" /> will be returned.
    </param>
    <param name="kSeekType">A constant that specifies what type of seek to perform. LV_SEEKVALUE causes a seek on a usual value. LV_SEEKTEXT causes a seek on a text string.  If the seek is on a Point object, this argument can be LV_SEEKUP or LV_SEEKDOWN to specify a search in the respective directions. In this case, if the argument is omitted, LV_SEEKDOWN is assumed.</param>
    <param name="nStart">The index of the list view item at which to begin the search. If omitted, the seek begins at the first item.</param>
    <param name="lWrap">A value of TRUE continues the search at the first list view item if no match is found. If omitted, the default is FALSE, which disables wrapping.</param>
    <param name="lPartial">
      A value of TRUE produces a match if the list view item label begins with <paramref name="cText" />. If omitted, the default is FALSE, which disables partial seeking.
    </param>
    <returns>
      The list view item returned as a result of the seek.
    </returns>
  </ListView.Seek>
  <ListView.SelectedCount>
    <summary>
      A numeric value representing the number of items that are selected in the list view.
    </summary>
    <value>A numeric value representing the number of items that are selected in the list view.</value>
  </ListView.SelectedCount>
  <ListView.SelectItem>
    <summary>
      Select or deselect a specific item in a list view.
    </summary>
    <param name="nItem">Index of the list view items in the list view to be selected or deselected.</param>
    <param name="lSelect">Select (TRUE) or deselect (FALSE) the item in the list view. The default setting is TRUE.</param>
    <returns>
      TRUE if the list view item was selected; otherwise, FALSE.
    </returns>
  </ListView.SelectItem>
  <ListView.SelectNextItem>
    <summary>
      Select the next list view item after the currently selected item.
    </summary>
    <returns>
      TRUE if the selection was successful; otherwise, FALSE.
    </returns>
  </ListView.SelectNextItem>
  <ListView.SetBackgroundImage>
    <summary>
      Set an image as the background to the list view.
    </summary>
    <param name="uImage">
      The image to use as the background in one of the following four types.
      Object	A BitMap object
      PTR	An image handle
      String	A URL or filename as a string
      NIL	If you want to remove the background
    </param>
    <param name="dwFlags">
      Flags that can be set to create the required style. More than one style can be used by combining them with _Or()
      _Or( LVBKIF_SOURCE_HBITMAP, LVBKIF_STYLE_TILE )
      _Or( LVBKIF_SOURCE_URL, LVBKIF_STYLE_TILE )
    </param>
    <param name="xOffSet">controls the x placement of the image.</param>
    <param name="yOffSet">controls the y placement of the image.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">
        The use of this method requires either the OLE library to be linked in or a call to CoInitialize().
        If CoInitialize() is called it will also require a call to CoUnitialize() later.
      </note>
    </remarks>
  </ListView.SetBackgroundImage>
  <ListView.SetColumnFormat>
    <summary>
      Set the desired extended style for a list view.
    </summary>
    <param name="nCol">The column index number.</param>
    <param name="dwFlag">
      Flags that can be set to create the required style. More than one style can be used by combining them with _Or()
      Available styles are -
      HDF_CENTER	Allign the column to the center.
      HDF_LEFT	Allign the column to the left. This is the default.
      HDF_RIGHT	Allign the column to the right.
      HDF_BITMAP	Add a bitmap to the left of the column.
      HDF_BITMAP_ON_RIGHT	Add a bitmap to the right of the column.
      HDF_SORTDOWN	down arrow in header - For visual themes only
      HDF_SORTUP	up arrow in header - For visual themes only
    </param>
    <param name="nImage">the number of the image in the image list to display in the column header. The default is no image.</param>
    <returns>
      TRUE, if the style was enabled; otherwise, FALSE.
    </returns>
  </ListView.SetColumnFormat>
  <ListView.SetExLVStyle>
    <exclude />

  </ListView.SetExLVStyle>
  <ListView.SetExStyle>
    <summary>
      Set the desired extended style for a list view.
    </summary>
    <param name="kExStyle">The extended list view style to be set. (See the Microsoft Win32 Software Development Kit documentation for a list of valid constants.)</param>
    <param name="lNewVal">A logical value determining whether the specified extended style should be enabled (TRUE) or disabled (FALSE).</param>
    <returns>
      TRUE, if the extended style was enabled; otherwise, FALSE.
    </returns>
  </ListView.SetExStyle>
  <ListView.SetGroupName>
    <summary>
      Set the name of a list view group.
    </summary>
    <param name="iGroupId">The number of the group.</param>
    <param name="cGroupName">group name</param>
    <param name="dwAlign">
      The group alignment.
      Available options are -
      LVGA_HEADER_LEFT
      LVGA_HEADER_RIGHT
      LVGA_HEADER_CENTER
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">
        Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
        If group view is enabled only items belonging to groups are displayed.
      </note>
    </remarks>
  </ListView.SetGroupName>
  <ListView.SetGroupTextColor>
    <summary>
      Set the text color to be used for the headings when displaying a ListView control by group.
    </summary>
    <param name="oColor">The color object required.</param>
    <remarks>
      <note type="tip">
        Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
        If group view is enabled only items belonging to groups are displayed.
      </note>
    </remarks>
  </ListView.SetGroupTextColor>
  <ListView.SetItemAttributes>
    <summary>
      Update a ListViewItem object with new attributes.
    </summary>
    <param name="oListViewItem">The list view item whose attributes you want to change.</param>
    <example>
      <code language="X#">
        nCount := SELF:oDClvClaims:ItemCount
        FOR x := 1 UPTO nCount
        oLVI := SELF:oDClvClaims:GetItemAttributes(x)
        IF oLVI != NULL_OBJECT
        IF oLVI:Checked	// Using the "checkbox" property of a ListView set to YES
        nValue := oLVI:GetValue( #dSvcDate )
        SELF:oBillingsServer:GoTo( nValue )
        // do some processing here
        DO CASE
        CASE cClaims == "P"
        oLVI:StateImageIndex := 1	// ImageList was predefined in a PostInit() method
        CASE cClaims == "X"
        oLVI:StateImageIndex := 2
        CASE cClaims == "S"
        oLVI:StateImageIndex := 3
        ENDCASE
        SELF:oDClvClaims:SetItemAttributes(oLVI)
        ENDIF
        ENDIF
        NEXT x
      </code>
    </example>
  </ListView.SetItemAttributes>
  <ListView.SetItemGroupId>
    <summary>
      A logical value to determine if the group with the specified ID exists in a ListView control.
    </summary>
    <param name="uLVI">The item index or ListViewItem.</param>
    <param name="nId">The number of the group.</param>
    <remarks>
      <note type="tip">
        Listview grouping requires visual styles. If visual styles are not enabled or available these features have no effect.
        If group view is enabled only items belonging to groups are displayed.
      </note>
    </remarks>
  </ListView.SetItemGroupId>
  <ListView.SetItemPosition>
    <summary>
      Move a list view item to a new position in icon view or small icon view.
    </summary>
    <param name="nItem">The index of the list view item whose position you want to change.</param>
    <param name="oPoint">The new position of the list view item.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ListView.SetItemPosition>
  <ListView.SetSelectedColumn>
    <summary>
      Show column as selected.
    </summary>
    <param name="nIndex">The column index number.</param>
  </ListView.SetSelectedColumn>
  <ListView.SmallImageList>
    <summary>
      An image list containing small images to display for each item when the list view is displayed in list view, report view, or small icon view. The icons in this list must be defined elsewhere in
    </summary>
    <value>An image list containing small images to display for each item when the list view is displayed in list view, report view, or small icon view. The icons in this list must be defined elsewhere in</value>
    <example>
      This example would typically occur in a PostInit() method of a window. In the example below, when the ListView is populated, each item will be assigned an image index, in this case depending upon whether the player in question is active or not.
      <code language="X#">LOCAL oImageList 	AS ImageList</code><code language="X#">
        oImageList := ImageList{2, Dimension{16, 16}}
        oImageList:Add(SmIconCheck{})
        oImageList:Add(SmIconCross{})
        SELF:oDClvPlayers:SmallImageList := oImageList
      </code>
    </example>
  </ListView.SmallImageList>
  <ListView.SortItems>
    <summary>
      Sort the list view items using the user-defined sort method specified by EnableSort().
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ListView.SortItems>
  <ListView.StateImageList>
    <summary>
      An image list containing state images to display for each item in the list view.
    </summary>
    <value>An image list containing state images to display for each item in the list view.</value>
  </ListView.StateImageList>
  <ListView.TextBackgroundColor>
    <summary>
      A Color object used to paint the text background in the list view.
    </summary>
    <value>A Color object used to paint the text background in the list view.</value>
  </ListView.TextBackgroundColor>
  <ListView.TextColor>
    <summary>
      A Color object used to paint the text in the list view.
    </summary>
    <value>A Color object used to paint the text in the list view.</value>
  </ListView.TextColor>
  <ListView.TopItem>
    <summary>
      A numeric value representing the index of the topmost visible item when the list view is in list view or report view.
    </summary>
    <value>A numeric value representing the index of the topmost visible item when the list view is in list view or report view.</value>
  </ListView.TopItem>
  <ListView.TrackSelection>
    <exclude />
  </ListView.TrackSelection>
  <ListView.Update>
    <summary>
      Update a list view item.
    </summary>
    <param name="nItem">The index of the list view item to update.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </ListView.Update>
  <ListView.ViewAs>
    <summary>
      Change the current view of the list view.
    </summary>
    <param name="symView">The symbolic name of the new view for the list view. It can be one of the following values:</param>
  </ListView.ViewAs>
  <ListView.ViewBoundingBox>
    <summary>
      The bounding box that encloses all of a list view's items when in icon view or small icon view.
    </summary>
    <value>The bounding box that encloses all of a list view's items when in icon view or small icon view.</value>
  </ListView.ViewBoundingBox>
  <ListView.ViewOrigin>
    <summary>
      The Point object representing the current view origin of a list view when in icon view or small icon view.
    </summary>
    <value>The Point object representing the current view origin of a list view when in icon view or small icon view.</value>
  </ListView.ViewOrigin>
  <ListView_CompareDelegate.ctor>
    <exclude />
  </ListView_CompareDelegate.ctor>
  <ListView_CompareDelegate.BeginInvoke>
    <exclude />
  </ListView_CompareDelegate.BeginInvoke>
  <ListView_CompareDelegate.EndInvoke>
    <exclude />
  </ListView_CompareDelegate.EndInvoke>
  <ListView_CompareDelegate.Invoke>
    <exclude />
  </ListView_CompareDelegate.Invoke>
  <ListViewColumn>
    <summary>
      Create a list view column.
    </summary>
    <remarks>
      A list view column is an object that is added to a list view control. Although a list view control does not have to be displayed in column or report view, at least one column must be added in order to add items to the control.
    </remarks>
  </ListViewColumn>
  <ListViewColumn.ctor>
    <summary>
      Construct a list view column.
    </summary>
    <param name="nWidth">The character width of the list view column. If omitted, the width is 16 characters.</param>
    <param name="xColumnID">The HyperLabel object for the column or the symbolic or string name of the column.</param>
    <param name="kAlignment">Optional constant representing the alignment of the list view column. If omitted, defaults to left-alignment. </param>
    <remarks>
      Valid constants are:
      LVCFMT_RIGHT
      LVCFMT_CENTER
      LVCFMT_LEFT
    </remarks>
  </ListViewColumn.ctor>
  <ListViewColumn.Alignment>
    <summary>
      A constant representing the alignment of the list view column. One of the following values can be used:
      LVCFMT_LEFT
      LVCFMT_CENTER
      LVCFMT_RIGHT
    </summary>
    <value>
      A constant representing the alignment of the list view column. One of the following values can be used:
      LVCFMT_LEFT
      LVCFMT_CENTER
      LVCFMT_RIGHT
    </value>
  </ListViewColumn.Alignment>
  <ListViewColumn.Caption>
    <summary>
      The caption displayed in the list view column header.
    </summary>
    <value>The caption displayed in the list view column header.</value>
  </ListViewColumn.Caption>
  <ListViewColumn.Destroy>
    <inheritdoc />
  </ListViewColumn.Destroy>
  <ListViewColumn.FieldSpec>
    <summary>
      The FieldSpec object for the list view column.
    </summary>
    <value>The FieldSpec object for the list view column.</value>
  </ListViewColumn.FieldSpec>
  <ListViewColumn.GetPixWidth>
    <exclude />
  </ListViewColumn.GetPixWidth>
  <ListViewColumn.HyperLabel>
    <summary>
      The HyperLabel object for the list view column.
    </summary>
    <value>The HyperLabel object for the list view column.</value>
  </ListViewColumn.HyperLabel>
  <ListViewColumn.NameSym>
    <summary>
      The symbolic name of the list view column.
    </summary>
    <value>The symbolic name of the list view column.</value>
  </ListViewColumn.NameSym>
  <ListViewColumn.Owner>
    <exclude />
  </ListViewColumn.Owner>
  <ListViewColumn.SetPixWidth>

  </ListViewColumn.SetPixWidth>
  <ListViewColumn.Width>
    <summary>
      A numeric value that represents the character width of the list view column.
    </summary>
    <value>A numeric value that represents the character width of the list view column.</value>
    <remarks>
      <para>For autosizing, one of the following values can be used:</para>
      <list type="table">
        <item>
          <term>LVCSW_AUTOSIZE</term>
          <description>The list view column is automatically sized to the entry with the maximum width (-1).</description>
        </item>
        <item>
          <term>LVCSW_AUTOSIZE_HEADER</term>
          <description>The list view column is automatically sized to the width of its header (-2)..</description>
        </item>
      </list>
    </remarks>
  </ListViewColumn.Width>
  <ListViewColumnClickEvent>
    <summary>
      Provide information about a list view column click event, which is generated when the header of a column in a list view control is clicked.
    </summary>
    <remarks>
      The list view control must be in report view in order for this event to be generated because this is the only view in which column headers are displayed. This event returns the ListViewColumn object which was clicked. A common action to take in response to this event is to sort the items in the column.

    </remarks>
  </ListViewColumnClickEvent>
  <ListViewColumnClickEvent.ctor>
    <inheritdoc />
  </ListViewColumnClickEvent.ctor>
  <ListViewColumnClickEvent.ListViewColumn>
    <summary>
      The ListViewColumn object whose header was clicked.
    </summary>
    <value>The ListViewColumn object whose header was clicked.</value>
  </ListViewColumnClickEvent.ListViewColumn>
  <ListViewDeleteEvent>
    <summary>
      Provide information about a list view delete event, which is generated when an item in a list view control is deleted.
    </summary>
    <remarks>
      The list view control generates this event whenever one of its items is deleted. The information packaged with this Event object includes which item was deleted so that the application can process any information stored in the ListViewItem object.

    </remarks>
  </ListViewDeleteEvent>
  <ListViewDeleteEvent.ctor>
    <inheritdoc />
  </ListViewDeleteEvent.ctor>
  <ListViewDeleteEvent.ListViewItem>
    <summary>
      The ListViewItem object which was deleted.
    </summary>
    <value>The ListViewItem object which was deleted.</value>
  </ListViewDeleteEvent.ListViewItem>
  <ListViewDragEvent>
    <summary>
      Provide information about a list view drag event, which is generated when an item in a list view control is dragged.
    </summary>
    <remarks>
      The list view control generates this event whenever one of its items is dragged. The user can use either the right or the left mouse button to generate the event and can take different courses of action depending on which mouse button is currently being used.

    </remarks>
  </ListViewDragEvent>
  <ListViewDragEvent.ctor>
    <inheritdoc />
  </ListViewDragEvent.ctor>
  <ListViewDragEvent.IsLeftButton>
    <summary>
      A logical value that is TRUE if this is a left-button drag.
    </summary>
    <value>A logical value that is TRUE if this is a left-button drag.</value>
  </ListViewDragEvent.IsLeftButton>
  <ListViewDragEvent.IsRightButton>
    <summary>
      A logical value that is TRUE if this is a right-button drag.
    </summary>
    <value>A logical value that is TRUE if this is a right-button drag.</value>
  </ListViewDragEvent.IsRightButton>
  <ListViewDragEvent.ListViewItem>
    <summary>
      The ListViewItem object which is being dragged.
    </summary>
    <value>The ListViewItem object which is being dragged.</value>
  </ListViewDragEvent.ListViewItem>
  <ListViewDragEvent.Position>
    <summary>
      A Point object that describes the initial position of the drag in list view control coordinates.
    </summary>
    <value>A Point object that describes the initial position of the drag in list view control coordinates.</value>
  </ListViewDragEvent.Position>
  <ListViewEditEvent>
    <summary>
      Provide information about a list view edit event, which is generated when the label of an item in a list view control is edited.
    </summary>
    <remarks>
      The list view control generates this event whenever the label of one of its items is edited. The event is actually generated twice for any edit operation: once at the beginning of the edit and once at the end. Properties of this object can determine whether the edit is beginning or ending.

    </remarks>
  </ListViewEditEvent>
  <ListViewEditEvent.ctor>
    <inheritdoc />
  </ListViewEditEvent.ctor>
  <ListViewEditEvent.EditBeginning>
    <summary>
      A logical value that is TRUE if the edit is beginning.
    </summary>
    <value>A logical value that is TRUE if the edit is beginning.</value>
  </ListViewEditEvent.EditBeginning>
  <ListViewEditEvent.EditEnding>
    <summary>
      A logical value that is TRUE if the edit is ending.
    </summary>
    <value>A logical value that is TRUE if the edit is ending.</value>
  </ListViewEditEvent.EditEnding>
  <ListViewEditEvent.EditText>
    <summary>
      String value containing the new label text of a list view item after that item's label has been edited.
    </summary>
    <value>String value containing the new label text of a list view item after that item's label has been edited.</value>
  </ListViewEditEvent.EditText>
  <ListViewEditEvent.ListViewItem>
    <summary>
      The ListViewItem object which is being edited.
    </summary>
    <value>The ListViewItem object which is being edited.</value>
  </ListViewEditEvent.ListViewItem>
  <ListViewItem>
    <summary>
      Create a list view item.
    </summary>
    <remarks>
      A list view item describes an item in a list view control.
    </remarks>
  </ListViewItem>
  <ListViewItem.ctor>
    <summary>
      Construct a list view item.
    </summary>
  </ListViewItem.ctor>
  <ListViewItem.Checked>
    <exclude />
  </ListViewItem.Checked>
  <ListViewItem.Destroy>
    <exclude />
  </ListViewItem.Destroy>
  <ListViewItem.Disabled>
    <summary>
      A logical value that is TRUE if the image of a list view item is displayed in a disabled fashion.
    </summary>
    <value>A logical value that is TRUE if the image of a list view item is displayed in a disabled fashion.</value>
  </ListViewItem.Disabled>
  <ListViewItem.DropTarget>
    <summary>
      A logical value that is TRUE if the list view item is highlighted as the target of a drag and drop operation.
    </summary>
    <value>A logical value that is TRUE if the list view item is highlighted as the target of a drag and drop operation.</value>
  </ListViewItem.DropTarget>
  <ListViewItem.Focused>
    <summary>
      A logical value that is TRUE if the list view item is focused.
    </summary>
    <value>A logical value that is TRUE if the list view item is focused.</value>
  </ListViewItem.Focused>
  <ListViewItem.GetText>
    <summary>
      Retrieve the text label of a column.
    </summary>
    <param name="symColumnName">The symbolic name of the column whose text you want to retrieve.</param>
    <param name="nRefImageIndex">If this is a reference to a numeric variable, it gets the image index of this column.</param>
    <returns>
      The text label of the specified column.
    </returns>
    <example>
      <code language="X#">
        oLVI := SELF:oDClvClaims:GetItemAttributes( nItemNr )
        IF oLVI != NULL_OBJECT
        cCity := oLVI:GetText( #cCity )
        ENDIF
      </code>
    </example>
  </ListViewItem.GetText>
  <ListViewItem.GetValue>
    <summary>
      Retrieve the value of a column.
    </summary>
    <param name="symColumnName">The symbolic name of the column whose value you want to retrieve.</param>
    <returns>
      The value of the specified column.
    </returns>
    <example>
      <code language="X#">
        nCount := SELF:oDClvClaims:ItemCount
        FOR x := 1 UPTO nCount
        oLVI := SELF:oDClvClaims:GetItemAttributes(x)
        IF oLVI != NULL_OBJECT
        nValue := oLVI:GetValue( #nItems )
        nTotal += nValue
        ENDIF
        NEXT x
      </code>
    </example>
  </ListViewItem.GetValue>
  <ListViewItem.ImageIndex>
    <summary>
      A numeric value that represents the index of the list view item's image in the image list.
    </summary>
    <value>A numeric value that represents the index of the list view item's image in the image list.</value>
  </ListViewItem.ImageIndex>
  <ListViewItem.Indent>
    <summary>
      Sets the indentation of a ListView item.
    </summary>
    <value>Sets the indentation of a ListView item.</value>
    <remarks>
      <note type="tip">
        This is only available in detail view, and then only if the item has an associated image.
      </note>
    </remarks>
  </ListViewItem.Indent>
  <ListViewItem.ItemIndex>
    <summary>
      A numeric value that represents the index of the list view item in the list view control.
    </summary>
    <value>A numeric value that represents the index of the list view item in the list view control.</value>
  </ListViewItem.ItemIndex>
  <ListViewItem.OverlayImageIndex>
    <summary>
      A numeric value that represents the index of the list view item's overlay image in the image list.
    </summary>
    <value>A numeric value that represents the index of the list view item's overlay image in the image list.</value>
    <remarks>
      A numeric value that represents the index of the list view item's overlay image in the image list. Overlay images are images that are drawn over the item's main image. A list view can have up to four overlay images, so this value can be in the range of 1 to 4.
    </remarks>
  </ListViewItem.OverlayImageIndex>
  <ListViewItem.Selected>
    <summary>
      A logical value that is TRUE if the list view item is selected.
    </summary>
    <value>A logical value that is TRUE if the list view item is selected.</value>
  </ListViewItem.Selected>
  <ListViewItem.SetText>
    <summary>
      Set the text label of a column.
    </summary>
    <param name="cNewText">The text to be added to the column.</param>
    <param name="symColumnName">The symbolic name of the column whose text you want to set.</param>
    <param name="nImageIndex">A numeric value that represents the index of the list view’s column image in the image list.</param>
    <remarks>
      <note type="tip">
        SubItemImages only work if the ListView control has the style LVS_EX_SUBITEMIMAGES. You can set this style with ListView:SetExLVStyle(LVS_EX_SUBITEMIMAGES).
      </note>
    </remarks>
    <example>
      See the ListView:AddItem() method for sample syntax.
    </example>
  </ListViewItem.SetText>
  <ListViewItem.SetValue>
    <summary>
      Set the value of a column.
    </summary>
    <param name="uNewValue">The value to be added to the column.</param>
    <param name="symColumnName">The symbolic name of the column whose value you want to set.</param>
    <example>
      See the ListView:AddItem() method for sample syntax.
    </example>
  </ListViewItem.SetValue>
  <ListViewItem.StateImageIndex>
    <summary>
      A numeric value that represents the index of the list view item's state image in the state image list.
    </summary>
    <value>A numeric value that represents the index of the list view item's state image in the state image list.</value>
    <remarks>
      A numeric value that represents the index of the list view item's state image in the state image list. State images are images that are drawn next to the item's main image.
    </remarks>
    <example>
      <code language="X#">
        nCount := SELF:oDClvClaims:ItemCount
        FOR x := 1 UPTO nCount
        oLVI := SELF:oDClvClaims:GetItemAttributes(x)
        IF oLVI != NULL_OBJECT
        IF oLVI:Checked	// Using the "checkbox" property of a ListView set to YES
        nValue := oLVI:GetValue( #dSvcDate )
        SELF:oBillingsServer:GoTo( nValue )
        // do some processing here
        DO CASE
        CASE cClaims == "P"
        oLVI:StateImageIndex := 1	// ImageList was predefined in a PostInit() method
        CASE cClaims == "X"
        oLVI:StateImageIndex := 2
        CASE cClaims == "S"
        oLVI:StateImageIndex := 3
        ENDCASE
        SELF:oDClvClaims:SetItemAttributes(oLVI)
        ENDIF
        ENDIF
        NEXT x
      </code>
    </example>
  </ListViewItem.StateImageIndex>
  <ListViewItemEvent>
    <summary>
      Provide information about events generated when operations with list view items are taking place.
    </summary>
    <remarks>
      ListViewItem events are generated by ListView controls whenever an ListViewItem is changed, deleted or dragged.
    </remarks>
  </ListViewItemEvent>
  <ListViewItemEvent.ctor>
    <inheritdoc />
  </ListViewItemEvent.ctor>
  <ListViewItemEvent.ListViewItem>
    <summary>
      The ListViewItem object affected by the list view item event.
    </summary>
    <value>The ListViewItem object affected by the list view item event.</value>
  </ListViewItemEvent.ListViewItem>
  <ListViewKeyEvent>
    <summary>
      Provide information about a list view key event, which is generated when a key is pressed while the list view control has the input focus.
    </summary>
    <remarks>
      The list view control generates this event whenever a key is pressed while the list view control has the input focus. Information packaged with this event includes the virtual key code of the pressed key.

    </remarks>
  </ListViewKeyEvent>
  <ListViewKeyEvent.ctor>
    <inheritdoc />
  </ListViewKeyEvent.ctor>
  <ListViewKeyEvent.KeyCode>
    <summary>
      The virtual key code of the key that was pressed.
    </summary>
    <value>The virtual key code of the key that was pressed.</value>
  </ListViewKeyEvent.KeyCode>
  <ListViewMouseEvent>
    <summary>
      Provide information about a list view mouse event, which is generated when a mouse button in a list view control is clicked or double-clicked.
    </summary>
    <remarks>
      This event occurs when a mouse click or double-click occurs within the list view control. Properties of the event determine not only the position where the event occurred physically but also the event's relationship to items in the control.

    </remarks>
  </ListViewMouseEvent>
  <ListViewMouseEvent.ctor>
    <summary>Construct a ListViewMouseEvent object.</summary>
    <param name="oControlNotifyEvent">The ControlNotifyEvent that occurred when the event happened.</param>

  </ListViewMouseEvent.ctor>
  <ListViewMouseEvent.ButtonID>
    <summary>
      A constant representing which mouse button was clicked. The value can be either BUTTONLEFT or BUTTONRIGHT.
    </summary>
    <value>A constant representing which mouse button was clicked. The value can be either BUTTONLEFT or BUTTONRIGHT.</value>
  </ListViewMouseEvent.ButtonID>
  <ListViewMouseEvent.IsLeftButton>
    <summary>
      A logical value that is TRUE if this is a left-button event.
    </summary>
    <value>A logical value that is TRUE if this is a left-button event.</value>
  </ListViewMouseEvent.IsLeftButton>
  <ListViewMouseEvent.IsRightButton>
    <summary>
      A logical value that is TRUE if this is a right-button event.
    </summary>
    <value>A logical value that is TRUE if this is a right-button event.</value>
  </ListViewMouseEvent.IsRightButton>
  <ListViewMouseEvent.ListViewItem>
    <summary>
      The ListViewItem object which was clicked, if the mouse click occurred on an item; otherwise, a null object.
    </summary>
    <value>The ListViewItem object which was clicked, if the mouse click occurred on an item; otherwise, a null object.</value>
  </ListViewMouseEvent.ListViewItem>
  <ListViewMouseEvent.PointAboveClientArea>
    <summary>
      A logical value that is TRUE if the click occurred above the list view control's client area.
    </summary>
    <value>A logical value that is TRUE if the click occurred above the list view control's client area.</value>
  </ListViewMouseEvent.PointAboveClientArea>
  <ListViewMouseEvent.PointBelowClientArea>
    <summary>
      A logical value that is TRUE if the click occurred below the list view control's client area.
    </summary>
    <value>A logical value that is TRUE if the click occurred below the list view control's client area.</value>
  </ListViewMouseEvent.PointBelowClientArea>
  <ListViewMouseEvent.PointLeftOfClientArea>
    <summary>
      A logical value that is TRUE if the click occurred to the left of the list view control's client area.
    </summary>
    <value>A logical value that is TRUE if the click occurred to the left of the list view control's client area.</value>
  </ListViewMouseEvent.PointLeftOfClientArea>
  <ListViewMouseEvent.PointNowhere>
    <summary>
      A logical value that is TRUE if the click occurred inside the list view control but not on an item.
    </summary>
    <value>A logical value that is TRUE if the click occurred inside the list view control but not on an item.</value>
  </ListViewMouseEvent.PointNowhere>
  <ListViewMouseEvent.PointOnItem>
    <summary>
      A logical value that is TRUE if the click occurred on a list view item in the list view control.
    </summary>
    <value>A logical value that is TRUE if the click occurred on a list view item in the list view control.</value>
  </ListViewMouseEvent.PointOnItem>
  <ListViewMouseEvent.PointOnItemImage>
    <summary>
      A logical value that is TRUE if the click occurred on a list view item's image in the list view control.
    </summary>
    <value>A logical value that is TRUE if the click occurred on a list view item's image in the list view control.</value>
  </ListViewMouseEvent.PointOnItemImage>
  <ListViewMouseEvent.PointOnItemLabel>
    <summary>
      A logical value that is TRUE if the click occurred on a list view item's label in the list view control.
    </summary>
    <value>A logical value that is TRUE if the click occurred on a list view item's label in the list view control.</value>
  </ListViewMouseEvent.PointOnItemLabel>
  <ListViewMouseEvent.PointOnItemStateImage>
    <summary>
      A logical value that is TRUE if the click occurred on a list view item's state image in the list view control.
    </summary>
    <value>A logical value that is TRUE if the click occurred on a list view item's state image in the list view control.</value>
  </ListViewMouseEvent.PointOnItemStateImage>
  <ListViewMouseEvent.PointRightOfClientArea>
    <summary>
      A logical value that is TRUE if the click occurred to the right of the list view control's client area.
    </summary>
    <value>A logical value that is TRUE if the click occurred to the right of the list view control's client area.</value>
  </ListViewMouseEvent.PointRightOfClientArea>
  <ListViewMouseEvent.Position>
    <summary>
      A Point object that describes the position where the click occurred in list view control coordinates.
    </summary>
    <value>A Point object that describes the position where the click occurred in list view control coordinates.</value>
  </ListViewMouseEvent.Position>
  <LogFile>
    <summary>
      Provide logging facilities to Internet server applications.
    </summary>
    <remarks>
      The LogFile class provides log output and error protocol capabilities.
    </remarks>
  </LogFile>
  <LogFile.ctor>
    <summary>
      Construct a LogFile object instance.
    </summary>
    <param name="cName">Log file name. If not specified, the log file name is identical to the application name. The extension is .LOG.</param>
    <param name="lWinLogPath">Specifies whether the log file should be created within the directory specified as LogFileDirectory by Windows (TRUE), or if the log file should be created within the application's directory (FALSE). The default is FALSE.</param>
    <param name="lAppend">Flag determining whether log messages should be appended to the end of an existing log file (TRUE), or if any existing log file should be overwritten by log messages of that object (FALSE). The default is TRUE.</param>
  </LogFile.ctor>
  <LogFile.Append>
    <summary>
      A logical value that determinds whether text should be appended to the end of the file or not.
    </summary>
    <value>A logical value that determinds whether text should be appended to the end of the file or not.</value>
  </LogFile.Append>
  <LogFile.DebugMsg>
    <summary>
      Add a message to the log file.
    </summary>
    <param name="cMsg">String containing the message.</param>
    <remarks>
      This method adds a message to the log file.
    </remarks>
  </LogFile.DebugMsg>
  <LogFile.DumpError>
    <summary>
      Add the runtime error description to the log file.
    </summary>
    <param name="oError">Error object instance.</param>
    <remarks>
      This method adds the error description to the log file.
    </remarks>
    <example>
      The following common framework for CGI applications uses the LogFile class to log error messages and application progress information:
      <code language="X#">
        CLASS MyFilter INHERIT LogFile
        CLASS StdHTTPContext    INHERIT HTTPCGIContext
        FUNCTION Start
        LOCAL oCGI   AS StdHTTPContext
        LOCAL cHtml   AS STRING
        LOCAL oOldError AS USUAL
        LOCAL oError  AS USUAL
        LOCAL oLogFile AS LogFile
        oLogFile := LogFile{}
        #IFDEF __DEBUG__
        oCGI:DebugMsg("CGI application started")
        #ENDIF
        oCGI := StdHTTPContext{}
        oOldError := ErrorBlock( {|oErr|__MyError(oErr)} )
        BEGIN SEQUENCE
        cHtml := oCGI:HTTPResponse()
        IF SLen(cHtml) &gt; 0
        //
        // Default behavior, return a HTML
        //
        oCGI:Write(cHtml)
        ENDIF
        RECOVER USING oError
        cHtml := oCGI:HTTPErrorMessage(oError)
        oCGI:Write(cHtml)
        oLogFile:DumpError(oError)
        END SEQUENCE
        ErrorBlock( oOldError )
        oCGI:Close()
        #IFDEF __DEBUG__
        oCGI:DebugMsg("CGI application finished")
        #ENDIF
        RETURN
        STATIC FUNC __MyError  (oError)
        LOCAL cRepl AS STRING
        cRepl := "Module " + ProcName(1)
        cRepl += ", line " + NTrim(ProcLine(1))
        IF SLen(oError:Description) &gt; 0
        oError:Description += "(" + cRepl + ")"
        ELSE
        oError:Description := cRepl
        ENDIF
        BREAK(oError)
      </code>
    </example>
  </LogFile.DumpError>
  <LogFile.FName>
    <summary>
      String representing the file name for log messages.
    </summary>
    <value>String representing the file name for log messages.</value>
  </LogFile.FName>
  <LogFile.Log2File>
    <exclude />

  </LogFile.Log2File>
  <LogFile.ServerPath>
    <summary>
      String representing the full path specification of the Internet server application.
    </summary>
    <value>String representing the full path specification of the Internet server application.</value>
  </LogFile.ServerPath>
  <LogicFS>
    <summary>
      Create a logic field specification, which holds logic data type information.
    </summary>
  </LogicFS>
  <LogicFS.ctor>
    <summary>
      Construct a logic field specification.
    </summary>
    <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new logic field specification.</param>
  </LogicFS.ctor>
  <Menu>
    <summary>
      Create a menu. Menus consist of items which the user selects for execution; a menu item can be a string, a bitmap, or another menu.
    </summary>
    <remarks>
      Menus provide the highest level of user control within an application. At the most basic level, a menu is series of items that are displayed in the menu bar (for example, the strings "OpenFile", a question mark bitmap to indicate help, and so on.) When selected, these items perform an action—for example, open a file, exit the application, or get help.
      The items in a menu bar might also contain a submenu as another type of item. When creating a submenu, you generally specify a title (this is the text that appears in the menu bar) and the set of items that belong to that submenu (the items are displayed when the title is activated in the menu bar). For example, a submenu might have the title "File" and items named "Open," "Save," and "Exit."
      Like menus, submenus can contain strings, bitmaps, and other menus. Using submenus allows you to have multi-dimensional menus. In addition, just like any menu, they can be created from a resource entity.
      Each item on a menu is identified by a unique ID. You can then use that ID to refer to the item later in your program (for example, to disable or delete an item).
      Menu commands can be selected with the mouse or with an accelerator key, and can be added, deleted, inserted, and appended as required.
      Items on a menu can be dimmed (or grayed) to indicate that they are disabled, and they can be checked to indicate that they are enabled/selected. You can also add separators to a menu. (A separator is a single line inserted between items on a submenu to group similar commands together.)
      A menu is usually associated with an accelerator table that defines shortcuts (like Ctrl+S for File Save) and a toolbar that provides certain buttons issuing commonly used menu commands. The toolbar and accelerators are usually carried by the menu; assigning a menu to a window automatically assigns the toolbar and accelerators as well.

      Menus in X# generate the following events—MenuInitEvent, MenuSelectEvent, and MenuCommandEvent. They are dispatched to the window that owns the menu that generated the event.
      The event handler methods for these events are as follows:
      Window:MenuInit() is called before a menu is displayed.
      Window:MenuSelect() is called when a menu command is highlighted.
      When the user selects a menu command for execution, the window method that matches the menu command's name is called, if any. If there is no matching method, Window:MenuCommand() is called. Menu commands are also propagated up the window ownership hierarchy. For an in depth discussion of how command events are used, refer to the Programmer's Guide.

      In the Windows, menus are normally created in resource entities. (You can also construct menus dynamically using the Append... or Insert... methods of Menu.)
      For example, in Windows, menus can be created in a resource entity as follows:
      <code language="X#">
        RESOURCE IDM_DEMO MENU
        BEGIN
        POPUP "&amp;File"
        BEGIN
        MENUITEM "&amp;New",			IDMI_NEW
        MENUITEM "&amp;Open...",		IDMI_OPEN
        MENUITEM "&amp;Save",			IDMI_SAVE
        MENUITEM "Save &amp;As...",		IDMI_SAVEAS
        MENUITEM SEPARATOR
        MENUITEM "E&amp;xit",			IDMI_EXIT
        MENUITEM "A&amp;bout Demo...",	IDMI_ABOUT
        END
        END
      </code>
      The easiest way to construct a menu is by using the Menu Editor. It generates the resource, as illustrated in the example above, as well as the subclass used to instantiate the menu, the accelerator table, and the toolbar.
    </remarks>
  </Menu>
  <Menu.ctor>
    <summary>
      Construct a menu.
    </summary>
    <param name="xResourceID">The resource ID of the menu. If not specified, the system creates an empty menu.</param>
  </Menu.ctor>
  <Menu.Accelerator>
    <summary>
      The accelerator table to be used with this menu.
    </summary>
    <value>The accelerator table to be used with this menu.</value>
    <remarks>
      The accelerator table to be used with this menu. The Menu Editor generates code that creates an accelerator and assigns it to the menu;
      when the menu is assigned to a window, the corresponding accelerator is assigned also.
    </remarks>
  </Menu.Accelerator>
  <Menu.AddChild>
    <exclude />

  </Menu.AddChild>
  <Menu.AppendItem>
    <summary>
      Add a string to the end of this menu.
    </summary>
    <param name="nItemID">
      The ID of the new menu item.
    </param>
    <param name="xNewItem">
      One of the following:oBitmap, cNewItem, oHyperLabel, oSubmenu
    </param>
    <remarks>
      <paramref name="oBitmap" />	The bitmap to appear for the new menu item.
      <paramref name="cNewItem" />	The text to appear as the new menu item.
      <paramref name="oHyperLabel" />	The hyperlabel containing the caption to appear as the new menu item.
      <paramref name="oSubMenu" />	The menu to appear for the new menu item. It is added as a submenu; this is how to construct hierarchical menus.
      <note type="tip">
        If <paramref name="nItemID" /> is specified as MENUSEPARATOR, the second parameter is not needed.
      </note>
    </remarks>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      After adding a new item to a menu, you must reassign the menu to the owner window's Menu property for the change to take effect.
    </remarks>
  </Menu.AppendItem>
  <Menu.CheckItem>
    <summary>
      Place a check mark to the left of a specified menu item.
    </summary>
    <param name="nItemID">The ID of the menu command.</param>
    <returns>
      MF_CHECKED if checked, MF_UNCHECKED if unchecked
    </returns>
    <remarks>
      Placing a check mark next to a menu item indicates its state. The state of such a command is usually indicated to the user by the check mark, which does or does not appear depending on whether the command is on or off.
      You can later use the Menu:UncheckItem() method to remove the check mark.
      <note type="tip">You can also use this method to check a menu item on a submenu.</note>
    </remarks>
  </Menu.CheckItem>
  <Menu.Children>
    <exclude />
  </Menu.Children>
  <Menu.DeleteChild>
    <exclude />

  </Menu.DeleteChild>
  <Menu.DeleteItem>
    <summary>
      Delete an item from this menu, removing it from memory. (To delete a bitmap or string, specify an ID; to delete a submenu, specify the Menu object.)
    </summary>
    <param name="xItemIdOrMenu">The ID of the menu item to be deleted or the submenu to be deleted.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </Menu.DeleteItem>
  <Menu.Destroy>
    <summary>
      Provide a method to de-instantiate a Menu object.
    </summary>
    <remarks>
      This method can be used when a Menu object is no longer needed. Menu:Destroy() de-instantiates the Menu object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </Menu.Destroy>
  <Menu.DisableAutoUpdate>
    <exclude />
  </Menu.DisableAutoUpdate>
  <Menu.DisableItem>
    <summary>
      Disable a specified menu item (until a subsequent call to Menu:EnableItem()).
    </summary>
    <param name="nItemID">The ID of the menu item to be disabled.</param>
    <returns>
      A LONG indicating the previous state of the item. If the item does not exist the return value is -1.
    </returns>
    <remarks>
      Disabled menu items are not active and, therefore, they do not send events to their owner windows. Note that under Windows, a disabled menu command is dimmed.
      <note type="tip">You can also use this method to disable a menu item on a submenu.</note>
    </remarks>
  </Menu.DisableItem>
  <Menu.EnableItem>
    <summary>
      Enable a specified menu item that was previously disabled.
    </summary>
    <param name="nItemID">The ID of the menu item to be enabled.</param>
    <returns>
      A LONG indicating the previous state of the item. If the item does not exist the return value is -1.
    </returns>
    <remarks>
      Enabling a menu item allows it to generate events and to send the events to its owner window when the user manipulates the menu command. The dimming of disabled menu item is removed, and the menu item is restored to its normal appearance.
      By default, menu item are enabled until disabled, so there is no need to call this EnableItem() method unless DisableItem() was previously called.
      <note type="tip">You can also use this method to enable a menu item on a submenu of a menu.</note>
    </remarks>
  </Menu.EnableItem>
  <Menu.GetAutoUpdate>
    <exclude />
  </Menu.GetAutoUpdate>
  <Menu.GetSubMenu>
    <exclude />

  </Menu.GetSubMenu>
  <Menu.Handle>
    <summary>
      Return the handle for a menu.
    </summary>
    <param name="nHandleType">
      The type of handle required. Zero (0) is the only supported option and is the default if <paramref name="nHandle" /> is omitted.
    </param>
    <returns>
      A handle describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
    </remarks>
  </Menu.Handle>
  <Menu.HyperLabel>
    <summary>
      Return the hyperlabel attached to the menu item, or NIL if it has none.
    </summary>
    <param name="nItemID">The unique ID of the menu item.</param>
  </Menu.HyperLabel>
  <Menu.InsertItem>
    <summary>
      Insert a new menu item before a specified menu item.
    </summary>
    <param name="nItemID">The ID of the new menu item or the sub-menu to add (simply another Menu object). This is how to construct hierarchical menus.</param>
    <param name="xNewItem">
      One of the following:
      <paramref name="cNewItem" />	The caption of the new menu item.
      <paramref name="oHyperLabel" />	The hyperlabel containing the caption to appear as the new menu item.
      <paramref name="oBitmap" />	The bitmap to appear for the new menu item.
    </param>
    <param name="nBeforeID">The ID of the menu item before which the new item should be inserted.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      After inserting a new item to a menu, you must reassign the menu to the owner window's Menu property for the change to take effect.
    </remarks>
  </Menu.InsertItem>
  <Menu.Items>
    <exclude />
  </Menu.Items>
  <Menu.MakeMenuRtol>
    <summary>
      Reverse the order of the menu items in a menu. This is only necessary if you are using an International, bi-directional version of Windows.
    </summary>
    <param name="lRToL">If TRUE, the menu items appear from right to left; if FALSE, they appear from left to right. If omitted, the default value is TRUE.</param>
    <remarks>
      This method is only functional if you are using an International, bi-directional version of Windows.
    </remarks>
  </Menu.MakeMenuRtol>
  <Menu.MenuItems>
    <exclude />
  </Menu.MenuItems>
  <Menu.Name>
    <summary>
      Return the name, as a string, stored in the hyperlabel attached to the menu command, or NIL if there is none.
    </summary>
    <param name="nItemID">The ID of the menu item.</param>
  </Menu.Name>
  <Menu.Name>
    <summary>
      Return the symbolic name stored in the hyperlabel attached to the menu item, or NIL if there is none.
    </summary>
    <param name="nItemID">The ID of the menu item.</param>
  </Menu.Name>
  <Menu.NameSym>
    <exclude />

  </Menu.NameSym>
  <Menu.PostInit>
    <summary>
      Implement customized initialization code for the window.
    </summary>
    <remarks>
      This method is used to customize the initialization code for a dataserver.
      The customized initialization code will not be overridden by the generated default initialization code.
      A call to PostInit() is automatically generated at the end of the Init() method.
    </remarks>
  </Menu.PostInit>
  <Menu.PreInit>
    <summary>
      Implement customized initialization code for the server.
    </summary>
    <remarks>
      This method is used to customize the initialization code for a server.
      The customized initialization code will not be overridden by the generated default initialization code.
      A call to PreInit() is automatically generated at the beginning of the Init() method.
      The default implementation of PostInit() in this class is empty.
      <note type="tip">
        In .Net it is normally not allowed or recommended to run code in a class before the parent constructor is called.
        The generated code in the Window editor does this (it calls PreInit before the SUPER() call). We advise you to
        be very careful not to touch protected instance variables inherited from parent classes, since these may not be
        initialized and/or values that you assign to them may be overwritten in the constructor of the parent class.
      </note>
    </remarks>
  </Menu.PreInit>
  <Menu.RegisterItem>
    <summary>
      Register the hyperlabel for this menu item.
    </summary>
    <param name="nItemID">The ID of the menu item.</param>
    <param name="oHyperLabel">The hyperlabel to be registered for the menu item.</param>
    <param name="hParentMenu">The handle of the menu item being registered. This parameter is only required if the registered item contains a submenu.</param>
    <param name="nPosition">
      The offset of menu item being registered.
      The offset of the submenu of the menu item being registered. (For example, if a menu contains the items 'File', 'Edit', and 'View' and the offset is 1, the Edit submenu will be registered with the Edit menu item.) This parameter is only required if the registered item contains a submenu.
    </param>
  </Menu.RegisterItem>
  <Menu.SetAutoUpdate>
    <summary>
      Append a section to a specified submenu on a menu. This section automatically keeps track of what MDI child windows are currently open and displays their names on the submenu.
    </summary>
    <param name="nMenuNumber">The offset of the submenu to which the new section should be appended. (For example, if a menu contains the items 'File', 'Edit' and 'View' and the offset is 1, the new section is appended to the 'Edit' submenu.) The default is 0 (the first menu item).</param>
    <remarks>
      In MDI applications, there is typically one menu which contains the titles of any currently open MDI child windows.
      After updating a new section, you must reassign the menu to the owner window's Menu property for the change to take effect.
    </remarks>
  </Menu.SetAutoUpdate>
  <Menu.SetParent>
    <exclude />

  </Menu.SetParent>
  <Menu.ShowAsPopup>
    <summary>
      Display menu as a local pop-up menu.
    </summary>
    <param name="oOwner">The window that owns the local pop-up menu.</param>
    <param name="oPoint">The point, relative to the client area, at which to display the menu. If omitted, the menu is displayed at the current mouse cursor position.</param>
    <param name="kButton">The button constant that indicates which button the menu will track. Values can be PM_LEFTBUTTON and PM_RIGHTBUTTON. If omitted, the menu tracks the left mouse button.</param>
    <param name="kAlignment">The alignment constant that indicates how the menu will be aligned with respect to the display position of the menu. Values can be PM_ALIGNCENTER, PM_ALIGNLEFT, and PM_ALIGNRIGHT. If omitted, the menu is aligned to the left of the display position.</param>
    <param name="oNotOverlap">** missing parameter documentation **</param>
    <returns>
      TRUE if the menu was displayed successfully; otherwise, FALSE.
    </returns>
  </Menu.ShowAsPopup>
  <Menu.ToolBar>
    <summary>
      The toolbar that corresponds to the menu.
    </summary>
    <value>The toolbar that corresponds to the menu.</value>
    <remarks>
      The toolbar that corresponds to the menu. The Menu Editor generates code that creates a toolbar and assigns it to the menu; when the menu is assigned to a window, the corresponding toolbar is assigned also.
    </remarks>
  </Menu.ToolBar>
  <Menu.UncheckItem>
    <summary>
      Remove the check mark (that the user sees) from the menu item. Typically, you do this in response to a MenuCommandEvent on that item.
    </summary>
    <param name="nItemID">The ID of the menu item.</param>
    <returns>
      TRUE if removed successfully; otherwise, FALSE.
    </returns>
  </Menu.UncheckItem>
  <Menu.UnregisterItem>
    <summary>
      Unregister the hyperlabel for this menu item.
    </summary>
    <param name="nItemID">The ID of the menu item.</param>
  </Menu.UnregisterItem>
  <MenuCommandEvent>
    <summary>
      Provide information about a MenuCommandEvent, generated when the user executes a menu item, either directly or through the use of accelerator keys.
    </summary>
    <remarks>
      MenuCommandEvent events are passed to Window:MenuCommand(), which dispatches the method indicated in the menu item's hyperlabel.
    </remarks>
  </MenuCommandEvent>
  <MenuCommandEvent.ctor>
    <inheritdoc />
  </MenuCommandEvent.ctor>
  <MenuCommandEvent.AsString>
    <summary>
      Return the caption of the selected menu item.
    </summary>
    <remarks>
      The caption is provided by the menu item resource.
    </remarks>
  </MenuCommandEvent.AsString>
  <MenuCommandEvent.HyperLabel>
    <summary>
      The hyperlabel connected to the menu item that generated this MenuCommandEvent.
    </summary>
    <value>The hyperlabel connected to the menu item that generated this MenuCommandEvent.</value>
    <remarks>
      The hyperlabel connected to the menu item that generated this MenuCommandEvent. From the hyperlabel, you can retrieve additional information about the menu item.
    </remarks>
  </MenuCommandEvent.HyperLabel>
  <MenuCommandEvent.ItemID>
    <summary>
      A numeric value representing the ID of the menu item that generated this MenuCommandEvent.
    </summary>
    <value>A numeric value representing the ID of the menu item that generated this MenuCommandEvent.</value>
  </MenuCommandEvent.ItemID>
  <MenuCommandEvent.Menu>
    <summary>
      The Menu object that generated this MenuCommandEvent.
    </summary>
    <value>The Menu object that generated this MenuCommandEvent.</value>
  </MenuCommandEvent.Menu>
  <MenuCommandEvent.Name>
    <summary>
      A string representing the name stored in the hyperlabel of the menu item that generated this MenuCommandEvent.
    </summary>
    <value>A string representing the name stored in the hyperlabel of the menu item that generated this MenuCommandEvent.</value>
  </MenuCommandEvent.Name>
  <MenuCommandEvent.NameSym>
    <summary>
      A symbol representing the name stored in the hyperlabel of the menu item that generated this MenuCommandEvent.
    </summary>
    <value>A symbol representing the name stored in the hyperlabel of the menu item that generated this MenuCommandEvent.</value>
  </MenuCommandEvent.NameSym>
  <MenuInitEvent>
    <summary>
      Provide information about a MenuInitEvent, generated when the user first activates a menu for the first time.
    </summary>
    <remarks>
      The system generates MenuInitEvent objects before displaying a pull-down menu, allowing the application to initialize items before they are displayed. For example, you can want to dim items that the program is not yet in a position to handle, or you may want to check or uncheck certain items. MenuInitEvent events are passed to Window:MenuInit().
      If you change the menu using the Menu access, you do not need to call the window's Menu assign. When the menu is displayed, it is the modified version.
      Accelerator keys generate MenuInitEvent events if the accelerator invokes a submenu.
    </remarks>
  </MenuInitEvent>
  <MenuInitEvent.ctor>
    <inheritdoc />
  </MenuInitEvent.ctor>
  <MenuInitEvent.Menu>
    <summary>
      The Menu object that generated this MenuInitEvent (and is about to be displayed for initialization).
    </summary>
    <value>The Menu object that generated this MenuInitEvent (and is about to be displayed for initialization).</value>
  </MenuInitEvent.Menu>
  <MenuSelectEvent>
    <summary>
      Provide information about a MenuSelectEvent, generated whenever a menu item is highlighted on a menu (menu items are highlighted as the user moves either the mouse or the highlight bar up or down a menu).
    </summary>
    <remarks>
      MenuSelectEvent events enable the program to anticipate that the user can activate an item or to provide status information.
      <note type="tip">When a menu item is actually selected (and therefore executed), the system generates a MenuCommandEvent.</note>
      When an accelerator key is executed, a MenuSelectEvent, immediately followed by a MenuCommandEvent, is generated to simulate the mouse route—the various selections that you have to pass over to choose the option. (Thus, the accelerator generates the same event as those generated with a mouse.)
    </remarks>
    <example>
      The following example prints a different help line in the status bar, depending on which command is currently selected:
      <code language="X#">
        CLASS MyWindow INHERIT TopAppWindow
        METHOD MenuSelect(oMSE) CLASS MyWindow
        LOCAL j := oMSE:ItemID
        DO CASE
        CASE j = IDMI_RED
        TextPrint("Select the Red Pen", Point{10,10})
        CASE j = IDMI_GREEN
        TextPrint("Select the Green Pen", Point{10,10})
        CASE j = IDMI_BLUE
        TextPrint("Select the Blue Pen", Point{10,10})
        ENDCASE
      </code>
    </example>
  </MenuSelectEvent>
  <MenuSelectEvent.ctor>
    <inheritdoc />
  </MenuSelectEvent.ctor>
  <MenuSelectEvent.AsString>
    <summary>
      Return the caption of the selected menu item.
    </summary>
    <remarks>
      The caption is provided by the menu item resource.
    </remarks>
  </MenuSelectEvent.AsString>
  <MenuSelectEvent.HyperLabel>
    <summary>
      The hyperlabel connected to the menu that generated this MenuSelectEvent. From the hyperlabel, you can retrieve additional information about the menu.
    </summary>
    <value>The hyperlabel connected to the menu that generated this MenuSelectEvent. From the hyperlabel, you can retrieve additional information about the menu.</value>
  </MenuSelectEvent.HyperLabel>
  <MenuSelectEvent.ItemID>
    <summary>
      A numeric value representing the ID of the menu item that generated this MenuSelectEvent.
    </summary>
    <value>A numeric value representing the ID of the menu item that generated this MenuSelectEvent.</value>
  </MenuSelectEvent.ItemID>
  <MenuSelectEvent.Menu>
    <summary>
      The Menu object that generated this MenuSelectEvent.
    </summary>
    <value>The Menu object that generated this MenuSelectEvent.</value>
  </MenuSelectEvent.Menu>
  <MenuSelectEvent.Name>
    <summary>
      A string representing the name stored in the hyperlabel of the menu items that generated this MenuSelectEvent.
    </summary>
    <value>A string representing the name stored in the hyperlabel of the menu items that generated this MenuSelectEvent.</value>
  </MenuSelectEvent.Name>
  <MenuSelectEvent.NameSym>
    <summary>
      A symbol representing the name stored in the hyperlabel of the menu items that generated this MenuSelectEvent.
    </summary>
    <value>A symbol representing the name stored in the hyperlabel of the menu items that generated this MenuSelectEvent.</value>
  </MenuSelectEvent.NameSym>
  <MinMaxInfoEvent>
    <summary>
      Provide information about a MinMaxInfoEvent, generated whenever the size or position of a window is about to change. The MinMaxInfoEvent object describes the maximised width, height and position of the maximised window in addition to the minimum and maximum height and width of the window.
    </summary>
    <remarks>
      The MinMaxInfoEvent event contains information about the size and placement of a window. It also allows these default values to be overridden by assigning new values.
    </remarks>
  </MinMaxInfoEvent>
  <MinMaxInfoEvent.ctor>
    <inheritdoc />
  </MinMaxInfoEvent.ctor>
  <MinMaxInfoEvent.MaxPosition>
    <exclude />
  </MinMaxInfoEvent.MaxPosition>
  <MinMaxInfoEvent.MaxSize>
    <exclude />
  </MinMaxInfoEvent.MaxSize>
  <MinMaxInfoEvent.MaxTrackSize>
    <exclude />
  </MinMaxInfoEvent.MaxTrackSize>
  <MinMaxInfoEvent.MinTrackSize>
    <exclude />
  </MinMaxInfoEvent.MinTrackSize>
  <ModelessDialog>
    <summary>
      Create a modeless dialog window (also commonly referred to as a dialog box), which are used to present a collection of controls for user input and output.
    </summary>
  </ModelessDialog>
  <ModelessDialog.ctor>
    <summary>
      Create a modeless dialog box.
    </summary>
    <param name="oOwner">The window that owns the modeless dialog box.</param>
    <param name="xResourceID">The resource ID of the modeless dialog box.</param>
  </ModelessDialog.ctor>
  <ModelessDialog.Destroy>
    <summary>
      Provide a method to de-instantiate a ModelessDialog object.
    </summary>
    <remarks>
      This method can be used when a ModelessDialog object is no longer needed. ModelessDialog:Destroy() de-instantiates the ModelessDialog object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </ModelessDialog.Destroy>
  <MoneyFS>
    <summary>
      Create a money field specification, which holds money data type information.
    </summary>
  </MoneyFS>
  <MoneyFS.ctor>
    <summary>
      Construct a money field specification.
    </summary>
    <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new money field specification.</param>
    <param name="uLength">The length of the field. If not specified, the default is 12.</param>
    <param name="uDecimals">The number of decimals in the field. If not specified, the default is 2.</param>
  </MoneyFS.ctor>
  <MonthCalendar>
    <summary>
      Encapsulate a standalone MonthCalendar control.
    </summary>
    <remarks>
      The MonthCalendar control displays a month calendar allowing the user to browse through months and to select a specific date.
      <note type="tip">Version 4.70 or higher of COMCTL32.DLL is needed to use the MonthCalendar control.</note>
    </remarks>
  </MonthCalendar>
  <MonthCalendar.ctor>
    <summary>
      Construct a MonthCalendar object.
    </summary>
    <param name="oOwner">The window that owns the MonthCalendar object.</param>
    <param name="xID">The unique ID for the MonthCalendar object (between 1 and 8000).</param>
    <param name="oPoint">The origin of the MonthCalendar object in canvas coordinates.</param>
    <param name="oDimension">The dimension of the MonthCalendar object in canvas coordinates.</param>
    <param name="dwStyle">
      Constant representing the style of the MonthCalendar object, specified either by a X# style constant or a Windows API style constant. Styles can be combined using the _Or() operator.
    </param>
    <param name="lDataAware">A logical value that is TRUE if the MonthCalendar object is data-aware; otherwise, FALSE. The default is TRUE.</param>
    <param name="nResourceID">The resource ID of the MonthCalendar object.</param>
    <remarks>
      <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular style constant.</note>
    </remarks>
  </MonthCalendar.ctor>
  <MonthCalendar.BackgroundColor>
    <summary>
      A Color object describing the background color (between the months) of the MonthCalendar control.
    </summary>
    <value>A Color object describing the background color (between the months) of the MonthCalendar control.</value>
  </MonthCalendar.BackgroundColor>
  <MonthCalendar.Dispatch>
    <inheritdoc />
  </MonthCalendar.Dispatch>
  <MonthCalendar.FirstDayOfWeek>
    <summary>
      An integer specifying the first day of the week (Monday=0, Tuesday=1, etc.).
    </summary>
    <value>An integer specifying the first day of the week (Monday=0, Tuesday=1, etc.).</value>
  </MonthCalendar.FirstDayOfWeek>
  <MonthCalendar.MaxSelCount>
    <summary>
      The maximum number of days that can be selected in the MonthCalendar control.
    </summary>
    <value>The maximum number of days that can be selected in the MonthCalendar control.</value>
    <remarks>
      The maximum number of days that can be selected in the MonthCalendar control.
      <note type="tip">This property is only valid for MonthCalendar controls that have the MultiSelect style (MCS_MULTISELECT) turned on.</note>
    </remarks>
  </MonthCalendar.MaxSelCount>
  <MonthCalendar.MonthBackgroundColor>
    <summary>
      A Color object describing the background color (within the month area) of the MonthCalendar control.
    </summary>
    <value>A Color object describing the background color (within the month area) of the MonthCalendar control.</value>
  </MonthCalendar.MonthBackgroundColor>
  <MonthCalendar.MonthDelta>
    <summary>
      The number of months the control scrolls when the user clicks the scroll button.
    </summary>
    <value>The number of months the control scrolls when the user clicks the scroll button.</value>
  </MonthCalendar.MonthDelta>
  <MonthCalendar.Range>
    <summary>
      A DateRange object setting the minimum and maximum allowable dates for the MonthCalendar control.
    </summary>
    <value>A DateRange object setting the minimum and maximum allowable dates for the MonthCalendar control.</value>
  </MonthCalendar.Range>
  <MonthCalendar.Selection>
    <summary>
      The currently selected date. In the case of a multiple selection, the starting date is returned.
    </summary>
    <value>The currently selected date. In the case of a multiple selection, the starting date is returned.</value>
  </MonthCalendar.Selection>
  <MonthCalendar.SelectionRange>
    <summary>
      A DateRange object representing the currently selected date range.
    </summary>
    <value>A DateRange object representing the currently selected date range.</value>
  </MonthCalendar.SelectionRange>
  <MonthCalendar.TextColor>
    <summary>
      A Color object specifying the text color of the MonthCalendar control.
    </summary>
    <value>A Color object specifying the text color of the MonthCalendar control.</value>
  </MonthCalendar.TextColor>
  <MonthCalendar.TextValue>
    <summary>
      The current date selection in string format.
    </summary>
    <value>The current date selection in string format.</value>
    <remarks>
      The current date selection in string format. This is needed internally to allow the binding of a MonthCalendar control to a database field.
    </remarks>
  </MonthCalendar.TextValue>
  <MonthCalendar.TitleBackgroundColor>
    <summary>
      A Color object specifying the title background color of the MonthCalendar control.
    </summary>
    <value>A Color object specifying the title background color of the MonthCalendar control.</value>
  </MonthCalendar.TitleBackgroundColor>
  <MonthCalendar.TitleTextColor>
    <summary>
      A Color object specifying the title text color of the MonthCalendar control.
    </summary>
    <value>A Color object specifying the title text color of the MonthCalendar control.</value>
  </MonthCalendar.TitleTextColor>
  <MonthCalendar.Today>
    <summary>
      The date specified as "today" for the MonthCalendar control.
    </summary>
    <value>The date specified as "today" for the MonthCalendar control.</value>
  </MonthCalendar.Today>
  <MonthCalendar.TrailingTextColor>
    <summary>
      A Color object describing the color of the trailing and leading days, i.e., those not belonging to the current month, of the MonthCalendar control.
    </summary>
    <value>A Color object describing the color of the trailing and leading days, i.e., those not belonging to the current month, of the MonthCalendar control.</value>
  </MonthCalendar.TrailingTextColor>
  <MonthCalendar.Value>
    <summary>
      The currently selected date.
    </summary>
    <value>The currently selected date.</value>
  </MonthCalendar.Value>
  <MonthCalSelectionEvent>
    <summary>
      Provide information about a monthcalendar selection event, which is generated when a user selects a date in a MonthCalendar control.
    </summary>
    <remarks>
      This event occurs when a date is selected in a MonthCalendar control

    </remarks>
  </MonthCalSelectionEvent>
  <MonthCalSelectionEvent.ctor>
    <inheritdoc />
  </MonthCalSelectionEvent.ctor>
  <MonthCalSelectionEvent.Explicit>
    <summary>
      A Logic value indicating when the user made an explicit date selection within a month calendar control
    </summary>
    <value>A Logic value indicating when the user made an explicit date selection within a month calendar control</value>
  </MonthCalSelectionEvent.Explicit>
  <MonthCalSelectionEvent.Selection>
    <summary>
      A date value indicating the date the user selected in the control
    </summary>
    <value>A date value indicating the date the user selected in the control</value>
  </MonthCalSelectionEvent.Selection>
  <MouseEvent>
    <summary>
      Provide information about the location of the mouse, as well as which mouse button was pressed, when a MouseEvent occurred.
    </summary>
    <remarks>
      MouseEvent events are passed to the following event handlers of class Window: MouseButtonDown(), MouseButtonUp(), MouseButtonDoubleClick(), MouseMove(), and MouseDrag().
    </remarks>
  </MouseEvent>
  <MouseEvent.ctor>
    <inheritdoc />
  </MouseEvent.ctor>
  <MouseEvent.ButtonID>
    <summary>
      One of the following constants indicating the mouse button the user pressed when a MouseEvent was generated:
    </summary>
    <value>One of the following constants indicating the mouse button the user pressed when a MouseEvent was generated:</value>
    <remarks>
      One of the following constants indicating the mouse button the user pressed when a MouseEvent was generated:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>BUTTONCONTROL</term>
          <description>The Control key on the keyboard was being used.</description>
        </item>
        <item>
          <term>BUTTONLEFT</term>
          <description>The left mouse button was being used.</description>
        </item>
        <item>
          <term>BUTTONMIDDLE</term>
          <description>The middle mouse button was being used.</description>
        </item>
        <item>
          <term>BUTTONRIGHT</term>
          <description>The right mouse button was being used.</description>
        </item>
        <item>
          <term>BUTTONSHIFT</term>
          <description>The Shift key on the keyboard was being pressed.</description>
        </item>
        <item>
          <term>BUTTONX1</term>
          <description>The ButtonX1 on a five button mouse was being used.</description>
        </item>
        <item>
          <term>BUTTONX2</term>
          <description>The ButtonX2 on a five button mouse was being used.</description>
        </item>
      </list>
      The MouseEvent:ButtonID access method does not work in Window:MouseDrag() event handlers if the user presses more than one mouse button simultaneously. To handle with multiple buttons, invoke the methods of MouseEvent (like IsLeftButton() and IsRightButton()), which report on individual buttons.
    </remarks>
  </MouseEvent.ButtonID>
  <MouseEvent.Height>
    <exclude />
  </MouseEvent.Height>
  <MouseEvent.IsControlButton>
    <summary>
      A logical value indicating whether the user pressed the Control key when a MouseEvent was generated.
    </summary>
    <value>A logical value indicating whether the user pressed the Control key when a MouseEvent was generated.</value>
    <remarks>
      A logical value indicating whether the user pressed the Control key when a MouseEvent was generated. If yes, TRUE is returned; otherwise, FALSE.
    </remarks>
  </MouseEvent.IsControlButton>
  <MouseEvent.IsLeftButton>
    <summary>
      A logical value indicating whether the user pressed the left mouse button when a MouseEvent was generated.
    </summary>
    <value>A logical value indicating whether the user pressed the left mouse button when a MouseEvent was generated.</value>
    <remarks>
      A logical value indicating whether the user pressed the left mouse button when a MouseEvent was generated. If yes, TRUE is returned; otherwise, FALSE.
    </remarks>
  </MouseEvent.IsLeftButton>
  <MouseEvent.IsMiddleButton>
    <summary>
      A logical value indicating whether the user pressed the middle mouse button when a MouseEvent was generated.
    </summary>
    <value>A logical value indicating whether the user pressed the middle mouse button when a MouseEvent was generated.</value>
    <remarks>
      A logical value indicating whether the user pressed the middle mouse button when a MouseEvent was generated. If yes, TRUE is returned; otherwise, FALSE.
    </remarks>
  </MouseEvent.IsMiddleButton>
  <MouseEvent.IsRightButton>
    <summary>
      A logical value indicating whether the user pressed the right mouse button when a MouseEvent was generated.
    </summary>
    <value>A logical value indicating whether the user pressed the right mouse button when a MouseEvent was generated.</value>
    <remarks>
      A logical value indicating whether the user pressed the right mouse button when a MouseEvent was generated. If yes, TRUE is returned; otherwise, FALSE.
    </remarks>
  </MouseEvent.IsRightButton>
  <MouseEvent.IsShiftButton>
    <summary>
      A logical value indicating whether the user pressed the Shift key when a MouseEvent was generated.
    </summary>
    <value>A logical value indicating whether the user pressed the Shift key when a MouseEvent was generated.</value>
    <remarks>
      A logical value determining whether the user pressed the Shift key when a MouseEvent was generated. If yes, TRUE is returned; otherwise, FALSE
    </remarks>
  </MouseEvent.IsShiftButton>
  <MouseEvent.IsXButton1>
    <summary>
      A logical value determining whether the user pressed the XButton1 causing the MouseEvent to be generated.
    </summary>
    <value>A logical value determining whether the user pressed the XButton1 causing the MouseEvent to be generated.</value>
    <remarks>
      Five button mice have Left, Middle, Right, XButton1and XButton2.
      A logical value determining whether the user pressed the XButton1 causing the MouseEvent to be generated. If yes, TRUE is returned; otherwise, FALSE
    </remarks>
  </MouseEvent.IsXButton1>
  <MouseEvent.IsXButton2>
    <summary>
      A logical value determining whether the user pressed the XButton2 causing the MouseEvent to be generated.
    </summary>
    <value>A logical value determining whether the user pressed the XButton2 causing the MouseEvent to be generated.</value>
    <remarks>
      Five button mice have Left, Middle, Right, XButton1and XButton2.
      A logical value determining whether the user pressed the XButton2 causing the MouseEvent to be generated. If yes, TRUE is returned; otherwise, FALSE
    </remarks>
  </MouseEvent.IsXButton2>
  <MouseEvent.Position>
    <summary>
      A point, in canvas coordinates, representing the position of the mouse pointer on the window when this MouseEvent was generated.
    </summary>
    <value>A point, in canvas coordinates, representing the position of the mouse pointer on the window when this MouseEvent was generated.</value>
  </MouseEvent.Position>
  <MouseEvent.Size>
    <exclude />
  </MouseEvent.Size>
  <MouseEvent.Width>
    <exclude />
  </MouseEvent.Width>
  <MoveEvent>
    <summary>
      Provide information about a MoveEvent, used to notify the program that the user is in the process of moving a window.
    </summary>
    <remarks>
      MoveEvent events are generated when the user or a program moves a window around on the screen. MoveEvent events are passed to Window:Move().
      Although most programs are not interested in MoveEvent events; although it would be rather unusual behavior, a program might wish to anchor the window in some specific area of the screen, for instance.
    </remarks>
  </MoveEvent>
  <MoveEvent.ctor>
    <inheritdoc />
  </MoveEvent.ctor>
  <MoveEvent.Origin>
    <summary>
      A point representing the new location of a window after a MoveEvent was generated.
    </summary>
    <value>A point representing the new location of a window after a MoveEvent was generated.</value>
    <remarks>
      A point representing the new location of a window after a MoveEvent was generated.
      For top application windows and shell windows, the point is given in desktop coordinates. For all other windows, it is given in the owner window's canvas coordinates. In this sense, the desktop owns the top window.
    </remarks>
  </MoveEvent.Origin>
  <MultiLineEdit>
    <summary>
      Create a multiline edit control for displaying and entering information to a variable or field in a server. Multiline edit controls may be bound to a data server field of any type (character, date, logical, numeric, or memo).
    </summary>
    <remarks>
      Some of the features provided by multiline edit controls include scrolling lines and pages and retrieving specified lines (in addition to the simple editing primitives inherited from the Edit class).
    </remarks>
    <example>
      This example creates and initializes a multiline edit control:
      <code language="X#">
        CLASS MyWindow INHERIT TopAppWindow
        HIDDEN oMyMLE AS OBJECT
        METHOD Init() CLASS MyWindow
        SUPER:Init()
        p := Point{10, 10}
        d := Dimension{100, 100}
        oMyMLE := MultiLineEdit{SELF,100,p,d}
        SELF:Show()
        oMyMLE:Show()
        oMyMLE:TextValue := "New York" + _CHR(10) + "Boston"
      </code>

      In Windows, multiline edit controls are equivalent to an edit control created with the ES_MULTILINE style. These are normally specified in the resource entity like this:
      <code language="X#">
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 80
        STYLE WS_POPUP | WS_DLGFRAME
        BEGIN
        EDITTEXT	IDE_TEXT,10,10,90,45, ES_MULTILINE
        DEFPUSHBUTTON "OK"	 IDB_OK,64,60,32,14, WS_GROUP
        END
      </code>
    </example>
  </MultiLineEdit>
  <MultiLineEdit.ctor>
    <summary>
      Construct a multiline edit control.
    </summary>
    <param name="oOwner">The window that owns the multiline edit control.</param>
    <param name="xID">The unique ID of the multiline edit control (between 1 and 8000).</param>
    <param name="oPoint">The origin of the multiline edit control in canvas coordinates.</param>
    <param name="oDimension">The dimension of the multiline edit control in canvas coordinates.</param>
    <param name="kStyle">The style of the multiline edit control, specified as one of the following constants listed below.</param>
    <param name="nResourceID">The resource ID of the multiline edit control.</param>
    <remarks>
      <include file="Gui.xml" path="doc/EditConstants/*" />
    </remarks>
  </MultiLineEdit.ctor>
  <MultiLineEdit.CurrentText>
    <summary>
      A string representing the text currently appearing in the edit box. The MultiLineEdit:CurrentText assign also changes the MultiLineEdit:TextValue and MultiLineEdit:Value when the focus shifts to another control.
    </summary>
    <value>A string representing the text currently appearing in the edit box. The MultiLineEdit:CurrentText assign also changes the MultiLineEdit:TextValue and MultiLineEdit:Value when the focus shifts to another control.</value>
  </MultiLineEdit.CurrentText>
  <MultiLineEdit.Destroy>
    <summary>
      Provide a method to de-instantiate a MultiLineEdit object.
    </summary>
    <remarks>
      This method can be used when a MultiLineEdit object is no longer needed. MultiLineEdit:Destroy() de-instantiates the MultiLineEdit object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </MultiLineEdit.Destroy>
  <MultiLineEdit.Dispatch>
    <inheritdoc />
  </MultiLineEdit.Dispatch>
  <MultiLineEdit.GetLine>
    <summary>
      Get a line of text—specified by position—in a multiline edit control.
    </summary>
    <param name="nLineNumber">
      The position in the multiline edit control at which the desired string is located. Specify one of the following values:
      Value	Position
      0	The current line in the multiline edit control (that is, the line currently containing the text cursor). This is the default.
      1	The first line in the multiline edit control.
      n	The nth line in the multiline edit control.
    </param>
    <param name="nMaxLength">The maximum number of characters to extract from the specified line. The default is to return the entire line, including any actual blanks in the text but excluding any blanks displayed due to word-wrapping.</param>
    <returns>
      The text of the specified line.
    </returns>
  </MultiLineEdit.GetLine>
  <MultiLineEdit.GetLineLength>
    <summary>
      Get the length of a line of text—specified by position—in a multiline edit control.
    </summary>
    <param name="nLineNumber">
      The position in the multiline edit control at which the desired string is located. Specify one of the following values:
      Value	Position
      0	The current line in the multiline edit control (that is, the line currently containing the text cursor). This is the default.
      1	The first line in the multiline edit control.
      n	The nth line in the multiline edit control.
    </param>
    <returns>
      The length of the specified line.
    </returns>
  </MultiLineEdit.GetLineLength>
  <MultiLineEdit.LineCount>
    <summary>
      A numeric value representing the number of lines in a multiline edit control.
    </summary>
    <value>A numeric value representing the number of lines in a multiline edit control.</value>
  </MultiLineEdit.LineCount>
  <MultiLineEdit.LineDown>
    <summary>
      Move the cursor from its current position in a multiline edit control down a single line.
    </summary>
  </MultiLineEdit.LineDown>
  <MultiLineEdit.LineUp>
    <summary>
      Move the cursor from its current position in a multiline edit control up a single line.
    </summary>
  </MultiLineEdit.LineUp>
  <MultiLineEdit.PageDown>
    <summary>
      Move the cursor from its current position in a multiline edit control down a single page length.
    </summary>
    <remarks>
      A page is the number of lines that fits in the current multiline edit control in the current font.
    </remarks>
  </MultiLineEdit.PageDown>
  <MultiLineEdit.PageUp>
    <summary>
      Move the cursor from its current position in a multiline edit control up a single page length.
    </summary>
    <remarks>
      A page is the number of lines that fits in the current multiline edit control in the current font.
    </remarks>
  </MultiLineEdit.PageUp>
  <MultiLineEdit.ScrollHorizontal>
    <summary>
      Scroll the text in a multiline edit control a specified number of characters to the right or left.
    </summary>
    <param name="nChars">The number of characters to scroll. Positive values move the cursor to the right; negative values to the left. The default is no movement.</param>
  </MultiLineEdit.ScrollHorizontal>
  <MultiLineEdit.ScrollVertical>
    <summary>
      Scroll the text in a multiline edit control a specified number of characters up or down.
    </summary>
    <param name="nLines">The number of lines to scroll. Positive values move the cursor up; negative values down. The default is no movement, or zero (0) lines.</param>
  </MultiLineEdit.ScrollVertical>
  <MultiLineEdit.Value>
    <summary>
      MultiLineEdit:Value contains the text stored after the previous edit operation. The MultiLineEdit:TextValue assign also changes the MultiLineEdit:CurrentText, MultiLineEdit:TextValue, and MultiLineEdit:ValueChanged.
    </summary>
    <value>MultiLineEdit:Value contains the text stored after the previous edit operation. The MultiLineEdit:TextValue assign also changes the MultiLineEdit:CurrentText, MultiLineEdit:TextValue, and MultiLineEdit:ValueChanged.</value>
  </MultiLineEdit.Value>
  <MultiMediaContainer>
    <summary>
      Implement a container window for displaying multimedia data.
    </summary>
    <remarks>
      The MultiMediaContainer class displays a child window that is capable of displaying various types of multimedia data, such as bitmaps, video, and audio files. MultiMediaContainer objects can be used data-bound, displaying multimedia data from a database, such as Jasmine. They can also be used standalone.
    </remarks>
  </MultiMediaContainer>
  <MultiMediaContainer.ctor>
    <summary>
      Instantiate a MultiMediaContainer control.
    </summary>
    <param name="oOwner">The window that owns the control.</param>
    <param name="xID">The unique ID of the control (between 1 and 8000).</param>
    <param name="oPoint">The origin of the control in canvas coordinates.</param>
    <param name="oDimension">The dimension of the control in canvas coordinates.</param>
    <param name="nResourceID">The resource ID of the control.</param>
    <remarks>
      This method instantiates a MultiMediaContainer object. Depending on the file assigned to it, the MultiMediaContainer object tries to display the multimedia data. In the case of video or audio data, it creates an MCI child window. For images, X# image support attempts to display the image in the control's client area.
    </remarks>
  </MultiMediaContainer.ctor>
  <MultiMediaContainer.Destroy>
    <summary>
      Provide a method to de-instantiate a MultiMediaContainer object.
    </summary>
    <remarks>
      This method can be used when a MultiMediaContainer object is no longer needed. MultiMediaContainer:Destroy() de-instantiates the MultiMediaContainer object, and allows you to close and free any resources that were opened or created by the object without waiting for the garbage collector.
    </remarks>
  </MultiMediaContainer.Destroy>
  <MultiMediaContainer.Dispatch>
    <summary>
      Provide the prototype dispatcher for events within the system when the control has focus, routing various events to their appropriate event handlers.
    </summary>
    <param name="oEvent">The event to be handled.</param>
    <seealso cref="T:VO.Event" />
    <returns>
      A numeric value representing the event handler that handled the event.
    </returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      MultiMediaContainer:Dispatch() serves as an internal callback method, dispatching events to various event handlers. It should never be necessary to call this method directly. Instead you should write your own Dispatch() method for derived classes, if you want to handle additional events. Usually the derived class Dispatch() method should call SUPER:Dispatch() to support the inherited event handling.
    </remarks>
  </MultiMediaContainer.Dispatch>
  <MultiMediaContainer.FileName>
    <summary>
      The name of the file containing the multimedia data as a string. Major and minor MIME types are derived from the file extension.
    </summary>
    <value>The name of the file containing the multimedia data as a string. Major and minor MIME types are derived from the file extension.</value>
  </MultiMediaContainer.FileName>
  <MultiMediaContainer.MajorType>
    <summary>
      The major MIME type of the current multimedia file, e.g., "image".
    </summary>
    <value>The major MIME type of the current multimedia file, e.g., "image".</value>
  </MultiMediaContainer.MajorType>
  <MultiMediaContainer.MCISendMessage>
    <summary>
      Send an MCIWNDM_XXX message to the contained MCI window.
    </summary>
    <param name="dwMsg">The message ID.</param>
    <param name="wParam">The first SendMessage parameter as DWORD. The default is 0.</param>
    <param name="lParam">The second SendMessage parameter as LONG. The default is 0.</param>
    <returns>
      The result value (as LONG).
    </returns>
    <remarks>
      If the associated file contains video or audio information (for example, an .AVI or .WAV file), the MultiMediaContainer class creates an MCI window. Using the MCISendMessage() method, you can send any of the MCIWNDM_XXX messages documented in the Win32 SDK help to this window. Using these messages, you can programmatically change the look and behavior of the window, play the multimedia data, etc.
      <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about MCIWNDM_XXX messages and commands.</note>
    </remarks>
    <example>
      This code snippet starts the playback of a video or audio file:
      <code language="X#">oDCMM:MCISendMessage(MCIWNDM_PLAYFROM)</code>
      This code snippet advances the data step by step:
      <code language="X#">oDCMM:MCISendMessage(MCI_STEP, 0, 1)</code>
      This code snippet removes the toolbar from the window:
      <code language="X#">
        oDCMM:MCISendMessage(MCIWNDM_CHANGESTYLES, MCIWNDF_NOPLAYBAR, ;
        MCIWNDF_NOPLAYBAR)
      </code>
    </example>
  </MultiMediaContainer.MCISendMessage>
  <MultiMediaContainer.MinorType>
    <summary>
      The minor MIME type of the current multimedia file, e.g., "x-msvideo".
    </summary>
    <value>The minor MIME type of the current multimedia file, e.g., "x-msvideo".</value>
  </MultiMediaContainer.MinorType>
  <MultiMediaContainer.Size>
    <summary>
      A Dimension object defining the size of the control.
    </summary>
    <value>A Dimension object defining the size of the control.</value>
  </MultiMediaContainer.Size>
  <NamedArg>
    <summary>
      Provide a class to support OLE named arguments.
    </summary>
    <remarks>
      OLE supports the concept of named arguments. On method invocation, an argument name that is defined by the OLE automation server can be attached to the actual parameter value. This allows you to pass parameters in any order and to omit parameters because the server can uniquely identify the parameters using their names. The NamedArg class is used to model this way of parameter passing.
    </remarks>
    <example>
      The following example shows how Named Arguments are used to simplify calling the PrintOut method of the Word.Application class that has lots of arguments.
      <code language="X#">
        FUNCTION Start
        LOCAL oApp AS OBJECT
        LOCAL oDocs	AS OBJECT
        LOCAL oDoc	AS OBJECT
        ?
        oApp  OleAutoObject{}
        oAppVisible  TRUE
        oDocs  oAppDocuments
        ?
        oDoc  oDocsOpen
        ?
        oAppPrintOutNamedArg{#Background TRUE} ;
        NamedArg{#PrintToFile TRUE} ;
        NamedArg{#OutputFileName “C}
        DO WHILE oAppBackgroundPrintingStatus
        ?
        DoEvents
        ENDDO
        ?
        oDocCloseFALSE
        oAppQuit
        wait
      </code><code language="X#">RETURN NIL</code>
    </example>
  </NamedArg>
  <NamedArg.ctor>
    <summary>
      Construct a NamedArg object.
    </summary>
    <param name="symArgName">A symbol representing the OLE argument name.</param>
    <param name="uValue">The value of the specified argument.</param>
    <example>
      This example shows how to pass only the Point parameter to the FormatFont() method, which otherwise takes more than 15 parameters:
      <code language="X#">
        LOCAL o AS OLEAutoObject
        o: = OLEAutoObject{"Word.Basic"}
        o:FormatFont(NamedArg{#Points, 18})
      </code>
    </example>
  </NamedArg.ctor>
  <NamedArg.ArgName>
    <summary>
      A symbol representing the name of a named argument.
    </summary>
    <value>A symbol representing the name of a named argument.</value>
  </NamedArg.ArgName>
  <NamedArg.Value>
    <summary>
      The value of a named argument.
    </summary>
    <value>The value of a named argument.</value>
  </NamedArg.Value>
  <NumberFS>
    <summary>
      Create a number field specification, which holds numeric data type information.
    </summary>
  </NumberFS>
  <NumberFS.ctor>
    <summary>
      Construct a numeric field specification.
    </summary>
    <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new number field specification.</param>
    <param name="uLength">The length of the field. If not specified, the default is 12.</param>
    <param name="uDecimals">The number of decimals in the field. If not specified, the default is 2.</param>
  </NumberFS.ctor>
  <ObjCodeBlock>
    <exclude />
  </ObjCodeBlock>
  <ObjCodeBlock.ctor>
    <exclude />
  </ObjCodeBlock.ctor>
  <ObjCodeBlock.Eval>
    <exclude />
  </ObjCodeBlock.Eval>
  <OLEAppDocStorage>
    <summary>
      Provide an encapsulation of an Application Doc File storage for an OLE object.
    </summary>
    <remarks>
      Whenever an OLEObject is inserted into a form inside the Window Editor, the OLE object's persistent information is stored in an Application Doc File. The OLEAppDocStorage class encapsulates an Application Doc File.
    </remarks>
  </OLEAppDocStorage>
  <OLEAppDocStorage.ctor>
    <summary>
      Construct an OLEAppDocStorage object.
    </summary>
    <param name="cDocFile">The name of the Application Doc File.</param>
    <param name="cForm">The name of the form.</param>
    <param name="cObject">The name of the OLEObject.</param>
    <remarks>
      All OLE objects inserted into a form inside the Window Editor are saved inside a special file called the Application Doc File. When the OLE object is recreated at runtime, the persistent information is loaded from the Application Doc File using OLEObject:CreateFromAppDocStorage().
    </remarks>
    <example>
      The following code is generated by the Window Editor to load the OLE object from the associated Application Doc File:
      <code language="X#">
        oDCOLEObject1:CreateFromAppDocStorage(OLEAppDocStorage{;
        "C:\CAVO2x\DATA\Application 5.MDF", "dw", "OLEObject1"}
      </code>
    </example>
  </OLEAppDocStorage.ctor>
  <OLEAppDocStorage.DocFile>
    <summary>
      A string representing the name of the Application Doc File.
    </summary>
    <value>A string representing the name of the Application Doc File.</value>
  </OLEAppDocStorage.DocFile>
  <OLEAppDocStorage.Form>
    <summary>
      A string representing the name of the form.
    </summary>
    <value>A string representing the name of the form.</value>
  </OLEAppDocStorage.Form>
  <OLEAppDocStorage.OLEObject>
    <summary>
      A string representing the name of the OLEObject.
    </summary>
    <value>A string representing the name of the OLEObject.</value>
  </OLEAppDocStorage.OLEObject>
  <OLEAutoObject>
    <summary>
      Provide a class to define an OLE automation server.
    </summary>
    <remarks>
      An OLE automation server is represented through an instance of this class in a X# application. An OLE automation server can be created at runtime using this class without having any information available about the particular server at compile time. All methods, properties, and variables of the automation server are available through the OLEAutoObject object. OLE automation server methods map to X# methods, get properties and variables with read access to Access methods, and set properties and variables with write access to Assign methods.
      While it is often very convenient to create automation servers at runtime on the fly, you might also want to consider generating base classes for specific automation servers using the Automation Server generator in the IDE. Generated OLE automation server base classes inherit from OLEAutoObject and provide compile-time information about the particular server, thereby introducing compile-time checking and speeding up method invocations at runtime.
      Internally this class uses an array of method description objects (type cOleMethod) to store the descriptions of the properties and methods that an OleAutomation server supports.
    </remarks>
  </OLEAutoObject>
  <OLEAutoObject.ctor>
    <summary>
      Construct an OLE automation server.
    </summary>
    <param name="ObjId">A string, IDispatch object, Interface Pointer or OleAutoObject specifying the automation server.</param>
    <param name="nLangID">The language ID for automation servers that support multiple language. The default value is zero.</param>
    <param name="lNoFuncArray">Reserved. The default value is FALSE.</param>
    <param name="fROTCheck">Should X# return a reference to an already running server (TRUE) or create a new instance of the server (FALSE). The default value is FALSE.</param>
    <remarks>
      Init() initializes an OLEAutoObject and tries to link it to the specified automation server.
      Usually, you will specify the automation server (OLE defined PROGID) using its name as a string (i.e., &lt;cServer&gt;). You can, however, specify it as an object of the IDispatch class (i.e., &lt;oIDispatch&gt;). This is required to handle interface hierarchies in OLE automation. A method, property, or variable might return an OLE interface, that in turn represents an automation object with its own methods, properties, and variables. The invoke logic of the automation class will automatically turn a returned OLE automation interface in a new OLEAutoObject object, by first creating an IDispatch object, then creating a new OLEAutoObject object and passing the IDispatch object to its Init() method.
      Alternate parameters are an IDispatch pointer or an OleAutoObject. IDispatch Pointers are handled just like IDispatch objects. When you pass in an OleAutoObject X# will create a second OleAutoObject that points to the same COM Interface. X# will make sure that the reference counting is adjusted to reflect the fact that TWO VO Objects are passing to the same OLE Object.
      The invoke logic in generated subclasses of OLEAutoObject handles return OLE automation interfaces in this manner, so that normally there is no need for the user to pass IDispatch objects to OLEAutoObject:Init().
      OLE automation servers might support different languages for the names of methods, properties, and variables. The desired language is specified through the <paramref name="nLangID" /> argument. The value zero tells the server to use its default language. For details about the supported languages, their identifiers, and the default language, refer to the documentation for your specific automation server.
      The &lt;lNoFuncArray&gt; parameter has to be considered reserved. It is only used by generated subclasses of OLEAutoObject to prevent the Init() method from creating OLEAutoObject:aFuncDesc (an array containing descriptions for all methods, properties, and variables of the automation server). Because this array is not needed by generated subclasses of OLEAutoObject, they call the Init() method using a value of TRUE for this argument. The default value, and the value that is normally used, is FALSE.
      The <paramref name="fROTCheck" /> parameter determines if X# will create a new instance of the server or if it will try to see if the server is already running. The default behavior is to create a new server (fROTCheck = FALSE). When you specify a TRUE for this parameter, X#will inspect the OLE Running Objects Table and try to attach to an already running server by calling the GetActiveObject() API function. When that fails, X# will create a new server
    </remarks>
    <example>
      This example creates a Word Application automation server:
      <code language="X#">
        FUNCTION Start()
        LOCAL oApp AS OBJECT
        LOCAL oDocs AS OBJECT
        LOCAL oDoc AS OBJECT
        ? "Starting Word"
        oApp := OleAutoObject{"Word.Application"}
        oApp:Visible := TRUE
        oDocs := oApp:Documents
        ? "Loading Document"
        oDoc := oDocs:Open("C:\Cavo28\whatsnew.rtf")
        ? "Printing Document"
        oApp:PrintOut(NamedArg{#Background, TRUE}, ;
        NamedArg{#PrintToFile, TRUE}, ;
        NamedArg{#OutputFileName, "C:\TEST.TXT"})
        DO WHILE oApp:BackgroundPrintingStatus != 0
        ? "."
        DoEvents()
        ENDDO
        ? "Closing WORD"
        oDoc:Close(FALSE)
        oApp:Quit()
        wait "Done"
        RETURN NIL
      </code>
    </example>
  </OLEAutoObject.ctor>
  <OLEAutoObject.aFuncDesc>
    <summary>
      Note 	This access is no longer available in X# 2.7b1.
    </summary>
    <value>Note 	This access is no longer available in X# 2.7b1.</value>
    <remarks>
      An array containing descriptions of the methods, properties, and variables of the OLE automation server represented by the OLEAutoObject. This array is only intended for use by the OLEAutoObject class—the user must not manipulate it.
      This array exists only for instances of the OLEAutoObject class. Generated automation server classes that inherit from OLEAutoObject do not need this array since the method information is generated and expanded into code.
      The array is used as a kind of Hash table. The position in the array is calculated from the name of the methods or properties. The elements in the array are objects of the class cOleMethod. This class is used to describe the methods from a OleAutoObject.
    </remarks>
  </OLEAutoObject.aFuncDesc>
  <OLEAutoObject.DateTimeAsDate>
    <summary>
      An OLE date is actually a DateTime combination, often known as a timestamp in SQL databases. This combination of DateTime can not be stored in a DBF Date field and is not recognised by the Date FieldSpec as being a valid date.
      When an OLE date field is returned it is an instance of the OleDateTime class and the values can be extracted from this.
      However, by setting the DateTimeAsDate to TRUE, all OLE dates will be returned as VO dates in the standard format.
    </summary>
    <value>
      An OLE date is actually a DateTime combination, often known as a timestamp in SQL databases. This combination of DateTime can not be stored in a DBF Date field and is not recognised by the Date FieldSpec as being a valid date.
      When an OLE date field is returned it is an instance of the OleDateTime class and the values can be extracted from this.
      However, by setting the DateTimeAsDate to TRUE, all OLE dates will be returned as VO dates in the standard format.
    </value>
  </OLEAutoObject.DateTimeAsDate>
  <OLEAutoObject.Destroy>
    <summary>
      Provide a method to de-instantiate an OLE automation server.
    </summary>
    <remarks>
      OLEAutoObject:Destroy() shuts down an OLE automation session and releases all the data associated with it. This method is called automatically by OLEAutoObject:Axit(), which is triggered by the garbage collector, but you can also call OLEAutoObject:Destroy() directly, as illustrated in the example below.
    </remarks>
    <example>
      This example shows how to destroy an automation server after you are finished working with it:
      <code language="X#">
        LOCAL o AS OLEAutoObject
        o := OLEAutoObject{"Word.Basic"}
        //
        // Work with automation object
        //
        // Shut down
        o:Destroy()
      </code>
    </example>
  </OLEAutoObject.Destroy>
  <OLEAutoObject.dwFuncs>
    <summary>
      The number of methods defined for the OLE automation server.
    </summary>
    <value>The number of methods defined for the OLE automation server.</value>
  </OLEAutoObject.dwFuncs>
  <OLEAutoObject.dwVars>
    <summary>
      The number of properties and variables for the OLE automation server.
    </summary>
    <value>The number of properties and variables for the OLE automation server.</value>
  </OLEAutoObject.dwVars>
  <OLEAutoObject.fInit>
    <summary>
      The instantiation of an OLEAutoObject object does not mean that the OLE automation has been successfully started. For example, moving an automation application from one PC to another will cause the application to malfunction if the OLE automation server is not installed on the new PC. In this case trying to use the OLEAutoObject after instantiation would cause runtime error.
      After creating the object, OLEAutoObject:fInit lets you check to see if the OLE automation server has been successfully initialized. It returns TRUE if the OLE automation server has been initialized properly; otherwise, it returns FALSE.
    </summary>
    <value>
      The instantiation of an OLEAutoObject object does not mean that the OLE automation has been successfully started. For example, moving an automation application from one PC to another will cause the application to malfunction if the OLE automation server is not installed on the new PC. In this case trying to use the OLEAutoObject after instantiation would cause runtime error.
      After creating the object, OLEAutoObject:fInit lets you check to see if the OLE automation server has been successfully initialized. It returns TRUE if the OLE automation server has been initialized properly; otherwise, it returns FALSE.
    </value>
    <example>
      This example displays an error message if the automation server could not be successfully initialized after instantiation:
      <code language="X#">
        LOCAL o AS OLEAutoObject
        o := OLEAutoObject{"Word.Basic"}
        IF !o:fInit
        MessageBox(0, "Error initializing automation server", ;
        "Error", 0)
        RETURN
        ENDIF
      </code>
    </example>
  </OLEAutoObject.fInit>
  <OLEAutoObject.No>
    <summary>
      Provide a general error interception that is automatically called whenever a reference is made to a non-existent method.
      <br />Important! NoMethod() should not be called directly; it is called by the system for handling invalid references.
    </summary>
  </OLEAutoObject.No>
  <OLEAutoObject.NoIVarGet>
    <summary>
      Provide a general error interception that is automatically called whenever an access reference is made to a non-existent access property.
      <include file="Gui.xml" path="doc/NoIVar/*" />
    </summary>
    <param name="symIVar">The symbolic name of the variable that was referenced.</param>
  </OLEAutoObject.NoIVarGet>
  <OLEAutoObject.NoIVarPut>
    <summary>
      Provide a general error interception that is automatically called whenever an assignment reference is made to a non-existent assign property.
      <include file="Gui.xml" path="doc/NoIVar/*" />
    </summary>
    <param name="symIVar">The symbolic name of the variable that was referenced.</param>
    <param name="uValue">The value to be assigned.</param>
  </OLEAutoObject.NoIVarPut>
  <OLEAutoObjectFromFile>
    <summary>
      Provide a class to create an OLE automation server from a file.
    </summary>
    <remarks>
      <br />Important! In order for this class to work the automation server must implement the IPersistFile interface—most automation servers do not.
      The OLEAutoObjectFromFile class lets you create an automation server object from a file. OLE will determine which automation server a particular file belongs to and automatically start the server and open the file inside it.
    </remarks>
  </OLEAutoObjectFromFile>
  <OLEAutoObjectFromFile.ctor>
    <summary>
      Create an OLE automation server from a file.
    </summary>
    <param name="cFName">The name of file from which to create the OLE automation server.</param>
    <param name="nLangID">The language ID for automation servers that support multiple language. The default value is zero.</param>
    <remarks>
      Init() initializes an OLEAutoObjectFromFile and tries to link it to the automation server that is registered for the file <paramref name="cFName" />.
      OLE automation servers might support different languages for the names of methods, properties, and variables. The desired language is specified through the <paramref name="nLangID" /> argument. The value zero tells the server to use its default language. For details about the supported languages, their identifiers, and the default language, refer to the documentation for your specific automation server.
      <br />Important! In order for this class to work the automation server must implement the IPersistFile interface—most automation servers do not.
    </remarks>
  </OLEAutoObjectFromFile.ctor>
  <OLEAutoObjectFromFile.cFileName>
    <summary>
      A string representing the file name to which the automation server is bound.
    </summary>
    <value>A string representing the file name to which the automation server is bound.</value>
  </OLEAutoObjectFromFile.cFileName>
  <OLEAutoObjectFromFile.Destroy>
    <summary>
      Provide a method to de-instantiate an OLE automation server.
    </summary>
    <remarks>
      OLEAutoObjectFromFile:Destroy() shuts down an OLE automation session and releases all the data associated with it. This method is called automatically by OLEAutoObject:Axit(), which is triggered by the garbage collector, but you can also call OLEAutoObjectFromFile:Destroy() directly.
    </remarks>
  </OLEAutoObjectFromFile.Destroy>
  <OleBinary>
    <summary>
      Provide a class to support passing Binary Information to Ole Server
    </summary>
    <remarks>
      This class is used to pass binary information to an OleServer, such as the contents of a file. In most cases the Ole Server will expect an array of butes. VO will generate an array of bytes for each OleBinary Argument.
      <note type="tip">
        VO 2.8 SP2 introduces this class. However: this patch does not come with a new repository, so you cannot directly reference the class but must use the CreateInstance() syntax in stead.
      </note>
    </remarks>
    <example>
      The following example shows how an OleBinary object is used to pass the contents of a binary file to a server
      <code language="X#">
        LOCAL oServer AS OBJECT
        LOCAL cData AS STRING
        oServer := OleAutoObject{"Some.Server"}
        cData := MemoRead("MyFile.bin")
        oServer:Upload("MyFile.bin", CreateInstance(#OleBinary, cData))
      </code>
    </example>
  </OleBinary>
  <OleBinary.ctor>
    <summary>
      Construct a NamedArg object.
    </summary>
    <param name="uValue">This can be a string. SafeArray or another OleBinary object.If you pass in a SafeArray, then the class creates a clone of the SafeArray. You remain the owner of the original SafeArray. If you pass in an OleBinary then it clones that object.</param>
  </OleBinary.ctor>
  <OleBinary.AsString>
    <summary>
      Returns the string representation of the OleBinary Object
      When the type is known, it can be a text such as ‘Word Document’ or ‘Bitmap’. Otherwise it is a hex dump from the contents
    </summary>
  </OleBinary.AsString>
  <OleBinary.ProgId>
    <summary>
      When the class can determine the contents of the binary info then this access returns the ProgId from the contents.
    </summary>
    <value>When the class can determine the contents of the binary info then this access returns the ProgId from the contents.</value>
  </OleBinary.ProgId>
  <OleBinary.SafeArray>
    <summary>
      This sets/returns a copy of the SafeArray stored in this object.
    </summary>
    <value>This sets/returns a copy of the SafeArray stored in this object.</value>
    <remarks>
      <note type="tip">
        If you call the access, you become responsible for destroying the SafeArray
        If you assign a new SafeArray then the object creates a clone of this SafeArray. You remain the owner of the original SafeArray.
      </note>
    </remarks>
  </OleBinary.SafeArray>
  <OleBinary.Value>
    <summary>
      Reads/Updates the contents of the object as a string.
    </summary>
    <value>Reads/Updates the contents of the object as a string.</value>
  </OleBinary.Value>
  <OLEControl>
    <summary>
      Provide a container and wrapper for an OLE control (OCX).
    </summary>
    <remarks>
      The OLEControl class implements a wrapper and container for an OLE control (OCX, ActiveX). An OLE control is basically an OLE object with an added automation interface, by which you can program the OCX and set up event handlers to handle events instantiated by the OLE control. To cover the first requirement, OLEControl is derived from OLEObject and, therefore, inherits all of the OLEObject's functionality. The automation interface is provided by an OLEAutoObject, which is a protected member variable of OLEControl initialized using OLEControl:InitAutoObject().
    </remarks>
  </OLEControl>
  <OLEControl.CreateEmbedding>
    <summary>
      Create an OLE control from a program ID.
    </summary>
    <param name="cProgID">The OLE control's program ID.</param>
    <param name="cLicKey">The license key for the OLE control's program.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Each object provided by an OLE server is uniquely identified by its program ID. These program IDs are stored in the system Registry as described in the OLE server's documentation. OLEControl:CreateEmbedding() creates an embedded OLE control from its program ID and loads it into an OLEControl container.
    </remarks>
    <example>
      The following code responds to a button click by creating an object with the program ID Word.Document.6 within an already existing OLEControl container sitting on a data window:
      <code language="X#">
        METHOD PushButton1() CLASS dw
        oDCOLEControl1:CreateEmbedding("Word.Document.6")
      </code>
    </example>
  </OLEControl.CreateEmbedding>
  <OLEControl.CreateFromAppDocStorage>
    <summary>
      Create an OLEControl from an Application Doc File storage.
    </summary>
    <param name="oOLEAppDocStorage">The OLEAppDocStorage object containing the object.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      All OLE controls inserted into a form inside the Window Editor are saved inside a special file called the Application Doc File. When the OLE control is recreated at runtime, the persistent information, including the OLEAutoObject, is loaded from the Application Doc File using OLEControl:CreateFromAppDocStorage().
    </remarks>
  </OLEControl.CreateFromAppDocStorage>
  <OLEControl.Destroy>
    <summary>
      Provide a method to de-instantiate an OLEControl object.
    </summary>
    <param name="oEvent">The event to be handled.</param>
    <seealso cref="T:VO.Event" />
    <remarks>
      This method can be used when an OLEControl object is no longer needed. OLEControl:Destroy() de-instantiates the OLEControl object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector. The associated OLE control is automatically closed and the OLE control's server is shut down, unless it is serving other clients.
    </remarks>
  </OLEControl.Destroy>
  <OLEControl.Dispatch>
    <summary>
      Provide the prototype dispatcher for events within the system when the control has focus; routing various events to their appropriate event handlers.
    </summary>
    <param name="oEvent">The event to be handled.</param>
    <seealso cref="T:VO.Event" />
    <returns>
      TRUE if the event was handled; otherwise, FALSE.
    </returns>
    <remarks>
      OLEControl:Dispatch() serves as an internal callback, dispatching events to various event handlers. It should never be necessary to call this method directly. Instead, you can write your own Dispatch() method for derived classes if you want to handle additional events. Usually the derived class Dispatch() should call SUPER:Dispatch() to support the inherited event handling.
    </remarks>
  </OLEControl.Dispatch>
  <OLEControl.InitAutoObject>
    <summary>
      Initialize the OLEAutoObject.
    </summary>
    <returns>
      SELF
    </returns>
    <remarks>
      The OLEAutoObject must be initialized after the OLE control is created. OLEControl:CreateFromAppDocStorage() does this automatically. If you use one of the other Create methods, however, make sure to initialize the OLEAutoObject properly using OLEControl:InitAutoObject().
    </remarks>
  </OLEControl.InitAutoObject>
  <OLEControl.No>
    <summary>
      Provide a general error interception that is automatically called whenever a reference is made to a non-existent method.
      <br />Important! NoMethod() should not be called directly; it is called by the system for handling invalid references.
    </summary>
  </OLEControl.No>
  <OLEDataWindow>
    <summary>
      Create a data window capable of hosting OLE objects.
    </summary>
    <remarks>
      Note 	The functionality in the methods of this class has now been incorporated into the DataWindow Class and the Window Class. The class name is retained for backward compatibility only, but all its methods have been moved to one of the parent classes
      An OLE data window is a regular data window enhanced by some features to support OLE objects.
    </remarks>
  </OLEDataWindow>
  <OLEDataWindow.ctor>
    <summary>
      Note 	The functionality in this method has now been incorporated into the Window Class.

      Construct an OLE data window.
    </summary>
    <param name="oOwner">
      The window that owns the OLE data window. The following window types can be owners: App, ShellWindow, TopAppWindow, ChildAppWindow, DialogWindow, DataDialog, or another DataWindow.
      The behavior of the OLE data window is determined by the type of its owner.
    </param>
    <param name="oSource">
      The ID of the resource that defines the layout of the OLE data window. or the resource ID that specifies the location and size of the sub-data window.
      Specifying this argument creates the new OLE data window as a sub-data window on its owner data window (only data window owners can have sub-data windows).
      It should refer to a control defined in the resource entity of the owner data window.
      If <paramref name="oSource" /> is omitted or if <paramref name="oOwner" /> is not a data window, the data window is created as a modal DialogWindow.
    </param>
    <param name="nResourceID">** missing parameter documentation **</param>
    <remarks>
      An OLE data window is an enhanced data window which can be used to host OLE objects. It provides the additional functionality needed for OLE objects. For more details, please see the specific methods for the OLEDataWindow class.
    </remarks>
  </OLEDataWindow.ctor>
  <OLEDataWindow.DeActivate>
    <summary>
      Note 	The functionality in this method has now been incorporated into the Window Class.

      Provide a method that is invoked when the OLE data window is deactivated.
      <br />Important! Deactivate() is a callback method used by X#. Normally, it should not be called in your application code.
    </summary>
    <param name="oEvent">An empty event required to maintain the protocol that all event handlers have exactly one event as their argument.</param>
    <seealso cref="T:VO.Event" />
    <remarks>
      This event handler is normally invoked when another application or window becomes activated. By default, all OLE objects on the OLEDataWindow will be deactivated. If Window:MouseTrapOn() is left on, MouseEvent events cannot be directed to other applications or windows.
    </remarks>
  </OLEDataWindow.DeActivate>
  <OLEDataWindow.DeactivateAllOLEObjects>
    <summary>
      Note 	The functionality in this method has now been incorporated into the Window Class.

      Deactivate all currently active OLE objects.
    </summary>
    <remarks>
      The DeactivateAllOLEObjects() method deactivates any currently (in-place) active OLE objects. The method is called automatically whenever the data window itself is deactivated.
    </remarks>
  </OLEDataWindow.DeactivateAllOLEObjects>
  <OLEDataWindow.MouseButtonDown>
    <summary>
      Note 	The functionality in this method has now been incorporated into the Window Class.

      Provide an event handler that is invoked when the mouse pointer is positioned over the window and a mouse button is clicked.
    </summary>
    <param name="oMouseEvent">The MouseEvent object that contains information about the state of the mouse when the button was clicked.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      By default, this method will deactivate all OLE object controls on the window before processing the MouseEvent.
      Use the Window:MouseTrapOn() method to force MouseEvents generated outside the canvas area to be directed to this window.
    </remarks>
  </OLEDataWindow.MouseButtonDown>
  <OLEDataWindow.Notify>
    <summary>
      Note 	The functionality in this method has now been incorporated into the DataWindow Class.

      Provide an event handler that reflects events that have occurred in the server connected to an OLE data window.
      <br />Important! Notify() is automatically called by the server, and should normally not be called by application code.
    </summary>
    <returns>
      SELF, except if NOTIFYINTENTTOMOVE is specified for <paramref name="kNotifyName" />. In this case, the return value is TRUE if successful; otherwise, FALSE.
    </returns>
    <include file="VOSDK.xml" path="doc/commonblocks/notify/*" />
  </OLEDataWindow.Notify>
  <OLEDataWindow.UpdateActiveObject>
    <summary>
      Note 	The functionality in this method has now been incorporated into the DataWindow Class.

      Update the toolbars of any in-place active OLE objects.
    </summary>
    <remarks>
      OLEDataWindow:UpdateActiveObject() calls the UpdateTools() method of any currently activated OLE object that the OLE data window contains. It first determines which OLE object control is in-place active, and then replaces the X# container application's toolbars with the OLE server's toolbars. In response to a resizing of the container application, this method causes the OLE object server to rearrange its toolbars.
    </remarks>
  </OLEDataWindow.UpdateActiveObject>
  <OLEDataWindow.ViewAs>
    <summary>
      Note 	The functionality in this method has now been incorporated into the DataWindow Class.

      Specify the view mode of the OLE data window as either browse view or form view.
    </summary>
    <param name="symViewMode">
      Specifies which view mode is to be used. Use one of these symbols:
      Symbol	Description
      #BrowseView	Several records are displayed at the same time, as rows in a spreadsheet-like table with each field corresponding to a column.
      #FormView	A single record is viewed at a time, with its fields displayed in individual controls.
    </param>
    <remarks>
      When a window is switched to a new view mode, a layout is automatically generated if one had not been defined previously.
      Because it takes an argument, OLEDataWindow:ViewAs() is rarely connected directly with a push button or menu command; instead, the OLEDataWindow:ViewForm() and OLEDataWindow:ViewTable() methods (inherited from DataWindow) are used.
      In addition to the functionality provided by the DataWindow base class, the implementation for the OLEDataWindow class also deactivates any activated OLE objects before changing the view.
    </remarks>
  </OLEDataWindow.ViewAs>
  <OleDateTime>
    <summary>
      Provide an encapsulation of a DateTime value as used by OLE objects.
    </summary>
    <remarks>
      OLE dates are a combination of the date and time which is sometimes known as a timestamp in SQL databases. The OleDateTime class provides a way for X# to encapsulate this type of value.
    </remarks>
  </OleDateTime>
  <OleDateTime.ctor>
    <summary>
      Construct an OleDateTime object.
    </summary>
    <param name="uDate">This can be passed as a number or as a VO date.</param>
    <remarks>
      The OleDateTime class can be initialized in two ways:
      - With a VO Date, in which case the time portion is set to 00:00:00.00
      - With a number, in which case the Integer is taken as the number of days from December 30th 1899 to make the date. The fraction is then taken as a fraction of a day to make the time portion of the object.
    </remarks>
  </OleDateTime.ctor>
  <OleDateTime.AsReal8>
    <summary>
      Returns the DateTime value as Real8 (the format that is used in COM).
    </summary>
  </OleDateTime.AsReal8>
  <OleDateTime.AsString>
    <summary>
      Returns the dateTime value as a String.
    </summary>
  </OleDateTime.AsString>
  <OleDateTime.DateVal>
    <summary>
      The value of the date part of the DateTime object as a Date.
    </summary>
    <value>The value of the date part of the DateTime object as a Date.</value>
  </OleDateTime.DateVal>
  <OleDateTime.TimeString>
    <summary>
      The value of the timee part of the DateTime object as a String.
    </summary>
    <value>The value of the timee part of the DateTime object as a String.</value>
  </OleDateTime.TimeString>
  <OleDateTime.TimeVal>
    <summary>
      The numeric value of the time part of the DateTime object as a Float.
    </summary>
    <value>The numeric value of the time part of the DateTime object as a Float.</value>
  </OleDateTime.TimeVal>
  <OLEDBStorage>
    <summary>
      Provide an encapsulation of a database storage for an OLE object.
    </summary>
    <remarks>
      X# supports the ability to store an OLE object in a DBF database. To assign a new value to the OLEObject container, you pass an OLEDBStorage object to OLEObject:CreateFromDBStorage(). To save an OLE object in the database, you pass an OLEDBStorage object to OLEObject:SaveToDBStorage(). You usually get the OLEDBStorage object as a result of a FieldGet() call.
    </remarks>
  </OLEDBStorage>
  <OLEDBStorage.ctor>
    <summary>
      Construct an OLEDBStorage object.
    </summary>
    <param name="ptrRootStg">A pointer to the root storage.</param>
    <param name="cSubStgName">A string representing the substorage name.</param>
    <remarks>
      OLEDBStorage objects are usually a result of a FieldGet() call. It should never be necessary to call this method directly.
    </remarks>
  </OLEDBStorage.ctor>
  <OLEDBStorage.RootStorage>
    <summary>
      A pointer to the root storage object.
    </summary>
    <value>A pointer to the root storage object.</value>
    <remarks>
      <br />Important! This property is used for internal purposes and is not intended to be used directly.
    </remarks>
  </OLEDBStorage.RootStorage>
  <OLEDBStorage.SubStorageName>
    <summary>
      A string representing the name of the object's substorage.
    </summary>
    <value>A string representing the name of the object's substorage.</value>
    <remarks>
      <br />Important! This property is used for internal purposes and is not intended to be used directly.
    </remarks>
  </OLEDBStorage.SubStorageName>
  <OLEDragEvent>
    <summary>
      Store information about an OLE drag and drop event.
    </summary>
    <remarks>
      A window that is registered as an OLE drop target using ChildAppWindow:EnableOLEDropTarget() can handle OLE drag and drop events and create new OLE objects in response to such events. In the associated handlers, an OLEDragEvent object is passed as a parameter that can be used to create a new OLE object by calling OLEObject:CreateFromOLEDragEvent().
    </remarks>
  </OLEDragEvent>
  <OleDragEvent.ctor>
    <summary>
      Construct an OLEDragEvent.
    </summary>
    <param name="DragInfo">A pointer to a DRAGINFO structure.</param>
  </OleDragEvent.ctor>
  <OleDragEvent.DataObject>
    <summary>
      A pointer to the OLE object data.
    </summary>
    <value>A pointer to the OLE object data.</value>
  </OleDragEvent.DataObject>
  <OleDragEvent.Effect>
    <summary>
      A constant indicating the effect of the drag and drop operation:
    </summary>
    <value>A constant indicating the effect of the drag and drop operation:</value>
    <remarks>
      One of the following constants indicating the effect of the drag and drop operation:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>DROPEFFECT_COPY</term>
          <description>Copy operation</description>
        </item>
        <item>
          <term>DROPEFFECT_LINK	</term>
          <description>
            Create a new link
          </description>
        </item>
        <item>
          <term>DROPEFFECT_MOVE	</term>
          <description>Move operation</description>
        </item>
        <item>
          <term>DROPEFFECT_NONE	</term>
          <description>No effect</description>
        </item>
      </list>
      OLEDragEvent:Effect controls the appearance of the drag and drop mouse cursor and can be set during the handling of an OLEDragEvent.
    </remarks>
  </OleDragEvent.Effect>
  <OleDragEvent.ObjectName>
    <summary>
      A string representing the OLE object name. By examining the object and/or server name, the container application can selectively allow or disallow a particular object or server as a drag and drop source.
    </summary>
    <value>A string representing the OLE object name. By examining the object and/or server name, the container application can selectively allow or disallow a particular object or server as a drag and drop source.</value>
  </OleDragEvent.ObjectName>
  <OleDragEvent.Position>
    <summary>
      A Point object specifying the position of the event.
    </summary>
    <value>A Point object specifying the position of the event.</value>
  </OleDragEvent.Position>
  <OleDragEvent.ServerName>
    <summary>
      A string representing the OLE server name. By examining the object and/or server name, the container application can selectively allow or disallow a particular object or server as a drag and drop source.
    </summary>
    <value>A string representing the OLE server name. By examining the object and/or server name, the container application can selectively allow or disallow a particular object or server as a drag and drop source.</value>
  </OleDragEvent.ServerName>
  <OLEInterface>
    <summary>
      Provide the base class for the internal implementation of OLE automation.
    </summary>
    <remarks>
      <br />Important! This class is used for internal implementation only and is not intended to be used directly.
    </remarks>
  </OLEInterface>
  <OLEObject>
    <summary>
      Provide a container and wrapper for an OLE object.
    </summary>
    <remarks>
      The OLEObject class serves as the container and wrapper for an OLE object, provided and managed by an OLE server. The OLEObject alone is simply a windowed control that can take exactly one OLE object. The OLE object is created via one of the Create methods, such as OLEObject:CreateFromPasteDialog() or OLEObject:CreateFromAppDocStorage(). Several properties, such as OLEObject:AllowInPlace, control the basic behavior of the OLEObject.
      Note the distinction between OLEObject, which is a class provided by X#, and an OLE object, which is provided by its server and "lives" inside the OLEObject container. Using OLEObject:DetachFromServer(), the current OLE object can be destroyed, but the same OLEObject container can be reused by calling one of the Create methods again.
    </remarks>
  </OLEObject>
  <OLEObject.ctor>
    <summary>
      Construct an OLEObject.
    </summary>
    <param name="oOwner">The window that owns the OLEObject.</param>
    <param name="nID">The unique ID between 1 and 8000 of the OLEObject.</param>
    <param name="nResourceID">The resource ID of OLEObject.</param>
    <param name="oPoint">The origin of the OLEObject in canvas coordinates.</param>
    <param name="oDimension">The dimension of the OLEObject in canvas coordinates.</param>
    <param name="lDataAware">A logical value that is TRUE if the OLEObject is data-aware and otherwise FALSE.</param>
    <example>
      The following code is generated by the Window Editor. It first creates an OLEObject container from a resource, then a HyperLabel is assigned, and finally the OLE object is loaded from the Application Doc File:
      <code language="X#">
        oDCOLEObject1 := OLEObject{SELF, ;
        ResourceID{DW_OLEOBJECT1, _GetInst()}}
        oDCOLEObject1:HyperLabel := HyperLabel{#OLEObject1, ;
        NULL_STRING, NULL_STRING, NULL_STRING}
        oDCOLEObject1:CreateFromAppDocStorage(OLEAppDocStorage{ ;
        "C:\CAVO2x\DATA\Application 5.MDF", "dw", "OLEObject1"})
      </code>
    </example>
  </OLEObject.ctor>
  <OLEObject.Activate>
    <summary>
      Activate the OLE object.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      The method puts the associated OLE object into the active state, which usually allows the user to edit the object.
    </remarks>
    <example>
      The following code shows a push button's click event handler, which activates an OLEObject located on the same data window:
      <code language="X#">
        METHOD PushButton1() CLASS dw
        oDCOLEObject1:Activate("Word.Document.6")
      </code>
    </example>
  </OLEObject.Activate>
  <OLEObject.ActivateOnDblClk>
    <summary>
      A logical value that is TRUE if the OLE object is activated by double-clicking on it and FALSE otherwise. The default value for this property is TRUE.
    </summary>
    <value>A logical value that is TRUE if the OLE object is activated by double-clicking on it and FALSE otherwise. The default value for this property is TRUE.</value>
  </OLEObject.ActivateOnDblClk>
  <OLEObject.AddVerbMenu>
    <summary>
      Insert the OLE object's verb menu into an existing menu.
    </summary>
    <param name="hMenu">The handle of the existing menu.</param>
    <param name="iPos">The position at which the menu should be inserted.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      A OLE object usually supports several actions (called verbs) which a user can perform on the object. An AVI object, for example, can support a Play and an Edit verb. The object's verbs can be invoked via its verb menu, which is added using OLEObject:AddVerbMenu() into an existing menu and is fully managed by the object.
    </remarks>
    <example>
      The following code inserts the verb menu at position two of the pop-up menu with ID one of the container application. Note that the system menu of an MDI child window counts as separate pop-up menu, in case the MDI child window is maximized:
      <code language="X#">
        LOCAL hObjMenu AS PTR
        IF oParent:IsZoomed()
        hObjMenu := oParent:Menu:GetSubMenu(2)
        ELSE
        hObjMenu := oParent:Menu:GetSubMenu(1)
        ENDIF
        SELF:AddVerbMenu(hObjMenu, 2)
      </code>
    </example>
  </OLEObject.AddVerbMenu>
  <OLEObject.AllowInPlace>
    <summary>
      If an OLE object is activated—either by calling OLEObject:Activate() or by double-clicking on the object—the server usually puts the object into edit mode. This editing can happen either inside the X# container application (in-place activation) or in a separate window managed by the server (out-of-place activation). During in-place activation, the server's and the container's menus and toolbars are merged, and the object can be edited inside the container's user interface context.
      OLEObject:AllowInPlace is a logical value that is TRUE if the object is allowed to be activated in-place and FALSE otherwise. The default value for this property is FALSE.
      <note type="tip">The server can deny in-place activation even if OLEObject:AllowInPlace is TRUE.</note>
    </summary>
    <value>
      If an OLE object is activated—either by calling OLEObject:Activate() or by double-clicking on the object—the server usually puts the object into edit mode. This editing can happen either inside the X# container application (in-place activation) or in a separate window managed by the server (out-of-place activation). During in-place activation, the server's and the container's menus and toolbars are merged, and the object can be edited inside the container's user interface context.
      OLEObject:AllowInPlace is a logical value that is TRUE if the object is allowed to be activated in-place and FALSE otherwise. The default value for this property is FALSE.
      The server can deny in-place activation even if OLEObject:AllowInPlace is TRUE.
    </value>
  </OLEObject.AllowInPlace>
  <OLEObject.AllowResize>
    <summary>
      A logical value that is TRUE if the OLE object is resizable and movable at runtime. The default value for this property is FALSE.
    </summary>
    <value>A logical value that is TRUE if the OLE object is resizable and movable at runtime. The default value for this property is FALSE.</value>
  </OLEObject.AllowResize>
  <OLEObject.AutoSizeOnCreate>
    <summary>
      A logical value that determines if the initial size of the OLE object is controlled by the object's server. If OLEObject:AutoSizeOnCreate is TRUE, the Create methods ask the object's server for a preferred object size. If this size is meaningful the OLEObject container resizes itself. The default value for this property is TRUE.
    </summary>
    <value>A logical value that determines if the initial size of the OLE object is controlled by the object's server. If OLEObject:AutoSizeOnCreate is TRUE, the Create methods ask the object's server for a preferred object size. If this size is meaningful the OLEObject container resizes itself. The default value for this property is TRUE.</value>
  </OLEObject.AutoSizeOnCreate>
  <OLEObject.CreateEmbedding>
    <summary>
      Create an OLE object from a program ID.
    </summary>
    <param name="cProgID">The OLE object's program ID.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Each object provided by an OLE server is uniquely identified by its program ID. These program IDs are stored in the system Registry as described in the OLE server's documentation. OLEObject:CreateEmbedding() creates an embedded OLE object from its program ID and loads it into an OLEObject container.
    </remarks>
    <example>
      The following code responds to a button click by creating an object with the program ID Word.Document.6 within an already existing OLEObject container sitting on a data window:
      <code language="X#">
        METHOD PushButton1() CLASS dw
        oDCOLEObject1:CreateEmbedding("Word.Document.6")
      </code>
    </example>
  </OLEObject.CreateEmbedding>
  <OLEObject.CreateEmbeddingFromFile>
    <summary>
      Create an OLE object from a file.
    </summary>
    <param name="cFileName">The file containing the object.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      If an OLE object is given as a file (such as a saved document). you use OLEObject:CreateEmbeddingFromFile() to create an embedded OLE object and load it into its OLEObject container.
    </remarks>
    <example>
      The following code responds to a button click by creating an object from the file \WINWORD\SAMPLE.DOC:
      <code language="X#">
        METHOD PushButton1() CLASS dw
        oDCOLEObject1:CreateEmbeddingFromFile("\WINWORD\SAMPLE.DOC")
      </code>
    </example>
  </OLEObject.CreateEmbeddingFromFile>
  <OLEObject.CreateFromAppDocStorage>
    <summary>
      Create an OLE object from an Application Doc File storage.
    </summary>
    <param name="oOLEAppDocStorage">The OLEAppDocStorage object containing the object.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      All OLE objects inserted into a form inside the Window Editor are saved inside a special file called the Application Doc File. When the OLE object is recreated at runtime, the persistent information is loaded from the Application Doc File using OLEObject:CreateFromAppDocStorage().
    </remarks>
    <example>
      The following code is generated by the Window Editor to load the OLE object from the associated Application Doc File.
      <code language="X#">
        oDCOLEObject1:CreateFromAppDocStorage(OLEAppDocStorage{ ;
        "C:\CAVO25\DATA\Application 5.MDF", "dw", "OLEObject1"}
      </code>
    </example>
  </OLEObject.CreateFromAppDocStorage>
  <OLEObject.CreateFromDBStorage>
    <summary>
      Create an OLE object from a database storage.
    </summary>
    <param name="oOLEDBStorage">The OLEDBStorage object describing the database storage.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      X# supports the ability to store an OLE object in a DBF database. To assign a new value to the OLEObject container, you pass an OLEDBStorage object to OLEObject:CreateFromDBStorage(). To save the persistent information of an OLE object in the database, you pass an OLEDBStorage object to OLEObject:SaveToDBStorage(). You usually get the OLEDBStorage object as a result of a FieldGet() call.
    </remarks>
    <example>
      The following code shows how an OLEDBStorage object received from the FieldGet() call is used to create an OLE object and insert it into the OLEObject container:
      <code language="X#">
        LOCAL oDBStg AS OLEDBStorage
        oDBStg := FieldGet(FieldPos(#PaintObject))
        oOLEContainer:CreateFromDBStorage(oDBStg)
      </code>
    </example>
  </OLEObject.CreateFromDBStorage>
  <OLEObject.CreateFromInsertDialog>
    <summary>
      Create an OLE object from the standard Insert Object dialog.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      OLEObject:CreateFromInsertDialog() brings up the standard Insert Object dialog, allowing the user to select an object type which is then used to create a new OLE object for this OLEObject container.
    </remarks>
    <example>
      The following code first instantiates a new OLEObject container then uses OLEObject:CreateFromInsertDialog() to create an OLE object for the container. The OLEObject container is destroyed in case the OLE object creation failed—for example, because the user clicked on the dialog's Cancel button:
      <code language="X#">
        LOCAL oOLE AL OLEObject
        oOLE := DraggableOLEObject{SELF}
        oOLE:AllowInPlace := TRUE
        oOLE:AllowResize := TRUE
        IF oOLE:CreateFromInsertDialog()
        oOLE:Show()
        oOLE:SetFocus()
        ELSE
        oOLE:Destroy()
        ENDIF
      </code>
    </example>
  </OLEObject.CreateFromInsertDialog>
  <OLEObject.CreateFromOLEDragEvent>
    <summary>
      Create an OLE object from an OLEDragEvent.
    </summary>
    <param name="oOLEDragEvent">The OLEDragEvent object.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      A window that is registered as an OLE drop target using ChileAppWindow:EnableOLEDropTarget() can handle OLE drag and drop events and create new OLE objects in response to such events. In the associated handlers, an OLEDragEvent object is passed as a parameter that can be used to create a new OLE object by calling OLEObject:CreateFromOLEDragEvent().
    </remarks>
    <example>
      The following code enables a data window as a drop target and creates a new OLE object inside its OLEDrop handler. It also checks the name of the OLE object to allow only WordPad documents:
      <code language="X#">
        METHOD EnableOLEDropTarget CLASS DropTargetDataWindow
        SELF:EnableOLEDropTarget(TRUE)
        METHOD OLEDrop(oOLEDragEvent) CLASS MyChild
        LOCAL oOLE AS OLEObject
        LOCAL lRet AS LOGIC
        IF oOLEDragEvent:ObjectName == "WordPad Document"
        oOLE := OLEObject{SELF}
        oOLE:AllowInPlace := TRUE
        oOLE:AllowResize := TRUE
        IF oOLE:CreateFromOLEDragEvent(oOLEDragEvent)
        oOLE:Origin := oOLEDragEvent:Position
        oOLE:Show()
        oOLE:SetFocus()
        ENDIF
        ENDIF
      </code>
    </example>
  </OLEObject.CreateFromOLEDragEvent>
  <OLEObject.CreateFromPasteDialog>
    <summary>
      Create an OLE object from the standard Paste Special dialog.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      OLEObject:CreateFromPasteDialog() brings up the standard Paste Special dialog, allowing the user to select an object from the Clipboard which is then used to create a new OLE object for this OLEObject container.
    </remarks>
    <example>
      The following code first instantiates a new OLEObject container then uses OLEObject:CreateFromPasteDialog() to create an OLE object for the container. The OLEObject container is destroyed in case the OLE object creation failed—for example, because the user clicked on the dialog's Cancel button:
      <code language="X#">
        LOCAL oOLE AS OLEObject
        oOLE := DraggableOLEObject{SELF}
        oOLE:AllowInPlace := TRUE
        oOLE:AllowResize := TRUE
        IF oOLE:CreateFromPasteDialog()
        oOLE:Show()
        oOLE:SetFocus()
        ELSE
        oOLE:Destroy()
        ENDIF
      </code>

      DataWindow:PasteSpecial(), OLEObject:CreateEmbedding(), OLEObject:CreateEmbeddingFromFile(), OLEObject:CreateFromAppDocStorage(), OLEObject:CreateFromDBStorage(), OLEObject:CreateFromInsertDialog(), OLEObject:CreateFromOLEDragEvent(), OLEObject:CreateLink()
    </example>
  </OLEObject.CreateFromPasteDialog>
  <OLEObject.CreateLink>
    <summary>
      Create an OLE object as a link to a file.
    </summary>
    <param name="cFileName">The name of file containing the OLE object.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      A linked OLE object is stored outside the container's storage. This allows other applications to use and change the OLE object as well. OLEObject:CreateLink() creates a new linked OLE object and loads it into the OLEObject container.
    </remarks>
    <example>
      The following code creates a linked OLE object from a text document into an OLEObject:
      <code language="X#">oMyTextObject:CreateLink("\WINWORD\SAMPLE.DOC")</code>
    </example>
  </OLEObject.CreateLink>
  <OLEObject.Deactivate>
    <summary>
      Deactivate an OLE object.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <example>
      The following code shows a push button's click event handler, which deactivates an OLEObject located on the same data window:
      <code language="X#">
        METHOD PushButton1() CLASS dw
        oDCOLEObject1:Deactivate("Word.Document.6")
      </code>
    </example>
  </OLEObject.Deactivate>
  <OLEObject.Destroy>
    <summary>
      Provide a method to de-instantiate an OLEObject.
    </summary>
    <remarks>
      This method can be used when an OLEObject object is no longer needed. OLEObject:Destroy() de-instantiates the OLEObject object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector. The associated OLE object is automatically closed and the OLE object's server is shut down, unless it is serving other clients.
    </remarks>
  </OLEObject.Destroy>
  <OLEObject.DetachFromServer>
    <summary>
      Remove a contained OLE object and cut the link to its server.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Since OLEObject serves as a container for any OLE object, it is possible to remove the current object, cut the link to its server, and load a new OLE object into the container by using one of the Create methods. In the process, OLEObject:DetachFromServer() removes the current OLE object and cuts the link to the object's server.
    </remarks>
  </OLEObject.DetachFromServer>
  <OLEObject.Dispatch>
    <summary>
      Provide the prototype dispatcher for events within the system when the control has focus; routing various events to their appropriate event handlers.
    </summary>
    <param name="oEvent">The event to be handled.</param>
    <seealso cref="T:VO.Event" />
    <returns>
      TRUE if the event was handled; otherwise, FALSE.
    </returns>
    <remarks>
      OLEObject:Dispatch() serves as an internal callback, dispatching events to various event handlers. It should never be necessary to call this method directly. Instead, you can write your own Dispatch() method for derived classes if you want to handle additional events. Usually the derived class Dispatch() should call SUPER:Dispatch() to support the inherited event handling.
    </remarks>
  </OLEObject.Dispatch>
  <OLEObject.DoVerb>
    <summary>
      Exercise an OLE object's verb.
    </summary>
    <param name="iVerb">The verbs numerical ID.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      A OLE object usually supports several actions (called verbs) which a user can perform on the object. An AVI object, for example, can support a Play and an Edit verb. The object's verbs can be invoked via the objects verb menu or directly by calling OLEObject:DoVerb().
    </remarks>
  </OLEObject.DoVerb>
  <OLEObject.ExportToStorage>
    <summary>
      Exports an OLE object to a user-managed storage file.
    </summary>
    <param name="cFileName">The name of the storage file.</param>
    <param name="cStorageName">The name of the storage.</param>
    <example>
      The following example is from the OLE Container application in \CAVO25\SAMPLES\OLE\CONT:
      <code language="X#">
        METHOD FileSave() CLASS Container
        LOCAL oOle AS OBJECT
        LOCAL oOD AS SaveAsDialog
        LOCAL i AS INT
        LOCAL s AS STRING
        (oOD := SaveAsDialog{SELF, "*.CDF"}):Show()
        s := oOD:FileNAme
        IF !Empty(oOD:FileName)
        SELF:Caption := oOD:FileName
        FOR i:= 1 TO ALen(aOLEObjects)
        oOle := aOLEObjects[i]
        oOle:ExportToStorage(oOd:FileName, "CONTAINEROBJECT_"+AllTrim(AsString(i)))
        NEXT
        ENDIF
      </code>
    </example>
  </OLEObject.ExportToStorage>
  <OLEObject.HyperLabel>
    <summary>
      The HyperLabel object for the OLE object.
    </summary>
    <value>The HyperLabel object for the OLE object.</value>
  </OLEObject.HyperLabel>
  <OLEObject.ImportFromStorage>
    <summary>
      Imports an OLE object from a user-managed storage file.
    </summary>
    <param name="cFileName">The name of the storage file.</param>
    <param name="cStorageName">The name of the storage.</param>
    <example>
      The following example is from the OLE Container application in \CAVO25\SAMPLES\OLE\CONT:
      <code language="X#">
        METHOD FileLoad() CLASS ContainerShell
        LOCAL oOle AS DraggableOleObject
        LOCAL oOD AS OpenDialog
        LOCAL aStgNames AS ARRAY
        LOCAL i AS INT
        LOCAL oCont AS Container
        (oOD := OpenDialog{SELF, "*.CDF"}):Show()
        aStgNames := {}
        IF (!Empty(oOD:FileName) .and. GetStorageNames(oOD:FileName, aStgNames))
        oCont := SELF:FileNew()
        oCont:Caption := oOD:FileName
        IF (oCont != NULL_OBJECT)
        FOR i:=1 TO ALen(aStgNames)
        oOle := DraggableOleObject{oCont}
        IF (oOle:ImportFromStorage(oOD:Filename, aStgNames[i]))
        oCont:SetupOLEObject(oOle, NIL, TRUE)
        ELSE
        oOle:Destroy()
        ENDIF
        NEXT
        ENDIF
        ENDIF
      </code>
    </example>
  </OLEObject.ImportFromStorage>
  <OLEObject.IsInPlaceActive>
    <summary>
      A logical value indicating the activation status of the associated OLE object.
    </summary>
    <value>A logical value indicating the activation status of the associated OLE object.</value>
  </OLEObject.IsInPlaceActive>
  <OLEObject.LongName>
    <summary>
      The container application can ask the OLE object for long and short versions of the object's name, as well as its server's name. OLEObject:LongName returns the long version of the object's name.
    </summary>
    <value>The container application can ask the OLE object for long and short versions of the object's name, as well as its server's name. OLEObject:LongName returns the long version of the object's name.</value>
  </OLEObject.LongName>
  <OLEObject.No>
    <summary>
      Provide a general error interception that is automatically called whenever a reference is made to a non-existent method.
      <br />Important! NoMethod() should not be called directly; it is called by the system for handling invalid references.
    </summary>
  </OLEObject.No>
  <OLEObject.NoIVarGet>
    <summary>
      Provide a general error interception that is automatically called whenever an access reference is made to a non-existent access property.
      <include file="Gui.xml" path="doc/NoIVar/*" />
    </summary>
    <param name="symIVar">The symbolic name of the variable that was referenced.</param>
  </OLEObject.NoIVarGet>
  <OLEObject.NoIVarPut>
    <summary>
      Provide a general error interception that is automatically called whenever an assignment reference is made to a non-existent assign property.
      <include file="Gui.xml" path="doc/NoIVar/*" />
    </summary>
    <param name="symIVar">The symbolic name of the variable that was referenced.</param>
    <param name="uValue">The value to be assigned.</param>
  </OLEObject.NoIVarPut>
  <OLEObject.ReadOnly>
    <summary>
      A logical value that is TRUE if the OLE object is read-only. A read-only object cannot be edited by the user at runtime. The default value for this property is FALSE.
    </summary>
    <value>A logical value that is TRUE if the OLE object is read-only. A read-only object cannot be edited by the user at runtime. The default value for this property is FALSE.</value>
  </OLEObject.ReadOnly>
  <OLEObject.Redraw>
    <summary>
      Cause the OLE object to redraw itself.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </OLEObject.Redraw>
  <OLEObject.Repaint>
    <summary>
      Invalidate the OLE object so that an ExposeEvent is sent to the object.
    </summary>
    <remarks>
      The ExposeEvent triggers a redraw of the OLEObject container and its contained OLE object.
    </remarks>
  </OLEObject.Repaint>
  <OLEObject.SaveToDBStorage>
    <summary>
      Save an OLE object into a database storage.
    </summary>
    <param name="oOLEDBStorage">The OLEDBStorage object to use for the save operation.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      X# supports the ability to store an OLE object in a DBF database. To assign a new value to the OLEObject container, you pass an OLEDBStorage object to OLEObject:CreateFromDBStorage(). To save the persistent information of an OLE object in the database, you pass an OLEDBStorage object to OLEObject:SaveToDBStorage(). You usually get the OLEDBStorage object as a result of a FieldGet() call.
    </remarks>
    <example>
      The following code shows how to load an OLE object form a database and save it back again:
      <code language="X#">
        LOCAL oDBStg AS OLEDBStorage
        oDBStg := FieldGet(FieldPos(#PaintObject))
        oOLEContainer:CreateFromDBStorage(oDBStg)
        // do some editing with the OLE object
        oOLEContainer:SaveToDBStorage(oDBStg)
      </code>
    </example>
  </OLEObject.SaveToDBStorage>
  <OLEObject.ServerName>
    <summary>
      The container application can ask the OLE object for long and short versions of the object's name, as well as its servers name. OLEObject:ServerName returns the name of the OLE object's server.
    </summary>
    <value>The container application can ask the OLE object for long and short versions of the object's name, as well as its servers name. OLEObject:ServerName returns the name of the OLE object's server.</value>
  </OLEObject.ServerName>
  <OLEObject.SetHostNames>
    <summary>
      Set the name of the container application and the current document.
    </summary>
    <param name="cApp">The name of the container application.</param>
    <param name="cDoc">The name of the current document.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      These names are used during out-of-place editing in the server's window to identify the OLE object container application and the document in which it is located.
    </remarks>
  </OLEObject.SetHostNames>
  <OLEObject.ShortName>
    <summary>
      The container application can ask the OLE object for long and short versions of the object's name, as well as its servers name. OLEObject:ShortName returns the short version of the object's name.
    </summary>
    <value>The container application can ask the OLE object for long and short versions of the object's name, as well as its servers name. OLEObject:ShortName returns the short version of the object's name.</value>
  </OLEObject.ShortName>
  <OLEObject.UpdateTools>
    <summary>
      Update the container's toolbars.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Whenever an OLE object is in-place active, the server's toolbars can replace the X# container application's toolbars. In response to a resizing of the container application, OLEObject:UpdateToolbars() causes the OLE object server to rearrange its toolbars.
    </remarks>
    <example>
      The following code shows how a X# container application uses OLEObject:UpdateToolbars() in response to a resize event:
      <code language="X#">
        METHOD Resize(oResizeEvent) CLASS MyShell
        LOCAL oOLE AS OBJECT
        LOCAL oChild AS MyChild
        SUPER:Resize(oResizeEvent)
        oChild := SELF:GetActiveMDIChildObject()
        IF oChild != NULL_OBJECT
        oOLE := oChild:GetActiveOLEObject()
        IF oOLE != NULL_OBJECT
        oOLE:UpdateTools()
        ENDIF
        ENDIF
      </code>
    </example>
  </OLEObject.UpdateTools>
  <OLEShellWindow>
    <summary>
      Create a specialized shell window that includes support for in-place active OLE objects.
    </summary>
    <remarks>
      Note 	The functionality in the methods of this class has now been incorporated into the ShellWindow Class. The class name is retained for backward compatibility only.
    </remarks>
  </OLEShellWindow>
  <OLEShellWindow.ctor>
    <summary>
      Note -

      Construct an OLE shell window.
    </summary>
    <param name="oOwner">The window that owns the OLE shell window.</param>
  </OLEShellWindow.ctor>
  <OLEShellWindow.Dispatch>
    <summary>
      Note -

      Provide the prototype dispatcher for events within the system when the OLE shell window has focus, routing various events to their appropriate event handlers.
    </summary>
    <param name="oEvent">The event to be handled.</param>
    <seealso cref="T:VO.Event" />
    <returns>
      TRUE if the event was handled; otherwise, FALSE.
    </returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This method serves as an internal callback, dispatching events to various event handlers. It should never be necessary to call this method directly. Instead, you can write your own Dispatch() method for derived classes if you want to handle additional events. Usually the derived class Dispatch() should call SUPER:Dispatch() to support the inherited event handling.
      In addition to the functionality provided by the ShellWindow base class, the implementation for the OLEShellWindow class also includes support for handling in-place active OLE objects. For example, whenever the shell window is resized, it automatically asks the activated OLE objects to update their toolbars.
    </remarks>
  </OLEShellWindow.Dispatch>
  <OpenDialog>
    <summary>
      Present the user with a standard "file open" dialog box.
    </summary>
    <remarks>
      This type of dialog box presents the user with a list of file names. It allows the user to select a name from the list (or type the name of an existing file), and provides the ability to specify drive and/or directory if necessary.
      If a user enters a file name that does not already exist, Windows displays a modal dialog box indicating that the file name does not exist for the specified drive, directory, and file type.
    </remarks>
  </OpenDialog>
  <OpenDialog.ctor>
    <summary>
      Construct a standard "file open" dialog box.
    </summary>
    <param name="oOwnWnd">The window that owns the dialog box.</param>
    <param name="cInitPath">The name of the file that is initially selected when the dialog is first shown (i.e., *.* or *.TXT). The default is *.*, which means all files and their extensions.</param>
    <param name="dwFlag">Reserved for future use.</param>
    <remarks>
      <note type="tip">
        If the :SetFilter( ) method is going to be used, cFileName must be specified as "" because without this the filter will have no effect and the default of "*.*" will take effect so as to show all files.
      </note>
    </remarks>
  </OpenDialog.ctor>
  <Pair>
    <summary>
      Provide the base class from which all X# objects containing ordered pairs of values are subclassed.
    </summary>
    <remarks>
      <br />Important! Pair is an abstract class and should not be used directly—instead, use one of its subclasses, which include Dimension, Point, Range, and Selection.
    </remarks>
    <example>
      In this example, fractions are represented as ordered pairs of integers:
      <code language="X#">
        CLASS Fraction INHERIT Pair
        HIDDEN Num
        HIDDEN Denom
        METHOD Init(nVal1,nVal2) CLASS Fraction
        SUPER:Init(nVal1,nVal2)
        Num := nVal1
        Denom := nVal2
        METHOD Numerator() CLASS Fraction
        RETURN SELF:Num
        METHOD Denominator() CLASS Fraction
        RETURN SELF:Denom
      </code>
    </example>
  </Pair>
  <Pair.ctor>
    <summary>
      Construct a pair.
    </summary>
    <param name="uInt1">The first value of the pair. The default is 0.</param>
    <param name="uInt2">The second value of the pair. The default is 0.</param>
    <param name="Int1">The first value of the pair. The default is 0.</param>
    <param name="Int2">The second value of the pair. The default is 0.</param>
  </Pair.ctor>
  <PaletteDialog>
    <summary>
      Present the user with a standard color palette dialog box, allowing the user to define custom colors.
    </summary>
    <remarks>
      This type of dialog box presents the user with a palette of available colors as a series of "boxes," allowing the user to select a color by clicking a box. It also allows the user to create and select their own custom colors.
    </remarks>
  </PaletteDialog>
  <PaletteDialog.ctor>
    <summary>
      Construct a standard color palette dialog.
    </summary>
    <param name="uOwner">The window that owns the palette dialog.</param>
    <param name="oColor">The color initially selected for the PaletteDialog object. The default is black. (Refer to the Color:Init() method for details on specifying a color.)</param>
  </PaletteDialog.ctor>
  <Pen>
    <summary>
      Create a pen, which can be used to draw lines in a particular color, style, and width. Pens are used by the Window:LineTo() method and the DrawObject hierarchy.
    </summary>
    <remarks>
      X# provides a set of predefined pens, which are specified in the Pen:Init() method (the default color and width is used). In addition, if desired, you can also create a brush by specifying a color, line style, and width.
      Each window has a current pen, which can be set or changed using the Window:Pen property. A window's pen is used in subsequent line and rectangle drawing operations, and should not be deleted while it is the current selection.
    </remarks>
    <example>
      The following example creates a pen and draws a line:
      <code language="X#">
        oMyPen := Pen{Color{COLORRED}, LINESOLID, 1}
        oOldPen := oMyWin:Pen
        oMyWin:Pen := oMyPen
        oMyWin:MoveTo(Point{100,100})
        oMyWin:LineTo(Point{200,100})
        oMyWin:Pen := oOldPen
      </code>
    </example>
  </Pen>
  <Pen.ctor>
    <summary>
      Construct a pen.
    </summary>
    <param name="uColor">The pen's color. The default is black. (Refer to the Color:Init() method for details on specifying a color.)</param>
    <param name="uLineStyle">
      The pen's style, specified as one of the following constants:
    </param>
    <param name="uWidth">The pen's width, in canvas coordinates. The default is 1.</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>LINECLEAR</term>
          <description>
            Invisible, which can be used to simplify the program logic.
            This is a shortcut to changing a point position without calling the MoveTo() and LineTo()
            functions (as in the code example under Pen class).
          </description>
        </item>
        <item>
          <term>LINEDASHDOT</term>
          <description>Alternating dash/dot pattern.</description>
        </item>
        <item>
          <term>LINEDASHDOTDOT</term>
          <description>A repeating sequence of a dash followed by two dots.</description>
        </item>
        <item>
          <term>LINEDASHED</term>
          <description>Dashes.</description>
        </item>
        <item>
          <term>LINEDOTTED</term>
          <description>Dots.</description>
        </item>
        <item>
          <term>LINESOLID</term>
          <description>A continuous line. This is the default.</description>
        </item>
      </list>
    </remarks>
  </Pen.ctor>
  <Pen.Destroy>
    <summary>
      Provide a method to de-instantiate a Pen object.
    </summary>
    <remarks>
      This method can be used when a Pen object is no longer needed. Pen:Destroy() de-instantiates the Pen object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </Pen.Destroy>
  <Pen.Handle>
    <summary>
      Return the handle for a pen.
    </summary>
    <param name="uType">
      The type of handle required. 0 is the only supported option and is the default if <paramref name="nHandle" /> is omitted.
    </param>
    <returns>
      A handle describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
    </remarks>
  </Pen.Handle>
  <PieObject>
    <summary>
      Construct a PieObject object.
    </summary>
  </PieObject>
  <PieObject.ctor>
    <summary>
      Construct a PieObject object.
    </summary>
    <param name="oPoint">The position of the PieObject object in canvas coordinates.</param>
    <param name="oDimension">The dimension of the PieObject object in canvas coordinates.</param>
    <param name="oPen">The pen used to draw the PieObject object. By default, the current pen is used.</param>
    <param name="oBrush">The brush used to fill the PieObject object. By default, the current brush is used.</param>
    <param name="iStartAngle">The starting angle of the pie shape in degrees (0 to 360).</param>
    <param name="iEndAngle">The ending angle of the pie shape in degrees (0 to 360).</param>
  </PieObject.ctor>
  <PieObject.Draw>
    <summary>
      Draw a PieObject object which represents a pie-shaped portion of an ellipse.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This method should not be invoked directly in the application code--it is invoked in X# by Window:Draw().
    </remarks>
    <example>
      To draw a PieObject object, call Window:Draw() with the PieObject object as its argument. The window does the drawing by asking each object to draw itself--for example:
      <code language="X#">
        METHOD Expose(oEvent) CLASS MyWindow
        LOCAL oPie AS OBJECT
        oPie := PieObject{Point{10,10},;
        Dimension{20,40},;
        Pen{Color{COLORBLACK}},;
        Brush{Color{COLORRED}}, 0, 180}
        SELF:Draw(oPie)
      </code>
    </example>
  </PieObject.Draw>
  <Point>
    <summary>
      Create a point, which is used to describe a location on the canvas of a window.
    </summary>
    <remarks>
      The Point class does not interpret the coordinates—whether they are screen or canvas coordinates is context-dependent.
    </remarks>
    <example>
      For an example using the Point class, refer to the ResourceFile class example.
    </example>
  </Point>
  <Point.ctor>
    <summary>
      Construct a point.
    </summary>
    <param name="nX">The x coordinate of the point. The default is 0.</param>
    <param name="nY">The y coordinate of the point. The default is 0.</param>
  </Point.ctor>
  <Point.ConvertToScreen>
    <exclude />

  </Point.ConvertToScreen>
  <Point.X>
    <summary>
      An integer representing this point's x coordinate.
    </summary>
    <value>An integer representing this point's x coordinate.</value>
  </Point.X>
  <Point.Y>
    <summary>
      An integer representing this point's y coordinate.
    </summary>
    <value>An integer representing this point's y coordinate.</value>
  </Point.Y>
  <Pointer>
    <summary>
      Create a mouse cursor, which is used to visually represent the mouse in a window.
    </summary>
    <remarks>
      X# provides a set of predefined pointers, defined in Pointer:Init(). In addition, if desired, you can also create pointers from resource entities.
      Each window can have its own pointer, and various pointer characteristics can be set, changed, or interrogated. As the pointer moves from the canvas area of one window to another, the GUI changes the pointer representation to that of the new window.
      Tip: In X#, the class Pointer corresponds to a mouse cursor; use class Cursor to create text cursors.
    </remarks>
    <example>
      The following example provides an application window with a custom cursor:
      <code language="X#">
        CLASS MyTopAppWin INHERIT TopAppWindow
        METHOD Init CLASS MyTopAppWin
        SUPER:Init()
        SELF:Pointer := Pointer{IDC_APPCURSOR}
        RESOURCE IDC_APPCURSOR CURSOR app.cur
      </code>

      In Windows, pointers are sometimes called cursors. You can create a pointer in a resource entity.
    </example>
  </Pointer>
  <Pointer.ctor>
    <summary>
      Load a pointer from a resource entity.
    </summary>
    <param name="xResourceID">
      The resource ID of the desired pointer.
      If <paramref name="kResourceID" /> is specified, use one of the constants listed below:
    </param>
    <remarks>
      <list>
        <item>
          <term>Pointer</term>
          <description>Description</description>
        </item>
        <item>
          <term>POINTERARROW</term>
          <description>A pointer commonly used for selecting and pointing at objects. This is the default.</description>
        </item>
        <item>
          <term>POINTERCROSSHAIRS</term>
          <description>A pointer commonly used for selecting and drawing graphic objects.</description>
        </item>
        <item>
          <term>POINTERFOURARROW</term>
          <description>A pointer commonly used for moving objects.</description>
        </item>
        <item>
          <term>POINTERHOURGLASS</term>
          <description>A pointer commonly used to indicate a delay.</description>
        </item>
        <item>
          <term>POINTERIBEAM</term>
          <description>A pointer commonly used for text entry.</description>
        </item>
        <item>
          <term>POINTERICON</term>
          <description>A pointer used for moving icons.</description>
        </item>
        <item>
          <term>POINTERUPARROW</term>
          <description>A pointer commonly used to drag a selection to a new location and "drop" or insert it.</description>
        </item>
      </list>
      <note type="tip">The icon specified by the POINTERICON resource ID takes on the appearance of the icon being moved.</note>
    </remarks>
  </Pointer.ctor>
  <Pointer.Confine>
    <summary>
      Confine the movement of this pointer to a given set of screen coordinates.
    </summary>
    <param name="oRect">The bounding box representing the set of screen coordinates in which the pointer can move.</param>
  </Pointer.Confine>
  <Pointer.Destroy>
    <summary>
      Provide a method to de-instantiate a Pointer object.
    </summary>
    <remarks>
      This method can be used when a Pointer object is no longer needed. Pointer:Destroy() de-instantiates the Pointer object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </Pointer.Destroy>
  <Pointer.Handle>
    <summary>
      Return the handle for a pointer.
    </summary>
    <param name="nHandleType">
      The type of handle required. 0 is the only supported option and is the default if <paramref name="nHandle" /> is omitted.
    </param>
    <returns>
      A handle describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
    </remarks>
  </Pointer.Handle>
  <Pointer.Hide>
    <summary>
      Hide this pointer so it is not visible. Hide a control so it is not visible (until a subsequent call to Pointer:Show()).
    </summary>
    <remarks>
      Multiple calls to Pointer:Hide() require multiple calls to Pointer:Show() before the pointer is redisplayed.
    </remarks>
  </Pointer.Hide>
  <Pointer.Position>
    <summary>
      A point representing the position of this pointer on the window, in screen coordinates.
    </summary>
    <value>A point representing the position of this pointer on the window, in screen coordinates.</value>
    <remarks>
      A point representing the position of this pointer on the window, in screen coordinates.
      Alternatively, you can use the MouseMove() or MouseDrag() event handlers of class Window and use Where() to get the location of the pointer in screen coordinates.
    </remarks>
  </Pointer.Position>
  <Pointer.Show>
    <summary>
      Display a pointer so it is visible.
    </summary>
    <remarks>
      By default, pointers are always visible until hidden, so there is no need to call the Pointer:Show() method unless Pointer:Hide() was previously called.
      <note type="tip">Multiple calls to Pointer:Hide() require multiple calls to Pointer:Show() before the pointer is redisplayed.</note>
    </remarks>
  </Pointer.Show>
  <Printer>
    <summary>
      Create an object that represents a single print job.
    </summary>
    <remarks>
      It is essential to check the validity of a Printer object—using Printer:IsValid()—before using it.
      To use a printer, the application should call Printer:Start(), which repeatedly calls Printer:PrinterExpose() for each page printed until the final page, in which it returns FALSE. Printer:Start() returns when the print job is finished.
      You can also:
      Determine the size of the page using Window:CanvasArea and Window:WindowArea to return the size of the printable area and total page size, respectively
      Scale the printout using Window:Size
      Determine the origin using Window:Origin (for example, to create margins)
      X# will only print the correct font if it exists for your printer; otherwise, the font that is most similar is used.
      Printing is done in printer coordinates, which are device dependent. Use the methods described here to scale and size your printout. Also note that for business printing, such as management reports, invoices, and notification letters, it is usually more convenient to design a report with the Report Editor and then run the report using the ReportQueue class. For more information, refer to the Programmer's Guide.
    </remarks>
    <example>
      The following example prints the text "Hello World":
      <code language="X#">
        METHOD PrinterExpose(oPEE) CLASS PrinterClass
        SELF:TextPrint("Hello World",Point{30,30})
        RETURN FALSE			// Nothing more to print
        CLASS PrinterClass INHERIT Printer
        METHOD Init() CLASS PrinterClass
        SUPER:Init()
        RETURN SELF
        METHOD MenuCommand(oMCE) CLASS StandardShellWindow
        LOCAL oPrinter AS PrinterClass
        IF(oMCE:ItemID = ;
        IDM_EMPTYSHELLMENU_FILE_PRINT_ID)
        // File Print menu item ID
        oPrinter := PrinterClass{}
        IF(oPrinter:IsValid())
        oPrinter:Start()
        oPrinter:Destroy()
        ENDIF
        ENDIF
      </code>
    </example>
  </Printer>
  <Printer.ctor>
    <summary>
      Construct a printer job.
    </summary>
    <param name="cJobname">The name passed to Print Manager, a Windows application, to identify the print job. If omitted, the default is NULL_STRING.</param>
    <param name="oDevice">The printing device to use. If omitted, the default is the currently selected printer installed by the user through Windows.</param>
  </Printer.ctor>
  <Printer.Abort>
    <summary>
      Instruct the printer to abort the current print job.
    </summary>
    <remarks>
      Typically, you would create and display a dialog before starting the print job. If the user presses a push button on the dialog window to cancel the job, the Window:ButtonClick() event handler would invoke this method.
    </remarks>
    <example>
      This example displays a dialog and starts a print job. If the Abort push button is pressed, the Window:ButtonClick() event handler aborts the job:
      <code language="X#">
        CLASS AbortDialog INHERIT DialogWindow
        HIDDEN oPrintJob AS OBJECT
        METHOD Init(oWindow,oPrinter) CLASS AbortDialog
        SUPER:Init(oWindow,ResourceID{IDD_ABORT})
        oPrintJob := oPrinter
        METHOD ButtonClick(oControlEvent) CLASS AbortDialog
        oPrintJob:Abort()
        SELF:EndDialog(1)
        METHOD FilePrint() CLASS TopAppWindow
        oPrinter := Printer{}
        IF(oPrinter:IsValid())
        oDialog := AbortDialog{SELF,oPrinter}
        oDialog:Show()
        oPrinter:Start()
        ENDIF
      </code>
    </example>
  </Printer.Abort>
  <Printer.Aborted>
    <exclude />
  </Printer.Aborted>
  <Printer.BeginDoc>
    <exclude />
  </Printer.BeginDoc>
  <Printer.CanvasArea>
    <exclude />
  </Printer.CanvasArea>
  <Printer.Destroy>
    <summary>
      Provide a method to de-instantiate a Printer object.
    </summary>
    <remarks>
      This method can be used when a Printer object is no longer needed. Printer:Destroy() de-instantiates the Printer object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </Printer.Destroy>
  <Printer.Handle>
    <summary>
      Return the handle for a printer.
    </summary>
    <param name="ServiceID">
      The type of handle required. 0 is the only supported option and is the default if <paramref name="ServiceID" /> is omitted.
    </param>
    <returns>
      A handle describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the Windows GDI object, which can then be used by Windows API GDI calls.
    </remarks>
  </Printer.Handle>
  <Printer.Idle>
    <summary>
      Instruct the system to process events while printing.
    </summary>
    <remarks>
      Printer:Idle() causes the system to continually check for other messages and process them, thus providing "background printing" functionality. If this method is not called, the system halts until the print operation is complete.
    </remarks>
  </Printer.Idle>
  <Printer.IsValid>
    <summary>
      Determine if a printer is valid.
    </summary>
    <returns>
      TRUE if valid; otherwise, FALSE.
    </returns>
    <remarks>
      It is essential to check the validity of a Printer object before using it.
    </remarks>
  </Printer.IsValid>
  <Printer.lprAbort>
    <exclude />
  </Printer.lprAbort>
  <Printer.NewPage>
    <summary>
      Direct the attached printer to eject to a new page.
    </summary>
  </Printer.NewPage>
  <Printer.PrinterError>
    <summary>
      Called if a printer error occurs. PrintErrorEvent is interrogated to identify the type of error has occurred.
    </summary>
    <param name="oPerr">The printer error event that is being handled.</param>
    <returns>
      TRUE if the print job is to be retried (i.e., the error is to be ignored); FALSE if the print job is to be canceled.
    </returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </Printer.PrinterError>
  <Printer.PrinterExpose>
    <summary>
      Invoked for each page (or part of a page) of the print job whenever it needs repainting.
    </summary>
    <param name="oPrinterExposeEvt">The expose event that describes which page (or part of a page) of the print job needs painting.</param>
    <returns>
      TRUE if there is another page (or part of a page) to print; FALSE if the last page has been printed.
    </returns>
  </Printer.PrinterExpose>
  <Printer.Start>
    <summary>
      Start a print job or contiguous portion of a print job.
    </summary>
    <param name="oRange">The range of pages to be printed. For example, to print pages 5 to 10 inclusive, specify Start(Range{5,10}). If omitted, Printer:PrinterExpose() is called until FALSE is returned.</param>
  </Printer.Start>
  <Printer.WindowArea>
    <exclude />
  </Printer.WindowArea>
  <PrinterErrorEvent>
    <summary>
      Provide information about a PrinterErrorEvent, used to describe errors that occur during a print job (for example, insufficient memory or disk space).
    </summary>
    <remarks>
      By default, the event handler displays a text box for the "no disk space" message. The error handler does not abort automatically, but prompts the user to abort or retry. If the user retries, the system returns control to the Print Manager. However, the device drivers of some printers can prohibit such a message.
      All other errors should cause a printer abort.
    </remarks>
  </PrinterErrorEvent>
  <PrinterErrorEvent.ctor>
    <inheritdoc />
  </PrinterErrorEvent.ctor>
  <PrinterErrorEvent.ErrorType>
    <summary>
      One of the following events that are passed to the Printer:Expose() method, when the system requires another page to be painted and sent to the Print Manager:
    </summary>
    <value>One of the following events that are passed to the Printer:Expose() method, when the system requires another page to be painted and sent to the Print Manager:</value>
    <remarks>
      One of the following events that are passed to the Printer:Expose() method, when the system requires another page to be painted and sent to the Print Manager:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>PRINTERERRORFATALDEVICEERROR</term>
          <description>The printer device could not be created or initialized correctly.</description>
        </item>
        <item>
          <term>PRINTERERRORGENERALERROR</term>
          <description>A general unidentifiable (system-specific) error has occurred.</description>
        </item>
        <item>
          <term>PRINTERERRORNODISKSPACE</term>
          <description>The Window's Print Manager has run out of disk space to complete the job. This is not necessarily fatal.</description>
        </item>
        <item>
          <term>PRINTERERRORNOMEMSPACE</term>
          <description>Insufficient memory to complete the job.</description>
        </item>
        <item>
          <term>PRINTERERRORUSERABORT</term>
          <description>The user or application has aborted the job.</description>
        </item>
      </list>
    </remarks>
  </PrinterErrorEvent.ErrorType>
  <PrinterExposeEvent>
    <summary>
      Provides facilities for determining the number of the page to be painted, as well as the area of the page to be painted.
    </summary>
    <remarks>
      Some printer drivers may request the page to be painted in segments ("banding printer"). PrinterExposeEvent:ExposedArea defines the area of the page to be painted, in the form of a BoundingBox object, in printer coordinates. If the full page is requested, the bounding box is equal to the full page size.
    </remarks>
  </PrinterExposeEvent>
  <PrinterExposeEvent.ctor>
    <inheritdoc />
  </PrinterExposeEvent.ctor>
  <PrinterExposeEvent.ExposedArea>
    <summary>
      A bounding box representing the area of the page to be printed, in printer coordinates.
    </summary>
    <value>A bounding box representing the area of the page to be printed, in printer coordinates.</value>
    <remarks>
      A bounding box representing the area of the page to be printed, in printer coordinates. Windows measures the size or portion of the page to be printed as what is contained in a bounding box. This is usually a full page, but on printers with limited memory (that can't print a full page), it is the area of the page to be printed.
    </remarks>
  </PrinterExposeEvent.ExposedArea>
  <PrinterExposeEvent.PageNo>
    <summary>
      A numeric value representing the number of the page to be painted.
    </summary>
    <value>A numeric value representing the number of the page to be painted.</value>
  </PrinterExposeEvent.PageNo>
  <PrintingDevice>
    <summary>
      Create an object that allows you to set up the printing device for an application. It also allows you to invoke the standard dialog box to configure a default printer and change values, such as changing the page orientation or paper source.
    </summary>
  </PrintingDevice>
  <PrintingDevice.ctor>
    <summary>
      Construct a PrintingDevice object.
    </summary>
    <param name="uName">
      The comma-separated string indicating the printer driver to be used. In Windows, this string should be given in the following form:
      &lt;PrinterInfo&gt;,&lt;PrinterDriver&gt;,&lt;Port&gt;
      For example, you might specify:
      'PostScript Printer,PSSCRIPT,LPT1:'
      If omitted, the default printer driver is used.
      NOTE: There are no spaces at the beginning or end of each part of this string. Spaces should only be used where they appear in the parameter.
    </param>
  </PrintingDevice.ctor>
  <PrintingDevice.Copies>
    <summary>
      Specifies the number of copies printed if the device supports multiple-page copies.
    </summary>
    <value>Specifies the number of copies printed if the device supports multiple-page copies.</value>
  </PrintingDevice.Copies>
  <PrintingDevice.Destroy>
    <summary>
      Provide a method to de-instantiate a PrintingDevice object.
    </summary>
    <remarks>
      This method can be used when a PrintingDevice object is no longer needed. PrintingDevice:Destroy() de-instantiates the PrintingDevice object, and allows you to close and free any resources that were opened or created by the object without waiting for the garbage collector.
    </remarks>
  </PrintingDevice.Destroy>
  <PrintingDevice.Device>
    <summary>
      Specifies the printer device to be used.
    </summary>
    <value>Specifies the printer device to be used.</value>
  </PrintingDevice.Device>
  <PrintingDevice.DeviceCapabilities>
    <summary>
      Obtain information about the capabilities printing device.
    </summary>
    <param name="wCapability">
      The capability to be queried, specified by a Windows API device capability constant. For example, you might specify:
      'DC_PAPERNAMES'
      If omitted, the default capability is used.
    </param>
    <returns>
      A usual variable containing a X# dynamic array or WORD. A value represented by the constant CAPABILITY_NOT_AVAILABLE indicates that the attempt to retrieve the value was unsuccessful. The return value varies according to the <paramref name="kCapability" />. Refer to the Windows SDK topic on DeviceCapabilites for return values. If the SDK indicates that the return value is an array or a point structure then the return value will contain a VO dynamic array; otherwise it will contain a word.
    </returns>
    <remarks>
      This method provides information about the capabilities of a printing device object.
    </remarks>
    <example>
      This is an example of a ListBox FillUsing method to populate the list box with a two dimensional array containing available paper sizes. The first dimension contains the display values and the second the return values.
      <code language="X#">
        SELF:oPrint is assumed to be a Printer object
        METHOD FillPaperSizesListBox() CLASS; MyPrintReportWindow
        LOCAL aDisplayValues, aReturnValues, aListBoxValues;
        := {} AS ARRAY
        LOCAL 	i, wALen AS DWORD
        aDisplayValues :=;
        SELF:oPrint:PrintingDevice:DeviceCapabilities;
        (DC_PAPERNAMES)
        aReturnValues	:=;
        SELF:oPrint:PrintingDevice:DeviceCapabilities;
        (DC_PAPERS)
        wALen := ALen(aDisplayValues)
        FOR i := 1 UPTO wALen
        aAdd(aListBoxValues,;
        {aDisplayValues[i],;
        aReturnValues[i]})
        NEXT
        RETURN aListBoxValues
      </code>
      This example creates a Printer object using the default device driver. Various device capabilities are queried and displayed.
      <code language="X#">
        LOCAL uValue			AS USUAL
        LOCAL oP, oPD	   AS OBJECT
        // Create Printer object using default device and
        // get reference to PrintingDevice object
        oP := Printer{}
        oPD := oP:PrintingDevice
        // List names of available paper sizes
        uValue := oPD:DeviceCapabilities(DC_PAPERNAMES)
        QOut("Show "+"DC_PAPERNAMES")
        ShowValue(uValue)
        InKey(0)
        // List names of available bins
        uValue := oPD:DeviceCapabilities(DC_PAPERNAMES)
        QOut("Show "+"DC_PAPERNAMES")
        ShowValue(uValue)
        InKey(0)
        // Destroy printer object (reclaim GDI resources)
        oP:Destroy()
        FUNCTION ShowValue(uValue)
        IF IsArray(uValue)
        AEval(uValue, {|u| ShowValue(u)});
        // recurse until single element found
        ELSEIF IsNumeric(uValue) .AND.;
        uValue = CAPABILITY_NOT_AVAIALBLE
        QOut ("Device capability not available;
        from driver")
        ELSE
        QOut(uValue)
        ENDIF
      </code>
    </example>
  </PrintingDevice.DeviceCapabilities>
  <PrintingDevice.Driver>
    <summary>
      A string representing the printer driver to be used.
    </summary>
    <value>A string representing the printer driver to be used.</value>
  </PrintingDevice.Driver>
  <PrintingDevice.GetDevMode>
    <summary>
      Retrieve a pointer to the DevMode structure.
    </summary>
    <returns>
      A pointer to the DevMode structure or 0 if the structure is inaccessible. You should store this pointer in a variable typed "AS _WINDEVMODE".
    </returns>
    <remarks>
      The DevMode structure is documented in the Win32 SDK and is defined in the X# Win32 API Library. This structure resides in the underlying PrintingDevice object and is created by using the device driver associated with the object.
      Updates to members of this structure are applied via the PrintingDevice:UpdateDevMode() method.
    </remarks>
    <example>
      This example accesses and displays various information from the DevMode structure:
      <code language="X#">
        oPD is assumed to be a PrintingDevice object.
        LOCAL structDevMode	AS _WINDEVMODE
        LOCAL i		AS DWORD
        LOCAL cDeviceName	AS STRING
        LOCAL cOrientation	AS STRING
        structDevMode := oPD:GetDevMode()
        FOR i := 1 TO CCHDEVICENAME
        cDeviceName:=cDeviceName+Chr(structDevMode.dmDeviceName[i])
        NEXT
        ?"Device name is "
        ??cDeviceName
        cOrientation := StringdmOrientation(structDevMode.dmOrientation)
        ?"Orientation is "
        ??cOrientation
        ?"PaperLength is "
        ??AllTrim(Str(structDevMode.dmPaperLength))
        ?"PaperWidth is "
        ??AllTrim(Str(structDevMode.dmPaperWidth))
        ?"Number of copies is "
        ??AllTrim(Str(structDevMode.dmCopies))
        ? "dmDefaultSource "
        ?structDevMode.dmDefaultSource
        Wait
        FUNCTION StringdmOrientation(nO AS SHORTINT) AS STRING
        IF nO = DMORIENT_LANDSCAPE
        RETURN "Landscape"
        ELSEIF nO = DMORIENT_PORTRAIT
        RETURN "Portrait"
        ELSE
        RETURN "Unknown"
        ENDIF
      </code>
    </example>
  </PrintingDevice.GetDevMode>
  <PrintingDevice.IsValid>
    <summary>
      Determine if a printing device is valid.
    </summary>
    <returns>
      TRUE if valid; otherwise, FALSE.
    </returns>
  </PrintingDevice.IsValid>
  <PrintingDevice.Orientation>
    <summary>
      Specifies whether the orientation of the paper is portrait or landscape.
    </summary>
    <value>Specifies whether the orientation of the paper is portrait or landscape.</value>
  </PrintingDevice.Orientation>
  <PrintingDevice.PaperHeight>
    <summary>
      Specifies paper length, in tenths of a millimeter.
    </summary>
    <value>Specifies paper length, in tenths of a millimeter.</value>
    <remarks>
      Specifies paper length, in tenths of a millimeter. This parameter overrides the paper length specified by the member of the DevMode structure, PaperSize, either for custom paper sizes or for such devices as dot-matrix printers that can print on a variety of page sizes.
    </remarks>
  </PrintingDevice.PaperHeight>
  <PrintingDevice.PaperSize>
    <summary>
      Specifies the size of the paper to print on.
    </summary>
    <value>Specifies the size of the paper to print on.</value>
    <remarks>
      Specifies the size of the paper to print on. This member may be set to zero if the length and width of the paper are specified by the members of the DevMode structure, PaperLength and PaperWidth, respectively. Otherwise, the dmPaperSize member can be set to one of the following predefined values:
      Value	Desription
      DMPAPER_FIRST	DMPAPER_LETTER
      DMPAPER_LETTER	Letter, 8 1/2 x 11 in.
      DMPAPER_LETTERSMALL	Letter Small, 8 1/2 x 11 in.
      DMPAPER_TABLOID	Tabloid, 11 x 17 in.
      DMPAPER_LEDGER	Ledger, 17 x 11 in.
      DMPAPER_LEGAL	Legal, 8 1/2 x 14 in.
      DMPAPER_STATEMENT	Statement, 5 1/2 x 8 1/2 in.
      DMPAPER_EXECUTIVE	Executive, 7 1/2 x 10 1/2 in.
      DMPAPER_A3	A3, 297 x 420 mm
      DMPAPER_A4	A4, 210 x 297 mm
      DMPAPER_A4SMALL	A4 Small, 210 x 297 mm
      DMPAPER_A5	A5, 148 x 210 mm
      DMPAPER_B4	B4, 250 x 354 mm
      DMPAPER_B5	B5, 182 x 257 mm
      DMPAPER_FOLIO	Folio, 8 1/2 x 13 in.
      DMPAPER_QUARTO	Quarto, 215 x 275 mm
      DMPAPER_10X14	10 x 14 in.
      DMPAPER_11X17	11 x 17 in.
      DMPAPER_NOTE	Note, 8 1/2 x 11 in.
      DMPAPER_ENV_9	Envelope #9, 3 7/8 x 87/8in.
      DMPAPER_ENV_10	Envelope #10, 4 1/8 x 91/2in.
      DMPAPER_ENV_11	Envelope #11, 4 1/2 x 103/8in.
      DMPAPER_ENV_12	Envelope #12, 4 1/2 x 11 in.
      DMPAPER_ENV_14	Envelope #14, 5 x 11 1/2 in.
      DMPAPER_CSHEET	C size sheet
      DMPAPER_DSHEET	D size sheet
      DMPAPER_ESHEET	E size sheet
      DMPAPER_ENV_DL	Envelope DL, 110 x 220 mm
      DMPAPER_ENV_C3	Envelope C3, 324 x 458 mm
      DMPAPER_ENV_C4	Envelope C4, 229 x 324 mm
      DMPAPER_ENV_C5	Envelope C5, 162 x 229 mm
      DMPAPER_ENV_C6	Envelope C6, 114 x 162 mm
      DMPAPER_ENV_C65	Envelope C65, 114 x 229 mm
      DMPAPER_ENV_B4	Envelope B4, 250 x 353 mm
      DMPAPER_ENV_B5	Envelope B5, 176 x 250 mm
      DMPAPER_ENV_B6	Envelope B6, 176 x 125 mm
      DMPAPER_ENV_ITALY	Envelope, 110 x 230 mm
      DMPAPER_ENV_MONARCH	Envelope Monarch, 3 7/8 x 71/2 in.
      DMPAPER_ENV_PERSONAL	Envelope, 3 5/8 x 6 1/2 in.
      DMPAPER_FANFOLD_US	U.S. Standard Fanfold, 147/8 x 11 in.
      DMPAPER_FANFOLD_STD_GERMAN	German Standard Fanfold, 81/2 x 12 in.
      DMPAPER_FANFOLD_LGL_GERMAN	German Legal Fanfold, 81/2 x 13 in.
      DMPAPER_LAST	German Legal Fanfold, 81/2 x 13 in.
      DMPAPER_USER	User-defined
    </remarks>
  </PrintingDevice.PaperSize>
  <PrintingDevice.PaperWidth>
    <summary>
      Specifies paper width, in tenths of a millimeter. This parameter overrides the paper width specified by the dmPaperSize member.
    </summary>
    <value>Specifies paper width, in tenths of a millimeter. This parameter overrides the paper width specified by the dmPaperSize member.</value>
  </PrintingDevice.PaperWidth>
  <PrintingDevice.Port>
    <summary>
      Specifies the default port setting for the printer.
    </summary>
    <value>Specifies the default port setting for the printer.</value>
  </PrintingDevice.Port>
  <PrintingDevice.SetUp>
    <summary>
      Display the standard Windows Printer Setup dialog box, which allows the user to configure or change a default printer and set page orientation, paper size, and paper source (e.g., Manual Feed, Upper Tray, etc.).
    </summary>
    <returns>
      Returns TRUE, if the OK button is pressed; or FALSE, if the Cancel button is pressed, thus closing the Windows Printer Setup dialog box.
    </returns>
  </PrintingDevice.SetUp>
  <PrintingDevice.UpdateDevMode>
    <summary>
      Apply changes made to the DevMode structure to the associated device driver.
    </summary>
    <returns>
      A logic indicating the success of the update.
    </returns>
    <remarks>
      UpdateDevMode() copies the information in the PrintingDevice objects DevMode structure to the printer driver. Access to the structure is provide via the PrintingDevice:GetDevMode() method.
      You must first use this method to obtain a pointer to the structure. This structure resides in the underlying PrintingDevice object.
    </remarks>
    <example>
      This example changes the orientation to landscape and sets the number of copies to be printed to10.
      <code language="X#">
        oPD is assumed to be a PrintingDevice object.
        LOCAL structDevMode	AS _WINDEVMODE	// AS allocates memory for
        // the pointer not the structure
        structDevMode := oPD:GetDevMode()	// map printing devices devmode
        // structure
        structDevMode.dmCopies	:= 10
        structDevMode.dmOrientation	:= DMORIENT_PORTRAIT
        lSuccess := oPD:UpdateDevMode()
        IF !lSuccess
        ? "Error updating devmode"
        ELSE
        ? "devmode updated successfully"
        ENDIF
        InKey(0)
        // destroy printer object (reclaim GDI resources)
        oP:Destroy()
        FUNCTION ShowValue(uValue)
        IF IsArray(uValue)
        AEval(uValue, {|u| ShowValue(u)})	// recurse until
        // single element found
        ELSEIF IsNumeric(uValue) .AND. uValue = CAPABILITY_NOT_AVAIALBLE
        QOut("Device capability not available from driver")
        ELSE
        QOut(uValue)
        ENDIF
      </code>
    </example>
  </PrintingDevice.UpdateDevMode>
  <ProgressBar>
    <summary>
      Create a progress bar.
    </summary>
    <remarks>
      A progress bar is a control that can be used to indicate the progress of an operation. It is a horizontal bar filled from left to right with the system highlight color as an operation progresses.
    </remarks>
  </ProgressBar>
  <ProgressBar.ctor>
    <summary>
      Construct a progress bar.
    </summary>
    <param name="oOwner">The window that owns the progress bar.</param>
    <param name="xID">The unique ID of the progress bar (between 1 and 8000).</param>
    <param name="oPoint">The origin of the progress bar in canvas coordinates.</param>
    <param name="oDimension">The dimension of the progress bar in canvas coordinates.</param>
    <param name="kStyle">The style of the progress bar.</param>
    <param name="lDataAware">A logical value specifying whether the progress bar is data aware.</param>
    <param name="nResourceID">The resource ID of the progress bar.</param>
  </ProgressBar.ctor>
  <ProgressBar.Advance>
    <summary>
      Advance the progress bar to a new position.
    </summary>
    <param name="dwNewPosition">The amount by which the progress bar is advanced. If omitted, the progress bar is advanced by the unit size.</param>
    <returns>
      The amount by which the progress bar is advanced.
    </returns>
  </ProgressBar.Advance>
  <ProgressBar.BackgroundColor>
    <summary>
      A Color object specifying the background color for the progress bar.
    </summary>
    <value>A Color object specifying the background color for the progress bar.</value>
  </ProgressBar.BackgroundColor>
  <ProgressBar.BarColor>
    <summary>
      A Color object specifying the bar color for the progress bar control.
    </summary>
    <value>A Color object specifying the bar color for the progress bar control.</value>
  </ProgressBar.BarColor>
  <ProgressBar.OldPosition>
    <summary>
      A numeric value representing the previous position of the progress bar.
    </summary>
    <value>A numeric value representing the previous position of the progress bar.</value>
  </ProgressBar.OldPosition>
  <ProgressBar.Position>
    <summary>
      A numeric value representing the current position of the progress bar.
    </summary>
    <value>A numeric value representing the current position of the progress bar.</value>
  </ProgressBar.Position>
  <ProgressBar.Range>
    <summary>
      A Range object representing the minimum and maximum values currently in use for the progress bar.
    </summary>
    <value>A Range object representing the minimum and maximum values currently in use for the progress bar.</value>
  </ProgressBar.Range>
  <ProgressBar.UnitSize>
    <summary>
      A numeric value representing the unit size currently associated with the progress bar.
    </summary>
    <value>A numeric value representing the unit size currently associated with the progress bar.</value>
  </ProgressBar.UnitSize>
  <PushButton>
    <summary>
      Create a push button, which can be used to initiate an event and associated action when clicked on by the user.
    </summary>
    <remarks>
      Unlike check boxes and radio buttons, which have an identifiable state, push buttons have no state; they are always ready to be clicked. However, you can specify one of the push buttons on a window to be the default button, in which case it can be activate by pressing the Enter key; the default push button is indicated by its heavy border.

      In Windows, push buttons are the equivalent to a button with the BS_PUSHBUTTON style. The style BS_DEFPUSHBUTTON is also very useful because the button automatically gets focus in a dialog box.
      In Windows, push buttons can be created in a resource entity as follows:
      <code language="X#">
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 120
        STYLE WS_POPUP | WS_DLGFRAME
        BEGIN
        PUSHBUTTON "Cancel" IDB_CANCEL, 64, 50, 32, 14
        DEFPUSHBUTTON "OK" IDB_OK, 64, 80, 32, 14,; 	WS_GROUP
        END
      </code>
    </remarks>
  </PushButton>
  <PushButton.ctor>
    <summary>
      Construct a push button.
    </summary>
    <param name="oOwner">The window that owns the push button.</param>
    <param name="xID">The unique ID of the push button (between 1 and 8000).</param>
    <param name="oPoint">The origin of the push button in canvas coordinates.</param>
    <param name="oDimension">The dimension of the push button in canvas coordinates.</param>
    <param name="cText">The text that appears in the push button. The default is NULL_STRING.</param>
    <param name="kStyle">
      The style of the push button, specified by a Windows API style constant.
    </param>
    <param name="nResourceID">The resource ID of the push button.</param>
    <remarks>
      <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular Windows API style constant.</note>
    </remarks>
  </PushButton.ctor>
  <PushButton.Destroy>
    <summary>
      Provide a method to de-instantiate a PushButton object.
    </summary>
    <remarks>
      This method can be used when a PushButton object is no longer needed. PushButton:Destroy() de-instantiates the PushButton object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </PushButton.Destroy>
  <PushButton.TextValue>
    <summary>
      PushButton:TextValue is set to the PushButton:Caption text.
    </summary>
    <value>PushButton:TextValue is set to the PushButton:Caption text.</value>
  </PushButton.TextValue>
  <PushButton.Value>
    <summary>
      PushButton:Value always returns FALSE, since it has a single state.
    </summary>
    <value>PushButton:Value always returns FALSE, since it has a single state.</value>
  </PushButton.Value>
  <RadioButton>
    <summary>
      Create a radio button.
    </summary>
    <remarks>
      Radio buttons are typically presented in related groups and provide mutually exclusive responses to a condition where only one choice is appropriate. (For example, a group of radio buttons might allow you to choose Inches, Centimeters, or Picas.)
      Only one radio button can be on in each radio button group. When a different button is pressed, the previously selected button is turned off. In the Window Editor, the Group style setting is checked for each radio button group, to designate the first control in each group. If you do not explicitly create two or more groups, then there will be only one group for the entire window and only one radio button may be selected at a time.
      A radio button is said to be "pressed" when it is filled in, and the RadioButton:Pressed access is TRUE. Like check boxes, radio buttons maintain their state between events. When you create a radio button group using the Window Editor, code is generated so that it functions automatically. The caption is used to indicate which button in the group is pressed, and the selected button's group value is stored in the RadioButton:Value.
      Radio buttons may not be bound to a field in a server, like other controls. Instead, a radio button group may be bound to a field.

      In Windows, radio buttons are equivalent to a button with the BS_RADIOBUTTON style. The style BS_AUTORADIOBUTTON is also very useful because the button is automatically turned on and off without any code being written in the system's Window:ButtonClick() event handler.
      In Windows, radio buttons can be created in a resource entity as follows:
      <code language="X#">
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 120
        STYLE WS_POPUP | WS_DLGFRAME
        BEGIN
        RADIOBUTTON "&amp;Black" IDB_BLACK, 10, 20, 40, 12
        RADIOBUTTON "&amp;Gray" IDB_GRAY, 10, 35, 40, 12
        RADIOBUTTON "&amp;White" IDB_WHITE, 10, 50, 40, 12
        CONTROL "&amp;Auto",IDB_AUTO, "button"; 	BS_AUTORADIOBUTTON, 10,65,40,12
        END
      </code>
    </remarks>
  </RadioButton>
  <RadioButton.ctor>
    <summary>
      Construct a radio button.
    </summary>
    <param name="oOwner">The window that owns the radio button.</param>
    <param name="xID">The unique ID of the radio button (between 1 and 8000).</param>
    <param name="oPoint">The origin of the radio button in canvas coordinates.</param>
    <param name="oDimension">The dimension of the radio button in canvas coordinates.</param>
    <param name="cText">The caption text of the radio button. If omitted, the default is NULL_STRING.</param>
    <param name="kStyle">
      The style of the radio button, specified by a Windows API style constant.
    </param>
    <remarks>
      <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular Windows API style constant.</note>
    </remarks>
    <param name="nResourceID">The resource ID of the radio button.</param>
  </RadioButton.ctor>
  <RadioButton.Destroy>
    <summary>
      Provide a method to de-instantiate a RadioButton object.
    </summary>
    <remarks>
      This method can be used when a RadioButton object is no longer needed. RadioButton:Destroy() de-instantiates the RadioButton object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </RadioButton.Destroy>
  <RadioButton.Pressed>
    <summary>
      A logical value representing the current state of the radio button (TRUE if it is on, FALSE if it is off).
    </summary>
    <value>A logical value representing the current state of the radio button (TRUE if it is on, FALSE if it is off).</value>
    <remarks>
      A logical value representing the current state of the radio button (TRUE if it is on, FALSE if it is off). RadioButton:Pressed is only modified by clicking on the button.
    </remarks>
  </RadioButton.Pressed>
  <RadioButton.TextValue>
    <summary>
      RadioButton:TextValue is set to the RadioButton:Caption text.
    </summary>
    <value>RadioButton:TextValue is set to the RadioButton:Caption text.</value>
    <remarks>
      RadioButton:TextValue is set to the RadioButton:Caption text. The RadioButton:TextValue assign also changes the RadioButton:Caption.
    </remarks>
  </RadioButton.TextValue>
  <RadioButton.Value>
    <summary>
      RadioButton:Value contains TRUE if the radio button is in the pressed (ON) state or FALSE if it is not pressed (OFF).
    </summary>
    <value>RadioButton:Value contains TRUE if the radio button is in the pressed (ON) state or FALSE if it is not pressed (OFF).</value>
  </RadioButton.Value>
  <RadioButtonGroup>
    <summary>
      A group of radio buttons considered as a combination control, presenting a set of options and returning a single value.
    </summary>
    <remarks>
      Radio buttons are commonly used to allow selection of one among a specific list of options. However, treating several radio buttons as individual controls requires explicit management of the behavior of the buttons: when one is selected, the program must turn off the other buttons in the group. Individual radio buttons are also not suited for linking to a database: databases typically do not have several fields representing linked properties, but rather a single field that can take on different values.
      The radio button group is a higher level control that automatically handles the interlinking of the buttons. It also links to database fields in a more intelligent way than individual radio buttons: the group as a whole is considered as one control that takes one of a number of specific values.
      Since the radio button group is the control that you deal with, and its constituent radio buttons are not directly referenced by the program, properties such as the hyperlabel, field specification, caption, value, and text value are attached to the group. The value is either the number of the radio button which is currently selected in the sequence or one of the values specified for a radio button in a two-dimensional array through FillUsing(). The text value is the same value formatted according to the picture clause of the field specification attached to the group (to get the caption displayed next to the radio buttons, retrieve the selected button and reference its caption property. Note that the data type and picture of the group's field specification are used and the field specs of the individual radio buttons are ignored.
      The radio button group behaves similarly to a list box or combo box and may be used as an alternative to any constrained single-selection list box when the number of options is small and fixed. (Although the radio button group supports variable caption strings for the individual buttons, a list box is usually a better choice for very dynamic data.)
      A radio button group is created empty and radio buttons are associated with it through the FillUsing() method. If you create a radio button using the Window Editor, the FillUsing( ) method in the generated source code defines a two-dimensional array, with one row for each button. The first element contains the caption of the radio button and the second element contains its group value.  When a button is pressed, the radio button group's TextValue contains the first element (the button caption), and Value contains the second element (the group value). If no button is pressed, RadioButtonGroup:TextValue is NULL_STRING and RadioButtonGroup:Value is NIL.
      A radio button group may be bound to a field in a server. The field's data value is stored in RadioButtonGroup:Value. The radio button group compares the field's data value to the second element values specified in the FillUsing() array, and if a match is found, the first element (the button caption) is stored in RadioButtonGroup:TextValue. If there is no match, RadioButtonGroup:TextValue is NULL_STRING. If a button is pressed, the corresponding second element is stored as RadioButtonGroup:Value, and this value is written to the server.
    </remarks>
  </RadioButtonGroup>
  <RadioButtonGroup.ctor>
    <summary>
      Construct a radio button group.
    </summary>
    <param name="oOwner">The window that owns the radio button group.</param>
    <param name="xID">The unique ID of the radio button group (between 1 and 8000) or the resource ID of the radio button group.</param>
    <param name="uPoint">The origin of the group box in canvas coordinates.</param>
    <param name="uDimension">The dimension of the group box in canvas coordinates.</param>
    <param name="cText">The caption text displayed when the group box containing the radio button group is shown. By default, this value is the caption in the dialog template, defined when the dialog is initialized.</param>
    <remarks>
      Note that after instantiation, the radio button group is "empty:" it doesn't contain any radio buttons. Visually, it may be drawn to surround the radio buttons, but logically it doesn't contain them. To relate the group to its radio buttons, use the FillUsing() method.
    </remarks>
  </RadioButtonGroup.ctor>
  <RadioButtonGroup.Button>
    <summary>
      Retrieve a specific radio button.
    </summary>
    <param name="nButtonPosition">The position of the radio button in the array that was used to set up the group (in FillUsing()).</param>
    <returns>
      The RadioButton object at the specified position in the array. Note that the radio button position in the array may not correspond to the order the radio buttons are displayed in the group box. NIL is returned if there is no radio button at the indicated position.
    </returns>
  </RadioButtonGroup.Button>
  <RadioButtonGroup.Buttons>
    <exclude />
  </RadioButtonGroup.Buttons>
  <RadioButtonGroup.Caption>
    <summary>
      A string representing the text that is displayed adjacent to the radio button in a radio button group that is currently pressed.
    </summary>
    <value>A string representing the text that is displayed adjacent to the radio button in a radio button group that is currently pressed.</value>
    <remarks>
      A string representing the text that is displayed adjacent to the radio button in a radio button group that is currently pressed. The RadioButtonGroup:Caption assign also changes RadioButtonGroup:CurrentText for the radio button.
    </remarks>
  </RadioButtonGroup.Caption>
  <RadioButtonGroup.Disable>
    <summary>
      Disable a radio button group (until a subsequent call to RadioButtonGroup:Enable()).
    </summary>
    <remarks>
      Disabled radio button groups are not active (that is, radio button cannot be clicked) and, therefore, they do not send events to their owner windows. Note that under Windows, a disabled radio button group is dimmed.
    </remarks>
  </RadioButtonGroup.Disable>
  <RadioButtonGroup.Enable>
    <summary>
      Enable a radio button group that was previously disabled.
    </summary>
    <remarks>
      Enabling a radio button group allows it to generate events and to send the events to its owner window when the user manipulates the radio button group. The dimming of disabled radio button groups is removed, and it is restored to its normal appearance.
      By default, radio button groups are enabled until disabled, so there is no need to call this Enable() method unless Disable() was previously called.
    </remarks>
  </RadioButtonGroup.Enable>
  <RadioButtonGroup.FillUsing>
    <summary>
      Specify the radio buttons that make up the group and the set of values corresponding to these buttons, using an array.
    </summary>
    <param name="aContents">
      The array containing existing radio buttons or the values that should be used to create radio buttons. A two-dimensional array may be used to define the values to be returned to the program when a radio button is selected; this 'other' value is what is returned in the RadioButtonGroup:Value property, and what is stored in the database if the control is associated with a database field. If a one-dimensional array is specified, the values are returned as 1, 2, 3...
      Thus, the array may be specified in one of two formats:
      1.	One-dimensional array containing radio button objects that are to be linked to the group
      2.	Two-dimensional arrays, each element containing a RadioButton object and the corresponding value returned to the program
      Note: the two dimensional array has the same structure as that returned by DBServer:GetLookupTable().
    </param>
    <remarks>
      For fixed structures, the individual radio buttons may be created as regular controls, either dynamically or through a resource entity, and assigned to the group through the FillUsing() method.
      <note type="tip">The radio button group may be associated with a database field, just like any other control.</note>
    </remarks>
    <example>
      Create a radio button group with different currencies, showing an explicit representation to the user but using a different representation internally.
      This example, shown below, with the radio buttons explicitly created through a resource entity. The code simply links the radio buttons to the group:
      <code language="X#">
        RESOURCE OrderWindow DIALOG 7,11,239,196
        STYLE WS_CHILD
        FONT 8,"MS Sans Serif"
        BEGIN
        CONTROL "Currency",;
        ORDERWINDOW_CURRENCY,"Button";
        BS_GROUPBOX|WS_GROUP|WS_CHILD,;
        27,33,85,122
        CONTROL "U.S. Dollars",;
        ORDERWINDOW_THERADIOBUTTON1,"Button";
        BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
        38,45,57,11
        CONTROL "Can. Dollars",;
        ORDERWINDOW_THERADIOBUTTON2,"Button";
        BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
        38,63,69,11
        CONTROL "Mexican Pesos",;
        ORDERWINDOW_THERADIOBUTTON3,"Button";
        BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
        38,82,69,11
        CONTROL "Yen",;
        ORDERWINDOW_THERADIOBUTTON4,"Button";
        BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
        38,100,68,11
        CONTROL "British Pounds",;
        ORDERWINDOW_THERADIOBUTTON5,"Button";
        BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
        38,118,68,11
        CONTROL "German Marks",;
        ORDERWINDOW_THERADIOBUTTON6,"Button";
        BS_AUTORADIOBUTTON|WS_TABSTOP|WS_CHILD,;
        38,137,69,11
        METHOD Init(oWindow,iCtlID,oServer) CLASS OrderWindow
        SUPER:Init(oWindow,ResourceID{"OrderWindow"},iCtlID)
        oCCTheRadioButton1 := RadioButton{SELF,;
        ResourceID{ORDERWINDOW_THERADIOBUTTON1}}
        RadioButton1:HyperLabel := {#TheRadioButton1,;
        "U.S. Dollars",,}
        oCCTheRadioButton2 := RadioButton{SELF,;
        ResourceID{ORDERWINDOW_THERADIOBUTTON2}}
        RadioButton2:HyperLabel := {#TheRadioButton2,;
        "Can. Dollars",,}
        oCCTheRadioButton3 := RadioButton{SELF,;
        ResourceID{ORDERWINDOW_THERADIOBUTTON3}}
        RadioButton3:HyperLabel := {#TheRadioButton3,;
        "Mexican Pesos",,}
        oCCTheRadioButton4 := RadioButton{SELF,;
        ResourceID{ORDERWINDOW_THERADIOBUTTON4}}
        RadioButton4:HyperLabel := {#TheRadioButton4,;
        "Yen",,}
        oCCTheRadioButton5 := RadioButton{SELF,;
        ResourceID{ORDERWINDOW_THERADIOBUTTON5}}
        RadioButton5:HyperLabel := {#TheRadioButton5,;
        "British Pounds",,}
        oCCTheRadioButton6 := RadioButton{SELF,;
        ResourceID{ORDERWINDOW_THERADIOBUTTON6}}
        RadioButton6:HyperLabel := {#TheRadioButton6,;
        "German Marks",,}
        oDCCCurrency := RadioButtonGroup{SELF,;
        ResourceID{ORDERWINDOW_CURRENCY}}
        oDCCCurrency:FieldSpec := ;
        FieldSpec{#Currency,STRING,3,0}
        oDCCurrency:FillUsing({;
        {oCCTheRadioButton1,"USD"},;
        {oCCTheRadioButton2,"CDN"},;
        {oCCTheRadioButton3,"MEX"},;
        {oCCTheRadioButton4,"YEN"},;
        {oCCTheRadioButton5,"UK"},;
        {oCCTheRadioButton6,"DM"};
        })
        oDCCurrency:HyperLabel := {#Currency,"Currency",,}
      </code>
    </example>
  </RadioButtonGroup.FillUsing>
  <RadioButtonGroup.Hide>
    <summary>
      Hide a radio button group so it is not visible (until a subsequent call to RadioButtonGroup:Show()).
    </summary>
  </RadioButtonGroup.Hide>
  <RadioButtonGroup.SetFocus>
    <summary>
      Pass input focus to the selected radio button within the radio button group.
    </summary>
  </RadioButtonGroup.SetFocus>
  <RadioButtonGroup.Show>
    <summary>
      Display a radio button group so it is visible.
    </summary>
    <remarks>
      RadioButtonGroup:Show() is usually called to redisplay a radio button group that was hidden with the RadioButtonGroup:Hide() method.
    </remarks>
  </RadioButtonGroup.Show>
  <RadioButtonGroup.TextValue>
    <summary>
      RadioButtonGroup:TextValue holds the first element of the FillUsing() array
    </summary>
    <value>RadioButtonGroup:TextValue holds the first element of the FillUsing() array</value>
    <remarks>
      RadioButtonGroup:TextValue holds the first element of the FillUsing() array (typically, the caption text of the radio button) for the currently selected button; if none is selected, RadioButtonGroup:TextValue is set to NULL_STRING.
    </remarks>
  </RadioButtonGroup.TextValue>
  <RadioButtonGroup.Value>
    <summary>
      Contains the group value setting (specified on the Window Editor Property Window) associated with the radio button within the group that is selected.
    </summary>
    <value>Contains the group value setting (specified on the Window Editor Property Window) associated with the radio button within the group that is selected.</value>
    <remarks>
      Contains the group value setting (specified on the Window Editor Property Window) associated with the radio button within the group that is selected.
      The data type of the control's Value is determined by its field specification; in turn, controls linked to a data server inherit the field specification—and hence data type—from the field of the server. When the control is made data-aware, by setting its name to the name of a field in the server attached to the data window, Value is able to automatically read from and write to this field.
      <note type="tip">RadioButtonGroup:Value may not always be consistent with what the state of the control, as indicated to the end-user. For example, if the data value for the field is not among the group value settings for the radio buttons in a radio button group, the control will be in a "no-match" situation. In this case the control will revert to its initial unselected state.</note>
    </remarks>
  </RadioButtonGroup.Value>
  <RadioButtonGroup.Values>
    <exclude />
  </RadioButtonGroup.Values>
  <Range>
    <summary>
      Create a range, representing the minimum and maximum values of the coordinates (or scroll units) that the thumb position on a scroll bar can move—up or down, left or right.
    </summary>
  </Range>
  <Range.ctor>
    <summary>
      Construct a range.
    </summary>
    <param name="nMin">The minimum value in the range. The default is 0.</param>
    <param name="nMax">The maximum value in the range. The default is 0.</param>
  </Range.ctor>
  <Range.IsInRange>
    <exclude />

  </Range.IsInRange>
  <Range.Max>
    <summary>
      A numeric value representing the maximum value in this range.
    </summary>
    <value>A numeric value representing the maximum value in this range.</value>
  </Range.Max>
  <Range.Min>
    <summary>
      A numeric value representing the minimum value in this range.
    </summary>
    <value>A numeric value representing the minimum value in this range.</value>
  </Range.Min>
  <RectangleObject>
    <summary>
      Create a RectangleObject object; this class is part of the DrawObject hierarchy, which provides a means of displaying and manipulating various geometric objects.
    </summary>
    <example>
      To draw a RectangleObject object, call Window:Draw() with the RectangleObject object as its argument. The window does the drawing by asking each object to draw itself—for example:
      <code language="X#">
        METHOD Expose(oEvent) CLASS MyWindow
        LOCAL oRectangle AS OBJECT
        oRectangle := RectangleObject{Point{10,10},;
        Dimension{20,40}}
        SELF:Draw(oRectangle)
      </code>
    </example>
  </RectangleObject>
  <RectangleObject.ctor>
    <summary>
      Construct a rectangle.
    </summary>
    <param name="oPoint">The origin of the rectangle, in canvas coordinates.</param>
    <param name="oDimension">The dimension of the rectangle, in canvas coordinates.</param>
    <param name="oPen">
      The pen to be used to draw the rectangle. By default, <paramref name="oPen" /> is set to NIL, which causes the current pen to be used.
    </param>
    <param name="oBrush">The brush to be used to fill the rectangle. If omitted, the default is NIL, which causes the current brush to be used.</param>
  </RectangleObject.ctor>
  <RectangleObject.Draw>
    <summary>
      Draw the rectangle on the window.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This method should not be invoked directly in the application code—it is invoked in X# by Window:Draw(). Refer to the class description for an example using the Draw() method.
    </remarks>
  </RectangleObject.Draw>
  <ReportQueue>
    <summary>
      Manage Report Editor reporting activities, as well as the appearance of the Report Editor window.
    </summary>
    <remarks>
      The ReportQueue class allows an application to create, edit, print, preview, and save reports using report definition files (*.RET) created and formatted using the Report Editor.
    </remarks>
  </ReportQueue>
  <ReportQueue.ctor>
    <summary>
      Construct a report queue.
    </summary>
    <param name="oOwner">The window that owns the ReportQueue object.</param>
    <param name="cServerName">
      The Report Editor server to be used. If not specified, the default value is 'Report Editor', which is the Report Editor runtime engine.
    </param>
    <remarks>
      <note type="tip">Report Editor is the only server that is supported.</note>
      ReportQueue:Init() creates a ReportQueue object owned by a window. This object can then be used for sequential reporting tasks.
    </remarks>
    <example>
      This example creates a shell window containing a ReportQueue object:
      <code language="X#">
        CLASS MyShellWindow INHERIT ShellWindow
        HIDDEN oRQ AS OBJECT
        METHOD Start() CLASS App
        LOCAL oSW := MyShellWind{}
        oSW:Show()
        SELF:Exec()
        METHOD Init() CLASS MyShellWind
        SUPER:Init()
        // Initializes the server
        oRQ := ReportQueue{SELF,"Report Editor"}
      </code>
    </example>
  </ReportQueue.ctor>
  <ReportQueue.ActiveFile>
    <summary>
      The report definition file the Report Editor server was just using. This information can be used within an AppWindow:ReportNotification() method.
    </summary>
    <value>The report definition file the Report Editor server was just using. This information can be used within an AppWindow:ReportNotification() method.</value>
  </ReportQueue.ActiveFile>
  <ReportQueue.Close>
    <summary>
      Close a report.
    </summary>
    <remarks>
      When a program has finished with a report, it should close the report to reduce the Report Editor's memory usage. This does not close the Report Editor; only the open report within it.
      The ReportQueue keeps a stack of the reports it opened by calls to the ReportQueue:Open() method (but it does not have visibility to the extra files the user opens via the Report Editor's menu). Once all reports are closed (via the ReportQueue:Close() method or the Report Editor menu), the ReportQueue knows of no reports that are open and rejects any further calls to print, preview, or export "the current report," until the next ReportQueue:Open() call.
      ReportQueue:Close() displays its status in the owner window's status bar.
      Even if the ReportQueue believes that the Report Editor has no report open, the Close() method still sends the FILE.CLOSE command to the Report Editor. This command is quietly ignored by the Report Editor, so it is always safe to call ReportQueue:Close().
      The ReportQueue:Close() method totally closes a report. The ReportQueue:Close() method closes a preview (if open), and/or closes the report definition, depending on which window type is open.
      The Report Editor advises the ReportQueue whenever a report or view is closed (whether the close was initiated by ReportQueue or the user).
    </remarks>
    <example>
      The following example closes a report definition:
      <code language="X#">
        LOCAL oReportQueue := ReportQueue{SELF,;
        "Report Editor"}
        oReportQueue:Open("one.ret")
        oReportQueue:Close()
      </code>
    </example>
  </ReportQueue.Close>
  <ReportQueue.CloseAll>
    <summary>
      Close all reports.
    </summary>
    <remarks>
      CloseAll() displays its status in the owner window's status bar. It leaves both the Report Editor server and your program running. CloseAll() can be called safely at any time, and is probably useful both in exception handlers and in clean-up routines.
    </remarks>
  </ReportQueue.CloseAll>
  <ReportQueue.ConnectToDB>
    <summary>
      Connect to an ODBC data source.
    </summary>
    <param name="cDataSourceName">The name of the ODBC data source to connect to. If no data source is specified, a dialog box will appear so that one can be selected.</param>
    <param name="cUserName">The ODBC user name for this data source.</param>
    <param name="cPassword">The ODBC password or authorization string for this data source.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      The Report Editor requires an active database connection. Before opening a report, you must create a data source for the report database.
    </remarks>
    <example>
      The following example connects to a "CA Xbase" data source:
      <code language="X#">oRQ:ConnectToDB("CA Xbase")</code>
    </example>
  </ReportQueue.ConnectToDB>
  <ReportQueue.DataUpdate>
    <summary>
      Handle DataUpdateEvent, if one occurs. Provide this event handler in your derived ReportQueue class if you require special handling of events.
      <br />Important! You should neither attempt to call nor provide alternative implementations to this method. Instead, you can provide extra handling of events in your derived version of AppWindow:ReportNotification().
    </summary>
    <param name="oIpcDataUpdateEvent">Stores the topic name, item name, and the changed data as a string.</param>
    <remarks>
      This method executes outstanding ReportQueue methods (either commands, like Print() and SaveToFile() or Report Editor appearance methods). Once a report is opened, subsequent command methods can take an array of report parameters to be inserted into the Report Editor report text and/or database query. The Report Editor's appearance can be changed synchronously, but the Report Editor performs commands asynchronously and all subsequent commands and appearance changes are queued within the ReportQueue until the Report Editor advises that it has finished the previous command.
      The ReportQueue methods post messages on their owner window's status bar whenever they send a command to the Report Editor and replace it with a confirmation on completing each command.
    </remarks>
  </ReportQueue.DataUpdate>
  <ReportQueue.Edit>
    <summary>
      Load a report into the Report Editor for editing.
    </summary>
    <remarks>
      This method allows the user to edit the report definition (.RET) file and provides the same environment as the IDE.
    </remarks>
    <example>
      The following example opens the "sales.ret" report file and allows the user to edit the file:
      <code language="X#">
        oRQ:Open("sales.ret")
        oRQ:Edit()
      </code>
    </example>
  </ReportQueue.Edit>
  <ReportQueue.EventType>
    <summary>
      One of the following constants representing an event:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>

        <item>
          <term>
            REPORTCLOSEEVENT
          </term>
          <description>Current report has been closed.</description>
        </item>
        <item>
          <term>
            REPORTCOMPLETEERROREVENT
          </term>
          <description> print or export task has aborted.</description>
        </item>
        <item>
          <term>
            REPORTCOMPLETEEVENT
          </term>
          <description>A print or export task has completed.</description>
        </item>
        <item>
          <term>
            REPORTFILESAVEEVENT
          </term>
          <description>A report definition has been closed.</description>
        </item>
        <item>
          <term>
            REPORTOPENEVENT
          </term>
          <description>Requested report has been opened.</description>
        </item>
        <item>
          <term>
            REPORTSERVERCLOSEEVENT
          </term>
          <description>Report Editor has been closed.</description>
        </item>
        <item>
          <term>
            REPORTVIEWCLOSEEVENT
          </term>
          <description>A report preview has been closed (but the report itself remains open).</description>
        </item>
      </list>
      It should be used only in any AppWindow:ReportNotification() method you add to your window class that owns this ReportQueue object.
    </summary>
    <value>
      A constant representing an event
    </value>
  </ReportQueue.EventType>
  <ReportQueue.Filename>
    <summary>
      The name of the .RET file that defines the report. This access is unlikely to be used within the function that opened the report—as the file name string should already be local to the function. It would be useful if one method opens a report and another method needs to use that open file.
      Note that this accesses the name of the report that is open when the next command method gets around to executing on the Report Editor, as opposed to the ReportQueue:ActiveFile which might be an earlier report now being processed by the Report Editor.
    </summary>
    <value>
      The name of the .RET file that defines the report. This access is unlikely to be used within the function that opened the report—as the file name string should already be local to the function. It would be useful if one method opens a report and another method needs to use that open file.
      Note that this accesses the name of the report that is open when the next command method gets around to executing on the Report Editor, as opposed to the ReportQueue:ActiveFile which might be an earlier report now being processed by the Report Editor.
    </value>
  </ReportQueue.Filename>
  <ReportQueue.Hide>
    <summary>
      Hide the Report Editor window and icon so that they are not visible.
    </summary>
  </ReportQueue.Hide>
  <ReportQueue.NEW>
    <summary>
      Create a new report definition in the Report Editor for editing.
    </summary>
    <param name="cSQLSelectStatement">The SQL Select statement string that defines the report.</param>
    <param name="kReportStyle">
      One of the following constants representing the report style for the new report:
    </param>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>RPTSTYLE_CROSSTAB		</term>
          <description>Creates a cross-tabular report.</description>
        </item>
        <item>
          <term>
            RPTSTYLE_FORM
          </term>
          <description>Creates a form-based report</description>
        </item>
        <item>
          <term>
            RPTSTYLE_FREESTYLE
          </term>
          <description>Creates a free-style report</description>
        </item>
        <item>
          <term>
            RPTSTYLE_LABEL
          </term>
          <description>Creates a label report</description>
        </item>
        <item>
          <term>
            RPTSTYLE_LETTER
          </term>
          <description>Creates a letter report</description>
        </item>
        <item>
          <term>RPTSTYLE_TABULAR		</term>
          <description>Creates a tabular report</description>
        </item>
        If no report style is specified, a dialog box containing all the above report styles will appear.
      </list>
      This method allows the user to edit the report definition (.RET) file and provides the same environment as the IDE.
    </remarks>
    <example>
      The following example creates a new report definition file and allows the user to edit the file:
      <code language="X#">oRQ:New("SELECT CUSTOMERS * FROM C:\CAVO2x\SAMPLES\CUSTOMER")</code>
    </example>
  </ReportQueue.NEW>
  <ReportQueue.Open>
    <summary>
      Open a report.
    </summary>
    <param name="cReportName">An existing Report Editor report definition file. If no extension is given, .RET is appended to the file name specified.</param>
    <remarks>
      Open() must be called before calling ReportQueue command methods like Print() or Preview().
      Before opening a second report, we recommend you close the first, in order to save memory, although it is not required.
      Open() displays its status in the owner window's status bar.
      <note type="tip">The Report Editor requires an active database connection. Before opening a report, you must create a data source for the report database and connect to it using ReportQueue:ConnectToDB().</note>
    </remarks>
    <example>
      This example opens a report definition:
      <code language="X#">
        LOCAL od AS OBJECT
        LOCAL ReportFile AS STRING
        od := OpenDialog{SELF,"*.ret"}
        od:Show()
        ReportFile := od:FileName
        od:Destroy()
        oRQ:ConnectToDB(...)
        oRQ:Open(ReportFile)
      </code>
    </example>
  </ReportQueue.Open>
  <ReportQueue.Origin>
    <summary>
      A point defining where the top left corner of the Report Editor window is shown, in canvas coordinates. The Report Editor is shown from this point downward. This is in contrast to the coordinate system used by X# applications, which consider their window's origin at the bottom-left corner and show windows in an upward direction.
    </summary>
    <value>A point defining where the top left corner of the Report Editor window is shown, in canvas coordinates. The Report Editor is shown from this point downward. This is in contrast to the coordinate system used by X# applications, which consider their window's origin at the bottom-left corner and show windows in an upward direction.</value>
  </ReportQueue.Origin>
  <ReportQueue.owner>
    <summary>
      The window that owns the ReportQueue object. This access allows code using a ReportQueue to call methods of the owner (ultimately derived from AppWindow).
    </summary>
    <value>The window that owns the ReportQueue object. This access allows code using a ReportQueue to call methods of the owner (ultimately derived from AppWindow).</value>
  </ReportQueue.owner>
  <ReportQueue.Preview>
    <summary>
      Cause a report to be previewed on screen.
    </summary>
    <param name="aParams">An array of report parameters, as understood by the Report Editor report file. These report parameters can be inserted by the Report Editor into the report text, and/or can be used as selection criteria in the report query. Use commas to default any unused parameters or to re-use previously provided parameters.</param>
    <param name="cPreviewTitle">String representing the title for the Preview window. If omitted, no title will appear in the window title bar.</param>
    <param name="lMDIChild">Logical value indicating whether the preview window will be an MDI child (TRUE) or not (FALSE). If omitted, the default value is FALSE.</param>
    <remarks>
      The status of the method is sent to the owner window's status bar, displaying "&lt;ServerName&gt; has completed report."
      The parameters are transmitted to the Report Editor before the Preview() method, and would be used by subsequent Print() methods. You can prefer to leave the decision whether to print the report with the person previewing, rather than have the program request a print.
    </remarks>
    <example>
      The following example previews a file on the screen before printing it:
      <code language="X#">
        oRQ:ConnectToDB(...)
        oRQ:Open("sales.ret")
        oRQ:Preview({"Spain","1993"})
        oRQ:Print()
      </code>
    </example>
  </ReportQueue.Preview>
  <ReportQueue.Print>
    <summary>
      Print a report to the Report Editor's selected printer.
    </summary>
    <param name="aParams">An array of report parameters, as understood by the Report Editor report file. These report parameters can be inserted by the Report Editor into the report text, and/or can be used as selection criteria in the report query. Use commas to default any unused parameters or to re-use previously provided parameters.</param>
    <param name="oRange">The range of page numbers to print. Omit this parameter to print all pages of the report. A Range:Min parameter of zero means 'from start,' while a Range:Max parameter of zero means 'to end.'</param>
    <remarks>
      The report parameters are transmitted to the Report Editor before the print command, and is used by subsequent Print() methods.
    </remarks>
    <example>
      This example prints three different reports from the same report definition:
      <code language="X#">
        // Print all
        oRQ:ConnectToDB(...)
        oRQ:Open{"sales.ret"}
        // Default to 1992 again
        oRQ:Print({"Spain","1992"})
        oRQ:Print({"Ireland"})
        // Second &amp; third pages
        oRQ:Print({,"1993"},Range{2,3})
        oRQ:Close()
      </code>
    </example>
  </ReportQueue.Print>
  <ReportQueue.ReportExit>
    <summary>
      Exit the Report Editor.
    </summary>
  </ReportQueue.ReportExit>
  <ReportQueue.ReportServer>
    <summary>
      The Report Editor server currently in use by this ReportQueue. The value is set in the ReportQueue:Init() method.
    </summary>
    <value>The Report Editor server currently in use by this ReportQueue. The value is set in the ReportQueue:Init() method.</value>
    <remarks>
      <note type="tip">The only supported server is "Report Editor."</note>
    </remarks>
  </ReportQueue.ReportServer>
  <ReportQueue.SaveToFile>
    <summary>
      Save a report to the given file name.
    </summary>
    <param name="cTarget">The file to which a report is saved.</param>
    <param name="cFormat">Another string defining the save format to be either RTF or TEXT. Rich Text Format maintains all the spacing, table alignments, fonts, and such characteristics. The default is RTF.</param>
    <param name="aParams">An array of string parameters, which are report parameters as understood by the Report Editor report file. See the discussion under the ReportQueue:Preview() method.</param>
    <example>
      This example stores two files in RTF format to disk:
      <code language="X#">
        oRQ:Print({"Spain","1992"})
        oRQ:SaveToFile("spain92.rtf","RTF")
        oRQ:SaveToFile("spain93.rtf",,{,"1993"})
      </code>
    </example>
  </ReportQueue.SaveToFile>
  <ReportQueue.SetPapersize>
    <summary>
      Set the paper size for the report.
    </summary>
    <param name="iSize">
      Integer representing one of the predefined paper sizes (see below).
      If omitted, the default is 1 (Letter 8 1/2 x 11 in).
    </param>
    <remarks>
      Paper Size	&lt;&gt;
      A3 297 x 420 mm	 8
      A4 210 x 297 mm	 9
      A4 Small 210 x 297 mm	10
      A5 148 x 210 mm	11
      B4 250 x 354	12
      B5 182 x 257 mm	13
      C size sheet	24
      D size sheet	25
      E size sheet	26
      Envelope B4 250 x 353 mm	33
      Envelope B5 176 x 250 mm	34
      Envelope B6 176 x 125 mm	35
      Envelope C5 162 x 229 mm	28
      Envelope C3 324 x 458 mm	29
      Envelope C4 229 x 324 mm	30
      Envelope C6 114 x 162 mm	31
      Envelope C65 114 x 229 mm	32
      Envelope DL 110 x 220 mm	27
      Envelope 110 x 230 mm	36
      Envelope Monarch 3.875 x 7.5 in	37
      6 3/4 Envelope 3 5/8 x 6 1/2 in	38
      Envelope #9 3 7/8 x 8 7/8	19
      Envelope #10 4 1/8 x 9 1/2	20
      Envelope #11 4 1/2 x 10 3/8	21
      Envelope #12 4 \276 x 11	22
      Envelope #14 5 x 11 1/2	23
      Executive 7 1/4 x 10 1/2 in	 7
      Folio 8 1/2 x 13 in	14
      German Std Fanfold 8 1/2 x 12 in	40
      German Legal Fanfold 8 1/2 x 13 in	41
      Ledger 17 x 11 in	 4
      Legal 8 1/2 x 14 in	 5
      Letter 8 1/2 x 11 in	 1
      Letter Small 8 1/2 x 11 in	 2
      Note 8 1/2 x 11 in	18
      Quarto 215 x 275 mm	15
      Statement 5 1/2 x 8 1/2 in	 6
      Tabloid 11 x 17 in	 3
      US Std Fanfold 14 7/8 x 11 in	39
      10x14 in	16
      11x17 in	17
      The paper size should be set before calling Print() or Preview().
      <note type="tip">Not all paper sizes are supported on all printers. Consult your printer documentation for supported paper sizes.</note>
    </remarks>
    <example>
      <code language="X#">oRQ:SetPrinterPaperSize(5)  // Sets paper size to Legal 8 1/2 x 14in</code>
    </example>
  </ReportQueue.SetPapersize>
  <ReportQueue.SetPrinterOrientation>
    <summary>
      Set the printer orientation for the report.
    </summary>
    <param name="bOrientation">Binary value value indicating whether the printer orientation will be portrait (0) or landscape (1). If omitted, default is 0 (portrait).</param>
    <remarks>
      The paper orientation should be set before calling Print() or Preview().
    </remarks>
    <example>
      <code language="X#">oRQ:SetPrinterOrientation(1)	// Set orientation to landscape</code>
    </example>
  </ReportQueue.SetPrinterOrientation>
  <ReportQueue.SetReportQuery>
    <summary>
      Set the query to be used for the report.
    </summary>
    <param name="sQueryName">Name of the query to use for the report.</param>
    <remarks>
      For reports that contain multiple queries, this method can be used to select which query is used when running a report. To view what queries are available, go into the Report Editor and select the Query, Set Report Query menu item. If that menu item is disabled, then only the default query (QUERY1) is defined. Otherwise a Set Report Query dialog box will appear and the available queries will be listed.
      The report query should be set before calling Print() or Preview().
    </remarks>
    <example>
      <code language="X#">oRQ:SetReportQuery("QUERY2")	//Set the report query to QUERY2</code>
    </example>
  </ReportQueue.SetReportQuery>
  <ReportQueue.SetSQLFile>
    <summary>
      Load an SQL query file as the active SQL query for the report.
    </summary>
    <param name="sQueryFile">Name of the query file to load.</param>
    <remarks>
      Loads an SQL query file from disk to be used as the active query for this report. The SQL query file should be loaded before calling Print() or Preview().
      <note type="tip">Query-By-Example (.QBE) query files are not supported by the X# Report Writer.</note>
    </remarks>
    <example>
      <code language="X#">oRQ:SetSQLFile("QUERY6.SQL")</code>
    </example>
  </ReportQueue.SetSQLFile>
  <ReportQueue.SetSQLText>
    <summary>
      Set a text string as the active SQL query for the report.
    </summary>
    <param name="sQuery">The query string to use as the active SQL query.</param>
    <remarks>
      The query text should be set before calling Print() or Preview().
    </remarks>
    <example>
      <code language="X#">
        oRQ:SetSQLText("SELECT Customer.* FROM " + ;
        "C:\CAVO2x\Samples\Explorer\Customer WHERE " + ;
        "Customer.CustNum = 8")
      </code>
    </example>
  </ReportQueue.SetSQLText>
  <ReportQueue.Show>
    <summary>
      Minimize or maximize the Report Editor window.
    </summary>
    <param name="kShowState">
      The state in which the Report Editor window area should be displayed. Specify one of the following constants:
    </param>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>SHOWICONIZED</term>
          <description>Iconizes or minimizes the Report Editor window.</description>
        </item>
        <item>
          <term>SHOWNORMAL</term>
          <description>Normalizes the Report Editor window. This is the default.</description>
        </item>
        <item>
          <term>SHOWZOOMED</term>
          <description>Maximizes the Report Editor window to a full screen.</description>
        </item>
      </list>
    </remarks>
  </ReportQueue.Show>
  <ReportQueue.Size>
    <summary>
      A dimension representing the current size of the Report Editor window, in canvas coordinates.
    </summary>
    <value>A dimension representing the current size of the Report Editor window, in canvas coordinates.</value>
  </ReportQueue.Size>
  <ResizeEvent>
    <summary>
      Provide information about the ResizeEvent, used to indicate that a window has been resized.
    </summary>
    <remarks>
      When the size of a window changes, the system generates ResizeEvents and sends them to the Window:Resize() event handler.
    </remarks>
  </ResizeEvent>
  <ResizeEvent.ctor>
    <inheritdoc />
  </ResizeEvent.ctor>
  <ResizeEvent.Height>
    <summary>
      A numeric value representing the new height of the canvas area of the window that generated this resize event, in canvas coordinates.
    </summary>
    <value>A numeric value representing the new height of the canvas area of the window that generated this resize event, in canvas coordinates.</value>
  </ResizeEvent.Height>
  <ResizeEvent.Size>
    <summary>
      A dimension representing the new size of the canvas area of the window that generated this resize event, in canvas coordinates.
    </summary>
    <value>A dimension representing the new size of the canvas area of the window that generated this resize event, in canvas coordinates.</value>
  </ResizeEvent.Size>
  <ResizeEvent.Width>
    <summary>
      A numeric value representing the new width, in canvas coordinates, of the canvas area of the window that generated this resize event.
    </summary>
    <value>A numeric value representing the new width, in canvas coordinates, of the canvas area of the window that generated this resize event.</value>
  </ResizeEvent.Width>
  <ResourceFile>
    <summary>
      Identify a file containing resource information.
    </summary>
    <remarks>
      This class is used to create objects that can be used to identify resource entities.
    </remarks>
    <example>
      The following example uses various methods of the ResourceFile, ResourceID, and the ResourceString classes to display resource strings embedded in an .EXE file:
      <code language="X#">
        CLASS MyMenu INHERIT Menu
        CLASS MyResFile INHERIT ResourceFile
        CLASS MyTopAppWin INHERIT TopAppWindow
        DEFINE IDM_MYMENU := "MyMenu"
        DEFINE IDM_MYMENU_GETSTR1_ID := 1001
        DEFINE IDM_MYMENU_GETSTR2_ID := 1002
        DEFINE IDM_MYMENU_QUIT_ID := 1003
        DEFINE IDT_STR1 := 2001
        DEFINE IDT_STR2 := 2002
        RESOURCE IDM_MYMENU MENU
        BEGIN
        POPUP "&amp;Menu1"
        BEGIN
        MENUITEM "Get String &amp;1", 	;
        IDM_MYMENU_GETSTR1_ID
        MENUITEM "Get String &amp;2", ;
        IDM_MYMENU_GETSTR2_ID
        MENUITEM SEPARATOR
        MENUITEM "&amp;QUIT", IDM_MYMENU_QUIT_ID
        END
        END
        RESOURCE STRINGTABLE
        BEGIN
        IDT_STR1 "The 1st String"
        IDT_STR2 "The second string is 35 chars long."
        END
        METHOD Start() CLASS App
        LOCAL oWin AS Window
        oWin := MyTopAppWin{SELF}
        oWin:Show()
        SELF:Exec()
        METHOD Init(oOwnerApp) CLASS MyTopAppWin
        LOCAL lRetVal AS LONG
        SUPER:Init(oOwnerApp)
        SELF:Menu := MyMenu{SELF}
        SELF:Caption := "Resource File Demo Application"
        METHOD Init(oOwner) CLASS MyMenu
        SUPER:Init(ResourceID{IDM_MYMENU})
        SELF:RegisterItem(IDM_MYMENU_GETSTR1_ID,;
        HyperLabel{#GetStr1,,,})
        SELF:RegisterItem(IDM_MYMENU_GETSTR2_ID,;
        HyperLabel{#GetStr2,,,})
        SELF:RegisterItem(IDM_MYMENU_QUIT_ID,;
        HyperLabel{#GoQuit,,,})
        METHOD Init(fName) CLASS MyResFile
        IF fName == NIL
        SUPER:Init()
        ELSE
        SUPER:Init(fName)
        ENDIF
        METHOD GetStr1() CLASS MyTopAppWin
        SELF:GetStrX(IDT_STR1, 0)
        METHOD GetStr2() CLASS MyTopAppWin
        SELF:GetStrX(IDT_STR2, 100)
        METHOD GetStrX(nStrX,dy) CLASS MyTopAppWin
        LOCAL oResFile, oResID, oResString AS OBJECT
        oResFile := MyResFile{"c:\cavo\mytstprg.exe"}
        oResID := ResourceID{nStrX ,oResFile}
        oResString := ResourceString{oResID}
        SELF:TextPrint(AsString(nStrX),Point{10, 10+dy})
        SELF:TextPrint(AsString(oResString:Length),;
        Point{10, 30 + dy})
        SELF:TextPrint(AsString(oResString:Value),;
        Point{10, 50 + dy})
        SELF:TextPrint(AsString(oResString:AsString()),;
        Point{10, 70 + dy})
        METHOD GoQuit() CLASS MyTopAppWin
        SELF:Owner:Quit()
      </code>
    </example>
  </ResourceFile>
  <ResourceFile.ctor>
    <summary>
      Construct a resource file object.
    </summary>
    <param name="sName">The name of the resource file, either an .EXE or .DLL file. If omitted, the default is the executable (.EXE) program file name.</param>
  </ResourceFile.ctor>
  <ResourceFile.Destroy>
    <summary>
      Provide a method to de-instantiate a ResourceFile object.
    </summary>
    <remarks>
      This method can be used when a ResourceFile object is no longer needed. ResourceFile:Destroy() de-instantiates the ResourceFile object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </ResourceFile.Destroy>
  <ResourceFile.Handle>
    <exclude />
  </ResourceFile.Handle>
  <ResourceID>
    <summary>
      Identify and create a ResourceID using a numeric resource ID.
    </summary>
    <remarks>
      This class is used to identify application resources stored as numeric values in a resource entity. A resource may be a cursor, icon, bitmap, string, or a font.
    </remarks>
    <example>
      For an example using the ResourceID class, refer to the ResourceFile class example.
    </example>
  </ResourceID>
  <ResourceID.ctor>
    <summary>
      Construct a ResourceID object.
    </summary>
    <param name="xID">
      The unique ID between 1 and 8000 of the resource ID or a string describing the resource.
      Strings can only identify resource blocks, such as dialogs or menus. For individual controls, you must use numeric IDs.
    </param>
    <param name="xResourceFile">The resource file that includes the resource. The default is the current executable file.</param>
  </ResourceID.ctor>
  <ResourceID.Address>
    <exclude />
  </ResourceID.Address>
  <ResourceID.Handle>
    <exclude />
  </ResourceID.Handle>
  <ResourceID.ID>
    <exclude />
  </ResourceID.ID>
  <ResourceString>
    <summary>
      Extract strings from a resource entity.
    </summary>
    <remarks>
      You can use this facility to provide language-independent applications (for example, substitute French text for German text and recompile the resource entity).
    </remarks>
    <example>
      For an example using the ResourceString class, refer to the ResourceFile class example.
    </example>
  </ResourceString>
  <ResourceString.ctor>
    <summary>
      Load a resource string from the resource entity.
    </summary>
    <param name="xResourceID">The resource ID of the desired string.</param>
    <param name="nMaxLen">The maximum length that you expect the string to be in any language. For example, if the string is translated into French, it can be longer than in English. The default is 255. If you set it too low, Windows truncates the resource string.</param>
  </ResourceString.ctor>
  <ResourceString.AsString>
    <summary>
      Return the text stored in a resource string.
    </summary>
  </ResourceString.AsString>
  <ResourceString.Destroy>
    <summary>
      Provide a method to de-instantiate a ResourceString object.
    </summary>
    <remarks>
      This method can be used when a ResourceString object is no longer needed. ResourceString:Destroy() de-instantiates the ResourceString object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </ResourceString.Destroy>
  <ResourceString.Length>
    <summary>
      A numeric value representing the length—the number of characters—of a ResourceString object.
    </summary>
    <value>A numeric value representing the length—the number of characters—of a ResourceString object.</value>
  </ResourceString.Length>
  <ResourceString.Value>
    <summary>
      The value held in the ResourceString object.
    </summary>
    <value>The value held in the ResourceString object.</value>
  </ResourceString.Value>
  <RichEdit>
    <summary>
      Create a rich edit control.
    </summary>
    <remarks>
      A rich edit is a control in which the user can enter and edit text. The text can be assigned character and paragraph formatting, as well as background and foreground color. The rich edit provides a programming interface for printing and searching for text and word breaks.
    </remarks>
  </RichEdit>
  <RichEdit.ctor>
    <summary>
      Construct a rich edit.
    </summary>
    <param name="oOwner">The window that owns the rich edit.</param>
    <param name="xID">The unique ID of the rich edit (between 1 and 8000).</param>
    <param name="nResourceID">The resource ID of the rich edit.</param>
    <param name="oPoint">The origin of the rich edit in canvas coordinates.</param>
    <param name="oDimension">The dimension of the rich edit in canvas coordinates.</param>
    <param name="kStyle">The style of the rich edit.</param>
  </RichEdit.ctor>
  <RichEdit.Alignment>
    <summary>
      A constant representing the paragraph alignment of the rich edit:
    </summary>
    <value>A constant representing the paragraph alignment of the rich edit:</value>
    <remarks>
      One of the following constants representing the paragraph alignment of the rich edit:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>REPARA_CENTER</term>
          <description>Text is centered</description>
        </item>
        <item>
          <term>REPARA_LEFT</term>
          <description>Text is left-aligned</description>
        </item>
        <item>
          <term>REPARA_RIGHT</term>
          <description>Text is right-aligned</description>
        </item>
      </list>
    </remarks>
  </RichEdit.Alignment>
  <RichEdit.BackgroundColor>
    <summary>
      A Color object representing the background color of the rich edit
    </summary>
    <value>A Color object representing the background color of the rich edit</value>
  </RichEdit.BackgroundColor>
  <RichEdit.CanPaste>
    <summary>
      Determine whether the rich edit can paste the specified clipboard format.
    </summary>
    <param name="dwClipboardFormat">
      The specified Clipboard format. If not specified, it defaults to 0, meaning that the rich edit object will try any format currently on the Clipboard.
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">Refer to the SetClipboardData() function in your Microsoft Win32 Software Development Kit documentation for definitions of valid format constants.</note>
    </remarks>
  </RichEdit.CanPaste>
  <RichEdit.ControlFont>
    <exclude />
  </RichEdit.ControlFont>
  <RichEdit.EnableAdvancedTypography>
    <summary>
      Sets the ability for advanced line breaking and line formatting.
    </summary>
    <param name="lEnable">TRUE turns this on, False turns this off.</param>
  </RichEdit.EnableAdvancedTypography>
  <RichEdit.Font>
    <summary>
      A Font object representing the font selection for the text or a portion of the text in the rich edit.
    </summary>
    <value>A Font object representing the font selection for the text or a portion of the text in the rich edit.</value>
  </RichEdit.Font>
  <RichEdit.GetOption>
    <summary>
      Determine the status of a particular option for the rich edit.
    </summary>
    <param name="kOption">One of the following constants representing the option whose status you want to check:</param>
    <returns>
      TRUE if the option is enabled; otherwise, FALSE.
    </returns>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>REOPT_AUTOWORD</term>
          <description>Automatic selection of a word on double-click</description>
        </item>
        <item>
          <term>REOPT_AUTOVSCROLL</term>
          <description>Automatic vertical scrolling</description>
        </item>
        <item>
          <term>REOPT_AUTOHSCROLL</term>
          <description>Automatic horizontal scrolling</description>
        </item>
        <item>
          <term>REOPT_NOHIDESEL</term>
          <description>Selection is not hidden when focus is lost</description>
        </item>
        <item>
          <term>REOPT_READONLY</term>
          <description>Editing of text is not permitted</description>
        </item>
        <item>
          <term>REOPT_WANTRETURN</term>
          <description>Captures carriage return keystrokes</description>
        </item>
        <item>
          <term>REOPT_SAVESEL</term>
          <description>Selection is saved focus is lost</description>
        </item>
        <item>
          <term>REOPT_SELBAR</term>
          <description>Has a selection bar</description>
        </item>
      </list>
    </remarks>
  </RichEdit.GetOption>
  <RichEdit.GetTabStops>
    <summary>
      Set the TabStops for a rich edit control.
    </summary>
    <returns>
      An array of tab values.
    </returns>
    <remarks>
      The tab array that is returned contains the tab-values. Each tab-value is a subarray with two values.
      The first one is the tab-position in cm.
      The second is the tab-alignment defined by one of these constants -
      RICHTAB_CENTER
      RICHTAB_DECIMAL
      RICHTAB_NORMAL
      RICHTAB_RIGHT
    </remarks>
  </RichEdit.GetTabStops>
  <RichEdit.GetTextRange>
    <summary>
      Retrieve a range of characters from the rich edit.
    </summary>
    <param name="oRange">The range of characters to retrieve.</param>
    <returns>
      A string representing the retrieved range of characters.
    </returns>
  </RichEdit.GetTextRange>
  <RichEdit.GetWordBreak>
    <summary>
      Locate a particular type of word break in the rich edit.
    </summary>
    <param name="nCharPos">The character position from which to find the work break.</param>
    <param name="kWordBreakType">One of the following constants representing the type of word break to retrieve:</param>
    <returns>
      If <paramref name="kWordBreakType" /> is REGWB_ISDELIMITER this function returns a logical value that is TRUE if the specified character is a delimiter and FALSE otherwise. If <paramref name="kWordBreakType" /> is any other value, the function returns a numeric value representing the character position of the word break.
    </returns>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>REGWB_ISDELIMITER</term>
          <description>Determines whether the specified character is a delimiter. This option causes a logical return value.</description>
        </item>
        <item>
          <term>REGWB_LEFT</term>
          <description>Finds the nearest character before the specified position that begins a word.</description>
        </item>
        <item>
          <term>REGWB_LEFTBREAK</term>
          <description>Finds the next word end before the specified position.</description>
        </item>
        <item>
          <term>REGWB_MOVEWORDLEFT</term>
          <description>Finds the next character that begins a word before the specified position.</description>
        </item>
        <item>
          <term>REGWB_RIGHT</term>
          <description>Finds the nearest character after the specified position that begins a word.</description>
        </item>
        <item>
          <term>REGWB_RIGHTBREAK</term>
          <description>Finds the next word end after the specified position.</description>
        </item>
        <item>
          <term>REGWB_MOVEWORDRIGHT</term>
          <description>Finds the next character that begins a word after the specified position.</description>
        </item>
      </list>
    </remarks>
  </RichEdit.GetWordBreak>
  <RichEdit.HideSelection>
    <summary>
      Hide the selection in the rich edit.
    </summary>
    <param name="lTemporary">A logical value that is TRUE if the selection will be hidden temporarily and FALSE otherwise. If omitted, the default is TRUE.</param>
  </RichEdit.HideSelection>
  <RichEdit.LineFromCharacter>
    <summary>
      Determine the line number of the rich edit from the specified character position.
    </summary>
    <param name="nCharacterPos">A numeric value specifying the character position whose line number you want to obtain.</param>
    <returns>
      The line number of the specified character position.
    </returns>
  </RichEdit.LineFromCharacter>
  <RichEdit.LoadFromFile>
    <summary>
      Load data from an RTF file into the rich edit control.
    </summary>
    <param name="cFileName">The name of the file you wish to load.</param>
    <param name="dwFormat">** missing parameter documentation **</param>
    <returns>
      TRUE, if successful; otherwise FALSE.
    </returns>
    <remarks>
      If successful, the current contents of the rich edit control will be replaced with the contents of the RTF file.
    </remarks>
  </RichEdit.LoadFromFile>
  <RichEdit.Margin>
    <summary>
      Set the margins for the currently selected text in the rich edit control.
    </summary>
    <param name="nStart">Integer representing the indentation of the first line in the paragraph.</param>
    <param name="nRight">Integer representing the right margin of the paragraph.</param>
    <param name="nOffset">
      Integer representing the indentation of the second line and subsequent lines, relative to <paramref name="nStart" />. If this value is positive, a hanging indent is created (first line is 'outdented' and the subsequent lines are indented). If this value is negative, the first line is indented and the subsequent lines are outdented.
    </param>
    <returns>
      TRUE, if successful; otherwise FALSE.
    </returns>
    <remarks>
      This method is equivalent to setting the RichEdit:PrimaryIndent, RichEdit:RightMargin, and RichEdit:SecondaryIndent properties.
    </remarks>
  </RichEdit.Margin>
  <RichEdit.Numbering>
    <summary>
      A constant representing the type of paragraph numbering currently associated with the rich edit:
    </summary>
    <value>A constant representing the type of paragraph numbering currently associated with the rich edit:</value>
    <remarks>
      One of the following constants representing the type of paragraph numbering currently associated with the rich edit:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>REPARA_NUMBER</term>
          <description>Paragraphs are numbered</description>
        </item>
        <item>
          <term>REPARA_BULLET</term>
          <description>Paragraphs are bulleted</description>
        </item>
      </list>
    </remarks>
  </RichEdit.Numbering>
  <RichEdit.PasteSpecial>
    <summary>
      Paste a particular clipboard format in the rich edit.
    </summary>
    <param name="dwClipboardFormat">The specified clipboard format. Refer to the SetClipboardData() function in your Microsoft Win32 Software Development Kit documentation for definitions of valid format constants.</param>
  </RichEdit.PasteSpecial>
  <RichEdit.PrimaryIndent>
    <summary>
      A numeric value representing the indent of the first line of a paragraph in the rich edit.
    </summary>
    <value>A numeric value representing the indent of the first line of a paragraph in the rich edit.</value>
  </RichEdit.PrimaryIndent>
  <RichEdit.Print>
    <summary>
      Print the contents of the rich edit.
    </summary>
    <param name="oPrintingDevice">The PrintingDevice object or printing device name that will receive the output. If omitted, a print dialog box is raised for the user to choose a print destination.</param>
    <param name="oRange">The range of characters to print. If omitted, the entire range of characters is printed.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </RichEdit.Print>
  <RichEdit.Protected>
    <summary>
      A logical value that is TRUE if the text in the rich edit is protected from modification.
    </summary>
    <value>A logical value that is TRUE if the text in the rich edit is protected from modification.</value>
  </RichEdit.Protected>
  <RichEdit.RightMargin>
    <summary>
      A numeric value representing the right margin of the rich edit.
    </summary>
    <value>A numeric value representing the right margin of the rich edit.</value>
  </RichEdit.RightMargin>
  <RichEdit.SaveToFile>
    <summary>
      Save the current contents of the control to an RTF file.
    </summary>
    <param name="cFileName">The name of the file to which you wish to save.</param>
    <param name="dwFormat">** missing parameter documentation **</param>
    <returns>
      TRUE, if successful; otherwise FALSE.
    </returns>
  </RichEdit.SaveToFile>
  <RichEdit.SecondaryIndent>
    <summary>
      A numeric value representing the indent of the second and subsequent lines of a paragraph in the rich edit.
    </summary>
    <value>A numeric value representing the indent of the second and subsequent lines of a paragraph in the rich edit.</value>
  </RichEdit.SecondaryIndent>
  <RichEdit.Seek>
    <summary>
      Search the rich edit for the specified text.
    </summary>
    <param name="cText">The text for which to search.</param>
    <param name="oRange">The range of characters in which to search.</param>
    <param name="lMatchCase">A logical value that is TRUE if the search is case-sensitive. If omitted, the default is FALSE.</param>
    <param name="lWholeWord">A logical value that is TRUE if the search must match on a whole word. If omitted, the default is FALSE.</param>
    <param name="lReturnRange">A logical value that is FALSE if the return value will be the numeric character position of the found text or TRUE if it will be a Range object representing the range of characters in which the text was found. If omitted, the default is FALSE.</param>
    <param name="lSearchUp">
      If lSearchUp is TRUE, the search is from the end of the current selection to the beginning of the document. If lSearchUp is FALSE, the search is from the end of the current selection to the end of the document. If omitted the default is FALSE.
      For Rich Edit 1.0 the lSearchUp parameter is ignored. The search is always from the end of the current selection to the end of the document.
    </param>
    <returns>
      If <paramref name="lReturnRange" /> is TRUE, the range of characters in which the text was found. If <paramref name="lReturnRange" /> is FALSE, the character position where the text was found.
    </returns>
  </RichEdit.Seek>
  <RichEdit.SelectedText>
    <summary>
      A string representing the currently selected text in the rich edit.
    </summary>
    <value>A string representing the currently selected text in the rich edit.</value>
  </RichEdit.SelectedText>
  <RichEdit.Selection>
    <summary>
      A Selection object representing the currently selected text in the rich edit.
    </summary>
    <value>A Selection object representing the currently selected text in the rich edit.</value>
  </RichEdit.Selection>
  <RichEdit.SelectionType>
    <summary>
      A constant representing the type of the current selection in the rich edit:
    </summary>
    <value>A constant representing the type of the current selection in the rich edit:</value>
    <remarks>
      One of the following constants representing the type of the current selection in the rich edit:

      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>RESEL_EMPTY</term>
          <description>Current selection is empty</description>
        </item>
        <item>
          <term>RESEL_TEXT</term>
          <description>Current selection is text</description>
        </item>
      </list>
    </remarks>
  </RichEdit.SelectionType>
  <RichEdit.SetOption>
    <summary>
      Set an option for the rich edit.
    </summary>
    <param name="kOption">One of the following constants representing the option you want to set:</param>
    <param name="symOperation">
      One of the following symbolic names representing the operation to perform:
      <list type="table">
        <listheader>
          <term>Operation</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>#Add</term>
          <description>Add this option to the current options. This is the default.</description>
        </item>
        <item>
          <term>#Change</term>
          <description>Change to this option, removing all other options</description>
        </item>
        <item>
          <term>#Keep</term>
          <description>Keep only this option</description>
        </item>
        <item>
          <term>#Remove</term>
          <description>Remove only this option</description>
        </item>
      </list>
    </param>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>REOPT_AUTOWORD</term>
          <description>Automatic selection of a word on double-click</description>
        </item>
        <item>
          <term>REOPT_AUTOVSCROLL</term>
          <description>Automatic vertical scrolling</description>
        </item>
        <item>
          <term>REOPT_AUTOHSCROLL</term>
          <description>Automatic horizontal scrolling</description>
        </item>
        <item>
          <term>REOPT_NOHIDESEL</term>
          <description>Selection is not hidden when focus is lost</description>
        </item>
        <item>
          <term>REOPT_READONLY</term>
          <description>Editing of text is not permitted</description>
        </item>
        <item>
          <term>REOPT_WANTRETURN</term>
          <description>Captures carriage return keystrokes</description>
        </item>
        <item>
          <term>REOPT_SAVESEL</term>
          <description>Selection is saved focus is lost</description>
        </item>
        <item>
          <term>REOPT_SELBAR</term>
          <description>Has a selection bar</description>
        </item>
      </list>
    </remarks>
  </RichEdit.SetOption>
  <RichEdit.SetTabStops>
    <summary>
      Set the TabStops for a rich edit control.
    </summary>
    <param name="aTabStops">An array of values.</param>
    <remarks>
      The Tab array contains the tab-values. Each tab-value is a subarray with two values.
      The first one is the tab-position in cm.
      The second is the tab-alignment defined by one of these constants -
      RICHTAB_CENTER
      RICHTAB_DECIMAL
      RICHTAB_NORMAL
      RICHTAB_RIGHT
    </remarks>
  </RichEdit.SetTabStops>
  <RichEdit.ShowSelection>
    <summary>
      Show the selection in the rich edit.
    </summary>
    <param name="lTemporary">A logical value that is TRUE if the selection will be shown temporarily and FALSE otherwise. If omitted, the default is TRUE.</param>
  </RichEdit.ShowSelection>
  <RichEdit.TabStopCount>
    <summary>
      A numeric value representing the number of tab stops in the rich edit.
    </summary>
    <value>A numeric value representing the number of tab stops in the rich edit.</value>
  </RichEdit.TabStopCount>
  <RichEdit.TextColor>
    <summary>
      A Color object representing the text color of the rich edit.
    </summary>
    <value>A Color object representing the text color of the rich edit.</value>
  </RichEdit.TextColor>
  <RichEdit.TextLimit>
    <summary>
      A numeric value representing the maximum amount of text in the rich edit. The default is 32KB.
    </summary>
    <value>A numeric value representing the maximum amount of text in the rich edit. The default is 32KB.</value>
  </RichEdit.TextLimit>
  <RichEdit.Value>
    <summary>
      A string representing the text contents of the rich edit
    </summary>
    <value>A string representing the text contents of the rich edit</value>
  </RichEdit.Value>
  <RichEdit.ValueAsText>
    <exclude />
  </RichEdit.ValueAsText>
  <RichEditCallback.ctor>
    <exclude />
  </RichEditCallback.ctor>
  <RichEditCallback.BeginInvoke>
    <exclude />
  </RichEditCallback.BeginInvoke>
  <RichEditCallback.EndInvoke>
    <exclude />
  </RichEditCallback.EndInvoke>
  <RichEditCallback.Invoke>
    <exclude />
  </RichEditCallback.Invoke>
  <RichEditProtectEvent>
    <summary>
      Provide information about a rich edit protection event, which is generated when the user attempts to edit protected text in a rich edit control.
    </summary>
    <remarks>
      The rich edit generates this message when an attempt is made to edit protected text in the rich edit. Text is protected by calling RichEdit:Protect().

    </remarks>
  </RichEditProtectEvent>
  <RichEditProtectEvent.ctor>
    <exclude />
  </RichEditProtectEvent.ctor>
  <RichEditProtectEvent.Selection>
    <summary>
      A selection object representing the selection range in the rich edit.
    </summary>
    <value>A selection object representing the selection range in the rich edit.</value>
  </RichEditProtectEvent.Selection>
  <RichEditProtectEvent.SelectionRange>
    <summary>
      A Range object representing the selection range in the rich edit.
    </summary>
    <value>A Range object representing the selection range in the rich edit.</value>
  </RichEditProtectEvent.SelectionRange>
  <RichEditSelectionEvent>
    <summary>
      Provide information about a rich edit selection event, which is generated when the selection in a rich edit control is changed.
    </summary>
    <remarks>
      The rich edit generates this message when the selection is changed in a rich edit. Properties of the event include the type of the new selection and the new selection range.

    </remarks>
  </RichEditSelectionEvent>
  <RichEditSelectionEvent.ctor>
    <exclude />
  </RichEditSelectionEvent.ctor>
  <RichEditSelectionEvent.Selection>
    <summary>
      A selection object representing the selection range in the rich edit.
    </summary>
    <value>A selection object representing the selection range in the rich edit.</value>
  </RichEditSelectionEvent.Selection>
  <RichEditSelectionEvent.SelectionRange>
    <summary>
      A Range object representing the new selection range in the rich edit.
    </summary>
    <value>A Range object representing the new selection range in the rich edit.</value>
  </RichEditSelectionEvent.SelectionRange>
  <RichEditSelectionEvent.SelectionType>
    <summary>
      A constant representing the type of the newly changed selection in the rich edit:
    </summary>
    <value>A constant representing the type of the newly changed selection in the rich edit:</value>
    <remarks>
      One of the following constants representing the type of the newly changed selection in the rich edit:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>RESEL_EMPTY</term>
          <description>Current selection is empty</description>
        </item>
        <item>
          <term>RESEL_TEXT</term>
          <description>Current selection is text</description>
        </item>
      </list>
    </remarks>
  </RichEditSelectionEvent.SelectionType>
  <SaveAsDialog>
    <summary>
      Provide standard save-file dialog facilities.
    </summary>
  </SaveAsDialog>
  <SaveAsDialog.ctor>
    <summary>
      Construct a standard SaveAs dialog box.
    </summary>
    <param name="oOwnWnd">The window that owns the SaveAsDialog object.</param>
    <param name="cInitPath">The preset file name to display in the dialog. Use this, for example, to prompt the user with the current name of the file. You can also specify wild-cards, such as *.TXT. The default is a NULL_STRING.</param>
    <param name="dwFlag">Reserved for future use.</param>
  </SaveAsDialog.ctor>
  <ScrollBar>
    <summary>
      Provide the base class from which all X# scroll bars are subclassed.
    </summary>
    <remarks>
      Scroll bars have a marker, called a thumb, which can be dragged up and down (or left and right) within a range of values. The thumb can be dragged to different positions on the scroll bar, or it can step up or down in blocks or units.
      GUI scroll bars automatically maintain block and unit operations. When a block or unit operation takes place, a ScrollEvent is generated with both the actual thumb position and the position the thumb would assume if the scroll bar is updated. The block and unit amounts are added or subtracted from the current position according to the scroll type that occurs.
      By default, a scroll bar has a range of (0,99), a unit size of 1, a block size of 10, and an initial thumb position of 0.
    </remarks>
  </ScrollBar>
  <ScrollBar.>
    <summary>
      A numeric value representing the thumb position of the scroll bar.
    </summary>
    <value>A numeric value representing the thumb position of the scroll bar.</value>
    <remarks>
      A numeric value representing the thumb position of the scroll bar. For example, the value can be the number 42. The ScrollBar:Value assign also changes ScrollBar:TextValue and ScrollBar:ThumbPosition. If the value to be assigned is outside the allowable Min-Max range associated with the scroll bar, the value is modified so it is either the Min or Max value.
    </remarks>
  </ScrollBar.>
  <ScrollBar.ctor>
    <summary>
      Construct a scroll bar.
    </summary>
    <param name="oOwner">The window that owns the scroll bar.</param>
    <param name="xID">The unique ID between 1 and 8000 of the scroll bar.</param>
    <param name="oPoint">The origin of the scroll bar, in canvas coordinates.</param>
    <param name="oDimension">The dimension of the scroll bar, in canvas coordinates.</param>
    <param name="oResourceID">The resource ID of the scroll bar.</param>
    <param name="lDataAware">A logical value specifying whether the list box is data aware.</param>
  </ScrollBar.ctor>
  <ScrollBar.BlockSize>
    <summary>
      A numeric value representing the block size of the scroll bar
    </summary>
    <value>A numeric value representing the block size of the scroll bar</value>
    <remarks>
      A numeric value representing the block size of the scroll bar.
      The block size is used to calculate the new position of the thumb when a BLOCKINCREMENT or BLOCKDECREMENT ScrollEvent occurs,
      which is one of the event types recognized by the ScrollEvent:Type access.
      The BlockSize is initially set to 10, but may be modified at runtime to change the behavior of the scroll bar.
    </remarks>
  </ScrollBar.BlockSize>
  <ScrollBar.Create>
    <inheritdoc />
  </ScrollBar.Create>
  <ScrollBar.Destroy>
    <summary>
      Provide a method to de-instantiate a ScrollBar object.
    </summary>
    <remarks>
      This method can be used when a ScrollBar object is no longer needed. ScrollBar:Destroy() de-instantiates the ScrollBar object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </ScrollBar.Destroy>
  <ScrollBar.Hide>
    <inheritdoc />
  </ScrollBar.Hide>
  <ScrollBar.Modified>
    <summary>
      A logical value that is set to FALSE for a scroll bar since it does not contain text that can be edited.
    </summary>
    <value>A logical value that is set to FALSE for a scroll bar since it does not contain text that can be edited.</value>
  </ScrollBar.Modified>
  <ScrollBar.PageSize>
    <exclude />
  </ScrollBar.PageSize>
  <ScrollBar.Range>
    <summary>
      A range object representing the minimum and maximum values currently in use for the thumb of a scroll bar.
    </summary>
    <value>A range object representing the minimum and maximum values currently in use for the thumb of a scroll bar.</value>
  </ScrollBar.Range>
  <ScrollBar.SetInfo>
    <summary>
      Set all scrollbar properties with one method call.
    </summary>
    <param name="oScrollRange">Specifies the minimum and maximum scrolling position.</param>
    <param name="nThumbPosition">Specifies the position of the scroll box.</param>
    <param name="nPageSize">Specifies the page size. A scroll bar uses this value to determine the appropriate size of the proportional scroll box. </param>
    <param name="lDisableNoScroll">Disables the scroll bar instead of removing it, if the scroll bar's new parameters make the scroll bar unnecessary.</param>
  </ScrollBar.SetInfo>
  <ScrollBar.SetThumbPosition>
    <summary>
      Set the thumb position of the scrollbar
    </summary>
    <param name="nPosition">New position of the thumb.</param>
    <param name="lNotifyOwner">Should the owner be notified? When TRUE then the owner receives a WM_HSCROLL or WM_VSCROLL with a wParam SB_THUMBTRACK and lParam contains the scrollbar handle.</param>
  </ScrollBar.SetThumbPosition>
  <ScrollBar.Show>
    <inheritdoc />
  </ScrollBar.Show>
  <ScrollBar.TextValue>
    <summary>
      A string representing the thumb position of the scroll bar.
    </summary>
    <value>A string representing the thumb position of the scroll bar.</value>
    <remarks>
      A string representing the thumb position of the scroll bar. For example, the value can be "42".
      The ScrollBar:TextValue assign also changes ScrollBar:ThumbPosition and ScrollBar:Value.
      If the value to be assigned is outside the allowable Min-Max range associated with the scroll bar, the value is modified so it is either the Min or Max value.
    </remarks>
  </ScrollBar.TextValue>
  <ScrollBar.ThumbPosition>
    <summary>
      A numeric value (short integer) representing the current thumb position of the scroll bar.
    </summary>
    <value>A numeric value (short integer) representing the current thumb position of the scroll bar.</value>
    <remarks>
      A numeric value (short integer) representing the current thumb position of the scroll bar.
      For example, the value can be the number 42. The ThumbPosition assign also changes ScrollBar:TextValue and ScrollBar:Value.
      If the value to be assigned is outside the allowable range associated with the scroll bar, the value is modified so it is either the Min or Max value defined for the Range object. When the scroll bar is created, the ThumbPosition is initialized to 99, or if 99 exceeds the Max value, to the Max value.
    </remarks>
  </ScrollBar.ThumbPosition>
  <ScrollBar.UnitSize>
    <summary>
      A numeric value representing the unit size currently associated with the scroll bar.
    </summary>
    <value>A numeric value representing the unit size currently associated with the scroll bar.</value>
    <remarks>
      A numeric value representing the unit size currently associated with the scroll bar.
      The unit size is used to calculate the new thumb position when a UNITINCREMENT or UNITDECREMENT ScrollEvent occurs.
      When a scroll bar is created, ScrollBar:UnitSize is initialized to 1. The ScrollBar:UnitSize can be changed at runtime to alter the behavior of the scroll bar.
    </remarks>
  </ScrollBar.UnitSize>
  <ScrollBar.Value>
    <inheritdoc />
  </ScrollBar.Value>
  <ScrollEvent>
    <summary>
      Provide information about a ScrollEvent, generated when a scroll bar is manipulated.
    </summary>
    <remarks>
      ScrollEvent events go to either Window:VerticalScroll() or Window:HorizontalScroll(), depending on whether a vertical or horizontal scroll bar generated the event.
      A ScrollEvent reports the following: what scroll bar caused the event, what type of scroll movement is requested, and whether the scroll bar is a window or a free-standing scroll bar.
      It also reports the old scroll bar position and the desired position. The old position is where the thumb was located before being manipulated by the user; the desired position is where the user has newly positioned the thumb (if the thumb is manipulated directly or calculated from the block and unit sizes).
    </remarks>
    <example>
      Normally, when you receive a ScrollEvent, you would update the scroll bar's thumb position with code similar to the following:
      <code language="X#">aScrollEvt:ScrollBar:ThumbPosition := aScrollEvt:Position</code>
    </example>
  </ScrollEvent>
  <ScrollEvent.ctor>
    <inheritdoc />
  </ScrollEvent.ctor>
  <ScrollEvent.IsWindowScroll>
    <summary>
      A logical value indicating whether the scroll bar which generated this ScrollEvent was a window scroll bar or a free-standing scroll bar.
    </summary>
    <value>A logical value indicating whether the scroll bar which generated this ScrollEvent was a window scroll bar or a free-standing scroll bar.</value>
    <remarks>
      A logical value indicating whether the scroll bar which generated this ScrollEvent was a window scroll bar or a free-standing scroll bar.
      If a window scroll bar generated this ScrollEvent, TRUE is returned; if it was a free-standing scroll bar, FALSE is returned.
    </remarks>
  </ScrollEvent.IsWindowScroll>
  <ScrollEvent.OldPosition>
    <summary>
      A numeric value representing the old position of the thumb in a scroll bar when this ScrollEvent occurred (that is, where the thumb was located before being manipulated by the user).
    </summary>
    <value>A numeric value representing the old position of the thumb in a scroll bar when this ScrollEvent occurred (that is, where the thumb was located before being manipulated by the user).</value>
    <remarks>
      A numeric value representing the old position of the thumb in a scroll bar when this ScrollEvent occurred (that is, where the thumb was located before being manipulated by the user).
      By subtracting ScrollEvent:Position from ScrollEvent:OldPosition, the relative difference can be used for scrolling the thumb.
    </remarks>
  </ScrollEvent.OldPosition>
  <ScrollEvent.Position>
    <summary>
      A numeric value representing the desired position of the thumb in a scroll bar when this ScrollEvent occurred (that is, where the user has newly positioned the thumb).
    </summary>
    <value>A numeric value representing the desired position of the thumb in a scroll bar when this ScrollEvent occurred (that is, where the user has newly positioned the thumb).</value>
    <remarks>
      A numeric value representing the desired position of the thumb in a scroll bar when this ScrollEvent occurred (that is, where the user has newly positioned the thumb).
      By subtracting ScrollEvent:Position from ScrollEvent:OldPosition, the relative difference can be used for scrolling the thumb.
    </remarks>
  </ScrollEvent.Position>
  <ScrollEvent.ScrollBar>
    <summary>
      The scroll bar that generated this ScrollEvent.
    </summary>
    <value>The scroll bar that generated this ScrollEvent.</value>
  </ScrollEvent.ScrollBar>
  <ScrollEvent.ScrollBarID>
    <summary>
      The ID of the scroll bar that generated this ScrollEvent.
    </summary>
    <value>The ID of the scroll bar that generated this ScrollEvent.</value>
  </ScrollEvent.ScrollBarID>
  <ScrollEvent.TYPE>
    <summary>
      A string representing the type of scrolling action that took place when this ScrollEvent occurred.
    </summary>
    <value>A string representing the type of scrolling action that took place when this ScrollEvent occurred.</value>
    <remarks>
      A string representing the type of scrolling action that took place when this ScrollEvent occurred.
      One of the following values are returned:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>BLOCKDECREMENT</term>
          <description>
            The thumb position has been decremented by one block. In Windows, one mouse click on the shaded area to the left of the thumb position on a horizontal scroll bar,
            or above the thumb position on a vertical scroll bar, is a block decrement.
          </description>
        </item>
        <item>
          <term>BLOCKINCREMENT</term>
          <description>
            The thumb position has been incremented by one block. In Windows, one mouse click on the shaded area to the right of the thumb position on a horizontal scroll bar,
            or below the thumb position on a vertical scroll bar, is a block increment.
          </description>
        </item>
        <item>
          <term>SCROLLEND</term>
          <description>Scrolling has finished.</description>
        </item>
        <item>
          <term>SCROLLTHUMBDRAG</term>
          <description>The thumb is being dragged (up or down).</description>
        </item>
        <item>
          <term>UNITDECREMENT</term>
          <description>
            The thumb position has been decremented by one unit. In Windows, one mouse click on the left arrow of a horizontal scroll bar,
            or on the up arrow for a vertical scroll bar, is a unit decrement.
          </description>
        </item>
        <item>
          <term>UNITINCREMENT</term>
          <description>
            The thumb position has been incremented by one unit. In Windows, one mouse click on the right arrow of a horizontal scroll bar,
            or on the down arrow of a vertical scroll bar, is a unit increment.
          </description>
        </item>
      </list>
    </remarks>
  </ScrollEvent.TYPE>
  <SelectDialog>
    <summary>
      Present the user with a standard color palette dialog box.
    </summary>
    <remarks>
      This type of dialog box presents the user with a palette of available colors as a series of "boxes," allowing the user to select a color by clicking a box. The user is not allowed to create or select custom colors.
    </remarks>
  </SelectDialog>
  <SelectDialog.ctor>
    <summary>
      Construct a standard color selection dialog.
    </summary>
    <param name="uOwner">The window that owns the SelectDialog object.</param>
    <param name="oColor">The color initially selected for the SelectDialog object. The default is the color currently being used. (Refer to the Color:Init() method for details on specifying a color.)</param>
  </SelectDialog.ctor>
  <Selection>
    <summary>
      Create a selection, which represents the start and end of a text selection in an edit control as an ordered pair.
    </summary>
    <remarks>
      Selections are used in edit controls (i.e., by the Edit and EditWindow classes). The start of a selection is the position in the edit control of the first character that is included in the selection. The finish is the position of the first character not in the selection. For example, to specify the text from position 5 through 9 inclusive, you would give a value of Selection{5,10}.
      To select all the characters in an edit control (such as a single-line edit control), you would specify a value of Selection{0,-1}.
      If the start and finish points are the same, the selection refers to a cursor position. For example, the cursor position in front of the fifth character would be referred to as Selection{5,5}.
    </remarks>
  </Selection>
  <Selection.ctor>
    <summary>
      Construct a selection.
    </summary>
    <param name="nStart">The selection's start. If omitted, the default is {0,0}.</param>
    <param name="nFinish">The selection's end. If omitted, the default is {0,0}.</param>
  </Selection.ctor>
  <Selection.Finish>
    <summary>
      A numeric value representing the finish value in a selection.
    </summary>
    <value>A numeric value representing the finish value in a selection.</value>
  </Selection.Finish>
  <Selection.Start>
    <summary>
      A numeric value representing the start value in a selection.
    </summary>
    <value>A numeric value representing the start value in a selection.</value>
  </Selection.Start>
  <SelectionSlider>
    <summary>
      Create a selection slider.
    </summary>
    <remarks>
      A selection slider is a control that contains a thumb, optional tick marks, and a selection bar. The user can move the selection slider's thumb using either the mouse or the Direction keys.
    </remarks>
  </SelectionSlider>
  <SelectionSlider.ctor>
    <summary>
      Construct a selection slider.
    </summary>
    <param name="oOwner">The window that owns the selection slider.</param>
    <param name="xID">The unique ID between 1 and 8000 of the selection slider.</param>
    <param name="nResourceID">The resource ID of selection slider.</param>
    <param name="oPoint">The origin of the selection slider in canvas coordinates.</param>
    <param name="oDimension">The dimension of the selection slider in canvas coordinates.</param>
  </SelectionSlider.ctor>
  <SelectionSlider.ClearSelection>
    <summary>
      Clear the selection bar of the selection slider.
    </summary>
  </SelectionSlider.ClearSelection>
  <SelectionSlider.SelectionRange>
    <summary>
      A Range object representing the minimum and maximum values currently in use for the selection bar of the slider.
    </summary>
    <value>A Range object representing the minimum and maximum values currently in use for the selection bar of the slider.</value>
  </SelectionSlider.SelectionRange>
  <SelfPtr>
    <exclude />
  </SelfPtr>
  <SelfPtr.ptrSelf>
    <exclude />
  </SelfPtr.ptrSelf>
  <ShapeObject>
    <summary>
      Provide an intermediate class from which all X# two-dimensional objects are subclassed.
    </summary>
    <remarks>
      <br />Important! ShapeObject is an abstract class and should not be used directly—instead, use one of its subclasses, which include BitmapObject, EllipseObject, and RectangleObject.
    </remarks>
  </ShapeObject>
  <ShapeObject.ctor>
    <summary>
      Construct a ShapeObject object.
    </summary>
    <param name="oPoint">The origin of the ShapeObject object, in canvas coordinates.</param>
    <param name="oDimension">The dimension of the ShapeObject object, in canvas coordinates.</param>
    <param name="oPen">The pen to be used in Draw(). If omitted, the currently selected pen is used.</param>
    <param name="oBrush">The brush to be used in Draw(). If omitted, the currently selected brush is used.</param>
  </ShapeObject.ctor>
  <ShapeObject.BoundingBox>
    <summary>
      A bounding box representing the smallest rectangle that fully encloses the ShapeObject object.
    </summary>
    <value>A bounding box representing the smallest rectangle that fully encloses the ShapeObject object.</value>
  </ShapeObject.BoundingBox>
  <ShapeObject.Brush>
    <summary>
      A brush currently in use by the ShapeObject object to draw itself.
    </summary>
    <value>A brush currently in use by the ShapeObject object to draw itself.</value>
  </ShapeObject.Brush>
  <ShapeObject.Destroy>
    <exclude />
  </ShapeObject.Destroy>
  <ShapeObject.Pen>
    <summary>
      A pen currently in use by the ShapeObject object to draw itself.
    </summary>
    <value>A pen currently in use by the ShapeObject object to draw itself.</value>
  </ShapeObject.Pen>
  <ShapeObject.Size>
    <summary>
      A dimension representing the current size of the ShapeObject object, in canvas coordinates.
    </summary>
    <value>A dimension representing the current size of the ShapeObject object, in canvas coordinates.</value>
  </ShapeObject.Size>
  <ShellWindow>
    <summary>
      Create a shell window, which provides MDI support for your applications.
    </summary>
    <remarks>
      A shell window is similar to a top application window except that it acts as an MDI client window and all children of this window act as MDI child windows.

      The style of a child window is determined by the type of its owner. By default, a child application window whose owner is a shell window automatically functions as an MDI child window. If you do not desire this behavior, you can inhibit it using the ChildAppWindow:Init().

      When a child window is activated, its menu is automatically placed on the parent window. When there are no open child windows, the parent's menu is used. MenuCommand events are sent to any currently active child window. If there is no active child window, the default event handler sends events to the parent. For an in-depth discussion on event propagation, refer to the Programmer's Guide.

      With MDI applications, there is typically one pull-down menu which contains the captions of currently open MDI child windows. The name of the currently active MDI window is checked on the menu; also, when the user selects one of the names on this menu, the system activates the corresponding MDI window.
      Use the Menu:SetAutoUpdate() method to specify which pull-down menu to use.
    </remarks>
  </ShellWindow>
  <ShellWindow.ctor>
    <summary>
      Construct a shell window.
    </summary>
    <param name="oOwner">The window that owns the shell window.</param>
  </ShellWindow.ctor>
  <ShellWindow.ToolBar>
    <inheritdoc />
  </ShellWindow.ToolBar>

  <ShellWindow.Arrange>
    <summary>
      Tile, iconize, or cascade all the child windows that are currently open in this shell window.
    </summary>
    <param name="kArrangeStyle">Number that indicates how the windows should be arranged. Can be ARRANGEASICONS, ARRANGECASCADE, ARRANGETILEVERTICAL, ARRANGETILEHORIZONTAL</param>
  </ShellWindow.Arrange>
  <ShellWindow.Background>
    <summary>
      This property is inherited from the Window class but does not apply to ShellWindow.
    </summary>
    <value>This property is inherited from the Window class but does not apply to ShellWindow.</value>
  </ShellWindow.Background>
  <ShellWindow.CanvasErase>
    <summary>
      This method is inherited from the Window class but does not apply to ShellWindow.
    </summary>
  </ShellWindow.CanvasErase>
  <ShellWindow.ChildToolBarLocation>
    <summary>
      Specifies the position of a child window's toolbar.
    </summary>
    <value>Specifies the position of a child window's toolbar.</value>
    <remarks>
      Specifies the position of a child window's toolbar. Valid values are:
      TBL_CHILD
      The child's toolbar is displayed in the child window. This is the <b>default</b> setting.
      TBL_SHELL
      The child's toolbar is displayed in the shell window and replaces the shell window's toolbar.
    </remarks>
  </ShellWindow.ChildToolBarLocation>
  <ShellWindow.CloseAllChildren>
    <summary>
      Send a close message to all open MDI child windows.
    </summary>
  </ShellWindow.CloseAllChildren>
  <ShellWindow.Default>
    <inheritdoc />
  </ShellWindow.Default>
  <ShellWindow.Destroy>
    <summary>
      Provide a method to free memory resources allocated for a ShellWindow object and its derived objects.
    </summary>
    <remarks>
      This method immediately frees resources for ShellWindow objects created explicitly in your application.
      ShellWindow:Destroy() also takes care of resources allocated to derived classes and deallocates them in the necessary order.
    </remarks>
  </ShellWindow.Destroy>
  <ShellWindow.Dispatch>
    <inheritdoc />
  </ShellWindow.Dispatch>
  <ShellWindow.Draw>
    <summary>
      This method is inherited from the Window class but does not apply to ShellWindow.
    </summary>
  </ShellWindow.Draw>
  <ShellWindow.EnableOleStatusMessages>
    <summary>
      Control the status message display of an in-place active OLE object.
    </summary>
    <param name="lEnable">A logical value specifying whether to enable (TRUE) or disable (FALSE) the status message display.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      After calling ShellWindow:EnableOLEStatusMessage(TRUE), browsing through the menu items of an in-place active OLE object will call ShellWindow:OnOLEStatusMessage() with the status string as a parameter. By default, ShellWindow:OnOLEStatusMessage() displays the status string inside the shell window's status bar.
    </remarks>
  </ShellWindow.EnableOleStatusMessages>
  <ShellWindow.Foreground>
    <summary>
      This method is inherited from the Window class but does not apply to ShellWindow.
    </summary>
    <value>This method is inherited from the Window class but does not apply to ShellWindow.</value>
  </ShellWindow.Foreground>
  <ShellWindow.GetActiveChild>
    <summary>
      Return the window object for the currently active MDI child window.
    </summary>
  </ShellWindow.GetActiveChild>
  <ShellWindow.Handle>
    <summary>
      Return the handle for a shell window.
    </summary>
    <param name="nHandleType">The type of handle required. Specify 0 for the window handle and 2 for the window device context. If omitted, 0 is the default.</param>
    <returns>
      A handle to the window, describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the window, which can then be used by Windows API calls.
    </remarks>
  </ShellWindow.Handle>
  <ShellWindow.HelpRequest>
    <summary>
      Provide a method that is invoked when the user requests help from the application using one of the available context-sensitive help mechanisms.
    </summary>
    <param name="oHelpRequestEvent">The HelpRequestEvent object that describes which item help is being requested for.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This event handler is invoked only if the help mechanism has been enabled for the current window (or one of its owners).
      The help mechanism is enabled by assigning a HelpDisplay object to the windows HelpDisplay property.
      The default implementation of this event handler is to display the help topic that is associated with the control, menu command, or window region with focus when the HelpRequestEvent was generated. This is accomplished using HelpDisplay:Show(&lt;cKeyword&gt;), where &lt;cKeyword&gt; is either a HyperLabel:HelpContext property or a default keyword generated by this event handler in cases where a hyperlabel is not available.
      If there is no hyperlabel for an item, the keyword generated is as follows:
      A HELPCONTROL request generates the keyword Control_xxxx, where xxxx is the numeric ID of the control, in decimal. For example, an OK push button might generate the keyword Control_101.
      A HELPMENU request generates the keyword Menu_xxxx, where xxxx is the "cleaned" text of the menu command. The cleaned text has all leading and trailing spaces and the ampersand character (&amp;) removed. In addition, all sequences of spaces are replaced by a single underscore, and the string is truncated at the first tab character.
      For example, the keyword generated for the menu command:
      Save &amp;As\tF3
      is
      Menu_Save_As
      A HELPWINDOW request generates one of the keywords listed in the table below, depending on the window region that has focus.
      Keyword	Window Region
      Window_Border	Border
      Window_Caption	Title bar
      Window_MaxBox	Maximize button
      Window_MinBox	Minimize button
      Window_SysMenuBox	System menu button
      Window_Unknown	Any area of the window not explicitly identified in this table
      Window_WindowCanvas	Canvas area
      <note type="tip">If the Window_Unknown keyword is generated, the default behavior of HelpRequest() is to display the Contents topic as defined in the HelpDisplay (that is, HelpDisplay:Show("HelpIndex")).</note>
      If a HELPWINDOW request is received, while Window:HelpContext is defined, Window:HelpRequest() uses the HelpContext property, regardless of the window region that has focus.
      Refer to the "GUI Classes" chapter in the Programmer's Guide for more information on programming an online help system for your application.
    </remarks>
  </ShellWindow.HelpRequest>
  <ShellWindow.LineTo>
    <summary>
      This method is inherited from the Window class but does not apply to ShellWindow.
    </summary>
  </ShellWindow.LineTo>
  <ShellWindow.MoveTo>
    <summary>
      This method is inherited from the Window class but does not apply to ShellWindow.
    </summary>
  </ShellWindow.MoveTo>
  <ShellWindow.OnOleStatusMessage>
    <summary>
      Provide a handler routine called with an OLE object's status message.
    </summary>
    <param name="cMsgString">The status string to be displayed.</param>
    <remarks>
      ShellWindow:OnOLEStatusMessage() is called whenever an in-place active OLE object's menu is browsed by the user. The default implementation displays the status string inside the shell window's status bar.
      It should never be necessary to call this method directly. Instead, you can write your own OnOLEStatusMessage() method for derived classed if you want to change the default implementation.
    </remarks>
  </ShellWindow.OnOleStatusMessage>
  <ShellWindow.Owner>
    <summary>
      The owner of the shell window, either a Window or App object.
    </summary>
    <value>The owner of the shell window, either a Window or App object.</value>
  </ShellWindow.Owner>
  <ShellWindow.PaintBoundingBox>
    <summary>
      This method is inherited from the Window class but does not apply to ShellWindow.
    </summary>
  </ShellWindow.PaintBoundingBox>
  <ShellWindow.Pen>
    <summary>
      This method is inherited from the Window class but does not apply to ShellWindow.
    </summary>
    <value>This method is inherited from the Window class but does not apply to ShellWindow.</value>
  </ShellWindow.Pen>
  <ShellWindow.RePaint>
    <summary>
      This method is inherited from the Window class but does not apply to ShellWindow.
    </summary>
  </ShellWindow.RePaint>
  <ShellWindow.RepaintBoundingBox>
    <summary>
      This method is inherited from the Window class but does not apply to ShellWindow.
    </summary>
  </ShellWindow.RepaintBoundingBox>
  <ShellWindow.Resize>
    <inheritdoc />
  </ShellWindow.Resize>
  <ShellWindow.TextColor>
    <summary>
      This method is inherited from the Window class but does not apply to ShellWindow.
    </summary>
    <value>This method is inherited from the Window class but does not apply to ShellWindow.</value>
  </ShellWindow.TextColor>
  <ShellWindow.TextPrint>
    <summary>
      This method is inherited from the Window class but does not apply to ShellWindow.
    </summary>
  </ShellWindow.TextPrint>
  <ShellWindow.ToolBarHeightChanged>
    <inheritdoc />
  </ShellWindow.ToolBarHeightChanged>
  <SingleLineEdit>
    <summary>
      Create a single-line edit control for displaying and entering information to a variable or field in a server.
      Single-line edit controls may be bound to a data server field of any type (character, date, logical, numeric, or memo).
    </summary>
  </SingleLineEdit>
  <SingleLineEdit.ctor>
    <summary>
      Construct a single-line edit control.
    </summary>
    <param name="oOwner">The window that owns the single-line edit control.</param>
    <param name="xID">The unique ID of the single-line edit control (between 1 and 8000).</param>
    <param name="oPoint">The origin of the single-line edit control in canvas coordinates.</param>
    <param name="oDimension">The dimension of the single-line edit control in canvas coordinates.</param>
    <param name="kStyle">The style of the single-line edit control, specified as one of the following constants:</param>
    <param name="nResourceID">The resource ID of the single-line edit control.</param>
    <remarks>
      <include file="Gui.xml" path="doc/EditConstants/*" />
      <note type="tip">In addition to the style constants specified above, you can use any Windows API style constant. Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular constant.</note>
    </remarks>
  </SingleLineEdit.ctor>
  <SingleLineEdit.AutoFocusChange>
    <summary>
      A logical value controlling whether the cursor should skip to the next control in the tab order if it reaches the end of the edit control. The default is FALSE.
    </summary>
    <value>A logical value controlling whether the cursor should skip to the next control in the tab order if it reaches the end of the edit control. The default is FALSE.</value>
  </SingleLineEdit.AutoFocusChange>
  <SingleLineEdit.CreateFormattedString>
    <summary>
      Create formatted text according to the parameters provided.
    </summary>
    <param name="cPicture">The picture clause as a string.</param>
    <param name="cType">The unique ID of the single-line edit control (between 1 and 8000).</param>
    <param name="cDefTempl">The origin of the single-line edit control in canvas coordinates.</param>
    <remarks>
      This method allows the developer to create formatted text in a way other than by using the internal class __FormattedString and prevents the need for using an internal class to do a direct assignment.
    </remarks>
  </SingleLineEdit.CreateFormattedString>
  <SingleLineEdit.CurrentText>
    <summary>
      A string representing the text currently appearing in the edit box.
    </summary>
    <value>A string representing the text currently appearing in the edit box.</value>
    <remarks>
      A string representing the text currently appearing in the edit box. The SingleLineEdit:CurrentText assign also changes SingleLineEdit:TextValue and SingleLineEdit:Value when the focus shifts to another control.
    </remarks>
  </SingleLineEdit.CurrentText>
  <SingleLineEdit.Destroy>
    <summary>
      Provide a method to de-instantiate a SingleLineEdit object.
    </summary>
    <remarks>
      This method can be used when a SingleLineEdit object is no longer needed. SingleLineEdit:Destroy() de-instantiates the SingleLineEdit object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </SingleLineEdit.Destroy>
  <SingleLineEdit.Dispatch>
    <inheritdoc />
  </SingleLineEdit.Dispatch>
  <SingleLineEdit.FocusChange>
    <exclude />

  </SingleLineEdit.FocusChange>
  <SingleLineEdit.FocusSelect>
    <summary>
      Controls the selection when the edit control gets focus.
    </summary>
    <value>Controls the selection when the edit control gets focus.</value>
    <remarks>
      <para>Valid values are:</para>
      <list type="table">
        <item>
          <term>FSEL_ALL</term>
          <description>All of the edit control's contents are selected.</description>
        </item>
        <item>
          <term>FSEL_TRIM</term>
          <description>
            The trimmed content is selected. This is the <b>default</b>.
          </description>
        </item>
        <item>
          <term>FSEL_HOME</term>
          <description>Nothing is selected; the cursor is positioned at the beginning of the edit control.</description>
        </item>
        <item>
          <term>FSEL_END</term>
          <description>Nothing is selected; the cursor is positioned at the end of the edit control.</description>
        </item>
      </list>
    </remarks>
  </SingleLineEdit.FocusSelect>
  <SingleLineEdit.OverWrite>
    <summary>
      A constant representing the overwrite mode for a single-line edit control.
    </summary>
    <value>A constant representing the overwrite mode for a single-line edit control.</value>
    <remarks>
      A constant representing the overwrite mode for a single-line edit control. This property affects only an edit control with an active PICTURE clause. Valid values are:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>OVERWRITE_NEVER</term>
          <description>Edit control is always in INSERT mode.</description>
        </item>
        <item>
          <term>OVERWRITE_ONKEY</term>
          <description>The mode depends on the state of the INSERT key.</description>
        </item>
        <item>
          <term>OVERWRITE_ALWAYS</term>
          <description>Edit control is always in OVERWRITE mode.</description>
        </item>
      </list>
    </remarks>
  </SingleLineEdit.OverWrite>
  <SingleLineEdit.Picture>
    <summary>
      A picture string for a single-line edit control.
    </summary>
    <value>A picture string for a single-line edit control.</value>
    <remarks>
      A picture string for a single-line edit control. If there is a field specification attached to the single-line edit control, the picture should be provided in the field specification and not via the Properties window in the window editor.
      The use of the SingleLineEdit:Picture assign will overwrite the field specification's picture string.
    </remarks>
  </SingleLineEdit.Picture>
  <SingleLineEdit.ScrollMode>
    <summary>
      Specifies the scrolling behavior (e.g., when the Delete key is pressed).
    </summary>
    <value>Specifies the scrolling behavior (e.g., when the Delete key is pressed).</value>
    <remarks>
      <para>Specifies the scrolling behavior (e.g., when the Delete key is pressed). Valid values are:</para>
      <list type="table">
        <item>
          <term>
            SCRMODE_FULL
          </term>
          <description>
            Scrolls through all of the edit control's contents. This is the <b>default</b>.
          </description>
        </item>
        <item>
          <term>
            SCRMODE_PART
          </term>
          <description>Partial scrolling stops at non-edit template characters.</description>
        </item>
        <item>
          <term>SCRMODE_NO</term>
          <description>No scrolling.</description>
        </item>
      </list>
    </remarks>
  </SingleLineEdit.ScrollMode>
  <SingleLineEdit.TextValue>
    <exclude />
  </SingleLineEdit.TextValue>
  <SingleLineEdit.Undo>
    <inheritdoc />
  </SingleLineEdit.Undo>
  <SingleLineEdit.Value>
    <summary>
      SingleLineEdit:Value contains the text stored after the previous edit operation. The SingleLineEdit:Value assign also changes the SingleLineEdit:CurrentText, SingleLineEdit:TextValue, and SingleLineEdit:ValueChanged.
    </summary>
    <value>SingleLineEdit:Value contains the text stored after the previous edit operation. The SingleLineEdit:Value assign also changes the SingleLineEdit:CurrentText, SingleLineEdit:TextValue, and SingleLineEdit:ValueChanged.</value>
  </SingleLineEdit.Value>
  <Slider>
    <summary>
      Create a slider control.
    </summary>
    <remarks>
      A slider is a control that contains a thumb and optional tick marks. The user can move the slider's thumb using either the mouse or the Direction keys.
    </remarks>
  </Slider>
  <Slider.ctor>
    <summary>
      Construct a slider.
    </summary>
    <param name="oOwner">The window that owns the slider.</param>
    <param name="xID">The unique ID between 1 and 8000 of the slider.</param>
    <param name="nResourceID">The resource ID of slider.</param>
    <param name="oPoint">The origin of the slider in canvas coordinates.</param>
    <param name="oDimension">The dimension of the slider in canvas coordinates.</param>
  </Slider.ctor>
  <Slider.BlockSize>
    <summary>
      A numeric value determining the block size (or page size) of the slider control.
    </summary>
    <value>A numeric value determining the block size (or page size) of the slider control.</value>
    <remarks>
      A numeric value determining the block size (or page size) of the slider control. The block size affects how much the slider moves when the user clicks next to the thumb.
    </remarks>
  </Slider.BlockSize>
  <Slider.ChannelBoundingBox>
    <summary>
      A BoundingBox object determining the size and position of the bounding rectangle for a slider control's channel.
    </summary>
    <value>A BoundingBox object determining the size and position of the bounding rectangle for a slider control's channel.</value>
    <remarks>
      A BoundingBox object determining the size and position of the bounding rectangle for a slider control's channel. (The channel is the area over which the thumb moves and which contains the highlight when a range is selected.)
    </remarks>
  </Slider.ChannelBoundingBox>
  <Slider.ClearTicks>
    <summary>
      Clear the slider of all ticks.
    </summary>
  </Slider.ClearTicks>
  <Slider.Create>
    <summary>
      Creates the underlying window control for a X# slider object.
    </summary>
    <returns>
      The window handle of the control, if successful. A null handle (NULL_PTR) is returned if the control creation failed.
    </returns>
    <remarks>
      The Create() method creates the underlying window control for controls not loaded from a resource (i.e., designed with the Window Editor) but created at runtime. Normally, it is not necessary to call Create() directly—CA-X# will create the object internally as soon as a window handle is needed.
    </remarks>
    <example>
      <code language="X#">
        Method CreateSlider() class MyDataWindow
        local oSLDR as Slider
        // Init creates the X# Slider Object
        oSLDR := Slider{self, 100, Point{10,10}, Dimension{100,20}}
        // Calling Create forces the Windows control to be created
        oSLDR:Create()
      </code>
    </example>
  </Slider.Create>
  <Slider.GetTickPos>
    <summary>
      Retrieves the position of a tick mark in a slider control.
    </summary>
    <param name="nIndex">Zero-based index identifying the tick mark.</param>
    <returns>
      The position of the specified tick mark or -1 if <paramref name="nIndex" /> does not specify a valid index.
    </returns>
  </Slider.GetTickPos>
  <Slider.Range>
    <summary>
      A Range object representing the minimum and maximum values currently in use for the thumb of the slider.
    </summary>
    <value>A Range object representing the minimum and maximum values currently in use for the thumb of the slider.</value>
  </Slider.Range>
  <Slider.SetTickPos>
    <summary>
      Sets the position of a tick mark in a slider control.
    </summary>
    <param name="nPosition">** missing parameter documentation **</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </Slider.SetTickPos>
  <Slider.ThumbBoundingBox>
    <summary>
      A BoundingBox object determining the size and position of the bounding rectangle for the thumb in a slider control.
    </summary>
    <value>A BoundingBox object determining the size and position of the bounding rectangle for the thumb in a slider control.</value>
  </Slider.ThumbBoundingBox>
  <Slider.ThumbLength>
    <summary>
      A numeric value determining the length of the thumb in a slider control
    </summary>
    <value>A numeric value determining the length of the thumb in a slider control</value>
  </Slider.ThumbLength>
  <Slider.ThumbPosition>
    <summary>
      A numeric value determining the current position of the thumb in a slider control.
    </summary>
    <value>A numeric value determining the current position of the thumb in a slider control.</value>
  </Slider.ThumbPosition>
  <Slider.TickAlignment>
    <summary>
      <para>A symbol that describes the alignment of ticks on the slider.</para>
      <para>Valid values for a horizontal slider are</para>
      <list type="bullet">
        <item>#Top</item>
        <item>#Bottom</item>
        <item>#Both</item>
      </list>
      <para>Valid values for a vertical slider are</para>
      <list type="bullet">
        <item>#Left</item>
        <item>#Right</item>
        <item>#Both</item>
      </list>
    </summary>
    <value>A symbol that describes the alignment of ticks on the slider.Valid values for a horizontal slider are#Top#Bottom#BothValid values for a vertical slider are#Left#Right#Both</value>
  </Slider.TickAlignment>
  <Slider.TickCount>
    <summary>
      A numeric value representing the number of ticks on the slider.
    </summary>
    <value>A numeric value representing the number of ticks on the slider.</value>
  </Slider.TickCount>
  <Slider.UnitSize>
    <summary>
      A numeric value determining the unit size (or line size) of the slider control.
    </summary>
    <value>A numeric value determining the unit size (or line size) of the slider control.</value>
    <remarks>
      A numeric value determining the unit size (or line size) of the slider control. The unit size affects how much the slider moves when the user presses the cursor left or cursor right key on the keyboard.
    </remarks>
  </Slider.UnitSize>
  <SliderEvent>
    <summary>
      Provide information about a slider event, which is generated when the thumb of a slider is dragged with the mouse or moved by pressing the Direction keys.
    </summary>
    <remarks>
      A slider event is generated when the thumb of a slider is moved either by mouse or by keyboard. This event is generated for both horizontal and vertical sliders.
    </remarks>
  </SliderEvent>
  <SliderEvent.ctor>
    <inheritdoc />
  </SliderEvent.ctor>
  <SliderEvent.IsWindowScroll>
    <exclude />
  </SliderEvent.IsWindowScroll>
  <SliderEvent.Slider>
    <summary>
      The slider control object that generated this event.
    </summary>
    <value>The slider control object that generated this event.</value>
  </SliderEvent.Slider>
  <Spinner>
    <summary>
      Create a spinner.
    </summary>
    <remarks>
      A spinner is a pair of arrow buttons that can be clicked to change a value, such as a number displayed in another control. A spinner can exist independently but is most often used with another control, referred to as the client.
    </remarks>
  </Spinner>
  <Spinner.ctor>
    <summary>
      Construct a spinner.
    </summary>
    <param name="oOwner">The window that owns the spinner.</param>
    <param name="xID">The unique ID of the spinner (between 1 and 8000).</param>
    <param name="oPoint">The origin of the spinner in canvas coordinates.</param>
    <param name="oDimension">The dimension of the spinner in canvas coordinates.</param>
    <param name="kStyle">The style of the spinner.</param>
    <param name="lDataAware">A logical value specifying whether the spinner is data aware.</param>
    <param name="nResourceID">The resource ID of the spinner.</param>
  </Spinner.ctor>
  <Spinner.Client>
    <summary>
      The client control of the spinner.
    </summary>
    <value>The client control of the spinner.</value>
  </Spinner.Client>
  <Spinner.IsHexBased>
    <exclude />
  </Spinner.IsHexBased>
  <Spinner.Position>
    <summary>
      The numeric value of the spinner.
    </summary>
    <value>The numeric value of the spinner.</value>
  </Spinner.Position>
  <Spinner.Range>
    <exclude />
  </Spinner.Range>
  <Spinner.ThumbPosition>
    <exclude />
  </Spinner.ThumbPosition>
  <SpinnerEvent>
    <summary>
      Provide information about a spinner event, which is generated when either of the spinner's arrow buttons is clicked.
    </summary>
    <remarks>
      A spinner event is generated when an arrow button of a spinner control is clicked. This event is generated for both horizontal and vertical spinners.
    </remarks>
  </SpinnerEvent>
  <SpinnerEvent.ctor>
    <inheritdoc />
  </SpinnerEvent.ctor>
  <SpinnerEvent.OldPosition>
    <summary>
      A numeric value representing the position of the spinner associated with this event immediately before the event occurred.
    </summary>
    <value>A numeric value representing the position of the spinner associated with this event immediately before the event occurred.</value>
  </SpinnerEvent.OldPosition>
  <SpinnerEvent.OldValue>
    <summary>
      The value of the spinner associated with this event immediately before the event occurred.
    </summary>
    <value>The value of the spinner associated with this event immediately before the event occurred.</value>
  </SpinnerEvent.OldValue>
  <SpinnerEvent.Position>
    <summary>
      A numeric value representing the new position of the spinner associated with this event.
    </summary>
    <value>A numeric value representing the new position of the spinner associated with this event.</value>
  </SpinnerEvent.Position>
  <SpinnerEvent.Spinner>
    <summary>
      The spinner control object that generated this event.
    </summary>
    <value>The spinner control object that generated this event.</value>
  </SpinnerEvent.Spinner>
  <SpinnerEvent.SpinnerID>
    <summary>
      The numeric ID of the spinner control object that generated this event.
    </summary>
    <value>The numeric ID of the spinner control object that generated this event.</value>
  </SpinnerEvent.SpinnerID>
  <SpinnerEvent.Type>
    <summary>
      One of the following constants representing the type of action that took place when this event occurred:
    </summary>
    <value>One of the following constants representing the type of action that took place when this event occurred:</value>
    <remarks>
      One of the following constants representing the type of action that took place when this event occurred:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>UNITDECREMENT</term>
          <description>The position has been decremented by a single unit.</description>
        </item>
        <item>
          <term>UNITINCREMENT</term>
          <description>The position has been incremented by a single unit.</description>
        </item>
        <item>
          <term>SCROLLTOTOPLEFT</term>
          <description>Spinning has reached the top-most position in a vertical spinner or the left-most position in a horizontal spinner.</description>
        </item>
        <item>
          <term>SCROLLTOBOTTOMRIGHT</term>
          <description>Spinning has reached the bottom-most position in a vertical spinner or the right-most position in a horizontal spinner.</description>
        </item>
        <item>
          <term>SCROLLEND</term>
          <description>Spinning has finished.</description>
        </item>
      </list>
    </remarks>
  </SpinnerEvent.Type>
  <SpinnerEvent.Value>
    <summary>
      The new value of the spinner associated with this event.
    </summary>
    <value>The new value of the spinner associated with this event.</value>
  </SpinnerEvent.Value>
  <SplitWindow>
    <summary>
      Create a split window.
    </summary>
    <remarks>
      A split window provides a simple and easy way to create a window that can be split into several pane windows separated by split bars that can be dragged to resize the panes. Each pane can specify a client window or control, which is automatically sized to fit into the pane.
      A Dimension object is used to configure the layout of the split window panes. The width specifies the number of panes across (horizontally), and the height specifies the number of panes up and down (vertically). Panes are numbered from left to right and top to bottom. For example, a split window with a layout of Dimension{4, 3} is arranged as follows:
      1	2	3	4
      5	6	7	8
      9	10	11	12
      The maximum total number of panes is 16.
      <note type="tip">Static dependencies to the CATO3*.DLL files, which contain the DataBrowser and SplitWindow functionality, have been removed in this version of X#. Applications not using a data browser and/or split window no longer need these .DLLs. This leads to a smaller memory footprint, faster application startup, and smaller installations.</note>
    </remarks>
  </SplitWindow>
  <SplitWindow.ctor>
    <summary>
      Construct a SplitWindow object.
    </summary>
    <param name="oOwner">The window that owns the split window.</param>
    <param name="lHorizontalDrag">A logical value that is TRUE if horizontal split bars can be dragged. If omitted, the default is FALSE, which indicates that horizontal split bar dragging is disabled.</param>
    <param name="lVerticalDrag">A logical value that is TRUE if vertical split bars can be dragged. If omitted, the default is FALSE, which indicates that vertical split bar dragging is disabled.</param>
    <param name="kAlignment">
      One of the following constants specifying how to align split bars in the split window:
    </param>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>
            SPLIT_HORZALIGN
          </term>
          <description>Split bars are horizontally aligned</description>
        </item>
        <item>
          <term>
            SPLIT_VERTALIGN
          </term>
          <description>Split bars are vertically aligned</description>
        </item>
      </list>
      If omitted, the default alignment is vertical (SPLIT_VERTALIGN). Split bars can be aligned either horizontally or vertically, but not both.

    </remarks>
  </SplitWindow.ctor>
  <SplitWindow.Background>
    <summary>
      The background brush currently in use by the split window.
    </summary>
    <value>The background brush currently in use by the split window.</value>
  </SplitWindow.Background>
  <SplitWindow.ChangeBackground>
    <summary>
      Change the background brush of a particular component of the split window.
    </summary>
    <param name="oBrush">The new Brush object to apply.</param>
    <param name="kWhere">One of the following constants specifying the portion of the split window where the new brush will be applied:</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>SPLIT_COLORWINDOW</term>
          <description>Split window background brush</description>
        </item>
        <item>
          <term>SPLIT_COLORBAR</term>
          <description>Split bar background brush</description>
        </item>
        <item>
          <term>SPLIT_COLORFRAME</term>
          <description>Split bar frame background brush</description>
        </item>
      </list>
    </remarks>
  </SplitWindow.ChangeBackground>
  <SplitWindow.Destroy>
    <inheritdoc />
  </SplitWindow.Destroy>
  <SplitWindow.Dispatch>
    <inheritdoc />
  </SplitWindow.Dispatch>
  <SplitWindow.EnableStatusBar>
    <inheritdoc />
  </SplitWindow.EnableStatusBar>
  <SplitWindow.GetAllChildren>
    <inheritdoc />
  </SplitWindow.GetAllChildren>
  <SplitWindow.GetPaneClient>
    <summary>
      Get the client window or control associated with a split window pane index.
    </summary>
    <param name="nPane">The index of the split window pane.</param>
    <returns>
      An object representing the split window pane's client window.
    </returns>
  </SplitWindow.GetPaneClient>
  <SplitWindow.GetPaneSize>
    <summary>
      Get a Dimension object that represents the current size of a pane.
    </summary>
    <param name="nPane">The index of the split window pane.</param>
    <returns>
      A Dimension object representing the split window pane's size.
    </returns>
  </SplitWindow.GetPaneSize>
  <SplitWindow.HidePane>
    <summary>
      Hide a particular pane or all panes of a split window.
    </summary>
    <param name="nPane">The index of the split window pane to hide. If omitted, all panes are hidden.</param>
  </SplitWindow.HidePane>
  <SplitWindow.HorizontalAlign>
    <summary>
      A logical value that is TRUE if horizontal split bars are aligned in the split window.
    </summary>
    <value>A logical value that is TRUE if horizontal split bars are aligned in the split window.</value>
  </SplitWindow.HorizontalAlign>
  <SplitWindow.HorizontalDrag>
    <summary>
      A logical value that is TRUE if dragging of horizontal split bars is enabled in the split window.
    </summary>
    <value>A logical value that is TRUE if dragging of horizontal split bars is enabled in the split window.</value>
  </SplitWindow.HorizontalDrag>
  <SplitWindow.Layout>
    <summary>
      A Dimension object that represents the number and visual layout of the panes in the split window.
    </summary>
    <value>A Dimension object that represents the number and visual layout of the panes in the split window.</value>
    <remarks>
      A Dimension object that represents the number and visual layout of the panes in the split window. The width of the dimension represents the number of horizontally aligned panes, while the height of the dimension represents the number of vertically aligned panes.
    </remarks>
  </SplitWindow.Layout>
  <SplitWindow.Resize>
    <inheritdoc />
  </SplitWindow.Resize>
  <SplitWindow.RestoreUpdate>
    <summary>
      Decrement the buffered paint count maintained by the split window.
    </summary>
    <remarks>
      Every call to RestoreUpdate() should be paired with a call to SuspendUpdate(). If the paint count is zero, deferred painting is ended.
    </remarks>
  </SplitWindow.RestoreUpdate>
  <SplitWindow.SetPaneClient>
    <summary>
      Set the client window or control associated with a split window pane index.
    </summary>
    <param name="oWindow">The client window or control to be associated with the specified pane.</param>
    <param name="nPane">The index of the split window pane.</param>
  </SplitWindow.SetPaneClient>
  <SplitWindow.SetPaneSize>
    <summary>
      Set a Dimension object representing the current size of a pane.
    </summary>
    <param name="oDimension">A Dimension object representing the new size of the specified split window pane.</param>
    <param name="nPane">The index of the split window pane.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </SplitWindow.SetPaneSize>
  <SplitWindow.Show>
    <inheritdoc cref="M:VO.Window.Show(XSharp.__Usual)"/>
  </SplitWindow.Show>
  <SplitWindow.ShowPane>
    <summary>
      Show a particular pane or all panes of a split window.
    </summary>
    <param name="nPane">The index of the split window pane to show. If omitted, all panes are shown.</param>
  </SplitWindow.ShowPane>
  <SplitWindow.SplitBarBackground>
    <summary>
      The background brush currently in use by split bars in the split window.
    </summary>
    <value>The background brush currently in use by split bars in the split window.</value>
  </SplitWindow.SplitBarBackground>
  <SplitWindow.SplitBarFrameBackground>
    <summary>
      The background brush currently in use by split bar frames in the split window.
    </summary>
    <value>The background brush currently in use by split bar frames in the split window.</value>
  </SplitWindow.SplitBarFrameBackground>
  <SplitWindow.SuspendUpdate>
    <summary>
      Increment the buffered paint count maintained by the split window.
    </summary>
    <remarks>
      Every call to SuspendUpdate() should be paired with a call to RestoreUpdate(). If the paint count is zero, deferred painting is ended.
    </remarks>
  </SplitWindow.SuspendUpdate>
  <SplitWindow.ToolBarHeightChanged>
    <inheritdoc />
  </SplitWindow.ToolBarHeightChanged>
  <SplitWindow.VerticalAlign>
    <summary>
      A logical value that is TRUE if vertical split bars are aligned in the split window.
    </summary>
    <value>A logical value that is TRUE if vertical split bars are aligned in the split window.</value>
  </SplitWindow.VerticalAlign>
  <SplitWindow.VerticalDrag>
    <summary>
      A logical value that is TRUE if dragging of vertical split bars is enabled in the split window.
    </summary>
    <value>A logical value that is TRUE if dragging of vertical split bars is enabled in the split window.</value>
  </SplitWindow.VerticalDrag>
  <StandardColorDialog>
    <summary>
      Provide the base class from which all X# color dialog boxes are subclassed.
    </summary>
    <remarks>
      <br />Important! StandardColorDialog is an abstract class and should not be used directly—instead, use one of its subclasses, which include PaletteDialog and SelectDialog.
    </remarks>
  </StandardColorDialog>
  <StandardColorDialog.ctor>
    <summary>
      Construct a standard color dialog.
    </summary>
    <param name="oColor">Color object representing the default color to be displayed in the standard color dialog. If omitted, the default color is black.</param>
  </StandardColorDialog.ctor>
  <StandardColorDialog.Color>
    <summary>
      Return the color that the user selected.
    </summary>
  </StandardColorDialog.Color>
  <StandardColorDialog.Destroy>
    <summary>
      Provide a method to free memory resources allocated for a StandardColorDialog object and its derived objects.
    </summary>
    <remarks>
      StandardColorDialog:Destroy() frees resources for StandardColorDialog objects created explicitly in an application. This method also takes care of resources allocated to derived classes and deallocates them in the necessary order.
    </remarks>
  </StandardColorDialog.Destroy>
  <StandardColorDialog.Show>
    <summary>
      Display a standard color dialog box. To retrieve the value that the user selected, use the StandardColorDialog:Color() method.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </StandardColorDialog.Show>
  <StandardDialog>
    <summary>
      Provide the base class from which all X# standard dialog boxes are subclassed.
    </summary>
    <remarks>
      <br />Important! StandardDialog is an abstract class and should not be used directly—instead, use one of its subclasses, which include OpenDialog, PaletteDialog, SaveAsDialog, SelectDialog, and StandardFontDialog.
    </remarks>
  </StandardDialog>
  <StandardDialog.ctor>
    <summary>
      Construct a standard dialog.
    </summary>
  </StandardDialog.ctor>
  <StandardFileDialog>
    <summary>
      Provide the base class from which all X# standard file-oriented dialog boxes are subclassed.
    </summary>
    <remarks>
      <br />Important! StandardFileDialog is an abstract class and should not be used directly—instead, use one of its subclasses, which include OpenDialog and SaveAsDialog.
    </remarks>
  </StandardFileDialog>
  <StandardFileDialog.ctor>
    <summary>
      Construct a standard file dialog.
    </summary>
    <param name="uOwner">The window object that owns the standard file dialog. If omitted, the dialog is not owned by any window.</param>
    <param name="cInitPath">String representing the initial file or directory to display in the dialog. Use this, for example, to prompt the user with the current name of the file. You can also specify wildcards, such as '*.TXT'. The default is '*.*'.</param>
    <remarks>
      <note type="tip">
        If the :SetFilter( ) method is going to be used, cInitPath must be specified as "" because without this the filter will have no effect and the default of "*.*" will take effect so as to show all files.
      </note>
    </remarks>
  </StandardFileDialog.ctor>
  <StandardFileDialog.Caption>
    <summary>
      Return or update the title displayed in the dialog window.
    </summary>
    <value>Return or update the title displayed in the dialog window.</value>
    <example>
      This example uses the Caption assign to set a title for an OpenFile dialog window:
      <code language="X#">
        METHOD MyOpen() CLASS StandardShellWindow
        LOCAL oOpenDialog AS OpenDialog
        oOpenDialog:=OpenDialog{SELF}
        oOpenDialog:Caption:="My OpenFile Dialog"
        oOpenDialog:Show()
      </code>
    </example>
  </StandardFileDialog.Caption>
  <StandardFileDialog.DefExt>
    <summary>
      Return or update the default file extension displayed in the dialog window.
    </summary>
    <value>Return or update the default file extension displayed in the dialog window.</value>
  </StandardFileDialog.DefExt>
  <StandardFileDialog.Destroy>
    <inheritdoc />
  </StandardFileDialog.Destroy>
  <StandardFileDialog.Dispatch>
    <summary>
      Intercept messages normally handled by the dialog box procedure in COMMDLG.DLL. Override this method to add your own custom processing.
    </summary>
    <param name="oEvt">An Event object.</param>
    <param name="hDlg">Handle of the dialog box.</param>
    <seealso cref="T:VO.Event" />
    <returns>
      A long integer indicating if the message is to be handled by the dialog box procedure in COMMDLG.DLL. Returns a non zero value to indicate that no further processing of the message is required. Returns a zero to continue processing for this message.
    </returns>
  </StandardFileDialog.Dispatch>
  <StandardFileDialog.FileName>
    <summary>
      A string representing the name of the file which the user selected. If the user cancels, the file name is NULL_STRING.
    </summary>
    <value>A string representing the name of the file which the user selected. If the user cancels, the file name is NULL_STRING.</value>
    <example>
      This example displays an OpenFile dialog with a filter which is set to display only DBFs and index files. Multiple file selection enables a user to select a DBF and an index. A DBServer object for the selected file(s) is created and returned to the caller.
      <code language="X#">
        METHOD OpenDB() CLASS StandardShellWindow
        LOCAL oOpenDialog   AS OpenDialog
        LOCAL uFileName   AS USUAL
        LOCAL aoFileSpecs  := {}  AS ARRAY
        LOCAL lDone  := .F.  AS LOGIC
        LOCAL oDB   AS Dbserver
        DO WHILE !lDone
        oOpenDialog:=OpenDialog{SELF}
        oOpenDialog:Caption:="Open DBF and Index"
        oOpenDialog:SetFilter ({"CUST*.*","ORD*.*","DET*.*"},;
        {"Customers", "Orders", "Details"})
        oOpenDialog:SetStyle(OFN_ALLOWMULTISELECT + OFN_HIDEREADONLY)
        oOpenDialog:InitialDirectory := "C:\CAVO2x\SAMPLES\GSTUTOR"
        oOpenDialog:Show()
        uFileName := oOpenDialog:FileName
        IF IsArray(uFileName) .AND. ALen(uFileName) &gt; 2
        (TextBox{SELF,"File Selection Error",;
        "Too many files selected"+CRLF+;
        "Please select one DBF and one index"}):Show()
        ELSE
        lDone := .T.
        ENDIF
        ENDDO
        // Open the selected DBF and index file
        uFileName := oOpenDialog:FileName
        IF IsArray(uFileName)   // DBF and Index selected ?
        AEval(uFileName,{ | cFileName | AADD( ;
        aoFileSpecs, FileSpec{cFileName} ) } )
        IF aoFileSpecs[1]:Extension != ".DBF"
        aoFileSpecs[1]:= ArraySwap(aoFileSpecs, ;
        2, aoFileSpecs[1])
        ENDIF
        RDDSetDefault("DBF"+SUBSTR(aoFileSpecs[2]:;
        Extension, 2, 3) )
        oDB := DBServer{aoFileSpecs[1]}
        oDB:SetIndex(aoFileSpecs[2])
        ELSEIF LOGIC(_CAST, uFileName)   // Anything selected at all?
        AADD(aoFileSpecs,FileSpec{uFileName})
        oDB := DBServer{aoFileSpecs[1]}
        ENDIF
        RETURN oDB
      </code>
    </example>
  </StandardFileDialog.FileName>
  <StandardFileDialog.FilterIndex>
    <summary>
      A string representing the index of the effective filter.
    </summary>
    <value>A string representing the index of the effective filter.</value>
  </StandardFileDialog.FilterIndex>
  <StandardFileDialog.help>
    <summary>
      Provide a means of displaying help when the HELP button is pressed. The HELP push button will be displayed if the SetStyle(OFN_SHOWHELP) message has been sent to the dialog object.
    </summary>
    <returns>
      A long integer indicating if the message is to be handled by the dialog box procedure in COMMDLG.DLL. The method returns a non zero value to indicate that no further processing of the message is required. It returns a zero to continue processing for this message.
    </returns>
    <remarks>
      <note type="tip">If &lt;oStandardFileDialog&gt;:SetStyle(OFN_SHOWHELP) is used, a "Help" pushbutton is created on the dialog box. A &lt;oStandardFileDialog&gt;:Help() method needs to be created to process the event associated with a user clicking on the "Help" button.</note>
    </remarks>
  </StandardFileDialog.help>
  <StandardFileDialog.InitialDirectory>
    <summary>
      Set the initial directory for the dialog window. The tree control will be initially positioned accordingly.
    </summary>
    <value>Set the initial directory for the dialog window. The tree control will be initially positioned accordingly.</value>
    <example>
      This example sets the initial directory to "C:\CAVO2x\SAMPLES":
      <code language="X#">
        METHOD MyOpen() CLASS StandardShellWindow
        LOCAL oOpenDialog AS OpenDialog
        oOpenDialog := OpenDialog{SELF}
        oOpenDialog:InitialDirectory := "C:\CAVO2x\SAMPLES"
        oOpenDialog:Show()
      </code>
    </example>
  </StandardFileDialog.InitialDirectory>
  <StandardFileDialog.NoPlacesBar>
    <exclude />
  </StandardFileDialog.NoPlacesBar>
  <StandardFileDialog.ReadOnly>
    <summary>
      A logical value indicating that the file's read-only attribute is set.
    </summary>
    <value>A logical value indicating that the file's read-only attribute is set.</value>
  </StandardFileDialog.ReadOnly>
  <StandardFileDialog.SetFilter>
    <summary>
      Set single or multiple filters and descriptions for the standard dialogs. If multiple filters are specified, a filter index may also be specified.
    </summary>
    <param name="uFilter">
      An array of filter strings. Grouped filters within a string must be delimited by semicolons or
      a single filter string. Grouped filters within a string must be delimited by semicolons..
    </param>
    <param name="uFilterDesc">An array of filter descriptions.</param>
    <param name="nIndex">A number specifying the initial filter in use if multiple filters are in effect.</param>
    <remarks>
      The standard dialog windows for the OpenFile and SaveAs dialogs may be customized by specifying one or more file name filters and their descriptions. The filters are used as a mask for file names displayed in the list. Each filter string may be composed of several filters delimited by semicolons. If multiple filters have been set, an index may be specified, which in turn specifies the initial filter displayed.
      <note type="tip">
        In the above example, the second parameter to the class has been specified as "" because without this the filter will have no effect and the default of "*.*" will take effect so as to show all files.
      </note>
    </remarks>
    <example>
      This example sets multiple filters for an OpenFile dialog. Some of the filter strings specify groups of filters:
      <code language="X#">
        METHOD MyOpen() CLASS StandardShellWindow
        LOCAL oOpenDialog AS OpenDialog
        oOpenDialog:= OpenDialog{SELF, ""}
        oOpenDialog:Caption:="Multiple Filters Test"
        oOpenDialog:SetFilter (	{"*.WRI;*.TXT", "*.PRG;*.CXX;*.C", "*.INI"},;
        {"Doc", "Program Source", "INI Files"},2)
        // The index may also be set independently:
        // oOpenDialog:SetFilter(,,2)
        oOpenDialog:InitialDirectory := "C:\CAVO28\Bin\"
        oOpenDialog:Show()
      </code>
    </example>
  </StandardFileDialog.SetFilter>
  <StandardFileDialog.SetStyle>
    <summary>
      Set the style for the dialog window.
    </summary>
    <param name="kStyle">The capability to be queried, specified by a Windows API OpenFileName flag constant (for example, OFN_ALLOWMULTISELECT).</param>
    <param name="lOnOff">A logical value that specifies whether the style setting is turned on or off. A value of TRUE means that the style setting is turned on; a value of FALSE means that it is set off. The default is TRUE.</param>
    <remarks>
      The style of the dialog windows for the OpenFile and SaveAs dialogs may be customize through the use of the SetStyle() method. Refer to the Windows API constants documented in the Microsoft Win32 Software Development Kit.
    </remarks>
    <example>
      This example removes the ReadOnly check box from the dialog window, allows multiple file selection and retains current directory setting in effect prior to the dialog:
      <code language="X#">
        METHOD MyOpen() CLASS StandardShellWindow
        LOCAL oOpenDialog AS OpenDialog
        oOpenDialog:=OpenDialog{SELF}
        oOpenDialog:SetStyle(OFN_ALLOWMULTISELECT)
        oOpenDialog:SetStyle(OFN_NOCHANGEDIR)
        oOpenDialog:SetStyle(OFN_HIDEREADONLY)
        oOpenDialog:Show()
      </code><note type="tip">If &lt;oStandardFileDialog&gt;:SetStyle(OFN_SHOWHELP) is used, a "Help" push button is created on the dialog box. A &lt;oStandardFileDialog&gt;:Help() method needs to be created to process the event associated with a user clicking on the "Help" button.</note>
    </example>
  </StandardFileDialog.SetStyle>
  <StandardFileDialog.SetStyleEx>
    <summary>
      Set the Exstyle for the dialog window.
    </summary>
    <param name="kStyle">The capability to be queried, specified by a Windows API OpenFileName flag constant (for example, OFN_ALLOWMULTISELECT).</param>
    <param name="lOnOff">A logical value that specifies whether the style setting is turned on or off. A value of TRUE means that the style setting is turned on; a value of FALSE means that it is set off. The default is TRUE.</param>
  </StandardFileDialog.SetStyleEx>
  <StandardFileDialog.Show>
    <summary>
      Display a standard file dialog box. To retrieve the value that the user selected, use the StandardFileDialog:FileName property.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </StandardFileDialog.Show>
  <StandardFolderDialog>
    <summary>
      Encapsulate a standard folder dialog.
    </summary>
    <remarks>
      The standard folder dialog allows the user to select a folder or directory interactively.
    </remarks>
  </StandardFolderDialog>
  <StandardFolderDialog.ctor>
    <summary>
      Construct a standard folder dialog.
    </summary>
    <param name="oOwner">The window that owns the standard folder dialog.</param>
    <param name="sCaption">The caption of the standard folder dialog. The default is 'Browser Folder'.</param>
    <param name="sStartFolder">The starting folder for the browse.</param>
    <param name="kType">
      Any _ORed combination of the following constants:
      Returns only file system directories (default).
      Does not include network folders below the domain level.
      Returns only computers.
      Returns only printers.
      The browse dialog includes files and folders.
    </param>
    <remarks>
      The standard folder dialog allows the user to browse for directories, as well as for printers and computers.
    </remarks>
  </StandardFolderDialog.ctor>
  <StandardFolderDialog.DialogCallBack>
    <exclude />
  </StandardFolderDialog.DialogCallBack>
  <StandardFolderDialog.FolderName>
    <summary>
      The name of the selected folder or directory (same as StandardFolderDialog:Result).
    </summary>
    <value>The name of the selected folder or directory (same as StandardFolderDialog:Result).</value>
  </StandardFolderDialog.FolderName>
  <StandardFolderDialog.Result>
    <summary>
      The name of the selected folder or directory (same as StandardFolderDialog:FolderName).
    </summary>
    <value>The name of the selected folder or directory (same as StandardFolderDialog:FolderName).</value>
  </StandardFolderDialog.Result>
  <StandardFolderDialog.Show>
    <summary>
      Display a standard folder dialog box. To retrieve the value that the user selected, use the relevant method of the specific subclass.
    </summary>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      The item selected by the user can be retrieved with the StandardFolderDialog:Result property.
    </remarks>
  </StandardFolderDialog.Show>
  <StandardFontDialog>
    <summary>
      Provide standard font dialog facilities.
    </summary>
  </StandardFontDialog>
  <StandardFontDialog.ctor>
    <summary>
      Construct a standard font dialog.
    </summary>
    <param name="uOwner">A Window object which identifies the device (i.e., monitor) for which to create the font list.</param>
    <param name="oPrinter">A Printer object which identifies the device (i.e., printer) for which to create the font list.</param>
    <remarks>
      A StandardFontDialog object is created, with a list of fonts available for the specified device.
    </remarks>
  </StandardFontDialog.ctor>
  <StandardFontDialog.EnableANSI>
    <summary>
      Allow ANSI fonts to appear in the list of fonts in the standard font dialog.
    </summary>
    <param name="bOnOff">The logical value indicating whether ANSI fonts appear in the list of fonts. TRUE is the default, if omitted or if the method is not called.</param>
  </StandardFontDialog.EnableANSI>
  <StandardFontDialog.EnableEffects>
    <summary>
      Allow the ability to change font effects, such as underline, strikethrough, and color.
    </summary>
    <param name="bOnOff">The logical value indicating whether font effects can be modified through the standard font dialog. TRUE is the default, if omitted or if the method is not called.</param>
    <remarks>
      When StandardFontDialog:EnableEffects() method is called, check boxes that allow the user to select the underline and strikethrough font attributes appear. The combo box to allow the user to select the color of the text is also enabled. The color that the user last selected is only evident after StandardFontDialog:EnableEffects(TRUE) is called.
    </remarks>
  </StandardFontDialog.EnableEffects>
  <StandardFontDialog.EnableFixedPitch>
    <summary>
      Determine whether only fixed pitch fonts will be displayed in the list of fonts for the standard font dialog.
    </summary>
    <param name="bOnOff">Logical value indicating whether only fixed pitch fonts appear in the list of fonts.</param>
  </StandardFontDialog.EnableFixedPitch>
  <StandardFontDialog.EnableTrueType>
    <summary>
      Determine whether only true type fonts will be displayed in the list of fonts for the standard font dialog.
    </summary>
    <param name="bOnOff">Logical value indicating whether only true type fonts appear in the list of fonts.</param>
  </StandardFontDialog.EnableTrueType>
  <StandardFontDialog.Flags>
    <summary>
      A Windows API style constant to be set for the standard font dialog window.
    </summary>
    <value>A Windows API style constant to be set for the standard font dialog window.</value>
    <remarks>
      <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for information on the available constants.</note>
    </remarks>
  </StandardFontDialog.Flags>
  <StandardFontDialog.Font>
    <summary>
      The font that was last selected in the standard font dialog window.
    </summary>
    <value>The font that was last selected in the standard font dialog window.</value>
  </StandardFontDialog.Font>
  <StandardFontDialog.FontColor>
    <summary>
      The font color that was last selected in the standard font dialog window. This is only evident after EnableEffects(TRUE) has been called.
    </summary>
    <value>The font color that was last selected in the standard font dialog window. This is only evident after EnableEffects(TRUE) has been called.</value>
  </StandardFontDialog.FontColor>
  <StandardFontDialog.Show>
    <summary>
      Display a standard font dialog. To retrieve the value that the user selected, use the StandardFontDialog:Font access.
    </summary>
    <returns>
      TRUE if user chooses a font, FALSE if the user presses CANCEL.
    </returns>
  </StandardFontDialog.Show>
  <StatusBar>
    <summary>
      Create a status bar for use in a window.
    </summary>
    <remarks>
      A status bar is the shallow bar that appears usually at the bottom of a window to provide status information to the user without taking up much screen "real-estate." Visual Object's status bar class has methods to present the following kinds of information:
      Status messages (permanent or transient)
      Time
      Keyboard state (NumLock, CapsLock, ScrollLock, and Insert keys)
      Virtual memory available
      A screen coordinate reading
      The sequence in which you call the various Display… methods determines the left-to-right order in which the corresponding items appear upon the status bar. Any transient status message overrides the StatusBar:PermanentText status message, but it times out after five seconds.
      <note type="tip">You never create a status bar yourself. Instead, you ask the window to do it, by calling AppWindow:EnableStatusBar(). Once you pick up the status bar returned by that method, you can customize the status bar by invoking the various Display… methods of status bar. Note that, except for the time display, the status bar items require you to refresh them. For example, if you turn on the display of available virtual memory, you must call the StatusBar:RefreshMemoryDisplay() method whenever the application is about to embark on a "memory-hungry" task. Because you never create status bars, you also never destroy them—the window does that itself.</note>
    </remarks>
  </StatusBar>
  <StatusBar.ctor>
    <summary>
      Construct a status bar.
    </summary>
    <param name="oOwner">The window that owns the status bar.</param>
    <param name="xID">The unique ID of the control (between 1 and 8000).</param>
    <param name="oPoint">The origin of the control in canvas coordinates.</param>
    <param name="oDimension">The dimension of the control in canvas coordinates.</param>
  </StatusBar.ctor>
  <StatusBar.AddItem>
    <summary>
      Add a new item to the status bar.
    </summary>
    <param name="oStatusBarItem">The new item to add to the status bar.</param>
  </StatusBar.AddItem>
  <StatusBar.AsString>
    <summary>
      A string representing the most recent StatusBar:PermanentText status message,
    </summary>
    <value>A string representing the most recent StatusBar:PermanentText status message,</value>
    <remarks>
      A string representing the most recent StatusBar:PermanentText status message, even if the status bar currently displays a transient message. If you disabled the message display, StatusBar:AsString returns NIL.
      The status bar does not wait for any transient message to time out. If the message was supplied as a hyperlabel instead of a string, AsString extracts and returns the hyperlabel's description.
    </remarks>
  </StatusBar.AsString>
  <StatusBar.Background>
    <summary>
      This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.
    </summary>
    <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.</value>
  </StatusBar.Background>
  <StatusBar.ClearItems>
    <summary>
      Remove all of the status bar items.
    </summary>
  </StatusBar.ClearItems>
  <StatusBar.ControlID>
    <summary>
      This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.
    </summary>
    <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.</value>
  </StatusBar.ControlID>
  <StatusBar.ControlText>
    <summary>
      A string representing a message associated with a control to be displayed on the status bar. This message takes priority over the StatusBar:PermanentText message.
    </summary>
    <value>A string representing a message associated with a control to be displayed on the status bar. This message takes priority over the StatusBar:PermanentText message.</value>
  </StatusBar.ControlText>
  <StatusBar.Create>
    <exclude />
  </StatusBar.Create>
  <StatusBar.Destroy>
    <summary>
      Provide a method to de-instantiate a StatusBar object.
    </summary>
    <remarks>
      This method can be used when a StatusBar object is no longer needed. StatusBar:Destroy() de-instantiates the StatusBar object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </StatusBar.Destroy>
  <StatusBar.Disable>
    <summary>
      Disable a status bar (until a subsequent call to StatusBar:Enable()).
    </summary>
    <remarks>
      Disabled status bars are not active and, therefore, they do not send events to their owner windows.
    </remarks>
  </StatusBar.Disable>
  <StatusBar.DisabledKeyIndicatorColor>
    <summary>
      The Color object that the status bar uses to indicate that a key is disabled. The default is gray.
    </summary>
    <value>The Color object that the status bar uses to indicate that a key is disabled. The default is gray.</value>
  </StatusBar.DisabledKeyIndicatorColor>
  <StatusBar.Dispatch>
    <inheritdoc />
  </StatusBar.Dispatch>
  <StatusBar.DisplayKeyboard>
    <summary>
      Enable the display of the keyboard state on the status bar.
    </summary>
    <remarks>
      The status bar refreshes the keyboard state itself, except for the insertion mode, which you must refresh by managing the StatusBar:InsertMode property.
      <note type="tip">You must call this method before calling StatusBar:Show().</note>
    </remarks>
  </StatusBar.DisplayKeyboard>
  <StatusBar.DisplayMemory>
    <summary>
      Enable the display of the virtual memory available, on the status bar. You must keep the display refreshed as necessary by calling StatusBar:RefreshMemoryDisplay().
    </summary>
  </StatusBar.DisplayMemory>
  <StatusBar.DisplayMessage>
    <summary>
      Enable the display of messages on the status bar.
    </summary>
  </StatusBar.DisplayMessage>
  <StatusBar.DisplayPosition>
    <summary>
      Enable the display of a coordinate pair on the status bar.
    </summary>
    <remarks>
      The pair is usually the mouse position, but you can supply any Pair object you like, such as a dimension or a point. You must keep the display refreshed as necessary by assigning pairs to the status bar's Position pseudo-variable.
      <note type="tip">You must call this method before calling StatusBar:Show().</note>
    </remarks>
  </StatusBar.DisplayPosition>
  <StatusBar.DisplayTime>
    <summary>
      Enable the digital clock display on the status bar.
    </summary>
  </StatusBar.DisplayTime>
  <StatusBar.Enable>
    <summary>
      Enable a status bar that was previously disabled.
    </summary>
    <remarks>
      Enabling a status bar allows it to generate events and to send the events to its owner window when the user manipulates the status bar. The dimming of disabled status bar is removed, and the status bar is restored to its normal appearance.
      By default, status bars are enabled until disabled, so there is no need to call this Enable() method unless StatusBar:Disable() was previously called.
    </remarks>
  </StatusBar.Enable>
  <StatusBar.ErrorMessageBeep>
    <summary>
      A logical value determining whether a beep is sounded by the error system when an error occurs. TRUE turns beeping on; FALSE turns it off.
    </summary>
    <value>A logical value determining whether a beep is sounded by the error system when an error occurs. TRUE turns beeping on; FALSE turns it off.</value>
  </StatusBar.ErrorMessageBeep>
  <StatusBar.ErrorText>
    <summary>
      A string representing an error message to be displayed on the status bar. This message takes priority over the StatusBar:ControlText and StatusBar:PermanentText messages.
    </summary>
    <value>A string representing an error message to be displayed on the status bar. This message takes priority over the StatusBar:ControlText and StatusBar:PermanentText messages.</value>
  </StatusBar.ErrorText>
  <StatusBar.GetItem>
    <exclude />

  </StatusBar.GetItem>
  <StatusBar.GetItemBoundingBox>
    <summary>
      Get the bounding box that describes the area of a status bar item.
    </summary>
    <param name="symItemName">The symbolic name of the status bar item whose bounding box will be returned. If omitted, the bounding box of the main message area will be returned.</param>
    <returns>
      The bounding box for the specified item.
    </returns>
  </StatusBar.GetItemBoundingBox>
  <StatusBar.GetTipText>
    <exclude />

  </StatusBar.GetTipText>
  <StatusBar.Handle>
    <summary>
      Return the handle for a status bar.
    </summary>
    <param name="nHandleType">
      The type of handle required. 0 is the only supported option and is the default if <paramref name="nHandle" /> is omitted.
    </param>
    <returns>
      A handle to the "window" (control), describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the window, which can then be used by Windows API calls.
    </remarks>
  </StatusBar.Handle>
  <StatusBar.Hide>
    <summary>
      Hide a status bar so it is not visible (until a subsequent call to StatusBar:Show()).
    </summary>
  </StatusBar.Hide>
  <StatusBar.HorizontalBorder>
    <summary>
      A numeric value representing the width of the horizontal border between the top or bottom edge of the status bar and its items.
    </summary>
    <value>A numeric value representing the width of the horizontal border between the top or bottom edge of the status bar and its items.</value>
  </StatusBar.HorizontalBorder>
  <StatusBar.InsertMode>
    <summary>
      A logical value indicating whether the program is in insert mode.
    </summary>
    <value>A logical value indicating whether the program is in insert mode.</value>
    <remarks>
      A logical value indicating whether the program is in insert mode. If insert mode is not enabled, NIL is returned.
      <note type="tip">The status bar figures out for itself the state of the other keys, such as CapsLock, but it has no automatic way of determining whether the program is in insertion mode or overwrite mode. Only the program knows that, and the program must set it.</note>
    </remarks>
  </StatusBar.InsertMode>
  <StatusBar.ItemBorder>
    <summary>
      A numeric value representing the width of the borders between the status bar items.
    </summary>
    <value>A numeric value representing the width of the borders between the status bar items.</value>
  </StatusBar.ItemBorder>
  <StatusBar.KeyIndicatorColor>
    <summary>
      The Color object that the status bar uses to indicate to the user that a key is in the on state.
    </summary>
    <value>The Color object that the status bar uses to indicate to the user that a key is in the on state.</value>
    <remarks>
      The Color object that the status bar uses to indicate to the user that a key is in the on state. For example, the imitation LEDs on the buttons that represent the state of the keyboard, such as NumLock. The default is green.
      <note type="tip">If you change StatusBar:KeyIndicatorColor, you must then invoke the StatusBar:Show() method for the change to take effect.</note>
    </remarks>
  </StatusBar.KeyIndicatorColor>
  <StatusBar.Length>
    <summary>
      A numeric value representing the number of characters in the message to be displayed on the status bar.
    </summary>
    <value>A numeric value representing the number of characters in the message to be displayed on the status bar.</value>
  </StatusBar.Length>
  <StatusBar.MenuText>
    <summary>
      A string representing a message associated with a menu selection to be displayed on the status bar.
    </summary>
    <value>A string representing a message associated with a menu selection to be displayed on the status bar.</value>
    <remarks>
      A string representing a message associated with a menu selection to be displayed on the status bar. This message takes priority over any other status bar messages, including StatusBar:ControlText, StatusBar:ErrorText, or StatusBar:PermanentText.
    </remarks>
  </StatusBar.MenuText>
  <StatusBar.ODDrawItem>
    <exclude />

  </StatusBar.ODDrawItem>
  <StatusBar.Origin>
    <summary>
      This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.
    </summary>
    <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.</value>
  </StatusBar.Origin>
  <StatusBar.Owner>
    <summary>
      This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.
    </summary>
    <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.</value>
  </StatusBar.Owner>
  <StatusBar.PermanentText>
    <summary>
      A string representing the default message to be displayed on the status bar
    </summary>
    <value>A string representing the default message to be displayed on the status bar</value>
    <remarks>
      A string representing the default message to be displayed on the status bar; it is stored whenever a higher priority message (including StatusBar:ControlText, StatusBar:ErrorText, or StatusBar:MenuText) takes precedence and redisplayed when no other messages take priority.
    </remarks>
  </StatusBar.PermanentText>
  <StatusBar.Position>
    <summary>
      A pair representing the coordinates to be shown in the status bar. The units you choose for coordinates are arbitrary.
    </summary>
    <value>A pair representing the coordinates to be shown in the status bar. The units you choose for coordinates are arbitrary.</value>
  </StatusBar.Position>
  <StatusBar.RefreshMemoryDisplay>
    <summary>
      Cause the status bar to bring the display of virtual memory up-to-date.
    </summary>
    <param name="kMemoryType">** missing parameter documentation **</param>
    <remarks>
      The status bar gets this information from the operating system. If you disabled the memory display, nothing happens.
    </remarks>
  </StatusBar.RefreshMemoryDisplay>
  <StatusBar.SetFocus>
    <summary>
      This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.
    </summary>
  </StatusBar.SetFocus>
  <StatusBar.SetIcon>
    <exclude />


  </StatusBar.SetIcon>
  <StatusBar.setmessage>
    <summary>
      Display a string in the main message area of the status bar.
    </summary>
    <param name="cMessage">The message to be displayed in the status bar.</param>
    <param name="nMode">The type of message to be displayed in the status bar.</param>
  </StatusBar.setmessage>
  <StatusBar.SetPair>
    <summary>
      Set a pair representing the coordinates to be shown in the status bar.
    </summary>
    <param name="oPoint">The point to set.</param>
    <remarks>
      The units you choose for coordinates are arbitrary.
    </remarks>
  </StatusBar.SetPair>
  <StatusBar.SetText>
    <summary>
      Set text for a status bar item.
    </summary>
    <param name="cText">The text to set.</param>
    <param name="symItemName">The name of the status bar item.</param>
  </StatusBar.SetText>
  <StatusBar.SetTipText>
    <exclude />

  </StatusBar.SetTipText>
  <StatusBar.SetValue>
    <exclude />

  </StatusBar.SetValue>
  <StatusBar.Show>
    <summary>
      Display a status bar so it is visible.
    </summary>
    <remarks>
      StatusBar:Show() is also usually called to redisplay a status bar that was hidden with the StatusBar:Hide() method.
    </remarks>
  </StatusBar.Show>
  <StatusBar.Size>
    <summary>
      This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.
    </summary>
    <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to the status bar.</value>
  </StatusBar.Size>
  <StatusBar.TextValue>
    <summary>
      A string representing the value held in the status bar.
    </summary>
    <value>A string representing the value held in the status bar.</value>
    <remarks>
      A string representing the value held in the status bar. For example, the value can be "Jones" or "$14,683.00".
      Note that the string is formatted according to the picture clause help in the field specification of the status bar; in turn, status bars linked to a data server inherit the field specification—and hence picture—from the field of the server.
    </remarks>
  </StatusBar.TextValue>
  <StatusBar.TimeOut>
    <summary>
      A numeric value indicating the number of seconds a nonpermanent message is displayed on the status bar.
    </summary>
    <value>A numeric value indicating the number of seconds a nonpermanent message is displayed on the status bar.</value>
  </StatusBar.TimeOut>
  <StatusBar.Timer>
    <exclude />
  </StatusBar.Timer>
  <StatusBar.Transient>
    <summary>
      A string representing an error message to be displayed on the status bar. This message takes priority over the StatusBar:ControlText and StatusBar:PermanentText messages.
    </summary>
    <value>A string representing an error message to be displayed on the status bar. This message takes priority over the StatusBar:ControlText and StatusBar:PermanentText messages.</value>
  </StatusBar.Transient>
  <StatusBar.VerticalBorder>
    <summary>
      A numeric value representing the height of the vertical border between the left or right edge of the status bar and its items.
    </summary>
    <value>A numeric value representing the height of the vertical border between the left or right edge of the status bar and its items.</value>
  </StatusBar.VerticalBorder>
  <StatusBarItem>
    <summary>
      Create a status bar item.
    </summary>
    <remarks>
      A status bar item is an object that can be added to a status bar. It is displayed as a rectangular section of the status bar and can be used to display text or graphical information. Simple status bar items that display messages, pairs of numbers, keyboard states, and memory information can be added automatically by calling the appropriate methods of the StatusBar class; this class is designed to allow the addition of user-defined items.
    </remarks>
  </StatusBarItem>
  <StatusBarItem.ctor>
    <summary>
      Construct a status bar item.
    </summary>
    <param name="symName">Name of the StatusbarItem</param>
    <param name="nWidth">Width of the StatusbarItem in pixels</param>
    <param name="kStyle">
      Style of the StatusbarItem
      One of:
      SBITEMFLAT
      SBITEMRAISED
      SBITEMSUNKEN
    </param>
    <param name="oIcon">Optional Icon object to display</param>
  </StatusBarItem.ctor>
  <StatusBarItem.Icon>
    <summary>
      The icon of the status bar item.
    </summary>
    <value>The icon of the status bar item.</value>
  </StatusBarItem.Icon>
  <StatusBarItem.NameSym>
    <summary>
      The symbolic name of the status bar item.
    </summary>
    <value>The symbolic name of the status bar item.</value>
  </StatusBarItem.NameSym>
  <StatusBarItem.Style>
    <summary>
      A constant determining the three-dimensional appearance of the status bar item:
    </summary>
    <value>A constant determining the three-dimensional appearance of the status bar item:</value>
    <remarks>
      One of the following constants determining the three-dimensional appearance of the status bar item:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>SBITEMFLAT</term>
          <description>Creates a status bar item with a flat appearance</description>
        </item>
        <item>
          <term>SBITEMSUNKEN</term>
          <description>Creates a status bar item with a sunken appearance</description>
        </item>
        <item>
          <term>SBITEMRAISED</term>
          <description>Creates a status bar item with a raised appearance</description>
        </item>
      </list>
    </remarks>
  </StatusBarItem.Style>
  <StatusBarItem.Value>
    <exclude />
  </StatusBarItem.Value>
  <StatusBarItem.Width>
    <summary>
      A numeric value that represents the width of the status bar item.
    </summary>
    <value>A numeric value that represents the width of the status bar item.</value>
  </StatusBarItem.Width>
  <StatusBarKeyItem>
    <summary>
      Create a status bar item to display CapsLock, Numlock and Insert keys
    </summary>
  </StatusBarKeyItem>
  <StatusBarKeyItem.ctor>
    <summary>
      Construct a status bar item.
    </summary>
    <param name="symName">Name of the StatusbarItem</param>
    <param name="nWidth">Width of the StatusbarItem in pixels</param>
    <param name="kStyle">
      Style of the StatusbarItem
      One of:
      SBITEMFLAT
      SBITEMRAISED
      SBITEMSUNKEN
    </param>
    <param name="oIcon">Optional Icon object to display</param>
  </StatusBarKeyItem.ctor>
  <StatusBarKeyItem.ODDrawItem>
    <exclude />

  </StatusBarKeyItem.ODDrawItem>
  <StdSocket>
    <exclude />
  </StdSocket>
  <StdSocket.ctor>
    <inheritdoc />
  </StdSocket.ctor>
  <StdSocket.InternetStatus>
    <inheritdoc />
  </StdSocket.InternetStatus>
  <Stream>
    <summary>
      A class representing streams in the ActiveXControl:StreamIn() and ActiveXControl:StreamOut() methods.
    </summary>
    <remarks>
      <note type="tip">Stream objects are automatically instantiated by the OLE runtime.</note>
      A Stream object is automatically instantiated by the OLE runtime system and passed as a parameter to the ActiveXControl:StreamIn() and ActiveXControl:StreamOut() methods. The Stream object wraps an OLE stream, allowing you to write to and read from the stream.
    </remarks>
  </Stream>
  <Stream.ctor>
    <summary>
      Construct a Stream object instance.
    </summary>
    <param name="pStream">Pointer to an OLE stream.</param>
  </Stream.ctor>
  <Stream.Read>
    <summary>
      Read the next USUAL value from a stream.
    </summary>
    <returns>
      The next value (type USUAL) in the stream. The USUAL can hold any X# data, including nested arrays but not objects.
    </returns>
    <remarks>
      Stream:Read() can be used in ActiveXControl:StreamIn handlers to read USUAL values from the stream. You can use subsequent calls to Stream:Read() to read in as many values as have been saved to the stream by previous calls to Stream:Write(). Stream:Read() and Stream:Write() operations should be balanced and in the same order.
      For further details, see Creating OLE Servers in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
    </remarks>
    <example>
      This is from the StreamIn() method of the Calendar ActiveX sample that is accessible from the Samples tab page of the Application Gallery:
      <code language="X#">
        method StreamIn(oStream) class CalOCX
        local u as usual
        u := oStream:Read()
        if IsDate(u)
        curDate := u
        endif
      </code>
    </example>
  </Stream.Read>
  <Stream.Write>
    <summary>
      Write a USUAL value into a stream.
    </summary>
    <param name="uValue">The USUAL value, which is written into the stream.</param>
    <returns>
      TRUE, if the write operation was successful; otherwise, FALSE.
    </returns>
    <remarks>
      Stream:Write() can be used in ActiveXControl:StreamOut handlers to write USUAL values into the stream. You can use subsequent calls to Stream:Write() to write multiple values subsequently. Stream:Read() and Stream:Write() operations should be balanced and in the same order.
      For further details, see Creating OLE Servers in the "How To" section of the online help, as well as the sample applications that are accessible from the Samples tab page of the Application Gallery.
    </remarks>
    <example>
      This is from the StreamOut() method of the Calendar ActiveX sample that is accessible from the Samples tab page of the Application Gallery:
      <code language="X#">
        method StreamOut(oStream) class CalOCX
        oStream:Write(oOCXWindow:CurrentDate)
        return
      </code>
    </example>
  </Stream.Write>
  <StringFS>
    <summary>
      Create a string field specification, which holds string data type information.
    </summary>
  </StringFS>
  <StringFS.ctor>
    <summary>
      Construct a string field specification.
    </summary>
    <param name="oHLName">The hyperlabel that contains the field name and other attributes (i.e., caption, description, and help context) to be used to create the new string field specification.</param>
    <param name="uLength">The length of the field. If not specified, the default is 10.</param>
  </StringFS.ctor>
  <strucPictureFuncFlags>
    <exclude />
  </strucPictureFuncFlags>
  <SysLink>
    <summary>
      Create a SysLink control.
    </summary>
    <remarks>
      The SysLink control provides hyperlink capabilities when running under XP visual themes.
      <note type="tip">
        This control is dependent on version 6 or greater of the COMCTL32.DLL and WinXP Theams.
        When XP themes are not available, such as when running on Windows 2000 or running the application on XP in "classic" mode, the SysLink control displays the full text assigned to it - any hyperlink references are included as literal text. It is suggested that the programmer should test for XP theme support, see IsThemeEnabled(), to determine what text should be assigned to the SysLink control
        For this reason it is recomended that it is called in this way -
        <code language="X#">
          IF IsThemeEnabled()
          s := "Visit &lt;A HREF="+_chr(34)+;
          "http://www.grafxsoft.com"+_chr(34)+"&gt;GrafX&lt;/A&gt; and &lt;A HREF="+;
          _CHR(34)+"http://www.cavo.com"+_Chr(34)+"&gt;X#&lt;/A&gt; on the web!"
          ELSE
          s := "Visit http://www.grafxsoft.com and http://www.cavo.com"+;
          " on the web!"
          ENDIF
        </code>
        The difference between the HyperLink and the SysLink classes is in the way that the text is used.
        In a HyperLink control, ALL of the text is passed as the hyperlink where as in the SysLink control you can mix display text and hyperlink text.
      </note>
    </remarks>
    <example>
      For an example of this , see the Help About screen in the Standard MDI Application.
    </example>
  </SysLink>
  <SysLink.ctor>
    <summary>
      Construct a SysLink control.
      <br />Important! This method is used internally by X#. Normally, it should not be called in your application code.
    </summary>
    <param name="oOwner">The window that owns the SysLink control.</param>
    <param name="xID">The unique ID between 1 and 8000 of the SysLink control.</param>
    <param name="oPoint">The Point object that locates the control.</param>
    <param name="oDimension">The Dimension that sets the size of the control.</param>
    <param name="cText">The text (including HTML tags) to be displayed.</param>
    <param name="lDataAware">TRUE sets the control to be Data-Aware, FALSE sets this off. The Default is TRUE.</param>
  </SysLink.ctor>
  <SysLinkSelectEvent>
    <summary>
      Provide information about an event that gets generated when a SysLink control is selected
    </summary>
  </SysLinkSelectEvent>
  <SysLinkSelectEvent.ctor>
    <summary>Construct a ListViewMouseEvent object.</summary>
    <param name="oControlNotifyEvent">The ControlNotifyEvent that occurred when the event happened.</param>
  </SysLinkSelectEvent.ctor>
  <SysLinkSelectEvent.ID>
    <exclude />
  </SysLinkSelectEvent.ID>
  <SysLinkSelectEvent.LinkIndex>
    <exclude />
  </SysLinkSelectEvent.LinkIndex>
  <SysLinkSelectEvent.URL>
    <exclude />
  </SysLinkSelectEvent.URL>
  <SystemMenu>
    <summary>
      Create a system menu.
    </summary>
    <remarks>
      System menus are used to provide a series of standard operations, such as moving, closing, and resizing windows. Different GUI conventions dictate what items should be added to the system menu.
      An application window can have a system menu by calling AppWindow:EnableSystemMenu(). Using the Window:MenuCommand() event handler, the system menu can be manipulated in the same way as a menu.
      To access a window's system menu, you must first enable the system menu with a call to AppWindow:EnableSystemMenu(). You can then use the system menu it returns.
    </remarks>
    <example>
      The following example adds an About item to a system menu:
      <code language="X#">
        oSysMenu := oMyWin:EnableSystemMenu()
        oSysMenu:AppendItem(MENUSEPARATOR)
        oSysMenu:AppendItem(IDM_ABOUT,"About...")
        oSysMenu:RegisterItem(IDM_ABOUT,HyperLabel{#About})
      </code>
    </example>
  </SystemMenu>
  <SystemMenu.ctor>
    <summary>
      Construct a system menu.
      <br />Important! This method is used internally by X#. Normally, it should not be called in your application code. To create a system menu object, store the return value of the AppWindow:EnableSystemMenu() method.
    </summary>
    <param name="oOwner">
      The window that owns the system menu.
      The resource ID of the system menu. If not specified, the system creates an empty menu.
    </param>
  </SystemMenu.ctor>
  <SystemMenu.Destroy>
    <exclude />
  </SystemMenu.Destroy>
  <TabControl>
    <summary>
      Create a tab control.
    </summary>
    <remarks>
      A tab control is a control that manages multiple pages (modeless dialog windows) and can be compared to dividers in a notebook. By using a tab control, an application can define multiple pages for the same area of a dialog window or data window. Each page is displayed when the user selects the corresponding tab.
    </remarks>
  </TabControl>
  <TabControl.ctor>
    <summary>
      Construct a tab control.
    </summary>
    <param name="oOwner">The window that owns the tab control.</param>
    <param name="xID">The unique ID between 1 and 8000 of the tab control.</param>
    <param name="nResourceID">The resource ID of the tab control.</param>
    <param name="oPoint">The origin of the tab control, in canvas coordinates.</param>
    <param name="oDimension">The dimension of the tab control, in canvas coordinates.</param>
    <param name="kStyle">The style of the tab control.</param>
  </TabControl.ctor>
  <TabControl.AddTipText>
    <summary>
      Add a string to be displayed as tip text for a tab.
    </summary>
    <param name="symTabName">The symbolic name of the tab to which you want to add the text.</param>
    <param name="cText">The text to add.</param>
  </TabControl.AddTipText>
  <TabControl.AppendTab>
    <summary>
      Add a new tab and tab page at the end of a tab control.
    </summary>
    <param name="symTabName">The symbolic name of the new tab.</param>
    <param name="cCaption">The caption of the new tab.</param>
    <param name="xPage">The modeless dialog window to act as the page for this tab or the symbolic name of the class to use for the tab.</param>
    <param name="nImage">The index of the image in the tab control's image list to display in the new tab.</param>
    <returns>
      TRUE if the tab was added successfully; otherwise FALSE.
    </returns>
  </TabControl.AppendTab>
  <TabControl.AutoSize>
    <summary>
      A logical value which lets the tab control automatically resize itself to accommodate the size of largest tab page. The default is FALSE.
    </summary>
    <value>A logical value which lets the tab control automatically resize itself to accommodate the size of largest tab page. The default is FALSE.</value>
  </TabControl.AutoSize>
  <TabControl.ChangeTipText>
    <summary>
      Change the current tip text for a tab.
    </summary>
    <param name="symTabName">The symbolic name of the tab whose tip text you want to change.</param>
    <param name="cText">The text to replace the current tip text.</param>
    <returns>
      TRUE if the text could be changed; otherwise FALSE.
    </returns>
  </TabControl.ChangeTipText>
  <TabControl.CreatePageInstance>
    <summary>
      Dynamically create a tab page.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="symPageClass">Classname of the page to create</param>
    <param name="symTabName">Symbolic Name of the tab to create</param>
    <returns>
      New Page Object
    </returns>
  </TabControl.CreatePageInstance>
  <TabControl.CurrentPage>
    <summary>
      The currently displayed tab control page.
    </summary>
    <value>The currently displayed tab control page.</value>
  </TabControl.CurrentPage>
  <TabControl.DeleteAllTabs>
    <summary>
      Remove all the tabs and their corresponding pages in the tab control.
    </summary>
    <returns>
      TRUE if all tabs could be deleted; otherwise FALSE.
    </returns>
  </TabControl.DeleteAllTabs>
  <TabControl.DeleteTab>
    <summary>
      Remove a tab and page from the tab control.
    </summary>
    <param name="symTabName">The symbolic name of the tab to delete.</param>
    <returns>
      TRUE if the tab could be deleted; otherwise FALSE.
    </returns>
  </TabControl.DeleteTab>
  <TabControl.Destroy>
    <summary>
      Provide a method to de-instantiate a Tab Control object.
    </summary>
    <remarks>
      This method can be used when a Tab Control object is no longer needed. Tab Control:Destroy() de-instantiates the Tab Control object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </TabControl.Destroy>
  <TabControl.FocusNextPage>
    <exclude />
  </TabControl.FocusNextPage>
  <TabControl.FocusPreviousPage>
    <exclude />
  </TabControl.FocusPreviousPage>
  <TabControl.FocusTab>
    <exclude />

  </TabControl.FocusTab>
  <TabControl.GetCaption>
    <summary>
      Return the current caption for a tab.
    </summary>
    <param name="symTabName">The symbolic name of the tab whose caption you want to obtain.</param>
    <returns>
      The current caption of the specified tab.
    </returns>
  </TabControl.GetCaption>
  <TabControl.GetPage>
    <exclude />

  </TabControl.GetPage>
  <TabControl.GetPageSymbol>
    <exclude />

  </TabControl.GetPageSymbol>
  <TabControl.GetTabBoundingBox>
    <summary>
      Get the bounding box representing the area that a tab occupies.
    </summary>
    <param name="symTabName">The symbolic name of the tab whose bounding box you want to obtain.</param>
    <returns>
      The bounding box that the specified tab occupies.
    </returns>
  </TabControl.GetTabBoundingBox>
  <TabControl.GetTabImage>
    <summary>
      Return the current image for a tab.
    </summary>
    <param name="symTabName">The symbolic name of the tab whose image you want to obtain.</param>
    <returns>
      The current image number of the specified tab.
    </returns>
  </TabControl.GetTabImage>
  <TabControl.GetTabPage>
    <summary>
      Retrieve a specified tab page.
    </summary>
    <param name="xSymbolOrPosition">Specifies the tab page's symbol or the numeric position of the tab page.</param>
    <returns>
      The modeless dialog window object that represents the specified tab page.
    </returns>
  </TabControl.GetTabPage>
  <TabControl.GetTipText>
    <summary>
      Return the current tip text for a tab.
    </summary>
    <param name="symTabName">The symbolic name of the tab whose tip text you want to obtain.</param>
    <returns>
      The current tip text of the specified tab.
    </returns>
  </TabControl.GetTipText>
  <TabControl.Hide>
    <summary>
      To hide the current tab page.
    </summary>
  </TabControl.Hide>
  <TabControl.ImageList>
    <summary>
      The image list for the tab control.
    </summary>
    <value>The image list for the tab control.</value>
  </TabControl.ImageList>
  <TabControl.InsertTab>
    <summary>
      Insert a new tab and tab page at a particular position in the tab control.
    </summary>
    <param name="nPosition">The numeric position of the new tab.</param>
    <param name="symTabName">The symbolic name of the new tab.</param>
    <param name="cCaption">The caption of the new tab.</param>
    <param name="xPage">The modeless dialog window to act as the page for this tab or the symbolic name of the class to use for the tab.</param>
    <param name="nImage">The index of the image in the tab control's image list to display in the new tab.</param>
    <returns>
      TRUE if the tab was added successfully; otherwise FALSE.
    </returns>
  </TabControl.InsertTab>
  <TabControl.IsTabPage>
    <exclude />

  </TabControl.IsTabPage>
  <TabControl.Move>
    <inheritdoc />
  </TabControl.Move>
  <TabControl.PadTabs>
    <summary>
      Pad a tab's label and icon with empty space.
    </summary>
    <param name="dwWidth">The amount of horizontal padding (in pixels).</param>
    <param name="dwHeight">The amount of vertical padding (in pixels).</param>
  </TabControl.PadTabs>
  <TabControl.Pages>
    <exclude />
  </TabControl.Pages>
  <TabControl.RemoveTabImage>
    <summary>
      Remove an image from the tab control's image list.
    </summary>
    <param name="nImageIndex">The index in the tab control's image list of the image you want to remove.</param>
    <returns>
      TRUE if the image was removed; otherwise, FALSE.
    </returns>
  </TabControl.RemoveTabImage>
  <TabControl.RemoveTipText>
    <summary>
      Remove the current tip text for a tab.
    </summary>
    <param name="symTabName">The symbolic name of the tab whose tip text you want to remove.</param>
    <returns>
      TRUE if the text could be removed; otherwise FALSE.
    </returns>
  </TabControl.RemoveTipText>
  <TabControl.Resize>
    <inheritdoc />
  </TabControl.Resize>
  <TabControl.RowCount>
    <summary>
      A numeric value representing the number of rows of tabs currently displayed in the tab control.
    </summary>
    <value>A numeric value representing the number of rows of tabs currently displayed in the tab control.</value>
  </TabControl.RowCount>
  <TabControl.SelectedTab>
    <summary>
      A symbolic name representing the currently selected tab in the tab control.
    </summary>
    <value>A symbolic name representing the currently selected tab in the tab control.</value>
  </TabControl.SelectedTab>
  <TabControl.SelectedTabPage>
    <summary>
      The modeless dialog window object representing the currently selected tab page in the tab control.
    </summary>
    <value>The modeless dialog window object representing the currently selected tab page in the tab control.</value>
  </TabControl.SelectedTabPage>
  <TabControl.SelectTab>
    <summary>
      Select a tab and display its page.
    </summary>
    <param name="symTabName">The symbolic name of the tab you want to select.</param>
  </TabControl.SelectTab>
  <TabControl.SetCaption>
    <summary>
      Set a new caption for a tab.
    </summary>
    <param name="symTabName">The symbolic name of the tab whose caption you want to obtain.</param>
    <param name="cCaption">The new caption for the Tab</param>
    <returns>
      TRUE if the caption could be changed; otherwise FALSE
    </returns>
  </TabControl.SetCaption>
  <TabControl.SetTabImage>
    <summary>
      Dynamically change the image (index) of a tab page.
    </summary>
    <param name="symTabName">The symbol of the page on which the image index will be changed.</param>
    <param name="nImageIndex">The index into the image list.</param>
    <returns>
      The new index into the image list.
    </returns>
  </TabControl.SetTabImage>
  <TabControl.SetTipText>
    <summary>
      Change the current tip text for a tab.
    </summary>
    <param name="symTabName">The symbolic name of the tab whose tip text you want to change.</param>
    <param name="cText">The text to replace the current tip text.</param>
    <returns>
      TRUE if the text could be changed; otherwise FALSE.
    </returns>
  </TabControl.SetTipText>
  <TabControl.Show>
    <exclude />
  </TabControl.Show>
  <TabControl.TabCaption>
    <exclude />
  </TabControl.TabCaption>
  <TabControl.TabCount>
    <summary>
      A numeric value representing the total number of tabs in the tab control.
    </summary>
    <value>A numeric value representing the total number of tabs in the tab control.</value>
  </TabControl.TabCount>
  <TextBox>
    <summary>
      Present the user with a text message box.
    </summary>
    <remarks>
      A message box is a small window that displays a caption, a message, an icon (chosen from a predefined set of icons), and push buttons (selected from a variety of predefined combinations). It provides an easy alternative to the dialog window when all you require from the user is a simple response.
      Message boxes require no sizing, positioning, or event handling. In addition, message boxes can be application modal (no processing can continue in the application until the user has acknowledged the message box), or it can be modal in relation to its owner window (no processing can continue in its owner window until the user has acknowledged the message box).
    </remarks>
    <example>
      The following example handles a QueryClose event:
      <code language="X#">
        METHOD QueryClose(oEvent) CLASS TopAppWindow
        oTB := TextBox{SELF, "Quit", "Do you really want to quit?"}
        oTB:TYPE := BOXICONQUESTIONMARK + BUTTONYESNO
        IF (oTB:Show() = BOXREPLYYES)
        RETURN TRUE // Quit application.
        ELSE
        RETURN FALSE
        // Don't quit the application.
        ENDIF
      </code>
    </example>
  </TextBox>
  <TextBox.ctor>
    <summary>
      Create a message box.
    </summary>
    <param name="uParent">The window that owns the message box. If omitted, the text box is application modal (that is, the application is suspended until the user acknowledges the text box).</param>
    <param name="uCaption">The text to be displayed in the title bar of the message boxor the hyperlabel containing a caption and description for the text box. If omitted, the default is NULL_STRING.</param>
    <param name="uText">
      The information to be printed in the message box. . If omitted, the default is NULL_STRING.
    </param>
    <param name="nType">
      The text box type. Valid types include the following button combinations and/or icons:
      Group 1: buttons
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Button(s)</description>
        </listheader>
        <item>
          <term>
            BOXABORTRETRYIGNORE
          </term>
          <description>
            Abort, Retry, and Ignore
          </description>
        </item>
        <item>
          <term>
            BUTTONOKAY
          </term>
          <description>OK (This is the default.)</description>
        </item>
        <item>
          <term>
            BUTTONOKAYCANCEL
          </term>
          <description>OK and Cancel</description>
        </item>
        <item>
          <term>
            BUTTONRETRYCANCEL
          </term>
          <description>Retry and Cancel</description>
        </item>
        <item>
          <term>
            BUTTONYESNO
          </term>
          <description>Yes and No</description>
        </item>
        <item>
          <term>BUTTONYESNOCANCEL   </term>
          <description>Yes, No, and Cancel</description>
        </item>
      </list>

      Group 2: Standard Icons
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Icon</description>
        </listheader>

        <item>
          <term>
            BOXICONASTERISK
          </term>
          <description>An icon consisting of a lowercase 'i' within a circle</description>
        </item>
        <item>
          <term>
            BOXICONEXCLAMATION
          </term>
          <description>An exclamation mark</description>
        </item>
        <item>
          <term>BOXICONHAND         </term>
          <description>A warning icon</description>
        </item>
        <item>
          <term>BOXICONQUESTIONMARK </term>
          <description>A question mark</description>
        </item>
      </list>
    </param>
  </TextBox.ctor>
  <TextBox.Beep>
    <summary>
      A logical value indicating whether to use a system default beep when displaying the text box. TRUE indicates that there will be a beep; FALSE indicates that there will be no beep.
    </summary>
    <value>A logical value indicating whether to use a system default beep when displaying the text box. TRUE indicates that there will be a beep; FALSE indicates that there will be no beep.</value>
  </TextBox.Beep>
  <TextBox.Caption>
    <summary>
      A string value representing the TextBox caption.
    </summary>
    <value>A string value representing the TextBox caption.</value>
  </TextBox.Caption>
  <TextBox.Message>
    <summary>
      A string value representing the TextBox message.
    </summary>
    <value>A string value representing the TextBox message.</value>
  </TextBox.Message>
  <TextBox.Show>
    <summary>
      Display this message box and return a value indicating how it was closed.
    </summary>
    <returns>
      The button selected by the user.
      <para>The possible values are:</para><list type="table">
        <listheader>
          <term>Constant</term>
          <description>Button</description>
        </listheader>
        <item>
          <term>BOXREPLYABORT</term>
          <description>Abort</description>
        </item>
        <item>
          <term>BOXREPLYCANCEL</term>
          <description>Cancel</description>
        </item>
        <item>
          <term>BOXREPLYIGNORE</term>
          <description>Ignore</description>
        </item>
        <item>
          <term>BOXREPLYNO</term>
          <description>No</description>
        </item>
        <item>
          <term>BOXREPLYOKAY</term>
          <description>OK</description>
        </item>
        <item>
          <term>BOXREPLYRETRY</term>
          <description>Retry</description>
        </item>
        <item>
          <term>BOXREPLYYES</term>
          <description>Yes</description>
        </item>
      </list>
    </returns>
  </TextBox.Show>
  <TextBox.Type>
    <summary>
      A constant or combination of constants that indicates which push buttons and/or icons are displayed in the message box
    </summary>
    <value>A constant or combination of constants that indicates which push buttons and/or icons are displayed in the message box</value>
    <remarks>
      A constant or combination of constants that indicates which push buttons and/or icons are displayed in the message box. One item from each of these groups is added together to create the combination that you choose.
      <para>Group 1: Standard Button Combinations</para><list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>BOXABORTRETRYIGNORE</term>
          <description>Abort, Retry, and Ignore</description>
        </item>
        <item>
          <term>BUTTONOKAY</term>
          <description>
            OK (This is the <b>default</b>.)
          </description>
        </item>
        <item>
          <term>BUTTONOKAYCANCEL</term>
          <description>OK and Cancel</description>
        </item>
        <item>
          <term>BUTTONRETRYCANCEL</term>
          <description>Retry and Cancel</description>
        </item>
        <item>
          <term>BUTTONYESNO</term>
          <description>Yes and No</description>
        </item>
        <item>
          <term>BUTTONYESNOCANCEL</term>
          <description>Yes, No, and Cancel</description>
        </item>
      </list><para>Group 2: Standard Icons</para><list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>BOXICONASTERISK</term>
          <description>An icon consisting of a lowercase "i" within a circle</description>
        </item>
        <item>
          <term>BOXICONEXCLAMATION</term>
          <description>An exclamation mark</description>
        </item>
        <item>
          <term>BOXICONHAND</term>
          <description>A warning icon</description>
        </item>
        <item>
          <term>BOXICONQUESTIONMARK</term>
          <description>A question mark</description>
        </item>
      </list>
    </remarks>
    <example>
      This example creates a text box with an exclamation mark icon and the OK and Cancel buttons:
      <code language="X#">oTextBox:Type := BOXICONEXCLAMATION + BUTTONOKAYCANCEL</code>
    </example>
  </TextBox.Type>
  <TextControl>
    <summary>
      Provide the base class from which all X# controls are subclassed.
    </summary>
    <remarks>
      Text controls in dialog windows are destroyed when the window is closed. Therefore, it is recommended that you save the text in a buffer if it is to be used after calling DialogWindow:EndDialog().
    </remarks>
    <example>
      This example changes the color of a button's name to red when the button is clicked:
      <code language="X#">
        METHOD ButtonClick(aControlEvent) CLASS TopAppWindow
        oPB := oControlEvent:Control
        oPB:TextColor := Color{COLORRED}
      </code>
    </example>
  </TextControl>
  <TextControl.ctor>
    <summary>
      Create a text control.
    </summary>
    <param name="oOwner">The window that owns the text control.</param>
    <param name="xId">The unique ID between 1 and 8000 of the text control.</param>
    <param name="oPoint">The origin of the text control in canvas coordinates.</param>
    <param name="oDimension">The dimension of the text control in canvas coordinates.</param>
    <param name="cRegclass">The window class name (e.g., 'ListBox') of the control.</param>
    <param name="kStyle">
      Constant representing the window style of the control, specified either by a X# style constant or a Windows API style constant. Styles can be combined using the _Or() operator.
    </param>
    <remarks>
      <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular Windows API constant.</note>
    </remarks>
    <param name="lDataAware">
      A logical value specifying whether the text control is data aware.
      For detailed information, see TextControl:Init() and the corresponding Init() method topics for the Button, CheckBox, ComboBox, DateTimePicker, Edit, FixedText, GroupBox, HotKeyEdit, IPAddress, ListBox, ListView, MonthCalendar, MultiLineEdit, PushButton, RadioButton, RadioButtonGroup, RichEdit, and SingleLineEdit subclasses in the online help.
    </param>
    <param name="nResourceID">The resource ID of the text control.</param>
  </TextControl.ctor>
  <TextControl.Caption>
    <summary>
      The string representing the caption of the text control.
    </summary>
    <value>The string representing the caption of the text control.</value>
  </TextControl.Caption>
  <TextControl.ControlFont>
    <summary>
      The font used to draw the text in the control.
    </summary>
    <value>The font used to draw the text in the control.</value>
  </TextControl.ControlFont>
  <TextControl.Create>
    <inheritdoc />
  </TextControl.Create>
  <TextControl.CurrentText>
    <summary>
      A string representing the text currently displayed in a text control.  For edit controls, including the edit box associated with simple and drop-down combo boxes, it contains the text currently appearing in the edit box. For fixed icon and group box controls, TextControl:CurrentText contains NULL_STRING.
    </summary>
    <value>A string representing the text currently displayed in a text control.  For edit controls, including the edit box associated with simple and drop-down combo boxes, it contains the text currently appearing in the edit box. For fixed icon and group box controls, TextControl:CurrentText contains NULL_STRING.</value>
  </TextControl.CurrentText>
  <TextControl.Destroy>
    <summary>
      Provide a method to de-instantiate any TextControl.Destroy object.
    </summary>
    <remarks>
      This method can be used when a TextControl.Destroy object is no longer needed. TextControl.Destroy:Destroy() de-instantiates the Control object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </TextControl.Destroy>
  <TextControl.EnableAutoComplete>
    <exclude />

  </TextControl.EnableAutoComplete>
  <TextControl.Font>
    <summary>
      Change the current font of the text control.
    </summary>
    <param name="oNewFont">The font used to draw the text control.</param>
    <param name="lRescal">TRUE rescales the control according to the new font size. FALSE does not allow rescaling. If omitted, the default is FALSE.</param>
    <returns>
      The previous font used by the text control.
    </returns>
  </TextControl.Font>
  <TextControl.Font>
    <summary>
      The font used to draw the text in the control.

      This Access/Assign was called Font (without the underscore) in previous versions of X#. it has been renamed to avoid name collision with the TextControl:Font() method
    </summary>
    <value>
      The font used to draw the text in the control.

      This Access/Assign was called Font (without the underscore) in previous versions of X#. it has been renamed to avoid name collision with the TextControl:Font() method
    </value>
  </TextControl.Font>
  <TextControl.Ime>
    <summary>
      Return and optionally set whether Input Method Editor is enabled for this text control.
    </summary>
    <param name="symIme">TRUE enables the Input Method Editor for this text control; FALSE disables it.</param>
    <returns>
      If &lt;symIme&gt; is not specified, TextControl:IME() returns the current setting. If &lt;lEnable&gt; is specified, the previous setting is returned.
    </returns>
    <remarks>
      This method applies to International versions of Windows.
    </remarks>
  </TextControl.Ime>
  <TextControl.Length>
    <summary>
      A numeric value representing the number of characters in the control.
    </summary>
    <value>A numeric value representing the number of characters in the control.</value>
  </TextControl.Length>
  <TextControl.Modified>
    <summary>
      A logical value that is set to TRUE when a standard edit control or editable combo box is in the process of being modified. When the editing is completed and focus shifts to another control, TextControl:Modified is reset to FALSE. TextControl:Modified is always FALSE for non-editable controls (fixed icon, fixed text, or group box).
    </summary>
    <value>A logical value that is set to TRUE when a standard edit control or editable combo box is in the process of being modified. When the editing is completed and focus shifts to another control, TextControl:Modified is reset to FALSE. TextControl:Modified is always FALSE for non-editable controls (fixed icon, fixed text, or group box).</value>
  </TextControl.Modified>
  <TextControl.RemoveEditBalloonTip>
    <summary>
      Removes the current BallonTip from the Edit control that has inherited from this class.
    </summary>
    <param name="hControl">The optional handle of the edit control to remove the BalloonTip from. The default is the control that the method is called against.</param>
  </TextControl.RemoveEditBalloonTip>
  <TextControl.SetCueBanner>
    <summary>
      Add a cue banner to the Edit control that has inherited from this class.
    </summary>
    <param name="cText">The text displayed as the cue.</param>
    <param name="hControl">The optional handle of the edit control to add the cue too. The default is the control that the method is called against.</param>
    <remarks>
      A cue banner is text displayed in an edit control, usually indicating the purpose of the control or prompting for the type of input required. When the control gets focus or has text in it the cue is no longer displayed.
    </remarks>
  </TextControl.SetCueBanner>
  <TextControl.ShowEditBalloonTip>
    <summary>
      Add a BallonTip to the Edit control that has inherited from this class.
    </summary>
    <param name="cTitle">The title displayed in the tip.</param>
    <param name="cText">The text displayed in the tip.</param>
    <param name="dwIcon">The icon to use in the tip.</param>
    <param name="hControl">The optional handle of the edit control to add the BalloonTip too. The default is the control that the method is called against.</param>
    <remarks>
      dwIcon can be:
      <list type="table">
        <listheader>
          <term>Value</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>TTI_ERROR</term>
          <description>Use the error icon.</description>
        </item>
        <item>
          <term>TTI_INFO</term>
          <description>Use the information icon.</description>
        </item>
        <item>
          <term>TTI_NONE</term>
          <description>Use no icon.</description>
        </item>
        <item>
          <term>TTI_WARNING</term>
          <description>Use the warning icon</description>
        </item>
      </list>
      A balloon tip can be displayed, pointing to an edit control.

      The tip always points to the current cursor position within the control, and is dismissed by either clicking on it, by moving focus to a control other than the control the tip is assigned to, or by typing into the text box. Showing the tip automatically sets focus to the control at the last cursor position. A form can not show more than one tip at a time, and if the tip is repeatedly shown, the previous tip is destroyed first. Tips never get focus, and there is no message sent when the tip is dismissed. If the tip is not dismissed before the system timeout value for tool tips is reached, it automatically disappears leaving focus on the control.
    </remarks>
  </TextControl.ShowEditBalloonTip>
  <TextControl.TextColor>
    <summary>
      The color used to draw the text in the control. (Refer to the Color:Init() method for details on specifying a color object.)
    </summary>
    <value>The color used to draw the text in the control. (Refer to the Color:Init() method for details on specifying a color object.)</value>
  </TextControl.TextColor>
  <TextControl.TextValue>
    <summary>
      A string representing the value held in the control.
    </summary>
    <value>A string representing the value held in the control.</value>
    <remarks>
      A string representing the value held in the control. For example, in a standard edit control, the value can be "Jones" or "$14,683.00". TextValue is set to NULL_STRING for FixedIcon objects, or to the Caption value for all other non-editable controls.
      Note that the string is formatted according to the picture clause held in the field specification of the text control; in turn, text controls linked to a data server inherit the field—and hence picture—from the field of the server.
    </remarks>
  </TextControl.TextValue>
  <TextObject>
    <summary>
      Create a text-drawing object.
    </summary>
    <remarks>
      This is part of the DrawObject hierarchy. It allows the programmer to display a text string at a particular point in a given color. An optional font can be specified.
    </remarks>
  </TextObject>
  <TextObject.ctor>
    <summary>
      Create a TextObject object.
    </summary>
    <param name="oPoint">The origin of the TextObject object in canvas coordinates. If omitted, the default is (10,10).</param>
    <param name="cText">The text to be displayed. If omitted, the default is NULL_STRING.</param>
    <param name="oFont">The font to be used by the TextObject object. The default is the system font.</param>
    <param name="oColor">The color to be used by the TextObject object. The default is the color currently being used. (Refer to the Color:Init() method for details on specifying a color.)</param>
  </TextObject.ctor>
  <TextObject.BoundingBox>
    <summary>
      A bounding box representing the smallest rectangle (in the owner window's canvas coordinates) which encloses this TextObject object.
    </summary>
    <value>A bounding box representing the smallest rectangle (in the owner window's canvas coordinates) which encloses this TextObject object.</value>
  </TextObject.BoundingBox>
  <TextObject.Color>
    <exclude />
  </TextObject.Color>
  <TextObject.Destroy>
    <exclude />
  </TextObject.Destroy>
  <TextObject.DisplayText>
    <exclude />
  </TextObject.DisplayText>
  <TextObject.Draw>
    <summary>
      Draw the TextObject object on the window.
      <br />Important! This method is called by X# when the text requires redrawing. Do not call this method from your application code—use Window:Draw() instead.
    </summary>
  </TextObject.Draw>
  <TextObject.Font>
    <exclude />
  </TextObject.Font>
  <ToolBar>
    <summary>
      Create a toolbar.
    </summary>
    <remarks>
      A toolbar provides the user with an alternative way of selecting menu commands. Although a toolbar looks more like a collection of controls than like a menu, it is constructed and manipulated as a menu rather than as a control. It is true that the events generated by a menu, a toolbar, and a push button are not fundamentally different: each menu command, toolbar button, or push button has a symbolic name; each type of event calls a named method; each has a description that appears in the status bar ("short help") and a help context that appears when you select context help (Shift+F1). But, since the toolbar is one object, capable of generating many events, and, since it is attached to the window as a whole (instead of as several push buttons), it resembles a menu more than a regular control. Also, the standard way of defining and using a toolbar is as an adjunct of its associated menu; this is the structure generated by the Menu Editor.

      Toolbar buttons can be presented with icons, icons plus text captions, or text only. The border around the buttons offers several different looks, and the gaps between buttons can be adjusted. If a toolbar is too small to display all its buttons, perhaps because its owner window is too small, it automatically presents scrolling buttons.
      The placement of the toolbar depends, to a certain extent, on its contents. For example, text-only buttons are long and thin, and are, therefore, better stacked along a vertical edge than along the top or bottom edge. Icon-only buttons, with no gaps, look very natural along the top edge. Icon and text buttons, with a small gap, are effective along the bottom edge.
      The ToolBar class also provides CoolBar/Band support, i.e., toolbars with separator bands:

      (This example is from one of the Internet Explorer's flat-style, toolbar bands.)

      A window is assigned a toolbar the same way it is assigned a menu, through an assignment to AppWindow:ToolBar(). Each toolbar button is associated with a menu command and generates the corresponding menu event; therefore, the menu and toolbar assigned to a window must be coordinated. The most convenient way to manage the toolbar is to associate it with a menu when both are created. Then, when the menu is assigned to the window, its toolbar is automatically assigned as well. This automatic approach, which fits the class definition created by the Menu Editor, ensures that toolbar button clicks are associated with the intended menu command event.
      <code language="X#">
        METHOD Init(oWOwner) CLASS MyWindow
        ...
        SELF:Menu := MyMenu{}
        ...
        METHOD Init() CLASS MyMenu
        ...
        SELF:ToolBar := ToolBar{}
      </code>
      (This is also the approach used with the accelerator table. Thus, a "menu" is actually a combination of menu, accelerator table, and toolbar, all coordinated and all used together.)

      It is possible to place a toolbar on any window, even windows that cannot own menus (such as dialog windows and nested subwindows). In these cases, assigning a menu does not produce a visible menu, but the toolbar is still active. It is also possible to have a toolbar button associated with a menu command that is not included on any menu, as long as the menu command is registered with Menu:RegisterItem().
      A toolbar takes up room on the window's client area. Some window types automatically adapt to this spatial conflict, but others require explicit management of space.
      The most common use of a toolbar in business applications is to attach it to a shell window or a data window. Both of these window types automatically adapt to the toolbar, so no further action is required. The data window is most likely used as a child window under the shell, or as a nested subwindow; in either case, the data window adapts to the toolbar.
      Placing a toolbar on a subwindow is particularly useful: it visually associates operations with the data they apply to. Many data windows may use toolbar buttons like Insert Record, Delete Record, Skip Next, Skip Previous, Go Top, Go Bottom, Seek, Undo, Cut, Copy, and Paste.
      With general top windows, child windows, and dialog windows, the management of space is the responsibility of the developer. With a toolbar on the window, this is somewhat tricky, especially if the user is allowed to drag the toolbar around: the room available depends both on resizing of the window and placement of the toolbar. The toolbar has the ToolBar:ClientArea access, which can be called during expose events to determine the shape of the remaining area.

      The action of control events sent by a toolbar attached to a window would seem to be pretty obvious: clicking on the Print button sends a #Print message to the window. But what happens if the toolbar is not attached to a child window, but to the shell window? Or if it is attached to the child window but the method that acts on the message belongs to the shell window? And what of a toolbar attached to a data window used as a nested subform?
      Toolbars are identical to menus in their action. Regardless of which window owns the toolbar or menu, the command event is sent first to the window that has focus; if it does not deal with it, it is sent to its owner, and to its owner, until it is handled. If no window responds to the message, the shell window displays a message in its status bar.
      More precisely, the chain of responses looks like this, given the symbolic name of the toolbar or menu command:
      Does the window that has focus have a method with a proper name? If so, it is called.
      <note type="tip">This is not necessarily the window that owns the toolbar or menu.</note>
      Check if its owner has a matching method, as well as the owner's owner, and so on.
      If no window has a matching method, the message is sent to the MenuCommand() method of the window with focus. The default implementation has the following logic: if it is owned by a window (as is a child window or subform), pass the method up to its owner; if it is owned by the application (as is the top or shell window), check if there is a window class with that name, and if so instantiate it; if not, display the message. The MenuCommand() method can, of course, be replaced with different logic (for example, the traditional CASE statement often used in low-level Windows programming).
      Thus, there are two chains of escalation: first, the system looks for matching method names up the ownership chain; then it escalates through the MenuCommand() methods up the ownership chain. If nobody reacts to the method, as a last resort, the window instantiation is tried; otherwise, it fails.
      This means that a toolbar can be placed on the shell window, on a child window, or even on a nested subwindow: it is active in any case, and the message is sent to all the windows and propagated up the ownership chain. Remember that only one menu is visible at any time, and a child window with a menu replaces the menu of its shell; but toolbars are different, they can be visible on any type of window.
      The window instantiation trick means that if we design a window in the Window Editor, all we have to do to open it is to give its name to a menu or toolbar item that is owned by some visible window.

      Note that there is a potential for confusing the end user with commands that could refer to different windows. (This problem is not confined to toolbars; it applies to menus as well.) Consider an order window, with information about an order and a nested subwindow (in browse view) that contains the order's line items. If a menu contains a Delete command, what does this refer to? Does it delete an order, an order and all its line items, or only a line item?
      Technically, the issue is clear: the command is sent to the lowest level window that has focus, so if the user is located on the line item subwindow, that window gets the command first. If it does not respond to it, the order window and later the shell window gets the command.
      However, from the user's viewpoint, this behavior is not obvious. The problem lies in the caption of the menu command or toolbar button: "Delete" is not very clear. Since the user may not be aware that the line item table is a subwindow (it looks just like a table on a window) getting different effects of Delete (depending on where the cursor is) can be confusing.
      It is, therefore, recommended that menu commands and toolbar buttons be labeled explicitly and clearly, for example as "Delete Order" and "Delete Item." Even if higher-level logic disables commands depending on cursor location and data (for example, Delete Order may be dimmed as long as there are still unshipped line items), captions should still be clear.
    </remarks>
    <example>
      For examples of suitable code, use the Menu Editor to generate a simple menu with a toolbar, and then use the Window Editor to assign this menu to a window.
    </example>
  </ToolBar>
  <ToolBar.ctor>
    <summary>
      Create a toolbar.
    </summary>
    <param name="oOwner">The window that owns the toolbar.</param>
    <param name="xID">The unique ID of the toolbar (between 1 and 8000).</param>
    <param name="oPoint">The origin of the toolbar in canvas coordinates.</param>
    <param name="oDimension">The dimension of the toolbar in canvas coordinates.</param>
    <param name="nButtonSize">The size of the toolbar buttons. The default is16.</param>
    <param name="lEnableBands">
      A flag specifying whether the toolbar supports bands.
      Band support is disabled if the flag is set to FALSE or if the application is running on a
      system with an old version of the Common Controls library.
      In this case, the band-related methods (AddBand(), AddSubToolBarBand(), etc.) are not available. The default is TRUE.
    </param>
    <remarks>
      A toolbar is usually assigned to a window simply by attaching it to its corresponding menu; when the menu is assigned to the window, the toolbar is assigned as well. (It is also possible to explicitly assign a toolbar separately from its menu, using the AppWindow:ToolBar property.)
      Instantiating the toolbar does not make it visible and active. The toolbar becomes alive only when attached to a window in the same way as a menu. To reduce "visual noise"(undesirable blinking and flicker), the configuration of the buttons and layout of the toolbar should be completed before it is assigned to the window and made visible.
      To define the button layout of a toolbar, you use the AppendItem() and InsertItem() methods. Note that the item IDs must be coordinated with the corresponding menu item IDs. The easiest way to manage this correspondence is to use the Menu Editor, which automatically generates the corresponding code.
      A toolbar can be placed on any type of window. Note however, that the window takes up some of the area of the window, leaving less space to work with. Shell windows and data windows automatically adapt to the toolbar, but if you place a toolbar on another kind of window you need to accommodate the change explicitly. Use the ToolBar:ClientArea property to determine how much room is left.
    </remarks>
  </ToolBar.ctor>
  <ToolBar.AddBand>
    <summary>
      Use this method to add a band to the ToolBar.
    </summary>
    <param name="sBandName">A symbol naming the band.</param>
    <param name="oControl">A window or control descendant to be included in the new band.</param>
    <param name="iPos">Position of the band. The default is the last position (-1).</param>
    <param name="iMinWidth">Minimum width of the band.</param>
    <param name="iMinHeight">Minimum height of the band.</param>
    <param name="sText">Text to be displayed on the band.</param>
    <param name="oForeColor">A Color object specifying the foreground color of the band.</param>
    <param name="oBackColor">A Color object specifying the background color of the band.</param>
    <param name="iImageIndex">An index into the image list specifying an image to be displayed.</param>
    <param name="oBackBitmap">A Bitmap object specifying a bitmap to be displayed as the band's background.</param>
    <returns>
      TRUE, if the operation was successful; otherwise, FALSE.
    </returns>
    <remarks>
      The ToolBar:AddBand() method adds a new band to the toolbar. Bands are separate areas of a toolbar control, or window, which that can be resized and moved by the end user. Each band can hold a text, an image, and a control. Additionally, foreground and background colors, as well as a background bitmap, can be specified. If you want to create a band holding a sub-toolbar as a control, use ToolBar:AddSubToolBarBand().
    </remarks>
    <example>
      For an example of a band-style toolbar, see the Private Eye sample application.
    </example>
  </ToolBar.AddBand>
  <ToolBar.AddSubToolBarBand>
    <summary>
      Add a new band to the toolbar as a sub-toolbar.
    </summary>
    <param name="symToolBar">A symbol naming the main toolbar.</param>
    <param name="iPos">Position of the sub-toolbar band. The default is -1 (the last position).</param>
    <param name="iMinWidth">Minimum width of the sub-toolbar band. The default is 100.</param>
    <param name="lFlat_dwStyle">
      You are now able to pass a DWORD value to this parameter which allows you to create ToolBars with different styles inside a ReBar control.
      <list type="table">
        <listheader>
          <term>Style</term>
          <description>Value</description>
        </listheader>
        <item>
          <term>
            BSTYLE_TOOLTIPS
          </term>
          <description>0x0100</description>
        </item>
        <item>
          <term>
            TBSTYLE_WRAPABLE
          </term>
          <description>0x0200</description>
        </item>
        <item>
          <term>
            TBSTYLE_ALTDRAG
          </term>
          <description>0x0400</description>
        </item>
        <item>
          <term>
            TBSTYLE_FLAT
          </term>
          <description> 0x0800</description>
        </item>
        <item>
          <term>
            TBSTYLE_LIST
          </term>
          <description>0x1000</description>
        </item>
        <item>
          <term>
            TBSTYLE_CUSTOMERASE
          </term>
          <description> 0x2000</description>
        </item>
        <item>
          <term>
            TBSTYLE_REGISTERDROP
          </term>
          <description>0x4000</description>
        </item>
        <item>
          <term>
            TBSTYLE_TRANSPARENT
          </term>
          <description>0x8000</description>
        </item>
      </list>
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      The AddSubToolBarBand() method creates a new band holding its own toolbar. This way, you can create a toolbar that is divided into several bands, each holding a sub-toolbar.
    </remarks>
  </ToolBar.AddSubToolBarBand>
  <ToolBar.AddTipText>
    <summary>
      Add a string to be displayed as tip text for a button.
    </summary>
    <param name="nButtonID">The button ID of the button to which to add the text.</param>
    <param name="nMenuItemID">The menu item ID of the button to which to add the text.</param>
    <param name="cText">The text to add.</param>
  </ToolBar.AddTipText>
  <ToolBar.AppendItem>
    <summary>
      Add a new toolbar button item to the end of the toolbar from the list of buttons available.
    </summary>
    <param name="nButtonID">
      The ID of the new toolbar button item. To add a gap between groups of buttons, append an item labeled IDT_SEPARATOR. To see the standard button items available, bring up the list in the Menu Editor.
      For custom toolbar buttons, append an item labeled IDT_CUSTOMBITMAP. (For example, for the first button, the &lt;nButtonID&gt; is IDT_CUSTOMBITMAP + 1; the second is IDT_CUSTOMBITMAP + 2, and so on.)
    </param>
    <param name="nMenuItemID">The ID of the menu item corresponding to the new toolbar button item.</param>
    <param name="oBmp">
      A bitmap object that contains one or more custom bitmaps. Each button in the bitmap must be a 16-color, 20 x 16 pixel bitmap. The first button in the bitmap must be drawn in pixel positions 1 and 20, the second in positions 21 and 40, the third in positions 41 and 60, and so on. (Effectively, this is a ribbon of buttons.)
      It is possible to have the custom buttons in individual bitmap resource files, and create a Bitmap object for each button. &lt;nPosition&gt; is set to 1 if you use this method. It is recommended to use a ribbon of buttons in one bitmap file, as this only uses one handle. The latter method will use a handle for each object created.
    </param>
    <param name="nPosition">
      The position of a custom toolbar button in the bitmap. If a ribbon of buttons is used for &lt;oBitmap&gt;, then the first button is 1, the second is 2, and so on. If an individual bitmap is used or if not specified, &lt;nPosition&gt; is 1.
      The following figure illustrates a ribbon of buttons contained in one bitmap, showing the pixel positions and the &lt;nPosition&gt; for each:
    </param>
    <param name="cTitle">The title of the toolbar button that is used if the button is displayed on the toolbar, in either of the TB_TEXTANDICON or TB_TEXTONLY styles. If not specified, the default is NULL_STRING.</param>
    <param name="nImgCount">The number of buttons in the image passed in &lt;oBmp&gt;. The default is 1.</param>
    <param name="bState">The initial state of the button—enabled or disabled. If enabled, the button can be selected by the user. If disabled, the button appears dimmed (grayed) and cannot be selected; it remains unavailable until it is enabled by the application. The default is enabled (TBSTATE_ENABLED).</param>
    <param name="bStyle">
      An optional style flag for the toolbar item. By default the style is automatically derived from the other parameters. Passing a Windows API constant can, however, enforce a specific style. The default is TBSTYLE_BUTTON.
    </param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      <note type="tip">Consult your Microsoft Win32 Software Development Kit documentation for detailed information about a particular Windows API constant.</note>
      Both the event triggered, when the button is clicked, and the description that shows up in the status bar are based on the properties of the associated menu. Thus, the toolbar controls the action of the application indirectly, through its associated menu.
      Specifying a toolbar by calling this method for each standard toolbar button might seem cumbersome. The recommended way to define the toolbar is to use the Menu Editor, which automatically generates code to lay out the toolbar.
      Note that the user can modify the set of button items on the toolbar with the configuration dialog. The program does not need to concern itself with what buttons exist, since the events come in as if they were menu selections.
      In order to reduce "visual noise" (undesirable blinking and flicker), the toolbar does not immediately reflect a button added with ToolBar:AppendItem(). Instead, you must call ToolBar:Update() to make all the new buttons show up at once. The ToolBar:Show() method automatically updates the display. For toolbars that are defined once and for all and attached to a window, there is no need for explicitly calling ToolBar:Update(), it is intended only for toolbars that change their button configuration on the fly.
    </remarks>
    <example>
      The following example adds two custom bitmaps to the toolbar:
      <code language="X#">
        DEFINE BUTTON_ONE := 1
        DEFINE BUTTON_TWO := 2
        DEFINE FIRST_BUTTON := IDT_CUSTOMBITMAP + BUTTON_ONE
        DEFINE SECOND_BUTTON := IDT_CUSTOMBITMAP + BUTTON_TWO
        DEFINE MENUOPTIONONE := 3000
        DEFINE MENUOPTIONTWO := 3001
        LOCAL oBitmap AS Bitmap
        // IDB_BUTTONS is the resource definition of the
        // bitmap for 2 buttons
        oBitmap := Bitmap{IDT_BUTTONS}
        // The first AppendItem() method takes the first
        // button bitmap in the bitmap object, while the
        // the second one takes the second bitmap.
        SELF:ToolBar:AppendItem(FIRST_BUTTON,MENUOPTIONONE,;
        oBitmap,1,"Button One")
        SELF:ToolBar:AppendItem(SECOND_BUTTON,;
        MENUOPTIONTWO,oBitmap,2,"Button Two")
      </code>
    </example>
  </ToolBar.AppendItem>
  <ToolBar.AppendSubItem>
    <exclude />

  </ToolBar.AppendSubItem>
  <ToolBar.BandCount>
    <summary>
      The number of bands in the toolbar.
    </summary>
    <value>The number of bands in the toolbar.</value>
  </ToolBar.BandCount>
  <ToolBar.BandImageList>
    <summary>
      An Image List object used for the bands.
    </summary>
    <value>An Image List object used for the bands.</value>
  </ToolBar.BandImageList>
  <ToolBar.Bitmap>
    <summary>
      The Bitmap object (containing a bitmap ribbon with one or more button images) that will be used to display buttons on the toolbar. If not assigned, the default bitmap is used.
    </summary>
    <value>The Bitmap object (containing a bitmap ribbon with one or more button images) that will be used to display buttons on the toolbar. If not assigned, the default bitmap is used.</value>
  </ToolBar.Bitmap>
  <ToolBar.BorderStyle>
    <summary>
      This property is no longer supported. It is included only for compatibility with existing X#1.0 code.
    </summary>
    <value>This property is no longer supported. It is included only for compatibility with existing X#1.0 code.</value>
  </ToolBar.BorderStyle>
  <ToolBar.BoundingBox>
    <summary>
      The bounding box, in canvas coordinates, representing the minimal area that encloses the toolbar.
    </summary>
    <value>The bounding box, in canvas coordinates, representing the minimal area that encloses the toolbar.</value>
  </ToolBar.BoundingBox>
  <ToolBar.ButtonCount>
    <summary>
      A numeric value representing the number of buttons currently on the toolbar.
    </summary>
    <value>A numeric value representing the number of buttons currently on the toolbar.</value>
  </ToolBar.ButtonCount>
  <ToolBar.ButtonSize>
    <summary>
      A Dimension object representing the size of buttons on the toolbar. If not assigned, the default is a 16 by 16 button.
    </summary>
    <value>A Dimension object representing the size of buttons on the toolbar. If not assigned, the default is a 16 by 16 button.</value>
  </ToolBar.ButtonSize>
  <ToolBar.ButtonStyle>
    <summary>
      A constant that represents how the buttons are displayed:
    </summary>
    <value>A constant that represents how the buttons are displayed:</value>
    <remarks>
      A constant that represents how the buttons are displayed:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>TB_ICONONLY</term>
          <description>
            Display icons only. The buttons are very small; many can fit in a limited space. This is the <b>default</b>.
          </description>
        </item>
        <item>
          <term>TB_TEXTANDICON</term>
          <description>Display both text and icons. The buttons are very large; not many can fit, but they are easy to use and easy to understand.</description>
        </item>
        <item>
          <term>TB_TEXTONLY</term>
          <description>Display text only. The icons are wide, but low. They take up too much room to be effective on a toolbar across the top or bottom, but can be very useful along the left or right side. Text-labeled buttons are not very flashy, but there are times when subtle distinctions among abstract concepts are referenced, and coming up with recognizable icons may not be easy (for example, for choices like Lease, Secured Credit and Unsecured Credit).</description>
        </item>
      </list>
    </remarks>
  </ToolBar.ButtonStyle>
  <ToolBar.ChangeTipText>
    <summary>
      Change the current tip text for a button.
    </summary>
    <param name="nID">The ID of the button whose tip text you want to change. This is either the button ID or the menu item ID, depending on the value of &lt;symLookup&gt;.</param>
    <param name="cText">The text that will replace the current tip text.</param>
    <param name="symLookUp">A symbol that describes how to interpret &lt;nID&gt;. If the value is #ButtonID, &lt;nID&gt; is the button ID of the button; otherwise, if the value is #MenuItemID, &lt;nID&gt; is the menu item ID of the button. If omitted, &lt;nID&gt; is interpreted as the button ID.</param>
    <returns>
      TRUE if the text could be changed; otherwise, FALSE.
    </returns>
  </ToolBar.ChangeTipText>
  <ToolBar.ClickItem>
    <summary>
      Make a button look like it is has been clicked, indicating that it has been selected.
    </summary>
    <param name="nMenuItemID">
      The menu item ID corresponding to the button that is clicked. This is not the original button ID that defines the look of the button; rather, it is the menu item ID which defines the meaning of the button.
    </param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
    <remarks>
      ClickItem() and UnclickItem() are used to indicate status ("sticky" buttons). A toolbar button is normally clicked in (which turns the middle of the button black) and out (which returns the middle of the button to white) to indicate that its corresponding menu item has been checked or unchecked. A button retains its clicked-in state whether enabled or disabled.
    </remarks>
  </ToolBar.ClickItem>
  <ToolBar.ClientArea>
    <summary>
      A bounding box (group or character box) representing the area of its parent window that remains available given the placement of the toolbar.
    </summary>
    <value>A bounding box (group or character box) representing the area of its parent window that remains available given the placement of the toolbar.</value>
    <remarks>
      A bounding box (group or character box) representing the area of its parent window that remains available given the placement of the toolbar. When a toolbar is used in the standard way, on a shell window or a data window, there is usually little need to use this property; the windows automatically adapt themselves to the toolbar. However, when placing the toolbar on a regular window, such as a TopAppWindow, the developer is responsible for adapting the window to the size that remains as the user moves the toolbar around. Thus, the window might respond to an expose event by asking its toolbar how much space remains.
    </remarks>
  </ToolBar.ClientArea>
  <ToolBar.Configure>
    <summary>
      This method is no longer supported. It is included only for compatibility with existing X#1.0 code.
    </summary>
  </ToolBar.Configure>
  <ToolBar.Create>
    <exclude />
  </ToolBar.Create>
  <ToolBar.DeleteItem>
    <summary>
      Remove a button from the toolbar.
    </summary>
    <param name="nMenuItemID">
      The menu item ID corresponding to the button that is to be removed.
      This is not the original button ID that defines the look of the button; rather it is the menu item ID which defines the meaning of the button.
    </param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
  </ToolBar.DeleteItem>
  <ToolBar.Destroy>
    <summary>
      Provide a method to de-instantiate a ToolBar object.
    </summary>
    <remarks>
      This method can be used when a ToolBar object is no longer needed. ToolBar:Destroy() de-instantiates the ToolBar object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </ToolBar.Destroy>
  <ToolBar.DimItem>
    <summary>
      Dim a button.
    </summary>
    <param name="nMenuItemID">The menu item ID of the button you want to dim.</param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
  </ToolBar.DimItem>
  <ToolBar.DisableItem>
    <summary>
      Disable a button.
    </summary>
    <param name="nMenuItemID">
      The menu item ID corresponding to the button that is to be disabled.
      This is not the original button ID that defines the look of the button; rather it is the menu item ID which defines the meaning of the button.
    </param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
    <remarks>
      A toolbar button is normally disabled (dimmed) and enabled (blackened) in conjunction with its corresponding menu item. A button retains its clicked-in state whether enabled or disabled.
    </remarks>
  </ToolBar.DisableItem>
  <ToolBar.Divider>
    <summary>This field reflects the constructor parameter lEnableBands (Divider is TRUE when lEnableBands = FALSE).</summary>
    <value>Should the toolbar have dividers or separate bands.</value>
  </ToolBar.Divider>
  <ToolBar.EnableBands>
    <summary>
      Enable toolbar band support.
    </summary>
    <param name="lEnable">A logical value specifying whether or not toolbar separator bands are supported. The default is TRUE.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      This method enables or disables toolbar band support. If bands are enabled (the default), the toolbar uses internally a Rebar32 control and supports the management of several bands. If you do not need or want bands, issue EnableBands(FALSE) before the toolbar is shown/created.
      <note type="tip">If band support is disabled, the band-related methods, such as ToolBar:AddBand(), will not work.</note>
    </remarks>
    <example>
      For an example of a band-style toolbar, see the Private Eye sample application.
    </example>
  </ToolBar.EnableBands>
  <ToolBar.EnableDrag>
    <summary>
      Allow the user to move the toolbar around with the mouse.
    </summary>
    <param name="lEnable">The logical value indicating whether dragging is allowed. TRUE is the default if omitted or if the method is not called.</param>
    <remarks>
      When dragged to an edge, the toolbar snaps onto the edge; if left in the central area of the window, the toolbar floats and is resizable.
      The EnableDrag() method can only be used before the toolbar is assigned to a window.
    </remarks>
  </ToolBar.EnableDrag>
  <ToolBar.EnableItem>
    <summary>
      Enable a button that has been disabled.
    </summary>
    <param name="nMenuItemID">
      The menu item ID corresponding to the button that is to be removed.
      This is not the original button ID that defines the look of the button, reference is based on the menu item ID which defines the meaning of the button.
    </param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
    <remarks>
      A toolbar button is normally disabled and enabled in conjunction with its corresponding menu item. A button retains its clicked-in state whether enabled or disabled.
    </remarks>
  </ToolBar.EnableItem>
  <ToolBar.Flat>
    <exclude />
  </ToolBar.Flat>
  <ToolBar.GapSize>
    <summary>
      This property is no longer supported. It is included only for compatibility with existing X#1.0 code.
    </summary>
    <value>This property is no longer supported. It is included only for compatibility with existing X#1.0 code.</value>
  </ToolBar.GapSize>
  <ToolBar.GetButtonCount>
    <exclude />
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
  </ToolBar.GetButtonCount>
  <ToolBar.GetButtonDescription>
    <summary>
      Retrieve the description of a toolbar button.
    </summary>
    <param name="nButtonID">The ID of the toolbar button.</param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
    <returns>
      The description of the toolbar button taken from the hyperlabel connected to the toolbar button.
    </returns>
  </ToolBar.GetButtonDescription>
  <ToolBar.GetImageList>
    <summary>
      Gets the ImageList that is specified by the parameters passed.
    </summary>
    <param name="symType">
      an be #IMAGELIST, #HOTIMAGELIST or #DISABLEDIMAGELIST,
      The default value is #IMAGELIST
    </param>
    <param name="symTB">
      Is the name of the toolbar (subtoolbar)
      The default is #Maintoolbar
    </param>
    <remarks>
      You can assign your own imagelist for every subtoolbar. Additionally you could assign a separate HotImagelist and a DisabledImagelist for every subtoolbar.
      This method is used to get those ImageLists.
    </remarks>
  </ToolBar.GetImageList>
  <ToolBar.GetRows>
    <exclude />
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
  </ToolBar.GetRows>
  <ToolBar.GetState>
    <exclude />

  </ToolBar.GetState>
  <ToolBar.GetTipText>
    <summary>
      Return the current tip text for a button.
    </summary>
    <param name="nButtonID">The ID of the button whose tip text you want to obtain. This is either the button ID or the menu item ID, depending on the value of &lt;symLookup&gt;.</param>
    <param name="symLookUp">A symbol that describes how to interpret &lt;nID&gt;. If the value is #ButtonID, &lt;nID&gt; is the button ID of the button; otherwise, if the value is #MenuItemID, &lt;nID&gt; is the menu item ID of the button. If omitted, &lt;nID&gt; is interpreted as the button ID.</param>
    <returns>
      The current tip text of the specified button.
    </returns>
  </ToolBar.GetTipText>
  <ToolBar.Hide>
    <summary>
      Hide a toolbar so it is not visible.
    </summary>
    <remarks>
      The toolbar remains hidden from display until the ToolBar:Show() method is called.
    </remarks>
  </ToolBar.Hide>
  <ToolBar.HideItem>
    <summary>
      Hide a button.
    </summary>
    <param name="nMenuItemID">The menu item ID of the button to hide.</param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
  </ToolBar.HideItem>
  <ToolBar.ImageCount>
    <summary>
      A numeric value representing the number of images in the toolbar bitmap. If a custom bitmap has been assigned to the toolbar, this value must be assigned as the number of images in that bitmap.
    </summary>
    <value>A numeric value representing the number of images in the toolbar bitmap. If a custom bitmap has been assigned to the toolbar, this value must be assigned as the number of images in that bitmap.</value>
  </ToolBar.ImageCount>
  <ToolBar.InsertItem>
    <summary>
      Insert a new toolbar button item before a specified toolbar button item, from the list of buttons available.
    </summary>
    <param name="nButtonID">The ID of the new toolbar button item. To add a gap between groups of buttons, append an item labeled IDT_SEPARATOR. To see the button items available, see Appendix A or bring up a list in the Menu Editor.</param>
    <param name="nMenuItemID">The ID of the menu item corresponding to the new toolbar button item.</param>
    <param name="nBeforeID">The ID of the toolbar button item before which the new toolbar button item should be inserted. If omitted, the new toolbar button item is inserted after the last toolbar button item.</param>
    <param name="bState">** missing parameter documentation **</param>
    <param name="bStyle">** missing parameter documentation **</param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>
      Both the event triggered when the button is clicked and the description that shows up in the status bar are based on the properties of the associated menu. Thus, the toolbar controls the action of the application indirectly, through its associated menu.
      Specifying a toolbar by calling this method for each button might seem cumbersome. The recommended way to define the toolbar is to use the Menu Editor, which automatically generates code to lay out the toolbar.
      Note that the user can modify the set of button items on the toolbar with the configuration dialog. The program does not need to concern itself with what buttons exist, since the events come in as if they were menu selections.
      In order to reduce "visual noise" (undesirable blinking and flicker), the toolbar does not immediately reflect a button added with InsertItem(). Instead, you must call Update() to make all the new buttons show up at once. The Show() method automatically updates the display. For toolbars that are defined once and for all and attached to a window, there is no need for explicitly calling Update(), it is intended only for toolbars that change their button configuration on the fly.
    </remarks>
  </ToolBar.InsertItem>
  <ToolBar.IsClicked>
    <summary>
      Return a logical value indicating whether the specified button is currently clicked or selected.
    </summary>
    <param name="nID">The ID of the desired toolbar button item.</param>
    <param name="symIDType">Symbol indicating the type of data &lt;nButtonID&gt; represents. Valid values are #ButtonID and #MenuItemID. Defaults to #ButtonID.</param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
    <returns>
      TRUE if clicked (or selected); otherwise, FALSE.
    </returns>
    <example>
      <code language="X#">
        //check if the first toolbar button is dimmed
        oTB:IsClicked(1)
        //check if the first toolbar button is dimmed, specifying a button ID for
        //the first parameter
        oTB:IsClicked(1, #ButtonID)
        //check if the File Open button is dimmed, specifying a menu item ID for
        //the first parameter
        oTB:IsClicked(IDM_StandardShellMenu_File_Open_ID, #MenuItemID)
      </code>
    </example>
  </ToolBar.IsClicked>
  <ToolBar.IsDimmed>
    <summary>
      Determine whether a button is dimmed.
    </summary>
    <param name="nID">The ID of the button whose state you want to determine. This is either the button ID or the menu item ID, depending on the value of &lt;symLookup&gt;.</param>
    <param name="symLookup">A symbol that describes how to interpret &lt;nID&gt;. If the value is #ButtonID, &lt;nID&gt; is the button ID of the button; otherwise, if the value is #MenuItemID, &lt;nID&gt; is the menu item ID of the button. If omitted, &lt;nID&gt; is interpreted as the button ID.</param>
    <param name="symIDType">Symbol indicating the type of data &lt;nButtonID&gt; represents. Valid values are #ButtonID and #MenuItemID. Defaults to #ButtonID.</param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
    <returns>
      TRUE if the button is dimmed; otherwise, FALSE.
    </returns>
    <example>
      <code language="X#">
        //check if the first toolbar button is dimmed
        oTB:IsDimmed(1)
        //check if the first toolbar button is dimmed, specifying a button ID for
        //the first parameter
        oTB:IsDimmed(1, #ButtonID)
        //check if the File Open button is dimmed, specifying a menu item ID for
        //the first parameter
        oTB:IsDimmed(IDM_StandardShellMenu_File_Open_ID, #MenuItemID)
      </code>
    </example>
  </ToolBar.IsDimmed>
  <ToolBar.IsEnabled>
    <summary>
      Return a logical value indicating whether the specified button is currently enabled.
    </summary>
    <param name="nID">The ID of the desired toolbar button item. This can be either the numeric position of the button in the toolbar (the button ID) or the menu item ID.</param>
    <param name="symIDType">Symbol indicating the type of data &lt;nButtonID&gt; represents. Valid values are #ButtonID and #MenuItemID. Defaults to #ButtonID.</param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
    <returns>
      TRUE if enabled; otherwise, FALSE.
    </returns>
    <example>
      <code language="X#">
        //check if the first toolbar button is enabled
        oTB:IsEnabled(1)
        //check if the first toolbar button is enabled, specifying a button ID for
        //the first parameter
        oTB:IsEnabled(1, #ButtonID)
        //check if the File Open button is enabled, specifying a menu item ID for
        //the first parameter
        oTB:IsEnabled(IDM_StandardShellMenu_File_Open_ID, #MenuItemID)
      </code>
    </example>
  </ToolBar.IsEnabled>
  <ToolBar.IsHidden>
    <summary>
      Determine whether a button is hidden.
    </summary>
    <param name="nID">The ID of the button whose state you want to determine. This is either the button ID or the menu item ID, depending on the value of &lt;symLookup&gt;.</param>
    <param name="symIDType">A symbol that describes how to interpret &lt;nID&gt;. If the value is #ButtonID, &lt;nID&gt; is the button ID of the button; otherwise, if the value is #MenuItemID, &lt;nID&gt; is the menu item ID of the button. If omitted, &lt;nID&gt; is interpreted as the button ID.</param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
    <returns>
      TRUE if the button is hidden; otherwise, FALSE.
    </returns>
  </ToolBar.IsHidden>
  <ToolBar.IsPressed>
    <summary>
      Determine whether a button is pressed.
    </summary>
    <param name="nID">The ID of the button whose state you want to determine. This is either the button ID or the menu item ID, depending on the value of &lt;symLookup&gt;.</param>
    <param name="symIDType">A symbol that describes how to interpret &lt;nID&gt;. If the value is #ButtonID, &lt;nID&gt; is the button ID of the button; otherwise, if the value is #MenuItemID, &lt;nID&gt; is the menu item ID of the button. If omitted, &lt;nID&gt; is interpreted as the button ID.</param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
    <returns>
      TRUE if the button is pressed; otherwise, FALSE.
    </returns>
  </ToolBar.IsPressed>
  <ToolBar.Location>
    <summary>
      This property is no longer supported. It is included only for compatibility with existing X#1.0 code.
    </summary>
    <value>This property is no longer supported. It is included only for compatibility with existing X#1.0 code.</value>
  </ToolBar.Location>
  <ToolBar.Origin>
    <summary>
      A point representing the origin of a toolbar on its owner window.
    </summary>
    <value>A point representing the origin of a toolbar on its owner window.</value>
  </ToolBar.Origin>
  <ToolBar.Owner>
    <summary>
      The window that owns the toolbar.
    </summary>
    <value>The window that owns the toolbar.</value>
  </ToolBar.Owner>
  <ToolBar.PressItem>
    <summary>
      Press a button.
    </summary>
    <param name="nMenuItemID">The menu item ID of the button to press.</param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
  </ToolBar.PressItem>
  <ToolBar.RemoveTipText>
    <summary>
      Remove the current tip text for a button.
    </summary>
    <param name="nButtonID">The ID of the button whose tip text you want to remove. This is either the button ID or the menu item ID, depending on the value of &lt;symLookup&gt;.</param>
    <param name="symLookUp">A symbol that describes how to interpret &lt;nID&gt;. If the value is #ButtonID, &lt;nID&gt; is the button ID of the button; otherwise, if the value is #MenuItemID, &lt;nID&gt; is the menu item ID of the button. If omitted, &lt;nID&gt; is interpreted as the button ID.</param>
    <returns>
      TRUE if the text could be removed; otherwise, FALSE.
    </returns>
  </ToolBar.RemoveTipText>
  <ToolBar.Rows>
    <summary>
      A numeric value representing the number of rows of buttons on the toolbar.
      Note that Rows now has an optional parameter, &lt;symTB&gt;, to indicate which toolbar, or sub-toolbar, to query. If not specified, #MAINTOOLBAR is assumed.
    </summary>
    <value>
      A numeric value representing the number of rows of buttons on the toolbar.
      Note that Rows now has an optional parameter, &lt;symTB&gt;, to indicate which toolbar, or sub-toolbar, to query. If not specified, #MAINTOOLBAR is assumed.
    </value>
    <example>
      To set the number of rows in the main toolbar, the following statements are equivalent:
      <code language="X#">
        oToolBar:Rows := 3
        oToolBar:[Rows, #MAINTOOLBAR] := 3
      </code>
      To set the number of rows for a (sub-)toolbar, you should do the following:
      <code language="X#">oToolBar:[Rows, #MYTOOLBAR] := 4</code>
      where #MYTOOLBAR is the symbol name representing the toolbar you which to change.
      There are two ways to query the number of rows in the main toolbar:
      <code language="X#">
        nRows := oToolBar:Rows
        nRows := oToolBar:[Rows, #MAINTOOLBAR]
      </code>
      To query the number of rows in the sub-toolbar represented by #MYSUBTOOLBAR, you could do the following:
      <code language="X#">nRows := oToolBar:[Rows, #MYSUBTOOLBAR]</code>
    </example>
  </ToolBar.Rows>
  <ToolBar.SeparatorSize>
    <summary>
      This property is no longer supported. It is included only for compatibility with existing X#1.0 code.
    </summary>
    <value>This property is no longer supported. It is included only for compatibility with existing X#1.0 code.</value>
  </ToolBar.SeparatorSize>
  <ToolBar.SetImageList>
    <summary>
      Sets the ImageList to be used by the ToolBar.
    </summary>
    <param name="uImageList">Can be an Imagelist or a bitmap loaded with LR_CREATEDIBSECTION and the background Color{192, 192, 192}.</param>
    <param name="symType">
      Can be #IMAGELIST, #HOTIMAGELIST or #DISABLEDIMAGELIST,
      The default value is #IMAGELIST
    </param>
    <param name="symTB">
      Is the name of the toolbar (subtoolbar)
      The default is #Maintoolbar
    </param>
    <remarks>
      You can assign your own imagelist for every subtoolbar.
      Additionally you could assign a separate HotImagelist and a DisabledImagelist for every subtoolbar.
      If you assign a Bitmap instead, it is automatically converted into a compatible Imagelist. Bitmaps for a toolbar imagelist must be loaded with the parameter LR_CREATEDIBSECTION and not with the BMP_3DTRANSPARENT which is needed for Ribbons.
      The Bitmap must have the default VO background color for Toolbar ribbons Color{192, 192, 192}.
    </remarks>
  </ToolBar.SetImageList>
  <ToolBar.SetRows>
    <exclude />

  </ToolBar.SetRows>
  <ToolBar.SetState>
    <exclude />

  </ToolBar.SetState>
  <ToolBar.Show>
    <summary>
      Display a toolbar so it is visible.
    </summary>
    <remarks>
      ToolBar:Show() is used to redisplay a toolbar that was hidden with the ToolBar:Hide() method. The toolbar does not have to be shown initially, it becomes visible as soon as it is assigned to a window.
    </remarks>
  </ToolBar.Show>
  <ToolBar.ShowBand>
    <exclude />

  </ToolBar.ShowBand>
  <ToolBar.ShowItem>
    <summary>
      Show a button.
    </summary>
    <param name="nMenuItemID">The menu item ID of the button to show.</param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
  </ToolBar.ShowItem>
  <ToolBar.Size>
    <summary>
      A dimension representing the size of a toolbar.
    </summary>
    <value>A dimension representing the size of a toolbar.</value>
  </ToolBar.Size>
  <ToolBar.UnClickItem>
    <summary>
      Make a button look like it is "clicked-out" (returned to its normal state) after it has been "clicked-in" to indicate that it has been selected.
    </summary>
    <param name="nMenuItemID">
      The menu item ID corresponding to the button that is unclicked.
      This is not the original button ID that defines the look of the button; rather it is the menu item ID which defines the meaning of the button.
    </param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
    <remarks>
      ToolBar:ClickItem() and ToolBar:UnclickItem() are used to indicate status ("sticky" buttons). A toolbar button is normally clicked in (which turns the middle of the button black) and out (which returns the middle of the button to white) to indicate that its corresponding menu item has been checked or unchecked. A button retains its clicked-in state whether enabled or disabled.
    </remarks>
  </ToolBar.UnClickItem>
  <ToolBar.UnDimItem>
    <summary>
      Undim a button.
    </summary>
    <param name="nMenuItemID">The menu item ID of the button to undim.</param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
  </ToolBar.UnDimItem>
  <ToolBar.UnPressItem>
    <summary>
      Unpress a button.
    </summary>
    <param name="nMenuItemID">The menu item ID of the button to unpress.</param>
    <param name="symTB">Symbolic name representing the toolbar to be used. Defaults to the main toolbar.</param>
  </ToolBar.UnPressItem>
  <ToolBar.Update>
    <summary>
      This method is no longer supported. It is included only for compatibility with existing X#1.0 code.
    </summary>
  </ToolBar.Update>
  <TopAppWindow>
    <summary>
      Create a top-level application window.
    </summary>
    <remarks>
      A top-level application window is the main window of an application; it has no owner windows. As with other application windows, a top application window can have icons, captions, resizeable borders, menus, and system menus. An application can have more than one top application window.
    </remarks>
    <example>
      This example creates a top application window with the caption "TopAppWindow":
      <code language="X#">
        METHOD Start() CLASS App
        MyWin := TopAppWindow{}
        MyWin:Caption := "TopAppWindow"
        MyWin:Show()
        SELF:Exec()
      </code>
    </example>
  </TopAppWindow>
  <TopAppWindow.ctor>
    <summary>
      Create a top-level application window.
    </summary>
    <param name="oOwner">The window that owns the top-level application window, which is the application itself. If not specified, SELF is used.</param>
  </TopAppWindow.ctor>
  <TopAppWindow.Destroy>
    <inheritdoc />
  </TopAppWindow.Destroy>
  <TopAppWindow.Owner>
    <summary>
      The owner of the top application window, either a Window or App object.
    </summary>
    <value>The owner of the top application window, either a Window or App object.</value>
  </TopAppWindow.Owner>
  <TopAppWindow.Resize>
    <inheritdoc />
  </TopAppWindow.Resize>
  <TopAppWindow.ToolBarHeightChanged>
    <inheritdoc />
  </TopAppWindow.ToolBarHeightChanged>
  <TreeView>
    <summary>
      Create a tree view control.
    </summary>
    <remarks>
      A tree view control is a control that displays a hierarchical list of tree view items, such as files and directories on a disk. Each item consists of a label and an optional icon, and each item can have a list of subitems associated with it. By clicking an item, the user can expand and collapse the associated list of subitems.
    </remarks>
  </TreeView>
  <TreeView.ctor>
    <summary>
      Construct a tree view.
    </summary>
    <param name="oOwner">The window that owns the tree view.</param>
    <param name="xID">The unique ID of the tree view (between 1 and 8000).</param>
    <param name="nResourceID">The resource ID of the tree view.</param>
    <param name="oPoint">The origin of the tree view in canvas coordinates.</param>
    <param name="oDimension">The dimension of the tree view in canvas coordinates.</param>
    <param name="kStyle">The style of the tree view.</param>
  </TreeView.ctor>
  <TreeView.AddItem>
    <summary>
      Add a new tree view item as the last child item of a specified parent.
    </summary>
    <param name="symParentName">The symbolic name of the parent tree view item. This can be the symbolic name of any tree view item or one of the following items: #Root, #First, #Last, and, if the tree view style is sorted, #Sort.</param>
    <param name="oTreeViewItem">The tree view item to add.</param>
    <returns>
      TRUE if the item was added successfully; otherwise, FALSE.
    </returns>
  </TreeView.AddItem>
  <TreeView.Collapse>
    <summary>
      Collapse a tree view item, hiding its child items.
    </summary>
    <param name="symName">The symbolic name of the tree view item to be collapsed.</param>
    <param name="oItem">The TreeViewItem object representing the tree view item to be collapsed.</param>
    <param name="lRemoveChildItems">A logical value indicating whether child tree view items of the specified item will be removed when the item is collapsed. If omitted, the default is FALSE.</param>
    <param name="lAll">If lAll is TRUE(default = FALSE), the operation is done for the complete subtree of the specified item.</param>
    <param name="lForceNotify">
      If lForceNotify is TRUE(default = FALSE), a notify message Window:TreeViewItemExpanding() and Window:TreeViewItemExpanded() is sent for each item whose expand state is changed.
      Generally windows will only send these messages when an item is first expanded. It depends on the TVIS_EXPANDEDONCE state. (see in Platform SDK the TVM_EXPAND Message for more details.)
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeView.Collapse>
  <TreeView.DeleteAll>
    <summary>
      Delete all items of the tree view.
    </summary>
    <returns>
      TRUE if all items were deleted successfully; otherwise, FALSE.
    </returns>
  </TreeView.DeleteAll>
  <TreeView.DeleteItem>
    <summary>
      Delete a tree view item.
    </summary>
    <param name="symName">The symbolic name of the tree view item to be deleted.</param>
    <param name="oItem">The TreeViewItem object representing the tree view item to be deleted.</param>
    <param name="lChildrenOnly">
      New logic parameter which defaults to FALSE.
      If lChildrenOnly is TRUE only the child items are deleted
    </param>
    <returns>
      TRUE if the item was deleted successfully; otherwise, FALSE.
    </returns>
  </TreeView.DeleteItem>
  <TreeView.Destroy>
    <exclude />
  </TreeView.Destroy>
  <TreeView.DragDropEnabled>
    <summary>
      A logical value that is TRUE if drag-and-drop is enabled for the tree view. If drag-and-drop is enabled, items can be dragged within, as well as outside, the control.
    </summary>
    <value>A logical value that is TRUE if drag-and-drop is enabled for the tree view. If drag-and-drop is enabled, items can be dragged within, as well as outside, the control.</value>
  </TreeView.DragDropEnabled>
  <TreeView.DragImageList>
    <summary>
      An image list containing a single image displayed during a drag-and-drop operation for the tree view.
    </summary>
    <value>An image list containing a single image displayed during a drag-and-drop operation for the tree view.</value>
  </TreeView.DragImageList>
  <TreeView.EditItemLabel>
    <summary>
      Begins in-place label editing of an item in the tree view.
    </summary>
    <param name="symName">The symbolic name of the tree view item whose label you want to edit or the TreeViewItem object representing the tree view item whose label you want to edit.</param>
  </TreeView.EditItemLabel>
  <TreeView.EnableDragDrop>
    <summary>
      Enable or disable drag-and-drop of items for the tree view.
    </summary>
    <param name="lEnable">A logical value that determines whether drag-and-drop is enabled or disabled.</param>
    <returns>
      TRUE if drag-and-drop could be enabled or disabled; otherwise, FALSE.
    </returns>
  </TreeView.EnableDragDrop>
  <TreeView.EnableSort>
    <summary>
      Register a user-defined method to use for sorting items in the tree view.
    </summary>
    <param name="symMethodName">The symbolic name of the user-defined method that will be used to sort items in the tree view. When called, this method receives two TreeViewItem objects as arguments. The method should determine which of the two tree view items should come first in the tree view. If the first item precedes the second, this method should return -1; if the second item precedes the first, this method should return 1; if the items are equivalent, this method should return 0.</param>
    <returns>
      The symbolic name of the user-defined method that will be used to perform the sort.
    </returns>
  </TreeView.EnableSort>
  <TreeView.EnsureVisible>
    <summary>
      Ensure that an item is visible in the tree view, expanding its parent item or scrolling the tree view if necessary.
    </summary>
    <param name="symName">The symbolic name of the tree view item which should be made visible or the TreeViewItem object representing the tree view item which should be made visible.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeView.EnsureVisible>
  <TreeView.Expand>
    <summary>
      Expand a tree view item, showing its child items.
    </summary>
    <param name="symName">The symbolic name of the tree view item to be expanded.</param>
    <param name="oItem">The treeview item to be expanded.</param>
    <param name="lAll">If lAll is TRUE(default = FALSE), the operation is done for the complete subtree of the specified item.</param>
    <param name="lForceNotify">
      If lForceNotify is TRUE(default = FALSE), a notify message Window:TreeViewItemExpanding() and Window:TreeViewItemExpanded() is sent for each item whose expand state is changed.
      Generally windows will only send these messages when an item is first expanded. It depends on the TVIS_EXPANDEDONCE state. (see in Platform SDK the TVM_EXPAND Message for more details.)
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeView.Expand>
  <TreeView.GetDropHighlight>
    <summary>
      Return the first tree view item that is the target of a drag-and-drop operation.
    </summary>
    <returns>
      The first tree view item that is the target of a drag-and-drop operation.
    </returns>
  </TreeView.GetDropHighlight>
  <TreeView.GetFirstChildItem>
    <summary>
      Return the first child tree view item.
    </summary>
    <param name="uItem">The treeview item or the name of the treeview item from which to start the search.</param>
    <param name="oItem">The treeview item from which to start the search.</param>
    <param name="symItem">
      The symbolic name of the tree view item from which to start the search. If omitted, the search starts from the root item.
      Or the TreeViewItem object representing the tree view item from which to start the search.
    </param>
    <returns>
      The first tree view item from the starting item.
    </returns>
  </TreeView.GetFirstChildItem>
  <TreeView.GetFirstVisibleItem>
    <summary>
      Return the first visible tree view item.
    </summary>
    <returns>
      The first visible tree view item.
    </returns>
  </TreeView.GetFirstVisibleItem>
  <TreeView.GetItemAtPosition>
    <summary>
      Return the tree view item at a particular position, if one exists.
    </summary>
    <param name="oPoint">The point at which to find a tree view item.</param>
    <returns>
      The tree view item at the specified point.
    </returns>
  </TreeView.GetItemAtPosition>
  <TreeView.GetItemAttributes>
    <summary>
      Return a tree view item given its symbolic name.
    </summary>
    <param name="symItem">The symbolic name of the tree view item to be returned.</param>
    <param name="oItem">The TreeViewItem object representing the tree view item to be returned.</param>
    <returns>
      The tree view item specified by the symbolic name.
    </returns>
  </TreeView.GetItemAttributes>
  <TreeView.GetItemBoundingBox>
    <summary>
      Return the bounding box of a tree view item.
    </summary>
    <param name="symItem">The symbolic name of the tree view item whose bounding box you want to obtain.</param>
    <param name="oItem">The TreeViewItem object representing the tree view item whose bounding box you want to obtain.</param>
    <param name="lTextOnly">Logical value determining whether the returned bounding box encloses just the portion of the list view item that the text takes up (TRUE), or the entire length of the list view item (FALSE). If omitted, defaults to FALSE.</param>
    <returns>
      The bounding box of the tree view item specified by the symbolic name or TreeViewItem object.
    </returns>
  </TreeView.GetItemBoundingBox>
  <TreeView.GetNextSiblingItem>
    <summary>
      Return a tree view item's next sibling item.
    </summary>
    <param name="symItem">The symbolic name of the tree view item whose next sibling you want to obtain.</param>
    <param name="oItem">The TreeViewItem object representing the tree view item whose next sibling you want to obtain.</param>
    <returns>
      The next sibling tree view item of the specified item.
    </returns>
  </TreeView.GetNextSiblingItem>
  <TreeView.GetNextVisibleItem>
    <summary>
      Return a tree view item's next visible item.
    </summary>
    <param name="symItem">The symbolic name of the tree view item whose next visible item you want to obtain.</param>
    <param name="oItem">The TreeViewItem object representing the tree view item whose next visible item you want to obtain.</param>
    <returns>
      The next visible tree view item of the specified item.
    </returns>
  </TreeView.GetNextVisibleItem>
  <TreeView.GetParentItem>
    <summary>
      Return a tree view item's parent item.
    </summary>
    <param name="symItem">The symbolic name of the tree view item whose parent item you want to obtain.</param>
    <param name="oItem">The TreeViewItem object representing the tree view item whose parent item you want to obtain.</param>
    <returns>
      The parent tree view item of the specified item.
    </returns>
  </TreeView.GetParentItem>
  <TreeView.GetPreviousSiblingItem>
    <summary>
      Return a tree view item's previous sibling item.
    </summary>
    <param name="symItem">The symbolic name of the tree view item whose previous sibling item you want to obtain.</param>
    <param name="oItem">The TreeViewItem object representing the tree view item whose previous sibling item you want to obtain.</param>
    <returns>
      The previous sibling tree view item of the specified item.
    </returns>
  </TreeView.GetPreviousSiblingItem>
  <TreeView.GetPreviousVisibleItem>
    <summary>
      Return a tree view item's previous visible item.
    </summary>
    <param name="symItem">The symbolic name of the tree view item whose previous visible item you want to obtain.</param>
    <param name="oItem">The TreeViewItem object representing the tree view item whose previous visible item you want to obtain.</param>
    <returns>
      The previous visible tree view item of the specified item.
    </returns>
  </TreeView.GetPreviousVisibleItem>
  <TreeView.GetRootItem>
    <summary>
      Return the root tree view item.
    </summary>
    <returns>
      The root tree view item.
    </returns>
  </TreeView.GetRootItem>
  <TreeView.GetSelectedItem>
    <summary>
      Return the currently selected tree view item.
    </summary>
    <returns>
      The currently selected tree view item.
    </returns>
  </TreeView.GetSelectedItem>
  <TreeView.ImageList>
    <summary>
      An image list containing images to display for each item in the tree view.
    </summary>
    <value>An image list containing images to display for each item in the tree view.</value>
  </TreeView.ImageList>
  <TreeView.Indent>
    <summary>
      A numeric value representing the number of pixels that child items are indented from parent items.
    </summary>
    <value>A numeric value representing the number of pixels that child items are indented from parent items.</value>
  </TreeView.Indent>
  <TreeView.InsertItem>
    <summary>
      Insert a new tree view item as a child of a specified item and after a specified item in the tree view.
    </summary>
    <param name="symParentName">The symbolic name of the parent tree view item of the new item. This can be the symbolic name of any tree view item or one of the following items: #Root, #First, #Last, and, if the tree view style is sorted, #Sort.</param>
    <param name="symInsertAfter">The symbolic name of the tree view item after which the new item should be inserted. This can be the symbolic name of any tree view item or one of the following items: #Root, #First, #Last, and, if the tree view style is sorted, #Sort.</param>
    <param name="oTreeViewItem">The tree view item to insert.</param>
    <returns>
      TRUE if the item was inserted successfully; otherwise, FALSE.
    </returns>
  </TreeView.InsertItem>
  <TreeView.ItemCount>
    <summary>
      A numeric value representing the number of items in the tree view.
    </summary>
    <value>A numeric value representing the number of items in the tree view.</value>
  </TreeView.ItemCount>
  <TreeView.SearchString>
    <summary>
      The incremental search string associated with the tree view.
    </summary>
    <value>The incremental search string associated with the tree view.</value>
    <remarks>
      The incremental search string associated with the tree view. The incremental search string is the character sequence that the user types while the tree view has the input focus. When the user types a character, the character is appended to the search string, and a matching item is sought. If the system finds a match, it selects the item. A timeout period is associated with the search string; if the timeout period elapses before the user types another character, the string is reset.
    </remarks>
  </TreeView.SearchString>
  <TreeView.SelectItem>
    <summary>
      Cause a tree view to select a tree view item, scroll the item into view, or redraw it as the target of a drag-and-drop operation.
    </summary>
    <param name="symItem">The symbolic name of the tree view item to be selected.</param>
    <param name="oItem">The TreeViewItem object representing the tree view item to be selected.</param>
    <param name="symCode">The symbolic name of the type of selection. It can be one of the following values: #FirstVisible to scroll the item into view, or #DropHighlight to redraw the item. If omitted, the item is simply selected.</param>
    <param name="lSelect">The optional logical value to determine whether the specified tree view item is selected (TRUE) or deselected (FALSE). If omitted, defaults to TRUE.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeView.SelectItem>
  <TreeView.SetItemAttributes>
    <summary>
      Update a tree view item within the tree view.
    </summary>
    <param name="oTreeViewItem">The tree view item to update.</param>
  </TreeView.SetItemAttributes>
  <TreeView.SortChildren>
    <summary>
      Sort the child tree view items of an item using the user-defined sort method specified by EnableSort().
    </summary>
    <param name="symParentName">The symbolic name of the tree view item whose children will be sorted.</param>
    <param name="oParentItem">TreeViewItem object representing the tree view item whose children will be sorted.</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeView.SortChildren>
  <TreeView.StateImageList>
    <summary>
      An image list containing state images to display for each item in the tree view.
    </summary>
    <value>An image list containing state images to display for each item in the tree view.</value>
  </TreeView.StateImageList>
  <TreeView.Toggle>
    <summary>
      Toggle the expanded or collapsed state of a tree view item, showing or hiding its child items appropriately.
    </summary>
    <param name="symName">The symbolic name of the tree view item to be toggled or the TreeViewItem object representing the tree view item to be toggled.</param>
    <param name="lAll">If lAll is TRUE(default = FALSE), the operation is done for the complete subtree of the specified item.</param>
    <param name="lForceNotify">
      If lForceNotify is TRUE(default = FALSE), a notify message Window:TreeViewItemExpanding() and Window:TreeViewItemExpanded() is sent for each item whose expand state is changed.
      Generally windows will only send these messages when an item is first expanded. It depends on the TVIS_EXPANDEDONCE state. (see in Platform SDK the TVM_EXPAND Message for more details.)
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeView.Toggle>
  <TreeView.VisibleCount>
    <summary>
      A numeric value representing the number of tree view items that are fully visible in the tree view.
    </summary>
    <value>A numeric value representing the number of tree view items that are fully visible in the tree view.</value>
  </TreeView.VisibleCount>
  <TreeView_CompareDelegate.ctor>
    <exclude />
  </TreeView_CompareDelegate.ctor>
  <TreeView_CompareDelegate.BeginInvoke>
    <exclude />
  </TreeView_CompareDelegate.BeginInvoke>
  <TreeView_CompareDelegate.EndInvoke>
    <exclude />
  </TreeView_CompareDelegate.EndInvoke>
  <TreeView_CompareDelegate.Invoke>
    <exclude />
  </TreeView_CompareDelegate.Invoke>
  <TreeViewDeleteEvent>
    <summary>
      Provide information about a tree view delete event, which is generated when an item in a tree view control is deleted.
    </summary>
    <remarks>
      The tree view control generates this event whenever one of its items is deleted. The information packaged with this event object includes which item was deleted so that the application can process any information stored in the TreeViewItem object.

    </remarks>
  </TreeViewDeleteEvent>
  <TreeViewDeleteEvent.ctor>
    <inheritdoc />
  </TreeViewDeleteEvent.ctor>
  <TreeViewDeleteEvent.TreeViewItem>
    <summary>
      The TreeViewItem object which was deleted.
    </summary>
    <value>The TreeViewItem object which was deleted.</value>
  </TreeViewDeleteEvent.TreeViewItem>
  <TreeViewDragEvent>
    <summary>
      Provide information about a tree view drag event, which is generated when an item in a tree view control is dragged.
    </summary>
    <remarks>
      The tree view control generates this event whenever one of its items is dragged. The user can use either the right or the left mouse button to generate the event and can take different courses of action depending on which mouse button is currently being used.

    </remarks>
  </TreeViewDragEvent>
  <TreeViewDragEvent.ctor>
    <inheritdoc />
  </TreeViewDragEvent.ctor>
  <TreeViewDragEvent.IsLeftButton>
    <summary>
      A logical value that is TRUE if this is a left-button drag.
    </summary>
    <value>A logical value that is TRUE if this is a left-button drag.</value>
  </TreeViewDragEvent.IsLeftButton>
  <TreeViewDragEvent.IsRightButton>
    <summary>
      A logical value that is TRUE if this is a right-button drag.
    </summary>
    <value>A logical value that is TRUE if this is a right-button drag.</value>
  </TreeViewDragEvent.IsRightButton>
  <TreeViewDragEvent.ListViewItem>
    <summary>
      The TreeViewItem object which is being dragged.
    </summary>
    <value>The TreeViewItem object which is being dragged.</value>
  </TreeViewDragEvent.ListViewItem>
  <TreeViewDragEvent.Position>
    <summary>
      A Point object that describes the initial position of the drag in tree view control coordinates.
    </summary>
    <value>A Point object that describes the initial position of the drag in tree view control coordinates.</value>
  </TreeViewDragEvent.Position>
  <TreeViewDragEvent.TreeViewItem>
    <summary>
      The TreeViewItem object which was dragged.
    </summary>
    <value>The TreeViewItem object which was dragged.</value>
  </TreeViewDragEvent.TreeViewItem>
  <TreeViewEditEvent>
    <summary>
      Provide information about a tree view edit event, which is generated when the label of an item in a tree view control is edited.
    </summary>
    <remarks>
      The tree view control generates this event whenever the label of one of its items is edited. The event is actually generated twice for any edit operation: once at the beginning of the edit and once at the end. Properties of this object can determine whether the edit is beginning or ending.

    </remarks>
  </TreeViewEditEvent>
  <TreeViewEditEvent.ctor>
    <inheritdoc />
  </TreeViewEditEvent.ctor>
  <TreeViewEditEvent.EditBeginning>
    <summary>
      A logical value that is TRUE if the edit is beginning.
    </summary>
    <value>A logical value that is TRUE if the edit is beginning.</value>
  </TreeViewEditEvent.EditBeginning>
  <TreeViewEditEvent.EditEnding>
    <summary>
      A logical value that is TRUE if the edit is ending.
    </summary>
    <value>A logical value that is TRUE if the edit is ending.</value>
  </TreeViewEditEvent.EditEnding>
  <TreeViewEditEvent.EditText>
    <summary>
      The Changed label of the TreeViewItem object.
    </summary>
    <value>The Changed label of the TreeViewItem object.</value>
  </TreeViewEditEvent.EditText>
  <TreeViewEditEvent.TreeViewItem>
    <summary>
      The TreeViewItem object which is being edited.
    </summary>
    <value>The TreeViewItem object which is being edited.</value>
  </TreeViewEditEvent.TreeViewItem>
  <TreeViewExpandedEvent>
    <summary>
      Provide information about a tree view expanded event, which is generated when an item in a tree view is expanded or collapsed, exposing or hiding its children.
    </summary>
    <remarks>
      The tree view control generates this event whenever one of its items is expanded or collapsed. Information packaged in the event object includes which item is affected and if the item is collapsed or expanded.

    </remarks>
  </TreeViewExpandedEvent>
  <TreeViewExpandedEvent.ctor>
    <inheritdoc />
  </TreeViewExpandedEvent.ctor>
  <TreeViewExpandedEvent.Collapsed>
    <summary>
      A logical value that is TRUE if the item is collapsed.
    </summary>
    <value>A logical value that is TRUE if the item is collapsed.</value>
  </TreeViewExpandedEvent.Collapsed>
  <TreeViewExpandedEvent.Expanded>
    <summary>
      A logical value that is TRUE if the item is expanded.
    </summary>
    <value>A logical value that is TRUE if the item is expanded.</value>
  </TreeViewExpandedEvent.Expanded>
  <TreeViewExpandedEvent.TreeViewItem>
    <summary>
      The TreeViewItem object which is being modified.
    </summary>
    <value>The TreeViewItem object which is being modified.</value>
  </TreeViewExpandedEvent.TreeViewItem>
  <TreeViewExpandingEvent>
    <summary>
      Provide information about a tree view expanding event, which is generated when an item in a tree view is about to be expanded or collapsed, exposing or hiding its children.
    </summary>
    <remarks>
      The tree view control generates this event whenever one of its items is about to be expanded or collapsed. Information packaged in the event object includes which item is affected. The primary difference between this object and the TreeViewExpandedEvent is that this event is generated before the expand/collapse action occurs.

    </remarks>
  </TreeViewExpandingEvent>
  <TreeViewExpandingEvent.ctor>
    <inheritdoc />
  </TreeViewExpandingEvent.ctor>
  <TreeViewExpandingEvent.TreeViewItem>
    <summary>
      The TreeViewItem object which is being modified.
    </summary>
    <value>The TreeViewItem object which is being modified.</value>
  </TreeViewExpandingEvent.TreeViewItem>
  <TreeViewItem>
    <summary>
      Create a tree view item.
    </summary>
    <remarks>
      A tree view item describes an item in a tree view control.
    </remarks>
  </TreeViewItem>
  <TreeViewItem.ctor>
    <summary>
      Construct a tree view item.
    </summary>
    <param name="sName">The symbolic name for the tree view item.</param>
    <param name="cTextVal">The text value of the tree view item.</param>
    <param name="uVal">The usual value associated with the tree view item.</param>
    <param name="iImage">A numeric value that represents the index of the tree view item's image in the image list.</param>
    <param name="iSelImage">A numeric value that represents the index of the tree view item's selected image in the image list.</param>
  </TreeViewItem.ctor>
  <TreeViewItem.Bold>
    <summary>
      A logical value that is TRUE if the text of the tree view item is bold.
    </summary>
    <value>A logical value that is TRUE if the text of the tree view item is bold.</value>
  </TreeViewItem.Bold>
  <TreeViewItem.Collapse>
    <summary>
      Collapse the tree view item, hiding its child items.
    </summary>
    <param name="lAll">** missing parameter documentation **</param>
    <param name="lForceNotify">** missing parameter documentation **</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeViewItem.Collapse>
  <TreeViewItem.Delete>
    <summary>
      Delete the tree view item.
    </summary>
    <param name="lChildrenOnly">
      New logic parameter which defaults to FALSE.
      If lChildrenOnly is TRUE only the child items are deleted
    </param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeViewItem.Delete>
  <TreeViewItem.Disabled>
    <summary>
      A logical value that is TRUE if the image of the tree view item is disabled.
    </summary>
    <value>A logical value that is TRUE if the image of the tree view item is disabled.</value>
  </TreeViewItem.Disabled>
  <TreeViewItem.DropTarget>
    <summary>
      A logical value that is TRUE if the tree view item is highlighted as the target of a drag-and-drop operation.
    </summary>
    <value>A logical value that is TRUE if the tree view item is highlighted as the target of a drag-and-drop operation.</value>
  </TreeViewItem.DropTarget>
  <TreeViewItem.Expand>
    <summary>
      Expand the tree view item, showing its child items.
    </summary>
    <param name="lAll">** missing parameter documentation **</param>
    <param name="lForceNotify">** missing parameter documentation **</param>
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
  </TreeViewItem.Expand>
  <TreeViewItem.Expanded>
    <summary>
      A logical value that determines if the tree view item is expanded or collapsed.
    </summary>
    <value>A logical value that determines if the tree view item is expanded or collapsed.</value>
  </TreeViewItem.Expanded>
  <TreeViewItem.FirstChild>
    <summary>
      The first child item of the tree view item.
    </summary>
    <value>The first child item of the tree view item.</value>
  </TreeViewItem.FirstChild>
  <TreeViewItem.Focused>
    <summary>
      A logical value that is TRUE if the tree view item is focused.
    </summary>
    <value>A logical value that is TRUE if the tree view item is focused.</value>
  </TreeViewItem.Focused>
  <TreeViewItem.ImageIndex>
    <summary>
      A numeric value that represents the index of the tree view item's image in the image list.
    </summary>
    <value>A numeric value that represents the index of the tree view item's image in the image list.</value>
  </TreeViewItem.ImageIndex>
  <TreeViewItem.NameSym>
    <summary>
      The symbolic name for the tree view item.
    </summary>
    <value>The symbolic name for the tree view item.</value>
  </TreeViewItem.NameSym>
  <TreeViewItem.NextSibling>
    <summary>
      The next sibling item of the tree view item.
    </summary>
    <value>The next sibling item of the tree view item.</value>
  </TreeViewItem.NextSibling>
  <TreeViewItem.OverlayImageIndex>
    <summary>
      A numeric value that represents the index of the tree view item's overlay image in the image list. Overlay images are images that are drawn over the item's main image. A tree view can have up to four overlay images, so this value can be in the range of 1 to 4.
    </summary>
    <value>A numeric value that represents the index of the tree view item's overlay image in the image list. Overlay images are images that are drawn over the item's main image. A tree view can have up to four overlay images, so this value can be in the range of 1 to 4.</value>
  </TreeViewItem.OverlayImageIndex>
  <TreeViewItem.Parent>
    <summary>
      The parent TreeView object of the tree view item.
    </summary>
    <value>The parent TreeView object of the tree view item.</value>
  </TreeViewItem.Parent>
  <TreeViewItem.PreviousSibling>
    <summary>
      The previous sibling item of the tree view item.
    </summary>
    <value>The previous sibling item of the tree view item.</value>
  </TreeViewItem.PreviousSibling>
  <TreeViewItem.Selected>
    <summary>
      A logical value that is TRUE if the tree view item is selected.
    </summary>
    <value>A logical value that is TRUE if the tree view item is selected.</value>
  </TreeViewItem.Selected>
  <TreeViewItem.SelectedImageIndex>
    <summary>
      A numeric value that represents the index of the tree view item's selected image in the image list. Selected images are displayed in place of an item's normal image when the item is selected.
    </summary>
    <value>A numeric value that represents the index of the tree view item's selected image in the image list. Selected images are displayed in place of an item's normal image when the item is selected.</value>
  </TreeViewItem.SelectedImageIndex>
  <TreeViewItem.StateImageIndex>
    <summary>
      A numeric value that represents the index of the tree view item's state image in the state image list. State images are images that are drawn next to the item's main image.
    </summary>
    <value>A numeric value that represents the index of the tree view item's state image in the state image list. State images are images that are drawn next to the item's main image.</value>
  </TreeViewItem.StateImageIndex>
  <TreeViewItem.TextValue>
    <summary>
      The text value of the tree view item.
    </summary>
    <value>The text value of the tree view item.</value>
  </TreeViewItem.TextValue>
  <TreeViewItem.TreeViewControl>
    <summary>
      The TreeView object identifying the TreeView control to which the current tree view item is linked.
    </summary>
    <value>The TreeView object identifying the TreeView control to which the current tree view item is linked.</value>
  </TreeViewItem.TreeViewControl>
  <TreeViewItem.Value>
    <summary>
      The usual value associated with the tree view item.
    </summary>
    <value>The usual value associated with the tree view item.</value>
  </TreeViewItem.Value>
  <TreeViewKeyEvent>
    <summary>
      Provide information about a tree view key event, which is generated when a key is pressed while the tree view control has the input focus.
    </summary>
    <remarks>
      The tree view control generates this event whenever a key is pressed while the tree view control has the input focus. Information packaged with this event includes the virtual key code of the pressed key.

    </remarks>
  </TreeViewKeyEvent>
  <TreeViewKeyEvent.ctor>
    <inheritdoc />
  </TreeViewKeyEvent.ctor>
  <TreeViewKeyEvent.KeyCode>
    <summary>
      The virtual key code of the key that was pressed.
    </summary>
    <value>The virtual key code of the key that was pressed.</value>
  </TreeViewKeyEvent.KeyCode>
  <TreeViewMouseEvent>
    <summary>
      Provide information about a tree view mouse event, which is generated when a mouse button in a tree view control is clicked or double-clicked.
    </summary>
    <remarks>
      This event occurs when a mouse click or double-click occurs within the tree view control. Properties of the event determine not only the position where the event occurred physically but also the event's relationship to items in the control.

    </remarks>
  </TreeViewMouseEvent>
  <TreeViewMouseEvent.ctor>
    <summary>Construct a TreeViewMouseEvent object.</summary>
    <param name="oControlNotifyEvent">The ControlNotifyEvent that occurred when the event happened.</param>

  </TreeViewMouseEvent.ctor>
  <TreeViewMouseEvent.ButtonID>
    <summary>
      A constant representing which mouse button was clicked. The value can be either BUTTONLEFT or BUTTONRIGHT.
    </summary>
    <value>A constant representing which mouse button was clicked. The value can be either BUTTONLEFT or BUTTONRIGHT.</value>
  </TreeViewMouseEvent.ButtonID>
  <TreeViewMouseEvent.IsLeftButton>
    <summary>
      A logical value that is TRUE if this is a left-button event.
    </summary>
    <value>A logical value that is TRUE if this is a left-button event.</value>
  </TreeViewMouseEvent.IsLeftButton>
  <TreeViewMouseEvent.IsRightButton>
    <summary>
      A logical value that is TRUE if this is a right-button event.
    </summary>
    <value>A logical value that is TRUE if this is a right-button event.</value>
  </TreeViewMouseEvent.IsRightButton>
  <TreeViewMouseEvent.PointAboveClientArea>
    <summary>
      A logical value that is TRUE if the click occurred above the tree view control's client area.
    </summary>
    <value>A logical value that is TRUE if the click occurred above the tree view control's client area.</value>
  </TreeViewMouseEvent.PointAboveClientArea>
  <TreeViewMouseEvent.PointBelowClientArea>
    <summary>
      A logical value that is TRUE if the click occurred below the tree view control's client area.
    </summary>
    <value>A logical value that is TRUE if the click occurred below the tree view control's client area.</value>
  </TreeViewMouseEvent.PointBelowClientArea>
  <TreeViewMouseEvent.PointLeftOfClientArea>
    <summary>
      A logical value that is TRUE if the click occurred to the left of the tree view control's client area.
    </summary>
    <value>A logical value that is TRUE if the click occurred to the left of the tree view control's client area.</value>
  </TreeViewMouseEvent.PointLeftOfClientArea>
  <TreeViewMouseEvent.PointNowhere>
    <summary>
      A logical value that is TRUE if the click occurred inside the tree view control but not on an item.
    </summary>
    <value>A logical value that is TRUE if the click occurred inside the tree view control but not on an item.</value>
  </TreeViewMouseEvent.PointNowhere>
  <TreeViewMouseEvent.PointOnItem>
    <summary>
      A logical value that is TRUE if the click occurred on a tree view item in the tree view control.
    </summary>
    <value>A logical value that is TRUE if the click occurred on a tree view item in the tree view control.</value>
  </TreeViewMouseEvent.PointOnItem>
  <TreeViewMouseEvent.PointOnItemButton>
    <summary>
      A logical value that is TRUE if the click occurred on a tree view item's button in the tree view control.
    </summary>
    <value>A logical value that is TRUE if the click occurred on a tree view item's button in the tree view control.</value>
  </TreeViewMouseEvent.PointOnItemButton>
  <TreeViewMouseEvent.PointOnItemImage>
    <summary>
      A logical value that is TRUE if the click occurred on a tree view item's image in the tree view control.
    </summary>
    <value>A logical value that is TRUE if the click occurred on a tree view item's image in the tree view control.</value>
  </TreeViewMouseEvent.PointOnItemImage>
  <TreeViewMouseEvent.PointOnItemIndent>
    <summary>
      A logical value that is TRUE if the click occurred on a tree view item's indented area in the tree view control.
    </summary>
    <value>A logical value that is TRUE if the click occurred on a tree view item's indented area in the tree view control.</value>
  </TreeViewMouseEvent.PointOnItemIndent>
  <TreeViewMouseEvent.PointOnItemLabel>
    <summary>
      A logical value that is TRUE if the click occurred on a tree view item's label in the tree view control.
    </summary>
    <value>A logical value that is TRUE if the click occurred on a tree view item's label in the tree view control.</value>
  </TreeViewMouseEvent.PointOnItemLabel>
  <TreeViewMouseEvent.PointOnItemRight>
    <summary>
      A logical value that is TRUE if the click occurred to the right of a tree view item in the tree view control.
    </summary>
    <value>A logical value that is TRUE if the click occurred to the right of a tree view item in the tree view control.</value>
  </TreeViewMouseEvent.PointOnItemRight>
  <TreeViewMouseEvent.PointOnItemStateImage>
    <summary>
      A logical value that is TRUE if the click occurred on a tree view item's state image in the tree view control.
    </summary>
    <value>A logical value that is TRUE if the click occurred on a tree view item's state image in the tree view control.</value>
  </TreeViewMouseEvent.PointOnItemStateImage>
  <TreeViewMouseEvent.PointRightOfClientArea>
    <summary>
      A logical value that is TRUE if the click occurred to the right of the tree view control's client area.
    </summary>
    <value>A logical value that is TRUE if the click occurred to the right of the tree view control's client area.</value>
  </TreeViewMouseEvent.PointRightOfClientArea>
  <TreeViewMouseEvent.Position>
    <summary>
      A Point object that describes the position where the click occurred in tree view control coordinates.
    </summary>
    <value>A Point object that describes the position where the click occurred in tree view control coordinates.</value>
  </TreeViewMouseEvent.Position>
  <TreeViewMouseEvent.TreeViewItem>
    <summary>
      The TreeViewItem object which was clicked, if the mouse click occurred on an item; otherwise, a null object.
    </summary>
    <value>The TreeViewItem object which was clicked, if the mouse click occurred on an item; otherwise, a null object.</value>
  </TreeViewMouseEvent.TreeViewItem>
  <TreeViewSelectionEvent>
    <summary>
      Provide information about a tree view selection event, which is generated when the current selection in a tree view control has changed or is about to change.
    </summary>
    <remarks>
      The tree view control generates this event whenever the current selection changes or is about to change. Information packaged in the event includes what caused the selection to change, as well as which item gained selection focus and which item lost it.

    </remarks>
  </TreeViewSelectionEvent>
  <TreeViewSelectionEvent.ctor>
    <inheritdoc />
  </TreeViewSelectionEvent.ctor>
  <TreeViewSelectionEvent.KeyBoardAction>
    <summary>
      A logical value indicating whether the selection change was caused by a key press.
    </summary>
    <value>A logical value indicating whether the selection change was caused by a key press.</value>
  </TreeViewSelectionEvent.KeyBoardAction>
  <TreeViewSelectionEvent.MouseAction>
    <summary>
      A logical value indicating whether the selection change was caused by a mouse click.
    </summary>
    <value>A logical value indicating whether the selection change was caused by a mouse click.</value>
  </TreeViewSelectionEvent.MouseAction>
  <TreeViewSelectionEvent.NewTreeViewItem>
    <summary>
      The TreeViewItem object that is selected as a result of this event.
    </summary>
    <value>The TreeViewItem object that is selected as a result of this event.</value>
  </TreeViewSelectionEvent.NewTreeViewItem>
  <TreeViewSelectionEvent.OldTreeViewItem>
    <summary>
      The TreeViewItem object that was selected before this event occurred.
    </summary>
    <value>The TreeViewItem object that was selected before this event occurred.</value>
  </TreeViewSelectionEvent.OldTreeViewItem>
  <TreeViewSelectionEvent.SelectionChanged>
    <summary>
      A logical value indicating whether the selection has changed.
    </summary>
    <value>A logical value indicating whether the selection has changed.</value>
  </TreeViewSelectionEvent.SelectionChanged>
  <TreeViewSelectionEvent.SelectionChanging>
    <summary>
      A logical value indicating whether the selection is about to change.
    </summary>
    <value>A logical value indicating whether the selection is about to change.</value>
  </TreeViewSelectionEvent.SelectionChanging>
  <TreeViewSelectionEvent.UnknownAction>
    <summary>
      A logical value indicating whether the selection change was caused by an unknown source.
    </summary>
    <value>A logical value indicating whether the selection change was caused by an unknown source.</value>
  </TreeViewSelectionEvent.UnknownAction>
  <VerticalScrollBar>
    <summary>
      Create a vertical scroll bar.
    </summary>
    <remarks>
      There are two types of vertical scroll bars in X#: regular (created with CLASS VerticalScrollBar) and window (created with the AppWindow:EnableVerticalScroll() method). Both types have an owner window and can be manipulated using Window:VerticalScroll(). However, a window vertical scroll bar differs in that it automatically appears aligned along the right side of its owner window's canvas area and also resizes itself according to the size of its owner window.
      A vertical scroll bar allows the user to update a short integer numeric value by either moving the thumb position, clicking on the button at either end of the scroll bar to change the number by the designated ScrollBar:UnitSize, or by clicking in the interior of the scroll bar to change the number by the designated ScrollBar:BlockSize. The minimum and maximum allowable numeric values are indicated by the Min and Max values for the Range object associated with the scroll bar. The ScrollBar:Value access indicates the currently selected numeric value. A scroll bar may be bound to a numeric field in a server.
      <note type="tip">By default, Window:VerticalScroll() updates the thumb position in the scroll bar; if desired, you can change this by using your own implementation of this handler.</note>

      In Windows, vertical scroll bars are equivalent to a scroll bar with the SBS_VERT style. These are normally specified in the resource entity like this:
      <code language="X#">
        RESOURCE IDD_ABOUT DIALOG 20, 20, 160, 120
        STYLE WS_POPUP | WS_DLGFRAME
        BEGIN
        CONTROL "", IDS_RED, "scrollbar", SBS_VERT, 10, 16, 24, 100
        END
      </code>
    </remarks>
  </VerticalScrollBar>
  <VerticalScrollBar.ctor>
    <summary>
      Construct a vertical scroll bar.
    </summary>
    <param name="oOwner">The window that owns the vertical scroll bar.</param>
    <param name="xID">The unique ID between 1 and 8000 of the vertical scroll bar.</param>
    <param name="oPoint">The origin of the vertical scroll bar in canvas coordinates.</param>
    <param name="oDimension">The dimension of the vertical scroll bar in canvas coordinates.</param>
    <param name="oResourceID">The resource ID of the vertical scroll bar.</param>
  </VerticalScrollBar.ctor>
  <VerticalScrollBar.Destroy>
    <summary>
      Provide a method to de-instantiate a VerticalScrollBar object.
    </summary>
    <remarks>
      This method can be used when a VerticalScrollBar object is no longer needed. VerticalScrollBar:Destroy() de-instantiates the VerticalScrollBar object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </VerticalScrollBar.Destroy>
  <VerticalSelectionSlider>
    <summary>
      Create a vertical selection slider control.
    </summary>
    <remarks>
      A vertical selection slider is a control that contains a thumb, optional tick marks, and a selection bar. The user can move the vertical selection slider's thumb using either the mouse or the Direction keys.
    </remarks>
  </VerticalSelectionSlider>
  <VerticalSelectionSlider.ctor>
    <summary>
      Construct a vertical selection slider.
    </summary>
    <param name="oOwner">The window that owns the vertical selection slider.</param>
    <param name="xID">The unique ID between 1 and 8000 of the vertical selection slider.</param>
    <param name="nResourceID">The resource ID of vertical selection slider.</param>
    <param name="oPoint">The origin of the vertical selection slider in canvas coordinates.</param>
    <param name="oDimension">The dimension of the vertical selection slider in canvas coordinates.</param>
  </VerticalSelectionSlider.ctor>
  <VerticalSlider>
    <summary>
      Create a vertical slider control.
    </summary>
    <remarks>
      A vertical slider is a control that contains a thumb and optional tick marks. The user can move the vertical slider's thumb using either the mouse or the Direction keys.
    </remarks>
  </VerticalSlider>
  <VerticalSlider.ctor>
    <summary>
      Construct a vertical slider.
    </summary>
    <param name="oOwner">The window that owns the vertical slider.</param>
    <param name="xID">The unique ID between 1 and 8000 of the vertical slider.</param>
    <param name="nResourceID">The resource ID of vertical slider.</param>
    <param name="oPoint">The origin of the vertical slider in canvas coordinates.</param>
    <param name="oDimension">The dimension of the vertical slider in canvas coordinates.</param>
  </VerticalSlider.ctor>
  <VerticalSpinner>
    <summary>
      Create a spinner with vertical arrow buttons.
    </summary>
    <remarks>
      A vertical spinner is a pair of up- and down-pointing arrow buttons that can be clicked to change a value, such as a number displayed in another control. A vertical spinner can exist independently but is most often used with another control, referred to as the client.
    </remarks>
  </VerticalSpinner>
  <VerticalSpinner.ctor>
    <summary>
      Construct a vertical spinner.
    </summary>
    <param name="oOwner">The window that owns the vertical spinner.</param>
    <param name="xID">The unique ID between 1 and 8000 of the vertical spinner.</param>
    <param name="nResourceID">The resource ID of the vertical spinner.</param>
    <param name="oPoint">The origin of the vertical spinner in canvas coordinates.</param>
    <param name="oDimension">The dimension of the vertical spinner in canvas coordinates.</param>
    <param name="kStyle">The style of the vertical spinner.</param>
  </VerticalSpinner.ctor>
  <VObject>
    <summary>
      Define the class on which all other GUI classes are based.
    </summary>
    <example>
      When you define a method (such as in the example below) or property for this class, it becomes available to all other GUI classes:
      <code language="X#">
        METHOD Save() CLASS VObject
        ...
        RETURN lSuccess
      </code>
    </example>
  </VObject>
  <VObject.ctor>
    <summary>
      Construct a VObject object.
    </summary>
  </VObject.ctor>
  <VObject.Destroy>
    <summary>
      Free memory resources allocated for an object and its derived objects.
    </summary>
  </VObject.Destroy>
  <WarningBox>
    <summary>
      Create a warning message box.
    </summary>
    <remarks>
      A warning message box is a window that displays a user-defined caption in the title bar, the text of the warning, and a warning icon. These boxes are typically used to alert users to a potential error or undesirable situation. For example, you might display a warning box to confirm a delete request on a particular file (like, "Are you sure you want to delete COMMAND.COM?").
      <note type="tip">A warning box is application modal; therefore, the user must acknowledge it before continuing with the application. When the warning box closes, focus is returned to its owner window.</note>
    </remarks>
  </WarningBox>
  <WarningBox.ctor>
    <summary>
      Create a warning box.
    </summary>
    <param name="uParent">The window that owns the warning box. If omitted, the owner is the desktop, and the warning box is application modal (that is, the application is suspended until the user acknowledges the warning box).</param>
    <param name="uCaption">
      The text to be displayed in the title bar of the warning box or
      the hyperlabel containing a caption and description for the warning box. If omitted, the default caption is 'Warning' and the default description is 'Warning...'.
    </param>
    <param name="uText">The information to be printed in the warning box when it is shown. If omitted, the default is NULL_STRING.</param>
  </WarningBox.ctor>
  <WCError>
    <exclude />
  </WCError>
  <WCError.ctor>
    <exclude />
  </WCError.ctor>
  <Win32.ClosePrinter>
    <exclude />
  </Win32.ClosePrinter>
  <Win32.DeviceCapabilities>
    <exclude />
  </Win32.DeviceCapabilities>
  <Win32.DocumentProperties>
    <exclude />
  </Win32.DocumentProperties>
  <Win32.OpenPrinter>
    <exclude />
  </Win32.OpenPrinter>
  <WinDLLVersion>
    <summary>
      Get the version info from DLLs.
    </summary>
    <remarks>
      This will get the version information from DLLs. The DLL must contain a function called DllGetVersion which fills in a _WINDLLVERSIONINFO structure.
      This convention for determining DLL version is followed by Windows DLLs such as Shell32.DLL.
    </remarks>
  </WinDLLVersion>
  <WinDLLVersion.ctor>
    <summary>
      Construct a WinDLLVersion object.
    </summary>
    <param name="cDLLName">The name of the DLL as a string.</param>
    <remarks>
      This will create a WinDLLVersion object arround the DLL passed as the parameter.
      The DLL must contain a function called DllGetVersion which fills in a _WINDLLVERSIONINFO structure.
      This convention for determining DLL version is followed by Windows DLLs such as Shell32.DLL.
    </remarks>
  </WinDLLVersion.ctor>
  <WinDLLVersion.DLL>
    <summary>
      The string representing the name of the DLL.
    </summary>
    <value>The string representing the name of the DLL.</value>
  </WinDLLVersion.DLL>
  <WinDLLVersion.IsWinNT>
    <summary>
      A Logical value regarding the platform that the DLL was developed for.
    </summary>
    <value>A Logical value regarding the platform that the DLL was developed for.</value>
  </WinDLLVersion.IsWinNT>
  <Window>
    <summary>
      Provide the base class from which all X# windows are subclassed.
    </summary>
    <remarks>
      Windows are central to every GUI. GUI windows can be thought of in two ways:
      As presentation objects with their visual representation on the screen
      As event handlers which process user interactions
      Each type of event goes to the appropriate event handler provided by subclasses of class Window.
      Event handler methods of the Window class are the system's default event handlers. By overriding these in subclasses, you change the behavior of your derived window from the default behavior provided by the Window class.
    </remarks>
  </Window>
  <Window.ctor>
    <summary>
      Construct a Window object.
    </summary>
    <param name="oOwner">The window that owns this window.</param>
    <remarks>
      The window initialization code generated by the Window Editor calls PreInit() and PostInit() at the beginning and the end, respectively, of the Init() method. The default implementation returns NIL. Implementation of PreInit()/PostInit(), however, results in customized initialization code which is not overridden by the Window Editor's code generation.
    </remarks>
  </Window.ctor>
  <Window.Accelerator>
    <summary>
      The accelerator table associated with this window.
    </summary>
    <value>The accelerator table associated with this window.</value>
  </Window.Accelerator>
  <Window.Activate>
    <summary>
      Provide a method that is invoked when this window is activated.
    </summary>
    <param name="oEvent">The event that describes which window was activated.</param>
    <seealso cref="T:VO.Event" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The Activate() event occurs at the start of the window's lifetime or when the window is activated after it has been deactivated (for example, by clicking on it with the mouse). The newly active window receives the input focus.

      You should create and show cursors (if needed) in this event handler method.
      Any subclass with its own Activate() and Deactivate() event handlers should always call its owner's handlers. This ensures that the caption bars get highlighted or dimmed accordingly.
    </remarks>
    <seealso cref="T:VO.Event" />
  </Window.Activate>
  <Window.AddTrayIcon>
    <summary>
      Adds a tray icon associated with the window.
    </summary>
    <param name="oTrayIcon">The icon object to add to the tray.</param>
    <param name="dwID">The unique ID of the icon (between 1 and 8000).</param>
    <param name="sToolTip">The tool tip string to be displayed for this icon.</param>
    <remarks>
      <note type="tip">
        If Shell version 5 or above is loaded, the tool tip will support line breaks by using CRLF.
        On older versions of the Shell the CRLF is automatically replaced with a space.
      </note>
    </remarks>
  </Window.AddTrayIcon>
  <Window.Animate>
    <exclude />

  </Window.Animate>
  <Window.AnimationStart>
    <summary>
      Provide a method that is invoked when an animation control begins playback.
    </summary>
    <param name="oControlEvent">The ControlEvent object that describes which animation control started playback.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <seealso cref="T:VO.ControlEvent" />
  </Window.AnimationStart>
  <Window.AnimationStop>
    <summary>
      Provide a method that is invoked when an animation control ends playback.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oControlEvent">The ControlEvent object that describes which animation control ended playback.</param>
    <seealso cref="T:VO.ControlEvent" />
  </Window.AnimationStop>
  <Window.AppCommand>
    <summary>
      Provide a method that is invoked when an AppCommand event takes place.
    </summary>
    <param name="oACEvent">The AppCommandEvent object that describes the event which was initiated.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This event must be overridden in the application and must return TRUE to complete the processing.
    </remarks>
    <seealso cref="T:VO.AppCommandEvent" />
  </Window.AppCommand>
  <Window.Automated>
    <summary>
      A logical value determining whether the window object is to be exposed as an OLE automation server. This is a convenient shortcut for the RegisterOLEAutomationObject() function. When the window is destroyed, the UnRegisterOLEAutomationObject() is automatically called.
    </summary>
    <value>A logical value determining whether the window object is to be exposed as an OLE automation server. This is a convenient shortcut for the RegisterOLEAutomationObject() function. When the window is destroyed, the UnRegisterOLEAutomationObject() is automatically called.</value>
  </Window.Automated>
  <Window.Background>
    <summary>
      The background brush currently in use by this window.
    </summary>
    <remarks>

      The background brush currently in use by this window.
      A window's background brush is used by CanvasErase() and in handling Expose events. Assigning a new background brush has no effect until the window (or portion of the window) is redrawn. If a window was partially covered and is then fully exposed, only the covered part of the window is redrawn and only that part gets the new background.

      This related example will change the background color of an application's main window, and would typically occur in the main Initialize() method:
      <code language="X#">
        oWin:oColour := Color{164,255,164}
        // app background set to light green
        oWin:ShellWithColourOnly()
      </code>

    </remarks>
    <value>
      The background brush currently in use by this window.
    </value>
  </Window.Background>
  <Window.ButtonClick>
    <summary>
      Provide a method that is invoked when a check box, push button, or radio button is clicked with the mouse.
    </summary>
    <param name="oControlEvent">The ControlEvent object that describes which button was clicked.</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      Button click events (radio, check, and push buttons) are propagated to the window's owner the same way as MenuEvents. For an in-depth discussion on command event propagation, refer to the Programmer's Guide.
      You must supply the code to turn a radio button on (and all the other radio buttons off) when a user clicks on a radio button. Similarly, you must also be sure to invert the state of a check box when it is clicked.
    </remarks>
    <example>
      This is a typical example of responding to various button clicks:
      <code language="X#">
        METHOD ButtonClick(oControlEvent) CLASS TeamInfo
        LOCAL oControl 		AS Control
        LOCAL sSym			AS SYMBOL
        oControl := IIf(oControlEvent == NULL_OBJECT, NULL_OBJECT, ;
        oControlEvent:Control)
        SUPER:ButtonClick(oControlEvent)
        //Put your changes here
        sSym := oControl:nameSym
        DO CASE
        CASE sSym == #cbHasSponsor		// a checkbox
        IF SELF:oDCcbHasSponsor:checked
        SELF:oDCsleSponsorName:enable()
        ELSE
        SELF:oDCsleSponsorName:TextValue := SPACE(25)
        SELF:oDCsleSponsorName:disable()
        ENDIF
        CASE sSym == #rbRecreational .or. sSym == #rbCompetition
        // radio buttons
        // Do something in here
        ENDCASE
      </code>
    </example>
  </Window.ButtonClick>
  <Window.ButtonDoubleClick>
    <summary>
      Provide a method that is invoked when a check box, push button, or radio button is double-clicked.
    </summary>
    <param name="oControlEvent">
      The <seealso cref="T:VO.ControlEvent">ControlEvent</seealso> that describes which button was double-clicked.
    </param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <seealso cref="T:VO.ControlEvent" />
  </Window.ButtonDoubleClick>
  <Window.CanvasArea>
    <summary>
      The bounding box representing the current size of this window's canvas area.
    </summary>
    <value>The bounding box representing the current size of this window's canvas area.</value>
  </Window.CanvasArea>
  <Window.CanvasErase>
    <summary>
      Erase the current canvas area of this window and repaint it using either the background brush or the system's default background color.
    </summary>
  </Window.CanvasErase>
  <Window.Caption>
    <summary>
      The string representing the caption (the text in the title bar of this window). This method can also be used to change the title of this window.
    </summary>
    <value>The string representing the caption (the text in the title bar of this window). This method can also be used to change the title of this window.</value>
  </Window.Caption>
  <Window.Center>
    <summary>Center the window on its owner, or if the owner is the dektop, then center the window on the desktop.</summary>
    <returns>NIL</returns>
  </Window.Center>
  <Window.Close>
    <summary>
      Invoked just as the window is about to close.
    </summary>
    <param name="oEvent">An empty event required to maintain the protocol that all event handlers have exactly one event as their argument.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      Note that this method is automatically called when an EndDialog() or EndWindow() method is called.
    </remarks>
    <seealso cref="T:VO.Event" />
  </Window.Close>
  <Window.ComboBoxExEndEdit>
    <summary>
      A callback method that is invoked when a ComboBoxEx control sends an 'EndEdit' notification message
    </summary>
    <param name="oComboBoxExEndEditEvent">An object that has the information about the event</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      Provide a method that is invoked when a ComboBoxEx controls sends a CBEN_ENDEDIT message.
    </remarks>
    <seealso cref="T:VO.ComboBoxExEndEditEvent" />
  </Window.ComboBoxExEndEdit>
  <Window.ComboBoxExNotify>
    <summary>
      A callback method that is invoked when a ComboBoxEx control sends a notification message
    </summary>
    <param name="oControlNotifyEvent">An event that has the information about the notify event</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      Provide a method that is invoked when a ComboBoxEx control sends one of the following notification messages.
      CBEN_INSERTITEM, CBEN_DELETEITEM, CBEN_DRAGBEGIN, CBEN_BEGINEDIT and CBEN_ENDEDIT
      Currently this method contains only a message handler for the CBEN_ENDEDIT message,
      which calls the Window:ComboBoxExEndEdit() method.
      If you override this method to process the other messages, don’t forget to call SUPER: ComboBoxExNotify(oControlNotifyEvent) in the otherwise part.
    </remarks>
    <seealso cref="T:VO.ControlNotifyEvent" />
  </Window.ComboBoxExNotify>
  <Window.ContextMenu>
    <summary>
      A menu object representing the local pop-up menu for a window or window control.
    </summary>
    <value>A menu object representing the local pop-up menu for a window or window control.</value>
  </Window.ContextMenu>
  <Window.ControlNotify>
    <summary>
      Provide a method that is invoked when a control sends a notification to its parent window.
    </summary>
    <param name="oControlNotifyEvent">The ControlNotifyEvent object that describes which control sent the notification.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This is a general method that is called whenever a common control sends a notification to its parent window.
      In many cases, a more specific method is invoked in addition to this method in response to the notification.
      Notifiy codes that are not handled by this method are send to the Control:ParentNotify() method when this method is available.
    </remarks>
    <seealso cref="T:VO.ControlNotifyEvent" />
  </Window.ControlNotify>
  <Window.DateTimeSelectionChanged>
    <summary>
      Provide a method that is invoked when a DateTimePicker selection is changed.
    </summary>
    <param name="oDateTimeSelectionEvent">The DateTimeSelectionEvent object that describes which control sent the notification.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <seealso cref="T:VO.DateTimeSelectionEvent" />
  </Window.DateTimeSelectionChanged>
  <Window.DeActivate>
    <summary>
      Provide a method that is invoked when this window is deactivated.
    </summary>
    <param name="oEvent">An empty event required to maintain the protocol that all event handlers have exactly one event as their argument.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This event handler is normally invoked when another application or window becomes activated. If Window:MouseTrapOn() is left on, MouseEvent events cannot be directed to other applications or windows.
    </remarks>
    <seealso cref="T:VO.Event" />
  </Window.DeActivate>
  <Window.DeactivateAllOLEObjects>
    <exclude />
  </Window.DeactivateAllOLEObjects>
  <Window.Default>
    <summary>Call the default windows procedure for a window and set the EventReturnValue for the object.</summary>
    <param name="oEvent">The event that occurred for the control.</param>
    <returns>NIL</returns>
    <seealso cref="T:VO.Event" />
  </Window.Default>
  <Window.DeleteTrayIcon>
    <exclude />

  </Window.DeleteTrayIcon>
  <Window.Destroy>
    <summary>
      Free memory resources allocated for a window and its derived objects.
    </summary>
    <remarks>
      This method immediately frees resources for Window objects created explicitly in your application. Window:Destroy() also takes care of resources allocated to derived classes and deallocates them in the necessary order (e.g., child windows are destroyed before the parent window, dialog windows and MDI shell windows are also looked after).
    </remarks>
    <returns>NIL</returns>
  </Window.Destroy>
  <Window.Disable>
    <summary>
      Disable this window (until a subsequent call to Enable()).
    </summary>
    <remarks>
      Disabled windows no longer receive mouse and keyboard events.
    </remarks>
    <returns>NIL</returns>
  </Window.Disable>
  <Window.Dispatch>
    <summary>
      Provide the dispatcher for events within the system when the window has focus;
      routing various events to their appropriate event handlers.
    </summary>
    <param name="oEvent">The event to be handled.</param>
    <seealso cref="T:VO.Event" />
    <returns>
      A numeric value representing the event handler to handle the event. This is usually the value of the EventReturnValue field.
    </returns>
    <remarks>
      Windows receive events from the user and the system all of the time. Each window receives only the events that are
      relevant to it. For each event that is generated, two things happen:
      1.	The event is converted to a particular Event object (an ExposeEvent or a MouseEvent, for example) according to the action that triggered the event.
      2.	The appropriate event handler is called, and this typed Event object is passed to it.
      <note type="tip">
        If you want to set a specific return value for the underlying window procedure, you have to change the EventReturnValue variable for the window object.
        If you want to handle other events (for example, timer events), you need to write your own Dispatch() method.
        The following guidelines should be followed when writing a customized Dispatch() method:
        1.	Subclass an event type appropriate to the type of operation for which it is being used.
        2.	Add an event handler function to your derived object. (This event handler should be called with the event when the event is received.)
        3.	In general, the implementation of this event handler should call Default(). This keeps the same behavior as the base class, but it also
        allows other classes to provide useful event handlers for your new type of event, allowing you to provide a framework for other classes to use.
        The base class Dispatch() method should be called in those cases where the received event is not handled by the customized dispatcher.
        For example:
        <code language="X#">RETURN SUPER:Dispatch(&lt;oEvent&gt;)</code>
      </note>
      You can now write a DispatchUnknown( oEvent ) method on your own window class to handle messages that are not processed by the window.
      When this message exists then it will be automatically called by the Dispatch() method inside the Window class.
      <example>
        <code language="X#">
          METHOD DispatchUnknown(oEvent) CLASS MyCustomWindow
          // Your code
          // If you need the default window
          //	procedure call SELF:Default(oEvent)
          // Assign the event return value to SELF:EventReturnValue,
          //	the default value is 0l.
          SELF:EventReturnValue := 1l
        </code>
      </example>
    </remarks>
  </Window.Dispatch>
  <Window.DragDropClient>
    <summary>
      The DragDropClient object created when Window:EnableDragDropClient(TRUE) is called.
    </summary>
    <value>The DragDropClient object created when Window:EnableDragDropClient(TRUE) is called.</value>
  </Window.DragDropClient>
  <Window.DragDropServer>
    <summary>
      The DragDropServer object created when Window:EnableDragDropServer(TRUE) is called.
    </summary>
    <value>The DragDropServer object created when Window:EnableDragDropServer(TRUE) is called.</value>
  </Window.DragDropServer>
  <Window.DragImageList>
    <summary>
      The ImageList object used for a drag-and-drop operation.
    </summary>
    <value>The ImageList object used for a drag-and-drop operation.</value>
  </Window.DragImageList>
  <Window.Draw>
    <summary>
      Display a Draw object on this window.
    </summary>
    <param name="oDrawObject">The object to be drawn, or the array of objects to be drawn.</param>
    <remarks>
      A Draw object is drawn by placing the device context or presentation space into the Draw object and then calling the Draw object's method Draw(). This is the only valid way of drawing a Draw object on a window.
    </remarks>
    <seealso cref="T:VO.DrawObject" />
  </Window.Draw>
  <Window.DrawBackground>
    <summary>
      Draw the background of a window.
    </summary>
    <param name="hdc">The handle of the device context.</param>
    <param name="oWindow">
      The window to be drawn.
      The oWindow object is normally identical with SELF except when SELF is a DataWindow. In this case oWindow should be the oSurface (__FormDialogWindow) object. In a DataWindow you should draw the background only if oWindow == oSurface, otherwise it is superfluous.
    </param>
    <remarks>
      If you draw the background for yourself you should return TRUE otherwise FALSE.
    </remarks>
  </Window.DrawBackground>
  <Window.Drop>
    <summary>
      Retrieve information about a load from the drag event and act on each file in the selection.
    </summary>
    <param name="oDragEvent">The DragEvent that determines the position of the mouse (in canvas coordinates), as well as the number and names of files, in the drag-and-drop load.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The system dispatches this method when the user lets go of the mouse button to drop the load in the client area. This method is required to handle drag-and-drop correctly. It retrieves information about the load from the drag event and acts on each file in the selection.
    </remarks>
    <seealso cref="T:VO.DragEvent" />
  </Window.Drop>
  <Window.EditChange>
    <summary>
      Provide a method that is invoked when the text in an edit control is changed.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oControlEvent">The ControlEvent object that describes which edit control was changed.</param>
    <seealso cref="T:VO.ControlEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.EditChange>
  <Window.EditFocusChange>
    <summary>
      Provide a method that is invoked when the input focus changes to or from an edit control.
    </summary>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    <param name="oEditFocusChangeEvent">The EditFocusChangeEvent object that identifies which edit control generated the EditFocusChangeEvent object and whether it has just gained or lost the keyboard focus.</param>
    <seealso cref="T:VO.EditFocusChangeEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      If Window:EditFocusChange() is used to validate an edit control (and also return the focus to it if invalid), Control:SetFocus() should not be called until another control has received the focus.
      In complex dialog windows that contain many edit controls, it makes sense to grab the edit control's text when the focus is changing so that other controls can be updated with it if necessary.
      See the ButtonClick() method for an example of similar syntax to be used in this method. Note that none of the button controls are passed through this method, only SingleLineEdit and MultiLineEdit controls. If looking to control Combobox selections, then use the ListBoxSelect() callback method.
    </remarks>
  </Window.EditFocusChange>
  <Window.EditScroll>
    <summary>
      Provide a method that is invoked for this window when an edit control is scrolled.
    </summary>
    <param name="oControlEvent">The ControlEvent object that identifies which edit control invoked the event handler.</param>
    <seealso cref="T:VO.ControlEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This type of event normally happens when the user enters more characters in an edit control than it can display.

      In Windows, you must set flags in the resource entity description of the edit control to allow scrolling:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>ES_AUTOHSCROLL</term>
          <description>Automatically scrolls the text horizontally</description>
        </item>
        <item>
          <term>ES_AUTOVSCROLL</term>
          <description>Automatically scrolls the text vertically</description>
        </item>
        <item>
          <term>WS_HSCROLL</term>
          <description>Displays a horizontal scroll bar on the edit control</description>
        </item>
        <item>
          <term>WS_VSCROLL</term>
          <description>Displays a vertical scroll bar on the edit control</description>
        </item>
      </list>
    </remarks>
  </Window.EditScroll>
  <Window.Enable>
    <summary>
      Enable a previously disabled window.
    </summary>
    <remarks>
      Enabling a window allows it to receive mouse and keyboard events. By default, windows are enabled until disabled, so there is no need to call the Window:Enable() method unless Window:Disable() was previously called.
    </remarks>
    <returns>NIL</returns>
  </Window.Enable>
  <Window.EnableCloseBox>
    <summary>
      Enable or Disable the close button on a window (the X )
    </summary>
    <param name="uValue">A logic value indicating if the close box should be enabled (TRUE) or disabled (FALSE).</param>
    <returns>NIL</returns>
  </Window.EnableCloseBox>
  <Window.EnableDragDropClient>
    <summary>
      Allow "draggable" windows to be dropped on this window.
    </summary>
    <param name="lEnable">TRUE enables the window as a drop client. FALSE does not allow this behavior. If omitted, the default is TRUE.</param>
    <returns>NIL</returns>
  </Window.EnableDragDropClient>
  <Window.EnableDragDropClient>
    <inheritdoc />
    <param name="lSurfaceOnly">When a logical value of TRUE is passed then only the surface of the DataWindow is activated.</param>
  </Window.EnableDragDropClient>
  <Window.EnableDragDropServer>
    <summary>
      Allow this window to be dropped on windows with drag and drop capabilities.
    </summary>
    <param name="lEnable">TRUE enables the window as a drag server. FALSE does not allow this behavior. If omitted, the default is TRUE.</param>
    <returns>NIL</returns>
  </Window.EnableDragDropServer>
  <Window.EnableHelp>
    <summary>
      Enable or disable help for a window and its child windows.
    </summary>
    <param name="lEnable">TRUE enables help; FALSE disables help. If not specified, the default is TRUE.</param>
    <param name="oHelpDisplay">A HelpDisplay object specifying the help file to use.</param>
    <remarks>
      This method is called by Window:HelpDisplay().
    </remarks>
    <returns>NIL</returns>
  </Window.EnableHelp>
  <Window.EnableHelpButton>
    <summary>
      Enables the help button in the window caption bar.
    </summary>
    <remarks>
      Enables the help button in the window caption bar. This works only if no maximize or minimize button is present on the caption bar. It is recommended for DialogWindow’s.
      This is recommended only, if you have created the HelpDisplay{} object with lWin32Processing is TRUE.
    </remarks>
    <returns>NIL</returns>
  </Window.EnableHelpButton>
  <Window.EnableHelpCursor>
    <summary>
      Changes the cursor to a question mark with a pointer.
    </summary>
    <remarks>
      Changes the cursor to a question mark with a pointer. If the user then clicks a control the control receives a help request message.
      This is recommended only, if you have created the HelpDisplay{} object with lWin32Processing is TRUE.
    </remarks>
    <returns>NIL</returns>
  </Window.EnableHelpCursor>
  <Window.EnableThemeDialogTexture>
    <summary>
      Enables or disables the visual style of a dialog window's background.
    </summary>
    <param name="dwStyle">
      The style to be set.
      <list type="table">
        <listheader>
          <term>Style</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>
            ETDT_ENABLE
          </term>
          <description>Enables dialog window background texturing. The texturing is defined by a visual style.</description>
        </item>
        <item>
          <term>
            ETDT_ENABLETAB
          </term>
          <description>
            Enables dialog window background texturing. The texture is the Tab control texture defined
            by the visual style. This flag is equivalent to (ETDT_ENABLE | ETDT_USETABTEXTURE).
          </description>
        </item>
        <item>
          <term>
            ETDT_DISABLE
          </term>
          <description>Disables background texturing.</description>
        </item>
        <item>
          <term>
            ETDT_USETABTEXTURE
          </term>
          <description>Uses the Tab control texture for the background texture of a dialog window.</description>
        </item>
      </list>
    </param>
    <remarks>
      This method allows the enabling and disableing of background themes in WinXP and later.
    </remarks>
  </Window.EnableThemeDialogTexture>
  <Window.EnableToolTips>
    <summary>
      Enable or disable the tooltips for a window. Note that assigning a value to Control:ToolTipText automatically enables the tooltip's display on the parent window.
    </summary>
    <param name="lEnable">Logical value indicating whether the tool tips should be enabled (TRUE) or disabled (FALSE). If omitted, the default is TRUE.</param>
    <returns>
      TRUE, if tooltips were enabled; FALSE, if tooltips were disabled.
    </returns>
  </Window.EnableToolTips>
  <Window.EventReturnValue>
    <summary>This field stores the result of the call to the Windows Procedure for the window.</summary>
  </Window.EventReturnValue>
  <Window.Expose>
    <summary>
      Provide a method that is invoked whenever part of the window needs repainting.
    </summary>
    <param name="oExposeEvent">The ExposeEvent object that describes which area of the window needs repainting.</param>
    <seealso cref="T:VO.ExposeEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This is one of the most important event handlers.
      A window requires repainting when the window:
      <list type="bullet">
        <item>Is partially uncovered by another window</item>
        <item>Is first shown</item>
        <item>Increases in size</item>
        <item>Is being restored after being iconized</item>
        <item>The window should retain enough information to redraw the screen as it was (or as it should be).</item>
      </list>
      An ExposeEvent is also triggered by calling Repaint() or Update(); you should not call Repaint() or Update() during the Expose().
    </remarks>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.Expose>
  <Window.FocusChange>
    <summary>
      Provide a method that is invoked when the input focus changes from the current window to another (or vice versa).
    </summary>
    <param name="oFocusChangeEvent">The FocusChangeEvent object that identifies whether the focus is being gained or lost.</param>
    <seealso cref="T:VO.FocusChangeEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      If your window uses cursors, you should hide the window's cursor when the focus is changed to a different window, and then show the cursor when the window receives focus again. This should be used in conjunction with the Window:Activate() and Window:Deactivate() event handlers.
    </remarks>
    <example>
      This example demonstrates how Window:FocusChange() displays the cursor at the specified cursor position when focus is gained. If the focus is lost, the cursor is hidden:
      <code language="X#">
        METHOD FocusChange(oFocusChangeEvt) CLASS MyTopAppWindow
        IF oFocusChangeEvt:GotFocus	 // Gaining focus
        oMyCursor:Show()
        oMyCursor:Position := oMyCursorPos
        ELSE						// Losing focus
        oMyCursorPos := oMyCursor:Position
        oMyCursor:Hide()
        ENDIF
      </code>
    </example>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.FocusChange>
  <Window.Font>
    <summary>
      The font currently used by this window. This font is used by the TextObject:TextPrint() method.
    </summary>
    <value>The font currently used by this window. This font is used by the TextObject:TextPrint() method.</value>
  </Window.Font>
  <Window.Foreground>
    <summary>
      The foreground brush currently in use by this window.
    </summary>
    <value>The foreground brush currently in use by this window.</value>
  </Window.Foreground>
  <Window.GetAllChildren>
    <summary>
      Obtain an array of all X# children objects of the window.
    </summary>
    <returns>
      An array of all X# children objects of the window. This array may contain window objects as well as control objects. Note that controls which do not have a corresponding X# object, like a FixedText control where the Generate Code property was set to "No", are not included in the returned array.
    </returns>
  </Window.GetAllChildren>
  <Window.GetExStyle>
    <summary>
      Retrieve the Ex styles for the window.
    </summary>
    <returns>
      Numeric value representing the X# style constants or Windows API style constants enabled for the window.
    </returns>
  </Window.GetExStyle>
  <Window.GetStyle>
    <summary>
      Retrieve the styles for the window.
    </summary>
    <returns>
      Numeric value representing the X# style constants or Windows API style constants enabled for the window.
    </returns>
  </Window.GetStyle>
  <Window.Handle>
    <summary>
      Return the handle for a window.
    </summary>
    <param name="nHandleType">
      The type of handle required. 0 is the only supported option and is the default if <paramref name="nHandle" /> is omitted.
    </param>
    <returns>
      A handle to the window, describing the underlying system object.
    </returns>
    <remarks>
      This method provides a handle to the window, which can then be used by Windows API calls.
    </remarks>
  </Window.Handle>
  <Window.HasExStyle>
    <summary>Check if an exstyle value has been set for the window</summary>
    <param name="kStyle">The style to check for</param>
    <returns>TRUE when the exstyle is set. Otherwise FALSE.</returns>
  </Window.HasExStyle>
  <Window.HasStyle>
    <summary>Check if a style value has been set for the window</summary>
    <param name="kStyle">The style to check for</param>
    <returns>TRUE when the style is set. Otherwise FALSE.</returns>
  </Window.HasStyle>
  <Window.HelpDisplay>
    <summary>
      The help display object currently used by this window. This help display object provides a connection between the help file to be displayed and this window.
    </summary>
    <value>The help display object currently used by this window. This help display object provides a connection between the help file to be displayed and this window.</value>
    <example>
      The following example handles the default Help menu command:
      <code language="X#">
        CLASS MyWindow INHERIT TopAppWindow
        METHOD Init() CLASS MyWindow
        SUPER:Init()
        SELF:HelpDisplay := HelpDisplay{"mywind.hlp"}
        METHOD MenuCommand(oMCE) CLASS MyWindow
        LOCAL nItemID := oMCE:ItemID
        DO CASE
        CASE nItemID = IDM_MENU_HELP_INDEX_ID
        SELF:HelpDisplay:Show("HelpIndex")
        CASE nItemID = IDM_MENU_HELP_USINGHELP_ID
        SELF:HelpDisplay:Show("HelpOnHelp")
        OTHERWISE
        SUPER:MenuCommand(oMCE)
        ENDCASE
      </code>
    </example>
  </Window.HelpDisplay>
  <Window.HelpRequest>
    <summary>
      Provide a method that is invoked when the user requests help from the application using one of the available context-sensitive help mechanisms.
    </summary>
    <param name="oHelpRequestEvent">The HelpRequestEvent object that describes which item help is being requested for.</param>
    <seealso cref="T:VO.HelpRequestEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This event handler is invoked only if the help mechanism has been enabled for the current window (or one of its owners). The help mechanism is enabled by assigning a HelpDisplay object to the windows HelpDisplay property.
      The default implementation of this event handler is to display the help topic that is associated with the control, menu command, or window region with focus when the HelpRequestEvent was generated. This is accomplished using HelpDisplay:Show(&lt;cKeyword&gt;), where &lt;cKeyword&gt; is either a HyperLabel:HelpContext property or a default keyword generated by this event handler in cases where a hyperlabel is not available.
      If there is no hyperlabel for an item, the keyword generated is as follows:
      A HELPCONTROL request generates the keyword Control_xxxx, where xxxx is the numeric ID of the control, in decimal. For example, an OK push button might generate the keyword Control_101.
      A HELPMENU request generates the keyword Menu_xxxx, where xxxx is the "cleaned" text of the menu command. The cleaned text has all leading and trailing spaces and the ampersand character (&amp;) removed. In addition, all sequences of spaces are replaced by a single underscore, and the string is truncated at the first tab character.
      For example, the keyword generated for the menu command:
      Save &amp;As\tF3
      is
      Menu_Save_As
      A HELPWINDOW request generates one of the keywords listed in the table below, depending on the window region that has focus:
      <list type="table">
        <listheader>
          <term>Keyword</term>
          <description>Window Region</description>
        </listheader>
        <item>
          <term>
            Window_Border
          </term>
          <description>Border</description>
        </item>
        <item>
          <term>
            Window_Caption
          </term>
          <description>Title bar</description>
        </item>
        <item>
          <term>
            Window_MaxBox
          </term>
          <description>Maximize button</description>
        </item>
        <item>
          <term>
            Window_MinBox
          </term>
          <description>Minimize button</description>
        </item>
        <item>
          <term>
            Window_SysMenuBox
          </term>
          <description>System menu button</description>
        </item>
        <item>
          <term>
            Window_Unknown
          </term>
          <description>Any area of the window not explicitly identified in this table</description>
        </item>
        <item>
          <term>
            Window_WindowCanvas
          </term>
          <description>Canvas area</description>
        </item>
      </list>
      <note type="tip">If the Window_Unknown keyword is generated, the default behavior of HelpRequest() is to display the Contents topic as defined in the HelpDisplay (that is, HelpDisplay:Show("HelpIndex")).</note>
      If a HELPWINDOW request is received, while Window:HelpContext is defined, Window:HelpRequest() uses the HelpContext property, regardless of the window region that has focus.
      Refer to the "GUI Classes" chapter in the Programmer's Guide for more information on programming an online help system for your application.
    </remarks>
  </Window.HelpRequest>
  <Window.Hide>
    <summary>
      Hide this window so it is not visible.
    </summary>
    <remarks>
      The window remains hidden from display until the Window:Show() method is called. This method is not used to close a window. Use Window:Hide() to make a window disappear from view, but remain available for re-opening.
    </remarks>
  </Window.Hide>
  <Window.HorizontalScroll>
    <summary>
      Provide a method that is invoked when a horizontal scroll bar is scrolled.
    </summary>
    <param name="oScrollEvent">The ScrollEvent object that describes the scroll type and new position.</param>
    <seealso cref="T:VO.ScrollEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The default behavior for this event handler is to update the thumb position of the scrollbar; this can be changed using your own implementation of the handler. This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects. If the application has vertical scroll bars, use a WindowVerticalScrollBar event handler.
    </remarks>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.HorizontalScroll>
  <Window.HorizontalSlide>
    <summary>
      Provide a method that is invoked when a horizontal slider's thumb is dragged either by the mouse or the keyboard.
    </summary>
    <param name="oSliderEvent">The SliderEvent object that describes which horizontal slider's thumb was dragged.</param>
    <seealso cref="T:VO.SliderEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </Window.HorizontalSlide>
  <Window.HorizontalSpin>
    <summary>
      Provide a method that is invoked when a horizontal spinner is spun.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The default behavior for this event handler is to update the position of the spinner; this can be changed using your own implementation of the handler. This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects. If the application has vertical scroll bars, use a WindowVerticalScrollBar event handler.
    </remarks>
    <param name="oSpinnerEvent">The SpinnerEvent object that describes which horizontal spinner was spun.</param>
    <seealso cref="T:VO.SpinnerEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.HorizontalSpin>
  <Window.HyperLabel>
    <summary>
      The hyperlabel connected to this window.
    </summary>
    <value>The hyperlabel connected to this window.</value>
    <remarks>
      The hyperlabel connected to this window. From the hyperlabel, you can retrieve additional information about the window, for example:
      <code language="X#">
        cCaption := oWindow:HyperLabel:Caption
        cDescription := oWindow:HyperLabel:Description
        cHelpContext := oWindow:HyperLabel:HelpContext
      </code>
      HyperLabel can also be used to assign a HyperLabel object to a window, although this is most commonly done during instantiation.
    </remarks>
  </Window.HyperLabel>
  <Window.Icon>
    <summary>
      The large icon object used for this window.
    </summary>
    <value>The large icon object used for this window.</value>
  </Window.Icon>
  <Window.IconSm>
    <summary>
      The small icon object used for this window.
    </summary>
    <value>The small icon object used for this window.</value>
  </Window.IconSm>
  <Window.IsEnabled>
    <summary>
      Report if this window is currently enabled.
    </summary>
    <returns>
      TRUE if the window is enabled; otherwise, FALSE.
    </returns>
  </Window.IsEnabled>
  <Window.IsIconic>
    <summary>
      Report if this window is currently iconized.
    </summary>
    <returns>
      TRUE if the window is iconized; otherwise, FALSE.
    </returns>
  </Window.IsIconic>
  <Window.IsVisible>
    <summary>
      Report if this window is visible (completely or partially) or hidden.
    </summary>
    <returns>
      TRUE if the window is visible; otherwise, FALSE.
    </returns>
  </Window.IsVisible>
  <Window.IsZoomed>
    <summary>
      Report if this window is maximized (fills the entire screen).
    </summary>
    <returns>
      TRUE if the window is maximized; otherwise, FALSE.
    </returns>
  </Window.IsZoomed>
  <Window.KeyDown>
    <summary>
      Provide a method that is invoked when a key on the keyboard is pressed.
    </summary>
    <param name="oKeyEvent">The KeyEvent object that describes what key was pressed.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This event handler is called only if the window has the input focus. In addition, it is rarely overridden due to the existence of edit controls. If it is overridden for a dialog window, it should call the owner handler (this ensures that tabbing to controls in Windows still works).
    </remarks>
  </Window.KeyDown>
  <Window.KeyUp>
    <summary>
      Provide a method that is invoked when a key on the keyboard is released.
    </summary>
    <param name="oKeyEvent">The KeyEvent object that describes what key was released.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This event handler is called only if the window has the input focus.
    </remarks>
  </Window.KeyUp>
  <Window.LineTo>
    <summary>
      Draw a line on this window (using the current pen) from the current pen position to a specified point.
    </summary>
    <param name="oPoint">
      The position where the line should end, in canvas coordinates. or an array of points,
      in canvas coordinates, where the line should end, in which case Window:LineTo() acts like a polyline method.
    </param>
    <seealso cref="T:VO.Point" />
    <remarks>
      The current pen position is updated to the line's ending position (as specified by &lt;oPoint&gt; or &lt;aoPoint&gt;).
    </remarks>
  </Window.LineTo>
  <Window.ListBoxClick>
    <summary>
      Provide a method that is invoked when an item in a list box owned by this window is double-clicked.
    </summary>
    <param name="oControlEvent">The ControlEvent object that describes which list box contained the item that is double-clicked.</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.ListBoxClick>
  <Window.ListBoxSelect>
    <summary>
      Provide a method that is invoked when an item in a list box owned by this window is clicked.
    </summary>
    <param name="oControlEvent">The ControlEvent object that describes which list box contained the item that was clicked.</param>
    <seealso cref="T:VO.ControlEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <example>
      Typical example below of using this method:
      <code language="X#">
        METHOD ListBoxSelect(oControlEvent) CLASS TeamInfo
        LOCAL oControl AS Control
        LOCAL sSym AS SYMBOL
        oControl := IIf(oControlEvent == NULL_OBJECT, NULL_OBJECT, ;
        oControlEvent:Control)
        SUPER:ListBoxSelect(oControlEvent)
        //Put your changes here
        sSym  := oControl:nameSym
        IF sSym == #cbxTeamNumbers
        IF SELF:cLastTeamNr != SELF:oDCcbxTeamNumbers:Value
        SELF:cLastTeamNr := SELF:oDCcbxTeamNumbers:Value
        SELF:BreakDownTeamNumber( SELF:oDCcbxTeamNumbers:Value )
        ENDIF
        ENDIF
      </code>
    </example>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.ListBoxSelect>
  <Window.ListViewColumnClick>
    <summary>
      Provide a method that is invoked when a list view column header is clicked in a list view control.
    </summary>
    <param name="oListViewColumnClickEvent">The ListViewColumnClickEvent object that describes which list view column of which list view control was clicked.</param>
    <seealso cref="T:VO.ListViewColumnClickEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.ListViewColumnClick>
  <Window.ListViewItemChanged>
    <summary>
      Provide a method that is invoked when a list view item has changed.
    </summary>
    <param name="oListViewItemEvent">The ListViewItemEvent object that describes which list view item has changed.</param>
    <seealso cref="T:VO.ListViewItemEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The ListViewItemChanged event handler notifies a list view control's parent window that an item has changed.
    </remarks>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.ListViewItemChanged>
  <Window.ListViewItemChanging>
    <summary>
      Provide a method that is invoked when the state of a list view item is about to change.
    </summary>
    <param name="oListViewItemEvent">The ListViewItemEvent object that describes which list view item is about to change.</param>
    <seealso cref="T:VO.ListViewItemEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The ListViewItemChanging event handler notifies a list view control's parent window that an item is about to be changed.
    </remarks>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.ListViewItemChanging>
  <Window.ListViewItemDelete>
    <summary>
      Provide a method that is invoked when a list view item is deleted in a list view control.
    </summary>
    <param name="oListViewDeleteEvent">The ListViewDeleteEvent object that describes which list view item of which list view control was deleted.</param>
    <seealso cref="T:VO.ListViewDeleteEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.ListViewItemDelete>
  <Window.ListViewItemDrag>
    <summary>
      Provide a method that is invoked when a list view item is dragged in a list view control.
    </summary>
    <param name="oListViewDragEvent">The ListViewDragEvent object that describes which list view item of which list view control was dragged.</param>
    <seealso cref="T:VO.ListViewDragEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The default implementation of this method checks to see if the listview control has DragDrop enabled, builds and positions the Drag image and
      calls the DragEnter() method on the imagelist.
    </remarks>
  </Window.ListViewItemDrag>
  <Window.ListViewItemEdit>
    <summary>
      Provide a method that is invoked when a list view item is edited in a list view control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oListViewEditEvent">The ListViewEditEvent object that describes which list view item of which list view control was edited.</param>
    <seealso cref="T:VO.ListViewEditEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.ListViewItemEdit>
  <Window.ListViewKeyDown>
    <summary>
      Provide a method that is invoked when a key is pressed in a list view control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oListViewKeyEvent">The ListViewKeyEvent object that describes which list view control received a key press.</param>
    <seealso cref="T:VO.ListViewKeyEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.ListViewKeyDown>
  <Window.ListViewMouseButtonDoubleClick>
    <summary>
      Provide a method that is invoked when a mouse button is double-clicked in a list view control. This could be used to invoke an "edit screen" for the selected item, print a report, etc. See the ListViewMouseButtonDown() method for sample syntax.
    </summary>
    <param name="oListViewMouseEvent">The ListViewMouseEvent object that describes which list control received a mouse button double-click.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <seealso cref="T:VO.ListViewMouseEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.ListViewMouseButtonDoubleClick>
  <Window.ListViewMouseButtonDown>
    <summary>
      Provide a method that is invoked when a mouse button is clicked in a list view control.
    </summary>
    <param name="oListViewMouseEvent">The ListViewMouseEvent object that describes which list control received a mouse button click.</param>
    <seealso cref="T:VO.ListViewMouseEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <example>
      Typical example of a ListViewMouseButtonDown usage. Note that in the example, the item's record number is stored in the "value" of the LVI, whereas the text of the item is stored in the "text" entity. Obviously this will only work when using a string-type column in the ListView for storing the record number also.
      <code language="X#">
        METHOD ListViewMouseButtonDown(oListViewMouseEvent) CLASS CoachesBrowse
        LOCAL sSym AS SYMBOL
        LOCAL oLVI AS ListViewItem
        SUPER:ListViewMouseButtonDown(oListViewMouseEvent)
        //Put your changes here
        oLVI := oListViewMouseEvent:ListViewItem
        sSym := oListViewMouseEvent:NameSym
        DO CASE
        CASE sSym == #lvCoaches
        IF oLVI != NULL_OBJECT
        IF oListViewMouseEvent:PointOnItem
        SELF:iCoachRec := oLVI:GetValue( #cCoachName )
        SELF:cSelCoach := oLVI:GetText( #cCoachName )
        SELF:oDbCoaches:GoTo( SELF:iCoachRec )
        ENDIF
        ENDIF
        ENDCASE
      </code>
    </example>
  </Window.ListViewMouseButtonDown>
  <Window.Menu>
    <summary>
      The menu currently in use by this window.
    </summary>
    <value>The menu currently in use by this window.</value>
  </Window.Menu>
  <Window.MenuCommand>
    <summary>
      Provide a method that is invoked when an item on a menu owned by this window is selected.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oMenuCommandEvent">The MenuCommandEvent object that describes which menu and menu command (via the item's ID) generated the event.</param>
    <seealso cref="T:VO.MenuCommandEvent" />
  </Window.MenuCommand>
  <Window.MenuInit>
    <summary>
      Provide a method that is invoked when a pop-up menu owned by this window is about to "pop up."
    </summary>
    <param name="oMenuInitEvent">The MenuInitEvent object that describes which menu is about to pop up.</param>
    <seealso cref="T:VO.MenuInitEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This event handler can be used to initialize menu commands, check items, and so forth.
    </remarks>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.MenuInit>
  <Window.MenuSelect>
    <summary>
      Provide a method that is invoked when an item on a menu owned by this window is selected.
    </summary>
    <param name="oMenuSelectEvent">The MenuSelectEvent object that describes which menu and menu command (via the item's ID) generated the event.</param>
    <seealso cref="T:VO.MenuSelectEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      One use for this event handler is to provide more extensive help with the user's current selection. Selecting a menu command does not necessarily imply that it is invoked, only that the menu highlight bar is currently over this item.
    </remarks>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.MenuSelect>
  <Window.MinMaxInfo>
    <summary>
      Provide a method that is invoked when the size or position of a window is about to change (cf WM_GETMINMAXINFO in Win API).
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The default implementation of this method sets the MinTrackSize property of the MinMaxInfoEvent event to the minsize of the window.
    </remarks>
    <param name="oMinMaxInfoEvent">The MinMaxInfoEvent object that describes the maximised width, height and position of the maximised window in addition to the minimum and maximum height and width of the window.</param>
    <seealso cref="T:VO.MinMaxInfoEvent" />
  </Window.MinMaxInfo>
  <Window.MinSize>
    <summary>The minimum size for the window</summary>
    <value>The minimum size for the window</value>
  </Window.MinSize>
  <Window.ModifyTrayIcon>
    <summary>
      Modify the tray icon associated with the window.
    </summary>
    <param name="oTrayIcon">The icon object to add to the tray.</param>
    <param name="dwID">The unique ID of the icon (between 1 and 8000).</param>
    <param name="sToolTip">The tool tip string to be displayed for this icon.</param>
    <remarks>
      <note type="tip">
        If modern versions of window , the tool tip will support line breaks by using CRLF.
        On older versions the CRLF is automatically replaced with a space.
      </note>
    </remarks>
  </Window.ModifyTrayIcon>
  <Window.MonthCalSelectionChanged>
    <summary>
      Provide a method that is invoked when the selection of a MonthCalendar control is changed.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="_oMonthCalSelectionEvent">The MonthCalSelectionEvent object that describes the changed selection.</param>
    <param name="oMonthCalSelectionEvent">The MonthCalSelectionEvent object that describes the changed selection.</param>
    <seealso cref="T:VO.MonthCalSelectionEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.MonthCalSelectionChanged>
  <Window.MouseButtonDoubleClick>
    <summary>
      Provide a method that is invoked when the mouse pointer is positioned over the window and a mouse button is double-clicked.
    </summary>
    <param name="oMouseEvent">The MouseEvent object that contains information about the state of the mouse when the button was double-clicked.</param>
    <seealso cref="T:VO.MouseEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      MouseButtonDoubleClick() often occurs between MouseButtonDown() and MouseButtonUp() event handlers.
    </remarks>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.MouseButtonDoubleClick>
  <Window.MouseButtonDown>
    <summary>
      Provide a method that is invoked when the mouse pointer is positioned over the window and a mouse button is clicked.
    </summary>
    <param name="oMouseEvent">The MouseEvent object that contains information about the state of the mouse when the button was clicked.</param>
    <seealso cref="T:VO.MouseEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      Use the Window:MouseTrapOn() method to force MouseEvents generated outside the canvas area to be directed to this window.
    </remarks>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.MouseButtonDown>
  <Window.MouseButtonUp>
    <summary>
      Provide a method that is invoked when the mouse pointer is positioned over the window and a mouse button is released.
    </summary>
    <param name="oMouseEvent">The MouseEvent object that contains information about the state of the mouse when the button was released.</param>
    <seealso cref="T:VO.MouseEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      Do not assume Window:MouseButtonUp() is called immediately after Window:MouseButtonDown(). Other MouseEvents can be generated during this time.
      In some cases, there may be no Window:MouseButtonUp() events directed to the window for a corresponding Window:MouseButtonDown().
      This can occur if the mouse button is clicked while over the window, but released after the mouse has moved off the window.
      Use Window:MouseTrapOn() to direct all MouseEvents to this window. <br />
      This event also detects if a MouseDrag was active and ends the drag.

    </remarks>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.MouseButtonUp>
  <Window.MouseDrag>
    <summary>
      Provide a method that is invoked when a mouse with one or more buttons clicked is moved in the window.
    </summary>
    <param name="oMouseEvent">The MouseEvent object containing information on the location and state of the buttons when the mouse was dragged.</param>
    <seealso cref="T:VO.MouseEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This method moves the drag imagelist to the new position.
    </remarks>
  </Window.MouseDrag>
  <Window.MouseMove>
    <summary>
      Provide a method that is invoked when the mouse is moved in the window.
    </summary>
    <param name="oMouseEvent">The MouseEvent object containing information on the location of the mouse when it was moved.</param>
    <seealso cref="T:VO.MouseEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This event occurs when the mouse is moved with no mouse buttons clicked.
    </remarks>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.MouseMove>
  <Window.MouseTrapOff>
    <summary>
      Disable the window from trapping MouseEvents generated outside itself.
    </summary>
    <returns>NIL</returns>
  </Window.MouseTrapOff>
  <Window.MouseTrapOn>
    <summary>
      Enable this window to trap MouseEvents generated outside itself.
    </summary>
    <remarks>
      Turn mouse trapping off before disabling or deactivating this window; otherwise, other windows cannot receive MouseEvents.
    </remarks>
    <returns>NIL</returns>
  </Window.MouseTrapOn>
  <Window.Move>
    <summary>
      Provide a method that is invoked when the window is moved (either by the user or by the application).
    </summary>
    <param name="oMoveEvent">The MoveEvent object that describes the window movement.</param>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <seealso cref="T:VO.MoveEvent" />
  </Window.Move>
  <Window.MoveTo>
    <summary>
      Move the current pen to a point on the window's canvas area.
    </summary>
    <param name="oPoint">The position of the pen, in canvas coordinates.</param>
    <returns>
      A point representing the previous location of the pen, in canvas coordinates.
    </returns>
    <remarks>
      The pen location may not be remembered between event handlers.
    </remarks>
  </Window.MoveTo>
  <Window.Origin>
    <summary>
      The point representing the new location of this window, in the canvas coordinates of its owner.
    </summary>
    <value>The point representing the new location of this window, in the canvas coordinates of its owner.</value>
    <example>
      The following example sets the origin of a window object:
      <code language="X#">oWin:Origin := Point{nLeft,nBottom}</code>
    </example>
  </Window.Origin>
  <Window.Owner>
    <summary>
      The owner of the window, either a Window or App object.
    </summary>
    <value>The owner of the window, either a Window or App object.</value>
  </Window.Owner>
  <Window.OwnerAlignment>
    <summary>The Owner Alignment value for the window, which is used when the window is a subwindow on another window.</summary>
    <value>The Owner Alignment value for the window</value>
  </Window.OwnerAlignment>
  <Window.PaintBackground>
    <summary>
      Paint the background for a window with the brush or background object that was specified by the user.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="hDC">The device context of the window on which the background must be painted.</param>
    <returns>NIL</returns>
  </Window.PaintBackground>
  <Window.PaintBoundingBox>
    <summary>
      Paint a rectangular area in the window using a specified painting method.
    </summary>
    <param name="oBoundingBox">The bounding box (group or character box) representing the window area to be painted, in canvas coordinates.</param>
    <param name="kPaintMode">
      The constant that represents how the window area is painted:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>
            PAINTFILL
          </term>
          <description>Fills the entire rectangle using the currently selected brush. This is the default.</description>
        </item>
        <item>
          <term>
            PAINTFRAME
          </term>
          <description>Frames the entire rectangle using the currently selected pen</description>
        </item>
        <item>
          <term>PAINTINVERT   </term>
          <description>Inverts the entire rectangle</description>
        </item>
      </list>
    </param>
    <returns>NIL</returns>
  </Window.PaintBoundingBox>
  <Window.Pen>
    <summary>
      The pen assigned to the window and used in subsequent line and rectangle drawing operations; it should not be deleted while it is the current selection.
    </summary>
    <value>The pen assigned to the window and used in subsequent line and rectangle drawing operations; it should not be deleted while it is the current selection.</value>
  </Window.Pen>
  <Window.Pointer>
    <summary>
      The pointer used by the window to represent the mouse when it enters the window.
    </summary>
    <value>The pointer used by the window to represent the mouse when it enters the window.</value>
  </Window.Pointer>
  <Window.PostInit>
    <summary>
      Implement customized initialization code for the window.
    </summary>
    <remarks>
      This method is used to customize the initialization code for a window.
      The customized initialization code will not be overridden by the Window Editor's default initialization code.
      A call to PostInit() is automatically generated at the end of the Init() method.
      You can customize the code generation by changing the [PostInitCall] and [PostInit] sections
      in your CAVOWED.TPL file. Note that PreInit() is always called prior to PostInit(). <br />
      The default implementation of PostInit() in this class is empty.
    </remarks>
  </Window.PostInit>
  <Window.PreInit>
    <summary>
      Implement customized initialization code for the window.
    </summary>
    <remarks>
      This method is used to customize the initialization code for a window.
      The customized initialization code will not be overridden by the Window Editor's default initialization code.
      A call to PreInit() is automatically generated at the beginning of the Init() method.
      You can customize the code generation by changing the [PreInitCall] and [PreInit] sections
      in your CAVOWED.TPL file. Note that only class variables are accessible in the PreInit() method,
      no window controls are visible until the PostInit() method itself is called. <br />
      The default implementation of PostInit() in this class is empty.
      <note type="tip">
        In .Net it is normally not allowed or recommended to run code in a class before the parent constructor is called.
        The generated code in the Window editor does this (it calls PreInit before the SUPER() call). We advise you to
        be very careful not to touch protected instance variables inherited from parent classes, since these may not be
        initialized and/or values that you assign to them may be overwritten in the constructor of the parent class.
      </note>
    </remarks>
  </Window.PreInit>
  <Window.PreMenuCommand>
    <summary>
      Process menu events before the normal MenuCommand method is called.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      This method can be written at the Window level to process menu commands. The window:PreMenuCommand( ) method will be called if it exists to process menu events before the normal MenuCommand( ) methods are called.
      The method must return a logic –
      TRUE – If you have processed the MenuCommand.
      FALSE – If you want the normal MenuCommand to run as well.
    </remarks>
  </Window.PreMenuCommand>
  <Window.Print>
    <summary>
      Print the contents of the window.
    </summary>
    <param name="oDevice">The PrintingDevice object that will receive the output. If omitted, the default printer driver is used.</param>
    <seealso cref="T:VO.PrintingDevice" />
    <include file="Gui.xml" path="doc/ReturnsLogic/*" />
    <remarks>The default implementation of this method creates a Butmap of the surface of the window and sends that to the default printer.</remarks>
  </Window.Print>
  <Window.QueryClose>
    <summary>
      Provide a method that is invoked just before the window closes to confirm if the application really wants to close the window.
    </summary>
    <param name="oEvent">An empty event required to maintain the protocol that all event handlers have exactly one event as their argument.</param>
    <seealso cref="T:VO.Event" />
    <returns>
      The method inside the window class always returns TRUE.
      If you override this method in your subclass then you must return TRUE if the window is to be closed; otherwise, return FALSE.
    </returns>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      When a user tries to close an application by selecting the Close menu command from a system menu (or by using another method to end the session), the system calls each window's QueryClose() event handler.
      <note type="tip">If you reimplement this method in your subclass, it is recommended that you first call SUPER:QueryClose() within the method to obtain its default behavior.</note>
    </remarks>
    <example>
      This example displays a message box to confirm that a user wants to quit the application. If a user chooses YES, TRUE is returned (otherwise, FALSE is returned).
      <code language="X#">
        METHOD QueryClose(oEvent) CLASS TopAppWindow
        oTB := TextBox{SELF, "Quit", "Do you really want to quit?"}
        oTB:TYPE := BOXICONQUESTIONMARK + BUTTONYESNO
        IF (oTB:Show() = BOXREPLYYES)
        RETURN TRUE // Quit application.
        ELSE
        RETURN FALSE
        // Don't quit the application.
        END
      </code>
    </example>
  </Window.QueryClose>
  <Window.RegisterTimer>
    <summary>
      Register a timer method to be invoked for the window.
    </summary>
    <param name="nInterval">Time interval, in seconds, between calls to the Timer() method of the window.</param>
    <param name="lOneTime">Logical value indicating if the timer is called just once (TRUE), or multiple times (FALSE). If omitted, the default is FALSE.</param>
  </Window.RegisterTimer>
  <Window.RePaint>
    <summary>
      Send an ExposeEvent to repaint the window's canvas area.
    </summary>
    <returns>NIL</returns>
  </Window.RePaint>
  <Window.RepaintBoundingBox>
    <summary>
      Repaint a rectangular area in the window.
    </summary>
    <param name="oBoundingBox">The bounding box (group or character box) representing the window area to be repainted, in canvas coordinates.</param>
    <remarks>
      This method should be avoided within an Expose() event handler. If it is used, make sure the application does not fall into an infinite loop.
    </remarks>
    <returns>NIL</returns>
  </Window.RepaintBoundingBox>
  <Window.Resize>
    <summary>
      Provide a method that is invoked when the window changes size.
    </summary>
    <param name="oResizeEvent">The ResizeEvent object that describes the new dimensions of the window canvas area.</param>
    <seealso cref="T:VO.ResizeEvent" />
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      In the Window:Resize() event handler, calling Window:Size should be used with caution to avoid entering an infinite loop. <br />
      If the window has a Toolbar then this method will also make sure that the toolbar is resized as well.
    </remarks>
  </Window.Resize>
  <Window.RichEditProtected>
    <summary>
      Provide a method that is invoked when an attempt is made to modify text that is protected in a rich edit control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oRichEditProtectEvent">The RichEditProtectEvent object that describes which rich edit control received a protect event.</param>
    <seealso cref="T:VO.RichEditProtectEvent" />
    <returns>This method always sets the EventReturnValue to 1 and returns 0</returns>
  </Window.RichEditProtected>
  <Window.RichEditSelectionChange>
    <summary>
      Provide a method that is invoked when the current selection in a rich edit control is changed.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oRichEditSelectionEvent">The RichEditSelectionEvent object that describes which rich edit had its current selection change.</param>
    <seealso cref="T:VO.RichEditSelectionEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.RichEditSelectionChange>
  <Window.RichEditUndoLost>
    <summary>
      Provide a method that is invoked when the undo state in a rich edit control can no longer be maintained.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oControlNotifyEvent">The ControlNotifyEvent object that describes which rich edit has lost its undo state.</param>
    <seealso cref="T:VO.ControlNotifyEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.RichEditUndoLost>
  <Window.Scroll>
    <summary>
      Scroll a rectangular area in the window a specified amount, in a specified direction, and optionally clip the area when scrolled.
    </summary>
    <param name="oDimension">The dimension representing the amount to move the rectangular scroll area (relative to its origin). Positive width values scroll to the right while negative width values scroll to the left. In addition, positive height values scroll upwards while negative height values scroll downwards.</param>
    <param name="oBoundingBox">The bounding box representing the rectangular window area, in canvas coordinates. If omitted, the default is the canvas area of the screen.</param>
    <param name="lClip">Indicates whether to clip the rectangular area when scrolled. TRUE clips the area; FALSE does not. If omitted, the default is TRUE.</param>
    <remarks>
      The clip region is an area that can receive output from the system.
    </remarks>
  </Window.Scroll>
  <Window.SetAlignStartSize>
    <summary>This method is used to register the start size of a window which is used later to resize controls that have their OwnerAlignment property set.</summary>
    <param name="oSize">The dimenstion object that contains the size that should be stored. If this object is not passed then the method will calculate the size of the window and store that for future reference.</param>
    <returns>NIL</returns>
  </Window.SetAlignStartSize>
  <Window.SetBackgroundBrush>
    <summary>
      Set the background brush used to paint the window.
    </summary>
    <param name="dwNew">The new brush to use. The default is COLOR_3DSHADOW.</param>
    <returns>NIL</returns>
  </Window.SetBackgroundBrush>
  <Window.SetExStyle>
    <summary>
      Set the extended style of a window.
    </summary>
    <param name="dwSetStyle">The extended style to set.</param>
    <param name="lEnable">A logical value. TRUE turns the style on, FALSE turns it off.</param>
    <returns>The new ExStyle of the window (calculated by taking the existing style and enableing or disabling the passed style value).</returns>
  </Window.SetExStyle>
  <Window.SetFocus>
    <summary>
      Set the keyboard focus to this window.
    </summary>
  </Window.SetFocus>
  <Window.SetHandle>
    <summary>This methdod allows to set or change the handle of the window. This is normally done right after the window is created.</summary>
    <param name="hNewWnd">The new window handle for the window.</param>
    <returns>The windows handle.</returns>
    <remarks>DO NOT CHANGE THE WINDOW HANDLE IF YOU DON'T KNOW WHAT YOU ARE DOING !</remarks>
  </Window.SetHandle>
  <Window.SetStyle>
    <summary>
      Set the styles for the window.
    </summary>
    <param name="dwSetStyle">The X# style constant or Windows API style constant to set.</param>
    <param name="lEnable">Logical value indicating whether the style should be enabled (TRUE) or disabled(FALSE). If omitted, the default is TRUE.</param>
    <returns>
      <returns>The new Style of the window (calculated by taking the existing style and enableing or disabling the passed style value).</returns>
    </returns>
  </Window.SetStyle>
  <Window.Show>
    <summary>
      Display this window.
    </summary>
    <param name="kShowState">The constant that represents how the window is shown. Valid values are:</param>
    <remarks>
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>
            SHOWCENTERED
          </term>
          <description>Shows the window centered within its owner window. If the owner is the desktop, the window is centered on the screen.</description>
        </item>
        <item>
          <term>
            SHOWICONIZED
          </term>
          <description>Shows the window initially as an icon</description>
        </item>
        <item>
          <term>
            SHOWNORMAL
          </term>
          <description>
            Shows the window on its owner, in a size chosen by the owner. If the owner is the desktop,
            the window appears quite large but may not fill the whole desktop. You can control the window's
            size precisely, if you want, with Window:Size and Window:Origin. This is the default.
          </description>
        </item>
        <item>
          <term>SHOWZOOMED</term>
          <description>
            Shows the window at the maximum size allowed by its owner. If the owner is the desktop, the window occupies
            the whole desktop.
          </description>
        </item>
      </list>
    </remarks>
    <returns>NIL</returns>
  </Window.Show>
  <Window.ShowBalloonTrayTip>
    <summary>
      Display a balloon tip for an icon in the tray that is associated with this window.
    </summary>
    <param name="oTrayIcon">The icon to be displayed in the tray.</param>
    <param name="dwID">The unique ID of the icon (between 1 and 8000).</param>
    <param name="sHeading">The heading to be displayed in the balloon. This title appears in boldface above the text. It can have a maximum of 63 characters.</param>
    <param name="sToolTip">The text to be displayed in the balloon. In Shell version 5 and above, the maximum size is 128 charecters. Below Shell version 5, the maximum is 64 charecters.</param>
    <param name="dwTimeOut">
      The length of time to display the balloon before it is removed if it is not dismissed by the user.
      The system enforces minimum and maximum timeout values. dwTimeout values that are too large are set to the maximum value and values that are too small default to the minimum value.
      This is set in milliseconds.
    </param>
    <param name="dwInfo">
      Flags that can be set to add an icon to a balloon ToolTip.
      Valid values are:
      <list type="table">
        <listheader>
          <term>Constant</term>
          <description>Description</description>
        </listheader>
        <item>
          <term>
            NIIF_ERROR
          </term>
          <description>An error icon.</description>
        </item>
        <item>
          <term>
            NIIF_INFO
          </term>
          <description>An information icon.</description>
        </item>
        <item>
          <term>
            NIIF_NONE
          </term>
          <description>No icon.</description>
        </item>
        <item>
          <term>
            NIIF_WARNING
          </term>
          <description>A warning icon.</description>
        </item>
        <item>
          <term>
            NIIF_NOSOUND
          </term>
          <description>Do not play the associated sound.</description>
        </item>
      </list>
    </param>
    <returns>The result of the call to Shell_NotifyIcon() (see the WIN32 API)</returns>
  </Window.ShowBalloonTrayTip>
  <Window.Size>
    <summary>
      The dimension representing the size of this window.
    </summary>
    <value>The dimension representing the size of this window.</value>
    <example>
      The following example sets the size of a window object:
      <code language="X#">oWin:Size := Dimension{nWidth,nHeight}</code>
    </example>
  </Window.Size>
  <Window.SizeText>
    <summary>
      Determine the space needed to print a string on the window in the current font.
    </summary>
    <param name="cTextToSize">The string to be printed.</param>
    <returns>
      A dimension representing the space required to print the string on this window using the current font.
    </returns>
  </Window.SizeText>
  <Window.StatusMessage>
    <summary>
      This is an empty method, since the Window class does not have a statusbar.
    </summary>
    <param name="oHL">The hyperlabel containing a description (HyperLabel:Description) for the status message or the status message as a string.</param>
    <param name="ntype">
      The constant value indicating the type and priority of the message to be displayed on the status bar.
      The highest priority message (MESSAGEMENU) always takes precedence over and replaces lower priority messages. See table in the remarks section for more info.
    </param>
    <returns>NIL</returns>
  </Window.StatusMessage>
  <Window.SysLinkSelect>
    <summary>
      Provide a method that is invoked when a a user clicks on a SysLink control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
    <param name="oSysLinkSelectEvent">The SysLinkSelectEvent object that describes the control on which the user clicked.</param>
    <seealso cref="T:VO.SysLinkSelectEvent" />
  </Window.SysLinkSelect>
  <Window.TabKeyDown>
    <summary>
      Provide a method that is invoked when a key press occurs in a tab control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oControlNotifyEvent">The ControlNotifyEvent object that describes which tab control received a key press.</param>
    <seealso cref="T:VO.ControlNotifyEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.TabKeyDown>
  <Window.TabSelect>
    <summary>
      Provide a method that is invoked when a tab is selected in a tab control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oControlNotifyEvent">The ControlNotifyEvent object that describes which tab control's tab has been selected.</param>
    <seealso cref="T:VO.ControlNotifyEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.TabSelect>
  <Window.TabSelectionChanging>
    <summary>
      Provide a method that is invoked when a tab selection is changing in a tab control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oControlNotifyEvent">The ControlNotifyEvent object that describes which tab control's selected tab is changing.</param>
    <seealso cref="T:VO.ControlNotifyEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.TabSelectionChanging>
  <Window.TextColor>
    <summary>
      Uses a pen object and builds a pen in this window.
    </summary>
    <value>Uses a pen object and builds a pen in this window.</value>
  </Window.TextColor>
  <Window.TextPrint>
    <summary>
      Display a given string on the window at a specified location using the current font and the current pen color.
    </summary>
    <param name="cText">The string to be printed.</param>
    <param name="oPoint">The position of the string's origin, in canvas coordinates.</param>
  </Window.TextPrint>
  <Window.Timer>
    <summary>
      Provide a method to be invoked at specific intervals defined when the timer is registered though the RegisterTimer() method.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
  </Window.Timer>
  <Window.ToolBar>
    <summary>
      The toolbar in use by the window.
    </summary>
    <value>The toolbar in use by the window.</value>
  </Window.ToolBar>
  <Window.ToolBarHeightChanged>
    <summary>
      Provide a method that is invoked when the height of the window's toolbar is changed.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oControlNotifyEvent">The ControlNotifyEvent object that describes the changes to the toolbar height.</param>
    <seealso cref="T:VO.ControlNotifyEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.ToolBarHeightChanged>
  <Window.ToTop>
    <summary>
      Move this window "to the front" of the windows lying on the desktop, giving it the input focus.
    </summary>
    <remarks>
      This makes the window fully visible.
    </remarks>
    <returns>NIL</returns>
  </Window.ToTop>
  <Window.TrayIconBalloonClicked>
    <summary>
      Provide a method that is invoked when a tray icon balloon is clicked.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="dwID">The ID that was associated with the tray icon balloon.</param>
    <returns>NIL</returns>
  </Window.TrayIconBalloonClicked>
  <Window.TrayIconBalloonShown>
    <summary>
      Provide a method that is invoked when a tray icon balloon is shown.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="dwID">The ID that was associated with the tray icon balloon.</param>
    <returns>NIL</returns>
  </Window.TrayIconBalloonShown>
  <Window.TrayIconBalloonTimeOut>
    <summary>
      Provide a method that is invoked when a tray icon balloon times out.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="dwID">The ID that was associated with the tray icon balloon.</param>
    <returns>NIL</returns>
  </Window.TrayIconBalloonTimeOut>
  <Window.TrayIconClicked>
    <summary>
      Provide a method that is invoked when a user clicks on a tray Icon
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="dwID">The ID that was associated with the tray icon balloon.</param>
    <param name="lRightButton">TRUE when the user clicked with the Right Mouse button</param>
    <param name="lDoubleClick">TRUE when the user double clicked</param>
    <returns>NIL</returns>
  </Window.TrayIconClicked>
  <Window.TreeViewItemDelete>
    <summary>
      Provide a method that is invoked when a tree view item is deleted in a tree view control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewDeleteEvent">The TreeViewDeleteEvent object that describes which tree view item of which tree view control was deleted.</param>
    <seealso cref="T:VO.TreeViewDeleteEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.TreeViewItemDelete>
  <Window.TreeViewItemDrag>
    <summary>
      Provide a method that is invoked when a tree view item is dragged in a tree view control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewDragEvent">The TreeViewDragEvent object that describes which tree view item of which tree view control was dragged.</param>
    <seealso cref="T:VO.TreeViewDragEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.TreeViewItemDrag>
  <Window.TreeViewItemEdit>
    <summary>
      Provide a method that is invoked when a tree view item is edited in a tree view control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewEditEvent">The TreeViewEditEvent object that describes which tree view item of which tree view control was edited.</param>
    <seealso cref="T:VO.TreeViewEditEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.TreeViewItemEdit>
  <Window.TreeViewItemExpanded>
    <summary>
      Provide a method that is invoked when a tree view item is expanded in a tree view control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewExpandedEvent">The TreeViewExpandedEvent object that describes which tree view item of which tree view control was expanded.</param>
    <seealso cref="T:VO.TreeViewExpandedEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.TreeViewItemExpanded>
  <Window.TreeViewItemExpanding>
    <summary>
      Provide a method that is invoked when a tree view item is expanding in a tree view control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewExpandingEvent">The TreeViewExpandingEvent object that describes which tree view item of which tree view control is expanding.</param>
    <seealso cref="T:VO.TreeViewExpandingEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.TreeViewItemExpanding>
  <Window.TreeViewKeyDown>
    <summary>
      Provide a method that is invoked when a key is pressed in a tree view control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewKeyEvent">The TreeViewKeyEvent object that describes which tree view control received a key press.</param>
    <seealso cref="T:VO.TreeViewKeyEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.TreeViewKeyDown>
  <Window.TreeViewMouseButtonDoubleClick>
    <summary>
      Provide a method that is invoked when a mouse button is double-clicked in a tree view control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewMouseEvent">The TreeViewMouseEvent object that describes which tree view control received a mouse button double-click.</param>
    <seealso cref="T:VO.TreeViewMouseEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.TreeViewMouseButtonDoubleClick>
  <Window.TreeViewMouseButtonDown>
    <summary>
      Provide a method that is invoked when a mouse button is clicked in a tree view control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewMouseEvent">The TreeViewMouseEvent object that describes which tree view control received a mouse button click.</param>
    <seealso cref="T:VO.TreeViewMouseEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.TreeViewMouseButtonDown>
  <Window.TreeViewSelectionChanged>
    <summary>
      Provide a method that is invoked when the selection has changed from one tree view item to another in a tree view control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewSelectionEvent">The TreeViewSelectionEvent object that describes which tree view control's selected item was changed.</param>
    <seealso cref="T:VO.TreeViewSelectionEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.TreeViewSelectionChanged>
  <Window.TreeViewSelectionChanging>
    <summary>
      Provide a method that is invoked when the selection is changing from one tree view item to another in a tree view control.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oTreeViewSelectionEvent">The TreeViewSelectionEvent object that describes which tree view control's selected item is changing.</param>
    <seealso cref="T:VO.TreeViewSelectionEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.TreeViewSelectionChanging>
  <Window.Update>
    <summary>
      Update the client area of the specified window.
    </summary>
    <remarks>
      This method utilizes the Windows API UpdateWindow() function which updates the client area of the specified window by sending a WM_PAINT message to the window. The message is sent directly to the window procedure of the specified window, thus bypassing the application queue.
      The Window:Update() method is automatically called upon when terminating the Expose().
      <note type="tip">This method should not be used within an Expose() event handler.</note>
    </remarks>
    <returns>NIL</returns>
  </Window.Update>
  <Window.VerticalScroll>
    <summary>
      Provide a method that is invoked when a vertical scroll bar is scrolled.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oScrollEvent">The ScrollEvent object that describes the scroll type and new position.</param>
    <seealso cref="T:VO.ScrollEvent" />
    <remarks>
      The default behavior for this event handler is to update the thumb position of the scrollbar; this can be changed using your own implementation of the handler. This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects. If the application has horizontal scroll bars, use a HorizontalScrollBar event handler.
    </remarks>
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.VerticalScroll>
  <Window.VerticalSlide>
    <summary>
      Provide a method that is invoked when a vertical slider's thumb is dragged either by the mouse or the keyboard.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
    </remarks>
    <param name="oSliderEvent">The SliderEvent object that describes which vertical slider's thumb was dragged.</param>
    <seealso cref="T:VO.SliderEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.VerticalSlide>
  <Window.VerticalSpin>
    <summary>
      Provide a method that is invoked when a vertical spinner is spun.
    </summary>
    <remarks>
      <include file="Gui.xml" path="doc/Callback/*" />
      The default behavior for this event handler is to update the position of the spinner; this can be changed using your own implementation of the handler. This event handler only works for HorizontalScrollBar and WindowHorizontalScrollBar objects. If the application has vertical scroll bars, use a WindowVerticalScrollBar event handler.
    </remarks>
    <param name="oSpinnerEvent">The SpinnerEvent object that describes which vertical spinner was spun.</param>
    <seealso cref="T:VO.SpinnerEvent" />
    <returns>This method calls Window.Default() and returns the result of Window.Default()</returns>
  </Window.VerticalSpin>
  <Window.WindowArea>
    <summary>
      The bounding box representing the minimal area which encloses the entire window (canvas area and non-canvas area), in canvas coordinates.
    </summary>
    <value>The bounding box representing the minimal area which encloses the entire window (canvas area and non-canvas area), in canvas coordinates.</value>
  </Window.WindowArea>
  <WindowHorizontalScrollBar>
    <summary>
      Create a window horizontal scroll bar.
    </summary>
    <remarks>
      There are two types of horizontal scroll bars in X#: regular (created with CLASS HorizontalScrollBar) and window (created with the AppWindow:EnableHorizontalScroll() method). Both types have an owner window and can be manipulated using Window:HorizontalScroll(). However, a window horizontal scroll bar differs in that it automatically appears aligned along the bottom of its owner window's canvas area and also resizes itself according to the size of its owner window.
      <note type="tip">By default, Window:HorizontalScroll() updates the thumb position in the scroll bar; if desired, you can change this by using your own implementation of this handler.</note>
    </remarks>
  </WindowHorizontalScrollBar>
  <WindowHorizontalScrollBar.ctor>
    <summary>
      Construct a window horizontal scroll bar.
    </summary>
    <param name="oOwner">The window that owns the window horizontal scroll bar.</param>
  </WindowHorizontalScrollBar.ctor>
  <WindowHorizontalScrollBar.Background>
    <summary>
      This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.
    </summary>
  </WindowHorizontalScrollBar.Background>
  <WindowHorizontalScrollBar.ControlID>
    <summary>
      This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.
    </summary>
    <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.</value>
  </WindowHorizontalScrollBar.ControlID>
  <WindowHorizontalScrollBar.Destroy>
    <summary>
      Provide a method to de-instantiate a WindowHorizontalScrollBar object.
    </summary>
    <remarks>
      This method can be used when a WindowHorizontalScrollBar object is no longer needed. WindowHorizontalScrollBar:Destroy() de-instantiates the WindowHorizontalScrollBar object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </WindowHorizontalScrollBar.Destroy>
  <WindowHorizontalScrollBar.Origin>
    <summary>
      This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.
    </summary>
    <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.</value>
  </WindowHorizontalScrollBar.Origin>
  <WindowHorizontalScrollBar.SetFocus>
    <summary>
      This method is inherited from the Control class, but does not apply to WindowHorizontalScrollBar.
    </summary>
  </WindowHorizontalScrollBar.SetFocus>
  <WindowHorizontalScrollBar.Size>
    <summary>
      This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.
    </summary>
    <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowHorizontalScrollBar.</value>
  </WindowHorizontalScrollBar.Size>
  <WindowScrollBar>
    <summary>
      Abstract class for Windows Scrollbars
    </summary>
    <remarks>
      There are two types of horizontal scroll bars in X#: regular (created with CLASS HorizontalScrollBar) and window (created with the AppWindow:EnableHorizontalScroll() method). Both types have an owner window and can be manipulated using Window:HorizontalScroll(). However, a window horizontal scroll bar differs in that it automatically appears aligned along the bottom of its owner window's canvas area and also resizes itself according to the size of its owner window.
      <note type="tip">By default, Window:HorizontalScroll() updates the thumb position in the scroll bar; if desired, you can change this by using your own implementation of this handler.</note>
    </remarks>
  </WindowScrollBar>
  <WindowScrollBar.ctor>
    <inheritdoc />
  </WindowScrollBar.ctor>
  <WindowStyle.ctor>
    <exclude />
  </WindowStyle.ctor>
  <WindowStyle.ClassName>
    <exclude />
  </WindowStyle.ClassName>
  <WindowStyle.SetExStyle>
    <exclude />
  </WindowStyle.SetExStyle>
  <WindowStyle.SetStyle>
    <exclude />
  </WindowStyle.SetStyle>
  <WindowVerticalScrollBar>
    <summary>
      Create a window vertical scroll bar.
    </summary>
    <remarks>
      There are two types of vertical scroll bars in X#: regular (created with CLASS VerticalScrollBar) and window (created with the AppWindow:EnableVerticalScroll() method). Both types have an owner window and can be manipulated using Window:VerticalScroll(). However, a window vertical scroll bar differs in that it automatically appears aligned along the right of its owner window's canvas area and also resizes itself according to the size of its owner window.
      <note type="tip">By default, Window:VerticalScroll() updates the thumb position of the scroll bar; if desired, you can change this by using your own implementation of this handler.</note>
    </remarks>
  </WindowVerticalScrollBar>
  <WindowVerticalScrollBar.ctor>
    <summary>
      Construct a window vertical scroll bar.
    </summary>
    <param name="oOwner">The window that owns the window vertical scroll bar.</param>
  </WindowVerticalScrollBar.ctor>
  <WindowVerticalScrollBar.Background>
    <summary>
      This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.
    </summary>
    <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.</value>
  </WindowVerticalScrollBar.Background>
  <WindowVerticalScrollBar.ControlID>
    <summary>
      This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.
    </summary>
    <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.</value>
  </WindowVerticalScrollBar.ControlID>
  <WindowVerticalScrollBar.Destroy>
    <summary>
      Provide a method to de-instantiate a WindowVerticalScrollBar object.
    </summary>
    <remarks>
      This method can be used when a WindowVerticalScrollBar object is no longer needed. WindowVerticalScrollBar:Destroy() de-instantiates the WindowVerticalScrollBar object and allows you to close and free any resources that were opened or created by the object, without waiting for the garbage collector.
    </remarks>
  </WindowVerticalScrollBar.Destroy>
  <WindowVerticalScrollBar.Origin>
    <summary>
      This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.
    </summary>
    <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.</value>
  </WindowVerticalScrollBar.Origin>
  <WindowVerticalScrollBar.SetFocus>
    <summary>
      This method is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.
    </summary>
  </WindowVerticalScrollBar.SetFocus>
  <WindowVerticalScrollBar.Size>
    <summary>
      This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.
    </summary>
    <value>This property is provided to override the inherited functionality from the Control class, as it does not apply to WindowVerticalScrollBar.</value>
  </WindowVerticalScrollBar.Size>
  <VOGUIClasses.Functions>
    <summary>
      This compiler generated class contains all the functions, globals and defines that are defined in the VOGUIClasses assembly.
    </summary>
  </VOGUIClasses.Functions>
  <ApplicationExec>
    <exclude />

  </ApplicationExec>
  <DIBCreateFromFile>
    <summary>
      Create a device independent bitmap (DIB) from an image file.
    </summary>
    <param name="pszFName">Name of the new DIB file.</param>
    <returns>
      Pointer to DIB data which can be displayed; otherwise, NULL_PTR.
    </returns>
    <remarks>
      DIBCreateFromFile() creates a device independent bitmap (.DIB file) from an image file of the following types: .JPG, .TIF, .BMP, .TGA, .PNG, .PCX, or .PCT.
    </remarks>
    <example></example>
    <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromPTR">DIBCreateFromPTR</seealso>
    <seealso cref="O:VOGUIClasses.Functions.DIBDelete">DIBDelete</seealso>
  </DIBCreateFromFile>
  <DIBCreateFromPTR>
    <summary>
      Convert an image file to a device independent bitmap (DIB).
    </summary>
    <param name="pbImage">Pointer to the first byte of image data.</param>
    <param name="nSize">Size (number of bytes) of image data.</param>
    <returns>
      Pointer to DIB data which can be displayed; otherwise, NULL_PTR.
    </returns>
    <remarks>
      DIBCreateFromPtr() converts an image file of type .JPG, .TIF, .BMP, .TGA, .PNG, .PCX, or .PCT into a device independent bitmap (.DIB file).
    </remarks>
    <example>
      The following sample converts a file, test.jpg, and displays the DIB within a TopAppWindow:
      <code language="X#">
        METHOD Start() CLASS App
        LOCAL oWin
        AS MyWindow
        LOCAL hf
        AS PTR
        LOCAL nSize AS INT
        LOCAL pDib
        AS PTR
        WCSetCoordinateSystem(WCWindowsCoordinates)
        InitializeCAPaint()
        hf := FOpen("test.jpg")
        IF hf != F_ERROR
        nSize := FSeek(hf, 0, FS_END)
        FSeek(hf, 0, FS_SET)
        pDib := MemAlloc(nSize)
        IF FRead3(hf, pDib, nSize) == nSize
        oWin := MyWindow{ SELF, pDib, nSize }
        oWin:Show(SHOWCENTERED)
        ENDIF
        FClose(hf)
        SELF:Exec()
        oWin:Axit()
        MemFree(pDib)
        ENDIF
        CLASS MyWindow INHERIT TopAppWindow
        PROTECT pBitMap  AS PTR
        PROTECT lBitMap  AS LOGIC
        CONSTRUCTOR(oParent, xFile, nSize)
        LOCAL pBmiH   AS _WINBITMAPINFO
        LOCAL nHeight  AS INT
        LOCAL nWidth
        AS INT
        LOCAL oPOint
        AS POINT
        LOCAL hWnd
        AS PTR
        LOCAL cx
        AS INT
        LOCAL cy
        AS INT
        LOCAL cr    IS _WINRECT
        LOCAL wr    IS _WINRECT
        SUPER:Init(oParent)
        SELF:QuitOnClose := TRUE
        IF IsPtr(xFile) .AND. IsNumeric(nSize)
        SELF:pBitMap := DIBCreateFromPtr(xFile, nSize)
        ENDIF
        IF pBitMap = NULL_PTR
        MessageBox(0, "Error reading image", "ERROR ", MB_ICONSTOP)
        ELSE
        SELF:lBitmap := .T.
        oPoint := SELF:Origin
        pBmiH  := DIBGetInfo(pBitMap)
        nHeight := pBmiH.bmiHeader.biHeight
        nWidth := pBmiH.bmiHeader.biWidth
        hWnd  := SELF:Handle()
        GetWindowRect(hWnd, @wr)
        GetClientRect(hWnd, @cr)
        cx := wr.right - wr.left - cr.right
        cy := wr.bottom - wr.top - cr.bottom
        SELF:Size  := DIMension{nWidth + cx, nHeight + cy}
        SELF:Origin := oPoint
        ENDIF
        RETURN SELF

        METHOD Expose(oExposeEvent)
        SUPER:Expose(oExposeEvent)
        IF SELF:lBitMap
        DIBShow( SELF:pBitMap, NULL_PTR )
        ENDIF
        DESTRUCTOR()    CLASS MyWindow
        DIBDelete(SELF:pBitmap)
        END CLASS
      </code>
    </example>
    <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromFile">DIBCreateFromFile</seealso>
    <seealso cref="O:VOGUIClasses.Functions.DIBDelete">DIBDelete</seealso>
  </DIBCreateFromPTR>
  <DIBDelete>
    <summary>
      Destroy a DIB created either by DIBCreateFromFile() or DIBCreateFromPtr().
    </summary>
    <param name="pWinBmp">Pointer to DIB data.</param>
    <returns></returns>
    <remarks>
      DIBDelete() destroys a DIB created by DIBCreateFromFile() or DIBCreateFromPtr().
    </remarks>
    <example>
      See the DIBCreateFromPtr() example.
    </example>
    <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromFile">DIBCreateFromFile</seealso>
    <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromPTR">DIBCreateFromPtr</seealso>
  </DIBDelete>
  <DIBGetInfo>
    <summary>
      Retrieve a pointer to the BITMAPINFO structure of a DIB.
    </summary>
    <param name="pWinBmp">Pointer to DIB data.</param>
    <returns>
      Pointer to the BITMAPINFO structure, if successful; otherwise, NULL_PTR.
    </returns>
    <remarks>
      DIBGetInfo() retrieves a pointer to the BITMAPINFO structure of a DIB.
    </remarks>
    <example>
      See the DIBCreateFromPtr() example.
    </example>
    <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromPTR">DIBCreateFromPtr</seealso>
  </DIBGetInfo>
  <DIBSaveAs>
    <summary>
      Save the DIB to a file.
    </summary>
    <param name="pWinBmp">Pointer to DIB data.</param>
    <param name="pszFName">Name of the new DIB file.</param>
    <returns></returns>
    <remarks>
      DIBSaveAs() saves the DIB as a file.
    </remarks>
    <example>
      The following sample saves the image, test.jpg, as file, test.dib:
      <code language="X#">
        FUNC Start()
        LOCAL pDib	AS PTR
      </code><code language="X#">
        pDib := DIBCreateFromFile("c:\test.jpg")
        IF pDib = NULL_PTR
        DIBSaveAs(pDib, "c:\test.dib")
        DIBDelete(pDib)
        ENDIF
        WAIT
      </code><code language="X#">	RETURN </code>
    </example>
    <seealso cref="O:VOGUIClasses.Functions.DIBCreateFromFile">DIBCreateFromFile</seealso>
  </DIBSaveAs>
  <DIBShow>
    <summary>
      Display the DIB within the specified window.
    </summary>
    <param name="pWinBmp">Pointer to DIB data.</param>
    <param name="hWnd">Window handle.</param>
    <returns></returns>
    <remarks>
      DIBShow() displays the DIB within to the specified window &lt;hWnd&gt;.
    </remarks>
    <example>
      See the DIBCreateFromPtr() example.
    </example>
    <seealso cref="O:VOGUIClasses.Functions.DIBStretch">DIBStretch</seealso>
  </DIBShow>
  <DIBStretch>
    <summary>
      Display the DIB within the specified window.
    </summary>
    <param name="pWinBmp">Pointer to the DIB data.</param>
    <param name="hWnd">Window handle.</param>
    <param name="nCx">Width of the area for displaying the DIB.</param>
    <param name="nCy">Height of the area for displaying the DIB.</param>
    <param name="r8Factor">
      The zoom factor of the bitmap.
      A value of 1.0 would be its normal size.
    </param>
    <returns></returns>
    <remarks>
      DIBStretch() copies a DIB into a destination rectangle of &lt;nWidth&gt; by &lt;nHeight&gt;, stretching or compressing the bitmap by a factor of &lt;r8Zoom&gt; to fit the dimensions of the specified window, &lt;hWnd&gt;. &lt;r8Zoom&gt; can be calculated as &lt;size of the area&gt;/&lt;size of the bitmap&gt;.
      For example, a value of 2.0 would double the bitmap size, while a value of 0.5 would shrink the DIB to half its normal size.
    </remarks>
    <example></example>
    <seealso cref="O:VOGUIClasses.Functions.DIBShow">DIBShow</seealso>
  </DIBStretch>
  <Enable3dControls>
    <summary>Determines whether controls on windows created with the GUI classes are displayed using a sculpted, three-dimensional look.</summary>
    <remarks>Note - This function has no purpose in 32 bit programs. It is included for backward compatibility with 16 bit applications only.</remarks>
  </Enable3dControls>
  <EnableAppVisualTheme>
    <summary>
      Enable or disable the applications support for visual themes.
    </summary>
    <param name="lEnable">
      An optional logical value. TRUE sets the support for visual themes on, FALSE sets this off.

      The default is TRUE.
    </param>
    <returns>
      TRUE if visual themes are enabled; otherwise, FALSE.
    </returns>
    <remarks>
      Visual themes are automatically enabled if version 6 of the common controls is loaded by using an application manifest.
    </remarks>
    <seealso cref="O:VOGUIClasses.Functions.IsThemeEnabled">IsThemeEnabled</seealso>
  </EnableAppVisualTheme>
  <EnableThemeDialogTexture>
    <exclude />


  </EnableThemeDialogTexture>
  <GetAppObject>
    <summary>
      Return the global App object for this application.
    </summary>
    <returns></returns>
    <remarks></remarks>
    <example>
      The following example terminates a dialog based application:
      <code language="X#">METHOD CancelButton() CLASS OrderDialog</code><code language="X#">
        SELF:EndDialog()
        GetAppObject():Quit()
      </code>
    </example>
    <seealso cref="T:VO.App">App Class</seealso>
    <seealso cref="O:VOGUIClasses.Functions.GetObjectByHandle">GetObjectByHandle</seealso>
  </GetAppObject>
  <GetFocusedObject>
    <summary>
      Return the object corresponding to the control or window that currently has input focus.
    </summary>
    <returns>
      The window or control object that currently has input focus.
    </returns>
    <remarks></remarks>
    <example>
      This example causes a beep if the object that currently has input focus is a MultiLineEdit control:
      <code language="X#">
        oObj := GetFocusedObject()
        IF oObj != NULL_OBJECT .AND. IsInstanceOf(oControl, #MultiLineEdit)
        MessageBeep(MB_ICONASTERISK)
        ENDIF
      </code>
    </example>
    <seealso cref="T:VO.Control">CLASS Control</seealso>
    <seealso cref="T:VO.Window">Class Window</seealso>
    <seealso cref="O:VOGUIClasses.Functions.GetAppObject">GetAppObject</seealso>
    <seealso cref="O:VOGUIClasses.Functions.GetObjectByHandle">GetObjectByHandle</seealso>
  </GetFocusedObject>
  <GetFrameWidth>
    <exclude />

  </GetFrameWidth>
  <GetObjectByHandle>
    <summary>
      Return the object associated with a given window handle.
    </summary>
    <param name="hwnd">The window handle.</param>
    <returns>
      The Window or Control object associated with the given window handle.
    </returns>
    <remarks></remarks>
    <example>
      This example gets the object associated with the control that currently has focus:
      <code language="X#">
        FUNCTION GetFocusedObject() AS OBJECT
        LOCAL oCtrl AS OBJECT
        oCtrl := GetObjectByHandle(GetFocus())
        IF IsInstanceOf(oCtrl, #Control)
        RETURN oCtrl
        ELSE
        RETURN NULL_OBJECT
        ENDIF
      </code>
    </example>
    <seealso cref="T:VO.Control">CLASS Control</seealso>
    <seealso cref="T:VO.Window">Class Window</seealso>
    <seealso cref="O:VOGUIClasses.Functions.GetAppObject">GetAppObject</seealso>
    <seealso cref="O:VOGUIClasses.Functions.GetFocusedObject">GetAppObject</seealso>
  </GetObjectByHandle>
  <GetThemeAppProperties>
    <summary>
      Retrieves the property flags that control how visual styles are applied in the current application
    </summary>
    <returns>
      STAP_ALLOW_NONCLIENT
      Specifies that the nonclient areas of application windows have visual styles applied.
      STAP_ALLOW_CONTROLS
      Specifies that controls in application windows have visual styles applied.
      STAP_ALLOW_WEBCONTENT
      Specifies that all web content displayed in an application is rendered using visual styles.




    </returns>
    <remarks></remarks>
    <example></example>
  </GetThemeAppProperties>
  <IsAltPressed>
    <summary>Get the current state of the Alt key.</summary>
  </IsAltPressed>
  <IsAppThemed>
    <summary>Return the theme setting for the current application.</summary>
  </IsAppThemed>
  <IsControlPressed>
    <summary>Get the current state of the Ctrl key.</summary>
  </IsControlPressed>
  <IsCtl3dEnabled>
    <exclude />
  </IsCtl3dEnabled>
  <IsShiftPressed>
    <summary>Get the current state of the Shift key.</summary>
  </IsShiftPressed>
  <IsThemeEnabled>
    <summary>
      Determine if visual theme support is enabled.
    </summary>
    <returns>
      TRUE if visual theme support is enabled; otherwise, FALSE.
    </returns>
    <seealso cref="O:VOGUIClasses.Functions.EnableAppVisualTheme">EnableAppVisualTheme</seealso>
  </IsThemeEnabled>
  <VerifyThemeState>
    <summary>Verifies the current theme state and sets the ThemeEnabled flag.</summary>
    <returns>The function returns the current value of the ThemeEnabled flag like the function IsThemeEnabled().</returns>
  </VerifyThemeState>
  <VOInternetClasses.Functions>
    <summary>
      This compiler generated class contains all the functions, globals and defines that are defined in the VOInternetClasses assembly.
    </summary>
  </VOInternetClasses.Functions>
  <VORDDClasses.Functions>
    <summary>
      This compiler generated class contains all the functions, globals and defines that are defined in the VORDDClasses assembly.
    </summary>
  </VORDDClasses.Functions>
  <VORDDClasses.Functions.DBFDebug>
    <exclude />
  </VORDDClasses.Functions.DBFDebug>
  <VORDDClasses.Functions.DbGetDefaultLockMode>
    <summary>Get/Set the default locking mode for the DbServer class</summary>
    <param name="dwLockMode">The new locking mode. The default = ccOptimistic</param>
    <returns>The previous locking mode</returns>

  </VORDDClasses.Functions.DbGetDefaultLockMode>
  <VORDDClasses.Functions.DbSetDefaultLockMode>
    <summary>Get the default locking mode for the DbServer class</summary>
    <returns>The current locking mode</returns>
  </VORDDClasses.Functions.DbSetDefaultLockMode>
  <VORDDClasses.Functions.DbSetRestoreWorkarea>
    <summary>Get/Set the flag that determines if DbServer operations restore the current workarea </summary>

  </VORDDClasses.Functions.DbSetRestoreWorkarea>
  <VOSystemClasses.Functions>
    <summary>
      This compiler generated class contains all the functions, globals and defines that are defined in the VOSystemClasses assembly.
    </summary>
  </VOSystemClasses.Functions>
  <XSharp.ChildWinForm.ctor>
    <exclude />
  </XSharp.ChildWinForm.ctor>
  <XSharp.ChildWinForm.Activate>
    <exclude />
  </XSharp.ChildWinForm.Activate>
  <XSharp.ChildWinForm.Close>
    <exclude />
  </XSharp.ChildWinForm.Close>
  <XSharp.ChildWinForm.DeActivate>
    <exclude />
  </XSharp.ChildWinForm.DeActivate>
  <XSharp.ChildWinForm.Resize>
    <exclude />
  </XSharp.ChildWinForm.Resize>
  <XSharp.ChildWinForm.WinForm>
    <exclude />
  </XSharp.ChildWinForm.WinForm>
  <XSharp.VOWinFormApp.ctor>
    <exclude />
  </XSharp.VOWinFormApp.ctor>
  <XSharp.VOWinFormApp.BeforeDispatch>
    <exclude />
  </XSharp.VOWinFormApp.BeforeDispatch>
  <XSharp.VOWinFormApp.RegisterWinForm>
    <exclude />
  </XSharp.VOWinFormApp.RegisterWinForm>
  <XSharp.VOWinFormApp.UnRegisterWinForm>
    <exclude />
  </XSharp.VOWinFormApp.UnRegisterWinForm>
  <XSharp.WinFormVOWindow.ctor>
    <exclude />
  </XSharp.WinFormVOWindow.ctor>
  <XSharp.WinFormVOWindow.CloseHostForm>
    <exclude />
  </XSharp.WinFormVOWindow.CloseHostForm>
  <XSharp.WinFormVOWindow.Initialize>
    <exclude />
  </XSharp.WinFormVOWindow.Initialize>
  <XSharp.WinFormVOWindow.VOWindowHost>
    <exclude />
  </XSharp.WinFormVOWindow.VOWindowHost>
  <XSharp.WinFormVOWindowHost.ctor>
    <exclude />
  </XSharp.WinFormVOWindowHost.ctor>
  <XSharp.WinFormVOWindowHost.ctor>
    <exclude />
  </XSharp.WinFormVOWindowHost.ctor>
  <XSharp.WinFormVOWindowHost.ctor>
    <exclude />
  </XSharp.WinFormVOWindowHost.ctor>
  <XSharp.WinFormVOWindowHost.AdjustVOWindow>
    <exclude />
  </XSharp.WinFormVOWindowHost.AdjustVOWindow>
  <XSharp.WinFormVOWindowHost.ClassesNeedingTranslateTabToArrow>
    <exclude />
  </XSharp.WinFormVOWindowHost.ClassesNeedingTranslateTabToArrow>
  <XSharp.WinFormVOWindowHost.Close>
    <exclude />
  </XSharp.WinFormVOWindowHost.Close>
  <XSharp.WinFormVOWindowHost.Focus>
    <exclude />
  </XSharp.WinFormVOWindowHost.Focus>
  <XSharp.WinFormVOWindowHost.HostingControl>
    <exclude />
  </XSharp.WinFormVOWindowHost.HostingControl>
  <XSharp.WinFormVOWindowHost.IsHostingDataWindow>
    <exclude />
  </XSharp.WinFormVOWindowHost.IsHostingDataWindow>
  <XSharp.WinFormVOWindowHost.ProcessDialogKey>
    <exclude />
  </XSharp.WinFormVOWindowHost.ProcessDialogKey>
  <XSharp.WinFormVOWindowHost.VOWindow>
    <exclude />
  </XSharp.WinFormVOWindowHost.VOWindow>
  <XSharp.WinFormVOWindowHost.VOWindowClassName>
    <exclude />
  </XSharp.WinFormVOWindowHost.VOWindowClassName>

</doc>
